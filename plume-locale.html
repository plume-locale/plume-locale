<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Outil d'Écriture - Organisation par Chapitres</title>
    <link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:wght@300;400;600;700&family=Noto+Serif+JP:wght@300;500;700&family=Source+Code+Pro:wght@400;500&display=swap" rel="stylesheet">
    <!-- Export Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/docx/7.8.2/docx.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <!-- IndexedDB wrapper for easier usage -->
    <script src="https://cdn.jsdelivr.net/npm/idb@7/build/umd.js"></script>
    <!-- Lucide Icons - Modern line icons -->
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.min.js"></script>
    <style>
        :root {
            /* Thème épuré blanc */
            --bg-primary: #ffffff;
            --bg-secondary: #f8f9fa;
            --bg-tertiary: #f0f1f3;
            --bg-accent: #2a2622;
            --text-primary: #1a1a1a;
            --text-secondary: #666666;
            --text-muted: #999999;
            --border-color: #e0e0e0;
            
            /* Couleur principale (orange) */
            --primary-color: #ff8c42;
            --primary-hover: #ff7629;
            
            /* Touches de couleur */
            --accent-red: #ff6b6b;
            --accent-gold: #ffd93d;
            --accent-blue: #4a9eff;
            --accent-green: #51cf66;
            --accent-purple: #a78bfa;
            
            --shadow: rgba(0, 0, 0, 0.08);
            
            /* Revision colors */
            --highlight-yellow: rgba(255, 235, 59, 0.4);
            --highlight-green: rgba(76, 175, 80, 0.3);
            --highlight-blue: rgba(33, 150, 243, 0.3);
            --highlight-red: rgba(244, 67, 54, 0.3);
            --highlight-purple: rgba(156, 39, 176, 0.3);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: 'Crimson Pro', serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
        }

        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        
        .app-header {
            flex-shrink: 0;
            height: 60px;
        }
        
        .app-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        
        .sidebar {
            flex-shrink: 0;
            width: 350px;
        }
        
        .sidebar-versions {
            flex-shrink: 0;
            width: 280px;
        }
        
        .sidebar-versions.hidden {
            display: none;
        }
        
        .editor-container {
            flex: 1;
            overflow: auto;
            min-height: 0;
        }
        
        /* Top Header */
        .app-header {
            background: var(--bg-primary);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            padding: 0 2rem;
            gap: 2rem;
            position: relative;
            z-index: 1000;
            box-shadow: 0 1px 3px var(--shadow);
            overflow: hidden;
        }
        
        .app-logo {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-size: 1.3rem;
            font-weight: 600;
            color: var(--accent-blue);
            font-family: 'Noto Serif JP', serif;
            white-space: nowrap;
            flex-shrink: 0;
        }
        
        .app-logo-icon {
            font-size: 1.5rem;
        }
        
        .header-nav {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex: 1;
            overflow-x: auto;
            overflow-y: hidden;
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE/Edge */
        }
        
        .header-nav::-webkit-scrollbar {
            display: none; /* Chrome/Safari */
        }
        
        .nav-group {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            padding-right: 1rem;
            border-right: 1px solid var(--border-color);
            flex-shrink: 0;
        }
        
        .nav-group:last-child {
            border-right: none;
        }
        
        .nav-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 0.25rem;
            padding: 0.5rem 0.5rem;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-family: 'Crimson Pro', serif;
            font-size: 0.7rem;
            border-radius: 8px;
            transition: all 0.2s ease;
            white-space: nowrap;
            flex-shrink: 0;
            min-width: 60px;
        }
        
        .nav-btn:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }
        
        .nav-btn.active {
            background: var(--primary-color);
            color: white;
            font-weight: 600;
        }
        
        .nav-btn-icon {
            font-size: 1.3rem;
            line-height: 1;
        }
        
        /* Lucide Icons Styling */
        .nav-btn-icon [data-lucide],
        .mobile-nav-item-icon [data-lucide],
        .header-action-btn [data-lucide],
        [data-lucide] {
            width: 18px;
            height: 18px;
            stroke-width: 1.75;
            vertical-align: middle;
        }
        
        .nav-btn-icon [data-lucide] {
            width: 20px;
            height: 20px;
        }
        
        .mobile-nav-item-icon [data-lucide] {
            width: 22px;
            height: 22px;
        }
        
        .header-action-btn [data-lucide] {
            width: 18px;
            height: 18px;
        }
        
        .app-logo-icon [data-lucide] {
            width: 24px;
            height: 24px;
            stroke: var(--primary-color);
        }
        
        .modal-title [data-lucide] {
            width: 22px;
            height: 22px;
            vertical-align: middle;
            margin-right: 8px;
        }
        
        .mobile-nav-section-title [data-lucide] {
            width: 16px;
            height: 16px;
            vertical-align: middle;
            margin-right: 6px;
        }
        
        .nav-btn-text {
            font-size: 0.7rem;
            line-height: 1;
        }
        
        .header-actions {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-left: auto;
            flex-shrink: 0;
        }
        
        .header-action-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 36px;
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            cursor: pointer;
            font-size: 1.1rem;
            border-radius: 4px;
            transition: all 0.2s ease;
        }
        
        .header-action-btn:hover:not(:disabled) {
            background: var(--accent-gold);
            color: white;
            border-color: var(--accent-gold);
        }
        
        .header-action-btn.active {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }
        
        .header-action-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        /* Sidebar Navigation */
        .sidebar {
            background: var(--bg-secondary);
            border-right: 2px solid var(--border-color);
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
        }
        
        /* Sidebar Versions (pour les versions de scènes) */
        .sidebar-versions {
            background: var(--bg-secondary);
            border-right: 2px solid var(--border-color);
            border-left: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-width: 250px;
            width: 280px;
        }
        
        .sidebar-versions.hidden {
            display: none;
            min-width: 0;
            width: 0;
        }
        
        .sidebar-versions-header {
            padding: 1rem;
            border-bottom: 1px solid var(--border-color);
            background: var(--bg-secondary);
            flex-shrink: 0;
        }
        
        .sidebar-versions-title {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.5rem;
        }
        
        .sidebar-versions-title h3 {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .sidebar-versions-toggle {
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            padding: 0.25rem;
            font-size: 1rem;
            transition: color 0.2s;
        }
        
        .sidebar-versions-toggle:hover {
            color: var(--text-primary);
        }
        
        .sidebar-versions-scene {
            font-size: 0.75rem;
            color: var(--text-muted);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .sidebar-versions-actions {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--border-color);
            background: var(--bg-primary);
            flex-shrink: 0;
        }
        
        .btn-new-version {
            width: 100%;
            padding: 0.6rem 1rem;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 6px;
            font-family: 'Crimson Pro', serif;
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        
        .btn-new-version:hover {
            background: var(--primary-hover);
            transform: translateY(-1px);
        }
        
        .sidebar-versions-list {
            flex: 1;
            overflow-y: auto;
            padding: 0.5rem;
        }
        
        .version-card {
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }
        
        .version-card:hover {
            border-color: var(--primary-color);
            background: rgba(255, 140, 66, 0.05);
        }
        
        .version-card.active {
            border-color: var(--primary-color);
            background: rgba(255, 140, 66, 0.1);
            box-shadow: 0 0 0 3px rgba(255, 140, 66, 0.15);
        }
        
        .version-card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.5rem;
        }
        
        .version-card-number {
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--primary-color);
        }
        
        .version-card-actions {
            display: flex;
            gap: 0.25rem;
            opacity: 1;
        }
        
        .version-card:hover .version-card-actions {
            opacity: 1;
        }
        
        .version-card-btn {
            background: var(--bg-tertiary);
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            padding: 0.35rem;
            font-size: 0.8rem;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        .version-card-btn:hover {
            background: var(--bg-primary);
            color: var(--text-primary);
        }
        
        .version-card-btn.delete:hover {
            background: rgba(255, 107, 107, 0.1);
            color: var(--accent-red);
        }
        
        .version-card-date {
            font-size: 0.75rem;
            color: var(--text-muted);
        }
        
        .version-card-stats {
            font-size: 0.7rem;
            color: var(--text-secondary);
            margin-top: 0.25rem;
        }
        
        .version-card-label {
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-top: 0.5rem;
            font-style: italic;
        }
        
        /* Version finale */
        .version-card.final {
            border-color: var(--accent-gold);
            background: rgba(255, 217, 61, 0.1);
        }
        
        .version-card.final .version-card-number::after {
            content: ' ⭐';
        }
        
        .version-card-final-badge {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            background: var(--accent-gold);
            color: var(--bg-accent);
            font-size: 0.65rem;
            font-weight: 700;
            padding: 0.15rem 0.5rem;
            border-radius: 10px;
            margin-left: 0.5rem;
            text-transform: uppercase;
        }
        
        .version-card-btn.final {
            color: var(--text-muted);
        }
        
        .version-card-btn.final:hover {
            background: rgba(255, 217, 61, 0.2);
            color: var(--accent-gold);
        }
        
        .version-card-btn.final.is-final {
            color: var(--accent-gold);
        }
        
        /* Diff Viewer Modal */
        .diff-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.6);
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 2rem;
        }
        
        .diff-modal-content {
            background: var(--bg-primary);
            border-radius: 12px;
            width: 100%;
            max-width: 1200px;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        
        .diff-modal-header {
            padding: 1.25rem 1.5rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-shrink: 0;
        }
        
        .diff-modal-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .diff-modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            color: var(--text-muted);
            cursor: pointer;
            padding: 0.25rem;
            line-height: 1;
            transition: color 0.2s;
        }
        
        .diff-modal-close:hover {
            color: var(--text-primary);
        }
        
        .diff-toolbar {
            padding: 0.75rem 1.5rem;
            border-bottom: 1px solid var(--border-color);
            background: var(--bg-secondary);
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 1rem;
            flex-shrink: 0;
        }
        
        .diff-stats {
            display: flex;
            gap: 1rem;
            font-size: 0.85rem;
        }
        
        .diff-stat {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }
        
        .diff-stat.added {
            color: #2e7d32;
        }
        
        .diff-stat.removed {
            color: #c62828;
        }
        
        .diff-stat.changed {
            color: #f57c00;
        }
        
        .diff-view-toggle {
            display: flex;
            gap: 0.25rem;
        }
        
        .diff-view-btn {
            padding: 0.4rem 0.8rem;
            border: 1px solid var(--border-color);
            background: var(--bg-primary);
            color: var(--text-secondary);
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .diff-view-btn:first-child {
            border-radius: 4px 0 0 4px;
        }
        
        .diff-view-btn:last-child {
            border-radius: 0 4px 4px 0;
        }
        
        .diff-view-btn.active {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }
        
        .diff-nav-buttons {
            display: flex;
            gap: 0.5rem;
        }
        
        .diff-nav-btn {
            padding: 0.4rem 0.8rem;
            border: 1px solid var(--border-color);
            background: var(--bg-primary);
            color: var(--text-secondary);
            font-size: 0.8rem;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        .diff-nav-btn:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        .diff-content {
            flex: 1;
            overflow: auto;
            padding: 1rem;
        }
        
        /* Vue unifiée */
        .diff-unified {
            font-family: 'Crimson Pro', serif;
            font-size: 1rem;
            line-height: 1.8;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        
        .diff-line {
            padding: 0.1rem 0.5rem;
            margin: 0 -0.5rem;
            border-radius: 3px;
        }
        
        .diff-line.added {
            background: rgba(46, 125, 50, 0.15);
        }
        
        .diff-line.removed {
            background: rgba(198, 40, 40, 0.15);
            text-decoration: line-through;
            opacity: 0.7;
        }
        
        .diff-word {
            padding: 0.1rem 0.2rem;
            border-radius: 2px;
        }
        
        .diff-word.added {
            background: rgba(46, 125, 50, 0.3);
            color: #1b5e20;
        }
        
        .diff-word.removed {
            background: rgba(198, 40, 40, 0.3);
            color: #b71c1c;
            text-decoration: line-through;
        }
        
        /* Vue côte à côte */
        .diff-side-by-side {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            height: 100%;
        }
        
        .diff-side {
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .diff-side-header {
            padding: 0.75rem 1rem;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            font-weight: 600;
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .diff-side-header.old {
            color: #c62828;
        }
        
        .diff-side-header.new {
            color: #2e7d32;
        }
        
        .diff-side-content {
            flex: 1;
            overflow: auto;
            padding: 1rem;
            font-family: 'Crimson Pro', serif;
            font-size: 1rem;
            line-height: 1.8;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        
        .diff-paragraph {
            margin-bottom: 1rem;
            padding: 0.5rem;
            border-radius: 4px;
            transition: background 0.2s;
        }
        
        .diff-paragraph.modified {
            background: rgba(255, 152, 0, 0.1);
            border-left: 3px solid #ff9800;
        }
        
        .diff-paragraph.added {
            background: rgba(46, 125, 50, 0.1);
            border-left: 3px solid #4caf50;
        }
        
        .diff-paragraph.removed {
            background: rgba(198, 40, 40, 0.1);
            border-left: 3px solid #f44336;
            text-decoration: line-through;
            opacity: 0.6;
        }
        
        .diff-highlight {
            cursor: pointer;
        }
        
        .diff-highlight:hover {
            filter: brightness(0.95);
        }
        
        .diff-empty-state {
            text-align: center;
            padding: 3rem;
            color: var(--text-muted);
        }
        
        .diff-empty-state-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }
        
        /* Version selector dans le diff */
        .diff-version-selector {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.85rem;
        }
        
        .diff-version-select {
            padding: 0.4rem 0.8rem;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background: var(--bg-primary);
            color: var(--text-primary);
            font-size: 0.85rem;
            cursor: pointer;
        }
        
        /* Bouton comparer dans version card */
        .version-card-btn.compare {
            color: #1976d2;
        }
        
        .version-card-btn.compare:hover {
            background: rgba(25, 118, 210, 0.1);
            color: #1565c0;
        }
        
        .versions-empty {
            text-align: center;
            padding: 2rem 1rem;
            color: var(--text-muted);
        }
        
        .versions-empty-icon {
            font-size: 2.5rem;
            margin-bottom: 0.75rem;
            opacity: 0.5;
        }
        
        .versions-empty-text {
            font-size: 0.85rem;
            line-height: 1.5;
        }
        
        .versions-no-scene {
            text-align: center;
            padding: 3rem 1rem;
            color: var(--text-muted);
        }
        
        .versions-no-scene-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
            opacity: 0.3;
        }
        
        .versions-no-scene-text {
            font-size: 0.9rem;
            line-height: 1.6;
        }
        
        /* Poignée de redimensionnement */
        .sidebar-resize-handle {
            position: absolute;
            top: 0;
            right: 0;
            width: 8px;
            height: 100%;
            cursor: ew-resize;
            z-index: 3000;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }
        
        .sidebar-resize-handle:hover {
            background: rgba(212, 175, 55, 0.1);
        }
        
        .sidebar-resize-handle:active {
            background: rgba(212, 175, 55, 0.2);
        }
        
        .resize-handle-line {
            width: 3px;
            height: 40px;
            background: var(--border-color);
            border-radius: 2px;
            transition: all 0.2s;
        }
        
        .sidebar-resize-handle:hover .resize-handle-line {
            background: var(--accent-gold);
            height: 60px;
        }


        .sidebar-header {
            padding: 1.5rem 1rem 1rem;
            border-bottom: 1px solid var(--border-color);
            position: relative;
            z-index: 2600;
            flex-shrink: 0;
        }

        .search-container {
            position: relative;
            margin-bottom: 1rem;
            z-index: 10;
        }

        .search-input {
            width: 100%;
            padding: 0.75rem 2.5rem 0.75rem 1rem;
            border: 1px solid var(--border-color);
            background: var(--bg-primary);
            font-family: 'Crimson Pro', serif;
            font-size: 0.9rem;
            color: var(--text-primary);
            border-radius: 2px;
            outline: none;
            transition: all 0.2s ease;
        }

        .search-input:focus {
            border-color: var(--accent-gold);
            box-shadow: 0 0 0 2px rgba(212, 175, 55, 0.1);
        }

        .search-icon {
            position: absolute;
            right: 0.75rem;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-muted);
            font-size: 1.2rem;
            pointer-events: none;
        }

        .search-results {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--bg-primary);
            border: 2px solid var(--accent-gold);
            border-radius: 4px;
            max-height: 400px;
            overflow-y: auto;
            z-index: 20;
            box-shadow: 0 4px 16px var(--shadow);
            margin-top: 0.5rem;
            display: none;
        }

        .search-results.active {
            display: block;
        }

        .search-result-item {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .search-result-item:last-child {
            border-bottom: none;
        }

        .search-result-item:hover {
            background: rgba(212, 175, 55, 0.1);
        }

        .search-result-type {
            font-size: 0.7rem;
            padding: 0.2rem 0.5rem;
            background: var(--accent-gold);
            color: var(--bg-primary);
            border-radius: 2px;
            margin-bottom: 0.5rem;
            display: inline-block;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            font-weight: 600;
        }

        .search-result-title {
            font-size: 0.9rem;
            font-weight: 600;
            margin-bottom: 0.25rem;
            color: var(--text-primary);
        }

        .search-result-path {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-bottom: 0.5rem;
        }

        .search-result-preview {
            font-size: 0.8rem;
            color: var(--text-secondary);
            line-height: 1.4;
        }

        .search-highlight {
            background: rgba(212, 175, 55, 0.3);
            font-weight: 600;
            padding: 0 2px;
        }

        .search-no-results {
            padding: 2rem;
            text-align: center;
            color: var(--text-muted);
            font-style: italic;
        }

        .view-tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .view-tab {
            flex: 1;
            padding: 0.5rem;
            border: 1px solid var(--border-color);
            background: var(--bg-primary);
            color: var(--text-secondary);
            cursor: pointer;
            font-family: 'Crimson Pro', serif;
            font-size: 0.85rem;
            font-weight: 500;
            transition: all 0.2s ease;
            border-radius: 2px;
            text-align: center;
        }

        .view-tab:hover {
            background: var(--bg-secondary);
        }

        .view-tab.active {
            background: var(--accent-gold);
            color: var(--bg-primary);
            border-color: var(--accent-gold);
        }

        .project-title {
            font-family: 'Noto Serif JP', serif;
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
            letter-spacing: 0.02em;
        }

        .project-stats {
            font-size: 0.85rem;
            color: var(--text-muted);
            font-weight: 300;
            display: flex;
            gap: 1rem;
        }

        .chapters-list {
            flex: 1;
            overflow-y: auto;
            padding: 1rem 0;
            position: relative;
            z-index: 1;
        }

        .database-list {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
            position: relative;
            z-index: 1;
        }
        
        /* Treeview compact style */
        .treeview-group {
            margin-bottom: 0.25rem;
        }
        
        .treeview-header {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.4rem 0.5rem;
            cursor: pointer;
            border-radius: 4px;
            transition: background 0.15s;
            user-select: none;
        }
        
        .treeview-header:hover {
            background: var(--bg-secondary);
        }
        
        .treeview-chevron {
            width: 14px;
            height: 14px;
            color: var(--text-muted);
            flex-shrink: 0;
        }
        
        .treeview-label {
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.03em;
            flex: 1;
        }
        
        .treeview-count {
            font-size: 0.7rem;
            color: var(--text-muted);
            background: var(--bg-secondary);
            padding: 0.1rem 0.4rem;
            border-radius: 10px;
        }
        
        .treeview-children {
            margin-left: 0.5rem;
            border-left: 1px solid var(--border-color);
            padding-left: 0.5rem;
            overflow: hidden;
            transition: max-height 0.2s ease, opacity 0.2s ease;
        }
        
        .treeview-children.collapsed {
            display: none;
        }
        
        .treeview-item {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            padding: 0.35rem 0.5rem;
            cursor: pointer;
            border-radius: 4px;
            transition: background 0.15s;
            position: relative;
        }
        
        .treeview-item:hover {
            background: var(--bg-secondary);
        }
        
        .treeview-item:hover .treeview-item-delete {
            opacity: 1;
        }
        
        .treeview-item-icon {
            font-size: 0.85rem;
            flex-shrink: 0;
            width: 18px;
            text-align: center;
        }
        
        .treeview-item-label {
            font-size: 0.85rem;
            color: var(--text-primary);
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .treeview-item-delete {
            opacity: 0;
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            padding: 0 0.25rem;
            font-size: 1rem;
            line-height: 1;
            transition: opacity 0.15s, color 0.15s;
        }
        
        .treeview-item-delete:hover {
            color: var(--accent-red);
        }
        
        .database-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 1rem;
            margin-bottom: 0.75rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .database-card:hover {
            border-color: var(--accent-gold);
            background: rgba(212, 175, 55, 0.05);
            transform: translateX(2px);
        }

        /* Acts Hierarchy */
        .act-group {
            margin-bottom: 0.25rem;
        }

        .act-header {
            padding: 0.3rem 0.5rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.3rem;
            transition: all 0.15s ease;
            position: relative;
            background: var(--bg-secondary);
            border-left: 3px solid var(--accent-red);
            border-radius: 0 4px 4px 0;
            font-weight: 600;
            font-size: 0.85rem;
        }

        .act-header:hover {
            background: var(--bg-tertiary);
        }

        .act-header.active {
            background: var(--accent-red);
            color: white;
        }

        .act-icon {
            font-size: 0.65rem;
            transition: transform 0.2s ease;
            color: var(--accent-red);
            width: 12px;
            text-align: center;
        }

        .act-header.active .act-icon {
            color: white;
        }

        .act-icon.expanded {
            transform: rotate(90deg);
        }

        .act-title {
            flex: 1;
            font-size: 0.8rem;
            font-family: 'Noto Serif JP', serif;
            letter-spacing: 0.01em;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .act-count {
            font-size: 0.65rem;
            opacity: 0.7;
            font-family: 'Source Code Pro', monospace;
        }

        .act-chapters {
            display: none;
            padding-left: 0.25rem;
        }

        .act-chapters.visible {
            display: block;
        }

        .chapter-group {
            margin-bottom: 0.1rem;
        }

        .chapter-header {
            padding: 0.25rem 0.5rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.3rem;
            transition: all 0.15s ease;
            position: relative;
            border-radius: 4px;
            font-size: 0.8rem;
        }

        .chapter-header:hover {
            background: var(--bg-secondary);
        }

        .chapter-header.active {
            background: var(--primary-color);
            color: white;
        }

        .chapter-icon {
            font-size: 0.6rem;
            transition: transform 0.2s ease;
            color: var(--text-muted);
            width: 10px;
            text-align: center;
        }

        .chapter-header.active .chapter-icon {
            color: white;
        }

        .chapter-icon.expanded {
            transform: rotate(90deg);
        }

        .chapter-title {
            flex: 1;
            font-size: 0.8rem;
            font-weight: 600;
            letter-spacing: 0.01em;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .chapter-count {
            font-size: 0.65rem;
            opacity: 0.7;
            font-family: 'Source Code Pro', monospace;
        }

        .scenes-list {
            display: none;
            padding-left: 0.75rem;
        }

        .scenes-list.visible {
            display: block;
        }

        .scene-item {
            padding: 0.2rem 0.5rem;
            cursor: pointer;
            font-size: 0.78rem;
            transition: all 0.15s ease;
            border-left: 2px solid transparent;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .scene-item:hover {
            background: var(--bg-secondary);
            border-left-color: var(--accent-red);
        }

        .scene-item.active {
            background: rgba(196, 69, 54, 0.1);
            border-left-color: var(--accent-red);
            color: var(--text-primary);
            font-weight: 500;
        }
        
        .scene-synopsis {
            display: none;
            font-size: 0.7rem;
            color: var(--text-muted);
            font-style: italic;
            line-height: 1.2;
            margin-top: 0.1rem;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            opacity: 0.8;
        }
        
        .scene-item:hover .scene-synopsis {
            display: block;
            opacity: 1;
        }
        
        /* Tree collapse toolbar */
        .tree-collapse-toolbar {
            display: flex;
            gap: 0.25rem;
            padding: 0.35rem 0.5rem;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
        }
        
        .tree-collapse-btn {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.2rem 0.5rem;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 3px;
            font-size: 0.7rem;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.15s ease;
        }
        
        .tree-collapse-btn:hover {
            background: var(--bg-tertiary);
            border-color: var(--primary-color);
            color: var(--primary-color);
        }

        .sidebar-actions {
            padding: 0.75rem 1rem;
            border-top: 1px solid var(--border-color);
            background: var(--bg-primary);
            display: flex;
            gap: 0.4rem;
            position: relative;
            z-index: 1;
            flex-shrink: 0;
        }
        
        .sidebar-actions .btn {
            flex: 1;
            padding: 0.5rem 0.25rem;
            font-size: 0.75rem;
            white-space: nowrap;
        }

        /* Scene Tools Bar */
        .scene-tools {
            display: flex;
            gap: 0.5rem;
            padding: 0.75rem 1rem;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
        }
        
        .scene-tool-btn {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            padding: 0.5rem 0.75rem;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-secondary);
            font-size: 0.8rem;
            font-family: 'Crimson Pro', serif;
            cursor: pointer;
            transition: all 0.2s ease;
            flex: 1;
            justify-content: center;
        }
        
        .scene-tool-btn:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        .scene-tool-btn.active {
            background: var(--primary-color);
            border-color: var(--primary-color);
            color: white;
        }
        
        .scene-tool-btn [data-lucide] {
            width: 16px;
            height: 16px;
        }
        
        .scene-tool-badge {
            background: var(--accent-red);
            color: white;
            font-size: 0.65rem;
            padding: 0.1rem 0.4rem;
            border-radius: 10px;
            font-weight: 600;
            margin-left: 0.25rem;
        }

        /* Main Editor */
        .editor-container {
            display: flex;
            flex-direction: column;
            background: var(--bg-primary);
            height: calc(100vh - 60px);
            overflow: hidden;
        }

        .editor-fixed-top {
            flex-shrink: 0;
            z-index: 100;
        }

        .editor-header {
            padding: 2rem 3rem 1rem;
            border-bottom: 1px solid var(--border-color);
            background: var(--bg-primary);
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }

        .editor-breadcrumb {
            font-size: 0.85rem;
            color: var(--text-muted);
            margin-bottom: 0.75rem;
            font-weight: 300;
        }

        .editor-title {
            font-family: 'Noto Serif JP', serif;
            font-size: 2rem;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
            letter-spacing: 0.01em;
        }

        .editor-meta {
            display: flex;
            gap: 2rem;
            font-size: 0.85rem;
            color: var(--text-muted);
            font-family: 'Source Code Pro', monospace;
        }
        
        .editor-synopsis {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-top: 0.75rem;
            padding-top: 0.75rem;
            border-top: 1px dashed var(--border-color);
        }
        
        .synopsis-label {
            display: flex;
            align-items: center;
            gap: 0.3rem;
            font-size: 0.8rem;
            color: var(--text-muted);
            white-space: nowrap;
        }
        
        .synopsis-input {
            flex: 1;
            min-width: 200px;
            padding: 0.4rem 0.6rem;
            font-size: 0.85rem;
            font-style: italic;
            color: var(--text-secondary);
            background: transparent;
            border: 1px solid transparent;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        .synopsis-input:hover {
            background: var(--bg-secondary);
            border-color: var(--border-color);
        }
        
        .synopsis-input:focus {
            outline: none;
            background: var(--bg-primary);
            border-color: var(--primary-color);
            font-style: normal;
        }
        
        .synopsis-input::placeholder {
            color: var(--text-muted);
            font-style: italic;
        }

        .editor-toolbar {
            display: flex;
            gap: 8px;
            padding: 8px 16px;
            border-bottom: 1px solid var(--border-color);
            background: white;
            flex-wrap: wrap;
            align-items: center;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            overflow: visible;
        }

        .editor-toolbar::-webkit-scrollbar {
            display: none;
        }

        .links-panel-toggle {
            display: none;
            width: 100%;
            padding: 0.5rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 0.9rem;
            color: var(--text-primary);
            cursor: pointer;
            text-align: center;
            font-weight: 600;
        }

        .links-panel-toggle:active {
            background: var(--accent-gold);
            color: white;
        }

        .links-panel-sticky {
            padding: 1rem 3rem;
            background: white;
            border-bottom: 1px solid var(--border-color);
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }

        .links-panel-sticky.hidden {
            display: none;
        }

        .editor-workspace {
            flex: 1 1 auto;
            overflow-y: scroll;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
        }

        .editor-content {
            max-width: 750px;
            margin: 0 auto;
            padding: 3rem;
        }

        .editor-textarea {
            width: 100%;
            min-height: 1200px;
            border: none;
            background: transparent;
            font-family: 'Crimson Pro', serif;
            font-size: 1.15rem;
            line-height: 1.8;
            color: var(--text-primary);
            outline: none;
            font-weight: 400;
        }

        .editor-textarea:focus {
            outline: none;
        }

        .editor-textarea::placeholder {
            color: var(--text-muted);
            font-style: italic;
        }

        /* Buttons */
        .btn {
            padding: 0.6rem 1.2rem;
            border: 1px solid var(--border-color);
            background: white;
            color: var(--text-primary);
            cursor: pointer;
            font-family: 'Crimson Pro', serif;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.2s ease;
            border-radius: 8px;
        }

        .btn:hover {
            background: var(--bg-secondary);
            border-color: var(--text-secondary);
        }

        .btn-primary {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }

        .btn-primary:hover {
            background: var(--primary-hover);
            border-color: var(--primary-hover);
        }

        .btn-small {
            padding: 0.4rem 0.8rem;
            font-size: 0.8rem;
        }

        .btn-icon {
            padding: 0.5rem;
            width: 32px;
            height: 32px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        /* Empty State */
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            text-align: center;
            padding: 3rem;
        }

        .empty-state-icon {
            font-size: 4rem;
            margin-bottom: 1.5rem;
            opacity: 0.3;
        }

        .empty-state-title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: var(--text-primary);
        }

        .empty-state-text {
            color: var(--text-muted);
            margin-bottom: 1.5rem;
            max-width: 400px;
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(42, 38, 34, 0.6);
            backdrop-filter: blur(4px);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: var(--bg-primary);
            padding: 2rem;
            border-radius: 4px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 8px 32px var(--shadow);
            border: 2px solid var(--border-color);
        }
        
        /* Modal overlay pour thèmes */
        .modal-overlay {
            display: flex;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(42, 38, 34, 0.85);
            backdrop-filter: blur(4px);
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 1rem;
            margin-bottom: 1.5rem;
            border-bottom: 2px solid var(--accent-gold);
        }
        
        .modal-header h2 {
            margin: 0;
            font-family: 'Noto Serif JP', serif;
        }
        
        .modal-close {
            background: transparent;
            border: none;
            font-size: 2rem;
            cursor: pointer;
            color: var(--text-muted);
            padding: 0.5rem;
            line-height: 1;
            transition: all 0.2s;
            border-radius: 4px;
            min-width: 44px;
            min-height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .modal-close:hover {
            color: var(--accent-red);
            background: rgba(196, 69, 54, 0.1);
        }

        .modal-close:active {
            transform: scale(0.95);
        }

        .modal-title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 1.5rem;
            font-family: 'Noto Serif JP', serif;
        }

        .form-group {
            margin-bottom: 1.5rem;
        }

        .form-label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: var(--text-secondary);
        }

        .form-input {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid var(--border-color);
            background: var(--bg-secondary);
            font-family: 'Crimson Pro', serif;
            font-size: 1rem;
            color: var(--text-primary);
            border-radius: 2px;
            outline: none;
            transition: all 0.2s ease;
        }

        .form-input:focus {
            border-color: var(--accent-gold);
            background: var(--bg-primary);
        }

        /* Detail View Styles (Characters, World, etc.) */
        .detail-view {
            padding: 2rem 3rem;
            max-width: 1400px;
            width: 100%;
            margin: 0 auto;
            height: 100vh;
            overflow-y: auto;
            box-sizing: border-box;
        }
        
        /* Character Sheet Styles */
        .character-sheet {
            padding: 1.5rem;
            height: 100%;
            overflow-y: auto;
        }
        
        /* Grille des sections - 2 colonnes sur desktop */
        .character-sections-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
        }
        
        /* Section qui prend toute la largeur */
        .character-section.full-width {
            grid-column: 1 / -1;
        }
        
        /* Responsive: 3 colonnes sur très grand écran */
        @media (min-width: 1600px) {
            .character-sections-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }
        
        /* Responsive: 4 colonnes sur écran ultra-large */
        @media (min-width: 2200px) {
            .character-sections-grid {
                grid-template-columns: repeat(4, 1fr);
            }
        }
        
        .character-sheet-header {
            display: flex;
            gap: 2rem;
            padding: 1.5rem;
            background: var(--bg-secondary);
            border-radius: 8px;
            margin-bottom: 1.5rem;
            border: 1px solid var(--border-color);
            position: relative;
        }
        
        .character-avatar {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--accent-red) 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5rem;
            color: white;
            flex-shrink: 0;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            border: 3px solid var(--bg-primary);
            box-shadow: 0 4px 12px var(--shadow);
        }
        
        .character-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .character-avatar:hover::after {
            content: '📷';
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
        }
        
        .character-header-info {
            flex: 1;
        }
        
        .character-header-info h2 {
            font-size: 1.6rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: var(--text-primary);
        }
        
        .character-header-info .character-meta {
            font-size: 0.9rem;
            color: var(--text-secondary);
            list-style: disc;
            margin-left: 1.2rem;
        }
        
        .character-header-actions {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 0.75rem;
        }
        
        .character-role-stars {
            display: flex;
            gap: 0.25rem;
        }
        
        .character-role-stars .star {
            font-size: 1.3rem;
            cursor: pointer;
            color: #ddd;
            transition: color 0.2s;
        }
        
        .character-role-stars .star.filled {
            color: var(--primary-color);
        }
        
        .character-role-stars .star:hover {
            color: var(--primary-hover);
        }
        
        .btn-write-beside {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 20px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .btn-write-beside:hover {
            border-color: var(--primary-color);
            color: var(--primary-color);
        }
        
        .character-close-btn {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--text-muted);
            line-height: 1;
        }
        
        .character-close-btn:hover {
            color: var(--accent-red);
        }
        
        .character-section {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow: hidden;
        }
        
        .character-section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1rem;
            background: var(--bg-secondary);
            cursor: pointer;
            user-select: none;
        }
        
        .character-section-header:hover {
            background: var(--bg-tertiary);
        }
        
        .character-section-title {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--accent-red);
        }
        
        .character-section-title::before {
            content: '';
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--primary-color);
        }
        
        .character-section-toggle {
            font-size: 0.9rem;
            color: var(--text-muted);
            transition: transform 0.2s;
        }
        
        .character-section.collapsed .character-section-toggle {
            transform: rotate(-90deg);
        }
        
        .character-section.collapsed .character-section-content {
            display: none;
        }
        
        .character-section-content {
            padding: 1rem;
        }
        
        .character-field-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 0.75rem;
            margin-bottom: 0.75rem;
        }
        
        .character-field-row:last-child {
            margin-bottom: 0;
        }
        
        .character-field {
            display: flex;
            flex-direction: column;
            gap: 0.3rem;
        }
        
        .character-field-label {
            font-size: 0.75rem;
            font-weight: 500;
            color: var(--accent-red);
            text-transform: capitalize;
        }
        
        .character-field input,
        .character-field textarea,
        .character-field select {
            padding: 0.5rem 0.6rem;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 0.9rem;
            font-family: inherit;
            background: var(--bg-primary);
            color: var(--text-primary);
            transition: border-color 0.2s;
        }
        
        .character-field input:focus,
        .character-field textarea:focus {
            outline: none;
            border-color: var(--primary-color);
        }
        
        .character-field textarea {
            resize: vertical;
            min-height: 60px;
        }
        
        .character-radio-group {
            display: flex;
            gap: 1rem;
            padding: 0.5rem 0;
        }
        
        /* Responsive: 1 colonne sur tablette/mobile */
        @media (max-width: 900px) {
            .character-sections-grid {
                grid-template-columns: 1fr;
            }
            
            .character-section.full-width {
                grid-column: 1;
            }
        }
        
        .character-radio-group label {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            cursor: pointer;
            font-size: 0.9rem;
        }
        
        .character-radio-group input[type="radio"] {
            accent-color: var(--primary-color);
        }
        
        /* Système de traits de caractère */
        .selected-traits-container {
            display: flex;
            flex-wrap: wrap;
            gap: 0.4rem;
            padding: 0.75rem;
            border: 2px solid var(--primary-color);
            border-radius: 8px;
            background: rgba(212, 175, 55, 0.05);
            min-height: 50px;
            align-items: flex-start;
        }
        
        .selected-trait {
            display: inline-flex;
            align-items: center;
            gap: 0.3rem;
            padding: 0.3rem 0.6rem;
            background: var(--primary-color);
            color: white;
            border-radius: 15px;
            font-size: 0.8rem;
            font-weight: 500;
        }
        
        .trait-remove {
            cursor: pointer;
            opacity: 0.7;
            font-size: 0.9rem;
            line-height: 1;
            margin-left: 0.2rem;
        }
        
        .trait-remove:hover {
            opacity: 1;
        }
        
        .no-traits {
            color: var(--text-muted);
            font-style: italic;
            font-size: 0.85rem;
        }
        
        .traits-categories {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-top: 1rem;
        }
        
        /* Sections principales de traits */
        .trait-section {
            border: 2px solid var(--border-color);
            border-radius: 8px;
            overflow: hidden;
            background: var(--bg-primary);
        }
        
        .trait-section-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.6rem 1rem;
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--accent-gold) 100%);
            cursor: pointer;
            user-select: none;
            font-size: 0.9rem;
            font-weight: 700;
            color: white;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .trait-section-header:hover {
            filter: brightness(1.1);
        }
        
        .trait-section-icon {
            font-size: 1.1rem;
            margin-right: 0.5rem;
        }
        
        .trait-section-toggle {
            font-size: 0.8rem;
            transition: transform 0.2s;
        }
        
        .trait-section.collapsed .trait-section-toggle {
            transform: rotate(-90deg);
        }
        
        .trait-section.collapsed .trait-section-content {
            display: none;
        }
        
        .trait-section-content {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
            gap: 0.5rem;
            padding: 0.75rem;
            background: var(--bg-secondary);
        }
        
        .trait-category {
            border: 1px solid var(--border-color);
            border-radius: 6px;
            overflow: hidden;
            background: var(--bg-primary);
        }
        
        .trait-category-header {
            display: flex;
            align-items: center;
            padding: 0.4rem 0.6rem;
            background: var(--bg-tertiary);
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .trait-category-icon {
            font-size: 0.9rem;
            margin-right: 0.3rem;
        }
        
        .trait-category-content {
            padding: 0.4rem;
            display: flex;
            flex-wrap: wrap;
            gap: 0.25rem;
        }
        
        .trait-option {
            padding: 0.2rem 0.45rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            font-size: 0.7rem;
            cursor: pointer;
            transition: all 0.15s;
            color: var(--text-secondary);
        }
        
        .trait-option:hover {
            background: var(--bg-tertiary);
            border-color: var(--primary-color);
            color: var(--text-primary);
        }
        
        .trait-option.selected {
            background: var(--primary-color);
            border-color: var(--primary-color);
            color: white;
        }
        
        /* Tags input */
        .character-tags-container {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            padding: 0.5rem;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            background: var(--bg-primary);
            min-height: 42px;
            align-items: center;
        }
        
        .character-tag {
            display: flex;
            align-items: center;
            gap: 0.3rem;
            padding: 0.25rem 0.6rem;
            background: var(--bg-tertiary);
            border-radius: 12px;
            font-size: 0.85rem;
        }
        
        .character-tag-remove {
            cursor: pointer;
            color: var(--text-muted);
            font-size: 0.9rem;
            line-height: 1;
        }
        
        .character-tag-remove:hover {
            color: var(--accent-red);
        }
        
        .character-tags-input {
            border: none !important;
            padding: 0.25rem !important;
            flex: 1;
            min-width: 120px;
            font-size: 0.9rem !important;
        }
        
        .character-tags-input:focus {
            outline: none;
        }
        
        /* Radar Chart */
        .character-radar-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 1rem;
        }
        
        .character-radar-canvas {
            max-width: 350px;
            max-height: 350px;
        }
        
        .character-radar-controls {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.75rem;
            width: 100%;
            max-width: 500px;
            margin-top: 1rem;
        }
        
        .radar-control {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .radar-control label {
            font-size: 0.85rem;
            min-width: 90px;
            color: var(--text-secondary);
        }
        
        .radar-control input[type="range"] {
            flex: 1;
            accent-color: var(--primary-color);
        }
        
        .radar-control .radar-value {
            font-size: 0.8rem;
            min-width: 24px;
            text-align: right;
            color: var(--text-muted);
        }
        
        /* Wealth slider */
        .wealth-slider-container {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .wealth-slider {
            flex: 1;
            height: 8px;
            -webkit-appearance: none;
            background: linear-gradient(to right, var(--bg-tertiary), var(--primary-color));
            border-radius: 4px;
            outline: none;
        }
        
        .wealth-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        }
        
        /* Timeline cards (Passé/Présent/Futur) */
        .character-timeline {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
        }
        
        .timeline-card {
            background: var(--bg-secondary);
            border-radius: 6px;
            padding: 1rem;
            border: 1px solid var(--border-color);
        }
        
        .timeline-card-title {
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--accent-red);
            margin-bottom: 0.5rem;
        }
        
        .timeline-card textarea {
            width: 100%;
            border: none;
            background: transparent;
            resize: none;
            font-family: inherit;
            font-size: 0.9rem;
            color: var(--text-secondary);
            min-height: 100px;
        }
        
        .timeline-card textarea:focus {
            outline: none;
        }
        
        /* Inventory items */
        .inventory-item {
            background: var(--bg-secondary);
            border-radius: 6px;
            padding: 1rem;
            margin-bottom: 0.75rem;
            border: 1px solid var(--border-color);
            position: relative;
        }
        
        .inventory-item-delete {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background: none;
            border: none;
            cursor: pointer;
            color: var(--text-muted);
            font-size: 1rem;
        }
        
        .inventory-item-delete:hover {
            color: var(--accent-red);
        }
        
        .inventory-add-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            padding: 0.75rem;
            border: 1px dashed var(--border-color);
            border-radius: 20px;
            background: transparent;
            cursor: pointer;
            color: var(--text-muted);
            font-size: 0.9rem;
            transition: all 0.2s;
            margin-top: 1rem;
        }
        
        .inventory-add-btn:hover {
            border-color: var(--primary-color);
            color: var(--primary-color);
        }
        
        /* Side-by-side mode */
        .editor-split-mode {
            display: flex;
            height: 100%;
        }
        
        .editor-split-mode .editor-main {
            flex: 1;
            overflow-y: auto;
            border-right: 1px solid var(--border-color);
        }
        
        .editor-split-mode .character-sheet-panel {
            width: 450px;
            overflow-y: auto;
            background: var(--bg-primary);
        }
        
        .character-sheet-panel .character-sheet {
            padding: 1rem;
        }
        
        .character-sheet-panel .character-sheet-header {
            flex-direction: column;
            align-items: center;
            text-align: center;
            gap: 1rem;
        }
        
        .character-sheet-panel .character-avatar {
            width: 80px;
            height: 80px;
            font-size: 2rem;
        }
        
        .character-sheet-panel .character-header-info h2 {
            font-size: 1.3rem;
        }
        
        /* ==========================================
           SPLIT VIEW SYSTEM
           ========================================== */
        
        .split-view-container {
            display: flex;
            height: 100%;
            width: 100%;
            position: relative;
        }
        
        .split-view-container.vertical {
            flex-direction: column;
        }
        
        .split-panel {
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-width: 250px;
            min-height: 200px;
        }
        
        .split-panel-left {
            flex: 6;
        }
        
        .split-panel-right {
            flex: 4;
        }
        
        .split-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0.75rem;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
            min-height: 40px;
        }
        
        .split-panel-title {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 0.5rem;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .split-panel-actions {
            display: flex;
            gap: 0.25rem;
            flex-shrink: 0;
        }
        
        .split-panel-btn {
            background: none;
            border: none;
            padding: 0.25rem 0.5rem;
            cursor: pointer;
            color: var(--text-muted);
            border-radius: 4px;
            font-size: 0.8rem;
            transition: all 0.2s;
        }
        
        .split-panel-btn:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        .split-panel-content {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
        }
        
        /* Active panel indicator */
        .split-panel.active {
            box-shadow: inset 0 0 0 2px var(--primary-color);
        }
        
        .split-panel.active .split-panel-header {
            background: var(--primary-color);
            color: white;
        }
        
        .split-panel.active .split-panel-header .split-panel-title {
            color: white;
        }
        
        .split-panel.active .split-panel-btn {
            color: rgba(255,255,255,0.8);
        }
        
        .split-panel.active .split-panel-btn:hover {
            background: rgba(255,255,255,0.2);
            color: white;
        }
        
        .split-panel-indicator {
            font-size: 8px;
            color: var(--text-muted);
            opacity: 0.3;
        }
        
        .split-panel-indicator.active {
            color: white;
            opacity: 1;
        }
        
        .split-panel-header {
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .split-panel-header:hover {
            background: var(--bg-tertiary);
        }
        
        .split-panel.active .split-panel-header:hover {
            background: var(--primary-color-dark, var(--primary-color));
            filter: brightness(0.9);
        }
        
        /* View option in selector */
        .split-view-option:hover {
            filter: brightness(1.1);
            transform: translateY(-1px);
        }
        
        /* Resizer */
        .split-resizer {
            flex-shrink: 0;
            background: var(--border-color);
            transition: background 0.2s;
            position: relative;
        }
        
        .split-resizer:hover,
        .split-resizer.dragging {
            background: var(--primary-color);
        }
        
        .split-resizer.horizontal {
            width: 5px;
            cursor: col-resize;
        }
        
        .split-resizer.vertical {
            height: 5px;
            cursor: row-resize;
        }
        
        .split-resizer::after {
            content: '';
            position: absolute;
            background: var(--text-muted);
            border-radius: 2px;
            opacity: 0.5;
        }
        
        .split-resizer.horizontal::after {
            width: 3px;
            height: 30px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        .split-resizer.vertical::after {
            width: 30px;
            height: 3px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        /* Split View Selector Dropdown */
        .split-selector {
            position: relative;
        }
        
        .split-selector-btn {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.4rem 0.75rem;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            color: var(--text-secondary);
            transition: all 0.2s;
        }
        
        .split-selector-btn:hover {
            border-color: var(--primary-color);
            color: var(--text-primary);
        }
        
        .split-selector-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            min-width: 200px;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            box-shadow: 0 4px 12px var(--shadow);
            z-index: 100;
            display: none;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .split-selector-dropdown.open {
            display: block;
        }
        
        .split-selector-group {
            padding: 0.5rem 0;
            border-bottom: 1px solid var(--border-color);
        }
        
        .split-selector-group:last-child {
            border-bottom: none;
        }
        
        .split-selector-group-title {
            padding: 0.25rem 0.75rem;
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            color: var(--text-muted);
            letter-spacing: 0.5px;
        }
        
        .split-selector-item {
            padding: 0.5rem 0.75rem;
            cursor: pointer;
            font-size: 0.85rem;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 0.5rem;
            transition: background 0.15s;
        }
        
        .split-selector-item:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }
        
        .split-selector-item.active {
            background: var(--bg-tertiary);
            color: var(--primary-color);
            font-weight: 500;
        }
        
        /* Split Mode Toggle Button in Header */
        .split-mode-toggle {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            padding: 0.4rem 0.75rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            color: var(--text-secondary);
            transition: all 0.2s;
        }
        
        .split-mode-toggle:hover {
            border-color: var(--primary-color);
            color: var(--primary-color);
        }
        
        .split-mode-toggle.active {
            background: var(--primary-color);
            border-color: var(--primary-color);
            color: white;
        }
        
        /* Responsive */
        @media (max-width: 900px) {
            .split-view-container {
                flex-direction: column !important;
            }
            
            .split-resizer.horizontal {
                width: 100%;
                height: 5px;
                cursor: row-resize;
            }
            
            .split-resizer.horizontal::after {
                width: 30px;
                height: 3px;
            }
            
            .split-panel {
                min-width: unset;
                min-height: 150px;
            }
            
            .split-panel-left,
            .split-panel-right {
                flex: 1;
            }
        }
        
        /* Character sheet adjustments in split view */
        .split-panel .character-sheet {
            padding: 1rem;
            height: auto;
        }
        
        .split-panel .character-sheet-header {
            padding: 1rem;
        }
        
        .split-panel .character-avatar {
            width: 80px;
            height: 80px;
            font-size: 2rem;
        }

        @media (max-width: 900px) {
            .character-sheet {
                padding: 1rem;
            }
            
            .character-sheet-header {
                flex-direction: column;
                align-items: center;
                text-align: center;
            }
            
            .character-header-actions {
                align-items: center;
            }
            
            .character-field-row {
                grid-template-columns: 1fr;
            }
            
            .character-timeline {
                grid-template-columns: 1fr;
            }
            
            .character-radar-controls {
                grid-template-columns: 1fr;
            }
        }
        
        .detail-header {
            padding: 1.5rem;
            background: var(--bg-secondary);
            border-radius: 4px;
            margin-bottom: 2rem;
            border-left: 4px solid var(--accent-red);
        }
        
        .detail-title {
            font-size: 1.8rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--text-primary);
            font-family: 'Noto Serif JP', serif;
        }
        
        .detail-section {
            background: var(--bg-secondary);
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            border-radius: 4px;
            border: 1px solid var(--border-color);
        }
        
        .detail-section-title {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--text-primary);
            padding-bottom: 0.75rem;
            border-bottom: 2px solid var(--border-color);
        }
        
        .detail-field {
            margin-bottom: 1.25rem;
        }
        
        .detail-field:last-child {
            margin-bottom: 0;
        }
        
        .detail-label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: var(--text-secondary);
            font-size: 0.95rem;
        }

        .modal-actions {
            display: flex;
            gap: 0.75rem;
            justify-content: flex-end;
        }

        .modal-button-group {
            display: flex;
            gap: 0.75rem;
            flex-wrap: wrap;
        }

        .modal-button-group .btn {
            flex: 1;
            min-width: 180px;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 12px;
            height: 12px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 6px;
            border: 2px solid var(--bg-secondary);
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }

        /* Better scrollbar for editor workspace */
        .editor-workspace::-webkit-scrollbar-thumb {
            background: var(--accent-gold);
            border: 2px solid var(--bg-primary);
        }

        .editor-workspace::-webkit-scrollbar-thumb:hover {
            background: var(--accent-red);
        }

        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .chapter-group {
            animation: fadeIn 0.3s ease forwards;
        }

        /* ==========================================
           AMÉLIORATIONS VISUELLES - OPT 1
           ========================================== */
        
        /* Badge de statut amélioré */
        .status-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            margin-left: 0.4rem;
            flex-shrink: 0;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            font-size: 10px;
            cursor: pointer;
            position: relative;
        }
        
        .status-badge:hover {
            transform: scale(1.2);
            box-shadow: 0 0 0 3px rgba(0,0,0,0.1);
        }
        
        .status-draft { 
            background: #ff6b6b; 
        }
        .status-draft::after { content: ""; }
        
        .status-progress { 
            background: #ffd93d; 
        }
        .status-progress::after { content: ""; }
        
        .status-complete { 
            background: #51cf66; 
        }
        .status-complete::after { content: "✓"; color: white; font-weight: bold; }
        
        .status-review { 
            background: #4a9eff; 
        }
        .status-review::after { content: ""; }
        
        /* Menu contextuel de statut */
        .status-menu {
            position: fixed;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 10000;
            min-width: 140px;
            padding: 0.5rem 0;
            display: none;
        }
        
        .status-menu.visible {
            display: block;
        }
        
        .status-menu-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            cursor: pointer;
            font-size: 0.85rem;
            color: var(--text-primary);
            transition: background 0.2s;
        }
        
        .status-menu-item:hover {
            background: var(--bg-secondary);
        }
        
        .status-menu-item.active {
            background: var(--bg-tertiary);
            font-weight: 600;
        }
        
        .status-menu-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            flex-shrink: 0;
        }
        
        .status-menu-dot.draft { background: #ff6b6b; }
        .status-menu-dot.progress { background: #ffd93d; }
        .status-menu-dot.complete { background: #51cf66; }
        .status-menu-dot.review { background: #4a9eff; }
        
        /* Barre de progression globale */
        .project-progress-bar {
            padding: 0.75rem 1rem;
            background: var(--bg-primary);
            border-bottom: 1px solid var(--border-color);
        }
        
        .progress-stats {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
            font-size: 0.75rem;
            color: var(--text-secondary);
        }
        
        .progress-track {
            height: 6px;
            background: var(--bg-tertiary);
            border-radius: 3px;
            overflow: hidden;
            display: flex;
        }
        
        .progress-segment {
            height: 100%;
            transition: width 0.3s ease;
        }
        
        .progress-segment.complete { background: #51cf66; }
        .progress-segment.review { background: #4a9eff; }
        .progress-segment.progress { background: #ffd93d; }
        .progress-segment.draft { background: #ff6b6b; }
        
        /* Filtres de statut */
        .status-filters {
            display: flex;
            gap: 0.25rem;
            padding: 0.5rem 1rem;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            flex-wrap: wrap;
        }
        
        .status-filter-btn {
            display: flex;
            align-items: center;
            gap: 0.3rem;
            padding: 0.3rem 0.6rem;
            border: 1px solid var(--border-color);
            border-radius: 12px;
            background: var(--bg-primary);
            font-size: 0.7rem;
            cursor: pointer;
            transition: all 0.2s;
            color: var(--text-secondary);
        }
        
        .status-filter-btn:hover {
            border-color: var(--text-muted);
        }
        
        .status-filter-btn.active {
            border-color: currentColor;
            font-weight: 600;
        }
        
        .status-filter-btn.draft.active { 
            background: rgba(255, 107, 107, 0.15); 
            color: #e55a5a;
            border-color: #ff6b6b;
        }
        .status-filter-btn.progress.active { 
            background: rgba(255, 217, 61, 0.15); 
            color: #c9a82e;
            border-color: #ffd93d;
        }
        .status-filter-btn.complete.active { 
            background: rgba(81, 207, 102, 0.15); 
            color: #3db854;
            border-color: #51cf66;
        }
        .status-filter-btn.review.active { 
            background: rgba(74, 158, 255, 0.15); 
            color: #3a8ae6;
            border-color: #4a9eff;
        }
        
        .status-filter-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }
        
        .status-filter-dot.draft { background: #ff6b6b; }
        .status-filter-dot.progress { background: #ffd93d; }
        .status-filter-dot.complete { background: #51cf66; }
        .status-filter-dot.review { background: #4a9eff; }
        
        .status-filter-count {
            font-weight: 600;
        }
        
        /* Scènes filtrées (cachées) */
        .scene-item.filtered-out {
            display: none !important;
        }
        
        .chapter-group.filtered-out {
            display: none !important;
        }
        
        .act-group.filtered-out {
            display: none !important;
        }
        
        /* Compteur de mots */
        .word-count-badge {
            font-size: 0.6rem;
            color: var(--text-muted);
            font-family: 'Courier New', monospace;
            padding: 0.05rem 0.25rem;
            background: var(--bg-tertiary);
            border-radius: 2px;
            white-space: nowrap;
            font-weight: 600;
        }
        
        /* Numérotation automatique */
        .auto-number {
            font-size: 0.65rem;
            color: var(--text-muted);
            font-family: 'Courier New', monospace;
            font-weight: 700;
            min-width: 28px;
            text-align: right;
            margin-right: 0.2rem;
            flex-shrink: 0;
        }

        .delete-btn {
            opacity: 0;
            margin-left: auto;
            transition: opacity 0.2s ease;
            padding: 0 0.2rem !important;
            min-width: auto !important;
            width: 18px !important;
            height: 18px !important;
            font-size: 0.8rem !important;
        }

        .act-header:hover .delete-btn,
        .chapter-header:hover .delete-btn,
        .scene-item:hover .delete-btn {
            opacity: 1;
        }

        .scene-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        /* Drag and Drop */
        .draggable {
            cursor: move;
        }

        .draggable:active {
            cursor: grabbing;
        }

        .drag-over {
            background: rgba(212, 175, 55, 0.2);
            border-left: 3px solid var(--accent-gold);
        }

        .dragging {
            opacity: 0.5;
            background: var(--bg-accent);
            color: var(--bg-primary);
        }

        .drag-handle {
            cursor: grab;
            padding: 0 0.2rem;
            color: var(--text-muted);
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.7rem;
        }

        .chapter-header:hover .drag-handle,
        .scene-item:hover .drag-handle,
        .act-header:hover .drag-handle {
            opacity: 1;
        }

        .drag-handle:active {
            cursor: grabbing;
        }

        /* Inline Editing */
        .editing-input {
            background: var(--bg-primary);
            border: 2px solid var(--accent-gold);
            padding: 0.15rem 0.3rem;
            font-family: 'Crimson Pro', serif;
            font-size: inherit;
            font-weight: inherit;
            color: var(--text-primary);
            border-radius: 2px;
            outline: none;
            width: 100%;
        }

        .chapter-title,
        .scene-item > div > span:not(.drag-handle) {
            cursor: text;
        }

        .chapter-title:hover,
        .scene-item > div > span:not(.drag-handle):hover {
            background: rgba(212, 175, 55, 0.1);
            padding: 0.15rem 0.3rem;
            margin: -0.15rem -0.3rem;
            border-radius: 2px;
        }

        .edit-hint {
            font-size: 0.6rem;
            color: var(--text-muted);
            opacity: 0;
            transition: opacity 0.2s ease;
            font-style: italic;
            margin-left: 0.25rem;
        }

        .chapter-header:hover .edit-hint,
        .scene-item:hover .edit-hint {
            opacity: 1;
        }

        /* Rich Text Editor Toolbar - defined above in main structure */

        .toolbar-group {
            display: flex;
            gap: 4px;
            padding-right: 12px;
            border-right: 1px solid var(--border-color);
            flex-shrink: 0;
        }

        .toolbar-group:last-child {
            border-right: none;
        }

        .toolbar-btn {
            padding: 0;
            min-width: 36px;
            height: 36px;
            border: none;
            background: transparent;
            color: var(--text-primary);
            cursor: pointer;
            font-family: 'Crimson Pro', serif;
            font-size: 16px;
            font-weight: 400;
            transition: all 0.15s ease;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .toolbar-btn:hover {
            background: var(--bg-secondary);
        }

        .toolbar-btn.active {
            background: var(--primary-color);
            color: white;
        }

        .toolbar-btn[data-format="bold"] {
            font-weight: 700;
        }

        .toolbar-btn[data-format="italic"] {
            font-style: italic;
        }

        .toolbar-btn[data-format="underline"] {
            text-decoration: underline;
        }

        /* Bouton annotations avec badge */
        .annotations-toolbar-btn {
            position: relative;
        }
        
        .annotations-toolbar-btn.has-annotations::after {
            content: attr(data-count);
            position: absolute;
            top: 2px;
            right: 2px;
            background: var(--accent-red);
            color: white;
            font-size: 10px;
            font-weight: 600;
            min-width: 14px;
            height: 14px;
            border-radius: 7px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 3px;
        }
        
        .annotations-toolbar-btn.panel-open {
            background: var(--primary-color);
            color: white;
        }

        /* Select dans le toolbar */
        select.toolbar-btn {
            min-width: 100px;
            padding: 0 32px 0 12px;
            font-size: 14px;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg width='10' height='6' viewBox='0 0 10 6' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 1L5 5L9 1' stroke='%23666' stroke-width='1.5' stroke-linecap='round'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 10px center;
            background-color: transparent;
        }

        select.toolbar-btn:hover {
            background-color: var(--bg-secondary);
            background-image: url("data:image/svg+xml,%3Csvg width='10' height='6' viewBox='0 0 10 6' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 1L5 5L9 1' stroke='%23666' stroke-width='1.5' stroke-linecap='round'/%3E%3C/svg%3E");
        }

        /* Color Picker Dropdown */
        .color-picker-wrapper {
            position: relative;
            display: inline-block;
        }

        .color-picker-dropdown {
            position: fixed;
            background: var(--bg-primary);
            border: 2px solid var(--border-color);
            border-radius: 4px;
            padding: 0.75rem;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 99999;
            display: none;
            min-width: 200px;
        }

        .color-picker-dropdown.active {
            display: block;
        }

        .color-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 0.25rem;
            margin-bottom: 0.5rem;
        }

        .color-swatch {
            width: 24px;
            height: 24px;
            border: 2px solid var(--border-color);
            border-radius: 2px;
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .color-swatch:hover {
            transform: scale(1.1);
            border-color: var(--accent-gold);
        }

        .color-input-wrapper {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-top: 0.5rem;
            padding-top: 0.5rem;
            border-top: 1px solid var(--border-color);
        }

        .color-input-wrapper input[type="color"] {
            width: 40px;
            height: 30px;
            border: 1px solid var(--border-color);
            border-radius: 2px;
            cursor: pointer;
        }

        .color-input-wrapper input[type="text"] {
            flex: 1;
            padding: 0.3rem 0.5rem;
            border: 1px solid var(--border-color);
            border-radius: 2px;
            font-family: 'Source Code Pro', monospace;
            font-size: 0.85rem;
        }

        /* Font Size Selector */
        .font-size-selector {
            padding: 0.5rem;
            border: 1px solid var(--border-color);
            background: var(--bg-primary);
            color: var(--text-primary);
            cursor: pointer;
            font-family: 'Crimson Pro', serif;
            font-size: 0.9rem;
            border-radius: 2px;
            min-width: 70px;
        }

        .font-size-selector:hover {
            background: var(--accent-gold);
            color: var(--bg-primary);
            border-color: var(--accent-gold);
        }

        /* Font Family Selector */
        .font-family-selector {
            padding: 0.5rem;
            border: 1px solid var(--border-color);
            background: var(--bg-primary);
            color: var(--text-primary);
            cursor: pointer;
            font-size: 0.9rem;
            border-radius: 2px;
            min-width: 150px;
        }

        .font-family-selector:hover {
            background: var(--accent-gold);
            color: var(--bg-primary);
            border-color: var(--accent-gold);
        }

        /* Toolbar separator */
        .toolbar-separator {
            width: 1px;
            height: 30px;
            background: var(--border-color);
            margin: 0 0.25rem;
        }

        /* Rich Text Editor Content */
        .editor-textarea[contenteditable="true"] {
            outline: none;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .editor-textarea[contenteditable="true"]:empty:before {
            content: attr(data-placeholder);
            color: var(--text-muted);
            font-style: italic;
            pointer-events: none;
        }

        .editor-textarea strong,
        .editor-textarea b {
            font-weight: 700;
        }

        .editor-textarea em,
        .editor-textarea i {
            font-style: italic;
        }

        .editor-textarea u {
            text-decoration: underline;
        }

        .editor-textarea h1 {
            font-size: 2em;
            font-weight: 700;
            margin: 1em 0 0.5em;
            font-family: 'Noto Serif JP', serif;
        }

        .editor-textarea h2 {
            font-size: 1.5em;
            font-weight: 600;
            margin: 1em 0 0.5em;
            font-family: 'Noto Serif JP', serif;
        }

        .editor-textarea h3 {
            font-size: 1.25em;
            font-weight: 600;
            margin: 1em 0 0.5em;
        }

        .editor-textarea blockquote {
            border-left: 4px solid var(--accent-gold);
            padding-left: 1.5rem;
            margin: 1.5rem 0;
            font-style: italic;
            color: var(--text-secondary);
        }

        .editor-textarea ul,
        .editor-textarea ol {
            margin: 1rem 0;
            padding-left: 2rem;
        }

        .editor-textarea li {
            margin: 0.5rem 0;
        }

        .editor-textarea hr {
            border: none;
            border-top: 2px solid var(--border-color);
            margin: 2rem 0;
        }

        /* Text alignment */
        .editor-textarea [style*="text-align: left"] {
            text-align: left;
        }

        .editor-textarea [style*="text-align: center"] {
            text-align: center;
        }

        .editor-textarea [style*="text-align: right"] {
            text-align: right;
        }

        .editor-textarea [style*="text-align: justify"] {
            text-align: justify;
        }

        /* Strikethrough */
        .editor-textarea s,
        .editor-textarea strike {
            text-decoration: line-through;
        }

        /* Superscript and subscript */
        .editor-textarea sup {
            vertical-align: super;
            font-size: 0.75em;
        }

        .editor-textarea sub {
            vertical-align: sub;
            font-size: 0.75em;
        }

        /* Timeline Styles */
        .timeline-container {
            position: relative;
            padding: 1rem 0 1rem 2.5rem;
        }

        .timeline-line {
            position: absolute;
            left: 0.75rem;
            top: 0;
            bottom: 0;
            width: 2px;
            background: var(--border-color);
        }

        .timeline-event {
            position: relative;
            margin-bottom: 1.5rem;
            padding: 0.75rem;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .timeline-event::before {
            content: '';
            position: absolute;
            left: -2rem;
            top: 1rem;
            width: 10px;
            height: 10px;
            background: var(--accent-red);
            border: 2px solid var(--bg-primary);
            border-radius: 50%;
            z-index: 2;
        }

        .timeline-event:hover {
            border-color: var(--accent-gold);
            box-shadow: 0 2px 8px var(--shadow);
        }

        .timeline-event.active {
            border-color: var(--accent-red);
            background: var(--bg-secondary);
        }

        .timeline-date {
            font-size: 0.75rem;
            color: var(--accent-gold);
            font-weight: 600;
            margin-bottom: 0.4rem;
            font-family: 'Source Code Pro', monospace;
        }

        .timeline-title {
            font-size: 0.95rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.4rem;
        }

        .timeline-meta {
            display: flex;
            gap: 0.75rem;
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-bottom: 0.4rem;
            flex-wrap: wrap;
        }

        .timeline-meta-item {
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .timeline-description {
            font-size: 0.85rem;
            color: var(--text-secondary);
            line-height: 1.4;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        /* Notes Styles */
        .note-card {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 1rem;
            margin-bottom: 1rem;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .note-card:hover {
            border-color: var(--accent-gold);
            box-shadow: 0 2px 8px var(--shadow);
        }

        .note-card.active {
            border-color: var(--accent-red);
            background: var(--bg-secondary);
        }

        .note-category-badge {
            display: inline-block;
            font-size: 0.7rem;
            padding: 0.25rem 0.5rem;
            background: var(--accent-gold);
            color: var(--bg-primary);
            border-radius: 2px;
            margin-bottom: 0.5rem;
            font-family: 'Source Code Pro', monospace;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .note-title {
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
        }

        .note-preview {
            font-size: 0.85rem;
            color: var(--text-secondary);
            line-height: 1.4;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
            overflow: hidden;
            margin-bottom: 0.5rem;
        }

        .note-tags {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .note-tag {
            font-size: 0.7rem;
            padding: 0.2rem 0.5rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 2px;
            color: var(--text-muted);
        }

        .note-date {
            font-size: 0.7rem;
            color: var(--text-muted);
            margin-top: 0.5rem;
            font-family: 'Source Code Pro', monospace;
        }

        /* Note Medias */
        .note-medias-container {
            margin-top: 0.5rem;
        }

        .note-medias-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 1rem;
        }

        .note-media-item {
            position: relative;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow: hidden;
            background: var(--bg-secondary);
            transition: all 0.2s;
        }

        .note-media-item:hover {
            border-color: var(--primary-color);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .note-media-image {
            cursor: pointer;
        }

        .note-media-image img {
            width: 100%;
            height: 150px;
            object-fit: cover;
            display: block;
        }

        .note-media-overlay {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.5rem;
            background: var(--bg-primary);
            border-top: 1px solid var(--border-color);
        }

        .note-media-title {
            font-size: 0.8rem;
            font-weight: 500;
            color: var(--text-primary);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            flex: 1;
        }

        .note-media-delete {
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 1.2rem;
            cursor: pointer;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .note-media-delete:hover {
            background: var(--accent-red);
            color: white;
        }

        .note-media-url {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 1rem;
            cursor: pointer;
        }

        .note-media-url-icon {
            font-size: 1.5rem;
            flex-shrink: 0;
        }

        .note-media-url-info {
            flex: 1;
            min-width: 0;
        }

        .note-media-domain {
            display: block;
            font-size: 0.7rem;
            color: var(--text-muted);
            margin-top: 0.2rem;
        }

        .note-media-audio {
            display: flex;
            align-items: flex-start;
            gap: 0.75rem;
            padding: 1rem;
        }

        .note-media-audio-icon {
            font-size: 1.5rem;
            flex-shrink: 0;
        }

        .note-media-audio-info {
            flex: 1;
            min-width: 0;
        }

        .note-media-youtube {
            cursor: pointer;
        }

        .note-media-youtube-thumb {
            position: relative;
            width: 100%;
            height: 120px;
            overflow: hidden;
        }

        .note-media-youtube-thumb img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .note-media-youtube-play {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 50px;
            height: 50px;
            background: rgba(255, 0, 0, 0.9);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 1.2rem;
            transition: transform 0.2s;
        }

        .note-media-youtube:hover .note-media-youtube-play {
            transform: translate(-50%, -50%) scale(1.1);
        }

        /* Treeview media icon */
        .treeview-media-icon {
            font-size: 0.75rem;
            margin-left: 0.25rem;
        }

        /* Statistics Styles */
        .stat-box {
            background: var(--bg-primary);
            border: 2px solid var(--border-color);
            border-radius: 4px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
        }

        .stat-title {
            font-size: 0.85rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.5rem;
            font-weight: 500;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: 700;
            color: var(--text-primary);
            font-family: 'Noto Serif JP', serif;
        }

        .stat-label {
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-top: 0.25rem;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: var(--bg-secondary);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 0.5rem;
        }

        .progress-fill {
            height: 100%;
            background: var(--accent-gold);
            transition: width 0.3s ease;
        }

        .goal-input {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        /* Codex Styles */
        .codex-card {
            background: var(--bg-primary);
            border-left: 4px solid var(--accent-gold);
            border-right: 1px solid var(--border-color);
            border-top: 1px solid var(--border-color);
            border-bottom: 1px solid var(--border-color);
            border-radius: 0 4px 4px 0;
            padding: 1rem;
            margin-bottom: 1rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .codex-card:hover {
            border-left-color: var(--accent-red);
            box-shadow: 0 2px 8px var(--shadow);
        }

        /* Version Styles */
        .version-card {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 1rem;
            margin-bottom: 1rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .version-card:hover {
            border-color: var(--accent-gold);
            box-shadow: 0 2px 8px var(--shadow);
        }

        .version-timestamp {
            font-size: 0.85rem;
            color: var(--accent-gold);
            font-weight: 600;
            margin-bottom: 0.5rem;
            font-family: 'Source Code Pro', monospace;
        }

        .version-label {
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
        }

        .version-stats {
            font-size: 0.8rem;
            color: var(--text-muted);
        }

        /* References and Links Styles */
        .references-section {
            margin-bottom: 1.5rem;
        }

        .references-title {
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .reference-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.5rem 0.75rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 2px;
            margin-bottom: 0.5rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .reference-item:hover {
            background: rgba(212, 175, 55, 0.1);
            border-color: var(--accent-gold);
        }

        .reference-link {
            display: inline-block;
            padding: 0.25rem 0.5rem;
            background: var(--accent-gold);
            color: var(--bg-primary);
            border-radius: 2px;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s ease;
            text-decoration: none;
            margin: 0.25rem;
        }

        .reference-link:hover {
            background: var(--accent-red);
        }

        .tag-selector {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .tag-option {
            padding: 0.4rem 0.8rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 2px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s ease;
        }

        .tag-option:hover {
            border-color: var(--accent-gold);
        }

        .tag-option.selected {
            background: var(--accent-gold);
            color: var(--bg-primary);
            border-color: var(--accent-gold);
        }

        .link-badge {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.25rem 0.5rem;
            background: rgba(212, 175, 55, 0.2);
            border: 1px solid var(--accent-gold);
            border-radius: 2px;
            font-size: 0.75rem;
            color: var(--text-primary);
            margin: 0.25rem 0.25rem 0.25rem 0;
            cursor: pointer;
        }

        .link-badge:hover {
            background: rgba(212, 175, 55, 0.3);
        }

        .link-badge-remove {
            cursor: pointer;
            color: var(--accent-red);
            font-weight: bold;
            margin-left: 0.25rem;
        }

        .link-badge-remove:hover {
            color: #8b2a1f;
        }

        .quick-links {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-top: 0.5rem;
        }

        /* Projects Management Styles */
        .project-card {
            background: var(--bg-primary);
            border: 2px solid var(--border-color);
            border-radius: 4px;
            padding: 1.5rem;
            margin-bottom: 1rem;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .project-card:hover {
            border-color: var(--accent-gold);
            box-shadow: 0 2px 8px var(--shadow);
        }

        .project-card.active {
            border-color: var(--accent-red);
            background: var(--bg-secondary);
        }

        .project-card-header {
            display: flex;
            justify-content: space-between;
            align-items: start;
            margin-bottom: 0.75rem;
        }

        .project-card-title {
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--text-primary);
            font-family: 'Noto Serif JP', serif;
        }

        .project-card-genre {
            font-size: 0.75rem;
            padding: 0.25rem 0.5rem;
            background: var(--accent-gold);
            color: var(--bg-primary);
            border-radius: 2px;
            font-weight: 600;
        }

        .project-card-desc {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 0.75rem;
            line-height: 1.4;
        }

        .project-card-stats {
            display: flex;
            gap: 1.5rem;
            font-size: 0.85rem;
            color: var(--text-muted);
            font-family: 'Source Code Pro', monospace;
        }

        .project-card-actions {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        /* Focus Mode Styles */
        .app-container.focus-mode {
            display: flex !important;
            flex-direction: column !important;
        }
        
        .app-container.focus-mode .app-content {
            display: flex !important;
            flex: 1 !important;
            overflow: hidden !important;
        }
        
        .app-container.focus-mode .sidebar {
            display: none !important;
            width: 0 !important;
        }
        
        .app-container.focus-mode .sidebar-versions {
            display: none !important;
            width: 0 !important;
        }
        
        .app-container.focus-mode .app-header {
            display: none !important;
        }
        
        .app-container.focus-mode .annotations-panel {
            display: none !important;
        }

        .app-container.focus-mode .editor-container {
            background: var(--bg-primary);
            height: 100vh !important;
            width: 100% !important;
            flex: 1 !important;
        }

        /* Header de l'éditeur toujours visible en mode focus */
        .app-container.focus-mode .editor-header {
            opacity: 1;
        }

        /* Toolbar toujours visible en mode focus (garde son style normal) */
        .app-container.focus-mode .editor-toolbar {
            opacity: 1;
        }
        
        /* Bouton Paramètres Focus - styles quand visible */
        .focus-settings-btn {
            background: var(--accent-gold) !important;
            color: var(--bg-accent) !important;
            border-color: var(--accent-gold) !important;
        }
        
        .focus-settings-btn:hover {
            background: var(--accent-red) !important;
            border-color: var(--accent-red) !important;
            color: white !important;
        }
        
        /* Barre de progression d'écriture */
        .writing-progress-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 28px;
            background: rgba(0,0,0,0.85);
            z-index: 9999;
            display: none;
            flex-direction: column;
            /* Ne participe pas au grid */
        }
        
        .app-container.focus-mode .writing-progress-bar {
            display: flex;
        }
        
        .writing-progress-fill {
            height: 3px;
            background: linear-gradient(90deg, var(--accent-gold), var(--accent-red));
            transition: width 0.3s ease;
            width: 0%;
        }
        
        .writing-progress-text {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            color: rgba(255,255,255,0.8);
            font-size: 0.7rem;
            font-family: 'Courier New', monospace;
            padding: 0.2rem;
        }
        
        /* Indicateur de position discret - DÉSACTIVÉ, intégré dans la barre */
        .position-indicator {
            display: none !important;
        }

        .focus-mode-panel {
            position: fixed;
            top: 0;
            right: 0;
            width: 350px;
            height: 100vh;
            background: var(--bg-primary);
            border-left: 2px solid var(--accent-gold);
            box-shadow: -8px 0 24px rgba(0, 0, 0, 0.3);
            transform: translateX(100%);
            transition: transform 0.3s ease;
            z-index: 2000;
            display: flex;
            flex-direction: column;
        }

        .focus-mode-panel.active {
            transform: translateX(0);
        }

        .app-container.focus-mode .focus-mode-panel {
            display: flex;
        }

        .focus-panel-header {
            padding: 1.5rem;
            border-bottom: 2px solid var(--border-color);
            background: var(--bg-accent);
            color: var(--bg-primary);
        }

        .focus-panel-title {
            font-size: 1.2rem;
            font-weight: 700;
            font-family: 'Noto Serif JP', serif;
        }

        .focus-panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 1.5rem;
        }

        .focus-section {
            margin-bottom: 2rem;
        }

        .focus-section-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .pomodoro-timer {
            text-align: center;
            padding: 2rem;
            background: var(--bg-primary);
            border-radius: 4px;
            border: 2px solid var(--border-color);
        }

        .pomodoro-display {
            font-size: 3rem;
            font-weight: 700;
            font-family: 'Source Code Pro', monospace;
            color: var(--text-primary);
            margin-bottom: 1rem;
        }

        .pomodoro-controls {
            display: flex;
            gap: 0.5rem;
            justify-content: center;
        }

        /* Pomodoro Popup dans le header */
        .pomodoro-popup {
            position: fixed;
            top: 60px;
            right: 100px;
            background: var(--bg-primary);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.15);
            z-index: 10000;
            display: none;
            min-width: 200px;
        }
        
        .pomodoro-popup.active {
            display: block;
        }
        
        .pomodoro-popup-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1rem;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            font-weight: 600;
            border-radius: 6px 6px 0 0;
        }
        
        .pomodoro-popup-close {
            cursor: pointer;
            font-size: 1.2rem;
            color: var(--text-muted);
            transition: color 0.2s;
        }
        
        .pomodoro-popup-close:hover {
            color: var(--accent-red);
        }
        
        .pomodoro-popup-content {
            padding: 1.5rem;
            text-align: center;
        }
        
        .pomodoro-popup .pomodoro-display {
            font-size: 2.5rem;
            margin-bottom: 1rem;
        }
        
        .pomodoro-popup .pomodoro-controls {
            margin-bottom: 1rem;
        }
        
        .pomodoro-stats {
            display: flex;
            justify-content: center;
            gap: 1rem;
        }
        
        .pomodoro-stat {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .pomodoro-stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--primary-color);
        }
        
        .pomodoro-stat-label {
            font-size: 0.75rem;
            color: var(--text-muted);
            text-transform: uppercase;
        }
        
        /* Indicateur visuel quand le timer tourne */
        .header-action-btn.pomodoro-active {
            color: var(--accent-red);
            animation: pomodoro-pulse 1s ease-in-out infinite;
        }
        
        @keyframes pomodoro-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .ambient-music {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .focus-stats {
            display: flex;
            gap: 1rem;
            margin-top: 1rem;
        }

        .focus-stat-box {
            flex: 1;
            padding: 0.75rem;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 2px;
            text-align: center;
        }

        .focus-stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--accent-gold);
            font-family: 'Source Code Pro', monospace;
        }

        .focus-stat-label {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-top: 0.25rem;
        }

        /* REVISION MODE STYLES */
        .highlight-yellow { background: var(--highlight-yellow); }
        .highlight-green { background: var(--highlight-green); }
        .highlight-blue { background: var(--highlight-blue); }
        .highlight-red { background: var(--highlight-red); }
        .highlight-purple { background: var(--highlight-purple); }

        .revision-toolbar {
            display: flex;
            gap: 0.5rem;
            padding: 1rem 3rem;
            border-bottom: 2px solid var(--accent-red);
            background: var(--bg-secondary);
            flex-wrap: wrap;
            align-items: center;
        }

        .revision-badge {
            padding: 0.5rem 1rem;
            background: var(--accent-red);
            color: var(--bg-primary);
            border-radius: 4px;
            font-weight: 600;
            margin-right: 1rem;
        }

        .highlight-btn {
            padding: 0.5rem 0.75rem;
            border: 1px solid var(--border-color);
            background: var(--bg-primary);
            cursor: pointer;
            font-size: 0.85rem;
            border-radius: 2px;
            transition: all 0.2s;
        }

        .highlight-btn.active {
            border-width: 2px;
            font-weight: 600;
        }

        .highlight-btn.yellow { background: var(--highlight-yellow); }
        .highlight-btn.green { background: var(--highlight-green); }
        .highlight-btn.blue { background: var(--highlight-blue); }
        .highlight-btn.red { background: var(--highlight-red); }
        .highlight-btn.purple { background: var(--highlight-purple); }

        .annotations-panel {
            position: fixed;
            right: -350px;
            top: 350px;
            width: 320px;
            height: calc(100vh - 350px);
            background: var(--bg-secondary);
            border-left: 2px solid var(--border-color);
            padding: 0;
            overflow: hidden;
            transition: right 0.3s;
            box-shadow: -4px 0 12px rgba(0,0,0,0.1);
            z-index: 50;
            display: flex;
            flex-direction: column;
        }

        .annotations-panel.visible {
            right: 0;
        }
        
        .annotations-panel-spacer {
            display: none; /* Plus besoin du spacer */
        }
        
        .annotations-panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
        }
        
        .annotations-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid var(--border-color);
        }
        
        .annotations-panel-close {
            cursor: pointer;
            font-size: 1.5rem;
            color: var(--text-muted);
            transition: color 0.2s;
            padding: 0.5rem;
            line-height: 1;
        }
        
        .annotations-panel-close:hover {
            color: var(--accent-red);
        }

        .annotation-card {
            background: var(--bg-primary);
            border-left: 4px solid var(--accent-gold);
            padding: 1rem;
            margin-bottom: 1rem;
            border-radius: 0 4px 4px 0;
            cursor: pointer;
        }

        .annotation-card:hover {
            transform: translateX(-4px);
        }

        .annotation-card.todo { border-left-color: var(--accent-red); }
        .annotation-card.note { border-left-color: #4CAF50; }
        .annotation-card.question { border-left-color: #2196F3; }

        .annotation-type {
            font-size: 0.7rem;
            padding: 0.25rem 0.5rem;
            border-radius: 2px;
            text-transform: uppercase;
            font-weight: 600;
            display: inline-block;
            margin-bottom: 0.5rem;
        }

        .annotation-type.comment { background: var(--accent-gold); color: white; }
        .annotation-type.todo { background: var(--accent-red); color: white; }
        .annotation-type.note { background: #4CAF50; color: white; }
        .annotation-type.question { background: #2196F3; color: white; }

        .annotation-content {
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
        }

        .annotation-context {
            font-size: 0.75rem;
            color: var(--text-muted);
            font-style: italic;
            padding: 0.5rem;
            background: var(--bg-secondary);
            border-radius: 2px;
            margin-bottom: 0.5rem;
        }

        /* Marqueurs d'annotation dans le texte */
        .annotation-marker {
            padding: 2px 0;
            border-radius: 2px;
            transition: background 0.3s ease, box-shadow 0.3s ease;
            position: relative;
        }

        .annotation-marker:hover {
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .annotation-marker.comment {
            background: rgba(255, 235, 59, 0.3);
            border-bottom: 2px solid #FBC02D;
        }

        .annotation-marker.question {
            background: rgba(33, 150, 243, 0.3);
            border-bottom: 2px solid #1976D2;
        }

        .annotation-marker.todo {
            background: rgba(244, 67, 54, 0.3);
            border-bottom: 2px solid #D32F2F;
        }

        .annotation-marker.note {
            background: rgba(76, 175, 80, 0.3);
            border-bottom: 2px solid #4CAF50;
        }

        .annotation-popup {
            position: fixed;
            background: var(--bg-primary);
            border: 2px solid var(--accent-gold);
            border-radius: 4px;
            padding: 1.5rem;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            z-index: 10000;
            min-width: 350px;
            display: none;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
        }

        .annotation-popup.visible {
            display: block;
        }

        .annotation-type-selector {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .annotation-type-btn {
            flex: 1;
            padding: 0.5rem;
            border: 1px solid var(--border-color);
            background: var(--bg-secondary);
            cursor: pointer;
            font-size: 0.75rem;
            border-radius: 2px;
        }

        .annotation-type-btn.active {
            border-width: 2px;
            font-weight: 600;
        }

        .annotation-type-btn.comment.active { border-color: var(--accent-gold); }
        .annotation-type-btn.todo.active { border-color: var(--accent-red); }
        .annotation-type-btn.note.active { border-color: #4CAF50; }
        .annotation-type-btn.question.active { border-color: #2196F3; }

        .annotation-popup textarea {
            width: 100%;
            min-height: 100px;
            padding: 0.75rem;
            border: 1px solid var(--border-color);
            border-radius: 2px;
            font-family: inherit;
            font-size: 0.95rem;
            margin-bottom: 1rem;
        }

        .todo-item {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            padding: 0.75rem;
            margin-bottom: 0.75rem;
            border-radius: 4px;
            display: flex;
            gap: 0.75rem;
            cursor: pointer;
        }

        .todo-item:hover {
            border-color: var(--accent-gold);
        }

        .todo-checkbox {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .todo-text {
            flex: 1;
        }

        .todo-text.done {
            text-decoration: line-through;
            color: var(--text-muted);
        }

        .scene-badge {
            font-size: 0.7rem;
            padding: 0.2rem 0.4rem;
            background: var(--accent-red);
            color: white;
            border-radius: 2px;
            margin-left: 0.5rem;
        }

        /* ============================================ */
        /* CORK BOARD STYLES */
        /* ============================================ */
        
        .cork-board-container {
            padding: 2rem;
            background: var(--bg-tertiary);
            background-image: 
                radial-gradient(circle at 20% 30%, rgba(0,0,0,0.03) 1px, transparent 1px),
                radial-gradient(circle at 70% 60%, rgba(0,0,0,0.03) 1px, transparent 1px),
                radial-gradient(circle at 40% 80%, rgba(0,0,0,0.03) 1px, transparent 1px);
            background-size: 100px 100px, 150px 150px, 120px 120px;
            min-height: calc(100vh - 200px);
            overflow-y: auto;
        }
        
        .cork-board-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            padding: 1rem 2rem;
            background: var(--bg-primary);
            border-radius: 8px;
            box-shadow: 0 2px 8px var(--shadow);
        }
        
        .cork-board-title {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--text-primary);
        }
        
        .cork-board-filters {
            display: flex;
            gap: 1rem;
            align-items: center;
        }
        
        .cork-board-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 2rem;
            padding: 1rem;
        }
        
        .cork-card {
            background: var(--bg-primary);
            padding: 1.5rem;
            border-radius: 4px;
            box-shadow: 
                0 2px 4px var(--shadow),
                0 4px 8px var(--shadow);
            cursor: move;
            transition: all 0.3s ease;
            position: relative;
            min-height: 200px;
            border: 1px solid var(--border-color);
        }
        
        .cork-card::before {
            content: '📌';
            position: absolute;
            top: -10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.5rem;
            filter: drop-shadow(0 2px 2px var(--shadow));
        }
        
        .cork-card:hover {
            transform: translateY(-5px) rotate(1deg);
            box-shadow: 
                0 4px 8px var(--shadow),
                0 8px 16px var(--shadow);
        }
        
        .cork-card.dragging {
            opacity: 0.5;
            transform: rotate(5deg);
        }
        
        .cork-card-header {
            display: flex;
            justify-content: space-between;
            align-items: start;
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 2px dashed var(--border-color);
        }
        
        .cork-card-number {
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--text-muted);
            font-family: 'Source Code Pro', monospace;
        }
        
        .cork-card-color-tag {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 2px solid rgba(0,0,0,0.2);
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        .cork-card-color-tag:hover {
            transform: scale(1.2);
        }
        
        .cork-card-title {
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 1rem;
            line-height: 1.3;
        }
        
        .cork-card-synopsis {
            font-size: 0.9rem;
            color: var(--text-secondary);
            line-height: 1.6;
            margin-bottom: 1rem;
            min-height: 60px;
        }
        
        .cork-card-meta {
            display: flex;
            gap: 1rem;
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-top: auto;
        }
        
        .cork-card-actions {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
            padding-top: 0.75rem;
            border-top: 1px dashed var(--border-color);
        }
        
        .cork-color-palette {
            position: absolute;
            top: 100%;
            right: 0;
            background: white;
            border: 2px solid var(--border-color);
            border-radius: 4px;
            padding: 0.5rem;
            display: none;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        
        .cork-color-palette.visible {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 0.5rem;
        }
        
        .cork-color-option {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 2px solid rgba(0,0,0,0.2);
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        .cork-color-option:hover {
            transform: scale(1.2);
        }
        
        /* Couleurs prédéfinies pour POV/Intrigues */
        .cork-color-yellow { background: #ffd93d; }
        .cork-color-pink { background: #ff6b9d; }
        .cork-color-blue { background: #6bcfff; }
        .cork-color-green { background: #6bff9d; }
        .cork-color-purple { background: #c26bff; }
        .cork-color-orange { background: #ffb56b; }
        .cork-color-red { background: #ff6b6b; }
        .cork-color-teal { background: #6bffd9; }
        .cork-color-default { background: #fef9e7; }
        
        .cork-board-empty {
            text-align: center;
            padding: 4rem;
            color: var(--text-muted);
        }
        
        .cork-board-empty-icon {
            font-size: 4rem;
            margin-bottom: 1rem;
            opacity: 0.5;
        }
        
        .cork-filter-btn {
            padding: 0.5rem 1rem;
            border: 2px solid var(--border-color);
            background: var(--bg-primary);
            color: var(--text-primary);
            cursor: pointer;
            font-size: 0.85rem;
            border-radius: 4px;
            transition: all 0.2s;
            font-weight: 500;
        }
        
        .cork-filter-btn:hover {
            background: var(--accent-gold);
            color: white;
            border-color: var(--accent-gold);
        }
        
        .cork-filter-btn.active {
            background: var(--accent-red);
            color: white;
            border-color: var(--accent-red);
        }

        /* ============================================
           STRUCTURED VIEW (Style NovelCrafter)
           ============================================ */
        
        .structured-act-container {
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 1rem;
            border: 1px solid var(--border-color);
        }
        
        .structured-act-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
        }
        
        .structured-collapse-btn {
            background: transparent;
            border: none;
            color: var(--text-primary);
            cursor: pointer;
            font-size: 0.9rem;
            padding: 0.25rem;
        }
        
        .structured-collapse-btn:hover {
            color: var(--primary-color);
        }
        
        .structured-act-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .structured-count {
            color: var(--text-secondary);
            font-size: 0.9rem;
            margin-left: auto;
        }
        
        .structured-chapters-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 1rem;
        }
        
        .structured-chapter-container {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 1rem;
        }
        
        .structured-chapter-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid var(--border-color);
        }
        
        .structured-chapter-icon {
            color: var(--text-muted);
            font-size: 1rem;
        }
        
        .structured-chapter-title {
            color: var(--text-primary);
            font-weight: 500;
            font-size: 0.95rem;
        }
        
        .structured-menu-btn {
            background: transparent;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            padding: 0.25rem 0.5rem;
            font-size: 1.2rem;
        }
        
        .structured-menu-btn:hover {
            color: var(--accent-gold);
        }
        
        .structured-scenes-list {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        
        .structured-scene-card {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 0.75rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .structured-scene-card:hover {
            border-color: var(--accent-gold);
            transform: translateX(2px);
        }
        
        .structured-scene-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }
        
        .structured-scene-icon {
            color: var(--text-muted);
            font-size: 0.9rem;
        }
        
        .structured-scene-title {
            color: var(--text-primary);
            font-size: 0.9rem;
            font-weight: 500;
        }
        
        .structured-scene-menu {
            background: transparent;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            padding: 0.25rem;
            margin-left: auto;
        }
        
        .structured-scene-menu:hover {
            color: var(--accent-gold);
        }
        
        .structured-scene-synopsis {
            color: var(--text-secondary);
            font-size: 0.85rem;
            line-height: 1.4;
            margin-bottom: 0.5rem;
            min-height: 2.5rem;
        }
        
        .structured-scene-synopsis:empty:before {
            content: attr(data-placeholder);
            color: var(--text-muted);
        }
        
        .structured-scene-synopsis:focus {
            outline: none;
            color: var(--text-primary);
        }
        
        .structured-scene-label {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            font-size: 0.8rem;
            color: var(--text-muted);
            cursor: pointer;
        }
        
        .structured-scene-label:hover {
            color: var(--accent-gold);
        }
        
        .label-icon {
            font-size: 0.9rem;
        }
        
        .structured-add-scene-btn {
            background: transparent;
            border: 1px dashed var(--border-color);
            border-radius: 4px;
            padding: 0.75rem;
            color: var(--text-muted);
            cursor: pointer;
            font-size: 0.85rem;
            width: 100%;
            transition: all 0.2s ease;
        }
        
        .structured-add-scene-btn:hover {
            border-color: var(--accent-gold);
            color: var(--accent-gold);
            background: rgba(212, 175, 55, 0.05);
        }
        
        .structured-bottom-actions {
            display: flex;
            gap: 0.75rem;
            margin-top: 2rem;
            padding-top: 2rem;
            border-top: 1px solid var(--border-color);
        }
        
        /* Couleurs pour les cartes de scène */
        .structured-color-yellow { border-left: 3px solid #f4c430; }
        .structured-color-pink { border-left: 3px solid #ff69b4; }
        .structured-color-blue { border-left: 3px solid #4a9eff; }
        .structured-color-green { border-left: 3px solid #4caf50; }
        .structured-color-purple { border-left: 3px solid #9b59b6; }
        .structured-color-orange { border-left: 3px solid #ff8c42; }
        .structured-color-red { border-left: 3px solid #e74c3c; }
        .structured-color-teal { border-left: 3px solid #1abc9c; }
        .structured-color-default { border-left: 3px solid #3a3a3a; }

        @keyframes slideIn {
            from { transform: translateX(400px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        @keyframes slideOut {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(400px); opacity: 0; }
        }

        /* ============================================
           STYLES POUR LES NOUVELLES VISUALISATIONS
           ============================================ */

        /* Canvas pour les visualisations */
        .visualization-canvas {
            width: 100%;
            height: 600px;
            background: white;
            border: 2px solid var(--border-color);
            border-radius: 4px;
            position: relative;
            overflow: hidden;
        }

        /* Mindmap Styles */
        /* Mindmap Styles */
        .mindmap-wrapper {
            display: flex;
            height: 100%;
            width: 100%;
            overflow: hidden;
        }

        .mindmap-sidebar {
            width: 250px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        .mindmap-sidebar-header {
            padding: 1rem;
            border-bottom: 1px solid var(--border-color);
            background: var(--bg-primary);
        }

        .mindmap-list {
            flex: 1;
            overflow-y: auto;
        }

        .mindmap-item {
            padding: 0.75rem 1rem;
            cursor: pointer;
            border-bottom: 1px solid var(--border-color);
            transition: background 0.2s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .mindmap-item:hover {
            background: rgba(212, 175, 55, 0.1);
        }

        .mindmap-item.active {
            background: rgba(212, 175, 55, 0.2);
            border-left: 3px solid var(--accent-gold);
        }

        .mindmap-main {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .mindmap-toolbar {
            padding: 0.75rem 1rem;
            background: var(--bg-primary);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            gap: 0.5rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .mindmap-canvas-wrapper {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: 
                linear-gradient(90deg, rgba(212, 175, 55, 0.05) 1px, transparent 1px),
                linear-gradient(rgba(212, 175, 55, 0.05) 1px, transparent 1px);
            background-size: 20px 20px;
        }

        .mindmap-canvas {
            width: 100%;
            height: 100%;
            position: relative;
            transform-origin: 0 0;
            cursor: grab;
        }

        .mindmap-canvas.panning {
            cursor: grabbing;
        }

        .mindmap-canvas.linking {
            cursor: crosshair;
        }

        .mindmap-node {
            position: absolute;
            padding: 1rem;
            background: var(--bg-primary);
            border: 2px solid var(--accent-gold);
            border-radius: 8px;
            cursor: move;
            box-shadow: 0 2px 8px var(--shadow);
            min-width: 120px;
            max-width: 200px;
            user-select: none;
            transition: box-shadow 0.2s ease;
        }

        .mindmap-node:hover {
            box-shadow: 0 4px 16px rgba(212, 175, 55, 0.3);
            z-index: 10;
        }

        .mindmap-node.selected {
            border-color: var(--accent-red);
            box-shadow: 0 0 0 3px rgba(196, 69, 54, 0.2);
        }

        .mindmap-node.dragging {
            opacity: 0.7;
            cursor: grabbing;
        }

        .mindmap-node-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
            font-weight: 600;
        }

        .mindmap-node-icon {
            font-size: 1.2rem;
        }

        .mindmap-node-title {
            flex: 1;
            font-size: 0.9rem;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .mindmap-node-delete {
            opacity: 0;
            cursor: pointer;
            color: var(--accent-red);
            font-size: 1.2rem;
            line-height: 1;
            transition: opacity 0.2s ease;
        }

        .mindmap-node:hover .mindmap-node-delete {
            opacity: 1;
        }

        .mindmap-node-link-btn {
            opacity: 0;
            cursor: pointer;
            color: var(--accent-gold);
            font-size: 1rem;
            line-height: 1;
            transition: opacity 0.2s ease;
            margin-right: 0.25rem;
        }

        .mindmap-node:hover .mindmap-node-link-btn {
            opacity: 1;
        }

        .mindmap-node-link-btn:hover {
            transform: scale(1.2);
        }

        .mindmap-node.linking-source {
            border-color: var(--accent-red);
            box-shadow: 0 0 0 3px rgba(196, 69, 54, 0.3);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 0 3px rgba(196, 69, 54, 0.3); }
            50% { box-shadow: 0 0 0 6px rgba(196, 69, 54, 0.1); }
        }

        @keyframes pulse-text {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .mindmap-canvas-wrapper.linking-mode {
            cursor: crosshair;
        }

        .mindmap-canvas-wrapper.linking-mode .mindmap-node:not(.linking-source) {
            cursor: pointer;
        }

        .mindmap-canvas-wrapper.linking-mode .mindmap-node:not(.linking-source):hover {
            box-shadow: 0 0 0 3px rgba(74, 158, 255, 0.5);
            border-color: var(--accent-blue);
        }

        .mindmap-node-content {
            font-size: 0.85rem;
            color: var(--text-secondary);
            line-height: 1.4;
        }

        .mindmap-node.type-character {
            border-color: var(--accent-red);
            background: rgba(196, 69, 54, 0.05);
        }

        .mindmap-node.type-element {
            border-color: #4caf50;
            background: rgba(76, 175, 80, 0.05);
        }

        .mindmap-node.type-scene {
            border-color: #2196f3;
            background: rgba(33, 150, 243, 0.05);
        }

        .mindmap-node.type-note {
            border-color: var(--accent-gold);
            background: var(--bg-primary);
        }

        .mindmap-node.type-codex {
            border-color: var(--accent-purple);
            background: rgba(167, 139, 250, 0.05);
        }

        .mindmap-node.type-act {
            border-color: var(--primary-color);
            background: rgba(255, 140, 66, 0.08);
        }

        .mindmap-node.type-chapter {
            border-color: var(--accent-blue);
            background: rgba(74, 158, 255, 0.05);
        }

        .mindmap-link-line {
            position: absolute;
            pointer-events: stroke;
            cursor: pointer;
        }

        .mindmap-link-label {
            position: absolute;
            padding: 0.25rem 0.5rem;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 0.75rem;
            white-space: nowrap;
            pointer-events: none;
            transform: translate(-50%, -50%);
        }

        .mindmap-library {
            width: 250px;
            background: var(--bg-secondary);
            border-left: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .mindmap-library.collapsed {
            width: 40px;
        }

        .mindmap-library-toggle {
            padding: 0.75rem;
            text-align: center;
            cursor: pointer;
            border-bottom: 1px solid var(--border-color);
            background: var(--bg-primary);
            font-size: 1.2rem;
        }

        .mindmap-library-tabs {
            display: flex;
            border-bottom: 1px solid var(--border-color);
        }

        .mindmap-library.collapsed .mindmap-library-tabs {
            display: none;
        }

        .mindmap-library-tab {
            flex: 1;
            padding: 0.5rem;
            text-align: center;
            cursor: pointer;
            font-size: 0.85rem;
            border-right: 1px solid var(--border-color);
            transition: background 0.2s ease;
        }

        .mindmap-library-tab:last-child {
            border-right: none;
        }

        .mindmap-library-tab:hover {
            background: rgba(212, 175, 55, 0.1);
        }

        .mindmap-library-tab.active {
            background: var(--accent-gold);
            color: white;
            font-weight: 600;
        }

        .mindmap-library-content {
            flex: 1;
            overflow-y: auto;
            padding: 0.5rem;
        }

        .mindmap-library.collapsed .mindmap-library-content {
            display: none;
        }

        .mindmap-library-item {
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: grab;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .mindmap-library-item:hover {
            border-color: var(--accent-gold);
            box-shadow: 0 2px 8px var(--shadow);
        }

        .mindmap-library-item:active {
            cursor: grabbing;
        }

        .mindmap-library-item-icon {
            font-size: 1.2rem;
        }

        .mindmap-library-item-text {
            flex: 1;
            font-size: 0.85rem;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .mindmap-empty {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: var(--text-muted);
            padding: 2rem;
            text-align: center;
        }

        .mindmap-empty-icon {
            font-size: 4rem;
            margin-bottom: 1rem;
            opacity: 0.3;
        }

        /* Storage Quota Badge Styles */
        .storage-badge {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 12px 18px;
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: 25px;
            font-size: 13px;
            font-weight: 600;
            color: var(--text-primary);
            box-shadow: 0 4px 12px var(--shadow);
            z-index: 10001;
            transition: all 0.3s;
            cursor: pointer;
            display: none;
            align-items: center;
            gap: 8px;
            min-width: 120px;
            -webkit-tap-highlight-color: transparent;
        }
        
        /* Version header du badge de stockage */
        .storage-badge-header {
            padding: 6px 12px;
            background: var(--bg-secondary);
            border: 1.5px solid var(--border-color);
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-primary);
            transition: all 0.2s;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            -webkit-tap-highlight-color: transparent;
        }
        
        .storage-badge-header:hover {
            border-color: var(--accent-gold);
            background: var(--bg-tertiary);
        }
        
        .storage-badge-header .storage-icon {
            font-size: 14px;
            line-height: 1;
        }
        
        .storage-badge-header.status-ok {
            border-color: #4caf50;
        }

        .storage-badge-header.status-warning {
            border-color: #ffc107;
        }

        .storage-badge-header.status-danger {
            border-color: #f44336;
        }

        .storage-badge:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px var(--shadow);
            border-color: var(--accent-gold);
        }

        .storage-badge:active {
            transform: translateY(0);
        }

        .storage-icon {
            font-size: 18px;
            line-height: 1;
        }

        .storage-badge.status-ok {
            border-color: #4caf50;
        }

        .storage-badge.status-warning {
            border-color: #ffc107;
            animation: pulse-warning 2s infinite;
        }

        .storage-badge.status-danger {
            border-color: #f44336;
            animation: pulse-danger 1.5s infinite;
        }

        @keyframes pulse-warning {
            0%, 100% {
                box-shadow: 0 4px 12px var(--shadow);
            }
            50% {
                box-shadow: 0 4px 20px rgba(255, 193, 7, 0.4);
            }
        }

        @keyframes pulse-danger {
            0%, 100% {
                box-shadow: 0 4px 12px var(--shadow);
            }
            50% {
                box-shadow: 0 4px 20px rgba(244, 67, 54, 0.5);
            }
        }

        .storage-details-modal .modal-content {
            max-width: 500px;
        }

        .storage-info {
            margin: 20px 0;
        }

        .storage-bar {
            width: 100%;
            height: 30px;
            background: var(--bg-tertiary);
            border-radius: 15px;
            overflow: hidden;
            margin: 15px 0;
            position: relative;
        }

        .storage-bar-fill {
            height: 100%;
            transition: width 0.5s ease, background-color 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            color: white;
        }

        .storage-bar-fill.ok {
            background: linear-gradient(90deg, #4caf50, #20c997);
        }

        .storage-bar-fill.warning {
            background: linear-gradient(90deg, #ffc107, #ffb800);
        }

        .storage-bar-fill.danger {
            background: linear-gradient(90deg, #f44336, #c62828);
        }

        .storage-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 20px 0;
        }

        .storage-stat {
            background: var(--bg-tertiary);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .storage-stat-label {
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 5px;
        }

        .storage-stat-value {
            font-size: 20px;
            font-weight: bold;
            color: var(--accent-gold);
        }

        .storage-recommendations {
            background: var(--bg-tertiary);
            padding: 15px;
            border-radius: 8px;
            border-left: 3px solid var(--accent-gold);
            margin: 20px 0;
        }

        .storage-recommendations h4 {
            color: var(--accent-gold);
            margin-bottom: 10px;
        }

        .storage-recommendations ul {
            margin-left: 20px;
            color: var(--text-secondary);
            line-height: 1.8;
        }

        /* ============================================ */
        /* FLOATING EDITOR MENU (MOBILE) */
        /* ============================================ */
        
        #floatingEditorToggle {
            display: none;
            position: fixed;
            bottom: 0;
            right: 0;
            width: 60px;
            height: 44px;
            border-radius: 0;
            background: white;
            border: none;
            border-left: 1px solid #e0e0e0;
            border-top: 1px solid #e0e0e0;
            color: #333;
            font-size: 24px;
            cursor: pointer;
            box-shadow: -2px -2px 8px rgba(0,0,0,0.1);
            z-index: 10002;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #floatingEditorToggle:active {
            transform: scale(0.95);
            background: #f5f5f5;
        }
            height: 44px;
            padding: 0 16px;
            background: white;
            border: none;
            border-top: 1px solid #e0e0e0;
            border-left: 1px solid #e0e0e0;
            border-radius: 8px 0 0 0;
            color: #333;
            font-size: 20px;
            cursor: pointer;
            box-shadow: -2px -2px 10px rgba(0,0,0,0.05);
            z-index: 10002;
            transition: all 0.2s ease;
            align-items: center;
            justify-content: center;
        }

        #floatingEditorToggle:active {
            background: #f0f0f0;
        }

        #floatingEditorMenu {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 60px;
            background: white;
            border-top: 1px solid #e0e0e0;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.05);
            z-index: 10001;
            overflow: visible;
            padding: 0;
            flex-direction: column-reverse;
        }

        #floatingEditorMenu.active {
            display: flex;
        }

        #floatingMenuHandle {
            display: none;
        }

        #floatingMenuContent {
            padding: 6px 12px;
            background: white;
            display: flex;
            gap: 8px;
            align-items: center;
            justify-content: flex-start;
            overflow-x: auto;
            overflow-y: hidden;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none;
            height: 44px;
        }

        #floatingMenuContent::-webkit-scrollbar {
            display: none;
        }
        
        /* Barre de sous-menu avancé */
        #advancedMenuBar {
            padding: 6px 12px;
            background: white;
            display: none !important;
            gap: 8px;
            align-items: center;
            justify-content: flex-start;
            overflow-x: auto;
            overflow-y: hidden;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none;
            height: 44px;
            border-bottom: 1px solid #e0e0e0;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
            width: 100%;
        }
        
        #advancedMenuBar::-webkit-scrollbar {
            display: none;
        }
        
        #floatingEditorMenu #advancedMenuBar.active {
            display: flex !important;
        }

        .floating-toolbar-row {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .floating-btn-mini {
            min-width: 36px;
            height: 36px;
            padding: 0;
            background: transparent;
            border: none;
            color: #333;
            cursor: pointer;
            transition: all 0.15s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: 400;
            position: relative;
            flex-shrink: 0;
        }

        .floating-btn-mini:active {
            background: #f0f0f0;
            border-radius: 6px;
        }

        .floating-select-mini {
            height: 36px;
            padding: 0 28px 0 10px;
            background: transparent;
            border: none;
            color: #333;
            font-size: 15px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            cursor: pointer;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg width='10' height='6' viewBox='0 0 10 6' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 1L5 5L9 1' stroke='%23666' stroke-width='1.5' stroke-linecap='round'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 8px center;
            flex-shrink: 0;
        }

        .floating-select-mini:active {
            background-color: #f0f0f0;
            border-radius: 6px;
        }

        .floating-divider {
            width: 1px;
            height: 24px;
            background: #e0e0e0;
            flex-shrink: 0;
        }

        /* Storage icon mobile - déjà géré dans la media query principale */
        /* Link Editor Modal */
        .link-editor-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }

        .link-editor-modal {
            background: var(--bg-primary);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            padding: 1.5rem;
            min-width: 400px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .link-editor-header {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--text-primary);
        }

        .link-editor-field {
            margin-bottom: 1rem;
        }

        .link-editor-label {
            display: block;
            font-size: 0.85rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: var(--text-secondary);
        }

        .link-editor-input {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-family: inherit;
            font-size: 0.9rem;
        }

        .link-editor-colors {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .link-color-option {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.2s ease;
        }

        .link-color-option:hover {
            transform: scale(1.1);
        }

        .link-color-option.selected {
            border-color: var(--text-primary);
            box-shadow: 0 0 0 2px var(--bg-primary), 0 0 0 4px var(--text-primary);
        }

        .link-editor-buttons {
            display: flex;
            gap: 0.5rem;
            margin-top: 1.5rem;
        }

        /* Relation Graph Styles */
        .relation-graph {
            width: 100%;
            height: 100%;
            position: relative;
        }

        .relation-node {
            position: absolute;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: var(--bg-primary);
            border: 3px solid var(--accent-gold);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 4px 12px var(--shadow);
        }

        .relation-node:hover {
            transform: scale(1.2);
            z-index: 100;
        }

        .relation-node-avatar {
            font-size: 2rem;
        }

        .relation-node-label {
            position: absolute;
            bottom: -25px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.85rem;
            font-weight: 600;
            white-space: nowrap;
            background: white;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            box-shadow: 0 2px 4px var(--shadow);
        }

        .relation-legend {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: white;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 1rem;
            box-shadow: 0 4px 12px var(--shadow);
        }

        .relation-legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
            font-size: 0.85rem;
        }

        .relation-legend-line {
            width: 30px;
            height: 3px;
        }

        /* Timeline Viz Styles */
        .timeline-viz-container {
            width: 100%;
            padding: 2rem;
            overflow-x: auto;
        }

        .timeline-viz {
            display: flex;
            position: relative;
            min-width: 100%;
            padding: 2rem 0;
        }

        .timeline-viz-line {
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 4px;
            background: var(--accent-gold);
            transform: translateY(-50%);
        }

        .timeline-viz-item {
            position: relative;
            flex: 0 0 200px;
            padding: 0 1rem;
        }

        .timeline-viz-marker {
            width: 20px;
            height: 20px;
            background: var(--accent-gold);
            border: 4px solid white;
            border-radius: 50%;
            margin: 0 auto;
            position: relative;
            z-index: 2;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .timeline-viz-marker:hover {
            transform: scale(1.5);
            background: var(--accent-red);
        }

        .timeline-viz-content {
            background: white;
            border: 2px solid var(--border-color);
            border-radius: 4px;
            padding: 1rem;
            margin-top: 2rem;
            box-shadow: 0 4px 12px var(--shadow);
            transition: all 0.2s ease;
        }

        .timeline-viz-content:hover {
            border-color: var(--accent-gold);
            transform: translateY(-4px);
        }

        .timeline-viz-date {
            font-size: 0.8rem;
            color: var(--text-muted);
            margin-bottom: 0.5rem;
        }

        .timeline-viz-title {
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
        }

        .timeline-viz-description {
            font-size: 0.85rem;
            color: var(--text-secondary);
            line-height: 1.4;
        }

        /* Metro Timeline Styles */
        .metro-timeline-container {
            width: 100%;
            min-height: 500px;
            overflow-x: auto;
            overflow-y: auto;
            background: var(--bg-primary);
            border-radius: 8px;
            position: relative;
        }

        .metro-timeline-wrapper {
            display: flex;
            min-width: max-content;
            padding: 2rem;
        }

        .metro-characters-column {
            flex: 0 0 180px;
            padding-right: 1rem;
            border-right: 2px solid var(--border-color);
            position: sticky;
            left: 0;
            background: var(--bg-primary);
            z-index: 10;
        }

        .metro-character-row {
            height: 60px;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem;
            border-radius: 4px;
            margin-bottom: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .metro-character-row:hover {
            background: var(--bg-secondary);
        }

        .metro-character-color {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 3px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            cursor: pointer;
            transition: transform 0.2s;
        }

        .metro-character-color:hover {
            transform: scale(1.2);
        }

        .metro-character-name {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 120px;
        }

        .metro-events-area {
            flex: 1;
            position: relative;
            min-width: 600px;
        }

        .metro-svg-container {
            display: block;
            min-height: 400px;
        }

        .metro-timeline-container svg {
            display: block;
        }

        .metro-event-node {
            cursor: pointer;
            transition: all 0.2s;
        }

        .metro-event-node:hover circle {
            r: 14;
        }

        .metro-event-node:hover .metro-event-label {
            font-weight: 700;
        }

        .metro-event-label {
            font-size: 11px;
            fill: var(--text-primary);
            pointer-events: none;
        }

        .metro-line {
            fill: none;
            stroke-width: 4;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        .metro-toolbar {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-bottom: 1rem;
            padding: 1rem;
            background: var(--bg-secondary);
            border-radius: 8px;
        }

        .metro-toolbar .btn {
            font-size: 0.85rem;
            padding: 0.5rem 1rem;
        }

        /* Metro Event Modal */
        .metro-event-form {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .metro-characters-selector {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 0.5rem;
        }

        .metro-char-option {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .metro-char-option:hover {
            background: var(--bg-secondary);
        }

        .metro-char-option.selected {
            background: var(--accent-blue-light, #e3f2fd);
            border: 1px solid var(--accent-blue);
        }

        .metro-char-option input[type="checkbox"] {
            margin: 0;
        }

        .metro-char-color-dot {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .metro-linked-chars {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .metro-linked-char-tag {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.25rem 0.5rem;
            border-radius: 12px;
            font-size: 0.8rem;
            color: white;
        }

        .metro-linked-char-tag .remove-char {
            cursor: pointer;
            opacity: 0.8;
            margin-left: 0.25rem;
        }

        .metro-linked-char-tag .remove-char:hover {
            opacity: 1;
        }

        .metro-empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 400px;
            color: var(--text-muted);
            text-align: center;
            padding: 2rem;
        }

        .metro-empty-state i {
            font-size: 4rem;
            margin-bottom: 1rem;
            opacity: 0.3;
        }

        .metro-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            padding: 1rem;
            background: var(--bg-secondary);
            border-radius: 8px;
            margin-top: 1rem;
        }

        .metro-legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.85rem;
        }

        .metro-legend-line {
            width: 30px;
            height: 4px;
            border-radius: 2px;
        }

        /* Metro Events Sortable List */
        .metro-events-sortable {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .metro-event-item {
            display: flex;
            align-items: stretch;
            background: var(--bg-primary);
            border-radius: 4px;
            font-size: 0.85rem;
            cursor: grab;
            transition: all 0.2s;
            border: 2px solid transparent;
        }

        .metro-event-item:hover {
            border-color: var(--border-color);
        }

        .metro-event-item.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }

        .metro-event-item.drag-over {
            border-color: var(--accent-blue);
            background: var(--accent-blue-light, #e3f2fd);
        }

        .metro-event-reorder-btns {
            display: flex;
            flex-direction: column;
            gap: 2px;
            padding: 0.25rem;
        }

        .metro-reorder-btn {
            width: 22px;
            height: 22px;
            border: none;
            background: var(--bg-secondary);
            color: var(--text-muted);
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
        }

        .metro-reorder-btn:hover:not(:disabled) {
            background: var(--accent-blue);
            color: white;
        }

        .metro-reorder-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .metro-event-item-content {
            flex: 1;
            padding: 0.5rem;
            padding-left: 0;
            cursor: pointer;
        }

        .metro-event-item-content:hover {
            background: var(--bg-secondary);
            border-radius: 0 4px 4px 0;
        }

        .metro-drop-indicator {
            height: 3px;
            background: var(--accent-blue);
            border-radius: 2px;
            margin: 2px 0;
        }

        /* Plot Graph Styles */
        .plot-graph {
            width: 100%;
            height: 100%;
            padding: 2rem;
        }

        .plot-legend {
            position: absolute;
            top: 2rem;
            right: 2rem;
            background: white;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 1rem;
            box-shadow: 0 4px 12px var(--shadow);
        }

        /* Map Styles */
        .world-map-container {
            width: 100%;
            height: 100%;
            position: relative;
            overflow: auto;
            background: #f0e6d2;
            background-image: 
                repeating-linear-gradient(0deg, transparent, transparent 20px, rgba(0,0,0,0.03) 20px, rgba(0,0,0,0.03) 21px),
                repeating-linear-gradient(90deg, transparent, transparent 20px, rgba(0,0,0,0.03) 20px, rgba(0,0,0,0.03) 21px);
        }

        .world-map {
            min-width: 100%;
            min-height: 100%;
            position: relative;
            cursor: grab;
        }

        .world-map:active {
            cursor: grabbing;
        }

        .map-location {
            position: absolute;
            width: 40px;
            height: 40px;
            background: var(--accent-red);
            border: 3px solid white;
            border-radius: 50% 50% 50% 0;
            transform: rotate(-45deg);
            cursor: pointer;
            box-shadow: 0 4px 12px var(--shadow);
            transition: all 0.2s ease;
        }

        .map-location:hover {
            transform: rotate(-45deg) scale(1.2);
            z-index: 100;
        }

        .map-location::after {
            content: attr(data-label);
            position: absolute;
            top: 45px;
            left: 50%;
            transform: translateX(-50%) rotate(45deg);
            background: white;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.85rem;
            font-weight: 600;
            white-space: nowrap;
            box-shadow: 0 2px 8px var(--shadow);
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .map-location:hover::after {
            opacity: 1;
        }

        .map-upload-zone {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border: 3px dashed var(--border-color);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .map-upload-zone:hover {
            border-color: var(--accent-gold);
            background: rgba(212, 175, 55, 0.05);
        }

        .map-upload-icon {
            font-size: 4rem;
            margin-bottom: 1rem;
            opacity: 0.5;
        }

        .map-uploaded-image {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        /* Toolbar pour les visualisations */
        .visualization-toolbar {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
            padding: 1rem;
            background: var(--bg-secondary);
            border-radius: 4px;
        }

        .viz-tool-btn {
            padding: 0.5rem 1rem;
            background: white;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Crimson Pro', serif;
            font-size: 0.9rem;
            transition: all 0.2s ease;
        }

        .viz-tool-btn:hover {
            background: var(--accent-gold);
            color: white;
            border-color: var(--accent-gold);
        }

        .viz-tool-btn.active {
            background: var(--accent-gold);
            color: white;
            border-color: var(--accent-gold);
        }

        /* ========================================
           RESPONSIVE DESIGN - MOBILE & TABLET
           ======================================== */

        /* Mobile Menu Handle (poignée latérale) */
        /* Mobile Menu Handle (poignée latérale) - Style blanc épuré */
        .mobile-menu-handle {
            display: none;
            position: fixed;
            top: 50%;
            left: 0;
            transform: translateY(-50%);
            width: 24px;
            height: 100px;
            background: white;
            border-radius: 0 12px 12px 0;
            cursor: pointer;
            z-index: 10003;
            transition: all 0.3s ease;
            box-shadow: 2px 0 12px rgba(0,0,0,0.15);
            border: 1px solid rgba(0,0,0,0.1);
            border-left: none;
        }

        .mobile-menu-handle::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 2px;
            height: 50px;
            background: linear-gradient(to bottom, 
                rgba(0,0,0,0.1) 0%, 
                rgba(0,0,0,0.3) 50%, 
                rgba(0,0,0,0.1) 100%);
            border-radius: 1px;
        }

        .mobile-menu-handle::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 8px;
            height: 8px;
            background: rgba(0,0,0,0.2);
            border-radius: 50%;
        }

        .mobile-menu-handle:active {
            transform: translateY(-50%) translateX(6px);
            box-shadow: 1px 0 8px rgba(0,0,0,0.1);
        }

        .mobile-menu-handle.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .mobile-menu-toggle:active {
            transform: scale(0.95);
        }

        /* Mobile Navigation Dropdown */
        .mobile-nav-dropdown {
            display: none;
            position: fixed;
            top: 56px;
            left: 0;
            right: 0;
            background: var(--bg-secondary);
            border-bottom: 2px solid var(--accent-gold);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            z-index: 9999;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .mobile-nav-dropdown.active {
            max-height: 80vh;
            overflow-y: auto;
        }

        .mobile-nav-section {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--border-color);
        }

        .mobile-nav-section-title {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 0.5rem;
        }

        .mobile-nav-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 1rem;
            color: var(--text-primary);
            background: transparent;
            border: none;
            width: 100%;
            text-align: left;
        }

        .mobile-nav-item:active {
            background: var(--accent-gold);
            color: white;
        }

        .mobile-nav-item.active {
            background: var(--accent-gold);
            color: white;
            font-weight: 600;
        }

        .mobile-nav-item-icon {
            font-size: 1.3rem;
            width: 28px;
            text-align: center;
        }

        .mobile-nav-toggle-btn {
            display: none;
            position: absolute;
            right: 1rem;
            top: 50%;
            transform: translateY(-50%);
            background: var(--accent-gold);
            color: white;
            border: none;
            border-radius: 6px;
            width: 36px;
            height: 36px;
            font-size: 1.2rem;
            cursor: pointer;
            z-index: 1001;
        }

        .mobile-nav-toggle-btn:active {
            opacity: 0.7;
        }

        /* Collapsible Editor Toolbar on Mobile */
        .toolbar-mobile-toggle {
            display: none;
            width: 100%;
            padding: 0.5rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 0.9rem;
            color: var(--text-primary);
            cursor: pointer;
            margin-bottom: 0.5rem;
            text-align: center;
            font-weight: 600;
        }

        .toolbar-mobile-toggle:active {
            background: var(--accent-gold);
            color: white;
        }

        /* Mobile Sidebar Overlay */
        .sidebar-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 10001;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .sidebar-overlay.active {
            opacity: 1;
        }

        /* Tablet styles (landscape phones and portrait tablets) */
        @media (max-width: 1024px) {
            .app-header {
                padding: 0 1rem;
                gap: 1rem;
            }

            .app-logo {
                font-size: 1.1rem;
            }

            .header-nav {
                gap: 0.25rem;
            }

            .nav-btn {
                padding: 0.5rem 0.75rem;
                font-size: 0.85rem;
            }

            .header-actions {
                gap: 0.25rem;
            }

            .header-action-btn {
                width: 36px;
                height: 36px;
                font-size: 1.1rem;
            }

            .app-container {
                grid-template-columns: 240px 1fr;
            }

            .sidebar {
                width: 240px;
            }

            .modal-content {
                max-width: 90%;
                margin: 2rem auto;
            }
            
            /* Masquer le texte des boutons scene-tools sur tablette */
            .scene-tool-btn span:not(.scene-tool-badge) {
                display: none;
            }
        }

        /* Force mobile nav quand le header déborde */
        body.force-mobile-nav .header-nav {
            display: none !important;
        }
        
        body.force-mobile-nav .mobile-nav-toggle-btn {
            display: block !important;
        }
        
        body.force-mobile-nav .mobile-nav-dropdown {
            display: block !important;
        }
        
        body.force-mobile-nav #headerStatsContainer {
            display: none !important;
        }
        
        body.force-mobile-nav .header-actions {
            gap: 0.35rem;
            margin-right: 3.5rem !important;
        }
        
        body.force-mobile-nav .split-mode-toggle span {
            display: none;
        }

        /* Mobile styles (phones) */
        /* ============================================ */
        /* RESPONSIVE - MOBILE FIRST */
        /* ============================================ */
        
        /* MOBILE (< 900px) */
        @media (max-width: 900px) {
            /* Layout Mobile */
            .app-content {
                flex-direction: column;
            }
            
            /* Sidebar versions en overlay sur mobile */
            .sidebar-versions {
                position: fixed !important;
                top: 0 !important;
                right: 0 !important;
                bottom: 0 !important;
                left: 0 !important;
                width: 100% !important;
                height: 100% !important;
                z-index: 10000 !important;
                background: var(--bg-primary) !important;
                transform: translateX(100%);
                transition: transform 0.3s ease;
            }
            
            .sidebar-versions:not(.hidden) {
                transform: translateX(0);
            }
            
            .sidebar-versions.hidden {
                display: block !important;
                transform: translateX(100%);
            }
            
            .sidebar-versions {
                padding-bottom: calc(60px + env(safe-area-inset-bottom, 20px));
            }
            
            .sidebar-versions-header {
                padding: 1rem;
                border-bottom: 2px solid var(--primary-color);
            }
            
            .sidebar-versions-toggle {
                font-size: 1.5rem;
                padding: 0.5rem;
            }

            /* Header Mobile */
            .app-header {
                height: 56px;
                padding: 0 1rem;
                gap: 1rem;
            }

            .app-logo {
                font-size: 1.1rem;
            }

            .app-logo-icon {
                font-size: 1.3rem;
            }

            /* Cacher navigation desktop */
            .header-nav {
                display: none !important;
            }

            /* Afficher toggle navigation mobile */
            .mobile-nav-toggle-btn {
                display: block;
            }
            
            /* Afficher le bouton ✏️ flottant en mobile */
            #floatingEditorToggle {
                display: flex !important;
            }

            /* Afficher la poignée latérale sur mobile */
            .mobile-menu-handle {
                display: block;
            }

            .mobile-nav-dropdown {
                display: block;
            }

            /* Cacher stats et boutons secondaires sur mobile */
            #headerStatsContainer,
            #headerUndoBtn,
            #headerRedoBtn,
            #storage-badge,
            #pomodoroHeaderBtn {
                display: none !important;
            }
            
            /* Header actions mobile - compacts et alignés */
            .header-actions {
                gap: 0.35rem;
                margin-left: auto;
                margin-right: 3.5rem !important;
            }
            
            .header-action-btn {
                width: 32px;
                height: 32px;
                padding: 0;
                font-size: 0.9rem;
            }
            
            /* Split toggle plus compact sur mobile */
            .split-mode-toggle {
                padding: 0.35rem 0.6rem;
                font-size: 0.75rem;
                gap: 0.25rem;
            }
            
            .split-mode-toggle span {
                display: none;
            }
            
            /* Logo plus compact */
            .app-logo {
                font-size: 0.95rem;
                max-width: 140px;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
            }
            
            .app-logo-icon {
                font-size: 1.1rem;
                flex-shrink: 0;
            }

            /* Sidebar Mobile - en overlay */
            .sidebar {
                position: fixed;
                top: 56px;
                left: -100%;
                width: 85%;
                max-width: 320px;
                height: calc(100vh - 56px);
                z-index: 10002;
                transition: left 0.3s ease;
                box-shadow: 2px 0 12px rgba(0,0,0,0.2);
                background: var(--bg-secondary);
                overflow-y: auto;
                padding-bottom: calc(60px + env(safe-area-inset-bottom, 20px));
            }

            .sidebar.mobile-open {
                left: 0;
            }
            
            /* Padding pour les listes de la sidebar sur mobile */
            .chapters-list,
            .database-list {
                padding-bottom: calc(80px + env(safe-area-inset-bottom, 20px));
            }
            
            .sidebar-actions {
                padding-bottom: calc(1rem + env(safe-area-inset-bottom, 20px));
            }
            
            /* Sidebar Structure - Optimisation mobile */
            .status-filters {
                padding: 0.3rem 0.5rem;
                gap: 0.25rem;
                flex-wrap: wrap;
            }
            
            .status-filter-btn {
                padding: 0.2rem 0.4rem;
                font-size: 0.6rem;
                gap: 0.15rem;
            }
            
            .status-filter-btn span:not(.status-filter-dot):not(.status-filter-count) {
                display: none; /* Cacher le texte, garder seulement le point et le count */
            }
            
            .status-filter-dot {
                width: 6px;
                height: 6px;
            }
            
            .status-filter-count {
                font-size: 0.55rem;
                padding: 0 0.2rem;
            }
            
            .scene-tools {
                padding: 0.3rem 0.5rem;
                gap: 0.25rem;
                flex-wrap: wrap;
            }
            
            .scene-tool-btn {
                padding: 0.25rem 0.4rem;
                font-size: 0.65rem;
                gap: 0.2rem;
            }
            
            .scene-tool-btn span {
                display: none;
            }
            
            .scene-tool-btn i {
                width: 14px !important;
                height: 14px !important;
            }
            
            .tree-collapse-toolbar {
                padding: 0.2rem 0.5rem;
                gap: 0.15rem;
            }
            
            .tree-collapse-btn {
                padding: 0.15rem 0.35rem;
                font-size: 0.6rem;
                gap: 0.15rem;
            }
            
            /* Treeview ULTRA compact sur mobile */
            .act-group {
                margin-bottom: 0.1rem;
            }
            
            .act-header {
                padding: 0.15rem 0.3rem;
                font-size: 0.7rem;
                gap: 0.15rem;
                min-height: 24px;
            }
            
            .act-icon {
                font-size: 0.5rem;
                width: 8px;
            }
            
            .act-title {
                font-size: 0.65rem;
            }
            
            .act-chapters {
                padding-left: 0.15rem;
            }
            
            .chapter-group {
                margin-bottom: 0;
            }
            
            .chapter-header {
                padding: 0.1rem 0.3rem;
                font-size: 0.65rem;
                gap: 0.15rem;
                min-height: 22px;
            }
            
            .chapter-icon {
                font-size: 0.45rem;
                width: 6px;
            }
            
            .chapter-title {
                font-size: 0.65rem;
            }
            
            .scenes-list {
                padding-left: 0.4rem;
            }
            
            .scene-item {
                padding: 0.08rem 0.3rem;
                font-size: 0.65rem;
                gap: 0.15rem;
                min-height: 20px;
            }
            
            .auto-number {
                font-size: 0.5rem;
                min-width: 20px;
                margin-right: 0.1rem;
            }
            
            .word-count-badge {
                font-size: 0.45rem;
                padding: 0 0.15rem;
            }
            
            .status-badge {
                width: 6px;
                height: 6px;
            }
            
            .drag-handle {
                padding: 0 0.1rem;
                font-size: 0.5rem;
            }
            
            .delete-btn {
                width: 14px !important;
                height: 14px !important;
                font-size: 0.6rem !important;
                padding: 0 !important;
            }
            
            .edit-hint {
                display: none;
            }
            
            .chapter-count {
                font-size: 0.5rem;
            }
            
            /* Barre de progression mobile */
            .sidebar-progress-info {
                padding: 0.25rem 0.5rem;
                font-size: 0.6rem;
            }
            
            /* Search bar mobile */
            .search-container {
                padding: 0.3rem 0.5rem;
                margin-bottom: 0.5rem;
            }
            
            .search-container input {
                padding: 0.35rem 0.5rem;
                font-size: 0.75rem;
            }
            
            /* Stats overview compact */
            .stats-overview {
                padding: 0.5rem;
                margin-bottom: 0.5rem;
            }
            
            .stats-overview .stat-group {
                gap: 0.25rem;
            }
            
            .stats-overview .stat-badge {
                padding: 0.15rem 0.4rem;
                font-size: 0.7rem;
            }
            
            /* Toolbar collapse buttons compact */
            .tree-collapse-toolbar {
                padding: 0.25rem 0.5rem;
                margin-bottom: 0.25rem;
            }
            
            .tree-collapse-btn {
                padding: 0.25rem 0.5rem;
                font-size: 0.75rem;
                gap: 0.25rem;
            }
            
            /* Sidebar actions mobile compact */
            .sidebar-actions .btn {
                padding: 0.4rem 0.6rem;
                font-size: 0.7rem;
            }

            /* Editor full width */
            .editor-container {
                width: 100%;
            }

            /* Toolbar Desktop - masqué et remplacé par bouton toggle */
            .toolbar-mobile-toggle {
                display: block;
                width: 100%;
                padding: 12px;
                background: white;
                border: none;
                border-bottom: 1px solid var(--border-color);
                color: var(--text-primary);
                font-size: 14px;
                font-weight: 600;
                cursor: pointer;
                text-align: center;
                transition: all 0.2s ease;
            }

            .toolbar-mobile-toggle:active {
                background: var(--bg-secondary);
            }

            .toolbar-mobile-toggle .toggle-icon {
                display: inline-block;
                transition: transform 0.3s ease;
                margin-left: 0.5rem;
            }

            .toolbar-mobile-toggle.expanded .toggle-icon {
                transform: rotate(180deg);
            }

            /* Toolbar collapsible */
            .editor-toolbar {
                max-height: 0 !important;
                overflow: hidden !important;
                transition: max-height 0.3s ease;
                padding: 0 !important;
                border-bottom: none !important;
            }

            .editor-toolbar.expanded {
                max-height: 500px !important;
                overflow-y: auto !important;
                overflow-x: hidden !important;
                padding: 12px !important;
                border-bottom: 1px solid var(--border-color) !important;
                flex-wrap: wrap !important;
            }

            /* Menu flottant mobile visible */
            #floatingEditorToggle {
                display: flex;
            }

            /* Editor content */
            .editor-content {
                padding: 1.5rem;
            }

            .editor-textarea {
                font-size: 1rem;
                line-height: 1.7;
            }
            
            /* Editor header mobile */
            .editor-header {
                padding: 1rem 1rem 0.75rem;
            }
            
            .editor-breadcrumb {
                font-size: 0.75rem;
                margin-bottom: 0.5rem;
            }
            
            .editor-title {
                font-size: 1.4rem;
            }
            
            .editor-meta {
                flex-wrap: wrap;
                gap: 0.5rem 1rem;
                font-size: 0.75rem;
            }
            
            /* Bouton Focus plus compact */
            .editor-header .btn-small,
            .editor-header .btn {
                padding: 0.4rem 0.6rem;
                font-size: 0.75rem;
            }
            
            /* Links panel toggle - comme toolbar */
            .links-panel-toggle {
                display: block;
                width: 100%;
                padding: 12px;
                background: white;
                border: none;
                border-bottom: 1px solid var(--border-color);
                color: var(--text-primary);
                font-size: 14px;
                font-weight: 600;
                cursor: pointer;
                text-align: center;
                transition: all 0.2s ease;
            }

            .links-panel-toggle:active {
                background: var(--bg-secondary);
            }

            /* Links panel collapsible - comme toolbar */
            #linksPanel {
                max-height: 0;
                overflow: hidden;
                transition: max-height 0.3s ease;
                padding: 0 1rem;
                border-bottom: none;
            }

            #linksPanel.expanded {
                max-height: 500px;
                overflow-y: auto;
                padding: 0.75rem 1rem;
                border-bottom: 1px solid var(--border-color);
            }
            
            .links-panel-sticky > div {
                flex-direction: column;
                gap: 0.75rem !important;
            }
            
            .quick-links {
                flex-wrap: wrap;
                gap: 0.4rem;
            }
            
            .link-badge {
                font-size: 0.75rem;
                padding: 0.25rem 0.5rem;
            }

            /* Modals */
            .modal-content {
                width: 95%;
                max-width: 95%;
                margin: 1rem;
                max-height: 90vh;
            }

            /* Boutons */
            .btn {
                padding: 0.7rem 1rem;
                font-size: 15px;
                touch-action: manipulation;
            }

            /* Formulaires */
            .form-input,
            .form-textarea {
                font-size: 16px; /* Évite le zoom sur iOS */
            }

            /* Storage badge */
            .storage-badge {
                bottom: 60px;
                right: 15px;
                font-size: 11px;
                min-width: 80px;
                min-height: 40px;
                padding: 8px 12px;
            }
        }

        /* TABLETTE (901px - 1024px) */
        @media (min-width: 901px) and (max-width: 1024px) {
            .app-content {
                display: flex;
                flex-direction: row;
            }

            .sidebar {
                position: static !important;
                left: auto !important;
                width: 240px !important;
                max-width: 240px !important;
                height: auto !important;
                z-index: auto !important;
                transition: none !important;
                display: flex !important;
                flex-shrink: 0;
            }

            .mobile-menu-handle,
            .sidebar-overlay {
                display: none !important;
            }

            .editor-content {
                padding: 2rem;
            }

            .app-header {
                padding: 0 1.5rem;
            }

            .editor-toolbar {
                padding: 8px 12px;
                flex-wrap: wrap;
            }
        }

        /* DESKTOP (> 1024px) */
        @media (min-width: 1025px) {
            /* Masquer les éléments mobile */
            .mobile-nav-toggle-btn,
            .mobile-nav-dropdown,
            .toolbar-mobile-toggle,
            #floatingEditorToggle,
            #floatingEditorMenu,
            .mobile-menu-handle,
            .sidebar-overlay {
                display: none !important;
            }

            /* Afficher navigation desktop */
            .header-nav {
                display: flex !important;
            }

            /* Toolbar toujours visible */
            .editor-toolbar {
                display: flex !important;
                max-height: none !important;
                flex-wrap: wrap !important;
            }

            /* SIDEBAR DESKTOP - CRITIQUE */
            .sidebar {
                position: static !important;
                left: auto !important;
                width: 350px !important;
                max-width: 350px !important;
                height: auto !important;
                z-index: auto !important;
                transition: none !important;
                display: flex !important;
            }

            /* Grid layout desktop */
            .app-container {
                grid-template-columns: 350px 1fr !important;
                grid-template-areas:
                    "header header"
                    "sidebar main" !important;
            }
        }

        /* GRAND ÉCRAN (> 1440px) */
        @media (min-width: 1441px) {
            .editor-content {
                max-width: 850px;
            }
        }

        /* Styles additionnels pour mobile (900px) - storage badge */
        @media (max-width: 900px) {
            .storage-badge {
                bottom: 15px;
                right: 15px;
                padding: 10px 15px;
                font-size: 12px;
                min-width: 100px;
                min-height: 44px;
                z-index: 10001;
            }

            /* Scene metadata */
            .scene-metadata {
                flex-direction: column;
                gap: 0.75rem;
            }

            .metadata-item {
                width: 100%;
            }

            /* Character and element links */
            .scene-links {
                flex-direction: column;
            }

            .link-group {
                width: 100%;
            }

            /* Content editor */
            #sceneContent {
                font-size: 1rem;
                line-height: 1.6;
                padding: 1rem;
            }

            /* Sidebar actions */
            .sidebar-actions {
                flex-direction: row;
                gap: 0.25rem;
                padding: 0.5rem;
            }

            .sidebar-actions .btn {
                width: 33.333%;
                flex: 1;
                font-size: 0.8rem;
                padding: 0.5rem 0.25rem;
                white-space: nowrap;
            }

            /* Modals */
            .modal-content {
                width: 95%;
                max-width: 95%;
                margin: 1rem auto;
                max-height: 90vh;
                overflow-y: auto;
            }

            .modal-title {
                font-size: 1.3rem;
            }

            /* Boutons dans les modals - empiler verticalement sur mobile */
            .modal-button-group {
                flex-direction: column;
            }

            .modal-button-group .btn {
                width: 100%;
                min-width: unset;
                margin: 0;
            }

            .modal-button-group .btn + .btn {
                margin-top: 0.75rem;
            }

            .modal-content > div > .btn {
                display: block;
                width: 100%;
                margin: 0.5rem 0;
            }

            /* Forms */
            .form-input,
            .form-textarea {
                font-size: 16px; /* Prevents zoom on iOS */
            }

            /* Buttons */
            .btn {
                padding: 0.65rem 1rem;
                font-size: 0.95rem;
                touch-action: manipulation;
                -webkit-tap-highlight-color: transparent;
            }

            .btn-small {
                padding: 0.4rem 0.6rem;
                font-size: 0.85rem;
            }

            /* Stats cards */
            .stats-cards {
                grid-template-columns: 1fr;
                gap: 1rem;
            }

            /* Character/World cards */
            .character-card,
            .world-card {
                padding: 1rem;
            }

            /* Act/Chapter structure */
            .act-header,
            .chapter-header {
                padding: 0.5rem 0.75rem;
                min-height: unset;
            }

            .act-title,
            .chapter-title {
                font-size: 0.9rem;
                line-height: 1.3;
            }

            .scene-item {
                padding: 0.45rem 0.75rem;
                font-size: 0.85rem;
                min-height: unset;
                line-height: 1.3;
            }
            
            /* Reduce spacing in act/chapter groups */
            .act-group {
                margin-bottom: 0.5rem;
            }
            
            .chapter-group {
                margin-bottom: 0.25rem;
            }
            
            /* Compact word count badges */
            .word-count-badge {
                font-size: 0.7rem;
                padding: 0.15rem 0.4rem;
            }
            
            /* Compact status badges */
            .status-badge {
                width: 6px;
                height: 6px;
            }
            
            /* Compact chapter count */
            .chapter-count {
                font-size: 0.7rem;
                padding: 0.15rem 0.35rem;
            }

            /* Empty state */
            .empty-state {
                padding: 2rem 1rem;
            }

            .empty-state-icon {
                font-size: 3rem;
            }

            .empty-state-title {
                font-size: 1.3rem;
            }

            /* Timeline visualization */
            .timeline-item {
                padding: 1rem;
            }

            /* Cork board */
            .cork-card {
                min-width: 200px;
                font-size: 0.9rem;
            }

            /* Search */
            .search-input {
                font-size: 0.95rem;
                padding: 0.65rem 2.5rem 0.65rem 1rem;
            }

            /* Tabs */
            .tabs {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }

            .tab-btn {
                flex-shrink: 0;
                padding: 0.6rem 1rem;
                font-size: 0.9rem;
            }
        }

        /* Small mobile phones */
        @media (max-width: 480px) {
            .app-header {
                height: 52px;
                padding: 0 0.5rem;
            }

            .app-logo {
                font-size: 0.9rem;
            }

            .app-logo-icon {
                font-size: 1.1rem;
            }

            .nav-btn {
                padding: 0.35rem 0.5rem;
                font-size: 0.95rem;
            }

            .header-action-btn {
                width: 32px;
                height: 32px;
                font-size: 0.95rem;
            }

            .sidebar {
                width: 90%;
                max-width: 280px;
                top: 52px;
                height: calc(100vh - 52px);
            }

            .app-container {
                grid-template-rows: 52px 1fr;
            }

            .scene-editor {
                padding: 0.75rem;
            }

            .scene-title {
                font-size: 1.3rem;
            }

            #sceneContent {
                font-size: 0.95rem;
                padding: 0.75rem;
            }

            .mobile-menu-toggle {
                width: 52px;
                height: 52px;
                font-size: 1.3rem;
                bottom: 16px;
                right: 16px;
            }

            .modal-content {
                width: 98%;
                margin: 0.5rem auto;
                padding: 1rem;
            }

            .modal-title {
                font-size: 1.2rem;
            }

            .btn {
                padding: 0.6rem 0.85rem;
                font-size: 0.9rem;
            }
        }

        /* Landscape orientation on phones */
        @media (max-width: 900px) and (orientation: landscape) {
            .app-header {
                height: 48px;
            }

            .sidebar {
                top: 48px;
                height: calc(100vh - 48px);
            }

            .app-container {
                grid-template-rows: 48px 1fr;
            }

            .modal-content {
                max-height: 85vh;
            }

            .mobile-menu-toggle {
                width: 48px;
                height: 48px;
                bottom: 12px;
                right: 12px;
            }
        }

        /* iOS specific fixes */
        @supports (-webkit-touch-callout: none) {
            /* iOS safe area insets */
            .app-header {
                padding-top: max(env(safe-area-inset-top), 0px);
            }

            .sidebar {
                padding-bottom: max(env(safe-area-inset-bottom), 0px);
            }

            .mobile-menu-toggle {
                bottom: max(env(safe-area-inset-bottom, 20px) + 20px, 20px);
                right: max(env(safe-area-inset-right, 20px) + 20px, 20px);
            }

            /* Prevent elastic scrolling on body */
            body {
                position: fixed;
                width: 100%;
            }

            /* Fix textarea font size to prevent zoom */
            input,
            textarea,
            select {
                font-size: 16px !important;
            }
        }

        /* Android Chrome specific */
        @media screen and (-webkit-min-device-pixel-ratio: 0) {
            select,
            textarea,
            input {
                font-size: 16px;
            }
        }

        /* High DPI screens */
        @media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
            .app-header {
                border-bottom-width: 1px;
            }
        }

        /* Dark mode support (if device prefers dark) */
        @media (prefers-color-scheme: dark) {
            /* This is ready for future dark mode implementation */
        }

        /* Reduced motion for accessibility */
        @media (prefers-reduced-motion: reduce) {
            *,
            *::before,
            *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* Touch device optimizations */
        @media (hover: none) and (pointer: coarse) {
            /* Larger touch targets */
            .btn,
            .nav-btn,
            .toolbar-btn,
            button {
                min-height: 44px;
                min-width: 44px;
            }

            /* Remove hover effects on touch devices */
            .btn:hover,
            .nav-btn:hover,
            .toolbar-btn:hover {
                transform: none;
            }

            /* Add active state feedback */
            .btn:active,
            .nav-btn:active,
            .toolbar-btn:active {
                opacity: 0.7;
            }
        }
    </style>
</head>
<body>
    <!-- Mobile Menu Handle (poignée latérale) -->
    <div class="mobile-menu-handle" onclick="toggleMobileSidebar()"></div>
    
    <!-- Mobile Sidebar Overlay -->
    <div class="sidebar-overlay" onclick="toggleMobileSidebar()"></div>
    
    <!-- Mobile Navigation Dropdown (déplacé hors du grid) -->
    <div class="mobile-nav-dropdown" id="mobileNavDropdown">
        <div class="mobile-nav-section">
            <div class="mobile-nav-section-title"><i data-lucide="pen-tool"></i> Écriture</div>
            <button class="mobile-nav-item active" onclick="switchViewMobile('editor')" data-view="editor">
                <span class="mobile-nav-item-icon"><i data-lucide="pen-line"></i></span>
                <span>Structure</span>
            </button>
            <button class="mobile-nav-item" onclick="switchViewMobile('corkboard')" data-view="corkboard">
                <span class="mobile-nav-item-icon"><i data-lucide="layout-grid"></i></span>
                <span>Tableau</span>
            </button>
            <button class="mobile-nav-item" onclick="switchViewMobile('plot')" data-view="plot">
                <span class="mobile-nav-item-icon"><i data-lucide="trending-up"></i></span>
                <span>Intrigue</span>
            </button>
        </div>

        <div class="mobile-nav-section">
            <div class="mobile-nav-section-title"><i data-lucide="database"></i> Base de données</div>
            <button class="mobile-nav-item" onclick="switchViewMobile('characters')" data-view="characters">
                <span class="mobile-nav-item-icon"><i data-lucide="users"></i></span>
                <span>Personnages</span>
            </button>
            <button class="mobile-nav-item" onclick="switchViewMobile('world')" data-view="world">
                <span class="mobile-nav-item-icon"><i data-lucide="globe"></i></span>
                <span>Univers</span>
            </button>
            <button class="mobile-nav-item" onclick="switchViewMobile('codex')" data-view="codex">
                <span class="mobile-nav-item-icon"><i data-lucide="book-open"></i></span>
                <span>Codex</span>
            </button>
            <button class="mobile-nav-item" onclick="switchViewMobile('notes')" data-view="notes">
                <span class="mobile-nav-item-icon"><i data-lucide="sticky-note"></i></span>
                <span>Notes</span>
            </button>
        </div>

        <div class="mobile-nav-section">
            <div class="mobile-nav-section-title"><i data-lucide="eye"></i> Visualisation</div>
            <button class="mobile-nav-item" onclick="switchViewMobile('mindmap')" data-view="mindmap">
                <span class="mobile-nav-item-icon"><i data-lucide="git-branch"></i></span>
                <span>Mindmap</span>
            </button>
            <button class="mobile-nav-item" onclick="switchViewMobile('relations')" data-view="relations">
                <span class="mobile-nav-item-icon"><i data-lucide="link"></i></span>
                <span>Relations</span>
            </button>
            <button class="mobile-nav-item" onclick="switchViewMobile('map')" data-view="map">
                <span class="mobile-nav-item-icon"><i data-lucide="map"></i></span>
                <span>Carte</span>
            </button>
            <button class="mobile-nav-item" onclick="switchViewMobile('timelineviz')" data-view="timelineviz">
                <span class="mobile-nav-item-icon"><i data-lucide="clock"></i></span>
                <span>Timeline</span>
            </button>
        </div>

        <div class="mobile-nav-section">
            <div class="mobile-nav-section-title"><i data-lucide="wrench"></i> Outils</div>
            <button class="mobile-nav-item" onclick="switchViewMobile('stats')" data-view="stats">
                <span class="mobile-nav-item-icon"><i data-lucide="bar-chart-3"></i></span>
                <span>Stats</span>
            </button>
            <button class="mobile-nav-item" onclick="switchViewMobile('analysis')" data-view="analysis">
                <span class="mobile-nav-item-icon"><i data-lucide="scan-search"></i></span>
                <span>Analyse</span>
            </button>
        </div>

        <div class="mobile-nav-section">
            <div class="mobile-nav-section-title"><i data-lucide="history"></i> Historique</div>
            <button class="mobile-nav-item" onclick="switchViewMobile('versions')" data-view="versions">
                <span class="mobile-nav-item-icon"><i data-lucide="history"></i></span>
                <span>Snapshots</span>
            </button>
        </div>

        <div class="mobile-nav-section">
            <div class="mobile-nav-section-title"><i data-lucide="settings"></i> Actions</div>
            <button class="mobile-nav-item" onclick="openProjectsModal(); toggleMobileNav();">
                <span class="mobile-nav-item-icon"><i data-lucide="folder-open"></i></span>
                <span>Mes Projets</span>
            </button>
            <button class="mobile-nav-item" onclick="openThemeManager(); toggleMobileNav();">
                <span class="mobile-nav-item-icon"><i data-lucide="palette"></i></span>
                <span>Thèmes</span>
            </button>
            <button class="mobile-nav-item" onclick="undo(); toggleMobileNav();" id="mobileUndoBtn">
                <span class="mobile-nav-item-icon"><i data-lucide="undo-2"></i></span>
                <span>Annuler</span>
            </button>
            <button class="mobile-nav-item" onclick="redo(); toggleMobileNav();" id="mobileRedoBtn">
                <span class="mobile-nav-item-icon"><i data-lucide="redo-2"></i></span>
                <span>Rétablir</span>
            </button>
            <button class="mobile-nav-item" onclick="showBackupMenu(); toggleMobileNav();">
                <span class="mobile-nav-item-icon"><i data-lucide="download"></i></span>
                <span>Sauvegarde/Export</span>
            </button>
        </div>
    </div>
    
    <!-- Barre de progression d'écriture (mode focus) - hors du grid -->
    <div class="writing-progress-bar">
        <div class="writing-progress-fill" id="writingProgressFill"></div>
        <div class="writing-progress-text" id="positionIndicator">
            Mot 0 / 0
        </div>
    </div>
    
    <div class="app-container">
        <!-- Top Header -->
        <div class="app-header">
            <div class="app-logo" onclick="renameProject()" style="cursor: pointer;" title="Cliquer pour renommer le projet">
                <span class="app-logo-icon"><i data-lucide="feather"></i></span>
                <span id="headerProjectTitle">Plume</span>
                <i data-lucide="pencil" style="width: 12px; height: 12px; opacity: 0.5; margin-left: 4px;"></i>
            </div>

            <!-- Mobile Navigation Toggle -->
            <button class="mobile-nav-toggle-btn" onclick="toggleMobileNav()" id="mobileNavToggleBtn">
                <i data-lucide="menu"></i>
            </button>
            
            <nav class="header-nav">
                <!-- Section 1 : Structure, Tableau, Intrigue -->
                <div class="nav-group">
                    <button class="nav-btn active" onclick="switchView('editor')" id="header-tab-editor">
                        <span class="nav-btn-icon"><i data-lucide="pen-line"></i></span>
                        <span class="nav-btn-text">Structure</span>
                    </button>
                    <button class="nav-btn" onclick="switchView('corkboard')" id="header-tab-corkboard">
                        <span class="nav-btn-icon"><i data-lucide="layout-grid"></i></span>
                        <span class="nav-btn-text">Tableau</span>
                    </button>
                    <button class="nav-btn" onclick="switchView('plot')" id="header-tab-plot">
                        <span class="nav-btn-icon"><i data-lucide="trending-up"></i></span>
                        <span class="nav-btn-text">Intrigue</span>
                    </button>
                </div>
                
                <!-- Section 2 : Personnages, Univers, Codex, Notes -->
                <div class="nav-group">
                    <button class="nav-btn" onclick="switchView('characters')" id="header-tab-characters">
                        <span class="nav-btn-icon"><i data-lucide="users"></i></span>
                        <span class="nav-btn-text">Personnages</span>
                    </button>
                    <button class="nav-btn" onclick="switchView('world')" id="header-tab-world">
                        <span class="nav-btn-icon"><i data-lucide="globe"></i></span>
                        <span class="nav-btn-text">Univers</span>
                    </button>
                    <button class="nav-btn" onclick="switchView('codex')" id="header-tab-codex">
                        <span class="nav-btn-icon"><i data-lucide="book-open"></i></span>
                        <span class="nav-btn-text">Codex</span>
                    </button>
                    <button class="nav-btn" onclick="switchView('notes')" id="header-tab-notes">
                        <span class="nav-btn-icon"><i data-lucide="sticky-note"></i></span>
                        <span class="nav-btn-text">Notes</span>
                    </button>
                </div>
                
                <!-- Section 3 : Mindmap, Relations, Carte, Timeline -->
                <div class="nav-group">
                    <button class="nav-btn" onclick="switchView('mindmap')" id="header-tab-mindmap">
                        <span class="nav-btn-icon"><i data-lucide="git-branch"></i></span>
                        <span class="nav-btn-text">Mindmap</span>
                    </button>
                    <button class="nav-btn" onclick="switchView('relations')" id="header-tab-relations">
                        <span class="nav-btn-icon"><i data-lucide="link"></i></span>
                        <span class="nav-btn-text">Relations</span>
                    </button>
                    <button class="nav-btn" onclick="switchView('map')" id="header-tab-map">
                        <span class="nav-btn-icon"><i data-lucide="map"></i></span>
                        <span class="nav-btn-text">Carte</span>
                    </button>
                    <button class="nav-btn" onclick="switchView('timelineviz')" id="header-tab-timeline-viz">
                        <span class="nav-btn-icon"><i data-lucide="clock"></i></span>
                        <span class="nav-btn-text">Timeline</span>
                    </button>
                </div>
                
                <!-- Section 4 : Stats, Analyse -->
                <div class="nav-group">
                    <button class="nav-btn" onclick="switchView('stats')" id="header-tab-stats">
                        <span class="nav-btn-icon"><i data-lucide="bar-chart-3"></i></span>
                        <span class="nav-btn-text">Stats</span>
                    </button>
                    <button class="nav-btn" onclick="switchView('analysis')" id="header-tab-analysis">
                        <span class="nav-btn-icon"><i data-lucide="scan-search"></i></span>
                        <span class="nav-btn-text">Analyse</span>
                    </button>
                </div>
                
                <!-- Section 5 : Snapshots -->
                <div class="nav-group">
                    <button class="nav-btn" onclick="switchView('versions')" id="header-tab-versions">
                        <span class="nav-btn-icon"><i data-lucide="history"></i></span>
                        <span class="nav-btn-text">Snapshots</span>
                    </button>
                </div>
            </nav>
            
            <!-- Actions à droite -->
            <div class="header-actions">
                <div id="headerStatsContainer" style="font-size: 0.85rem; color: var(--text-muted); margin-right: 0.5rem;">
                    <span id="headerTotalWords">0 mots</span>
                    <span id="headerStatsSeparator"> · </span>
                    <span id="headerTotalChapters">0 chapitres</span>
                </div>
                
                <!-- Split View Toggle -->
                <button class="split-mode-toggle" onclick="toggleSplitView()" id="splitModeToggle" title="Activer/désactiver le mode split (vue côte à côte)">
                    <i data-lucide="columns-2" style="width:14px;height:14px;"></i>
                    <span>Split</span>
                </button>
                
                <!-- Storage badge intégré dans le header -->
                <div class="storage-badge-header status-ok" id="storage-badge" onclick="showStorageDetails()" title="Espace de stockage">
                    <span class="storage-icon"><i data-lucide="hard-drive"></i></span>
                    <span id="storage-percentage">...</span>
                </div>
                
                <button class="header-action-btn" onclick="undo()" id="headerUndoBtn" title="Annuler (Ctrl+Z)" disabled><i data-lucide="undo-2"></i></button>
                <button class="header-action-btn" onclick="redo()" id="headerRedoBtn" title="Rétablir (Ctrl+Y)" disabled><i data-lucide="redo-2"></i></button>
                <button class="header-action-btn" onclick="togglePomodoroPopup()" id="pomodoroHeaderBtn" title="Timer Pomodoro"><i data-lucide="timer"></i></button>
                <button class="header-action-btn" onclick="openThemeManager()" title="Gérer les thèmes"><i data-lucide="palette"></i></button>
                <button class="header-action-btn" onclick="openProjectsModal()" title="Gérer les projets"><i data-lucide="folder-open"></i></button>
            </div>
        </div>
        
        <!-- Pomodoro Popup -->
        <div class="pomodoro-popup" id="pomodoroPopup">
            <div class="pomodoro-popup-header">
                <span>⏱️ Pomodoro</span>
                <span class="pomodoro-popup-close" onclick="togglePomodoroPopup()">×</span>
            </div>
            <div class="pomodoro-popup-content">
                <div class="pomodoro-display" id="pomodoroDisplay">25:00</div>
                <div class="pomodoro-controls">
                    <button class="btn btn-small" onclick="startPomodoro()">▶</button>
                    <button class="btn btn-small" onclick="pausePomodoro()">⏸</button>
                    <button class="btn btn-small" onclick="resetPomodoro()">↻</button>
                </div>
                <div class="pomodoro-stats">
                    <div class="pomodoro-stat">
                        <span class="pomodoro-stat-value" id="pomodorosCompleted">0</span>
                        <span class="pomodoro-stat-label">sessions</span>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Conteneur principal (sidebar + versions + éditeur) -->
        <div class="app-content">
            <!-- Sidebar Navigation -->
            <div class="sidebar">
            <!-- Poignée de redimensionnement -->
            <div class="sidebar-resize-handle" id="sidebarResizeHandle">
                <div class="resize-handle-line"></div>
            </div>
            
            <div class="sidebar-header">
                <div class="search-container">
                    <input type="text" 
                           class="search-input" 
                           id="globalSearch" 
                           placeholder="🔍 Rechercher dans tout le projet..."
                           oninput="performGlobalSearch(this.value)"
                           onfocus="this.select()">
                    <span class="search-icon">🔍</span>
                    <div class="search-results" id="searchResults"></div>
                </div>
            </div>

            <!-- Barre de progression globale -->
            <div class="project-progress-bar" id="projectProgressBar">
                <div class="progress-stats">
                    <span id="progressStatsText">0 scènes</span>
                    <span id="progressPercent">0%</span>
                </div>
                <div class="progress-track">
                    <div class="progress-segment complete" id="progressComplete" style="width: 0%"></div>
                    <div class="progress-segment review" id="progressReview" style="width: 0%"></div>
                    <div class="progress-segment progress" id="progressProgress" style="width: 0%"></div>
                    <div class="progress-segment draft" id="progressDraft" style="width: 0%"></div>
                </div>
            </div>

            <!-- Filtres de statut -->
            <div class="status-filters" id="statusFilters">
                <button class="status-filter-btn draft active" onclick="toggleStatusFilter('draft')" data-status="draft">
                    <span class="status-filter-dot draft"></span>
                    <span>Brouillon</span>
                    <span class="status-filter-count" id="countDraft">0</span>
                </button>
                <button class="status-filter-btn progress active" onclick="toggleStatusFilter('progress')" data-status="progress">
                    <span class="status-filter-dot progress"></span>
                    <span>En cours</span>
                    <span class="status-filter-count" id="countProgress">0</span>
                </button>
                <button class="status-filter-btn complete active" onclick="toggleStatusFilter('complete')" data-status="complete">
                    <span class="status-filter-dot complete"></span>
                    <span>Terminé</span>
                    <span class="status-filter-count" id="countComplete">0</span>
                </button>
                <button class="status-filter-btn review active" onclick="toggleStatusFilter('review')" data-status="review">
                    <span class="status-filter-dot review"></span>
                    <span>À réviser</span>
                    <span class="status-filter-count" id="countReview">0</span>
                </button>
            </div>

            <!-- Outils de scène -->
            <div class="scene-tools" id="sceneTools">
                <button class="scene-tool-btn" onclick="toggleVersionsSidebar()" id="headerVersionsToggle" title="Afficher/masquer les versions de scène">
                    <i data-lucide="git-branch"></i>
                    <span>Versions</span>
                </button>
                <button class="scene-tool-btn" onclick="toggleAnnotationsPanel()" id="sidebarAnnotationsBtn" title="Afficher/masquer les annotations">
                    <i data-lucide="message-square"></i>
                    <span>Annotations</span>
                    <span class="scene-tool-badge" id="annotationsBadge" style="display: none;">0</span>
                </button>
                <button class="scene-tool-btn" onclick="toggleTodosPanel()" id="sidebarTodosBtn" title="Afficher/masquer les TODOs">
                    <i data-lucide="check-square"></i>
                    <span>TODOs</span>
                    <span class="scene-tool-badge" id="todosBadge" style="display: none;">0</span>
                </button>
            </div>

            <!-- Boutons déplier/replier tout -->
            <div class="tree-collapse-toolbar" id="treeCollapseToolbar">
                <button class="tree-collapse-btn" onclick="expandAllTree()" title="Tout déplier">
                    <i data-lucide="unfold-vertical" style="width:12px;height:12px;"></i>
                    <span>Déplier</span>
                </button>
                <button class="tree-collapse-btn" onclick="collapseAllTree()" title="Tout replier">
                    <i data-lucide="fold-vertical" style="width:12px;height:12px;"></i>
                    <span>Replier</span>
                </button>
            </div>

            <div class="chapters-list" id="chaptersList">
                <!-- Structure will be dynamically inserted here -->
            </div>

            <div class="database-list" id="charactersList" style="display: none;">
                <!-- Characters will be dynamically inserted here -->
            </div>

            <div class="database-list" id="worldList" style="display: none;">
                <!-- World elements will be dynamically inserted here -->
            </div>

            <div class="database-list" id="timelineList" style="display: none;">
                <!-- Timeline events will be dynamically inserted here -->
            </div>

            <div class="database-list" id="notesList" style="display: none;">
                <!-- Notes will be dynamically inserted here -->
            </div>

            <div class="database-list" id="codexList" style="display: none;">
                <!-- Codex entries will be dynamically inserted here -->
            </div>

            <div class="database-list" id="statsList" style="display: none;">
                <!-- Statistics will be dynamically inserted here -->
            </div>

            <div class="database-list" id="versionsList" style="display: none;">
                <!-- Versions will be dynamically inserted here -->
            </div>

            <div class="database-list" id="analysisList" style="display: none;">
                <!-- Analysis will be dynamically inserted here -->
            </div>

            <div class="database-list" id="corkboardList" style="display: none;">
                <!-- Cork Board info will be here -->
            </div>

            <div class="database-list" id="mindmapList" style="display: none;">
                <!-- Mindmap will be here -->
            </div>

            <div class="database-list" id="plotList" style="display: none;">
                <!-- Plot graph will be here -->
            </div>

            <div class="database-list" id="relationsList" style="display: none;">
                <!-- Relations graph will be here -->
            </div>

            <div class="database-list" id="mapList" style="display: none;">
                <!-- World map will be here -->
            </div>

            <div class="database-list" id="timelineVizList" style="display: none;">
                <!-- Visual timeline will be here -->
            </div>

            <div class="database-list" id="todosList" style="display: none;">
                <!-- TODOs list will be here -->
            </div>

            <div class="database-list" id="noSidebarMessage" style="display: none;">
                <!-- Message for views without sidebar -->
            </div>

            <div class="sidebar-actions" id="sidebarActions">
                <button class="btn btn-primary" onclick="openAddActModal()">+ Acte</button>
                <button class="btn btn-primary" onclick="openAddChapterModal()">+ Chapitre</button>
                <button class="btn btn-primary" onclick="openAddSceneModalQuick()">+ Scène</button>
            </div>
        </div>

        <!-- Sidebar Versions (pour les versions de scènes) -->
        <div class="sidebar-versions hidden" id="sidebarVersions">
            <div class="sidebar-versions-header">
                <div class="sidebar-versions-title">
                    <h3><i data-lucide="git-branch" style="width:16px;height:16px;vertical-align:middle;margin-right:6px;"></i>Versions</h3>
                    <button class="sidebar-versions-toggle" onclick="toggleVersionsSidebar()" title="Masquer">✕</button>
                </div>
                <div class="sidebar-versions-scene" id="versionsSceneName">Aucune scène sélectionnée</div>
            </div>
            <div class="sidebar-versions-actions" id="versionsActionsArea">
                <button class="btn-new-version" onclick="createSceneVersion()" id="btnNewVersion" disabled>
                    + Nouvelle version
                </button>
            </div>
            <div class="sidebar-versions-list" id="sceneVersionsList">
                <div class="versions-no-scene">
                    <div class="versions-no-scene-icon">📄</div>
                    <div class="versions-no-scene-text">
                        Sélectionnez une scène<br>dans la structure<br>pour voir ses versions
                    </div>
                </div>
            </div>
        </div>

        <!-- Main Editor -->
        <div class="editor-container" id="editorView">
            <div class="empty-state">
                <div class="empty-state-icon">✍️</div>
                <div class="empty-state-title">Commencez votre histoire</div>
                <div class="empty-state-text">
                    Créez votre premier chapitre pour commencer à écrire.
                </div>
                <button class="btn btn-primary" onclick="openAddChapterModal()">+ Créer un chapitre</button>
            </div>
        </div>
        </div><!-- Fin app-content -->
        
        <!-- Focus Mode Panel (inside app-container for fullscreen) -->
        <div class="focus-mode-panel" id="focusPanel">
            <div class="focus-panel-header">
                <div class="focus-panel-title">🧘 Mode Focus</div>
            </div>
            <div class="focus-panel-content">
                <!-- Pomodoro Timer -->
                <div class="focus-section">
                    <div class="focus-section-title">⏱️ Timer Pomodoro</div>
                    <div class="pomodoro-timer">
                        <div class="pomodoro-display" id="pomodoroDisplay">25:00</div>
                        <div class="pomodoro-controls">
                            <button class="btn btn-small" onclick="startPomodoro()">▶ Démarrer</button>
                            <button class="btn btn-small" onclick="pausePomodoro()">⏸ Pause</button>
                            <button class="btn btn-small" onclick="resetPomodoro()">↻ Reset</button>
                        </div>
                        <div class="focus-stats">
                            <div class="focus-stat-box">
                                <div class="focus-stat-value" id="pomodorosCompleted">0</div>
                                <div class="focus-stat-label">Pomodoros</div>
                            </div>
                            <div class="focus-stat-box">
                                <div class="focus-stat-value" id="focusWordCount">0</div>
                                <div class="focus-stat-label">Mots</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Focus Settings -->
                <div class="focus-section">
                    <div class="focus-section-title">⚙️ Paramètres</div>
                    <div style="display: flex; flex-direction: column; gap: 0.75rem;">
                        <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                            <input type="checkbox" id="hideToolbar" onchange="toggleToolbar()">
                            <span>Masquer la barre d'outils</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                            <input type="checkbox" id="hideLinksPanel" onchange="toggleLinksPanelVisibility()">
                            <span>Masquer le panneau de liens</span>
                        </label>
                    </div>
                </div>

                <!-- Exit Focus Mode -->
                <div class="focus-section">
                    <button class="btn btn-primary" style="width: 100%;" onclick="toggleFocusMode()">
                        ← Quitter le mode Focus
                    </button>
                </div>
            </div>
        </div>
        
    </div><!-- Fin app-container -->

    <!-- Diff Modal -->
    <div class="diff-modal" id="diffModal" style="display: none;">
        <div class="diff-modal-content">
            <div class="diff-modal-header">
                <div class="diff-modal-title">
                    <span>🔀</span>
                    <span>Comparaison des versions</span>
                </div>
                <button class="diff-modal-close" onclick="closeDiffModal()">×</button>
            </div>
            <div class="diff-toolbar">
                <div class="diff-version-selector">
                    <span>Comparer</span>
                    <select class="diff-version-select" id="diffVersionOld" onchange="updateDiff()">
                    </select>
                    <span>avec</span>
                    <select class="diff-version-select" id="diffVersionNew" onchange="updateDiff()">
                    </select>
                </div>
                <div class="diff-stats" id="diffStats">
                    <span class="diff-stat added">+0 ajoutés</span>
                    <span class="diff-stat removed">−0 supprimés</span>
                </div>
                <div class="diff-view-toggle">
                    <button class="diff-view-btn active" onclick="setDiffView('unified')" id="btnDiffUnified">Unifié</button>
                    <button class="diff-view-btn" onclick="setDiffView('side')" id="btnDiffSide">Côte à côte</button>
                </div>
            </div>
            <div class="diff-content" id="diffContent">
                <!-- Diff content will be inserted here -->
            </div>
        </div>
    </div>

    <!-- Add Act Modal -->
    <!-- Storage Details Modal -->
    <div class="modal storage-details-modal" id="storage-modal">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header">
                <h2>💾 Espace de stockage</h2>
                <button class="modal-close" onclick="closeModal('storage-modal')">×</button>
            </div>
            <div class="storage-info">
                <div class="storage-bar">
                    <div class="storage-bar-fill ok" id="storage-bar-fill" style="width: 0%">
                        <span id="storage-bar-text">0%</span>
                    </div>
                </div>
                <div class="storage-stats">
                    <div class="storage-stat">
                        <div class="storage-stat-label">Utilisé</div>
                        <div class="storage-stat-value" id="storage-used">0 MB</div>
                    </div>
                    <div class="storage-stat">
                        <div class="storage-stat-label">Disponible</div>
                        <div class="storage-stat-value" id="storage-available">5 MB</div>
                    </div>
                </div>
                <!-- Section repliable pour les recommandations -->
                <details id="storage-recommendations-details" style="margin-top: 1rem;">
                    <summary style="cursor: pointer; font-weight: 600; color: var(--accent-green); font-size: 0.9rem;">✅ Espace suffisant</summary>
                    <div id="storage-recommendations-container" style="margin-top: 0.5rem;"></div>
                </details>
            </div>
            
            <hr style="border: none; border-top: 1px solid var(--border-color); margin: 1.25rem 0;">
            
            <!-- Importer des données -->
            <div style="margin-bottom: 1rem;">
                <div style="font-size: 0.9rem; font-weight: 600; margin-bottom: 0.5rem; color: var(--text-primary);">Importer</div>
                <button class="btn" onclick="importProject()" style="width: 100%; font-size: 0.85rem;">
                    <i data-lucide="upload" style="width:14px;height:14px;vertical-align:middle;margin-right:6px;"></i>Importer depuis un fichier JSON
                </button>
            </div>

            <!-- Exporter les données -->
            <div style="margin-bottom: 1rem;">
                <div style="font-size: 0.9rem; font-weight: 600; margin-bottom: 0.5rem; color: var(--text-primary);">Exporter</div>
                <div style="display: flex; flex-direction: column; gap: 0.5rem;">
                    <button class="btn btn-primary" onclick="closeModal('storage-modal'); openExportNovelModal();" style="font-weight: 600; font-size: 0.85rem;">
                        <i data-lucide="book-open" style="width:14px;height:14px;vertical-align:middle;margin-right:6px;"></i>Exporter le roman (MD, TXT, HTML ...)
                    </button>
                    <div style="display: flex; gap: 0.5rem;">
                        <button class="btn" onclick="exportToJSON()" style="flex: 1; font-size: 0.8rem;">
                            <i data-lucide="hard-drive" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>JSON
                        </button>
                        <button class="btn" onclick="exportProject()" style="flex: 1; font-size: 0.8rem;">
                            <i data-lucide="file-text" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>TXT
                        </button>
                    </div>
                </div>
            </div>

            <!-- Cloud manuel - repliable -->
            <details style="margin-bottom: 1rem;">
                <summary style="cursor: pointer; font-weight: 600; color: var(--text-primary); font-size: 0.9rem;">☁️ Cloud (manuel)</summary>
                <div style="padding: 0.75rem; background: var(--bg-secondary); border-radius: 4px; margin-top: 0.5rem; border: 1px solid var(--border-color);">
                    <ol style="font-size: 0.75rem; color: var(--text-secondary); line-height: 1.6; padding-left: 1.25rem; margin: 0;">
                        <li>Télécharge en JSON</li>
                        <li>Uploade sur Google Drive / Dropbox</li>
                        <li>Pour restaurer : "Importer depuis un fichier"</li>
                    </ol>
                </div>
            </details>

            <!-- Avertissement très petit -->
            <p style="font-size: 0.7rem; color: var(--text-muted); text-align: center; margin: 0;">
                ⚠️ Pense à exporter régulièrement — les données navigateur peuvent être effacées
            </p>

            <div class="modal-actions" style="margin-top: 1rem;">
                <button class="btn" onclick="closeModal('storage-modal')">Fermer</button>
            </div>
        </div>
    </div>

    <!-- Modals -->
    <div class="modal" id="addActModal">
        <div class="modal-content">
            <div class="modal-title">Nouvel Acte</div>
            <div class="form-group">
                <label class="form-label">Titre de l'acte</label>
                <input type="text" class="form-input" id="actTitleInput" placeholder="Acte I : L'Éveil">
            </div>
            <div class="modal-actions">
                <button class="btn" onclick="closeModal('addActModal')">Annuler</button>
                <button class="btn btn-primary" onclick="addAct()">Créer</button>
            </div>
        </div>
    </div>

    <!-- Add Chapter Modal -->
    <div class="modal" id="addChapterModal">
        <div class="modal-content">
            <div class="modal-title">Nouveau Chapitre</div>
            <div class="form-group">
                <label class="form-label">Titre du chapitre</label>
                <input type="text" class="form-input" id="chapterTitleInput" placeholder="Chapitre 1 : Le Début">
            </div>
            <div class="modal-actions">
                <button class="btn" onclick="closeModal('addChapterModal')">Annuler</button>
                <button class="btn btn-primary" onclick="addChapter()">Créer</button>
            </div>
        </div>
    </div>

    <!-- Add Scene Modal -->
    <div class="modal" id="addSceneModal">
        <div class="modal-content">
            <div class="modal-title">Nouvelle Scène</div>
            <div class="form-group">
                <label class="form-label">Titre de la scène</label>
                <input type="text" class="form-input" id="sceneTitleInput" placeholder="Scène 1 : Rencontre">
            </div>
            <div class="modal-actions">
                <button class="btn" onclick="closeModal('addSceneModal')">Annuler</button>
                <button class="btn btn-primary" onclick="addScene()">Créer</button>
            </div>
        </div>
    </div>

    <!-- Split View Selector Modal -->
    <div class="modal" id="splitSelectorModal">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-title"><i data-lucide="layout" style="width:20px;height:20px;vertical-align:middle;margin-right:8px;"></i>Choisir la vue</div>
            <div id="splitSelectorContent" style="max-height: 600px; overflow-y: auto;">
                <!-- Content will be populated by JavaScript -->
            </div>
            <div class="modal-actions">
                <button class="btn" onclick="closeModal('splitSelectorModal')">Annuler</button>
            </div>
        </div>
    </div>

    <!-- Add Character Modal -->
    <div class="modal" id="addCharacterModal">
        <div class="modal-content">
            <div class="modal-title">Nouveau Personnage</div>
            <div class="form-group">
                <label class="form-label">Nom du personnage</label>
                <input type="text" class="form-input" id="characterNameInput" placeholder="Akiko">
            </div>
            <div class="form-group">
                <label class="form-label">Rôle</label>
                <input type="text" class="form-input" id="characterRoleInput" placeholder="Protagoniste, Antagoniste, Allié...">
            </div>
            <div class="form-group">
                <label class="form-label">Description rapide</label>
                <textarea class="form-input" id="characterDescInput" placeholder="Description du personnage..." rows="3"></textarea>
            </div>
            <div class="modal-actions">
                <button class="btn" onclick="closeModal('addCharacterModal')">Annuler</button>
                <button class="btn btn-primary" onclick="addCharacter()">Créer</button>
            </div>
        </div>
    </div>

    <!-- Add World Element Modal -->
    <div class="modal" id="addWorldModal">
        <div class="modal-content">
            <div class="modal-title">Nouvel Élément d'Univers</div>
            <div class="form-group">
                <label class="form-label">Nom</label>
                <input type="text" class="form-input" id="worldNameInput" placeholder="Cité de Voile">
            </div>
            <div class="form-group">
                <label class="form-label">Type</label>
                <select class="form-input" id="worldTypeInput">
                    <option value="Lieu">Lieu</option>
                    <option value="Objet">Objet</option>
                    <option value="Concept">Concept</option>
                    <option value="Organisation">Organisation</option>
                    <option value="Événement">Événement</option>
                </select>
            </div>
            <div class="form-group">
                <label class="form-label">Description rapide</label>
                <textarea class="form-input" id="worldDescInput" placeholder="Description de l'élément..." rows="3"></textarea>
            </div>
            <div class="modal-actions">
                <button class="btn" onclick="closeModal('addWorldModal')">Annuler</button>
                <button class="btn btn-primary" onclick="addWorldElement()">Créer</button>
            </div>
        </div>
    </div>

    <!-- Add Timeline Event Modal -->
    <div class="modal" id="addTimelineModal">
        <div class="modal-content">
            <div class="modal-title">Nouvel Événement</div>
            <div class="form-group">
                <label class="form-label">Titre de l'événement</label>
                <input type="text" class="form-input" id="timelineTitleInput" placeholder="La grande bataille">
            </div>
            <div class="form-group">
                <label class="form-label">Date / Moment</label>
                <input type="text" class="form-input" id="timelineDateInput" placeholder="An 2157, Printemps / Chapitre 5 / Jour 3...">
            </div>
            <div class="form-group">
                <label class="form-label">Localisation</label>
                <input type="text" class="form-input" id="timelineLocationInput" placeholder="Cité de Voile">
            </div>
            <div class="form-group">
                <label class="form-label">Personnages impliqués</label>
                <input type="text" class="form-input" id="timelineCharactersInput" placeholder="Akiko, Sora, Kumi...">
            </div>
            <div class="form-group">
                <label class="form-label">Description</label>
                <textarea class="form-input" id="timelineDescInput" placeholder="Description de l'événement..." rows="4"></textarea>
            </div>
            <div class="modal-actions">
                <button class="btn" onclick="closeModal('addTimelineModal')">Annuler</button>
                <button class="btn btn-primary" onclick="addTimelineEvent()">Créer</button>
            </div>
        </div>
    </div>

    <!-- Metro Timeline Event Modal -->
    <div class="modal" id="metroEventModal">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-title" id="metroEventModalTitle">Nouvel Événement</div>
            <input type="hidden" id="metroEventId">
            <div class="metro-event-form">
                <div class="form-group">
                    <label class="form-label">Titre de l'événement *</label>
                    <input type="text" class="form-input" id="metroEventTitle" placeholder="La grande bataille">
                </div>
                <div class="form-group">
                    <label class="form-label">Date / Moment</label>
                    <input type="text" class="form-input" id="metroEventDate" placeholder="An 2157, Printemps...">
                </div>
                <div class="form-group">
                    <label class="form-label">Position sur la timeline</label>
                    <select class="form-input" id="metroEventPosition">
                        <!-- Populated dynamically -->
                    </select>
                    <input type="hidden" id="metroEventOrder">
                    <small style="color: var(--text-muted);">Choisissez où placer cet événement dans la chronologie</small>
                </div>
                <div class="form-group">
                    <label class="form-label">Description</label>
                    <textarea class="form-input" id="metroEventDesc" placeholder="Ce qui se passe..." rows="3"></textarea>
                </div>
                <div class="form-group">
                    <label class="form-label">Scène liée</label>
                    <select class="form-input" id="metroEventScene">
                        <option value="">Aucune scène</option>
                        <!-- Populated dynamically -->
                    </select>
                    <small style="color: var(--text-muted);">Associez cet événement à une scène de votre roman</small>
                </div>
                <div class="form-group">
                    <label class="form-label">Personnages impliqués</label>
                    <div id="metroCharactersSelector" class="metro-characters-selector">
                        <!-- Populated dynamically -->
                    </div>
                    <div id="metroLinkedChars" class="metro-linked-chars">
                        <!-- Tags des personnages liés -->
                    </div>
                </div>
            </div>
            <div class="modal-actions">
                <button class="btn" onclick="closeModal('metroEventModal')">Annuler</button>
                <button class="btn" style="background: var(--accent-red); color: white;" onclick="deleteMetroEvent()" id="metroDeleteBtn" style="display: none;">Supprimer</button>
                <button class="btn btn-primary" onclick="saveMetroEvent()">Enregistrer</button>
            </div>
        </div>
    </div>

    <!-- Metro Event View Choice Modal -->
    <div class="modal" id="metroViewChoiceModal">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-title">Ouvrir l'événement Timeline</div>
            <input type="hidden" id="metroViewChoiceEventId">
            <div style="padding: 1rem 0;">
                <p style="color: var(--text-secondary); margin-bottom: 1.5rem;">
                    Comment souhaitez-vous visualiser cet événement ?
                </p>
                <div style="display: flex; flex-direction: column; gap: 1rem;">
                    <button class="btn" onclick="openMetroEventFullView()" style="padding: 1rem; text-align: left; display: flex; align-items: start; gap: 1rem; border: 2px solid var(--border-color);">
                        <i data-lucide="maximize-2" style="width: 24px; height: 24px; flex-shrink: 0; color: var(--accent-blue);"></i>
                        <div>
                            <div style="font-weight: 600; margin-bottom: 0.25rem;">Vue complète</div>
                            <div style="font-size: 0.85rem; color: var(--text-muted);">Basculer vers la vue Timeline Métro (quitte la vue actuelle)</div>
                        </div>
                    </button>
                    <button class="btn" onclick="openMetroEventSplitView()" style="padding: 1rem; text-align: left; display: flex; align-items: start; gap: 1rem; border: 2px solid var(--border-color);">
                        <i data-lucide="columns-2" style="width: 24px; height: 24px; flex-shrink: 0; color: var(--accent-green);"></i>
                        <div>
                            <div style="font-weight: 600; margin-bottom: 0.25rem;">Split-view</div>
                            <div style="font-size: 0.85rem; color: var(--text-muted);">Ouvrir la Timeline en vue séparée (conserve l'éditeur)</div>
                        </div>
                    </button>
                </div>
            </div>
            <div class="modal-actions">
                <button class="btn" onclick="closeModal('metroViewChoiceModal')">Annuler</button>
            </div>
        </div>
    </div>

    <!-- Metro Character Color Picker Modal -->
    <div class="modal" id="metroColorModal">
        <div class="modal-content" style="max-width: 350px;">
            <div class="modal-title">Couleur de la ligne</div>
            <input type="hidden" id="metroColorCharId">
            <div class="form-group">
                <label class="form-label" id="metroColorCharName">Personnage</label>
                <div style="display: flex; flex-wrap: wrap; gap: 0.5rem; margin-top: 0.5rem;">
                    <div class="metro-color-option" data-color="#E53935" style="background: #E53935;" onclick="selectMetroColor('#E53935')"></div>
                    <div class="metro-color-option" data-color="#D81B60" style="background: #D81B60;" onclick="selectMetroColor('#D81B60')"></div>
                    <div class="metro-color-option" data-color="#8E24AA" style="background: #8E24AA;" onclick="selectMetroColor('#8E24AA')"></div>
                    <div class="metro-color-option" data-color="#5E35B1" style="background: #5E35B1;" onclick="selectMetroColor('#5E35B1')"></div>
                    <div class="metro-color-option" data-color="#3949AB" style="background: #3949AB;" onclick="selectMetroColor('#3949AB')"></div>
                    <div class="metro-color-option" data-color="#1E88E5" style="background: #1E88E5;" onclick="selectMetroColor('#1E88E5')"></div>
                    <div class="metro-color-option" data-color="#039BE5" style="background: #039BE5;" onclick="selectMetroColor('#039BE5')"></div>
                    <div class="metro-color-option" data-color="#00ACC1" style="background: #00ACC1;" onclick="selectMetroColor('#00ACC1')"></div>
                    <div class="metro-color-option" data-color="#00897B" style="background: #00897B;" onclick="selectMetroColor('#00897B')"></div>
                    <div class="metro-color-option" data-color="#43A047" style="background: #43A047;" onclick="selectMetroColor('#43A047')"></div>
                    <div class="metro-color-option" data-color="#7CB342" style="background: #7CB342;" onclick="selectMetroColor('#7CB342')"></div>
                    <div class="metro-color-option" data-color="#C0CA33" style="background: #C0CA33;" onclick="selectMetroColor('#C0CA33')"></div>
                    <div class="metro-color-option" data-color="#FDD835" style="background: #FDD835;" onclick="selectMetroColor('#FDD835')"></div>
                    <div class="metro-color-option" data-color="#FFB300" style="background: #FFB300;" onclick="selectMetroColor('#FFB300')"></div>
                    <div class="metro-color-option" data-color="#FB8C00" style="background: #FB8C00;" onclick="selectMetroColor('#FB8C00')"></div>
                    <div class="metro-color-option" data-color="#F4511E" style="background: #F4511E;" onclick="selectMetroColor('#F4511E')"></div>
                    <div class="metro-color-option" data-color="#6D4C41" style="background: #6D4C41;" onclick="selectMetroColor('#6D4C41')"></div>
                    <div class="metro-color-option" data-color="#757575" style="background: #757575;" onclick="selectMetroColor('#757575')"></div>
                    <div class="metro-color-option" data-color="#546E7A" style="background: #546E7A;" onclick="selectMetroColor('#546E7A')"></div>
                    <div class="metro-color-option" data-color="#263238" style="background: #263238;" onclick="selectMetroColor('#263238')"></div>
                </div>
                <div style="margin-top: 1rem;">
                    <label class="form-label">Couleur personnalisée</label>
                    <input type="color" id="metroCustomColor" class="form-input" style="width: 100%; height: 40px; padding: 0; cursor: pointer;">
                </div>
            </div>
            <div class="modal-actions">
                <button class="btn" onclick="closeModal('metroColorModal')">Annuler</button>
                <button class="btn btn-primary" onclick="applyMetroColor()">Appliquer</button>
            </div>
        </div>
    </div>

    <style>
        .metro-color-option {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.2s;
        }
        .metro-color-option:hover {
            transform: scale(1.15);
            border-color: white;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
        .metro-color-option.selected {
            border-color: var(--text-primary);
            box-shadow: 0 0 0 2px var(--accent-blue);
        }
    </style>

    <!-- Add Note Modal -->
    <div class="modal" id="addNoteModal">
        <div class="modal-content">
            <div class="modal-title">Nouvelle Note</div>
            <div class="form-group">
                <label class="form-label">Titre de la note</label>
                <input type="text" class="form-input" id="noteTitleInput" placeholder="Recherche sur les sanctuaires Shinto">
            </div>
            <div class="form-group">
                <label class="form-label">Catégorie</label>
                <select class="form-input" id="noteCategoryInput">
                    <option value="Recherche">Recherche</option>
                    <option value="Idée">Idée</option>
                    <option value="Référence">Référence</option>
                    <option value="A faire">À faire</option>
                    <option value="Question">Question</option>
                    <option value="Autre">Autre</option>
                </select>
            </div>
            <div class="form-group">
                <label class="form-label">Tags (séparés par des virgules)</label>
                <input type="text" class="form-input" id="noteTagsInput" placeholder="shinto, religion, japon">
            </div>
            <div class="form-group">
                <label class="form-label">Contenu</label>
                <textarea class="form-input" id="noteContentInput" placeholder="Contenu de la note..." rows="6"></textarea>
            </div>
            <div class="modal-actions">
                <button class="btn" onclick="closeModal('addNoteModal')">Annuler</button>
                <button class="btn btn-primary" onclick="addNote()">Créer</button>
            </div>
        </div>
    </div>

    <!-- Add Codex Entry Modal -->
    <div class="modal" id="addCodexModal">
        <div class="modal-content">
            <div class="modal-title">Nouvelle Entrée Codex</div>
            <div class="form-group">
                <label class="form-label">Titre</label>
                <input type="text" class="form-input" id="codexTitleInput" placeholder="Les Sanctuaires Shinto">
            </div>
            <div class="form-group">
                <label class="form-label">Catégorie</label>
                <select class="form-input" id="codexCategoryInput">
                    <option value="Culture">Culture</option>
                    <option value="Histoire">Histoire</option>
                    <option value="Technologie">Technologie</option>
                    <option value="Géographie">Géographie</option>
                    <option value="Politique">Politique</option>
                    <option value="Magie/Pouvoir">Magie/Pouvoir</option>
                    <option value="Religion">Religion</option>
                    <option value="Société">Société</option>
                    <option value="Autre">Autre</option>
                </select>
            </div>
            <div class="form-group">
                <label class="form-label">Résumé rapide</label>
                <textarea class="form-input" id="codexSummaryInput" placeholder="Description courte..." rows="3"></textarea>
            </div>
            <div class="modal-actions">
                <button class="btn" onclick="closeModal('addCodexModal')">Annuler</button>
                <button class="btn btn-primary" onclick="addCodexEntry()">Créer</button>
            </div>
        </div>
    </div>

    <!-- Projects Management Modal -->
    <div class="modal" id="projectsModal">
        <div class="modal-content" style="max-width: 800px;">
            <div class="modal-title"><i data-lucide="folder-open"></i> Mes Projets</div>
            
            <div class="modal-button-group" style="margin-bottom: 2rem;">
                <button class="btn btn-primary" onclick="openNewProjectModal()">+ Nouveau Projet</button>
                <button class="btn" onclick="importProject()">📥 Importer un projet</button>
            </div>

            <div id="projectsList" style="max-height: 400px; overflow-y: auto;">
                <!-- Projects will be listed here -->
            </div>

            <div class="modal-actions">
                <button class="btn" onclick="closeModal('projectsModal')">Fermer</button>
            </div>
        </div>
    </div>

    <!-- New Project Modal -->
    <div class="modal" id="newProjectModal">
        <div class="modal-content">
            <div class="modal-title">Nouveau Projet</div>
            
            <div class="form-group">
                <label class="form-label">Titre du projet</label>
                <input type="text" class="form-input" id="newProjectTitle" placeholder="Mon Roman">
            </div>
            
            <div class="form-group">
                <label class="form-label">Description (optionnel)</label>
                <textarea class="form-input" id="newProjectDesc" placeholder="Un roman de fantasy épique..." rows="3"></textarea>
            </div>
            
            <div class="form-group">
                <label class="form-label">Genre</label>
                <select class="form-input" id="newProjectGenre">
                    <option value="">Aucun</option>
                    <option value="Fantasy">Fantasy</option>
                    <option value="Science-Fiction">Science-Fiction</option>
                    <option value="Thriller">Thriller</option>
                    <option value="Romance">Romance</option>
                    <option value="Policier">Policier</option>
                    <option value="Horreur">Horreur</option>
                    <option value="Historique">Historique</option>
                    <option value="Aventure">Aventure</option>
                    <option value="Drame">Drame</option>
                    <option value="Autre">Autre</option>
                </select>
            </div>

            <div class="form-group">
                <label class="form-label">Utiliser un template ?</label>
                <select class="form-input" id="newProjectTemplate">
                    <option value="">Projet vide</option>
                    <option value="fantasy">Fantasy (3 actes + personnages types)</option>
                    <option value="thriller">Thriller (Structure suspense)</option>
                    <option value="scifi">Science-Fiction (Worldbuilding avancé)</option>
                </select>
            </div>
            
            <div class="modal-actions">
                <button class="btn" onclick="closeModal('newProjectModal')">Annuler</button>
                <button class="btn btn-primary" onclick="createNewProject()">Créer</button>
            </div>
        </div>
    </div>

    <input type="file" id="importProjectInput" accept=".json" style="display: none;" onchange="handleProjectImport(event)">

    <!-- Backup Menu Modal -->
    <div class="modal" id="backupModal">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-title"><i data-lucide="hard-drive"></i> Sauvegardes et Exports</div>
            
            <div style="margin-bottom: 2rem;">
                <div style="font-size: 1rem; font-weight: 600; margin-bottom: 1rem; color: var(--text-primary);"><i data-lucide="download" style="width:16px;height:16px;vertical-align:middle;margin-right:6px;"></i>Importer des données</div>
                <div style="display: flex; flex-direction: column; gap: 0.75rem;">
                    <button class="btn" onclick="importFromFile()">
                        <i data-lucide="folder-open" style="width:16px;height:16px;vertical-align:middle;margin-right:6px;"></i>Importer depuis un fichier JSON
                    </button>
                    <input type="file" id="importFileInput" accept=".json" style="display: none;" onchange="handleFileImport(event)">
                </div>
            </div>

            <div style="margin-bottom: 2rem;">
                <div style="font-size: 1rem; font-weight: 600; margin-bottom: 1rem; color: var(--text-primary);"><i data-lucide="upload" style="width:16px;height:16px;vertical-align:middle;margin-right:6px;"></i>Exporter les données</div>
                <div style="display: flex; flex-direction: column; gap: 0.75rem;">
                    <button class="btn btn-primary" onclick="openExportNovelModal()" style="font-weight: 600;">
                        <i data-lucide="book-open" style="width:16px;height:16px;vertical-align:middle;margin-right:6px;"></i>Exporter le roman (MD, TXT, HTML ...)
                    </button>
                    <button class="btn" onclick="exportToJSON()">
                        <i data-lucide="hard-drive" style="width:16px;height:16px;vertical-align:middle;margin-right:6px;"></i>Télécharger en JSON (sauvegarde complète)
                    </button>
                    <button class="btn" onclick="exportProject()">
                        <i data-lucide="file-text" style="width:16px;height:16px;vertical-align:middle;margin-right:6px;"></i>Exporter en TXT (texte seulement)
                    </button>
                </div>
            </div>

            <div style="margin-bottom: 2rem;">
                <div style="font-size: 1rem; font-weight: 600; margin-bottom: 1rem; color: var(--text-primary);"><i data-lucide="cloud" style="width:16px;height:16px;vertical-align:middle;margin-right:6px;"></i>Cloud (manuel)</div>
                <div style="padding: 1rem; background: var(--bg-secondary); border-radius: 4px; border: 1px solid var(--border-color);">
                    <p style="font-size: 0.9rem; color: var(--text-secondary); margin-bottom: 1rem; line-height: 1.6;">
                        Pour sauvegarder sur Google Drive, Dropbox, ou tout autre service cloud :
                    </p>
                    <ol style="font-size: 0.85rem; color: var(--text-secondary); line-height: 1.8; padding-left: 1.5rem;">
                        <li>Clique sur "Télécharger en JSON"</li>
                        <li>Le fichier contient TOUTES tes données</li>
                        <li>Uploade-le manuellement sur ton service cloud préféré</li>
                        <li>Pour restaurer : télécharge le fichier et utilise "Importer depuis un fichier"</li>
                    </ol>
                </div>
            </div>

            <div style="padding: 1rem; background: rgba(196, 69, 54, 0.1); border-radius: 4px; border: 1px solid var(--accent-red);">
                <div style="font-size: 0.85rem; font-weight: 600; color: var(--accent-red); margin-bottom: 0.5rem;">
                    ⚠️ Important : Sauvegarde régulière
                </div>
                <p style="font-size: 0.8rem; color: var(--text-secondary); line-height: 1.6;">
                    Le localStorage peut être effacé par le navigateur. Pense à exporter régulièrement ton projet en JSON et à le sauvegarder dans un endroit sûr (Google Drive, Dropbox, disque dur, etc.).
                </p>
            </div>

            <div class="modal-actions" style="margin-top: 1.5rem;">
                <button class="btn" onclick="closeModal('backupModal')">Fermer</button>
            </div>
        </div>
    </div>

    <!-- Export Novel Modal -->
    <div class="modal" id="exportNovelModal">
        <div class="modal-content" style="max-width: 700px; max-height: 90vh; overflow-y: auto;">
            <div class="modal-title"><i data-lucide="book-open"></i> Exporter votre roman</div>
            
            <p style="font-size: 0.95rem; color: var(--text-secondary); margin-bottom: 1.5rem; line-height: 1.6;">
                Vous pouvez exporter votre roman dans plusieurs formats. Vous pouvez ensuite importer les données dans d'autres logiciels d'écriture.
            </p>

            <!-- Toggle All Button -->
            <div style="margin-bottom: 1.5rem;">
                <button class="btn btn-small" onclick="toggleAllScenes()" style="width: 100%;">
                    🔄 Tout sélectionner / Tout désélectionner
                </button>
            </div>

            <!-- Acts/Chapters/Scenes Selection Tree -->
            <div style="margin-bottom: 1.5rem; max-height: 300px; overflow-y: auto; border: 1px solid var(--border-color); border-radius: 6px; padding: 1rem; background: var(--bg-secondary);" id="exportTreeContainer">
                <!-- Will be populated by JavaScript -->
            </div>

            <!-- Format Selection -->
            <div style="margin-bottom: 1.5rem;">
                <label style="display: block; font-weight: 600; margin-bottom: 0.75rem; color: var(--text-primary);">
                    Format du fichier
                </label>
                <select id="exportFormatSelect" onchange="updateExportFormatInfo()" style="width: 100%; padding: 0.75rem; background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); font-size: 0.95rem; font-family: 'Crimson Pro', serif;">
                    <option value="markdown">📝 Markdown (.md)</option>
                    <option value="txt">📋 Texte brut (.txt)</option>
                    <option value="html">🌐 HTML (.html)</option>
                    <option value="epub">📚 EPUB (.epub)</option>
                </select>
                <div id="formatInfoBox" style="margin-top: 0.75rem; padding: 0.75rem; background: rgba(212, 175, 55, 0.1); border-radius: 4px; border: 1px solid var(--accent-gold); font-size: 0.85rem; color: var(--text-secondary); line-height: 1.5;">
                    <strong style="color: var(--text-primary);">ℹ️ Note :</strong> 
                    Toutes les fonctionnalités ne sont pas supportées en format DOCX. Le texte exporté pourrait ne pas ressembler exactement à l'éditeur. Pour une compatibilité complète, utilisez un autre format.
                </div>
            </div>

            <!-- General Options -->
            <div style="margin-bottom: 1.5rem;">
                <label style="display: block; font-weight: 600; margin-bottom: 0.75rem; color: var(--text-primary);">
                    Options générales
                </label>
                <div style="display: flex; flex-direction: column; gap: 0.5rem;">
                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-size: 0.95rem;">
                        <input type="checkbox" id="exportSummariesCheck" style="cursor: pointer;">
                        <span>Exporter les résumés</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-size: 0.95rem;">
                        <input type="checkbox" id="exportProseCheck" checked style="cursor: pointer;">
                        <span>Exporter le texte</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-size: 0.95rem;">
                        <input type="checkbox" id="includeActTitlesCheck" checked style="cursor: pointer;">
                        <span>Inclure les titres d'actes <span style="color: var(--text-muted); font-size: 0.85rem;">(désactiver pour ex. Vellum, Atticus)</span></span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-size: 0.95rem;">
                        <input type="checkbox" id="includeSceneSubtitlesCheck" checked style="cursor: pointer;">
                        <span>Inclure les sous-titres de scènes</span>
                    </label>
                </div>
            </div>

            <!-- Scene Dividers -->
            <div style="margin-bottom: 1.5rem;">
                <label style="display: block; font-weight: 600; margin-bottom: 0.75rem; color: var(--text-primary);">
                    Séparateurs de scènes
                </label>
                <select id="sceneDividerSelect" style="width: 100%; padding: 0.75rem; background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); font-size: 0.95rem; font-family: 'Crimson Pro', serif;">
                    <option value="asterisks">Astérisques ( * * * )</option>
                    <option value="hash">Dièse ( ### )</option>
                    <option value="line">Ligne horizontale (---)</option>
                    <option value="space">Espace vide</option>
                    <option value="none">Aucun séparateur</option>
                </select>
            </div>

            <!-- Project Export (ZIP with all data) -->
            <div style="margin-bottom: 1.5rem; padding: 1rem; background: var(--bg-secondary); border-radius: 6px; border: 1px solid var(--border-color);">
                <label style="display: block; font-weight: 600; margin-bottom: 0.75rem; color: var(--text-primary);">
                    Export du projet complet
                </label>
                <p style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 1rem; line-height: 1.5;">
                    En exportant le projet complet, le fichier résultant sera une archive ZIP contenant tout le contenu sélectionné.
                </p>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-size: 0.95rem;">
                        <input type="checkbox" id="includeCharactersCheck" style="cursor: pointer;">
                        <span>👤 Personnages</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-size: 0.95rem;">
                        <input type="checkbox" id="includeWorldCheck" style="cursor: pointer;">
                        <span>🌍 Univers</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-size: 0.95rem;">
                        <input type="checkbox" id="includeTimelineCheck" style="cursor: pointer;">
                        <span>📅 Timeline</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-size: 0.95rem;">
                        <input type="checkbox" id="includeRelationsCheck" style="cursor: pointer;">
                        <span>🔗 Relations</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-size: 0.95rem;">
                        <input type="checkbox" id="includeCodexCheck" style="cursor: pointer;">
                        <span>📚 Codex</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-size: 0.95rem;">
                        <input type="checkbox" id="includeNotesCheck" style="cursor: pointer;">
                        <span>📝 Notes</span>
                    </label>
                </div>
                <div style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px dashed var(--border-color);">
                    <button onclick="toggleAllExportOptions(true)" class="btn btn-small" style="margin-right: 0.5rem; font-size: 0.8rem; padding: 0.3rem 0.6rem;">
                        Tout sélectionner
                    </button>
                    <button onclick="toggleAllExportOptions(false)" class="btn btn-small" style="font-size: 0.8rem; padding: 0.3rem 0.6rem;">
                        Tout désélectionner
                    </button>
                </div>
            </div>

            <!-- Export Button -->
            <div style="text-align: center; padding-top: 1rem; border-top: 1px solid var(--border-color);">
                <button class="btn btn-primary" onclick="executeNovelExport()" style="padding: 0.75rem 2rem; font-size: 1rem; font-weight: 600;">
                    📥 Exporter
                </button>
            </div>

            <div class="modal-actions" style="margin-top: 1rem;">
                <button class="btn" onclick="closeModal('exportNovelModal')">Annuler</button>
            </div>
        </div>
    </div>

    <!-- Tension Words Editor Modal -->
    <div class="modal" id="tensionWordsModal">
        <div class="modal-content" style="max-width: 900px;">
            <div class="modal-title">✏️ Personnaliser les mots de tension</div>
            
            <div style="margin-bottom: 1.5rem; padding: 1rem; background: var(--bg-secondary); border-radius: 6px; border: 1px solid var(--border-color);">
                <p style="font-size: 0.9rem; color: var(--text-secondary); line-height: 1.6; margin: 0;">
                    Ces mots sont utilisés pour calculer automatiquement la tension narrative de vos scènes. 
                    Personnalisez-les selon votre style d'écriture et le genre de votre roman.
                </p>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 1.5rem; margin-bottom: 1.5rem;">
                <!-- High Tension Words -->
                <div style="background: var(--bg-secondary); border-radius: 8px; padding: 1.25rem; border: 2px solid rgba(196, 69, 54, 0.3);">
                    <h3 style="margin: 0 0 0.75rem 0; font-size: 1rem; color: var(--accent-red); display: flex; align-items: center; gap: 0.5rem;">
                        🔥 Haute tension
                        <span style="font-size: 0.75rem; color: var(--text-muted); font-weight: normal;">(+3 pts chacun)</span>
                    </h3>
                    <div style="margin-bottom: 0.75rem;">
                        <input type="text" id="highTensionInput" placeholder="Ajouter un mot..." 
                               style="width: 100%; padding: 0.5rem; background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); font-size: 0.85rem;"
                               onkeypress="if(event.key==='Enter') addTensionWord('high')">
                        <button onclick="addTensionWord('high')" 
                                style="width: 100%; margin-top: 0.5rem; padding: 0.5rem; background: var(--accent-red); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85rem; font-weight: 500;">
                            + Ajouter
                        </button>
                        <button onclick="openBulkImport('high')" 
                                style="width: 100%; margin-top: 0.5rem; padding: 0.5rem; background: rgba(196, 69, 54, 0.2); color: var(--accent-red); border: 1px solid var(--accent-red); border-radius: 4px; cursor: pointer; font-size: 0.85rem; font-weight: 500;">
                            📥 Import en masse
                        </button>
                    </div>
                    <div id="highTensionList" style="max-height: 300px; overflow-y: auto; display: flex; flex-direction: column; gap: 0.4rem;">
                        <!-- Words will be added here -->
                    </div>
                </div>

                <!-- Medium Tension Words -->
                <div style="background: var(--bg-secondary); border-radius: 8px; padding: 1.25rem; border: 2px solid rgba(230, 162, 60, 0.3);">
                    <h3 style="margin: 0 0 0.75rem 0; font-size: 1rem; color: #e6a23c; display: flex; align-items: center; gap: 0.5rem;">
                        ⚡ Tension moyenne
                        <span style="font-size: 0.75rem; color: var(--text-muted); font-weight: normal;">(+1.5 pts chacun)</span>
                    </h3>
                    <div style="margin-bottom: 0.75rem;">
                        <input type="text" id="mediumTensionInput" placeholder="Ajouter un mot..." 
                               style="width: 100%; padding: 0.5rem; background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); font-size: 0.85rem;"
                               onkeypress="if(event.key==='Enter') addTensionWord('medium')">
                        <button onclick="addTensionWord('medium')" 
                                style="width: 100%; margin-top: 0.5rem; padding: 0.5rem; background: #e6a23c; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85rem; font-weight: 500;">
                            + Ajouter
                        </button>
                        <button onclick="openBulkImport('medium')" 
                                style="width: 100%; margin-top: 0.5rem; padding: 0.5rem; background: rgba(230, 162, 60, 0.2); color: #e6a23c; border: 1px solid #e6a23c; border-radius: 4px; cursor: pointer; font-size: 0.85rem; font-weight: 500;">
                            📥 Import en masse
                        </button>
                    </div>
                    <div id="mediumTensionList" style="max-height: 300px; overflow-y: auto; display: flex; flex-direction: column; gap: 0.4rem;">
                        <!-- Words will be added here -->
                    </div>
                </div>

                <!-- Low Tension Words -->
                <div style="background: var(--bg-secondary); border-radius: 8px; padding: 1.25rem; border: 2px solid rgba(74, 144, 226, 0.3);">
                    <h3 style="margin: 0 0 0.75rem 0; font-size: 1rem; color: var(--accent-blue); display: flex; align-items: center; gap: 0.5rem;">
                        🌊 Faible tension
                        <span style="font-size: 0.75rem; color: var(--text-muted); font-weight: normal;">(-2 pts chacun)</span>
                    </h3>
                    <div style="margin-bottom: 0.75rem;">
                        <input type="text" id="lowTensionInput" placeholder="Ajouter un mot..." 
                               style="width: 100%; padding: 0.5rem; background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); font-size: 0.85rem;"
                               onkeypress="if(event.key==='Enter') addTensionWord('low')">
                        <button onclick="addTensionWord('low')" 
                                style="width: 100%; margin-top: 0.5rem; padding: 0.5rem; background: #2d6bb3; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85rem; font-weight: 500;">
                            + Ajouter
                        </button>
                        <button onclick="openBulkImport('low')" 
                                style="width: 100%; margin-top: 0.5rem; padding: 0.5rem; background: rgba(45, 107, 179, 0.15); color: #2d6bb3; border: 1px solid #2d6bb3; border-radius: 4px; cursor: pointer; font-size: 0.85rem; font-weight: 500;">
                            📥 Import en masse
                        </button>
                    </div>
                    <div id="lowTensionList" style="max-height: 300px; overflow-y: auto; display: flex; flex-direction: column; gap: 0.4rem;">
                        <!-- Words will be added here -->
                    </div>
                </div>
            </div>

            <div class="modal-actions" style="display: flex; justify-content: space-between; align-items: center;">
                <div style="display: flex; gap: 0.75rem;">
                    <button class="btn" onclick="exportTensionWords()" style="background: #2d6bb3; color: white; border: 1px solid #2d6bb3;">
                        📤 Exporter les dictionnaires
                    </button>
                    <button class="btn" onclick="resetTensionWordsToDefault()" style="background: var(--accent-red); color: white;">
                        🔄 Réinitialiser aux valeurs par défaut
                    </button>
                </div>
                <div style="display: flex; gap: 0.75rem;">
                    <button class="btn" onclick="closeModal('tensionWordsModal')">Annuler</button>
                    <button class="btn btn-primary" onclick="saveTensionWords()">💾 Enregistrer</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Bulk Import Modal -->
    <div class="modal" id="bulkImportModal">
        <div class="modal-content" style="max-width: 700px;">
            <div class="modal-title" id="bulkImportTitle">📥 Import en masse</div>
            
            <div style="margin-bottom: 1.5rem;">
                <p style="font-size: 0.9rem; color: var(--text-secondary); line-height: 1.6; margin-bottom: 1rem;">
                    Importez une liste de mots en masse. Vous pouvez :
                </p>
                <ul style="font-size: 0.85rem; color: var(--text-secondary); line-height: 1.8; padding-left: 1.5rem;">
                    <li><strong>Coller du texte</strong> : Un mot par ligne ou séparés par des virgules</li>
                    <li><strong>Importer un fichier</strong> : Fichier .txt avec un mot par ligne</li>
                </ul>
            </div>

            <div style="margin-bottom: 1.5rem;">
                <label class="form-label">Collez vos mots ici :</label>
                <textarea id="bulkImportText" 
                          placeholder="Ex: combat, bataille, mort&#10;tuer, danger, peur&#10;terreur, cri, hurler" 
                          style="width: 100%; min-height: 200px; padding: 0.75rem; background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); font-size: 0.85rem; font-family: monospace; resize: vertical;">
                </textarea>
                <div style="font-size: 0.75rem; color: var(--text-muted); margin-top: 0.5rem;">
                    💡 Formats acceptés : un mot par ligne, ou plusieurs mots séparés par des virgules
                </div>
            </div>

            <div style="margin-bottom: 1.5rem;">
                <label class="form-label">Ou importez un fichier .txt :</label>
                <input type="file" id="bulkImportFile" accept=".txt" 
                       style="width: 100%; padding: 0.5rem; background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); font-size: 0.85rem;">
            </div>

            <div style="padding: 1rem; background: rgba(74, 144, 226, 0.1); border-radius: 4px; border: 1px solid var(--accent-blue); margin-bottom: 1.5rem;">
                <div style="font-size: 0.85rem; font-weight: 600; color: var(--accent-blue); margin-bottom: 0.5rem;">
                    ℹ️ Mode de fusion
                </div>
                <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; margin-bottom: 0.5rem;">
                    <input type="radio" name="importMode" value="add" checked>
                    <span style="font-size: 0.85rem; color: var(--text-primary);">Ajouter aux mots existants (recommandé)</span>
                </label>
                <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                    <input type="radio" name="importMode" value="replace">
                    <span style="font-size: 0.85rem; color: var(--text-primary);">Remplacer tous les mots existants</span>
                </label>
            </div>

            <div class="modal-actions">
                <button class="btn" onclick="closeModal('bulkImportModal')">Annuler</button>
                <button class="btn btn-primary" onclick="processBulkImport()">📥 Importer les mots</button>
            </div>
        </div>
    </div>

    <!-- References Panel Modal -->
    <div class="modal" id="referencesModal">
        <div class="modal-content" style="max-width: 700px;">
            <div class="modal-title" id="referencesModalTitle">Références et Liens</div>
            <div id="referencesModalContent"></div>
            <div class="modal-actions">
                <button class="btn" onclick="closeModal('referencesModal')">Fermer</button>
            </div>
        </div>
    </div>


    <!-- Annotations Panel -->
    <div class="annotations-panel" id="annotationsPanel">
        <div class="annotations-panel-spacer"></div>
        <div class="annotations-panel-content" id="annotationsPanelContent"></div>
    </div>

    <!-- TODOs Panel -->
    <div class="annotations-panel" id="todosPanel">
        <div class="annotations-panel-spacer"></div>
        <div class="annotations-panel-content" id="todosPanelContent"></div>
    </div>

    <!-- Annotation Popup -->
    <div class="annotation-popup" id="annotationPopup">
        <h3 style="margin-bottom: 1rem;">Ajouter une annotation</h3>
        <div class="annotation-type-selector">
            <div class="annotation-type-btn comment active" onclick="selectAnnotationType('comment')"><i data-lucide="message-circle" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Commentaire</div>
            <div class="annotation-type-btn todo" onclick="selectAnnotationType('todo')"><i data-lucide="check-square" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>TODO</div>
            <div class="annotation-type-btn note" onclick="selectAnnotationType('note')"><i data-lucide="sticky-note" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Note</div>
            <div class="annotation-type-btn question" onclick="selectAnnotationType('question')">? Question</div>
        </div>
        <textarea id="annotationText" placeholder="Votre annotation..."></textarea>
        <div style="display: flex; gap: 0.75rem; justify-content: flex-end;">
            <button class="btn" onclick="closeAnnotationPopup()">Annuler</button>
            <button class="btn btn-primary" onclick="saveAnnotation()">Enregistrer</button>
        </div>
    </div>

    <!-- Floating Editor Menu Toggle Button (Mobile) -->
    <button id="floatingEditorToggle" onclick="toggleFloatingEditorMenu()">✏️</button>

    <!-- Floating Editor Menu (Mobile) -->
    <div id="floatingEditorMenu">
        <div id="floatingMenuContent">
            <!-- Annuler/Rétablir -->
            <button class="floating-btn-mini" onclick="undo()" title="Annuler">↶</button>
            <button class="floating-btn-mini" onclick="redo()" title="Rétablir">↷</button>
            
            <div class="floating-divider"></div>
            
            <!-- Formatage de base -->
            <button class="floating-btn-mini" onclick="formatText('bold')" title="Gras"><b>B</b></button>
            <button class="floating-btn-mini" onclick="formatText('italic')" title="Italique"><i>I</i></button>
            <button class="floating-btn-mini" onclick="formatText('underline')" title="Souligné"><u>U</u></button>
            <button class="floating-btn-mini" onclick="formatText('strikeThrough')" title="Barré"><s>S</s></button>
            
            <div class="floating-divider"></div>
            
            <!-- Alignement -->
            <button class="floating-btn-mini" onclick="formatText('justifyLeft')" title="Aligner à gauche">⬅</button>
            <button class="floating-btn-mini" onclick="formatText('justifyCenter')" title="Centrer">↔</button>
            <button class="floating-btn-mini" onclick="formatText('justifyRight')" title="Aligner à droite">➡</button>
            <button class="floating-btn-mini" onclick="formatText('justifyFull')" title="Justifier">⬌</button>
            
            <div class="floating-divider"></div>
            
            <!-- Listes -->
            <button class="floating-btn-mini" onclick="formatText('insertUnorderedList')" title="Liste à puces">•</button>
            <button class="floating-btn-mini" onclick="formatText('insertOrderedList')" title="Liste numérotée">1.</button>
            
            <div class="floating-divider"></div>
            
            <!-- Plus d'options - Toggle sous-menu -->
            <button class="floating-btn-mini" onclick="toggleAdvancedMenu()" id="advancedMenuBtn" title="Plus d'options">⋮</button>
        </div>
        
        <!-- Barre de sous-menu avancé (apparaît au-dessus grâce à column-reverse) -->
        <div id="advancedMenuBar" style="display: none;">
            <button class="floating-btn-mini" onclick="formatText('removeFormat')" title="Supprimer le formatage">🚫</button>
            <button class="floating-btn-mini" onclick="insertLink()" title="Insérer un lien"><i data-lucide="link" style="width:16px;height:16px;"></i></button>
            <button class="floating-btn-mini" onclick="formatText('formatBlock', 'h1')" title="Titre 1">H1</button>
            <button class="floating-btn-mini" onclick="formatText('formatBlock', 'h2')" title="Titre 2">H2</button>
            <button class="floating-btn-mini" onclick="formatText('formatBlock', 'h3')" title="Titre 3">H3</button>
            <button class="floating-btn-mini" onclick="formatText('formatBlock', 'blockquote')" title="Citation">❝</button>
            <button class="floating-btn-mini" onclick="formatText('insertHorizontalRule')" title="Ligne horizontale">―</button>
        </div>
    </div>
            <button class="floating-btn-mini" onclick="formatText('insertUnorderedList')" title="Liste à puces">•</button>
            <button class="floating-btn-mini" onclick="formatText('insertOrderedList')" title="Liste numérotée">1.</button>
            
            <div class="floating-divider"></div>
            
            <!-- Plus d'options - Toggle sous-menu -->
            <button class="floating-btn-mini" onclick="toggleAdvancedMenu()" id="advancedMenuBtn" title="Plus d'options">⋮</button>
        </div>
    </div>

    <script>
        // Data Structure
        let projects = []; // Array of all projects
        let currentProjectId = null;
        let project = {
            id: null,
            title: "Mon Roman",
            description: "",
            genre: "",
            createdAt: null,
            updatedAt: null,
            acts: [], // Acts contain chapters, chapters contain scenes
            characters: [], // Character database
            world: [], // World elements (locations, objects, concepts)
            timeline: [], // Timeline events
            notes: [], // Standalone notes and research
            codex: [], // Wiki/Codex entries for worldbuilding
            stats: {
                dailyGoal: 500,
                totalGoal: 80000,
                writingSessions: [] // Track writing sessions with word count and date
            },
            versions: [], // Version history snapshots
            relationships: [], // Cross-references between elements
            relations: [], // Character relations with types and colors
            characterPositions: {}, // Custom positions for relations graph
            mapLocations: [], // Geographic map markers
            mapImage: null, // Map image data URL
            visualTimeline: [], // Timeline visualization events
            metroTimeline: [], // Metro-style timeline with character links
            characterColors: {}, // Colors for metro timeline lines
            mindmaps: [] // Custom mindmaps with nodes and links
        };

        let currentActId = null;
        let currentChapterId = null;
        let currentSceneId = null;
        let activeActId = null;
        let activeChapterId = null;
        let currentView = 'editor'; // 'editor', 'characters', 'world', 'timeline', 'notes', 'stats', 'codex', 'versions'
        let currentMindmapId = null; // ID du mindmap actuellement affiché
        
        // SPLIT VIEW SYSTEM - New Architecture
        let splitViewActive = false;
        let splitActivePanel = 'left'; // 'left' or 'right' - which panel is currently active
        let splitViewState = {
            left: {
                view: 'editor',
                sceneId: null,
                actId: null,
                chapterId: null,
                characterId: null,
                worldId: null,
                noteId: null,
                codexId: null
            },
            right: {
                view: null, // null = empty
                sceneId: null,
                actId: null,
                chapterId: null,
                characterId: null,
                worldId: null,
                noteId: null,
                codexId: null
            },
            ratio: 60,
            persistOnReload: true
        };

        // TREE STATE - pour mémoriser l'état d'expansion
        let expandedActs = new Set(); // IDs des actes dépliés
        let expandedChapters = new Set(); // IDs des chapitres dépliés

        // REVISION MODE VARIABLES
        let revisionMode = false;
        let selectedHighlightColor = 'yellow';
        let selectedAnnotationType = 'comment';
        let currentSelection = null; // 'editor', 'characters', 'world', 'timeline', 'notes', 'stats', 'codex', 'versions'

        // UNDO/REDO SYSTEM
        let historyStack = []; // Stack pour les états précédents
        let redoStack = []; // Stack pour redo
        let maxHistorySize = 50; // Garder max 50 états
        let isUndoRedoAction = false; // Flag pour éviter de sauvegarder pendant undo/redo
        let historyDebounceTimer = null; // Timer pour debounce
        let historyDebounceDelay = 2000; // 2 secondes de délai

        // ============================================
        // INDEXEDDB FUNCTIONS
        // ============================================
        
        let db = null; // Instance de la base de données
        
        // Initialiser IndexedDB
        async function initDB() {
            try {
                console.log('🔧 Initialisation IndexedDB...');
                
                // Ouvrir (ou créer) la base de données
                db = await idb.openDB('PlumeDB', 1, {
                    upgrade(db) {
                        // Créer les object stores si ils n'existent pas
                        if (!db.objectStoreNames.contains('projects')) {
                            db.createObjectStore('projects', { keyPath: 'id' });
                            console.log('✅ Object store "projects" créé');
                        }
                        if (!db.objectStoreNames.contains('settings')) {
                            db.createObjectStore('settings');
                            console.log('✅ Object store "settings" créé');
                        }
                    }
                });
                
                console.log('✅ IndexedDB initialisé avec succès');
                
                // Migrer depuis localStorage si nécessaire
                await migrateFromLocalStorage();
                
                return true;
            } catch (error) {
                console.error('❌ Erreur initialisation IndexedDB:', error);
                alert('Erreur lors de l\'initialisation de la base de données. Veuillez réessayer.');
                return false;
            }
        }
        
        // Migrer les données depuis localStorage vers IndexedDB
        async function migrateFromLocalStorage() {
            try {
                // Vérifier si migration déjà effectuée
                const migrated = await db.get('settings', 'migrated_from_localStorage');
                if (migrated) {
                    console.log('✅ Migration déjà effectuée précédemment');
                    return;
                }
                
                console.log('🔄 Vérification des données localStorage...');
                
                // Récupérer les anciennes données
                const oldData = localStorage.getItem('novelcraft_project');
                const oldProjects = localStorage.getItem('novelcraft_projects');
                const oldCurrentId = localStorage.getItem('novelcraft_currentProjectId');
                const oldTreeState = localStorage.getItem('treeState');
                
                if (!oldData && !oldProjects) {
                    console.log('ℹ️ Aucune donnée à migrer');
                    await db.put('settings', true, 'migrated_from_localStorage');
                    return;
                }
                
                console.log('📦 Migration des données...');
                
                // Migrer le projet actuel
                if (oldData) {
                    try {
                        const projectData = JSON.parse(oldData);
                        
                        // S'assurer qu'il a un ID
                        if (!projectData.id) {
                            projectData.id = 'project_' + Date.now();
                        }
                        
                        // S'assurer qu'il a des timestamps
                        if (!projectData.createdAt) {
                            projectData.createdAt = Date.now();
                        }
                        if (!projectData.updatedAt) {
                            projectData.updatedAt = Date.now();
                        }
                        
                        await db.put('projects', projectData);
                        console.log('✅ Projet principal migré:', projectData.title);
                    } catch (e) {
                        console.error('❌ Erreur migration projet:', e);
                    }
                }
                
                // Migrer la liste des projets
                if (oldProjects) {
                    try {
                        const projectsList = JSON.parse(oldProjects);
                        for (const proj of projectsList) {
                            // Éviter les doublons
                            const existing = await db.get('projects', proj.id);
                            if (!existing) {
                                await db.put('projects', proj);
                                console.log('✅ Projet migré:', proj.title);
                            }
                        }
                    } catch (e) {
                        console.error('❌ Erreur migration liste projets:', e);
                    }
                }
                
                // Migrer les settings
                if (oldCurrentId) {
                    await db.put('settings', oldCurrentId, 'currentProjectId');
                }
                if (oldTreeState) {
                    await db.put('settings', oldTreeState, 'treeState');
                }
                
                // Marquer la migration comme effectuée
                await db.put('settings', true, 'migrated_from_localStorage');
                
                console.log('✅ Migration terminée avec succès !');
                console.log('ℹ️ Les anciennes données localStorage sont conservées par sécurité');
                
                // NE PAS supprimer localStorage pour l'instant (sécurité)
                // L'utilisateur pourra le faire manuellement plus tard
                
            } catch (error) {
                console.error('❌ Erreur lors de la migration:', error);
            }
        }
        
        // Sauvegarder un projet dans IndexedDB
        async function saveProjectToDB(projectData) {
            try {
                if (!db) {
                    console.error('❌ Base de données non initialisée');
                    return false;
                }
                
                // S'assurer que le projet a un ID
                if (!projectData.id) {
                    projectData.id = 'project_' + Date.now();
                }
                
                // Mettre à jour le timestamp
                projectData.updatedAt = Date.now();
                
                // Sauvegarder dans IndexedDB
                await db.put('projects', projectData);
                
                console.log('💾 Projet sauvegardé dans IndexedDB:', projectData.title);
                return true;
            } catch (error) {
                console.error('❌ Erreur sauvegarde IndexedDB:', error);
                alert('Erreur lors de la sauvegarde. Veuillez exporter votre projet par sécurité.');
                return false;
            }
        }
        
        // Charger un projet depuis IndexedDB
        async function loadProjectFromDB(projectId) {
            try {
                if (!db) {
                    console.error('❌ Base de données non initialisée');
                    return null;
                }
                
                const projectData = await db.get('projects', projectId);
                
                if (projectData) {
                    console.log('📖 Projet chargé depuis IndexedDB:', projectData.title);
                    return projectData;
                } else {
                    console.log('ℹ️ Projet non trouvé:', projectId);
                    return null;
                }
            } catch (error) {
                console.error('❌ Erreur chargement IndexedDB:', error);
                return null;
            }
        }
        
        // Charger tous les projets
        async function loadAllProjectsFromDB() {
            try {
                if (!db) {
                    console.error('❌ Base de données non initialisée');
                    return [];
                }
                
                const allProjects = await db.getAll('projects');
                console.log(`📚 ${allProjects.length} projet(s) chargé(s)`);
                return allProjects;
            } catch (error) {
                console.error('❌ Erreur chargement projets:', error);
                return [];
            }
        }
        
        // Supprimer un projet
        async function deleteProjectFromDB(projectId) {
            try {
                if (!db) {
                    console.error('❌ Base de données non initialisée');
                    return false;
                }
                
                await db.delete('projects', projectId);
                console.log('🗑️ Projet supprimé:', projectId);
                return true;
            } catch (error) {
                console.error('❌ Erreur suppression projet:', error);
                return false;
            }
        }
        
        // Obtenir la taille totale utilisée par IndexedDB
        async function getIndexedDBSize() {
            try {
                if (!db) return 0;
                
                const allProjects = await db.getAll('projects');
                const allSettings = await db.getAll('settings');
                
                // Calculer la taille approximative
                const projectsSize = JSON.stringify(allProjects).length * 2; // UTF-16
                const settingsSize = JSON.stringify(allSettings).length * 2;
                
                return projectsSize + settingsSize;
            } catch (error) {
                console.error('❌ Erreur calcul taille IndexedDB:', error);
                return 0;
            }
        }
        
        // Sauvegarder un setting
        async function saveSetting(key, value) {
            try {
                if (!db) return false;
                await db.put('settings', value, key);
                return true;
            } catch (error) {
                console.error('❌ Erreur sauvegarde setting:', error);
                return false;
            }
        }
        
        // Charger un setting
        async function loadSetting(key) {
            try {
                if (!db) return null;
                return await db.get('settings', key);
            } catch (error) {
                console.error('❌ Erreur chargement setting:', error);
                return null;
            }
        }

        // ============================================
        // END INDEXEDDB FUNCTIONS
        // ============================================

        // View Management (définie tôt pour être accessible partout)
        function switchView(view) {
            // Si split view actif, changer la vue du panneau actif
            if (splitViewActive) {
                switchSplitPanelView(splitActivePanel, view);
                return;
            }
            
            currentView = view;
            
            // Update header nav buttons
            document.querySelectorAll('[id^="header-tab-"]').forEach(btn => {
                btn.classList.remove('active');
            });
            const headerBtn = document.getElementById(`header-tab-${view}`);
            if (headerBtn) {
                headerBtn.classList.add('active');
            }
            
            // Éléments spécifiques à la vue Structure
            const structureOnlyElements = [
                'projectProgressBar',  // Barre de progression
                'statusFilters',       // Filtres Brouillon/En cours/Terminé/À réviser
                'sceneTools'           // Boutons Versions/Annotations/TODOs
            ];
            
            // Masquer/Afficher les éléments Structure uniquement
            structureOnlyElements.forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    el.style.display = (view === 'editor') ? '' : 'none';
                }
            });
            
            // Update tree collapse toolbar visibility (for views with collapsible groups)
            const treeCollapseToolbar = document.getElementById('treeCollapseToolbar');
            const viewsWithGroups = ['editor', 'world', 'notes', 'codex'];
            if (treeCollapseToolbar) {
                treeCollapseToolbar.style.display = viewsWithGroups.includes(view) ? '' : 'none';
            }
            
            // Gérer la sidebar des versions (à droite)
            const sidebarVersions = document.getElementById('sidebarVersions');
            if (sidebarVersions) {
                // Toujours cacher par défaut lors du changement de vue
                // L'utilisateur peut l'ouvrir manuellement s'il le souhaite
                if (view !== 'editor') {
                    sidebarVersions.classList.add('hidden');
                }
                // Si on est en vue editor, ne rien changer (garde l'état actuel)
            }
            
            // Cacher toutes les listes de la sidebar
            const sidebarLists = [
                'chaptersList', 'charactersList', 'worldList', 'timelineList', 
                'notesList', 'codexList', 'statsList', 'versionsList', 'analysisList',
                'todosList', 'corkboardList', 'mindmapList', 'plotList', 
                'relationsList', 'mapList', 'timelineVizList', 'noSidebarMessage'
            ];
            
            sidebarLists.forEach(listId => {
                const el = document.getElementById(listId);
                if (el) el.style.display = 'none';
            });
            
            // Vues qui utilisent la sidebar (listes à gauche)
            const sidebarViews = {
                'editor': 'chaptersList',
                'characters': 'charactersList',
                'world': 'worldList',
                'notes': 'notesList',
                'codex': 'codexList',
                'mindmap': 'mindmapList',
                'timelineviz': 'timelineVizList'
            };
            
            // Vues qui utilisent editorView entièrement (visualisations plein écran sans sidebar)
            const editorViewVues = ['stats', 'analysis', 'versions', 'todos', 'timeline', 'corkboard', 'plot', 'relations', 'map'];
            
            // Labels pour les vues sans sidebar
            const viewLabelsNoSidebar = {
                'stats': 'Statistiques',
                'analysis': 'Analyse',
                'versions': 'Versions',
                'todos': 'TODOs',
                'timeline': 'Timeline',
                'corkboard': 'Tableau',
                'plot': 'Intrigue',
                'relations': 'Relations',
                'map': 'Carte'
            };
            
            // Afficher la bonne liste sidebar si applicable
            if (sidebarViews[view]) {
                const listEl = document.getElementById(sidebarViews[view]);
                if (listEl) listEl.style.display = 'block';
            } else if (editorViewVues.includes(view)) {
                // Afficher le message pour les vues sans sidebar
                const noSidebarEl = document.getElementById('noSidebarMessage');
                if (noSidebarEl) {
                    const viewLabel = viewLabelsNoSidebar[view] || 'Cette vue';
                    noSidebarEl.innerHTML = `
                        <div style="padding: 2rem 1rem; text-align: center; color: var(--text-muted);">
                            <i data-lucide="layout-dashboard" style="width: 48px; height: 48px; opacity: 0.3; margin-bottom: 1rem;"></i>
                            <div style="font-size: 0.9rem; line-height: 1.6;">
                                <strong>${viewLabel}</strong> utilise tout l'espace disponible.
                            </div>
                            <div style="font-size: 0.85rem; margin-top: 0.5rem; opacity: 0.8;">
                                La barre latérale n'est pas utilisée dans cette vue.
                            </div>
                        </div>
                    `;
                    noSidebarEl.style.display = 'block';
                    
                    // Refresh icons
                    setTimeout(() => {
                        if (typeof lucide !== 'undefined') lucide.createIcons();
                    }, 50);
                }
            }
            
            // Sur mobile, créer une vue centrale pour les vues sidebar
            const isMobile = window.innerWidth <= 900;
            const editorView = document.getElementById('editorView');
            
            if (isMobile && sidebarViews[view]) {
                // Créer une vue mobile pour les vues avec sidebar
                renderMobileSidebarView(view);
            } else if (editorViewVues.includes(view)) {
                // Ces vues remplissent l'editorView
                if (editorView) {
                    // Le contenu sera rempli par les fonctions de rendu
                }
            }
            
            // Update sidebar actions
            const actionsHTML = {
                editor: '<button class="btn btn-primary" onclick="openAddActModal()">+ Acte</button><button class="btn btn-primary" onclick="openAddChapterModal()">+ Chapitre</button><button class="btn btn-primary" onclick="openAddSceneModalQuick()">+ Scène</button>',
                characters: '<button class="btn btn-primary" onclick="openAddCharacterModal()">+ Personnage</button>',
                world: '<button class="btn btn-primary" onclick="openAddWorldModal()">+ Élément</button>',
                notes: '<button class="btn btn-primary" onclick="openAddNoteModal()">+ Note</button>',
                codex: '<button class="btn btn-primary" onclick="openAddCodexModal()">+ Entrée</button>'
            };
            const sidebarActions = document.getElementById('sidebarActions');
            if (sidebarActions) {
                sidebarActions.innerHTML = actionsHTML[view] || '';
            }
            
            // Render appropriate content based on view
            renderViewContent(view, 'editorView');
            
            // Refresh Lucide icons after view change
            setTimeout(() => {
                if (typeof lucide !== 'undefined') lucide.createIcons();
            }, 50);
        }
        
        // Fonction pour rendre le contenu d'une vue dans un conteneur donné
        function renderViewContent(view, containerId) {
            const container = document.getElementById(containerId);
            if (!container) return;
            
            switch(view) {
                case 'editor':
                    if (currentActId && currentChapterId && currentSceneId) {
                        // Use renderEditor for the main editor view (not split mode)
                        if (containerId === 'editorView' && !splitViewActive) {
                            const act = project.acts.find(a => a.id === currentActId);
                            if (act) {
                                const chapter = act.chapters.find(c => c.id === currentChapterId);
                                if (chapter) {
                                    const scene = chapter.scenes.find(s => s.id === currentSceneId);
                                    if (scene) {
                                        renderEditor(act, chapter, scene);
                                    }
                                }
                            }
                        } else {
                            // Use simplified version for split-view panels
                            renderSceneInContainer(currentActId, currentChapterId, currentSceneId, containerId);
                        }
                    } else if (project.acts.length === 0 || (project.acts.length === 1 && project.acts[0].chapters.length === 0)) {
                        container.innerHTML = `
                            <div class="empty-state">
                                <div class="empty-state-icon">✍️</div>
                                <div class="empty-state-title">Commencez votre histoire</div>
                                <div class="empty-state-text">Créez votre premier chapitre pour commencer à écrire.</div>
                                <button class="btn btn-primary" onclick="openAddChapterModal()">+ Créer un chapitre</button>
                            </div>
                        `;
                    } else {
                        container.innerHTML = `
                            <div class="empty-state">
                                <div class="empty-state-icon">✍️</div>
                                <div class="empty-state-title">Sélectionnez une scène</div>
                                <div class="empty-state-text">Choisissez une scène dans la barre latérale pour commencer à écrire.</div>
                            </div>
                        `;
                    }
                    break;
                case 'characters':
                    if (typeof renderCharactersList === 'function') renderCharactersList();
                    renderCharacterWelcome();
                    break;
                case 'world':
                    if (typeof renderWorldList === 'function') renderWorldList();
                    renderWorldWelcome();
                    break;
                case 'notes':
                    if (typeof renderNotesList === 'function') renderNotesList();
                    renderNotesWelcome();
                    break;
                case 'codex':
                    if (typeof renderCodexList === 'function') renderCodexList();
                    renderCodexWelcome();
                    break;
                case 'stats':
                    if (typeof renderStats === 'function') renderStats();
                    break;
                case 'analysis':
                    if (typeof renderAnalysis === 'function') renderAnalysis();
                    break;
                case 'versions':
                    if (typeof renderVersionsList === 'function') renderVersionsList();
                    break;
                case 'todos':
                    if (typeof renderTodosList === 'function') renderTodosList();
                    break;
                case 'corkboard':
                    if (typeof openCorkBoardView === 'function') openCorkBoardView();
                    break;
                case 'mindmap':
                    if (typeof renderMindmapView === 'function') renderMindmapView();
                    break;
                case 'plot':
                    if (typeof renderPlotView === 'function') renderPlotView();
                    break;
                case 'relations':
                    if (typeof renderRelationsView === 'function') renderRelationsView();
                    break;
                case 'map':
                    if (typeof renderMapView === 'function') renderMapView();
                    break;
                case 'timelineviz':
                    if (typeof renderTimelineVizView === 'function') renderTimelineVizView();
                    break;
                default:
                    container.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-state-icon"><i data-lucide="layout" style="width:48px;height:48px;stroke-width:1;"></i></div>
                            <div class="empty-state-title">Panneau vide</div>
                            <div class="empty-state-text">Cliquez sur l'en-tête pour choisir une vue</div>
                        </div>
                    `;
            }
        }
        
        // Render scene in a specific container (for split view)
        function renderSceneInContainer(actId, chapterId, sceneId, containerId) {
            const container = document.getElementById(containerId);
            if (!container) return;
            
            const act = project.acts.find(a => a.id === actId);
            if (!act) return;
            const chapter = act.chapters.find(c => c.id === chapterId);
            if (!chapter) return;
            const scene = chapter.scenes.find(s => s.id === sceneId);
            if (!scene) return;
            
            const wordCount = getWordCount(scene.content || '');
            
            container.innerHTML = `
                <div class="split-scene-view" style="height: 100%; display: flex; flex-direction: column;">
                    <div style="padding: 0.75rem 1rem; background: var(--bg-secondary); border-bottom: 1px solid var(--border-color);">
                        <div style="font-size: 0.8rem; color: var(--text-muted);">${act.title} > ${chapter.title}</div>
                        <div style="font-size: 1.1rem; font-weight: 600;">${scene.title || 'Sans titre'}</div>
                        <div style="font-size: 0.75rem; color: var(--text-muted);">${wordCount} mots</div>
                    </div>
                    <div class="editor-textarea" 
                         contenteditable="true" 
                         data-container="${containerId}"
                         data-scene-id="${scene.id}"
                         data-chapter-id="${chapter.id}"
                         data-act-id="${act.id}"
                         oninput="updateSplitSceneContent(this)"
                         style="flex: 1; padding: 1.5rem; overflow-y: auto; outline: none; line-height: 1.8; font-size: 1.1rem;"
                    >${scene.content || ''}</div>
                </div>
            `;
        }

        let lastSavedState = null; // Dernier état sauvegardé pour détecter les changements

        // Projects Management
        function openProjectsModal() {
            renderProjectsList();
            document.getElementById('projectsModal').classList.add('active');
        }

        function openNewProjectModal() {
            document.getElementById('newProjectModal').classList.add('active');
            setTimeout(() => document.getElementById('newProjectTitle').focus(), 100);
        }

        function createNewProject() {
            const title = document.getElementById('newProjectTitle').value.trim();
            const description = document.getElementById('newProjectDesc').value.trim();
            const genre = document.getElementById('newProjectGenre').value;
            const template = document.getElementById('newProjectTemplate').value;

            if (!title) {
                alert('Veuillez entrer un titre pour le projet');
                return;
            }

            const newProject = {
                id: Date.now(),
                title: title,
                description: description,
                genre: genre,
                createdAt: new Date().toISOString(),
                updatedAt: new Date().toISOString(),
                acts: [],
                characters: [],
                world: [],
                timeline: [],
                notes: [],
                codex: [],
                stats: { dailyGoal: 500, totalGoal: 80000, writingSessions: [] },
                versions: [],
                relationships: []
            };

            // Apply template if selected
            if (template === 'fantasy') {
                newProject.acts = [
                    { id: Date.now(), title: "Acte I - Le Monde Ordinaire", chapters: [] },
                    { id: Date.now() + 1, title: "Acte II - L'Aventure", chapters: [] },
                    { id: Date.now() + 2, title: "Acte III - Le Retour", chapters: [] }
                ];
                newProject.stats.dailyGoal = 1000;
                newProject.stats.totalGoal = 120000;
            } else if (template === 'thriller') {
                newProject.acts = [
                    { id: Date.now(), title: "Acte I - L'Incident", chapters: [] },
                    { id: Date.now() + 1, title: "Acte II - La Tension", chapters: [] },
                    { id: Date.now() + 2, title: "Acte III - Le Dénouement", chapters: [] }
                ];
                newProject.stats.dailyGoal = 800;
                newProject.stats.totalGoal = 90000;
            } else if (template === 'scifi') {
                newProject.acts = [
                    { id: Date.now(), title: "Acte I - Découverte", chapters: [] },
                    { id: Date.now() + 1, title: "Acte II - Exploration", chapters: [] },
                    { id: Date.now() + 2, title: "Acte III - Révélation", chapters: [] }
                ];
                newProject.stats.dailyGoal = 1000;
                newProject.stats.totalGoal = 150000;
            }

            projects.push(newProject);
            saveAllProjects();
            
            document.getElementById('newProjectTitle').value = '';
            document.getElementById('newProjectDesc').value = '';
            document.getElementById('newProjectGenre').value = '';
            document.getElementById('newProjectTemplate').value = '';
            
            closeModal('newProjectModal');
            switchToProject(newProject.id);
            closeModal('projectsModal');
        }

        function switchToProject(projectId) {
            currentProjectId = projectId;
            project = projects.find(p => p.id === projectId);
            
            if (!project) return;

            const headerTitle = document.getElementById('headerProjectTitle');
            if (headerTitle) headerTitle.textContent = project.title;
            
            currentActId = null;
            currentChapterId = null;
            currentSceneId = null;
            
            switchView('editor');
            renderActsList();
            showEmptyState();
            
            localStorage.setItem('novelcraft_current_project', projectId);
        }

        function deleteProject(projectId) {
            const proj = projects.find(p => p.id === projectId);
            if (!proj) return;

            if (!confirm(`Supprimer "${proj.title}" ?\n\nIrréversible !`)) return;

            projects = projects.filter(p => p.id !== projectId);
            saveAllProjects();

            if (currentProjectId === projectId) {
                if (projects.length > 0) {
                    switchToProject(projects[0].id);
                } else {
                    createDefaultProject();
                }
            }

            renderProjectsList();
        }

        function exportProjectIndividual(projectId) {
            const proj = projects.find(p => p.id === projectId);
            if (!proj) return;

            const dataStr = JSON.stringify(proj, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${proj.title.replace(/\s+/g, '_')}_${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function importProject() {
            document.getElementById('importProjectInput').click();
        }

        function handleProjectImport(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const imported = JSON.parse(e.target.result);
                    if (!imported.title) throw new Error('Format invalide');

                    imported.id = Date.now();
                    imported.title += " (Importé)";
                    imported.createdAt = new Date().toISOString();
                    imported.updatedAt = new Date().toISOString();

                    projects.push(imported);
                    saveAllProjects();
                    renderProjectsList();
                    alert(`✅ "${imported.title}" importé !`);
                } catch (error) {
                    alert('❌ Erreur: ' + error.message);
                }
                event.target.value = '';
            };
            reader.readAsText(file);
        }

        function renderProjectsList() {
            const container = document.getElementById('projectsList');
            
            if (projects.length === 0) {
                container.innerHTML = '<div style="padding: 2rem; text-align: center; color: var(--text-muted);">Aucun projet</div>';
                return;
            }

            container.innerHTML = projects.map(proj => {
                const wordCount = proj.acts.reduce((sum, act) => sum + act.chapters.reduce((ch, chapter) => ch + chapter.scenes.reduce((sc, scene) => sc + getWordCount(scene.content), 0), 0), 0);
                const isActive = proj.id === currentProjectId;

                return `
                    <div class="project-card ${isActive ? 'active' : ''}" onclick="switchToProject(${proj.id}); closeModal('projectsModal');">
                        <div class="project-card-header">
                            <div>
                                <div class="project-card-title">${proj.title}</div>
                                ${proj.genre ? `<span class="project-card-genre">${proj.genre}</span>` : ''}
                            </div>
                            ${isActive ? '<span style="color: var(--accent-red); font-weight: 600;">● Actif</span>' : ''}
                        </div>
                        ${proj.description ? `<div class="project-card-desc">${proj.description}</div>` : ''}
                        <div class="project-card-stats">
                            <span>${wordCount.toLocaleString('fr-FR')} mots</span>
                            <span>${proj.acts.length} actes</span>
                            <span>${proj.characters.length} personnages</span>
                        </div>
                        <div class="project-card-actions">
                            <button class="btn btn-small" onclick="event.stopPropagation(); exportProjectIndividual(${proj.id})">📤 Exporter</button>
                            <button class="btn btn-small" onclick="event.stopPropagation(); deleteProject(${proj.id})">🗑️ Supprimer</button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        async function saveAllProjects() {
            try {
                if (currentProjectId) {
                    const index = projects.findIndex(p => p.id === currentProjectId);
                    if (index >= 0) {
                        projects[index] = { ...project, updatedAt: new Date().toISOString() };
                    }
                }
                
                // Sauvegarder tous les projets dans IndexedDB
                for (const proj of projects) {
                    await saveProjectToDB(proj);
                }
                
                // Sauvegarder le projet actuel
                await saveSetting('currentProjectId', currentProjectId);
                
                console.log('💾 Tous les projets sauvegardés');
            } catch (error) {
                console.error('❌ Erreur sauvegarde projets:', error);
            }
        }

        async function loadAllProjects() {
            try {
                // Charger tous les projets depuis IndexedDB
                const loadedProjects = await loadAllProjectsFromDB();
                
                if (loadedProjects && loadedProjects.length > 0) {
                    projects = loadedProjects;
                    
                    // Charger le dernier projet utilisé
                    const savedId = await loadSetting('currentProjectId');
                    
                    if (savedId) {
                        currentProjectId = savedId;
                        project = projects.find(p => p.id === currentProjectId);
                    }
                    
                    // Si projet non trouvé, prendre le premier
                    if (!project && projects.length > 0) {
                        project = projects[0];
                        currentProjectId = project.id;
                    }
                } else {
                    // Aucun projet trouvé, créer un projet par défaut
                    createDefaultProject();
                    await saveProjectToDB(project);
                }
                
                ensureProjectStructure();
                
                if (project?.title) {
                    const headerTitle = document.getElementById('headerProjectTitle');
                    if (headerTitle) headerTitle.textContent = project.title;
                }
                
                console.log('✅ Projets chargés:', projects.length);
            } catch (error) {
                console.error('❌ Erreur chargement projets:', error);
                createDefaultProject();
            }
        }

        function createDefaultProject() {
            project = {
                id: Date.now(),
                title: "Mon Roman",
                description: "",
                genre: "",
                createdAt: new Date().toISOString(),
                updatedAt: new Date().toISOString(),
                acts: [],
                characters: [],
                world: [],
                timeline: [],
                notes: [],
                codex: [],
                stats: { dailyGoal: 500, totalGoal: 80000, writingSessions: [] },
                versions: [],
                relationships: []
            };
            projects = [project];
            currentProjectId = project.id;
        }

        function ensureProjectStructure() {
            if (!project) return;
            project.characters = project.characters || [];
            project.world = project.world || [];
            project.timeline = project.timeline || [];
            project.notes = project.notes || [];
            project.codex = project.codex || [];
            project.stats = project.stats || { dailyGoal: 500, totalGoal: 80000, writingSessions: [] };
            project.versions = project.versions || [];
            project.relationships = project.relationships || [];
        }

        const originalSaveProject = saveProject;
        saveProject = function() {
            saveAllProjects();
        };

        // Text Analysis Tools
        function renderAnalysis() {
            const editorView = document.getElementById('editorView');
            if (!editorView) {
                console.error('editorView not found');
                return;
            }
            
            editorView.innerHTML = `
                <div style="height: 100%; overflow-y: auto; padding: 2rem 3rem;">
                    <h2 style="margin-bottom: 2rem; color: var(--accent-gold);"><i data-lucide="scan-search" style="width:24px;height:24px;vertical-align:middle;margin-right:8px;"></i>Analyse du texte</h2>
                    
                    <div style="background: var(--bg-secondary); padding: 2rem; border-radius: 8px; margin-bottom: 2rem;">
                        <label style="display: block; font-weight: 600; margin-bottom: 1rem; font-size: 1rem;">Portée de l'analyse :</label>
                        <select id="analysisScope" class="form-input" style="width: 100%; max-width: 400px; font-size: 1rem;">
                            <option value="current">Scène actuelle</option>
                            <option value="chapter">Chapitre actuel</option>
                            <option value="act">Acte actuel</option>
                            <option value="all">Tout le projet</option>
                        </select>
                    </div>
                    
                    <div id="analysisResults"></div>
                </div>
            `;
            
            // Attach event listener after DOM is updated
            setTimeout(() => {
                const scopeSelect = document.getElementById('analysisScope');
                if (scopeSelect) {
                    scopeSelect.addEventListener('change', runTextAnalysis);
                }
                runTextAnalysis();
            }, 0);
        }

        function runTextAnalysis() {
            const scope = document.getElementById('analysisScope')?.value || 'current';
            const text = getTextForAnalysis(scope);
            
            if (!text || text.trim().length === 0) {
                document.getElementById('analysisResults').innerHTML = '<div style="padding: 2rem; text-align: center; color: var(--text-muted);">Aucun texte à analyser</div>';
                return;
            }

            const analysis = {
                wordCount: getWordCount(text),
                repetitions: detectRepetitions(text),
                readability: calculateReadability(text),
                wordFrequency: calculateWordFrequency(text),
                sentenceLength: calculateSentenceLength(text),
                narrativeDistribution: analyzeNarrativeDistribution(text)
            };

            displayAnalysisResults(analysis);
        }

        function getTextForAnalysis(scope) {
            console.log('getTextForAnalysis called with scope:', scope);
            console.log('currentActId:', currentActId, 'currentChapterId:', currentChapterId, 'currentSceneId:', currentSceneId);
            
            if (scope === 'current' && currentSceneId) {
                const act = project.acts.find(a => a.id === currentActId);
                if (!act) return '';
                const chapter = act.chapters.find(c => c.id === currentChapterId);
                if (!chapter) return '';
                const scene = chapter.scenes.find(s => s.id === currentSceneId);
                if (!scene) return '';
                console.log('Current scene text length:', stripHTML(scene.content).length);
                return stripHTML(scene.content);
            } else if (scope === 'chapter') {
                if (!currentChapterId) {
                    // Try to use first chapter of first act
                    if (project.acts.length > 0 && project.acts[0].chapters.length > 0) {
                        const chapter = project.acts[0].chapters[0];
                        const text = chapter.scenes.map(s => stripHTML(s.content)).join('\n\n');
                        console.log('Using first chapter, text length:', text.length);
                        return text;
                    }
                    return '';
                }
                const act = project.acts.find(a => a.id === currentActId);
                if (!act) return '';
                const chapter = act.chapters.find(c => c.id === currentChapterId);
                if (!chapter) return '';
                const text = chapter.scenes.map(s => stripHTML(s.content)).join('\n\n');
                console.log('Chapter text length:', text.length);
                return text;
            } else if (scope === 'act') {
                if (!currentActId) {
                    // Try to use first act
                    if (project.acts.length > 0) {
                        const act = project.acts[0];
                        const text = act.chapters.flatMap(ch => ch.scenes.map(s => stripHTML(s.content))).join('\n\n');
                        console.log('Using first act, text length:', text.length);
                        return text;
                    }
                    return '';
                }
                const act = project.acts.find(a => a.id === currentActId);
                if (!act) return '';
                const text = act.chapters.flatMap(ch => ch.scenes.map(s => stripHTML(s.content))).join('\n\n');
                console.log('Act text length:', text.length);
                return text;
            } else if (scope === 'all') {
                const text = project.acts.flatMap(a => a.chapters.flatMap(ch => ch.scenes.map(s => stripHTML(s.content)))).join('\n\n');
                console.log('All project text length:', text.length);
                return text;
            }
            return '';
        }

        function stripHTML(html) {
            const div = document.createElement('div');
            div.innerHTML = html;
            return div.textContent || div.innerText || '';
        }

        function detectRepetitions(text) {
            // Correction pour inclure les caractères accentués français et autres Unicode
            const words = text.toLowerCase().match(/[\p{L}]{4,}/gu) || []; 
            const frequency = {};
            words.forEach(word => frequency[word] = (frequency[word] || 0) + 1);
            
            const repeated = Object.entries(frequency)
                .filter(([word, count]) => count >= 5)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10);
            
            return repeated;
        }

        function calculateReadability(text) {
            const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
            // Correction pour inclure les caractères accentués français et autres Unicode
            const words = text.match(/[\p{L}]+/gu) || []; 
            const syllables = words.reduce((sum, word) => sum + countSyllables(word), 0);
            
            if (sentences.length === 0 || words.length === 0) return { score: 0, level: 'N/A' };
            
            // Flesch Reading Ease (adapted for French)
            const avgWordsPerSentence = words.length / sentences.length;
            const avgSyllablesPerWord = syllables / words.length;
            const score = 206.835 - (1.015 * avgWordsPerSentence) - (84.6 * avgSyllablesPerWord);
            
            let level = '';
            if (score >= 90) level = 'Très facile';
            else if (score >= 80) level = 'Facile';
            else if (score >= 70) level = 'Assez facile';
            else if (score >= 60) level = 'Standard';
            else if (score >= 50) level = 'Assez difficile';
            else if (score >= 30) level = 'Difficile';
            else level = 'Très difficile';
            
            return { score: Math.max(0, Math.min(100, score)).toFixed(1), level };
        }

        function countSyllables(word) {
            word = word.toLowerCase();
            const vowels = /[aeiouyàâäéèêëïîôùûü]/g;
            const matches = word.match(vowels);
            if (!matches) return 1;
            
            let count = matches.length;
            // Adjustments for French
            if (word.endsWith('e')) count--;
            if (word.match(/[aeiouy]{2,}/)) count--;
            return Math.max(1, count);
        }

        function calculateWordFrequency(text) {
            // Correction pour inclure les caractères accentués français et autres Unicode
            const words = text.toLowerCase().match(/[\p{L}]{3,}/gu) || []; 
            const stopWords = new Set(['le', 'la', 'les', 'un', 'une', 'des', 'de', 'du', 'et', 'ou', 'où', 'qui', 'que', 'quoi', 'dont', 'ce', 'cette', 'ces', 'son', 'sa', 'ses', 'mon', 'ma', 'mes', 'ton', 'ta', 'tes', 'notre', 'nos', 'votre', 'vos', 'leur', 'leurs', 'je', 'tu', 'il', 'elle', 'nous', 'vous', 'ils', 'elles', 'on', 'ne', 'pas', 'plus', 'dans', 'sur', 'pour', 'par', 'avec', 'sans', 'est', 'était', 'être', 'avoir', 'fait', 'faire', 'dit', 'dire', 'peut', 'bien', 'tout', 'tous', 'comme', 'très', 'aussi', 'encore', 'mais', 'donc', 'ainsi']);
            
            const frequency = {};
            words.forEach(word => {
                if (!stopWords.has(word)) {
                    frequency[word] = (frequency[word] || 0) + 1;
                }
            });
            
            return Object.entries(frequency)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 15);
        }

        function calculateSentenceLength(text) {
            const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
            const lengths = sentences.map(s => s.trim().split(/\s+/).length);
            
            if (lengths.length === 0) return { avg: 0, min: 0, max: 0, distribution: [] };
            
            const avg = lengths.reduce((a, b) => a + b, 0) / lengths.length;
            const min = Math.min(...lengths);
            const max = Math.max(...lengths);
            
            // Distribution
            const ranges = [
                { label: '1-5 mots', count: lengths.filter(l => l >= 1 && l <= 5).length },
                { label: '6-10 mots', count: lengths.filter(l => l >= 6 && l <= 10).length },
                { label: '11-15 mots', count: lengths.filter(l => l >= 11 && l <= 15).length },
                { label: '16-20 mots', count: lengths.filter(l => l >= 16 && l <= 20).length },
                { label: '20+ mots', count: lengths.filter(l => l > 20).length }
            ];
            
            return { avg: avg.toFixed(1), min, max, distribution: ranges };
        }

        function analyzeNarrativeDistribution(text) {
            const dialogRegex = /[«"—–]\s*[^»"—–]{10,}?\s*[»"—–]/g;
            const dialogs = text.match(dialogRegex) || [];
            const dialogLength = dialogs.join('').length;
            const totalLength = text.length;
            
            const dialogPercent = totalLength > 0 ? (dialogLength / totalLength * 100).toFixed(1) : 0;
            const narrativePercent = totalLength > 0 ? (100 - dialogPercent).toFixed(1) : 0;
            
            return {
                dialogue: dialogPercent,
                narrative: narrativePercent,
                dialogCount: dialogs.length
            };
        }

        function displayAnalysisResults(analysis) {
            const container = document.getElementById('analysisResults');
            
            container.innerHTML = `
                <div style="margin-top: 1rem;">
                    <!-- General Stats -->
                    <div style="background: var(--bg-primary); padding: 1rem; border-radius: 4px; border: 1px solid var(--border-color); margin-bottom: 1rem;">
                        <div style="font-weight: 700; font-size: 1rem; margin-bottom: 0.75rem; color: var(--accent-gold);"><i data-lucide="bar-chart-3" style="width:16px;height:16px;vertical-align:middle;margin-right:6px;"></i>Statistiques générales</div>
                        <div style="font-size: 1.2rem; font-weight: 600;">${analysis.wordCount.toLocaleString('fr-FR')} mots</div>
                    </div>

                    <!-- Readability -->
                    <div style="background: var(--bg-primary); padding: 1rem; border-radius: 4px; border: 1px solid var(--border-color); margin-bottom: 1rem;">
                        <div style="font-weight: 700; font-size: 1rem; margin-bottom: 0.75rem; color: var(--accent-gold);"><i data-lucide="book-open" style="width:16px;height:16px;vertical-align:middle;margin-right:6px;"></i>Lisibilité (Flesch)</div>
                        <div style="font-size: 1.1rem; margin-bottom: 0.25rem;">Score: <strong>${analysis.readability.score}</strong> / 100</div>
                        <div style="color: var(--text-muted);">Niveau: ${analysis.readability.level}</div>
                        <div style="margin-top: 0.5rem; font-size: 0.75rem; color: var(--text-muted); line-height: 1.4;">
                            Plus le score est élevé, plus le texte est facile à lire. 60-70 = Standard, 70-80 = Facile.
                        </div>
                    </div>

                    <!-- Sentence Length -->
                    <div style="background: var(--bg-primary); padding: 1rem; border-radius: 4px; border: 1px solid var(--border-color); margin-bottom: 1rem;">
                        <div style="font-weight: 700; font-size: 1rem; margin-bottom: 0.75rem; color: var(--accent-gold);"><i data-lucide="ruler" style="width:16px;height:16px;vertical-align:middle;margin-right:6px;"></i>Longueur des phrases</div>
                        <div style="display: flex; gap: 1rem; margin-bottom: 0.75rem;">
                            <div><strong>Moyenne:</strong> ${analysis.sentenceLength.avg} mots</div>
                            <div><strong>Min:</strong> ${analysis.sentenceLength.min}</div>
                            <div><strong>Max:</strong> ${analysis.sentenceLength.max}</div>
                        </div>
                        <div style="font-size: 0.8rem; font-weight: 600; margin-bottom: 0.5rem;">Distribution:</div>
                        ${analysis.sentenceLength.distribution.map(r => `
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.25rem;">
                                <span style="font-size: 0.75rem;">${r.label}</span>
                                <div style="flex: 1; margin: 0 0.5rem; height: 8px; background: var(--bg-secondary); border-radius: 4px; overflow: hidden;">
                                    <div style="height: 100%; width: ${r.count * 100 / analysis.sentenceLength.distribution.reduce((s, d) => s + d.count, 0)}%; background: var(--accent-gold);"></div>
                                </div>
                                <span style="font-size: 0.75rem; font-weight: 600; min-width: 30px; text-align: right;">${r.count}</span>
                            </div>
                        `).join('')}
                    </div>

                    <!-- Narrative Distribution -->
                    <div style="background: var(--bg-primary); padding: 1rem; border-radius: 4px; border: 1px solid var(--border-color); margin-bottom: 1rem;">
                        <div style="font-weight: 700; font-size: 1rem; margin-bottom: 0.75rem; color: var(--accent-gold);"><i data-lucide="message-circle" style="width:16px;height:16px;vertical-align:middle;margin-right:6px;"></i>Distribution narrative</div>
                        <div style="display: flex; gap: 1rem; margin-bottom: 0.75rem;">
                            <div><strong>Dialogues:</strong> ${analysis.narrativeDistribution.dialogue}%</div>
                            <div><strong>Narration:</strong> ${analysis.narrativeDistribution.narrative}%</div>
                        </div>
                        <div style="height: 20px; background: var(--bg-secondary); border-radius: 4px; overflow: hidden; display: flex;">
                            <div style="height: 100%; width: ${analysis.narrativeDistribution.dialogue}%; background: #4CAF50;" title="Dialogues"></div>
                            <div style="height: 100%; width: ${analysis.narrativeDistribution.narrative}%; background: var(--accent-gold);" title="Narration"></div>
                        </div>
                        <div style="margin-top: 0.5rem; font-size: 0.75rem; color: var(--text-muted);">
                            ${analysis.narrativeDistribution.dialogCount} segments de dialogue détectés
                        </div>
                    </div>

                    <!-- Word Frequency -->
                    <div style="background: var(--bg-primary); padding: 1rem; border-radius: 4px; border: 1px solid var(--border-color); margin-bottom: 1rem;">
                        <div style="font-weight: 700; font-size: 1rem; margin-bottom: 0.75rem; color: var(--accent-gold);"><i data-lucide="type" style="width:16px;height:16px;vertical-align:middle;margin-right:6px;"></i>Mots les plus fréquents</div>
                        <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 0.5rem;">
                            ${analysis.wordFrequency.map(([word, count]) => `
                                <div style="padding: 0.4rem 0.6rem; background: var(--bg-secondary); border-radius: 2px; font-size: 0.75rem;">
                                    <strong>${word}</strong>: ${count}×
                                </div>
                            `).join('')}
                        </div>
                    </div>

                    <!-- Repetitions -->
                    <div style="background: var(--bg-primary); padding: 1rem; border-radius: 4px; border: 1px solid var(--border-color);">
                        <div style="font-weight: 700; font-size: 1rem; margin-bottom: 0.75rem; color: var(--accent-red);"><i data-lucide="alert-triangle" style="width:16px;height:16px;vertical-align:middle;margin-right:6px;"></i>Répétitions à surveiller (5+ occurrences)</div>
                        ${analysis.repetitions.length > 0 ? `
                            <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 0.5rem;">
                                ${analysis.repetitions.map(([word, count]) => `
                                    <div style="padding: 0.4rem 0.6rem; background: rgba(196, 69, 54, 0.1); border: 1px solid var(--accent-red); border-radius: 2px; font-size: 0.75rem;">
                                        <strong>${word}</strong>: ${count}×
                                    </div>
                                `).join('')}
                            </div>
                        ` : '<div style="color: var(--text-muted); font-size: 0.85rem;">Aucune répétition excessive détectée</div>'}
                    </div>
                </div>
            `;
        }

        // Initialize
        async function init() {
            // Initialiser IndexedDB en premier
            const dbReady = await initDB();
            if (!dbReady) {
                console.error('❌ Impossible d\'initialiser la base de données');
                alert('Erreur critique : impossible d\'initialiser le stockage. Rechargez la page.');
                return;
            }
            
            // Charger les projets depuis IndexedDB
            await loadAllProjects();
            await loadTreeState(); // Charger l'état d'expansion
            
            // Forcer la vue Structure au démarrage
            currentView = 'editor';
            
            // S'assurer que les autres vues sont cachées
            setTimeout(() => {
                // Masquer toutes les vues
                const viewsToHide = ['charactersList', 'worldList', 'notesList', 'codexList', 'statsList', 
                                     'versionsList', 'analysisList', 'todosList', 'corkboardList'];
                viewsToHide.forEach(viewId => {
                    const el = document.getElementById(viewId);
                    if (el) el.style.display = 'none';
                });
                
                // Afficher la structure
                const chaptersList = document.getElementById('chaptersList');
                if (chaptersList) chaptersList.style.display = 'block';
                
                // Activer l'onglet Structure
                document.querySelectorAll('[id^="tab-"]').forEach(tab => {
                    tab.classList.remove('btn-primary');
                });
                const editorTab = document.getElementById('tab-editor');
                if (editorTab) editorTab.classList.add('btn-primary');
            }, 100);
            
            switchView('editor');
            renderActsList();
            
            // Initialiser l'historique avec l'état initial
            saveToHistory();
            
            // Initialize color pickers
            initializeColorPickers();
            
            // Initialize sidebar resize
            initSidebarResize();
            
            // Initialize floating editor menu (mobile)
            initFloatingEditorMenu();
            
            // Initialize touch gestures for editor
            initEditorGestures();
            
            // Initialize storage monitoring
            initStorageMonitoring();
            
            // Initialize scene versions sidebar
            renderSceneVersionsList();
            
            // Initialize progress bar
            updateProgressBar();
            
            // Auto-save every 30 seconds
            setInterval(saveProject, 30000);
            
            // Update storage badge every 10 seconds
            setInterval(updateStorageBadge, 10000);
        }

        // Fonction utilitaire pour convertir un nombre en chiffres romains
        function toRoman(num) {
            const romanNumerals = [
                { value: 10, numeral: 'X' },
                { value: 9, numeral: 'IX' },
                { value: 5, numeral: 'V' },
                { value: 4, numeral: 'IV' },
                { value: 1, numeral: 'I' }
            ];
            
            let result = '';
            for (const { value, numeral } of romanNumerals) {
                while (num >= value) {
                    result += numeral;
                    num -= value;
                }
            }
            return result;
        }

        // Save/Load from localStorage
        async function saveProject() {
            try {
                // Sauvegarder dans IndexedDB
                const success = await saveProjectToDB(project);
                
                if (!success) {
                    throw new Error('Échec de la sauvegarde IndexedDB');
                }
                
                // Mettre à jour le badge de stockage après chaque sauvegarde
                updateStorageBadge();
                
                console.log('💾 saveProject appelé - isUndoRedoAction:', isUndoRedoAction);
                
                // Si c'est une action undo/redo, ne pas sauvegarder dans l'historique
                if (isUndoRedoAction) {
                    console.log('⏭️ Action undo/redo, pas de sauvegarde historique');
                    return;
                }
                
                // Si c'est le premier changement (pas de timer actif)
                if (!historyDebounceTimer) {
                    console.log('🆕 Premier changement - sauvegarde immédiate');
                    // Sauvegarder l'état ACTUEL comme point de départ
                    saveToHistory();
                    lastSavedState = JSON.stringify(project);
                } else {
                    console.log('⏱️ Timer existant, réinitialisation');
                }
                
                // Annuler le timer précédent
                if (historyDebounceTimer) {
                    clearTimeout(historyDebounceTimer);
                }
                
                // Créer un nouveau timer
                historyDebounceTimer = setTimeout(() => {
                    console.log('⏰ Timer expiré - vérification changements');
                    // Sauvegarder l'état final après la pause
                    const finalState = JSON.stringify(project);
                    
                    // Ne sauvegarder que si l'état a changé
                    if (finalState !== lastSavedState) {
                        console.log('✏️ État modifié - sauvegarde finale');
                        saveToHistory();
                        lastSavedState = finalState;
                    } else {
                        console.log('⏭️ Aucun changement détecté');
                    }
                    
                    historyDebounceTimer = null; // Réinitialiser
                }, historyDebounceDelay);
            } catch (error) {
                console.error('❌ Erreur de sauvegarde:', error);
                alert('Erreur lors de la sauvegarde. Veuillez exporter votre projet par sécurité.');
            }
        }
        
        function renameProject() {
            const newName = prompt('Nouveau nom du projet :', project.title || 'Mon Roman');
            if (newName === null) return; // Annulé
            
            const trimmedName = newName.trim();
            if (trimmedName === '') {
                showNotification('Le nom ne peut pas être vide');
                return;
            }
            
            project.title = trimmedName;
            
            // Mettre à jour le titre dans le header
            const headerTitle = document.getElementById('headerProjectTitle');
            if (headerTitle) {
                headerTitle.textContent = trimmedName;
            }
            
            // Mettre à jour le titre de la page
            document.title = trimmedName + ' - Plume';
            
            saveProject();
            showNotification('✓ Projet renommé');
        }
        
        function saveToHistory() {
            // Créer une copie profonde du projet
            const snapshot = JSON.parse(JSON.stringify(project));
            
            console.log('📝 saveToHistory appelé - historyStack.length:', historyStack.length);
            
            // Ajouter à l'historique
            historyStack.push(snapshot);
            
            // Limiter la taille de l'historique
            if (historyStack.length > maxHistorySize) {
                historyStack.shift(); // Retirer le plus ancien
            }
            
            // Vider le redo stack car on a fait une nouvelle action
            redoStack = [];
            
            console.log('✓ État sauvegardé - Total dans historique:', historyStack.length);
            
            // Mettre à jour l'UI
            updateUndoRedoButtons();
        }
        
        // Sauvegarder immédiatement dans l'historique (pour actions importantes)
        function saveToHistoryImmediate() {
            // Annuler le timer de debounce en cours
            if (historyDebounceTimer) {
                clearTimeout(historyDebounceTimer);
                historyDebounceTimer = null;
            }
            
            // Sauvegarder immédiatement
            saveToHistory();
        }
        
        function undo() {
            console.log('🔙 Undo appelé - historyStack.length:', historyStack.length);
            
            if (historyStack.length === 0) {
                console.log('⚠️ Historique vide !');
                showNotification('⚠️ Aucune action à annuler');
                return;
            }
            
            // Sauvegarder l'état actuel dans le redo stack
            redoStack.push(JSON.parse(JSON.stringify(project)));
            console.log('💾 État actuel sauvegardé dans redoStack');
            
            // Restaurer l'état précédent
            const previousState = historyStack.pop();
            console.log('📂 État précédent récupéré - reste dans historique:', historyStack.length);
            
            // Flag pour éviter de sauvegarder cette restauration
            isUndoRedoAction = true;
            project = JSON.parse(JSON.stringify(previousState));
            console.log('✓ Projet restauré');
            
            // Sauvegarder et rafraîchir
            saveProject();
            refreshAllViews();
            
            isUndoRedoAction = false;
            updateUndoRedoButtons();
            showNotification('↶ Annulé');
        }
        
        function redo() {
            if (redoStack.length === 0) {
                showNotification('⚠️ Aucune action à rétablir');
                return;
            }
            
            // Sauvegarder l'état actuel dans l'historique
            historyStack.push(JSON.parse(JSON.stringify(project)));
            
            // Restaurer l'état suivant
            const nextState = redoStack.pop();
            
            // Flag pour éviter de sauvegarder cette restauration
            isUndoRedoAction = true;
            project = JSON.parse(JSON.stringify(nextState));
            
            // Sauvegarder et rafraîchir
            saveProject();
            refreshAllViews();
            
            isUndoRedoAction = false;
            updateUndoRedoButtons();
            showNotification('↷ Rétabli');
        }
        
        function updateUndoRedoButtons() {
            // Boutons dans le header
            const headerUndoBtn = document.getElementById('headerUndoBtn');
            const headerRedoBtn = document.getElementById('headerRedoBtn');
            
            // Boutons dans le menu mobile
            const mobileUndoBtn = document.getElementById('mobileUndoBtn');
            const mobileRedoBtn = document.getElementById('mobileRedoBtn');
            
            const undoDisabled = historyStack.length === 0;
            const redoDisabled = redoStack.length === 0;
            
            if (headerUndoBtn) {
                headerUndoBtn.disabled = undoDisabled;
                headerUndoBtn.title = historyStack.length > 0 
                    ? `Annuler (${historyStack.length} action(s) disponible(s)) - Ctrl+Z`
                    : 'Aucune action à annuler';
            }
            
            if (headerRedoBtn) {
                headerRedoBtn.disabled = redoDisabled;
                headerRedoBtn.title = redoStack.length > 0 
                    ? `Rétablir (${redoStack.length} action(s) disponible(s)) - Ctrl+Y`
                    : 'Aucune action à rétablir';
            }
            
            // Mettre à jour aussi les boutons mobiles
            if (mobileUndoBtn) {
                mobileUndoBtn.disabled = undoDisabled;
                if (undoDisabled) {
                    mobileUndoBtn.style.opacity = '0.5';
                    mobileUndoBtn.style.cursor = 'not-allowed';
                } else {
                    mobileUndoBtn.style.opacity = '1';
                    mobileUndoBtn.style.cursor = 'pointer';
                }
            }
            
            if (mobileRedoBtn) {
                mobileRedoBtn.disabled = redoDisabled;
                if (redoDisabled) {
                    mobileRedoBtn.style.opacity = '0.5';
                    mobileRedoBtn.style.cursor = 'not-allowed';
                } else {
                    mobileRedoBtn.style.opacity = '1';
                    mobileRedoBtn.style.cursor = 'pointer';
                }
            }
        }
        
        function refreshAllViews() {
            // Rafraîchir tous les affichages après un undo/redo
            renderActsList();
            
            // Restaurer l'état d'expansion immédiatement après le rendu
            setTimeout(() => restoreTreeState(), 100);
            
            updateStats();
            
            // Rafraîchir la vue actuelle
            switch(currentView) {
                case 'editor':
                    // Render the acts/chapters sidebar
                    renderActsList();
                    // renderViewContent will handle rendering the editor
                    break;
                case 'characters':
                    renderCharactersList();
                    break;
                case 'world':
                    renderWorldList();
                    break;
                case 'timeline':
                    renderTimelineList();
                    break;
                case 'notes':
                    renderNotesList();
                    break;
                case 'codex':
                    renderCodexList();
                    break;
                case 'stats':
                    renderStats();
                    break;
                case 'analysis':
                    renderAnalysis();
                    break;
                case 'versions':
                    renderVersionsList();
                    break;
                case 'todos':
                    if (typeof renderTodosList === 'function') renderTodosList();
                    break;
                case 'corkboard':
                    if (typeof renderCorkBoard === 'function') renderCorkBoard();
                    break;
                case 'mindmap':
                    if (typeof renderMindmapView === 'function') renderMindmapView();
                    break;
                case 'plot':
                    if (typeof renderPlotView === 'function') renderPlotView();
                    break;
                case 'relations':
                    if (typeof renderRelationsView === 'function') renderRelationsView();
                    break;
                case 'map':
                    if (typeof renderMapView === 'function') renderMapView();
                    break;
                case 'timelineviz':
                    if (typeof renderTimelineVizView === 'function') renderTimelineVizView();
                    break;
            }
            
            // Rafraîchir l'éditeur si une scène est ouverte
            if (currentSceneId) {
                const scene = findScene(currentActId, currentChapterId, currentSceneId);
                if (scene) {
                    document.getElementById('sceneTitle').value = scene.title;
                    document.getElementById('sceneContent').value = scene.content || '';
                    updateWordCount();
                }
            }
        }
        
        // Raccourcis clavier pour undo/redo
        document.addEventListener('keydown', function(e) {
            // Ctrl+Z ou Cmd+Z pour undo
            if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                undo();
            }
            // Ctrl+Y ou Cmd+Shift+Z pour redo
            else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
                e.preventDefault();
                redo();
            }
        });

        function loadProject() {
            const saved = localStorage.getItem('novelcraft_project');
            if (saved) {
                const loadedProject = JSON.parse(saved);
                
                // Migration: Convert old structure (chapters array) to new structure (acts array)
                if (loadedProject.chapters && !loadedProject.acts) {
                    console.log('Migrating old project structure to acts-based structure...');
                    project = {
                        title: loadedProject.title || "Mon Roman",
                        acts: [
                            {
                                id: Date.now(),
                                title: "Acte I",
                                chapters: loadedProject.chapters || []
                            }
                        ],
                        characters: loadedProject.characters || [],
                        world: loadedProject.world || []
                    };
                    // Save migrated structure
                    saveProject();
                    console.log('Migration complete!');
                } else {
                    // Ensure all data structures exist
                    project = {
                        ...loadedProject,
                        characters: loadedProject.characters || [],
                        world: loadedProject.world || [],
                        timeline: loadedProject.timeline || [],
                        notes: loadedProject.notes || [],
                        codex: loadedProject.codex || [],
                        stats: loadedProject.stats || {
                            dailyGoal: 500,
                            totalGoal: 80000,
                            writingSessions: []
                        },
                        versions: loadedProject.versions || [],
                        relationships: loadedProject.relationships || [],
                        metroTimeline: loadedProject.metroTimeline || [],
                        characterColors: loadedProject.characterColors || {}
                    };
                    
                    // Ensure all scenes have linked arrays
                    project.acts.forEach(act => {
                        act.chapters.forEach(chapter => {
                            chapter.scenes.forEach(scene => {
                                if (!scene.linkedCharacters) scene.linkedCharacters = [];
                                if (!scene.linkedElements) scene.linkedElements = [];
                            });
                        });
                    });
                    
                    // Ensure all characters have linked arrays
                    project.characters.forEach(char => {
                        if (!char.linkedScenes) char.linkedScenes = [];
                        if (!char.linkedElements) char.linkedElements = [];
                    });
                    
                    // Ensure all world elements have linked arrays
                    project.world.forEach(elem => {
                        if (!elem.linkedScenes) elem.linkedScenes = [];
                        if (!elem.linkedElements) elem.linkedElements = [];
                    });
                }
            }
        }

        // Act Management
        function addAct() {
            const title = document.getElementById('actTitleInput').value.trim();
            if (!title) return;

            const act = {
                id: Date.now(),
                title: title,
                chapters: []
            };

            project.acts.push(act);
            
            // Auto-déplier le nouvel acte
            expandedActs.add(act.id);
            
            document.getElementById('actTitleInput').value = '';
            closeModal('addActModal');
            saveProject();
            renderActsList();
        }

        function deleteAct(actId) {
            if (!confirm('Êtes-vous sûr de vouloir supprimer cet acte et tous ses chapitres ?')) return;
            
            project.acts = project.acts.filter(a => a.id !== actId);
            if (currentActId === actId) {
                currentActId = null;
                currentChapterId = null;
                currentSceneId = null;
                showEmptyState();
            }
            saveProject();
            renderActsList();
        }

        function toggleAct(actId) {
            const element = document.getElementById(`act-${actId}`);
            const icon = element.querySelector('.act-icon');
            const chaptersContainer = element.querySelector('.act-chapters');
            
            const isExpanded = icon.classList.contains('expanded');
            
            icon.classList.toggle('expanded');
            chaptersContainer.classList.toggle('visible');
            
            // Sauvegarder l'état
            if (isExpanded) {
                expandedActs.delete(actId);
            } else {
                expandedActs.add(actId);
            }
            saveTreeState();
        }

        function startEditingAct(actId, element) {
            const act = project.acts.find(a => a.id === actId);
            if (!act) return;

            const originalText = act.title;
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'editing-input';
            input.value = originalText;
            
            element.textContent = '';
            element.appendChild(input);
            input.focus();
            input.select();

            const finishEditing = () => {
                const newTitle = input.value.trim();
                if (newTitle && newTitle !== originalText) {
                    act.title = newTitle;
                    saveProject();
                }
                renderActsList();
            };

            input.addEventListener('blur', finishEditing);
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    finishEditing();
                } else if (e.key === 'Escape') {
                    renderActsList();
                }
            });
        }

        // Chapter Management
        function addChapter() {
            const title = document.getElementById('chapterTitleInput').value.trim();
            if (!title) return;
            
            // Si pas d'acte, en créer un par défaut
            if (!activeActId || !project.acts.find(a => a.id === activeActId)) {
                if (project.acts.length === 0) {
                    const defaultAct = {
                        id: Date.now(),
                        title: 'Roman',
                        chapters: []
                    };
                    project.acts.push(defaultAct);
                    activeActId = defaultAct.id;
                    expandedActs.add(defaultAct.id);
                } else {
                    activeActId = project.acts[0].id;
                }
            }

            const act = project.acts.find(a => a.id === activeActId);
            if (!act) return;

            const chapter = {
                id: Date.now() + 1, // +1 pour éviter collision avec l'acte créé juste avant
                title: title,
                scenes: []
            };

            act.chapters.push(chapter);
            
            // Auto-déplier l'acte parent et le nouveau chapitre
            expandedActs.add(act.id);
            expandedChapters.add(chapter.id);
            
            console.log('addChapter - act.id:', act.id, 'chapter.id:', chapter.id);
            console.log('expandedActs:', [...expandedActs]);
            console.log('expandedChapters:', [...expandedChapters]);
            
            document.getElementById('chapterTitleInput').value = '';
            closeModal('addChapterModal');
            saveProject();
            renderActsList();
        }

        function deleteChapter(actId, chapterId) {
            if (!confirm('Êtes-vous sûr de vouloir supprimer ce chapitre et toutes ses scènes ?')) return;
            
            const act = project.acts.find(a => a.id === actId);
            if (!act) return;

            act.chapters = act.chapters.filter(c => c.id !== chapterId);
            if (currentChapterId === chapterId) {
                currentChapterId = null;
                currentSceneId = null;
                showEmptyState();
            }
            saveProject();
            renderActsList();
        }

        function toggleChapter(actId, chapterId) {
            const element = document.getElementById(`chapter-${chapterId}`);
            const icon = element.querySelector('.chapter-icon');
            const scenesList = element.querySelector('.scenes-list');
            
            const isExpanded = icon.classList.contains('expanded');
            
            icon.classList.toggle('expanded');
            scenesList.classList.toggle('visible');
            
            // Sauvegarder l'état
            if (isExpanded) {
                expandedChapters.delete(chapterId);
            } else {
                expandedChapters.add(chapterId);
            }
            saveTreeState();
        }
        
        async function saveTreeState() {
            // Sauvegarder l'état d'expansion dans IndexedDB
            try {
                await saveSetting('expanded_acts', [...expandedActs]);
                await saveSetting('expanded_chapters', [...expandedChapters]);
            } catch (error) {
                console.error('❌ Erreur sauvegarde TreeState:', error);
            }
        }
        
        function expandAllTree() {
            // Déplier tous les actes
            document.querySelectorAll('.act-group').forEach(actEl => {
                const icon = actEl.querySelector('.act-icon');
                const chaptersContainer = actEl.querySelector('.act-chapters');
                const actId = parseInt(actEl.dataset.actId);
                
                if (icon && chaptersContainer) {
                    icon.classList.add('expanded');
                    chaptersContainer.classList.add('visible');
                    expandedActs.add(actId);
                }
            });
            
            // Déplier tous les chapitres
            document.querySelectorAll('.chapter-group').forEach(chapterEl => {
                const icon = chapterEl.querySelector('.chapter-icon');
                const scenesList = chapterEl.querySelector('.scenes-list');
                const chapterId = parseInt(chapterEl.dataset.chapterId);
                
                if (icon && scenesList) {
                    icon.classList.add('expanded');
                    scenesList.classList.add('visible');
                    expandedChapters.add(chapterId);
                }
            });
            
            // Déplier tous les groupes treeview (univers, codex)
            const collapsedState = JSON.parse(localStorage.getItem('plume_treeview_collapsed') || '{}');
            document.querySelectorAll('.treeview-group').forEach(group => {
                const header = group.querySelector('.treeview-header');
                const children = group.querySelector('.treeview-children');
                const chevron = group.querySelector('.treeview-chevron');
                
                if (children) {
                    children.classList.remove('collapsed');
                }
                if (chevron) {
                    chevron.setAttribute('data-lucide', 'chevron-down');
                }
                
                // Update localStorage state
                const onclickAttr = header ? header.getAttribute('onclick') : '';
                const match = onclickAttr ? onclickAttr.match(/toggleTreeviewGroup\('([^']+)'\)/) : null;
                if (match) {
                    collapsedState[match[1]] = false;
                }
            });
            localStorage.setItem('plume_treeview_collapsed', JSON.stringify(collapsedState));
            
            // Déplier les catégories de notes
            expandedNoteCategories = new Set(['Idée', 'Recherche', 'Référence', 'A faire', 'Question', 'Autre']);
            if (document.getElementById('notesList').style.display !== 'none') {
                renderNotesList();
            }
            
            saveTreeState();
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }
        
        function collapseAllTree() {
            // Replier tous les actes
            document.querySelectorAll('.act-group').forEach(actEl => {
                const icon = actEl.querySelector('.act-icon');
                const chaptersContainer = actEl.querySelector('.act-chapters');
                const actId = parseInt(actEl.dataset.actId);
                
                if (icon && chaptersContainer) {
                    icon.classList.remove('expanded');
                    chaptersContainer.classList.remove('visible');
                    expandedActs.delete(actId);
                }
            });
            
            // Replier tous les chapitres
            document.querySelectorAll('.chapter-group').forEach(chapterEl => {
                const icon = chapterEl.querySelector('.chapter-icon');
                const scenesList = chapterEl.querySelector('.scenes-list');
                const chapterId = parseInt(chapterEl.dataset.chapterId);
                
                if (icon && scenesList) {
                    icon.classList.remove('expanded');
                    scenesList.classList.remove('visible');
                    expandedChapters.delete(chapterId);
                }
            });
            
            // Replier tous les groupes treeview (univers, codex)
            const collapsedState = JSON.parse(localStorage.getItem('plume_treeview_collapsed') || '{}');
            document.querySelectorAll('.treeview-group').forEach(group => {
                const header = group.querySelector('.treeview-header');
                const children = group.querySelector('.treeview-children');
                const chevron = group.querySelector('.treeview-chevron');
                
                if (children) {
                    children.classList.add('collapsed');
                }
                if (chevron) {
                    chevron.setAttribute('data-lucide', 'chevron-right');
                }
                
                // Update localStorage state
                const onclickAttr = header ? header.getAttribute('onclick') : '';
                const match = onclickAttr ? onclickAttr.match(/toggleTreeviewGroup\('([^']+)'\)/) : null;
                if (match) {
                    collapsedState[match[1]] = true;
                }
            });
            localStorage.setItem('plume_treeview_collapsed', JSON.stringify(collapsedState));
            
            // Replier les catégories de notes
            expandedNoteCategories.clear();
            if (document.getElementById('notesList').style.display !== 'none') {
                renderNotesList();
            }
            
            saveTreeState();
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }
        
        async function loadTreeState() {
            // Charger l'état d'expansion depuis IndexedDB
            try {
                const savedActs = await loadSetting('expanded_acts');
                const savedChapters = await loadSetting('expanded_chapters');
                
                if (savedActs) {
                    expandedActs = new Set(savedActs);
                }
                if (savedChapters) {
                    expandedChapters = new Set(savedChapters);
                }
            } catch (e) {
                console.error('Erreur chargement état arborescence:', e);
            }
        }
        
        function restoreTreeState() {
            // Restaurer visuellement l'état d'expansion après le rendu
            expandedActs.forEach(actId => {
                const element = document.getElementById(`act-${actId}`);
                if (element) {
                    const icon = element.querySelector('.act-icon');
                    const chaptersContainer = element.querySelector('.act-chapters');
                    if (icon && chaptersContainer) {
                        icon.classList.add('expanded');
                        chaptersContainer.classList.add('visible');
                    }
                }
            });
            
            expandedChapters.forEach(chapterId => {
                const element = document.getElementById(`chapter-${chapterId}`);
                if (element) {
                    const icon = element.querySelector('.chapter-icon');
                    const scenesList = element.querySelector('.scenes-list');
                    if (icon && scenesList) {
                        icon.classList.add('expanded');
                        scenesList.classList.add('visible');
                    }
                }
            });
        }

        function startEditingChapter(actId, chapterId, element) {
            const act = project.acts.find(a => a.id === actId);
            if (!act) return;

            const chapter = act.chapters.find(c => c.id === chapterId);
            if (!chapter) return;

            const originalText = chapter.title;
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'editing-input';
            input.value = originalText;
            
            element.textContent = '';
            element.appendChild(input);
            input.focus();
            input.select();

            const finishEditing = () => {
                const newTitle = input.value.trim();
                if (newTitle && newTitle !== originalText) {
                    chapter.title = newTitle;
                    saveProject();
                    
                    // Update editor if this chapter is currently open
                    if (currentChapterId === chapterId) {
                        const breadcrumb = document.querySelector('.editor-breadcrumb');
                        if (breadcrumb) breadcrumb.textContent = `${act.title} > ${newTitle}`;
                    }
                }
                renderActsList();
            };

            input.addEventListener('blur', finishEditing);
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    finishEditing();
                } else if (e.key === 'Escape') {
                    renderActsList();
                }
            });
        }

        // Scene Management
        function openAddSceneModal(actId, chapterId) {
            activeActId = actId;
            activeChapterId = chapterId;
            document.getElementById('addSceneModal').classList.add('active');
        }
        
        function openAddSceneModalQuick() {
            // Utiliser le chapitre courant s'il existe, sinon le premier chapitre disponible
            if (currentActId && currentChapterId) {
                openAddSceneModal(currentActId, currentChapterId);
            } else if (project.acts.length > 0 && project.acts[0].chapters.length > 0) {
                openAddSceneModal(project.acts[0].id, project.acts[0].chapters[0].id);
            } else {
                showNotification('Créez d\'abord un chapitre');
            }
        }

        function addScene() {
            const title = document.getElementById('sceneTitleInput').value.trim();
            if (!title || !activeActId || !activeChapterId) return;

            const act = project.acts.find(a => a.id === activeActId);
            if (!act) return;

            const chapter = act.chapters.find(c => c.id === activeChapterId);
            if (!chapter) return;

            const scene = {
                id: Date.now(),
                title: title,
                content: '',
                linkedCharacters: [],
                linkedElements: [],
                wordCount: 0,
                status: 'draft'
            };

            chapter.scenes.push(scene);
            
            // Auto-déplier l'acte et le chapitre parents
            expandedActs.add(act.id);
            expandedChapters.add(chapter.id);
            
            document.getElementById('sceneTitleInput').value = '';
            closeModal('addSceneModal');
            saveProject();
            renderActsList();
            
            // Auto-open the new scene
            openScene(activeActId, activeChapterId, scene.id);
        }

        // Variable pour les filtres actifs
        let activeStatusFilters = ['draft', 'progress', 'complete', 'review'];
        let currentStatusMenu = null;

        function toggleSceneStatus(actId, chapterId, sceneId, event) {
            event = event || window.event;
            event.stopPropagation();
            
            // Fermer tout menu existant
            closeStatusMenu();
            
            const act = project.acts.find(a => a.id === actId);
            if (!act) return;
            
            const chapter = act.chapters.find(c => c.id === chapterId);
            if (!chapter) return;
            
            const scene = chapter.scenes.find(s => s.id === sceneId);
            if (!scene) return;
            
            const currentStatus = scene.status || 'draft';
            
            // Créer le menu contextuel
            const menu = document.createElement('div');
            menu.className = 'status-menu visible';
            menu.id = 'statusMenu';
            menu.innerHTML = `
                <div class="status-menu-item ${currentStatus === 'draft' ? 'active' : ''}" onclick="setSceneStatus(${actId}, ${chapterId}, ${sceneId}, 'draft')">
                    <span class="status-menu-dot draft"></span>
                    <span>Brouillon</span>
                </div>
                <div class="status-menu-item ${currentStatus === 'progress' ? 'active' : ''}" onclick="setSceneStatus(${actId}, ${chapterId}, ${sceneId}, 'progress')">
                    <span class="status-menu-dot progress"></span>
                    <span>En cours</span>
                </div>
                <div class="status-menu-item ${currentStatus === 'complete' ? 'active' : ''}" onclick="setSceneStatus(${actId}, ${chapterId}, ${sceneId}, 'complete')">
                    <span class="status-menu-dot complete"></span>
                    <span>Terminé</span>
                </div>
                <div class="status-menu-item ${currentStatus === 'review' ? 'active' : ''}" onclick="setSceneStatus(${actId}, ${chapterId}, ${sceneId}, 'review')">
                    <span class="status-menu-dot review"></span>
                    <span>À réviser</span>
                </div>
            `;
            
            // Positionner le menu en position fixe près du clic
            const badge = event.target.closest('.status-badge');
            if (badge) {
                const rect = badge.getBoundingClientRect();
                menu.style.top = (rect.bottom + 5) + 'px';
                menu.style.left = (rect.left - 100) + 'px'; // Décaler vers la gauche
                
                // S'assurer que le menu ne sort pas de l'écran
                document.body.appendChild(menu);
                
                const menuRect = menu.getBoundingClientRect();
                if (menuRect.right > window.innerWidth) {
                    menu.style.left = (window.innerWidth - menuRect.width - 10) + 'px';
                }
                if (menuRect.left < 0) {
                    menu.style.left = '10px';
                }
                if (menuRect.bottom > window.innerHeight) {
                    menu.style.top = (rect.top - menuRect.height - 5) + 'px';
                }
                
                currentStatusMenu = menu;
            }
            
            // Fermer le menu si on clique ailleurs
            setTimeout(() => {
                document.addEventListener('click', closeStatusMenuOnClickOutside);
            }, 10);
        }
        
        function closeStatusMenu() {
            const menu = document.getElementById('statusMenu');
            if (menu) {
                menu.remove();
            }
            currentStatusMenu = null;
            document.removeEventListener('click', closeStatusMenuOnClickOutside);
        }
        
        function closeStatusMenuOnClickOutside(event) {
            if (currentStatusMenu && !currentStatusMenu.contains(event.target)) {
                closeStatusMenu();
            }
        }
        
        function setSceneStatus(actId, chapterId, sceneId, status) {
            const act = project.acts.find(a => a.id === actId);
            if (!act) return;
            
            const chapter = act.chapters.find(c => c.id === chapterId);
            if (!chapter) return;
            
            const scene = chapter.scenes.find(s => s.id === sceneId);
            if (!scene) return;
            
            scene.status = status;
            
            closeStatusMenu();
            saveProject();
            renderActsList();
            updateProgressBar();
        }
        
        function toggleStatusFilter(status) {
            const index = activeStatusFilters.indexOf(status);
            const btn = document.querySelector(`.status-filter-btn[data-status="${status}"]`);
            
            if (index > -1) {
                // Désactiver le filtre (cacher ce statut)
                activeStatusFilters.splice(index, 1);
                btn.classList.remove('active');
            } else {
                // Activer le filtre (montrer ce statut)
                activeStatusFilters.push(status);
                btn.classList.add('active');
            }
            
            applyStatusFilters();
        }
        
        function applyStatusFilters() {
            // Appliquer les filtres à toutes les scènes
            document.querySelectorAll('.scene-item[data-scene-id]').forEach(sceneEl => {
                const sceneId = parseInt(sceneEl.dataset.sceneId);
                const actId = parseInt(sceneEl.dataset.actId);
                const chapterId = parseInt(sceneEl.dataset.chapterId);
                
                const act = project.acts.find(a => a.id === actId);
                if (!act) return;
                const chapter = act.chapters.find(c => c.id === chapterId);
                if (!chapter) return;
                const scene = chapter.scenes.find(s => s.id === sceneId);
                if (!scene) return;
                
                const status = scene.status || 'draft';
                
                if (activeStatusFilters.includes(status)) {
                    sceneEl.classList.remove('filtered-out');
                } else {
                    sceneEl.classList.add('filtered-out');
                }
            });
            
            // Cacher les chapitres dont toutes les scènes sont filtrées (mais pas les chapitres vides)
            document.querySelectorAll('.chapter-group').forEach(chapterEl => {
                const allScenes = chapterEl.querySelectorAll('.scene-item[data-scene-id]');
                const visibleScenes = chapterEl.querySelectorAll('.scene-item[data-scene-id]:not(.filtered-out)');
                
                // Si le chapitre a des scènes mais aucune visible, le cacher
                // Si le chapitre n'a pas de scènes (vide), le garder visible
                if (allScenes.length > 0 && visibleScenes.length === 0) {
                    chapterEl.classList.add('filtered-out');
                } else {
                    chapterEl.classList.remove('filtered-out');
                }
            });
            
            // Cacher les actes dont tous les chapitres sont filtrés (mais pas les actes avec chapitres vides)
            document.querySelectorAll('.act-group').forEach(actEl => {
                const allChapters = actEl.querySelectorAll('.chapter-group');
                const visibleChapters = actEl.querySelectorAll('.chapter-group:not(.filtered-out)');
                
                // Si l'acte a des chapitres mais aucun visible, le cacher
                // Si l'acte n'a pas de chapitres (vide), le garder visible
                if (allChapters.length > 0 && visibleChapters.length === 0) {
                    actEl.classList.add('filtered-out');
                } else {
                    actEl.classList.remove('filtered-out');
                }
            });
        }
        
        function updateProgressBar() {
            let counts = { draft: 0, progress: 0, complete: 0, review: 0 };
            let total = 0;
            
            project.acts.forEach(act => {
                act.chapters.forEach(chapter => {
                    chapter.scenes.forEach(scene => {
                        const status = scene.status || 'draft';
                        counts[status] = (counts[status] || 0) + 1;
                        total++;
                    });
                });
            });
            
            // Mettre à jour les compteurs
            document.getElementById('countDraft').textContent = counts.draft;
            document.getElementById('countProgress').textContent = counts.progress;
            document.getElementById('countComplete').textContent = counts.complete;
            document.getElementById('countReview').textContent = counts.review;
            
            // Mettre à jour le texte de progression
            const completedPercent = total > 0 ? Math.round((counts.complete / total) * 100) : 0;
            document.getElementById('progressStatsText').textContent = `${total} scène${total > 1 ? 's' : ''}`;
            document.getElementById('progressPercent').textContent = `${completedPercent}% terminé`;
            
            // Mettre à jour les segments de la barre
            if (total > 0) {
                document.getElementById('progressComplete').style.width = `${(counts.complete / total) * 100}%`;
                document.getElementById('progressReview').style.width = `${(counts.review / total) * 100}%`;
                document.getElementById('progressProgress').style.width = `${(counts.progress / total) * 100}%`;
                document.getElementById('progressDraft').style.width = `${(counts.draft / total) * 100}%`;
            } else {
                document.getElementById('progressComplete').style.width = '0%';
                document.getElementById('progressReview').style.width = '0%';
                document.getElementById('progressProgress').style.width = '0%';
                document.getElementById('progressDraft').style.width = '0%';
            }
        }

        function deleteScene(actId, chapterId, sceneId) {
            if (!confirm('Êtes-vous sûr de vouloir supprimer cette scène ?')) return;
            
            const act = project.acts.find(a => a.id === actId);
            if (!act) return;

            const chapter = act.chapters.find(c => c.id === chapterId);
            if (!chapter) return;

            chapter.scenes = chapter.scenes.filter(s => s.id !== sceneId);
            if (currentSceneId === sceneId) {
                currentSceneId = null;
                showEmptyState();
            }
            saveProject();
            renderActsList();
        }

        function startEditingScene(actId, chapterId, sceneId, element) {
            const act = project.acts.find(a => a.id === actId);
            if (!act) return;

            const chapter = act.chapters.find(c => c.id === chapterId);
            if (!chapter) return;
            
            const scene = chapter.scenes.find(s => s.id === sceneId);
            if (!scene) return;

            const originalText = scene.title;
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'editing-input';
            input.value = originalText;
            
            element.textContent = '';
            element.appendChild(input);
            input.focus();
            input.select();

            const finishEditing = () => {
                const newTitle = input.value.trim();
                if (newTitle && newTitle !== originalText) {
                    scene.title = newTitle;
                    saveProject();
                    
                    // Update editor if this scene is currently open
                    if (currentSceneId === sceneId) {
                        const editorTitle = document.querySelector('.editor-title');
                        if (editorTitle) editorTitle.textContent = newTitle;
                    }
                }
                renderActsList();
            };

            input.addEventListener('blur', finishEditing);
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    finishEditing();
                } else if (e.key === 'Escape') {
                    renderActsList();
                }
            });
        }

        // Navigation
        function openScene(actId, chapterId, sceneId) {
            // Close mobile sidebar if open (for mobile devices)
            if (window.innerWidth <= 900 && typeof closeMobileSidebar === 'function') {
                closeMobileSidebar();
            }
            
            // Sauvegarder l'état avant d'ouvrir une nouvelle scène
            saveToHistoryImmediate();
            
            currentActId = actId;
            currentChapterId = chapterId;
            currentSceneId = sceneId;
            
            const act = project.acts.find(a => a.id === actId);
            const chapter = act.chapters.find(c => c.id === chapterId);
            const scene = chapter.scenes.find(s => s.id === sceneId);
            
            // Update active states in sidebar
            document.querySelectorAll('.act-header, .chapter-header, .scene-item').forEach(el => {
                el.classList.remove('active');
            });
            
            const sceneElement = document.querySelector(`[data-scene-id="${sceneId}"]`);
            if (sceneElement) {
                sceneElement.classList.add('active');
                
                // Expand parent chapter and act if needed
                const chapterElement = document.getElementById(`chapter-${chapterId}`);
                if (chapterElement) {
                    const chapterIcon = chapterElement.querySelector('.chapter-icon');
                    const scenesList = chapterElement.querySelector('.scenes-list');
                    if (!scenesList.classList.contains('visible')) {
                        chapterIcon.classList.add('expanded');
                        scenesList.classList.add('visible');
                    }
                }
                
                const actElement = document.getElementById(`act-${actId}`);
                if (actElement) {
                    const actIcon = actElement.querySelector('.act-icon');
                    const chaptersContainer = actElement.querySelector('.act-chapters');
                    if (!chaptersContainer.classList.contains('visible')) {
                        actIcon.classList.add('expanded');
                        chaptersContainer.classList.add('visible');
                    }
                }
                
                // Scroll the scene into view in the sidebar
                setTimeout(() => {
                    const chaptersList = document.getElementById('chaptersList');
                    if (chaptersList && sceneElement) {
                        const containerRect = chaptersList.getBoundingClientRect();
                        const elementRect = sceneElement.getBoundingClientRect();
                        
                        if (elementRect.top < containerRect.top || elementRect.bottom > containerRect.bottom) {
                            sceneElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        }
                    }
                }, 100);
            }
            
            // Handle split view mode
            if (splitViewActive) {
                // Find which panel has the editor view
                let editorPanel = null;
                if (splitViewState.left.view === 'editor') {
                    editorPanel = 'left';
                } else if (splitViewState.right.view === 'editor') {
                    editorPanel = 'right';
                }
                
                if (editorPanel) {
                    // Update the editor panel's state
                    const state = editorPanel === 'left' ? splitViewState.left : splitViewState.right;
                    state.sceneId = sceneId;
                    state.actId = actId;
                    state.chapterId = chapterId;
                    renderSplitPanelViewContent(editorPanel);
                    
                    // Set this as the active panel
                    splitActivePanel = editorPanel;
                    saveSplitViewState();
                } else {
                    // No editor panel found, use the active panel
                    const state = splitActivePanel === 'left' ? splitViewState.left : splitViewState.right;
                    state.view = 'editor';
                    state.sceneId = sceneId;
                    state.actId = actId;
                    state.chapterId = chapterId;
                    renderSplitPanelViewContent(splitActivePanel);
                    saveSplitViewState();
                }
            } else {
                // Normal mode
                renderEditor(act, chapter, scene);
            }
            
            // Update scene versions sidebar
            renderSceneVersionsList();
            
            // Afficher automatiquement le panneau d'annotations si la scène en contient (sauf sur mobile)
            const annotationsPanel = document.getElementById('annotationsPanel');
            const annotations = getVersionAnnotations(scene);
            if (annotations && annotations.length > 0) {
                // Sur mobile, ne pas ouvrir automatiquement le panneau
                if (window.innerWidth > 900) {
                    renderAnnotationsPanel();
                }
                updateAnnotationsButton(true);
            } else {
                if (annotationsPanel) {
                    annotationsPanel.classList.remove('visible');
                }
                updateAnnotationsButton(false);
            }
        }

        // Rendering
        // Expand/Collapse All
        function expandAll() {
            project.acts.forEach(act => {
                const actElement = document.getElementById(`act-${act.id}`);
                if (actElement) {
                    const icon = actElement.querySelector('.act-icon');
                    const chaptersContainer = actElement.querySelector('.act-chapters');
                    if (icon && chaptersContainer) {
                        icon.classList.add('expanded');
                        chaptersContainer.classList.add('visible');
                    }
                }
                
                act.chapters.forEach(chapter => {
                    const chapterElement = document.getElementById(`chapter-${chapter.id}`);
                    if (chapterElement) {
                        const icon = chapterElement.querySelector('.chapter-icon');
                        const scenesContainer = chapterElement.querySelector('.scenes-list');
                        if (icon && scenesContainer) {
                            icon.classList.add('expanded');
                            scenesContainer.classList.add('visible');
                        }
                    }
                });
            });
        }

        function collapseAll() {
            project.acts.forEach(act => {
                const actElement = document.getElementById(`act-${act.id}`);
                if (actElement) {
                    const icon = actElement.querySelector('.act-icon');
                    const chaptersContainer = actElement.querySelector('.act-chapters');
                    if (icon && chaptersContainer) {
                        icon.classList.remove('expanded');
                        chaptersContainer.classList.remove('visible');
                    }
                }
                
                act.chapters.forEach(chapter => {
                    const chapterElement = document.getElementById(`chapter-${chapter.id}`);
                    if (chapterElement) {
                        const icon = chapterElement.querySelector('.chapter-icon');
                        const scenesContainer = chapterElement.querySelector('.scenes-list');
                        if (icon && scenesContainer) {
                            icon.classList.remove('expanded');
                            scenesContainer.classList.remove('visible');
                        }
                    }
                });
            });
        }

        // ==========================================
        // HELPER FUNCTIONS - STATS & PROGRESSION
        // ==========================================
        
        function formatWordCount(count) {
            if (count >= 1000) {
                return (count / 1000).toFixed(1).replace('.0', '') + 'k';
            }
            return count.toString();
        }
        
        // getSceneStatus supprimée - on utilise directement scene.status

        function getChapterStats(chapter) {
            const totalScenes = chapter.scenes.length;
            const totalWords = chapter.scenes.reduce((sum, s) => sum + (s.wordCount || 0), 0);
            const completedScenes = chapter.scenes.filter(s => (s.status || 'draft') === 'complete').length;
            const progressPercent = totalScenes > 0 ? Math.round((completedScenes / totalScenes) * 100) : 0;
            return { totalScenes, totalWords, completedScenes, progressPercent };
        }

        function getActStats(act) {
            const totalChapters = act.chapters.length;
            const totalScenes = act.chapters.reduce((sum, ch) => sum + ch.scenes.length, 0);
            const totalWords = act.chapters.reduce((sum, ch) => 
                sum + ch.scenes.reduce((s, scene) => s + (scene.wordCount || 0), 0), 0);
            return { totalChapters, totalScenes, totalWords };
        }

        function renderActsList() {
            const container = document.getElementById('chaptersList');
            
            console.log('renderActsList called');
            console.log('container:', container);
            console.log('project.acts.length:', project.acts.length);
            
            if (!container) {
                console.error('chaptersList container not found!');
                return;
            }
            
            if (project.acts.length === 0) {
                console.log('No acts, showing empty state');
                container.innerHTML = `
                    <div style="padding: 2rem; text-align: center; color: var(--text-muted);">
                        <div style="margin-bottom: 1rem;">Aucun chapitre</div>
                        <button class="btn btn-primary" onclick="openAddChapterModal()">+ Créer un chapitre</button>
                    </div>
                `;
                updateStats();
                return;
            }
            
            console.log('Acts found:', project.acts);
            console.log('expandedActs:', [...expandedActs]);
            console.log('expandedChapters:', [...expandedChapters]);
        
            let html = '<div style="padding: 0 0.5rem;">';
            
            project.acts.forEach((act, actIndex) => {
                const actStats = getActStats(act);
                
                html += '<div class="act-group" id="act-' + act.id + '" data-act-id="' + act.id + '">';
                
                // Toujours afficher le header de l'acte
                const actExpanded = expandedActs.has(act.id);
                html += '<div class="act-header" data-act-id="' + act.id + '">';
                html += '<span class="drag-handle" draggable="true" onclick="event.stopPropagation()">⋮⋮</span>';
                html += '<span class="act-icon' + (actExpanded ? ' expanded' : '') + '" onclick="toggleAct(' + act.id + '); event.stopPropagation();" style="cursor: pointer;">▶</span>';
                html += '<span class="auto-number">' + (actIndex + 1) + '.</span>';
                html += '<span class="act-title" ondblclick="event.stopPropagation(); startEditingAct(' + act.id + ', this)" onclick="toggleAct(' + act.id + ')">' + act.title + '</span>';
                html += '<span class="edit-hint">✏️</span>';
                html += '<span class="word-count-badge" title="' + actStats.totalWords.toLocaleString() + ' mots">' + formatWordCount(actStats.totalWords) + '</span>';
                html += '<button class="btn btn-icon btn-small delete-btn" onclick="event.stopPropagation(); deleteAct(' + act.id + ')">×</button>';
                html += '</div>';
                
                // Visible si dans expandedActs
                const actVisible = expandedActs.has(act.id);
                html += '<div class="act-chapters' + (actVisible ? ' visible' : '') + '">';
        
                act.chapters.forEach((chapter, chapterIndex) => {
                    const chapterStats = getChapterStats(chapter);
                    const chapterStatus = chapterStats.progressPercent === 100 ? 'complete' : chapterStats.progressPercent > 0 ? 'progress' : 'draft';
                    
                    // Numérotation complète
                    const chapterNumber = (actIndex + 1) + '.' + (chapterIndex + 1);
                    
                    html += '<div class="chapter-group" id="chapter-' + chapter.id + '" data-chapter-id="' + chapter.id + '" data-act-id="' + act.id + '">';
                    html += '<div class="chapter-header" data-chapter-id="' + chapter.id + '" data-act-id="' + act.id + '">';
                    html += '<span class="drag-handle" draggable="true" onclick="event.stopPropagation()">⋮⋮</span>';
                    
                    // Icône avec classe expanded si le chapitre est déplié
                    const chapterExpanded = expandedChapters.has(chapter.id);
                    html += '<span class="chapter-icon' + (chapterExpanded ? ' expanded' : '') + '" onclick="toggleChapter(' + act.id + ', ' + chapter.id + '); event.stopPropagation();" style="cursor: pointer;">▶</span>';
                    html += '<span class="auto-number">' + chapterNumber + '</span>';
                    html += '<span class="chapter-title" ondblclick="event.stopPropagation(); startEditingChapter(' + act.id + ', ' + chapter.id + ', this)" onclick="toggleChapter(' + act.id + ', ' + chapter.id + ')">' + chapter.title + '</span>';
                    html += '<span class="edit-hint">✏️</span>';
                    html += '<span class="word-count-badge" title="' + chapterStats.totalWords.toLocaleString() + ' mots">' + formatWordCount(chapterStats.totalWords) + '</span>';
                    html += '<span class="status-badge status-' + chapterStatus + '" title="' + chapterStats.progressPercent + '%"></span>';
                    html += '<span class="chapter-count">' + chapter.scenes.length + '</span>';
                    html += '<button class="btn btn-icon btn-small delete-btn" onclick="event.stopPropagation(); deleteChapter(' + act.id + ', ' + chapter.id + ')">×</button>';
                    html += '</div>';
                    
                    // Visible si dans expandedChapters
                    const chapterVisible = expandedChapters.has(chapter.id);
                    html += '<div class="scenes-list' + (chapterVisible ? ' visible' : '') + '">';
        
                    chapter.scenes.forEach((scene, sceneIndex) => {
                        const sceneStatus = scene.status || 'draft';
                        const sceneWords = scene.wordCount || 0;
                        const synopsis = scene.synopsis ? scene.synopsis.substring(0, 100) + (scene.synopsis.length > 100 ? '...' : '') : '';
                        const tooltipText = scene.synopsis ? scene.synopsis.replace(/"/g, '&quot;').replace(/'/g, '&#39;') : '';
                        
                        // Numérotation complète
                        const sceneNumber = (actIndex + 1) + '.' + (chapterIndex + 1) + '.' + (sceneIndex + 1);
                        
                        html += '<div class="scene-item draggable" draggable="true" data-scene-id="' + scene.id + '" data-chapter-id="' + chapter.id + '" data-act-id="' + act.id + '" onclick="openScene(' + act.id + ', ' + chapter.id + ', ' + scene.id + ')"' + (tooltipText ? ' title="' + tooltipText + '"' : '') + '>';
                        html += '<div style="display: flex; align-items: center; gap: 0.4rem; flex: 1; min-width: 0;">';
                        html += '<span class="drag-handle">⋮⋮</span>';
                        html += '<span class="auto-number">' + sceneNumber + '</span>';
                        html += '<div style="flex: 1; min-width: 0; overflow: hidden;">';
                        html += '<span ondblclick="event.stopPropagation(); startEditingScene(' + act.id + ', ' + chapter.id + ', ' + scene.id + ', this)" style="display: block;">' + scene.title + '</span>';
                        if (synopsis) {
                            html += '<span class="scene-synopsis">' + synopsis + '</span>';
                        }
                        html += '</div>';
                        html += '<span class="edit-hint">✏️</span>';
                        html += '</div>';
                        html += '<span class="word-count-badge" title="' + sceneWords.toLocaleString() + ' mots">' + formatWordCount(sceneWords) + '</span>';
                        html += '<span class="status-badge status-' + sceneStatus + '" onclick="event.stopPropagation(); toggleSceneStatus(' + act.id + ', ' + chapter.id + ', ' + scene.id + ', event)" style="cursor: pointer;" title="Cliquez pour changer le statut"></span>';
                        html += '<button class="btn btn-icon btn-small delete-btn" onclick="event.stopPropagation(); deleteScene(' + act.id + ', ' + chapter.id + ', ' + scene.id + ')">×</button>';
                        html += '</div>';
                    });
        
                    html += '<div class="scene-item" onclick="openAddSceneModal(' + act.id + ', ' + chapter.id + ')" style="opacity: 0.6; font-style: italic;">+ Ajouter une scène</div>';
                    html += '</div></div>';
                });
        
                // Bouton ajouter chapitre
                html += '<div class="scene-item" onclick="openAddChapterModal(' + act.id + ')" style="opacity: 0.6; font-style: italic; margin-left: 1rem;">+ Ajouter un chapitre</div>';
                html += '</div></div>';
            });
        
            html += '</div>';
            
            console.log('Generated HTML length:', html.length);
            console.log('First 500 chars:', html.substring(0, 500));
            
            container.innerHTML = html;
            
            console.log('Container innerHTML set, children:', container.children.length);
            
            setupActDragAndDrop();
            setupChapterDragAndDrop();
            setupSceneDragAndDrop();
            updateStats();
            updateProgressBar();
            applyStatusFilters();
            setTimeout(() => restoreTreeState(), 50);
        }
        function renderSceneCharacters(actId, chapterId, scene) {
            if (!scene.linkedCharacters || scene.linkedCharacters.length === 0) {
                return '<span style="font-size: 0.8rem; color: var(--text-muted); font-style: italic;">Aucun personnage lié</span>';
            }

            return scene.linkedCharacters.map(charId => {
                const character = project.characters.find(c => c.id === charId);
                if (!character) return '';
                return `
                    <span class="link-badge" onclick="event.stopPropagation(); switchView('characters'); openCharacterDetail(${charId});">
                        ${character.name}
                        <span class="link-badge-remove" onclick="event.stopPropagation(); toggleCharacterInScene(${actId}, ${chapterId}, ${scene.id}, ${charId}); openScene(${actId}, ${chapterId}, ${scene.id});">×</span>
                    </span>
                `;
            }).join('');
        }

        function renderSceneElements(actId, chapterId, scene) {
            if (!scene.linkedElements || scene.linkedElements.length === 0) {
                return '<span style="font-size: 0.8rem; color: var(--text-muted); font-style: italic;">Aucun élément lié</span>';
            }

            return scene.linkedElements.map(elemId => {
                const element = project.world.find(e => e.id === elemId);
                if (!element) return '';
                return `
                    <span class="link-badge" onclick="event.stopPropagation(); switchView('world'); openWorldDetail(${elemId});">
                        ${element.name}
                        <span class="link-badge-remove" onclick="event.stopPropagation(); toggleElementInScene(${actId}, ${chapterId}, ${scene.id}, ${elemId}); openScene(${actId}, ${chapterId}, ${scene.id});">×</span>
                    </span>
                `;
            }).join('');
        }

        function renderSceneMetroEvents(sceneId) {
            if (!project.metroTimeline || project.metroTimeline.length === 0) {
                return '<span style="font-size: 0.8rem; color: var(--text-muted); font-style: italic;">Aucun événement</span>';
            }

            // Find all events linked to this scene (use == for loose comparison to handle string/number)
            const linkedEvents = project.metroTimeline.filter(event => event.sceneId == sceneId);
            
            if (linkedEvents.length === 0) {
                return '<span style="font-size: 0.8rem; color: var(--text-muted); font-style: italic;">Aucun événement lié</span>';
            }

            return linkedEvents.map(event => {
                return `
                    <span class="link-badge" style="background: var(--accent-blue); color: white;" onclick="event.stopPropagation(); openMetroEventFromScene(${event.id});" title="${event.date || 'Sans date'}">
                        <i data-lucide="train-track" style="width:12px;height:12px;vertical-align:middle;margin-right:2px;"></i>
                        ${event.title}
                    </span>
                `;
            }).join('');
        }

        function openCharacterLinker(actId, chapterId, sceneId) {
            const act = project.acts.find(a => a.id === actId);
            const chapter = act.chapters.find(c => c.id === chapterId);
            const scene = chapter.scenes.find(s => s.id === sceneId);

            document.getElementById('referencesModalTitle').textContent = 'Lier des personnages à cette scène';
            document.getElementById('referencesModalContent').innerHTML = `
                <div class="tag-selector">
                    ${project.characters.map(char => {
                        const isLinked = scene.linkedCharacters && scene.linkedCharacters.includes(char.id);
                        return `
                            <div class="tag-option ${isLinked ? 'selected' : ''}" 
                                 onclick="toggleCharacterInScene(${actId}, ${chapterId}, ${sceneId}, ${char.id}); this.classList.toggle('selected');">
                                ${char.name}
                            </div>
                        `;
                    }).join('')}
                </div>
                ${project.characters.length === 0 ? '<p style="color: var(--text-muted); margin-top: 1rem;">Aucun personnage créé. Créez des personnages dans l\'onglet Personnages.</p>' : ''}
            `;

            document.getElementById('referencesModal').classList.add('active');
        }

        function openElementLinker(actId, chapterId, sceneId) {
            const act = project.acts.find(a => a.id === actId);
            const chapter = act.chapters.find(c => c.id === chapterId);
            const scene = chapter.scenes.find(s => s.id === sceneId);

            document.getElementById('referencesModalTitle').textContent = 'Lier des lieux/éléments à cette scène';
            document.getElementById('referencesModalContent').innerHTML = `
                <div class="tag-selector">
                    ${project.world.map(elem => {
                        const isLinked = scene.linkedElements && scene.linkedElements.includes(elem.id);
                        return `
                            <div class="tag-option ${isLinked ? 'selected' : ''}" 
                                 onclick="toggleElementInScene(${actId}, ${chapterId}, ${sceneId}, ${elem.id}); this.classList.toggle('selected');">
                                ${elem.name} <small>(${elem.type})</small>
                            </div>
                        `;
                    }).join('')}
                </div>
                ${project.world.length === 0 ? '<p style="color: var(--text-muted); margin-top: 1rem;">Aucun élément créé. Créez des lieux dans l\'onglet Univers.</p>' : ''}
            `;

            document.getElementById('referencesModal').classList.add('active');
        }

        function renderEditor(act, chapter, scene) {
            const editorView = document.getElementById('editorView');
            const wordCount = getWordCount(scene.content);
            
            // Vérifier si une version finale existe
            const hasFinalVersion = scene.versions && scene.versions.some(v => v.isFinal === true);
            const finalVersion = hasFinalVersion ? scene.versions.find(v => v.isFinal === true) : null;
            const finalVersionBadge = hasFinalVersion 
                ? `<span style="display: inline-flex; align-items: center; gap: 0.25rem; background: var(--accent-gold); color: var(--bg-accent); font-size: 0.7rem; font-weight: 600; padding: 0.2rem 0.5rem; border-radius: 10px; margin-left: 0.5rem;" title="Version finale : ${finalVersion.number}">⭐ ${finalVersion.number}</span>`
                : '';
            
            editorView.innerHTML = `
                <div class="editor-fixed-top">
                    <div class="editor-header">
                        <div class="editor-breadcrumb">${act.title} > ${chapter.title}</div>
                        <div style="display: flex; align-items: center; gap: 1rem;">
                            <div class="editor-title" style="flex: 1;">${scene.title}${finalVersionBadge}</div>
                            <button class="btn btn-small" onclick="toggleFocusMode()" title="Mode Focus (F11)" style="white-space: nowrap;">
                                <i data-lucide="maximize" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Focus
                            </button>
                        </div>
                        <div class="editor-meta">
                            <span id="sceneWordCount">${wordCount} mots</span>
                            <span>Dernière modification : ${new Date().toLocaleDateString('fr-FR')}</span>
                        </div>
                        <div class="editor-synopsis">
                            <span class="synopsis-label"><i data-lucide="file-text" style="width:12px;height:12px;"></i> Résumé :</span>
                            <input type="text" 
                                   class="synopsis-input" 
                                   value="${(scene.synopsis || '').replace(/"/g, '&quot;')}" 
                                   placeholder="Ajouter un résumé de la scène..."
                                   onchange="updateSceneSynopsis(${act.id}, ${chapter.id}, ${scene.id}, this.value)"
                                   oninput="this.style.width = Math.max(200, this.scrollWidth) + 'px'">
                        </div>
                    </div>
                    <button class="toolbar-mobile-toggle" onclick="toggleEditorToolbar()">
                        <span id="toolbarToggleText"><i data-lucide="pen-line" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Afficher les outils de formatage</span>
                    </button>
                    <button class="links-panel-toggle" onclick="toggleLinksPanel()">
                        <span id="linksPanelToggleText"><i data-lucide="chevron-right" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Afficher personnages & lieux liés</span>
                    </button>
                    <div class="editor-toolbar" id="editorToolbar">
                        <!-- Basic formatting -->
                        <div class="toolbar-group">
                            <button class="toolbar-btn" data-format="bold" onclick="formatText('bold')" title="Gras (Ctrl+B)">
                                <strong>B</strong>
                            </button>
                            <button class="toolbar-btn" data-format="italic" onclick="formatText('italic')" title="Italique (Ctrl+I)">
                                <em>I</em>
                            </button>
                            <button class="toolbar-btn" data-format="underline" onclick="formatText('underline')" title="Souligné (Ctrl+U)">
                                <u>U</u>
                            </button>
                            <button class="toolbar-btn" data-format="strikethrough" onclick="formatText('strikeThrough')" title="Barré">
                                <s>S</s>
                            </button>
                        </div>
                        
                        <!-- Font family and size -->
                        <div class="toolbar-group">
                            <select class="font-family-selector" onchange="formatText('fontName', this.value)" title="Police de caractères">
                                <option value="Crimson Pro">Crimson Pro</option>
                                <option value="Arial">Arial</option>
                                <option value="Georgia">Georgia</option>
                                <option value="Times New Roman">Times New Roman</option>
                                <option value="Courier New">Courier New</option>
                                <option value="Verdana">Verdana</option>
                                <option value="Garamond">Garamond</option>
                                <option value="Palatino">Palatino</option>
                            </select>
                            <select class="font-size-selector" onchange="formatText('fontSize', this.value)" title="Taille de police">
                                <option value="1">Très petit</option>
                                <option value="2">Petit</option>
                                <option value="3" selected>Normal</option>
                                <option value="4">Grand</option>
                                <option value="5">Très grand</option>
                                <option value="6">Énorme</option>
                                <option value="7">Gigantesque</option>
                            </select>
                        </div>
                        
                        <!-- Text color -->
                        <div class="toolbar-group">
                            <div class="color-picker-wrapper">
                                <button class="toolbar-btn" onclick="toggleColorPicker('text', event)" title="Couleur du texte">
                                    <span style="border-bottom: 3px solid currentColor;">A</span>
                                </button>
                                <div class="color-picker-dropdown" id="textColorPicker">
                                    <div class="color-grid" id="textColorGrid"></div>
                                    <div class="color-input-wrapper">
                                        <input type="color" id="textColorInput" onchange="applyTextColor(this.value)">
                                        <input type="text" id="textColorHex" placeholder="#000000" maxlength="7" onchange="applyTextColor(this.value)">
                                    </div>
                                </div>
                            </div>
                            <div class="color-picker-wrapper">
                                <button class="toolbar-btn" onclick="toggleColorPicker('background', event)" title="Couleur de fond">
                                    <span style="background: yellow; padding: 0 4px;">A</span>
                                </button>
                                <div class="color-picker-dropdown" id="backgroundColorPicker">
                                    <div class="color-grid" id="backgroundColorGrid"></div>
                                    <div class="color-input-wrapper">
                                        <input type="color" id="bgColorInput" onchange="applyBackgroundColor(this.value)">
                                        <input type="text" id="bgColorHex" placeholder="#FFFF00" maxlength="7" onchange="applyBackgroundColor(this.value)">
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Alignment -->
                        <div class="toolbar-group">
                            <button class="toolbar-btn" onclick="formatText('justifyLeft')" title="Aligner à gauche">
                                ⫷
                            </button>
                            <button class="toolbar-btn" onclick="formatText('justifyCenter')" title="Centrer">
                                ⫶
                            </button>
                            <button class="toolbar-btn" onclick="formatText('justifyRight')" title="Aligner à droite">
                                ⫸
                            </button>
                            <button class="toolbar-btn" onclick="formatText('justifyFull')" title="Justifier">
                                ☰
                            </button>
                        </div>
                        
                        <!-- Headings -->
                        <div class="toolbar-group">
                            <button class="toolbar-btn" onclick="formatText('formatBlock', 'h1')" title="Titre 1">H1</button>
                            <button class="toolbar-btn" onclick="formatText('formatBlock', 'h2')" title="Titre 2">H2</button>
                            <button class="toolbar-btn" onclick="formatText('formatBlock', 'h3')" title="Titre 3">H3</button>
                            <button class="toolbar-btn" onclick="formatText('formatBlock', 'p')" title="Paragraphe">P</button>
                        </div>
                        
                        <!-- Lists and quotes -->
                        <div class="toolbar-group">
                            <button class="toolbar-btn" onclick="formatText('insertUnorderedList')" title="Liste à puces">• Liste</button>
                            <button class="toolbar-btn" onclick="formatText('insertOrderedList')" title="Liste numérotée">1. Liste</button>
                            <button class="toolbar-btn" onclick="formatText('formatBlock', 'blockquote')" title="Citation">❝ Citation</button>
                        </div>
                        
                        <!-- Indentation -->
                        <div class="toolbar-group">
                            <button class="toolbar-btn" onclick="formatText('indent')" title="Augmenter l'indentation">→|</button>
                            <button class="toolbar-btn" onclick="formatText('outdent')" title="Diminuer l'indentation">|←</button>
                        </div>
                        
                        <!-- Superscript, subscript -->
                        <div class="toolbar-group">
                            <button class="toolbar-btn" onclick="formatText('superscript')" title="Exposant">x²</button>
                            <button class="toolbar-btn" onclick="formatText('subscript')" title="Indice">x₂</button>
                        </div>
                        
                        <!-- Annotations -->
                        <div class="toolbar-group">
                            <button class="toolbar-btn annotations-toolbar-btn" onclick="toggleAnnotationsPanel()" title="Annotations" id="toolbarAnnotationsBtn"><i data-lucide="message-square"></i></button>
                        </div>
                        
                        <!-- Other -->
                        <div class="toolbar-group">
                            <button class="toolbar-btn" onclick="formatText('insertHorizontalRule')" title="Ligne horizontale">─</button>
                            <button class="toolbar-btn" onclick="formatText('removeFormat')" title="Supprimer le formatage">✕ Format</button>
                        </div>
                        
                        <!-- Révision - à la fin -->
                        <div class="toolbar-group">
                            <button class="toolbar-btn" onclick="toggleRevisionMode()" title="Mode Révision (Ctrl+R)" id="toolbarRevisionBtn" style="color: var(--accent-gold); font-weight: 600;">✏️ RÉVISION</button>
                        </div>
                    </div>
                    <div class="links-panel-sticky" id="linksPanel">
                        <div style="display: flex; gap: 2rem; align-items: start;">
                            <div style="flex: 1;">
                                <div style="font-size: 0.85rem; font-weight: 600; margin-bottom: 0.5rem; color: var(--text-muted);"><i data-lucide="users" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Personnages</div>
                                <div class="quick-links">
                                    ${renderSceneCharacters(act.id, chapter.id, scene)}
                                    <button class="btn btn-small" onclick="openCharacterLinker(${act.id}, ${chapter.id}, ${scene.id})" style="font-size: 0.75rem; padding: 0.3rem 0.6rem;">+ Lier</button>
                                </div>
                            </div>
                            <div style="flex: 1;">
                                <div style="font-size: 0.85rem; font-weight: 600; margin-bottom: 0.5rem; color: var(--text-muted);"><i data-lucide="globe" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Lieux/Éléments</div>
                                <div class="quick-links">
                                    ${renderSceneElements(act.id, chapter.id, scene)}
                                    <button class="btn btn-small" onclick="openElementLinker(${act.id}, ${chapter.id}, ${scene.id})" style="font-size: 0.75rem; padding: 0.3rem 0.6rem;">+ Lier</button>
                                </div>
                            </div>
                            <div style="flex: 1;">
                                <div style="font-size: 0.85rem; font-weight: 600; margin-bottom: 0.5rem; color: var(--text-muted);"><i data-lucide="train-track" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Timeline</div>
                                <div class="quick-links">
                                    ${renderSceneMetroEvents(scene.id)}
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="editor-workspace">
                    <div class="editor-content">
                        <div 
                            class="editor-textarea" 
                            contenteditable="true"
                            spellcheck="true"
                            data-placeholder="Commencez à écrire votre scène..."
                            oninput="updateSceneContent()"
                            onkeydown="handleEditorKeydown(event)"
                        >${scene.content}</div>
                    </div>
                </div>
            `;
            
            // Focus the editor
            setTimeout(() => {
                const editor = document.querySelector('.editor-textarea');
                if (editor && editor.textContent.trim() === '') {
                    editor.focus();
                }
            }, 100);
        }

        function showEmptyState() {
            const editorView = document.getElementById('editorView');
            editorView.innerHTML = `
                <div class="empty-state">
                    <div class="empty-state-icon">✍️</div>
                    <div class="empty-state-title">Sélectionnez une scène</div>
                    <div class="empty-state-text">
                        Choisissez une scène dans la barre latérale pour commencer à écrire.
                    </div>
                </div>
            `;
            
            // Reset versions sidebar
            renderSceneVersionsList();
        }

        // Alias pour renderWelcomeEditor
        function renderWelcomeEditor() {
            showEmptyState();
        }

        function renderCharacterWelcome() {
            const editorView = document.getElementById('editorView');
            editorView.innerHTML = `
                <div class="empty-state">
                    <div class="empty-state-icon"><i data-lucide="users" style="width:48px;height:48px;stroke-width:1.5;"></i></div>
                    <div class="empty-state-title">Personnages</div>
                    <div class="empty-state-text">
                        Sélectionnez un personnage dans la liste pour voir sa fiche,<br>
                        ou créez-en un nouveau.
                    </div>
                </div>
            `;
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }

        function renderWorldWelcome() {
            const editorView = document.getElementById('editorView');
            editorView.innerHTML = `
                <div class="empty-state">
                    <div class="empty-state-icon"><i data-lucide="globe" style="width:48px;height:48px;stroke-width:1.5;"></i></div>
                    <div class="empty-state-title">Univers</div>
                    <div class="empty-state-text">
                        Sélectionnez un élément dans la liste pour voir ses détails,<br>
                        ou créez un nouvel élément de votre univers.
                    </div>
                </div>
            `;
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }

        function renderNotesWelcome() {
            const editorView = document.getElementById('editorView');
            editorView.innerHTML = `
                <div class="empty-state">
                    <div class="empty-state-icon"><i data-lucide="sticky-note" style="width:48px;height:48px;stroke-width:1.5;"></i></div>
                    <div class="empty-state-title">Notes</div>
                    <div class="empty-state-text">
                        Sélectionnez une note dans la liste pour la consulter,<br>
                        ou créez une nouvelle note.
                    </div>
                </div>
            `;
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }

        function renderCodexWelcome() {
            const editorView = document.getElementById('editorView');
            editorView.innerHTML = `
                <div class="empty-state">
                    <div class="empty-state-icon"><i data-lucide="book-open" style="width:48px;height:48px;stroke-width:1.5;"></i></div>
                    <div class="empty-state-title">Codex</div>
                    <div class="empty-state-text">
                        Sélectionnez une entrée dans la liste pour la consulter,<br>
                        ou créez une nouvelle entrée de codex.
                    </div>
                </div>
            `;
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }

        function updateSceneContent() {
            const editor = document.querySelector('.editor-textarea');
            const act = project.acts.find(a => a.id === currentActId);
            const chapter = act.chapters.find(c => c.id === currentChapterId);
            const scene = chapter.scenes.find(s => s.id === currentSceneId);
            
            scene.content = editor.innerHTML;
            
            const wordCount = getWordCount(editor.innerHTML);
            scene.wordCount = wordCount;
            
            // Update active version content
            updateSceneContentWithVersion(editor.innerHTML);
            
            document.getElementById('sceneWordCount').textContent = `${wordCount} mots`;
            
            saveProject();
            updateStats();
            renderActsList();
            trackWritingSession();
            
            // Mettre à jour les indicateurs en mode focus
            if (focusModeActive) {
                updateWritingProgress();
            }
            
            // Auto-détection des personnages et lieux mentionnés dans le texte
            autoDetectLinksDebounced();
        }

        function getWordCount(html) {
            // Create temporary div to strip HTML tags
            const temp = document.createElement('div');
            temp.innerHTML = html;
            const text = temp.textContent || temp.innerText || '';
            return text.split(/\s+/).filter(w => w.length > 0).length;
        }

        // ============================================
        // AUTO-DÉTECTION DES PERSONNAGES ET LIEUX
        // ============================================
        
        let autoDetectTimeout = null;
        
        function autoDetectLinksDebounced() {
            clearTimeout(autoDetectTimeout);
            autoDetectTimeout = setTimeout(() => {
                autoDetectLinks();
            }, 800); // Délai de 800ms après arrêt de la frappe
        }
        
        function autoDetectLinks() {
            if (!currentActId || !currentChapterId || !currentSceneId) return;
            
            const act = project.acts.find(a => a.id === currentActId);
            if (!act) return;
            const chapter = act.chapters.find(c => c.id === currentChapterId);
            if (!chapter) return;
            const scene = chapter.scenes.find(s => s.id === currentSceneId);
            if (!scene) return;
            
            // Obtenir le texte brut de la scène
            const editor = document.querySelector('.editor-textarea');
            if (!editor) return;
            
            const temp = document.createElement('div');
            temp.innerHTML = editor.innerHTML;
            const sceneText = temp.textContent || temp.innerText || '';
            
            // Normaliser le texte pour la recherche (sans accents, minuscule)
            const normalizedText = normalizeForSearch(sceneText);
            
            // Initialiser les tableaux si nécessaire
            if (!scene.linkedCharacters) scene.linkedCharacters = [];
            if (!scene.linkedElements) scene.linkedElements = [];
            
            let hasChanges = false;
            
            // === PERSONNAGES ===
            project.characters.forEach(char => {
                const charNameNormalized = normalizeForSearch(char.name);
                // Vérifier si le nom apparaît comme mot complet
                const regex = new RegExp('\\b' + escapeRegex(charNameNormalized) + '\\b', 'i');
                const isInText = regex.test(normalizedText);
                const isLinked = scene.linkedCharacters.includes(char.id);
                
                if (isInText && !isLinked) {
                    // Ajouter automatiquement
                    scene.linkedCharacters.push(char.id);
                    hasChanges = true;
                } else if (!isInText && isLinked) {
                    // Retirer automatiquement
                    const index = scene.linkedCharacters.indexOf(char.id);
                    if (index > -1) {
                        scene.linkedCharacters.splice(index, 1);
                        hasChanges = true;
                    }
                }
            });
            
            // === LIEUX/ÉLÉMENTS ===
            project.world.forEach(elem => {
                const elemNameNormalized = normalizeForSearch(elem.name);
                // Vérifier si le nom apparaît comme mot complet
                const regex = new RegExp('\\b' + escapeRegex(elemNameNormalized) + '\\b', 'i');
                const isInText = regex.test(normalizedText);
                const isLinked = scene.linkedElements.includes(elem.id);
                
                if (isInText && !isLinked) {
                    // Ajouter automatiquement
                    scene.linkedElements.push(elem.id);
                    hasChanges = true;
                } else if (!isInText && isLinked) {
                    // Retirer automatiquement
                    const index = scene.linkedElements.indexOf(elem.id);
                    if (index > -1) {
                        scene.linkedElements.splice(index, 1);
                        hasChanges = true;
                    }
                }
            });
            
            // Mettre à jour l'affichage si des changements ont eu lieu
            if (hasChanges) {
                saveProject();
                refreshLinksPanel();
            }
        }
        
        // Normaliser le texte pour la recherche (retirer accents, minuscule)
        function normalizeForSearch(text) {
            return text
                .toLowerCase()
                .normalize('NFD')
                .replace(/[\u0300-\u036f]/g, ''); // Retire les accents
        }
        
        // Échapper les caractères spéciaux regex
        function escapeRegex(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }
        
        // Rafraîchir le panneau des liens dans l'éditeur
        function refreshLinksPanel() {
            const linksPanel = document.getElementById('linksPanel');
            if (!linksPanel) return;
            
            const act = project.acts.find(a => a.id === currentActId);
            if (!act) return;
            const chapter = act.chapters.find(c => c.id === currentChapterId);
            if (!chapter) return;
            const scene = chapter.scenes.find(s => s.id === currentSceneId);
            if (!scene) return;
            
            const flexDivs = linksPanel.querySelectorAll('[style*="flex: 1"]');
            
            // Rafraîchir les personnages
            if (flexDivs.length >= 1) {
                const charDiv = flexDivs[0];
                const quickLinks = charDiv.querySelector('.quick-links');
                if (quickLinks) {
                    quickLinks.innerHTML = `
                        ${renderSceneCharacters(currentActId, currentChapterId, scene)}
                        <button class="btn btn-small" onclick="openCharacterLinker(${currentActId}, ${currentChapterId}, ${currentSceneId})" style="font-size: 0.75rem; padding: 0.3rem 0.6rem;">+ Lier</button>
                    `;
                }
            }
            
            // Rafraîchir les lieux/éléments
            if (flexDivs.length >= 2) {
                const locationDiv = flexDivs[1];
                const quickLinks = locationDiv.querySelector('.quick-links');
                if (quickLinks) {
                    quickLinks.innerHTML = `
                        ${renderSceneElements(currentActId, currentChapterId, scene)}
                        <button class="btn btn-small" onclick="openElementLinker(${currentActId}, ${currentChapterId}, ${currentSceneId})" style="font-size: 0.75rem; padding: 0.3rem 0.6rem;">+ Lier</button>
                    `;
                }
            }
            
            // Réinitialiser les icônes Lucide
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }

        // Rich Text Formatting
        function formatText(command, value = null) {
            document.execCommand(command, false, value);
            document.querySelector('.editor-textarea').focus();
        }

        // ============================================
        // FLOATING EDITOR MENU (MOBILE)
        // ============================================
        // GESTES TACTILES POUR L'ÉDITEUR
        // ============================================
        
        function initEditorGestures() {
            const editor = document.querySelector('.editor-textarea');
            if (!editor) return;
            
            let lastTap = 0;
            let initialPinchDistance = 0;
            let initialFontSize = 16;
            
            // Double-tap pour mode focus
            editor.addEventListener('touchend', (e) => {
                const currentTime = new Date().getTime();
                const tapLength = currentTime - lastTap;
                
                if (tapLength < 300 && tapLength > 0) {
                    // Double-tap détecté
                    e.preventDefault();
                    toggleFocusMode();
                }
                lastTap = currentTime;
            });
            
            // Swipe à 2 doigts pour annuler/refaire
            let touchStartY = 0;
            editor.addEventListener('touchstart', (e) => {
                if (e.touches.length === 2) {
                    touchStartY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
                    
                    // Calculer distance initiale pour pinch
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    initialPinchDistance = Math.sqrt(dx * dx + dy * dy);
                    
                    const computedStyle = window.getComputedStyle(editor);
                    initialFontSize = parseFloat(computedStyle.fontSize);
                }
            });
            
            editor.addEventListener('touchmove', (e) => {
                if (e.touches.length === 2) {
                    // Pinch to zoom font size
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    const currentDistance = Math.sqrt(dx * dx + dy * dy);
                    
                    const scale = currentDistance / initialPinchDistance;
                    const newFontSize = Math.max(12, Math.min(24, initialFontSize * scale));
                    
                    editor.style.fontSize = newFontSize + 'px';
                }
            });
            
            editor.addEventListener('touchend', (e) => {
                if (e.changedTouches.length === 2) {
                    const touchEndY = touchStartY;
                    const deltaY = touchEndY - touchStartY;
                    
                    // Swipe vers le haut = annuler
                    if (deltaY < -50) {
                        e.preventDefault();
                        undo();
                    }
                    // Swipe vers le bas = refaire
                    else if (deltaY > 50) {
                        e.preventDefault();
                        redo();
                    }
                }
            });
        }
        
        // ============================================
        // FLOATING EDITOR MENU (MOBILE)
        // ============================================
        
        let floatingMenuPosition = null;
        let isDraggingFloatingMenu = false;
        let dragOffset = { x: 0, y: 0 };

        function initFloatingEditorMenu() {
            const menu = document.getElementById('floatingEditorMenu');
            const handle = document.getElementById('floatingMenuHandle');
            const toggleBtn = document.getElementById('floatingEditorToggle');
            
            if (!menu || !handle) {
                console.error('❌ Menu flottant ou handle non trouvé');
                return;
            }

            if (!toggleBtn) {
                console.error('❌ Bouton toggle non trouvé');
                return;
            }

            // Ajouter le listener au bouton toggle
            toggleBtn.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                toggleFloatingEditorMenu();
            });

            console.log('✅ Menu flottant initialisé');
            
            // Load saved position or set default
            const savedPos = localStorage.getItem('floatingMenuPosition');
            if (savedPos) {
                try {
                    floatingMenuPosition = JSON.parse(savedPos);
                    console.log('📍 Position chargée:', floatingMenuPosition);
                } catch (e) {
                    console.error('Erreur chargement position:', e);
                    floatingMenuPosition = null;
                }
            }
            
            if (!floatingMenuPosition) {
                // Default position: center of screen
                floatingMenuPosition = {
                    x: Math.max(10, (window.innerWidth / 2) - 150),
                    y: Math.max(10, (window.innerHeight / 2) - 200)
                };
                console.log('📍 Position par défaut:', floatingMenuPosition);
            }

            // Setup drag - TOUCH
            handle.addEventListener('touchstart', function(e) {
                console.log('👆 TOUCH START - isDragging avant:', isDraggingFloatingMenu);
                isDraggingFloatingMenu = true;
                console.log('👆 TOUCH START - isDragging après:', isDraggingFloatingMenu);
                
                const touch = e.touches[0];
                const rect = menu.getBoundingClientRect();
                
                dragOffset.x = touch.clientX - rect.left;
                dragOffset.y = touch.clientY - rect.top;
                
                handle.style.background = 'var(--accent-red)';
                console.log('🎯 Touch:', touch.clientX, touch.clientY);
                console.log('🎯 Rect:', rect.left, rect.top, rect.width, rect.height);
                console.log('🎯 Drag offset:', dragOffset);
                
                e.preventDefault();
                e.stopPropagation();
            }, { passive: false });

            // Setup drag - MOUSE (pour test desktop)
            handle.addEventListener('mousedown', function(e) {
                console.log('🖱️ MOUSE DOWN');
                isDraggingFloatingMenu = true;
                const rect = menu.getBoundingClientRect();
                
                dragOffset.x = e.clientX - rect.left;
                dragOffset.y = e.clientY - rect.top;
                
                handle.style.background = 'var(--accent-red)';
                
                e.preventDefault();
                e.stopPropagation();
            });

            console.log('✅ Drag handlers installés sur handle');
        }

        // TOUCH MOVE - au niveau global
        document.addEventListener('touchmove', function(e) {
            console.log('👆 TOUCH MOVE event - isDragging:', isDraggingFloatingMenu);
            
            if (!isDraggingFloatingMenu) return;
            
            console.log('👆 TOUCH MOVE - vraiment en train de bouger!');
            const menu = document.getElementById('floatingEditorMenu');
            const handle = document.getElementById('floatingMenuHandle');
            const touch = e.touches[0];
            
            const newX = touch.clientX - dragOffset.x;
            const newY = touch.clientY - dragOffset.y;
            
            console.log('📍 Nouvelle position calculée:', newX, newY);
            
            floatingMenuPosition.x = Math.max(10, Math.min(newX, window.innerWidth - menu.offsetWidth - 10));
            floatingMenuPosition.y = Math.max(10, Math.min(newY, window.innerHeight - menu.offsetHeight - 10));
            
            console.log('📍 Position finale:', floatingMenuPosition);
            
            menu.style.transform = 'none';
            menu.style.left = floatingMenuPosition.x + 'px';
            menu.style.top = floatingMenuPosition.y + 'px';
            
            e.preventDefault();
            e.stopPropagation();
        }, { passive: false });

        // TOUCH END - au niveau global
        document.addEventListener('touchend', function(e) {
            console.log('👆 TOUCH END - isDragging:', isDraggingFloatingMenu);
            
            if (!isDraggingFloatingMenu) return;
            
            console.log('👆 TOUCH END - Position finale:', floatingMenuPosition);
            isDraggingFloatingMenu = false;
            
            const handle = document.getElementById('floatingMenuHandle');
            if (handle) handle.style.background = 'var(--accent-gold)';
            
            localStorage.setItem('floatingMenuPosition', JSON.stringify(floatingMenuPosition));
            console.log('💾 Position sauvegardée');
        });

        // MOUSE MOVE - au niveau global
        document.addEventListener('mousemove', function(e) {
            if (!isDraggingFloatingMenu) return;
            
            console.log('🖱️ MOUSE MOVE');
            const menu = document.getElementById('floatingEditorMenu');
            
            const newX = e.clientX - dragOffset.x;
            const newY = e.clientY - dragOffset.y;
            
            floatingMenuPosition.x = Math.max(10, Math.min(newX, window.innerWidth - menu.offsetWidth - 10));
            floatingMenuPosition.y = Math.max(10, Math.min(newY, window.innerHeight - menu.offsetHeight - 10));
            
            menu.style.transform = 'none';
            menu.style.left = floatingMenuPosition.x + 'px';
            menu.style.top = floatingMenuPosition.y + 'px';
            
            e.preventDefault();
        });

        // MOUSE UP - au niveau global
        document.addEventListener('mouseup', function(e) {
            if (!isDraggingFloatingMenu) return;
            
            console.log('🖱️ MOUSE UP - Position finale:', floatingMenuPosition);
            isDraggingFloatingMenu = false;
            
            const handle = document.getElementById('floatingMenuHandle');
            if (handle) handle.style.background = 'var(--accent-gold)';
            
            localStorage.setItem('floatingMenuPosition', JSON.stringify(floatingMenuPosition));
        });

        function updateFloatingMenuPosition() {
            const menu = document.getElementById('floatingEditorMenu');
            if (menu && floatingMenuPosition) {
                menu.style.transform = 'none'; // Annuler le centrage par défaut
                menu.style.left = floatingMenuPosition.x + 'px';
                menu.style.top = floatingMenuPosition.y + 'px';
                console.log('Position mise à jour:', floatingMenuPosition);
            }
        }

        function toggleFloatingEditorMenu() {
            console.log('toggleFloatingEditorMenu appelée');
            const menu = document.getElementById('floatingEditorMenu');
            const toggle = document.getElementById('floatingEditorToggle');
            
            console.log('Menu:', menu);
            console.log('Toggle:', toggle);
            
            if (!menu || !toggle) {
                console.error('Menu ou toggle non trouvé!');
                return;
            }
            
            if (menu.classList.contains('active')) {
                console.log('Fermeture du menu');
                menu.classList.remove('active');
                toggle.textContent = '✏️';
            } else {
                console.log('Ouverture du menu');
                menu.classList.add('active');
                updateFloatingMenuPosition();
                toggle.textContent = '✖️';
            }
        }

        function applyFloatingFormat() {
            const format = document.getElementById('floatingFormatBlock').value;
            document.execCommand('formatBlock', false, format);
            const editor = document.querySelector('.editor-textarea');
            if (editor) editor.focus();
        }

        function changeFloatingTextColor() {
            const color = document.getElementById('floatingTextColor').value;
            document.execCommand('foreColor', false, color);
            const editor = document.querySelector('.editor-textarea');
            if (editor) editor.focus();
        }

        function changeFloatingBackgroundColor() {
            const color = document.getElementById('floatingBgColor').value;
            document.execCommand('hiliteColor', false, color);
            const editor = document.querySelector('.editor-textarea');
            if (editor) editor.focus();
        }

        function insertLink() {
            const url = prompt('URL du lien :');
            if (url) {
                const selection = window.getSelection();
                if (selection.toString()) {
                    document.execCommand('createLink', false, url);
                } else {
                    const text = prompt('Texte du lien :');
                    if (text) {
                        document.execCommand('insertHTML', false, `<a href="${url}" target="_blank">${text}</a>`);
                    }
                }
                const editor = document.querySelector('.editor-textarea');
                if (editor) editor.focus();
            }
        }

        function insertImage() {
            const url = prompt('URL de l\'image :');
            if (url) {
                document.execCommand('insertImage', false, url);
                const editor = document.querySelector('.editor-textarea');
                if (editor) editor.focus();
            }
        }

        // ============================================
        // END FLOATING EDITOR MENU
        // ============================================


        // Color palette for quick selection
        const colorPalette = [
            '#000000', '#434343', '#666666', '#999999', '#b7b7b7', '#cccccc', '#d9d9d9', '#efefef',
            '#f3f3f3', '#ffffff', '#980000', '#ff0000', '#ff9900', '#ffff00', '#00ff00', '#00ffff',
            '#4a86e8', '#0000ff', '#9900ff', '#ff00ff', '#e6b8af', '#f4cccc', '#fce5cd', '#fff2cc',
            '#d9ead3', '#d0e0e3', '#c9daf8', '#cfe2f3', '#d9d2e9', '#ead1dc', '#dd7e6b', '#ea9999',
            '#f9cb9c', '#ffe599', '#b6d7a8', '#a2c4c9', '#a4c2f4', '#9fc5e8', '#b4a7d6', '#d5a6bd',
            '#cc4125', '#e06666', '#f6b26b', '#ffd966', '#93c47d', '#76a5af', '#6d9eeb', '#6fa8dc',
            '#8e7cc3', '#c27ba0', '#a61c00', '#cc0000', '#e69138', '#f1c232', '#6aa84f', '#45818e',
            '#3c78d8', '#3d85c6', '#674ea7', '#a64d79', '#85200c', '#990000', '#b45f06', '#bf9000',
            '#38761d', '#134f5c', '#1155cc', '#0b5394', '#351c75', '#741b47', '#5b0f00', '#660000'
        ];

        // Initialize color pickers
        // ============================================
        // SIDEBAR RESIZE
        // ============================================
        
        function initSidebarResize() {
            const sidebar = document.querySelector('.sidebar');
            const resizeHandle = document.getElementById('sidebarResizeHandle');
            const appContainer = document.querySelector('.app-container');
            
            if (!sidebar || !resizeHandle) return;
            
            let isResizing = false;
            let startX = 0;
            let startWidth = 0;
            
            resizeHandle.addEventListener('mousedown', (e) => {
                isResizing = true;
                startX = e.clientX;
                startWidth = sidebar.offsetWidth;
                
                document.body.style.cursor = 'ew-resize';
                document.body.style.userSelect = 'none';
                
                e.preventDefault();
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;
                
                const diff = e.clientX - startX;
                const newWidth = startWidth + diff;
                
                // Respecter min et max width
                if (newWidth >= 200 && newWidth <= 600) {
                    sidebar.style.width = newWidth + 'px';
                    appContainer.style.gridTemplateColumns = `${newWidth}px 1fr`;
                }
            });
            
            document.addEventListener('mouseup', () => {
                if (isResizing) {
                    isResizing = false;
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';
                    
                    // Sauvegarder la largeur dans localStorage
                    localStorage.setItem('sidebarWidth', sidebar.offsetWidth);
                }
            });
            
            // Charger la largeur sauvegardée
            const savedWidth = localStorage.getItem('sidebarWidth');
            if (savedWidth) {
                const width = parseInt(savedWidth);
                if (width >= 200 && width <= 600) {
                    sidebar.style.width = width + 'px';
                    appContainer.style.gridTemplateColumns = `${width}px 1fr`;
                }
            }
        }

        function initializeColorPickers() {
            const textColorGrid = document.getElementById('textColorGrid');
            const bgColorGrid = document.getElementById('backgroundColorGrid');
            
            // Vérifier que les éléments existent
            if (!textColorGrid || !bgColorGrid) {
                console.log('Color pickers not found in DOM, skipping initialization');
                return;
            }
            
            colorPalette.forEach(color => {
                // Text color swatch
                const textSwatch = document.createElement('div');
                textSwatch.className = 'color-swatch';
                textSwatch.style.backgroundColor = color;
                textSwatch.title = color;
                textSwatch.onclick = () => applyTextColor(color);
                textColorGrid.appendChild(textSwatch);
                
                // Background color swatch
                const bgSwatch = document.createElement('div');
                bgSwatch.className = 'color-swatch';
                bgSwatch.style.backgroundColor = color;
                bgSwatch.title = color;
                bgSwatch.onclick = () => applyBackgroundColor(color);
                bgColorGrid.appendChild(bgSwatch);
            });
        }

        // Toggle color picker dropdown
        function toggleColorPicker(type, event) {
            const textPicker = document.getElementById('textColorPicker');
            const bgPicker = document.getElementById('backgroundColorPicker');
            
            // Obtenir le bouton cliqué pour positionner la popup
            const button = event ? event.currentTarget : null;
            
            if (type === 'text') {
                const wasActive = textPicker.classList.contains('active');
                bgPicker.classList.remove('active');
                
                if (!wasActive && button) {
                    const rect = button.getBoundingClientRect();
                    textPicker.style.top = (rect.bottom + 5) + 'px';
                    textPicker.style.left = rect.left + 'px';
                }
                textPicker.classList.toggle('active');
            } else {
                const wasActive = bgPicker.classList.contains('active');
                textPicker.classList.remove('active');
                
                if (!wasActive && button) {
                    const rect = button.getBoundingClientRect();
                    bgPicker.style.top = (rect.bottom + 5) + 'px';
                    bgPicker.style.left = rect.left + 'px';
                }
                bgPicker.classList.toggle('active');
            }
        }

        // Apply text color
        function applyTextColor(color) {
            document.execCommand('foreColor', false, color);
            document.getElementById('textColorInput').value = color;
            document.getElementById('textColorHex').value = color.toUpperCase();
            document.querySelector('.editor-textarea').focus();
        }

        // Apply background color
        function applyBackgroundColor(color) {
            document.execCommand('hiliteColor', false, color);
            document.getElementById('bgColorInput').value = color;
            document.getElementById('bgColorHex').value = color.toUpperCase();
            document.querySelector('.editor-textarea').focus();
        }

        // Close color pickers when clicking outside
        document.addEventListener('click', function(event) {
            if (!event.target.closest('.color-picker-wrapper')) {
                document.querySelectorAll('.color-picker-dropdown').forEach(picker => {
                    picker.classList.remove('active');
                });
            }
        });

        function handleEditorKeydown(event) {
            // Handle keyboard shortcuts
            if (event.ctrlKey || event.metaKey) {
                switch(event.key.toLowerCase()) {
                    case 'b':
                        event.preventDefault();
                        formatText('bold');
                        break;
                    case 'i':
                        event.preventDefault();
                        formatText('italic');
                        break;
                    case 'u':
                        event.preventDefault();
                        formatText('underline');
                        break;
                }
            }
        }

        function updateStats() {
            const totalActs = project.acts.length;
            const totalChapters = project.acts.reduce((sum, act) => sum + act.chapters.length, 0);
            const totalWords = project.acts.reduce((sum, act) => {
                return sum + act.chapters.reduce((chSum, chapter) => {
                    return chSum + chapter.scenes.reduce((sceneSum, scene) => {
                        return sceneSum + getWordCount(scene.content);
                    }, 0);
                }, 0);
            }, 0);

            // Mettre à jour les stats dans le header
            const headerWords = document.getElementById('headerTotalWords');
            const headerChapters = document.getElementById('headerTotalChapters');
            if (headerWords) headerWords.textContent = `${totalWords} mots`;
            if (headerChapters) headerChapters.textContent = `${totalChapters} chapitres`;
            
            // Mettre à jour le titre du projet dans le header
            const headerTitle = document.getElementById('headerProjectTitle');
            if (headerTitle) headerTitle.textContent = project.title;
        }

        // Backup and Import Management
        function showBackupMenu() {
            document.getElementById('backupModal').classList.add('active');
        }

        function exportToJSON() {
            const dataStr = JSON.stringify(project, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const filename = `${project.title.replace(/\s+/g, '_')}_${new Date().toISOString().split('T')[0]}.json`;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
            
            alert(`✅ Fichier JSON téléchargé !\n\nNom : ${filename}\n\nTu peux maintenant l'uploader sur Google Drive, Dropbox, ou tout autre service cloud.`);
        }

        function importFromFile() {
            document.getElementById('importFileInput').click();
        }

        function handleFileImport(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (!file.name.endsWith('.json')) {
                alert('❌ Erreur : Le fichier doit être au format JSON');
                return;
            }

            if (!confirm('⚠️ ATTENTION : L\'import va remplacer toutes vos données actuelles.\n\nVoulez-vous créer une sauvegarde avant de continuer ?')) {
                event.target.value = ''; // Reset input
                return;
            }

            // Create backup before import
            exportToJSON();

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedData = JSON.parse(e.target.result);
                    
                    // Validate imported data
                    if (!importedData.acts || !Array.isArray(importedData.acts)) {
                        throw new Error('Format de fichier invalide');
                    }

                    // Merge with current structure to ensure all fields exist
                    project = {
                        title: importedData.title || "Mon Roman",
                        acts: importedData.acts || [],
                        characters: importedData.characters || [],
                        world: importedData.world || [],
                        timeline: importedData.timeline || [],
                        notes: importedData.notes || [],
                        codex: importedData.codex || [],
                        stats: importedData.stats || {
                            dailyGoal: 500,
                            totalGoal: 80000,
                            writingSessions: []
                        },
                        versions: importedData.versions || []
                    };

                    saveProject();
                    switchView('editor');
                    renderActsList();
                    closeModal('backupModal');
                    
                    alert('✅ Import réussi !\n\nToutes vos données ont été restaurées.');
                } catch (error) {
                    alert('❌ Erreur lors de l\'import : ' + error.message);
                }
                
                event.target.value = ''; // Reset input
            };
            
            reader.onerror = function() {
                alert('❌ Erreur lors de la lecture du fichier');
                event.target.value = ''; // Reset input
            };
            
            reader.readAsText(file);
        }

        // Export
        function exportProject() {
            let text = `${project.title}\n${'='.repeat(project.title.length)}\n\n`;
            
            project.acts.forEach(act => {
                text += `\n\n${act.title}\n${'='.repeat(act.title.length)}\n\n`;
                
                act.chapters.forEach(chapter => {
                    text += `\n${chapter.title}\n${'-'.repeat(chapter.title.length)}\n\n`;
                    chapter.scenes.forEach(scene => {
                        // Convert HTML to plain text for export
                        const temp = document.createElement('div');
                        temp.innerHTML = scene.content;
                        const plainText = temp.textContent || temp.innerText || '';
                        
                        text += `\n${scene.title}\n\n${plainText}\n\n`;
                    });
                });
            });

            const blob = new Blob([text], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${project.title.replace(/\s+/g, '_')}.txt`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // Modal Management
        function openAddActModal() {
            document.getElementById('addActModal').classList.add('active');
            setTimeout(() => document.getElementById('actTitleInput').focus(), 100);
        }

        function openAddChapterModal(actId) {
            // Si pas d'actId fourni, utiliser le premier acte ou on en créera un
            if (actId) {
                activeActId = actId;
            } else if (project.acts.length > 0) {
                activeActId = project.acts[0].id;
            } else {
                activeActId = null; // Sera créé dans addChapter
            }
            document.getElementById('addChapterModal').classList.add('active');
            setTimeout(() => document.getElementById('chapterTitleInput').focus(), 100);
        }

        function closeModal(modalId) {
            document.getElementById(modalId).classList.remove('active');
        }

        // ========================================
        // MOBILE MENU FUNCTIONS
        // ========================================
        
        function toggleMobileSidebar() {
            const sidebar = document.querySelector('.sidebar');
            const overlay = document.querySelector('.sidebar-overlay');
            const handle = document.querySelector('.mobile-menu-handle');
            
            console.log('🍔 toggleMobileSidebar appelé');
            console.log('Sidebar:', sidebar);
            console.log('Overlay:', overlay);
            console.log('Handle:', handle);
            
            // Toggle sidebar
            sidebar.classList.toggle('mobile-open');
            
            console.log('Sidebar classes:', sidebar.className);
            console.log('Sidebar mobile-open?', sidebar.classList.contains('mobile-open'));
            
            // Toggle overlay and handle
            if (sidebar.classList.contains('mobile-open')) {
                overlay.style.display = 'block';
                setTimeout(() => overlay.classList.add('active'), 10);
                if (handle) handle.classList.add('hidden');
                // Prevent body scroll when menu is open
                document.body.style.overflow = 'hidden';
                console.log('✅ Sidebar ouverte');
            } else {
                overlay.classList.remove('active');
                setTimeout(() => overlay.style.display = 'none', 300);
                if (handle) handle.classList.remove('hidden');
                // Restore body scroll
                document.body.style.overflow = '';
                console.log('❌ Sidebar fermée');
            }
        }
        
        function closeMobileSidebar() {
            const sidebar = document.querySelector('.sidebar');
            const overlay = document.querySelector('.sidebar-overlay');
            const handle = document.querySelector('.mobile-menu-handle');
            
            if (sidebar.classList.contains('mobile-open')) {
                sidebar.classList.remove('mobile-open');
                overlay.classList.remove('active');
                setTimeout(() => overlay.style.display = 'none', 300);
                if (handle) handle.classList.remove('hidden');
                document.body.style.overflow = '';
            }
        }
        
        // ========================================
        // MOBILE NAVIGATION FUNCTIONS
        // ========================================
        
        function toggleMobileNav() {
            const dropdown = document.getElementById('mobileNavDropdown');
            const toggleBtn = document.getElementById('mobileNavToggleBtn');
            const sidebar = document.querySelector('.sidebar');
            
            if (dropdown.classList.contains('active')) {
                dropdown.classList.remove('active');
                toggleBtn.innerHTML = '☰';
                if (sidebar) sidebar.style.visibility = '';
            } else {
                dropdown.classList.add('active');
                toggleBtn.innerHTML = '✕';
                if (sidebar) sidebar.style.visibility = 'hidden';
            }
        }
        
        function closeMobileNav() {
            const dropdown = document.getElementById('mobileNavDropdown');
            const toggleBtn = document.getElementById('mobileNavToggleBtn');
            const sidebar = document.querySelector('.sidebar');
            
            if (dropdown.classList.contains('active')) {
                dropdown.classList.remove('active');
                toggleBtn.innerHTML = '☰';
                if (sidebar) sidebar.style.visibility = '';
            }
        }
        
        function switchViewMobile(view) {
            // Update active state in mobile menu
            document.querySelectorAll('.mobile-nav-item').forEach(item => {
                item.classList.remove('active');
            });
            const activeItem = document.querySelector(`[data-view="${view}"]`);
            if (activeItem) {
                activeItem.classList.add('active');
            }
            
            // Close mobile nav
            closeMobileNav();
            
            // Switch to the view
            switchView(view);
        }
        
        // ========================================
        // MOBILE EDITOR TOOLBAR FUNCTIONS
        // ========================================
        
        function toggleEditorToolbar() {
            const toolbar = document.getElementById('editorToolbar');
            const toggleText = document.getElementById('toolbarToggleText');
            const toggleBtn = document.querySelector('.toolbar-mobile-toggle');
            
            if (toolbar.classList.contains('expanded')) {
                toolbar.classList.remove('expanded');
                toggleText.innerHTML = '<i data-lucide="pen-line" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Afficher les outils de formatage';
                if (toggleBtn) toggleBtn.classList.remove('expanded');
                if (typeof lucide !== 'undefined') lucide.createIcons();
            } else {
                toolbar.classList.add('expanded');
                toggleText.innerHTML = '<i data-lucide="x" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Masquer les outils de formatage';
                if (toggleBtn) toggleBtn.classList.add('expanded');
                if (typeof lucide !== 'undefined') lucide.createIcons();
            }
        }

        function toggleLinksPanel() {
            const panel = document.getElementById('linksPanel');
            const toggleText = document.getElementById('linksPanelToggleText');
            const toggleBtn = document.querySelector('.links-panel-toggle');
            
            if (panel.classList.contains('expanded')) {
                panel.classList.remove('expanded');
                if (toggleText) toggleText.innerHTML = '<i data-lucide="chevron-right" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Afficher personnages & lieux liés';
                if (toggleBtn) toggleBtn.classList.remove('expanded');
                if (typeof lucide !== 'undefined') lucide.createIcons();
            } else {
                panel.classList.add('expanded');
                if (toggleText) toggleText.innerHTML = '<i data-lucide="chevron-down" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Masquer personnages & lieux liés';
                if (toggleBtn) toggleBtn.classList.add('expanded');
                if (typeof lucide !== 'undefined') lucide.createIcons();
            }
        }

        function toggleToolbarFromFloating() {
            // Fermer le menu flottant
            const floatingMenu = document.getElementById('floatingEditorMenu');
            const floatingToggle = document.getElementById('floatingEditorToggle');
            
            if (floatingMenu && floatingMenu.classList.contains('active')) {
                floatingMenu.classList.remove('active');
                if (floatingToggle) floatingToggle.textContent = '✏️';
            }
            
            // Ouvrir le toolbar complet
            const toolbar = document.getElementById('editorToolbar');
            const toggleText = document.getElementById('toolbarToggleText');
            const toggleBtn = document.querySelector('.toolbar-mobile-toggle');
            
            if (toolbar && !toolbar.classList.contains('expanded')) {
                toolbar.classList.add('expanded');
                if (toggleText) toggleText.textContent = '✕ Masquer les outils de formatage';
                if (toggleBtn) toggleBtn.classList.add('expanded');
            }
            
            // Scroll vers le toolbar pour le rendre visible
            setTimeout(() => {
                if (toolbar) {
                    toolbar.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
            }, 100);
        }
        
        function toggleAdvancedMenu() {
            const advancedBar = document.getElementById('advancedMenuBar');
            const advancedBtn = document.getElementById('advancedMenuBtn');
            
            console.log('Toggle advanced menu clicked');
            console.log('Advanced bar found:', !!advancedBar);
            console.log('Current display:', advancedBar ? window.getComputedStyle(advancedBar).display : 'not found');
            
            if (advancedBar.classList.contains('active')) {
                console.log('Hiding advanced menu');
                advancedBar.classList.remove('active');
                advancedBtn.style.background = '';
            } else {
                console.log('Showing advanced menu');
                advancedBar.classList.add('active');
                advancedBtn.style.background = 'rgba(255,215,0,0.3)';
                
                // Force display after a tick
                setTimeout(() => {
                    console.log('After timeout display:', window.getComputedStyle(advancedBar).display);
                }, 10);
            }
        }
        
        function insertLink() {
            const url = prompt('Entrez l\'URL du lien:');
            if (url) {
                formatText('createLink', url);
            }
        }
        
        // Override switchView to close mobile sidebar
        const originalSwitchView = switchView;
        switchView = function(view) {
            if (window.innerWidth <= 900) {
                closeMobileSidebar();
            }
            originalSwitchView(view);
        };
        
        // Détection dynamique du débordement du header
        function checkHeaderOverflow() {
            const header = document.querySelector('.app-header');
            const headerNav = document.querySelector('.header-nav');
            const body = document.body;
            
            if (!header || !headerNav) return;
            
            // Temporairement forcer le mode desktop pour mesurer
            body.classList.remove('force-mobile-nav');
            
            // Attendre le reflow
            requestAnimationFrame(() => {
                const headerWidth = header.offsetWidth;
                const logoWidth = document.querySelector('.app-logo')?.offsetWidth || 0;
                const actionsWidth = document.querySelector('.header-actions')?.offsetWidth || 0;
                const navWidth = headerNav.scrollWidth;
                const availableSpace = headerWidth - logoWidth - actionsWidth - 60; // 60px de marge
                
                if (navWidth > availableSpace) {
                    body.classList.add('force-mobile-nav');
                } else {
                    body.classList.remove('force-mobile-nav');
                }
            });
        }
        
        // Handle window resize
        let resizeTimeout;
        window.addEventListener('resize', function() {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(function() {
                // Vérifier le débordement du header
                checkHeaderOverflow();
                
                // If resizing to desktop, ensure sidebar is visible and overlay hidden
                if (window.innerWidth > 900 && !document.body.classList.contains('force-mobile-nav')) {
                    const sidebar = document.querySelector('.sidebar');
                    const overlay = document.querySelector('.sidebar-overlay');
                    const menuBtn = document.querySelector('.mobile-menu-toggle');
                    
                    if (sidebar) sidebar.classList.remove('mobile-open');
                    if (overlay) {
                        overlay.classList.remove('active');
                        overlay.style.display = 'none';
                    }
                    if (menuBtn) menuBtn.innerHTML = '☰';
                    document.body.style.overflow = '';
                }
            }, 100);
        });
        
        // Vérifier au chargement
        window.addEventListener('load', function() {
            setTimeout(checkHeaderOverflow, 100);
        });

        // Drag and Drop for Acts
        let draggedAct = null;

        function setupActDragAndDrop() {
            const actHeaders = document.querySelectorAll('.act-header');
            
            actHeaders.forEach(header => {
                const dragHandle = header.querySelector('.drag-handle');
                if (!dragHandle) return;
                
                dragHandle.addEventListener('dragstart', (e) => {
                    draggedAct = parseInt(header.dataset.actId);
                    header.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('type', 'act');
                    e.stopPropagation(); // Empêcher le clic de se propager
                });

                dragHandle.addEventListener('dragend', (e) => {
                    header.classList.remove('dragging');
                    draggedAct = null;
                });

                header.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    
                    const targetActId = parseInt(e.currentTarget.dataset.actId);
                    if (draggedAct && draggedAct !== targetActId) {
                        e.currentTarget.classList.add('drag-over');
                    }
                });

                header.addEventListener('dragleave', (e) => {
                    e.currentTarget.classList.remove('drag-over');
                });

                header.addEventListener('drop', (e) => {
                    e.preventDefault();
                    e.currentTarget.classList.remove('drag-over');
                    
                    const targetActId = parseInt(e.currentTarget.dataset.actId);
                    
                    if (draggedAct && draggedAct !== targetActId) {
                        reorderActs(draggedAct, targetActId);
                    }
                });
            });
        }

        function reorderActs(draggedId, targetId) {
            const draggedIndex = project.acts.findIndex(a => a.id === draggedId);
            const targetIndex = project.acts.findIndex(a => a.id === targetId);
            
            if (draggedIndex === -1 || targetIndex === -1) return;
            
            const [removed] = project.acts.splice(draggedIndex, 1);
            project.acts.splice(targetIndex, 0, removed);
            
            saveProject();
            renderActsList();
        }

        // Drag and Drop for Chapters
        let draggedChapter = { chapterId: null, actId: null };

        function setupChapterDragAndDrop() {
            const chapterHeaders = document.querySelectorAll('.chapter-header');
            
            chapterHeaders.forEach(header => {
                const dragHandle = header.querySelector('.drag-handle');
                if (!dragHandle) return;
                
                dragHandle.addEventListener('dragstart', (e) => {
                    draggedChapter.chapterId = parseInt(header.dataset.chapterId);
                    draggedChapter.actId = parseInt(header.dataset.actId);
                    header.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('type', 'chapter');
                    e.stopPropagation(); // Empêcher le clic de se propager
                });

                dragHandle.addEventListener('dragend', (e) => {
                    header.classList.remove('dragging');
                    draggedChapter = { chapterId: null, actId: null };
                });

                header.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    
                    const targetChapterId = parseInt(e.currentTarget.dataset.chapterId);
                    const targetActId = parseInt(e.currentTarget.dataset.actId);
                    
                    if (draggedChapter.chapterId && draggedChapter.chapterId !== targetChapterId) {
                        e.currentTarget.classList.add('drag-over');
                    } else if (draggedScene.sceneId && draggedScene.chapterId !== targetChapterId) {
                        e.currentTarget.classList.add('drag-over');
                    }
                });

                header.addEventListener('dragleave', (e) => {
                    e.currentTarget.classList.remove('drag-over');
                });

                header.addEventListener('drop', (e) => {
                    e.preventDefault();
                    e.currentTarget.classList.remove('drag-over');
                    
                    const targetChapterId = parseInt(e.currentTarget.dataset.chapterId);
                    const targetActId = parseInt(e.currentTarget.dataset.actId);
                    
                    if (draggedChapter.chapterId && draggedChapter.chapterId !== targetChapterId) {
                        reorderChapters(draggedChapter.chapterId, draggedChapter.actId, targetChapterId, targetActId);
                    } else if (draggedScene.sceneId && draggedScene.chapterId !== targetChapterId) {
                        moveSceneToChapter(draggedScene.sceneId, draggedScene.actId, draggedScene.chapterId, targetActId, targetChapterId);
                    }
                });
            });
        }

        function reorderChapters(draggedChapterId, draggedActId, targetChapterId, targetActId) {
            const sourceAct = project.acts.find(a => a.id === draggedActId);
            const targetAct = project.acts.find(a => a.id === targetActId);
            
            if (!sourceAct || !targetAct) return;
            
            const draggedIndex = sourceAct.chapters.findIndex(c => c.id === draggedChapterId);
            const targetIndex = targetAct.chapters.findIndex(c => c.id === targetChapterId);
            
            if (draggedIndex === -1 || targetIndex === -1) return;
            
            const [removed] = sourceAct.chapters.splice(draggedIndex, 1);
            
            if (draggedActId === targetActId) {
                targetAct.chapters.splice(targetIndex, 0, removed);
            } else {
                targetAct.chapters.splice(targetIndex, 0, removed);
            }
            
            saveProject();
            renderActsList();
        }

        // Drag and Drop for Scenes
        let draggedScene = { sceneId: null, chapterId: null, actId: null };

        function setupSceneDragAndDrop() {
            const sceneItems = document.querySelectorAll('.scene-item.draggable');
            
            sceneItems.forEach(item => {
                item.addEventListener('dragstart', (e) => {
                    draggedScene.sceneId = parseInt(e.target.dataset.sceneId);
                    draggedScene.chapterId = parseInt(e.target.dataset.chapterId);
                    draggedScene.actId = parseInt(e.target.dataset.actId);
                    e.target.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                });

                item.addEventListener('dragend', (e) => {
                    e.target.classList.remove('dragging');
                    draggedScene = { sceneId: null, chapterId: null, actId: null };
                });

                item.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    
                    const targetSceneId = parseInt(e.currentTarget.dataset.sceneId);
                    const targetChapterId = parseInt(e.currentTarget.dataset.chapterId);
                    
                    if (draggedScene.sceneId && draggedScene.sceneId !== targetSceneId) {
                        e.currentTarget.classList.add('drag-over');
                    }
                });

                item.addEventListener('dragleave', (e) => {
                    e.currentTarget.classList.remove('drag-over');
                });

                item.addEventListener('drop', (e) => {
                    e.preventDefault();
                    e.currentTarget.classList.remove('drag-over');
                    
                    const targetSceneId = parseInt(e.currentTarget.dataset.sceneId);
                    const targetChapterId = parseInt(e.currentTarget.dataset.chapterId);
                    const targetActId = parseInt(e.currentTarget.dataset.actId);
                    
                    if (draggedScene.sceneId && draggedScene.sceneId !== targetSceneId) {
                        reorderScenes(
                            draggedScene.sceneId, 
                            draggedScene.actId,
                            draggedScene.chapterId,
                            targetSceneId,
                            targetActId,
                            targetChapterId
                        );
                    }
                });
            });
        }

        function reorderScenes(draggedSceneId, draggedActId, draggedChapterId, targetSceneId, targetActId, targetChapterId) {
            const sourceAct = project.acts.find(a => a.id === draggedActId);
            const targetAct = project.acts.find(a => a.id === targetActId);
            
            if (!sourceAct || !targetAct) return;
            
            const sourceChapter = sourceAct.chapters.find(c => c.id === draggedChapterId);
            const targetChapter = targetAct.chapters.find(c => c.id === targetChapterId);
            
            if (!sourceChapter || !targetChapter) return;
            
            const draggedIndex = sourceChapter.scenes.findIndex(s => s.id === draggedSceneId);
            const targetIndex = targetChapter.scenes.findIndex(s => s.id === targetSceneId);
            
            if (draggedIndex === -1 || targetIndex === -1) return;
            
            const [removed] = sourceChapter.scenes.splice(draggedIndex, 1);
            
            if (draggedChapterId === targetChapterId) {
                targetChapter.scenes.splice(targetIndex, 0, removed);
            } else {
                targetChapter.scenes.splice(targetIndex, 0, removed);
            }
            
            saveProject();
            renderActsList();
        }

        function moveSceneToChapter(sceneId, sourceActId, sourceChapterId, targetActId, targetChapterId) {
            const sourceAct = project.acts.find(a => a.id === sourceActId);
            const targetAct = project.acts.find(a => a.id === targetActId);
            
            if (!sourceAct || !targetAct) return;
            
            const sourceChapter = sourceAct.chapters.find(c => c.id === sourceChapterId);
            const targetChapter = targetAct.chapters.find(c => c.id === targetChapterId);
            
            if (!sourceChapter || !targetChapter) return;
            
            const sceneIndex = sourceChapter.scenes.findIndex(s => s.id === sceneId);
            if (sceneIndex === -1) return;
            
            const [removed] = sourceChapter.scenes.splice(sceneIndex, 1);
            targetChapter.scenes.push(removed);
            
            saveProject();
            renderActsList();
            
            // Auto-expand target chapter
            setTimeout(() => {
                const targetChapterElement = document.getElementById(`chapter-${targetChapterId}`);
                if (targetChapterElement) {
                    const icon = targetChapterElement.querySelector('.chapter-icon');
                    const scenesList = targetChapterElement.querySelector('.scenes-list');
                    if (!scenesList.classList.contains('visible')) {
                        icon.classList.add('expanded');
                        scenesList.classList.add('visible');
                    }
                }
            }, 100);
        }

        // View Management

        // Character Management
        function openAddCharacterModal() {
            document.getElementById('addCharacterModal').classList.add('active');
            setTimeout(() => document.getElementById('characterNameInput').focus(), 100);
        }

        function addCharacter() {
            const name = document.getElementById('characterNameInput').value.trim();
            const role = document.getElementById('characterRoleInput').value.trim();
            const description = document.getElementById('characterDescInput').value.trim();
            
            if (!name) return;

            const character = {
                id: Date.now(),
                // État civil
                firstName: name.split(' ')[0] || '',
                lastName: name.split(' ').slice(1).join(' ') || '',
                nickname: '',
                pronouns: '',
                sex: '',
                race: 'Humain',
                age: '',
                birthDate: '',
                birthPlace: '',
                residence: '',
                occupation: '',
                // Header
                name: name,
                role: role || '',
                roleImportance: 3, // 1-5 stars
                avatarEmoji: '👤',
                avatarImage: '',
                // Physique
                height: '',
                weight: '',
                bodyType: '',
                hairColor: '',
                eyeColor: '',
                voice: '',
                clothing: '',
                accessories: '',
                physicalDescription: description || '',
                // Caractère
                qualities: [], // tags array
                flaws: [], // tags array
                tastes: '',
                habits: '',
                fears: '',
                // Personnalité radar (0-20)
                personality: {
                    intelligence: 10,
                    force: 10,
                    robustesse: 10,
                    empathie: 10,
                    perception: 10,
                    agilite: 10,
                    sociabilite: 10
                },
                // Profil
                education: '',
                wealth: 50, // 0-100 slider
                secrets: '',
                beliefs: '',
                importantPlaces: '',
                catchphrases: '',
                // Évolution
                goals: '',
                past: '',
                present: '',
                future: '',
                // Inventaire & Possessions
                inventory: [], // [{id, name, quantity, description}]
                possessions: [], // [{id, name, quantity, description}]
                // Autres
                notes: '',
                // Legacy fields for compatibility
                appearance: '',
                background: '',
                relationships: '',
                linkedScenes: [],
                linkedElements: []
            };

            project.characters.push(character);
            
            // Clear inputs
            document.getElementById('characterNameInput').value = '';
            document.getElementById('characterRoleInput').value = '';
            document.getElementById('characterDescInput').value = '';
            
            closeModal('addCharacterModal');
            saveProject();
            renderCharactersList();
            
            // Open the new character detail
            openCharacterDetail(character.id);
        }

        function deleteCharacter(id) {
            if (!confirm('Êtes-vous sûr de vouloir supprimer ce personnage ?')) return;
            project.characters = project.characters.filter(c => c.id !== id);
            saveProject();
            renderCharactersList();
            showEmptyState();
        }

        function renderCharactersList() {
            const container = document.getElementById('charactersList');
            
            if (project.characters.length === 0) {
                container.innerHTML = '<div style="padding: 1rem; text-align: center; color: var(--text-muted); font-size: 0.85rem;">Aucun personnage</div>';
                return;
            }
            
            // Simple list without grouping - sorted alphabetically
            let html = '<div class="treeview-children" style="margin-left: 0; border-left: none; padding-left: 0;">';
            
            // Sort characters alphabetically by name
            const sortedCharacters = [...project.characters].sort((a, b) => {
                const nameA = (a.name || a.firstName || '').toLowerCase();
                const nameB = (b.name || b.firstName || '').toLowerCase();
                return nameA.localeCompare(nameB, 'fr');
            });
            
            sortedCharacters.forEach(char => {
                migrateCharacterData(char);
                const displayName = char.name || char.firstName || 'Sans nom';
                html += `
                    <div class="treeview-item" onclick="openCharacterDetail(${char.id})">
                        <span class="treeview-item-icon">${char.avatarEmoji || '👤'}</span>
                        <span class="treeview-item-label">${displayName}</span>
                        <button class="treeview-item-delete" onclick="event.stopPropagation(); deleteCharacter(${char.id})" title="Supprimer">×</button>
                    </div>
                `;
            });
            
            html += '</div>';
            container.innerHTML = html;
        }
        
        function toggleTreeviewGroup(groupKey) {
            const collapsedState = JSON.parse(localStorage.getItem('plume_treeview_collapsed') || '{}');
            collapsedState[groupKey] = !collapsedState[groupKey];
            localStorage.setItem('plume_treeview_collapsed', JSON.stringify(collapsedState));
            
            // Re-render the appropriate list
            if (groupKey.startsWith('chars_')) renderCharactersList();
            else if (groupKey.startsWith('world_')) renderWorldList();
            else if (groupKey.startsWith('codex_')) renderCodexList();
        }

        function renderCharacterLinkedScenes(character) {
            const scenes = findScenesWithCharacter(character.id);
            if (scenes.length === 0) return '';

            return `
                <div class="detail-section">
                    <div class="detail-section-title"><i data-lucide="file-text" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Apparaît dans ${scenes.length} scène(s)</div>
                    <div class="quick-links">
                        ${scenes.map(scene => {
                            const actIndex = project.acts.findIndex(a => a.id === scene.actId);
                            const act = project.acts[actIndex];
                            const chapterIndex = act.chapters.findIndex(c => c.id === scene.chapterId);
                            const actNumber = toRoman(actIndex + 1);
                            const chapterNumber = chapterIndex + 1;
                            const breadcrumb = `Acte ${actNumber} › Chapitre ${chapterNumber} › ${scene.sceneTitle}`;
                            
                            return `
                            <span class="link-badge" onclick="openScene(${scene.actId}, ${scene.chapterId}, ${scene.sceneId})" title="${scene.actTitle} - ${scene.chapterTitle}">
                                ${breadcrumb}
                            </span>
                        `;
                        }).join('')}
                    </div>
                </div>
            `;
        }

        function openCharacterDetail(id) {
            const character = project.characters.find(c => c.id === id);
            if (!character) return;
            
            // Ensure new fields exist for legacy characters
            migrateCharacterData(character);
            
            // Handle split view mode
            if (splitViewActive) {
                const state = splitActivePanel === 'left' ? splitViewState.left : splitViewState.right;
                if (state.view === 'characters') {
                    state.characterId = id;
                    renderSplitPanelViewContent(splitActivePanel);
                    saveSplitViewState();
                    return;
                }
            }

            const editorView = document.getElementById('editorView');
            editorView.innerHTML = renderCharacterSheet(character, false);
            
            // Initialize radar chart
            setTimeout(() => {
                initCharacterRadar(character);
                lucide.createIcons();
            }, 50);
        }
        
        function migrateCharacterData(char) {
            // Migrate legacy characters to new structure
            if (!char.firstName) char.firstName = char.name?.split(' ')[0] || '';
            if (!char.lastName) char.lastName = char.name?.split(' ').slice(1).join(' ') || '';
            if (!char.nickname) char.nickname = '';
            if (!char.pronouns) char.pronouns = '';
            if (!char.sex) char.sex = '';
            if (!char.race) char.race = 'Humain';
            if (!char.birthDate) char.birthDate = '';
            if (!char.birthPlace) char.birthPlace = '';
            if (!char.residence) char.residence = '';
            if (!char.occupation) char.occupation = '';
            if (!char.roleImportance) char.roleImportance = 3;
            if (!char.avatarEmoji) char.avatarEmoji = '👤';
            if (!char.avatarImage) char.avatarImage = '';
            if (!char.height) char.height = '';
            if (!char.weight) char.weight = '';
            if (!char.bodyType) char.bodyType = '';
            if (!char.hairColor) char.hairColor = '';
            if (!char.eyeColor) char.eyeColor = '';
            if (!char.voice) char.voice = '';
            if (!char.clothing) char.clothing = '';
            if (!char.accessories) char.accessories = '';
            if (!char.physicalDescription) char.physicalDescription = char.appearance || '';
            if (!char.qualities) char.qualities = [];
            if (!char.flaws) char.flaws = [];
            if (!char.tastes) char.tastes = '';
            if (!char.habits) char.habits = '';
            if (!char.fears) char.fears = '';
            if (!char.personality || typeof char.personality === 'string') {
                const oldPersonality = char.personality || '';
                char.personality = {
                    intelligence: 10,
                    force: 10,
                    robustesse: 10,
                    empathie: 10,
                    perception: 10,
                    agilite: 10,
                    sociabilite: 10
                };
                if (oldPersonality) char.notes = (char.notes || '') + '\n\nPersonnalité (ancien):\n' + oldPersonality;
            }
            if (!char.education) char.education = '';
            if (char.wealth === undefined) char.wealth = 50;
            if (!char.secrets) char.secrets = '';
            if (!char.beliefs) char.beliefs = '';
            if (!char.importantPlaces) char.importantPlaces = '';
            if (!char.catchphrases) char.catchphrases = '';
            if (!char.goals) char.goals = '';
            if (!char.past) char.past = char.background || '';
            if (!char.present) char.present = '';
            if (!char.future) char.future = '';
            if (!char.inventory) char.inventory = [];
            if (!char.possessions) char.possessions = [];
        }
        
        function renderCharacterSheet(character, compact = false) {
            const metaInfo = [];
            if (character.age) metaInfo.push(`${character.age}${character.birthPlace ? ', né à ' + character.birthPlace : ''}`);
            if (character.residence) metaInfo.push(character.residence);
            
            return `
                <div class="character-sheet" data-character-id="${character.id}">
                    <!-- Header -->
                    <div class="character-sheet-header">
                        <div class="character-avatar" onclick="changeCharacterAvatar(${character.id})" title="Changer l'avatar">
                            ${character.avatarImage 
                                ? `<img src="${character.avatarImage}" alt="${character.name}">` 
                                : character.avatarEmoji || '👤'}
                        </div>
                        <div class="character-header-info">
                            <h2 contenteditable="true" onblur="updateCharacterName(${character.id}, this.textContent)">${character.firstName}${character.lastName ? ' ' + character.lastName : ''}</h2>
                            <ul class="character-meta">
                                ${metaInfo.map(m => `<li>${m}</li>`).join('')}
                            </ul>
                        </div>
                        <button class="character-close-btn" onclick="switchView('editor')" title="Fermer">×</button>
                    </div>
                    
                    <!-- Grille des sections -->
                    <div class="character-sections-grid">
                    
                    <!-- État Civil -->
                    <div class="character-section" id="section-etat-civil">
                        <div class="character-section-header" onclick="toggleCharacterSection('etat-civil')">
                            <div class="character-section-title">État Civil</div>
                            <span class="character-section-toggle">▼</span>
                        </div>
                        <div class="character-section-content">
                            <div class="character-field-row">
                                <div class="character-field">
                                    <label class="character-field-label">Prénom</label>
                                    <input type="text" value="${character.firstName || ''}" 
                                           onchange="updateCharacterField(${character.id}, 'firstName', this.value); updateCharacterDisplayName(${character.id})">
                                </div>
                                <div class="character-field">
                                    <label class="character-field-label">Nom de famille</label>
                                    <input type="text" value="${character.lastName || ''}" 
                                           onchange="updateCharacterField(${character.id}, 'lastName', this.value); updateCharacterDisplayName(${character.id})">
                                </div>
                            </div>
                            <div class="character-field-row">
                                <div class="character-field">
                                    <label class="character-field-label">Surnom</label>
                                    <input type="text" value="${character.nickname || ''}" 
                                           onchange="updateCharacterField(${character.id}, 'nickname', this.value)">
                                </div>
                                <div class="character-field">
                                    <label class="character-field-label">Pronoms</label>
                                    <input type="text" value="${character.pronouns || ''}" placeholder="il/lui, elle/elle, iel..."
                                           onchange="updateCharacterField(${character.id}, 'pronouns', this.value)">
                                </div>
                            </div>
                            <div class="character-field-row">
                                <div class="character-field">
                                    <label class="character-field-label">Sexe</label>
                                    <div class="character-radio-group">
                                        <label><input type="radio" name="sex-${character.id}" value="F" ${character.sex === 'F' ? 'checked' : ''} onchange="updateCharacterField(${character.id}, 'sex', 'F')"> Femme</label>
                                        <label><input type="radio" name="sex-${character.id}" value="M" ${character.sex === 'M' ? 'checked' : ''} onchange="updateCharacterField(${character.id}, 'sex', 'M')"> Homme</label>
                                        <label><input type="radio" name="sex-${character.id}" value="A" ${character.sex === 'A' ? 'checked' : ''} onchange="updateCharacterField(${character.id}, 'sex', 'A')"> Autre</label>
                                    </div>
                                </div>
                                <div class="character-field">
                                    <label class="character-field-label">Race</label>
                                    <input type="text" value="${character.race || 'Humain'}" 
                                           onchange="updateCharacterField(${character.id}, 'race', this.value)">
                                </div>
                            </div>
                            <div class="character-field-row">
                                <div class="character-field" style="max-width: 100px;">
                                    <label class="character-field-label">Âge</label>
                                    <input type="text" value="${character.age || ''}" 
                                           onchange="updateCharacterField(${character.id}, 'age', this.value)">
                                </div>
                                <div class="character-field">
                                    <label class="character-field-label">Date de naissance</label>
                                    <input type="text" value="${character.birthDate || ''}" placeholder="JJ/MM/AAAA"
                                           onchange="updateCharacterField(${character.id}, 'birthDate', this.value)">
                                </div>
                                <div class="character-field">
                                    <label class="character-field-label">Lieu de naissance</label>
                                    <input type="text" value="${character.birthPlace || ''}" 
                                           onchange="updateCharacterField(${character.id}, 'birthPlace', this.value)">
                                </div>
                            </div>
                            <div class="character-field-row">
                                <div class="character-field">
                                    <label class="character-field-label">Lieu de résidence</label>
                                    <input type="text" value="${character.residence || ''}" 
                                           onchange="updateCharacterField(${character.id}, 'residence', this.value)">
                                </div>
                                <div class="character-field">
                                    <label class="character-field-label">Occupation</label>
                                    <input type="text" value="${character.occupation || ''}" 
                                           onchange="updateCharacterField(${character.id}, 'occupation', this.value)">
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Physique -->
                    <div class="character-section" id="section-physique">
                        <div class="character-section-header" onclick="toggleCharacterSection('physique')">
                            <div class="character-section-title">Physique</div>
                            <span class="character-section-toggle">▼</span>
                        </div>
                        <div class="character-section-content">
                            <div class="character-field-row">
                                <div class="character-field">
                                    <label class="character-field-label">Taille</label>
                                    <input type="text" value="${character.height || ''}" placeholder="cm"
                                           onchange="updateCharacterField(${character.id}, 'height', this.value)">
                                </div>
                                <div class="character-field">
                                    <label class="character-field-label">Poids</label>
                                    <input type="text" value="${character.weight || ''}" placeholder="kg"
                                           onchange="updateCharacterField(${character.id}, 'weight', this.value)">
                                </div>
                                <div class="character-field">
                                    <label class="character-field-label">Corpulence</label>
                                    <input type="text" value="${character.bodyType || ''}" 
                                           onchange="updateCharacterField(${character.id}, 'bodyType', this.value)">
                                </div>
                            </div>
                            <div class="character-field-row">
                                <div class="character-field">
                                    <label class="character-field-label">Couleur des cheveux</label>
                                    <input type="text" value="${character.hairColor || ''}" 
                                           onchange="updateCharacterField(${character.id}, 'hairColor', this.value)">
                                </div>
                                <div class="character-field">
                                    <label class="character-field-label">Couleur des yeux</label>
                                    <input type="text" value="${character.eyeColor || ''}" 
                                           onchange="updateCharacterField(${character.id}, 'eyeColor', this.value)">
                                </div>
                                <div class="character-field">
                                    <label class="character-field-label">Voix / Manière de parler</label>
                                    <input type="text" value="${character.voice || ''}" 
                                           onchange="updateCharacterField(${character.id}, 'voice', this.value)">
                                </div>
                            </div>
                            <div class="character-field-row">
                                <div class="character-field">
                                    <label class="character-field-label">Tenue</label>
                                    <textarea rows="3" onchange="updateCharacterField(${character.id}, 'clothing', this.value)">${character.clothing || ''}</textarea>
                                </div>
                                <div class="character-field">
                                    <label class="character-field-label">Accessoires</label>
                                    <textarea rows="3" onchange="updateCharacterField(${character.id}, 'accessories', this.value)">${character.accessories || ''}</textarea>
                                </div>
                            </div>
                            <div class="character-field">
                                <label class="character-field-label">Description</label>
                                <textarea rows="4" onchange="updateCharacterField(${character.id}, 'physicalDescription', this.value)">${character.physicalDescription || ''}</textarea>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Caractère - Full width car contient beaucoup de catégories -->
                    <div class="character-section full-width" id="section-caractere">
                        <div class="character-section-header" onclick="toggleCharacterSection('caractere')">
                            <div class="character-section-title">Traits de Caractère</div>
                            <span class="character-section-toggle">▼</span>
                        </div>
                        <div class="character-section-content">
                            <!-- Traits sélectionnés -->
                            <div class="character-field">
                                <label class="character-field-label">Traits sélectionnés</label>
                                <div class="selected-traits-container" id="selectedTraits-${character.id}">
                                    ${(character.traits || []).map((t, i) => `
                                        <span class="selected-trait">${t}<span class="trait-remove" onclick="removeCharacterTrait(${character.id}, ${i})">×</span></span>
                                    `).join('') || '<span class="no-traits">Cliquez sur les traits ci-dessous pour les ajouter</span>'}
                                </div>
                            </div>
                            
                            <!-- Catégories de traits -->
                            <div class="traits-categories">
                                ${renderTraitsCategories(character.id, character.traits || [])}
                            </div>
                            
                            <!-- Champs texte conservés -->
                            <div class="character-field" style="margin-top: 1rem;">
                                <label class="character-field-label">Goûts</label>
                                <textarea rows="2" onchange="updateCharacterField(${character.id}, 'tastes', this.value)">${character.tastes || ''}</textarea>
                            </div>
                            <div class="character-field">
                                <label class="character-field-label">Tics, manies, habitudes</label>
                                <textarea rows="2" onchange="updateCharacterField(${character.id}, 'habits', this.value)">${character.habits || ''}</textarea>
                            </div>
                            <div class="character-field">
                                <label class="character-field-label">Peurs et doutes</label>
                                <textarea rows="2" onchange="updateCharacterField(${character.id}, 'fears', this.value)">${character.fears || ''}</textarea>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Profil -->
                    <div class="character-section" id="section-profil">
                        <div class="character-section-header" onclick="toggleCharacterSection('profil')">
                            <div class="character-section-title">Profil</div>
                            <span class="character-section-toggle">▼</span>
                        </div>
                        <div class="character-section-content">
                            <div class="character-field">
                                <label class="character-field-label">Éducation</label>
                                <textarea rows="3" onchange="updateCharacterField(${character.id}, 'education', this.value)">${character.education || ''}</textarea>
                            </div>
                            <div class="character-field">
                                <label class="character-field-label">Secrets</label>
                                <textarea rows="3" onchange="updateCharacterField(${character.id}, 'secrets', this.value)">${character.secrets || ''}</textarea>
                            </div>
                            <div class="character-field">
                                <label class="character-field-label">Croyances et idéologies</label>
                                <textarea rows="2" onchange="updateCharacterField(${character.id}, 'beliefs', this.value)">${character.beliefs || ''}</textarea>
                            </div>
                            <div class="character-field-row">
                                <div class="character-field">
                                    <label class="character-field-label">Lieux marquants</label>
                                    <input type="text" value="${character.importantPlaces || ''}" 
                                           onchange="updateCharacterField(${character.id}, 'importantPlaces', this.value)">
                                </div>
                                <div class="character-field">
                                    <label class="character-field-label">Phrases ou expressions typiques</label>
                                    <textarea rows="3" onchange="updateCharacterField(${character.id}, 'catchphrases', this.value)">${character.catchphrases || ''}</textarea>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Évolution - Full width car contient la timeline -->
                    <div class="character-section full-width" id="section-evolution">
                        <div class="character-section-header" onclick="toggleCharacterSection('evolution')">
                            <div class="character-section-title">Évolution</div>
                            <span class="character-section-toggle">▼</span>
                        </div>
                        <div class="character-section-content">
                            <div class="character-field">
                                <label class="character-field-label">Buts / Objectifs</label>
                                <textarea rows="3" onchange="updateCharacterField(${character.id}, 'goals', this.value)">${character.goals || ''}</textarea>
                            </div>
                            <div class="character-timeline">
                                <div class="timeline-card">
                                    <div class="timeline-card-title">Passé</div>
                                    <textarea placeholder="Le personnage avant le début de l'histoire (enfance, souffrances potentielles...)." 
                                              onchange="updateCharacterField(${character.id}, 'past', this.value)">${character.past || ''}</textarea>
                                </div>
                                <div class="timeline-card">
                                    <div class="timeline-card-title">Présent</div>
                                    <textarea placeholder="Le personnage au commencement de l'histoire." 
                                              onchange="updateCharacterField(${character.id}, 'present', this.value)">${character.present || ''}</textarea>
                                </div>
                                <div class="timeline-card">
                                    <div class="timeline-card-title">Futur</div>
                                    <textarea placeholder="Le personnage à la fin de l'histoire." 
                                              onchange="updateCharacterField(${character.id}, 'future', this.value)">${character.future || ''}</textarea>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Inventaire -->
                    <div class="character-section" id="section-inventaire">
                        <div class="character-section-header" onclick="toggleCharacterSection('inventaire')">
                            <div class="character-section-title">Inventaire</div>
                            <span class="character-section-toggle">▼</span>
                        </div>
                        <div class="character-section-content">
                            <div id="inventory-list-${character.id}">
                                ${(character.inventory || []).map((item, i) => renderInventoryItem(character.id, 'inventory', item, i)).join('')}
                            </div>
                            <button class="inventory-add-btn" onclick="addInventoryItem(${character.id}, 'inventory')">
                                Ajouter <i data-lucide="plus-circle" style="width:16px;height:16px;"></i>
                            </button>
                        </div>
                    </div>
                    
                    <!-- Autres -->
                    <div class="character-section" id="section-autres">
                        <div class="character-section-header" onclick="toggleCharacterSection('autres')">
                            <div class="character-section-title">Autres</div>
                            <span class="character-section-toggle">▼</span>
                        </div>
                        <div class="character-section-content">
                            <div class="character-field">
                                <textarea rows="5" placeholder="Notes diverses..." 
                                          onchange="updateCharacterField(${character.id}, 'notes', this.value)">${character.notes || ''}</textarea>
                            </div>
                        </div>
                    </div>
                    
                    </div><!-- Fin de character-sections-grid -->
                    
                    ${renderCharacterLinkedScenes(character)}
                </div>
            `;
        }
        
        function renderInventoryItem(charId, listType, item, index) {
            return `
                <div class="inventory-item" data-index="${index}">
                    <button class="inventory-item-delete" onclick="removeInventoryItem(${charId}, '${listType}', ${index})">
                        <i data-lucide="trash-2" style="width:14px;height:14px;"></i>
                    </button>
                    <div class="character-field-row">
                        <div class="character-field" style="flex: 2;">
                            <label class="character-field-label">Nom</label>
                            <input type="text" value="${item.name || ''}" 
                                   onchange="updateInventoryItem(${charId}, '${listType}', ${index}, 'name', this.value)">
                        </div>
                        <div class="character-field" style="max-width: 100px;">
                            <label class="character-field-label">Quantité</label>
                            <input type="number" value="${item.quantity || 1}" min="1"
                                   onchange="updateInventoryItem(${charId}, '${listType}', ${index}, 'quantity', parseInt(this.value))">
                        </div>
                    </div>
                    <div class="character-field">
                        <label class="character-field-label">Description</label>
                        <input type="text" value="${item.description || ''}" 
                               onchange="updateInventoryItem(${charId}, '${listType}', ${index}, 'description', this.value)">
                    </div>
                </div>
            `;
        }
        
        function toggleCharacterSection(sectionName) {
            const section = document.getElementById(`section-${sectionName}`);
            if (section) {
                section.classList.toggle('collapsed');
            }
        }
        
        function updateCharacterName(id, newName) {
            const character = project.characters.find(c => c.id === id);
            if (character) {
                const parts = newName.trim().split(' ');
                character.firstName = parts[0] || '';
                character.lastName = parts.slice(1).join(' ') || '';
                character.name = newName.trim();
                saveProject();
                renderCharactersList();
            }
        }
        
        function updateCharacterDisplayName(id) {
            const character = project.characters.find(c => c.id === id);
            if (character) {
                character.name = `${character.firstName || ''} ${character.lastName || ''}`.trim();
                saveProject();
                renderCharactersList();
            }
        }
        
        function handleTagInput(event, charId, field) {
            if (event.key === 'Enter' && event.target.value.trim()) {
                event.preventDefault();
                const character = project.characters.find(c => c.id === charId);
                if (character) {
                    if (!character[field]) character[field] = [];
                    character[field].push(event.target.value.trim());
                    event.target.value = '';
                    saveProject();
                    // Refresh tags display
                    const container = document.getElementById(`${field}-${charId}`);
                    if (container) {
                        const input = container.querySelector('input');
                        container.innerHTML = character[field].map((tag, i) => `
                            <span class="character-tag">${tag}<span class="character-tag-remove" onclick="removeCharacterTag(${charId}, '${field}', ${i})">×</span></span>
                        `).join('') + `<input type="text" class="character-tags-input" placeholder="Ajouter..." onkeydown="handleTagInput(event, ${charId}, '${field}')">`;
                    }
                }
            }
        }
        
        function removeCharacterTag(charId, field, index) {
            const character = project.characters.find(c => c.id === charId);
            if (character && character[field]) {
                character[field].splice(index, 1);
                saveProject();
                openCharacterDetail(charId);
            }
        }
        
        // Système de traits de caractère
        const TRAIT_SECTIONS = {
            'emotional': {
                icon: '💖',
                label: 'Aspect Émotionnel',
                categories: {
                    'adversity': { icon: '🛡️', label: 'Réaction face à l\'adversité', traits: ['Résilient', 'Fragile', 'Agressif', 'Évasif', 'Persévérant', 'Courageux'] },
                    'information': { icon: '🧠', label: 'Traitement de l\'information', traits: ['Analytique', 'Intuitif', 'Réfléchi', 'Impulsif', 'Distrait'] },
                    'emotions': { icon: '❤️', label: 'Gestion des émotions', traits: ['Expressif', 'Réservé', 'Explosif', 'Équilibré', 'Empathique', 'Apathique', 'Passionné', 'Téméraire'] },
                    'motivations': { icon: '🚀', label: 'Motivations principales', traits: ['Ambition', 'Curiosité', 'Besoin de sécurité', 'Besoin d\'approbation', 'Quête de sens'] },
                    'social': { icon: '🤝', label: 'Interactions sociales', traits: ['Leader', 'Suiveur', 'Confiant', 'Timide', 'Solitaire', 'Mystérieux', 'Médiateur', 'Manipulateur', 'Pédagogue'] },
                    'change': { icon: '🔄', label: 'Gestion du changement', traits: ['Adaptatif', 'Résistant', 'Enthousiaste', 'Craintif', 'Indécis'] },
                    'self': { icon: '🪞', label: 'Vision de soi', traits: ['Confiant', 'Insécure', 'Narcissique', 'Humble', 'Critique'] },
                    'intimacy': { icon: '💕', label: 'Rapport à l\'intimité', traits: ['Prude', 'Pudique', 'Romantique', 'Discret', 'Réservé', 'Ouvert', 'Extraverti'] },
                    'sexuality': { icon: '🔥', label: 'Rapport à la sexualité', traits: ['Sensuel', 'Chaste', 'Timide', 'Décomplexé', 'Romantique', 'Passionné', 'Libertin', 'Asexuel'] },
                    'pain': { icon: '💢', label: 'Rapport à la douleur', traits: ['Sadique', 'Masochiste', 'Stoïque', 'Sensible', 'Endurant', 'Douillet', 'Vulnérable'] },
                    'time': { icon: '⏳', label: 'Rapport au temps', traits: ['Nostalgique', 'Tourné vers l\'avenir', 'Carpe Diem', 'Cynique', 'Patient', 'Impatient'] }
                }
            },
            'evolution': {
                icon: '🌱',
                label: 'Évolution Personnelle',
                categories: {
                    'initial': { icon: '🌱', label: 'État initial', traits: ['Innocent', 'Naïf', 'Ferme dans ses convictions', 'Curieux', 'Méfiant', 'Mystérieux', 'Téméraire'] },
                    'learning': { icon: '📚', label: 'Approche face à l\'apprentissage', traits: ['Autodidacte', 'Chercheur de mentors', 'Expérimentateur', 'Sceptique', 'Réfractaire au changement'] },
                    'failure': { icon: '💔', label: 'Gestion des échecs', traits: ['Persévérant', 'Résilient', 'Facilement découragé', 'Fuyant', 'Auto-compassion', 'Revanchard', 'Défaitiste'] },
                    'quest': { icon: '🗺️', label: 'Quête personnelle', traits: ['Chercheur d\'identité', 'Chercheur de vérité', 'Chercheur de sensations', 'Chercheur d\'équilibre', 'Chercheur de pouvoir'] },
                    'adaptability': { icon: '🦋', label: 'Adaptabilité à l\'évolution', traits: ['Flexible', 'Rigide', 'Conservateur', 'Caméléon'] },
                    'world': { icon: '🌍', label: 'Interaction avec le monde', traits: ['Explorateur', 'Protecteur', 'Observateur', 'Pionnier', 'Réformateur'] },
                    'relationships': { icon: '💞', label: 'Gestion des relations', traits: ['Loyal', 'Solidaire', 'Indépendant', 'Codépendant'] },
                    'death': { icon: '💀', label: 'Rapport à la mort', traits: ['Stoïque', 'Anxieux', 'Fataliste', 'Spirituel', 'Déni'] }
                }
            },
            'daily': {
                icon: '🌞',
                label: 'Au Quotidien',
                categories: {
                    'order': { icon: '📁', label: 'Organisation et ordre', traits: ['Désordonné', 'Méticuleux', 'Négligent', 'Soigneux'] },
                    'appearance': { icon: '👔', label: 'Apparence et style', traits: ['Coquet', 'Négligé', 'Élégant', 'Décontracté', 'Mystérieux', 'Inspirant'] },
                    'physical': { icon: '💪', label: 'Habileté physique', traits: ['Adroit', 'Maladroit', 'Agile', 'Fort', 'Fragile', 'Précis', 'Souple'] },
                    'timeManagement': { icon: '⏰', label: 'Gestion du temps', traits: ['Ponctuel', 'Retardataire', 'Organisé', 'Procrastinateur'] }
                }
            },
            'others': {
                icon: '👥',
                label: 'Rapport aux Autres',
                categories: {
                    'norms': { icon: '⛩️', label: 'Réponse aux normes culturelles', traits: ['Conformiste', 'Rebelle', 'Innovateur', 'Traditionaliste', 'Indifférent'] },
                    'group': { icon: '👥', label: 'Rapport au groupe', traits: ['Leader', 'Suiveur', 'Autoritaire', 'Solitaire', 'Médiateur', 'Esprit de contradiction'] },
                    'maturity': { icon: '🧒', label: 'Maturité émotionnelle', traits: ['Candide', 'Immature', 'Mature', 'Naïf', 'Sage'] },
                    'communication': { icon: '💬', label: 'Communication', traits: ['Expressif', 'Réservé', 'Enthousiaste', 'Observateur', 'Provocateur', 'Éloquent', 'Persuasif', 'À l\'écoute', 'Franc'] },
                    'diversity': { icon: '🌈', label: 'Réaction à la diversité', traits: ['Tolérant', 'Intolérant', 'Curieux', 'Ignorant', 'Ambivalent'] },
                    'pressure': { icon: '🌪️', label: 'Gestion de la pression sociale', traits: ['Influençable', 'Résistant', 'Indécis', 'Évitant'] },
                    'identity': { icon: '🎭', label: 'Quête d\'identité sociale', traits: ['Cherche l\'appartenance', 'Caméléon social', 'Loup solitaire', 'Conformiste', 'Cosmopolite'] },
                    'success': { icon: '⭐', label: 'Vision de la réussite', traits: ['Ambitieux', 'Minimaliste', 'Opportuniste', 'Idéaliste', 'Pessimiste'] },
                    'institutions': { icon: '🏛️', label: 'Interactions avec les institutions', traits: ['Respectueux', 'Critique', 'Manipulateur', 'Défenseur', 'Détaché'] }
                }
            },
            'age': {
                icon: '👴',
                label: 'Personnalité selon l\'Âge',
                categories: {
                    'childhood': { icon: '👶', label: 'Enfance et adolescence', traits: ['Curieux', 'Rebelle', 'Suiveur', 'Protecteur', 'Rêveur'] },
                    'youngAdult': { icon: '🎓', label: 'Jeunes adultes', traits: ['Ambitieux', 'Aventurier', 'Stable', 'Introspectif', 'Social', 'Téméraire'] },
                    'midLife': { icon: '🏠', label: 'Milieu de vie', traits: ['Responsable', 'Pédagogue', 'Entrepreneur', 'Nostalgique', 'Philanthrope', 'Mentor', 'Sage', 'Expérimenté', 'Accompli'] },
                    'mature': { icon: '🍂', label: 'Âge mûr', traits: ['Sage', 'Conservateur', 'Libéré', 'Prudent', 'Gardien de la tradition'] },
                    'generations': { icon: '👨‍👩‍👧', label: 'Interactions entre générations', traits: ['Respectueux', 'Aime les défier', 'Guide', 'Élève', 'Indifférent'] }
                }
            },
            'moral': {
                icon: '⚖️',
                label: 'La Morale',
                categories: {
                    'virtues': { icon: '✨', label: 'Vertus', traits: ['Courageux', 'Juste', 'Sage', 'Tempéré', 'Tolérant', 'Intègre', 'Honnête', 'Loyal', 'Compatissant', 'Bienveillant', 'Sincère', 'Désintéressé', 'Responsable'] },
                    'neutral': { icon: '⚖️', label: 'Traits neutres', traits: ['Modéré', 'Prudent', 'Réfléchi', 'Objectif', 'Réaliste', 'Modeste', 'Patient'] },
                    'ambiguous': { icon: '🎲', label: 'Ambiguïté morale', traits: ['Astucieux', 'Manipulateur', 'Séducteur', 'Rusé', 'Stratège', 'Entêté'] },
                    'minorVices': { icon: '😈', label: 'Vices mineurs', traits: ['Paresseux', 'Égoïste', 'Impulsif', 'Moqueur', 'Malhonnête', 'Hypocrite', 'Lâche', 'Cupide', 'Envieux'] },
                    'majorVices': { icon: '👿', label: 'Vices majeurs', traits: ['Cruel', 'Tyrannique', 'Malveillant', 'Traître', 'Violent', 'Sadique'] },
                    'redemption': { icon: '🌅', label: 'Traits rédempteurs', traits: ['Repentant', 'Humble', 'Reconnaissant', 'Miséricordieux', 'Compatissant'] },
                    'moralApproach': { icon: '🧭', label: 'Approche de la moralité', traits: ['Amoral', 'Nihiliste', 'Utilitariste', 'Paragon de vertu'] },
                    'values': { icon: '💎', label: 'Principes et valeurs', traits: ['Conformiste', 'Conventionnel', 'Éthique', 'Honnête', 'Idéaliste', 'Incorruptible', 'Intransigeant', 'Non-conformiste', 'Pragmatique', 'Rebelle', 'Respectueux', 'Révolutionnaire', 'Traditionnel', 'Transgressif'] }
                }
            },
            'past': {
                icon: '📜',
                label: 'En Fonction du Passé',
                categories: {
                    'privileged': { icon: '👑', label: 'Enfance privilégiée', traits: ['Confiant', 'Naïf', 'Entreprenant', 'Éduqué'] },
                    'trauma': { icon: '⛈️', label: 'Traumatismes passés', traits: ['Méfiant', 'Résilient', 'Tourmenté', 'Secret', 'Vigilant', 'Mystérieux'] },
                    'hardship': { icon: '🔥', label: 'Enfance dans l\'adversité', traits: ['Combattif', 'Ingénieux', 'Méfiant', 'Endurci', 'Tenace'] },
                    'nomad': { icon: '🎒', label: 'Passé nomade', traits: ['S\'adapte facilement', 'Curieux', 'Indépendant', 'Nomade', 'Polyglotte'] },
                    'educated': { icon: '🎓', label: 'Éducation formelle', traits: ['Analytique', 'Érudit', 'Précis', 'Structuré', 'Sceptique'] },
                    'artist': { icon: '🎨', label: 'Passé d\'artiste', traits: ['Imaginatif', 'Sensible', 'Non-conformiste', 'Passionné', 'Perfectionniste'] },
                    'delinquent': { icon: '🚫', label: 'Ancien délinquant', traits: ['Rusé', 'Secret', 'Rebelle', 'Débrouillard', 'Insoumis'] },
                    'noble': { icon: '🏰', label: 'Origines nobles', traits: ['Digne', 'Autoritaire', 'Élitiste', 'Gracieux', 'Maniéré', 'Conservateur'] }
                }
            },
            'elements': {
                icon: '🌿',
                label: 'Éléments Naturels',
                categories: {
                    'earth': { icon: '⛰️', label: 'Terre', traits: ['Ancré', 'Résistant', 'Patient', 'Pratique', 'Loyal'] },
                    'water': { icon: '🌊', label: 'Eau', traits: ['Sensible', 'Profond', 'Réfléchi', 'Adaptable', 'Empathique'] },
                    'fire': { icon: '🔥', label: 'Feu', traits: ['Enthousiaste', 'Colérique', 'Charismatique', 'Audacieux', 'Créatif', 'Impulsif'] },
                    'air': { icon: '💨', label: 'Air', traits: ['Analytique', 'Expressif', 'Léger', 'Intuitif', 'Curieux'] },
                    'metal': { icon: '⚔️', label: 'Métal', traits: ['Organisé', 'Tenace', 'Réfléchi', 'Précis', 'Discipliné'] },
                    'wood': { icon: '🌲', label: 'Bois', traits: ['Innovateur', 'Visionnaire', 'Ambitieux', 'Flexible', 'Énergique'] },
                    'space': { icon: '🌌', label: 'Espace', traits: ['Indépendant', 'Mystérieux', 'Rêveur', 'Explorateur', 'Contemplatif'] },
                    'light': { icon: '☀️', label: 'Lumière', traits: ['Lumineux', 'Optimiste', 'Inspirant', 'Chaleureux', 'Rayonnant', 'Bienveillant', 'Leader'] }
                }
            }
        };
        
        function renderTraitsCategories(charId, selectedTraits) {
            return Object.entries(TRAIT_SECTIONS).map(([sectionKey, section]) => `
                <div class="trait-section" id="trait-section-${sectionKey}">
                    <div class="trait-section-header" onclick="toggleTraitSection('${sectionKey}')">
                        <span><span class="trait-section-icon">${section.icon}</span>${section.label}</span>
                        <span class="trait-section-toggle">▼</span>
                    </div>
                    <div class="trait-section-content">
                        ${Object.entries(section.categories).map(([catKey, category]) => `
                            <div class="trait-category" id="trait-cat-${sectionKey}-${catKey}">
                                <div class="trait-category-header">
                                    <span><span class="trait-category-icon">${category.icon}</span>${category.label}</span>
                                </div>
                                <div class="trait-category-content">
                                    ${category.traits.map(trait => `
                                        <span class="trait-option ${selectedTraits.includes(trait) ? 'selected' : ''}" 
                                              onclick="event.stopPropagation(); toggleCharacterTrait(${charId}, '${trait.replace(/'/g, "\\'")}')">${trait}</span>
                                    `).join('')}
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `).join('');
        }
        
        function toggleTraitSection(sectionKey) {
            const section = document.getElementById(`trait-section-${sectionKey}`);
            if (section) {
                section.classList.toggle('collapsed');
            }
        }
        
        function toggleCharacterTrait(charId, trait) {
            const character = project.characters.find(c => c.id === charId);
            if (!character) return;
            
            if (!character.traits) character.traits = [];
            
            const index = character.traits.indexOf(trait);
            if (index > -1) {
                // Retirer le trait
                character.traits.splice(index, 1);
            } else {
                // Ajouter le trait
                character.traits.push(trait);
            }
            
            saveProject();
            refreshTraitsDisplay(charId);
        }
        
        function removeCharacterTrait(charId, index) {
            const character = project.characters.find(c => c.id === charId);
            if (!character || !character.traits) return;
            
            character.traits.splice(index, 1);
            saveProject();
            refreshTraitsDisplay(charId);
        }
        
        function refreshTraitsDisplay(charId) {
            const character = project.characters.find(c => c.id === charId);
            if (!character) return;
            
            const traits = character.traits || [];
            
            // Mettre à jour la zone des traits sélectionnés
            const selectedContainer = document.getElementById(`selectedTraits-${charId}`);
            if (selectedContainer) {
                selectedContainer.innerHTML = traits.length > 0 
                    ? traits.map((t, i) => `
                        <span class="selected-trait">${t}<span class="trait-remove" onclick="removeCharacterTrait(${charId}, ${i})">×</span></span>
                    `).join('')
                    : '<span class="no-traits">Cliquez sur les traits ci-dessous pour les ajouter</span>';
            }
            
            // Mettre à jour les options dans les catégories
            document.querySelectorAll('.trait-option').forEach(option => {
                const traitName = option.textContent;
                if (traits.includes(traitName)) {
                    option.classList.add('selected');
                } else {
                    option.classList.remove('selected');
                }
            });
        }
        
        function updatePersonalityStat(charId, stat, value) {
            const character = project.characters.find(c => c.id === charId);
            if (character && character.personality) {
                character.personality[stat] = parseInt(value);
                saveProject();
                // Update display
                const control = event.target.parentElement;
                const valueSpan = control.querySelector('.radar-value');
                if (valueSpan) valueSpan.textContent = value;
                // Redraw radar
                initCharacterRadar(character);
            }
        }
        
        function initCharacterRadar(character) {
            const canvas = document.getElementById(`radarChart-${character.id}`);
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = Math.min(centerX, centerY) - 50;
            
            const stats = character.personality;
            const labels = ['Intelligence', 'Force', 'Robustesse', 'Empathie', 'Perception', 'Agilité', 'Sociabilité'];
            const values = [stats.intelligence, stats.force, stats.robustesse, stats.empathie, stats.perception, stats.agilite, stats.sociabilite];
            const numPoints = labels.length;
            const angleStep = (Math.PI * 2) / numPoints;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid circles
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            for (let i = 1; i <= 4; i++) {
                ctx.beginPath();
                const gridRadius = (radius / 4) * i;
                for (let j = 0; j <= numPoints; j++) {
                    const angle = (angleStep * j) - Math.PI / 2;
                    const x = centerX + Math.cos(angle) * gridRadius;
                    const y = centerY + Math.sin(angle) * gridRadius;
                    if (j === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.stroke();
            }
            
            // Draw axes
            ctx.strokeStyle = '#ccc';
            for (let i = 0; i < numPoints; i++) {
                const angle = (angleStep * i) - Math.PI / 2;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(centerX + Math.cos(angle) * radius, centerY + Math.sin(angle) * radius);
                ctx.stroke();
            }
            
            // Draw data polygon
            ctx.fillStyle = 'rgba(100, 100, 120, 0.5)';
            ctx.strokeStyle = 'var(--primary-color)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let i = 0; i < numPoints; i++) {
                const angle = (angleStep * i) - Math.PI / 2;
                const value = values[i] / 20; // Normalize to 0-1
                const x = centerX + Math.cos(angle) * radius * value;
                const y = centerY + Math.sin(angle) * radius * value;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // Draw data points
            ctx.fillStyle = 'var(--primary-color)';
            for (let i = 0; i < numPoints; i++) {
                const angle = (angleStep * i) - Math.PI / 2;
                const value = values[i] / 20;
                const x = centerX + Math.cos(angle) * radius * value;
                const y = centerY + Math.sin(angle) * radius * value;
                ctx.beginPath();
                ctx.arc(x, y, 5, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Draw labels
            ctx.fillStyle = 'var(--text-secondary)';
            ctx.font = '12px "Crimson Pro", serif';
            ctx.textAlign = 'center';
            for (let i = 0; i < numPoints; i++) {
                const angle = (angleStep * i) - Math.PI / 2;
                const labelRadius = radius + 30;
                const x = centerX + Math.cos(angle) * labelRadius;
                const y = centerY + Math.sin(angle) * labelRadius;
                
                // Draw value in brackets
                const displayValue = values[i] === 20 ? '[MAX]' : `[${values[i]}]`;
                ctx.fillText(`${displayValue} ${labels[i]}`, x, y);
            }
            
            // Draw center cross
            ctx.strokeStyle = '#999';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(centerX - 5, centerY);
            ctx.lineTo(centerX + 5, centerY);
            ctx.moveTo(centerX, centerY - 5);
            ctx.lineTo(centerX, centerY + 5);
            ctx.stroke();
        }
        
        function addInventoryItem(charId, listType) {
            const character = project.characters.find(c => c.id === charId);
            if (character) {
                if (!character[listType]) character[listType] = [];
                character[listType].push({
                    id: Date.now(),
                    name: '',
                    quantity: 1,
                    description: ''
                });
                saveProject();
                // Mettre à jour seulement la liste sans re-rendre toute la fiche
                refreshInventoryList(charId, listType);
            }
        }
        
        function removeInventoryItem(charId, listType, index) {
            const character = project.characters.find(c => c.id === charId);
            if (character && character[listType]) {
                character[listType].splice(index, 1);
                saveProject();
                // Mettre à jour seulement la liste sans re-rendre toute la fiche
                refreshInventoryList(charId, listType);
            }
        }
        
        function refreshInventoryList(charId, listType) {
            const character = project.characters.find(c => c.id === charId);
            if (!character) return;
            
            const containerId = `inventory-list-${charId}`;
            const container = document.getElementById(containerId);
            if (!container) {
                // Fallback: re-rendre toute la fiche si le container n'existe pas
                openCharacterDetail(charId);
                return;
            }
            
            const items = character[listType] || [];
            
            container.innerHTML = items.map((item, index) => renderInventoryItem(charId, listType, item, index)).join('');
            
            // Rafraîchir les icônes Lucide
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }
        
        function updateInventoryItem(charId, listType, index, field, value) {
            const character = project.characters.find(c => c.id === charId);
            if (character && character[listType] && character[listType][index]) {
                character[listType][index][field] = value;
                saveProject();
            }
        }
        
        function changeCharacterAvatar(charId) {
            const character = project.characters.find(c => c.id === charId);
            if (!character) return;
            
            const choice = prompt('Choisissez un emoji pour l\'avatar (ou collez une URL d\'image) :', character.avatarEmoji || '👤');
            if (choice === null) return;
            
            if (choice.startsWith('http')) {
                character.avatarImage = choice;
                character.avatarEmoji = '';
            } else {
                character.avatarEmoji = choice || '👤';
                character.avatarImage = '';
            }
            
            saveProject();
            openCharacterDetail(charId);
        }
        
        // ==========================================
        // SPLIT VIEW SYSTEM - New Architecture
        // ==========================================
        
        const viewLabels = {
            'editor': 'Structure',
            'characters': 'Personnages',
            'world': 'Univers',
            'notes': 'Notes',
            'codex': 'Codex',
            'stats': 'Statistiques',
            'analysis': 'Analyse',
            'versions': 'Snapshots',
            'todos': 'TODOs',
            'corkboard': 'Tableau',
            'mindmap': 'Mindmap',
            'plot': 'Intrigue',
            'relations': 'Relations',
            'map': 'Carte',
            'timelineviz': 'Timeline'
        };
        
        const viewIcons = {
            'editor': 'pen-line',
            'characters': 'users',
            'world': 'globe',
            'notes': 'sticky-note',
            'codex': 'book-open',
            'stats': 'bar-chart-3',
            'analysis': 'scan-search',
            'versions': 'history',
            'todos': 'check-square',
            'corkboard': 'layout-grid',
            'mindmap': 'git-branch',
            'plot': 'trending-up',
            'relations': 'link',
            'map': 'map',
            'timelineviz': 'clock'
        };
        
        function toggleSplitView() {
            if (splitViewActive) {
                closeSplitView();
            } else {
                activateSplitView();
            }
        }
        
        function activateSplitView() {
            splitViewActive = true;
            splitActivePanel = 'left';
            
            // Initialize left panel with current view state
            splitViewState.left.view = currentView || 'editor';
            if (currentSceneId) {
                splitViewState.left.sceneId = currentSceneId;
                splitViewState.left.actId = currentActId;
                splitViewState.left.chapterId = currentChapterId;
            }
            
            // Right panel starts empty or with a default
            if (!splitViewState.right.view) {
                splitViewState.right.view = null;
            }
            
            renderSplitView();
            updateSplitToggleButton();
            showNotification('Mode split activé - Cliquez sur un panneau pour le sélectionner');
        }
        
        function closeSplitView() {
            splitViewActive = false;
            
            // Find which panel has the editor and restore it as the main view
            let viewToRestore = 'editor';
            let sceneToRestore = null;
            
            if (splitViewState.left.view === 'editor') {
                viewToRestore = 'editor';
                sceneToRestore = splitViewState.left.sceneId;
                currentActId = splitViewState.left.actId;
                currentChapterId = splitViewState.left.chapterId;
            } else if (splitViewState.right.view === 'editor') {
                viewToRestore = 'editor';
                sceneToRestore = splitViewState.right.sceneId;
                currentActId = splitViewState.right.actId;
                currentChapterId = splitViewState.right.chapterId;
            } else {
                // No editor found, restore left panel view
                viewToRestore = splitViewState.left.view || 'editor';
            }
            
            currentView = viewToRestore;
            if (sceneToRestore) {
                currentSceneId = sceneToRestore;
            }
            
            // Reset split state
            splitViewState.right.view = null;
            
            // Restore normal view
            switchView(currentView);
            
            updateSplitToggleButton();
            saveSplitViewState();
            showNotification('Mode split désactivé');
        }
        
        function updateSplitToggleButton() {
            const btn = document.getElementById('splitModeToggle');
            if (btn) {
                if (splitViewActive) {
                    btn.classList.add('active');
                    btn.innerHTML = '<i data-lucide="columns-2" style="width:14px;height:14px;"></i> <span>Split actif</span>';
                } else {
                    btn.classList.remove('active');
                    btn.innerHTML = '<i data-lucide="columns-2" style="width:14px;height:14px;"></i> <span>Split</span>';
                }
                if (typeof lucide !== 'undefined') lucide.createIcons();
            }
        }
        
        function renderSplitView() {
            if (!splitViewActive) return;
            
            const editorView = document.getElementById('editorView');
            const ratio = splitViewState.ratio || 60;
            
            const leftLabel = splitViewState.left.view ? viewLabels[splitViewState.left.view] || 'Vue' : 'Vide';
            const rightLabel = splitViewState.right.view ? viewLabels[splitViewState.right.view] || 'Vue' : 'Vide';
            const leftIcon = splitViewState.left.view ? viewIcons[splitViewState.left.view] || 'file' : 'plus-circle';
            const rightIcon = splitViewState.right.view ? viewIcons[splitViewState.right.view] || 'file' : 'plus-circle';
            
            editorView.innerHTML = `
                <div class="split-view-container" id="splitViewContainer">
                    <div class="split-panel split-panel-left ${splitActivePanel === 'left' ? 'active' : ''}" 
                         id="splitPanelLeft" 
                         style="flex: ${ratio};"
                         onclick="setActiveSplitPanel('left')">
                        <div class="split-panel-header" onclick="openSplitViewSelector('left'); event.stopPropagation();">
                            <div class="split-panel-title" id="splitLeftTitle">
                                <i data-lucide="${leftIcon}" style="width:14px;height:14px;"></i>
                                <span>${leftLabel}</span>
                                <i data-lucide="chevron-down" style="width:12px;height:12px;opacity:0.5;margin-left:4px;"></i>
                            </div>
                            <div class="split-panel-actions" onclick="event.stopPropagation();">
                                <span class="split-panel-indicator ${splitActivePanel === 'left' ? 'active' : ''}" title="Panneau actif">●</span>
                            </div>
                        </div>
                        <div class="split-panel-content" id="splitLeftContent">
                            <!-- Content rendered by renderSplitPanelViewContent -->
                        </div>
                    </div>
                    
                    <div class="split-resizer horizontal" id="splitResizer" 
                         onmousedown="startSplitResize(event)"
                         ontouchstart="startSplitResize(event)"></div>
                    
                    <div class="split-panel split-panel-right ${splitActivePanel === 'right' ? 'active' : ''}" 
                         id="splitPanelRight" 
                         style="flex: ${100 - ratio};"
                         onclick="setActiveSplitPanel('right')">
                        <div class="split-panel-header" onclick="openSplitViewSelector('right'); event.stopPropagation();">
                            <div class="split-panel-title" id="splitRightTitle">
                                <i data-lucide="${rightIcon}" style="width:14px;height:14px;"></i>
                                <span>${rightLabel}</span>
                                <i data-lucide="chevron-down" style="width:12px;height:12px;opacity:0.5;margin-left:4px;"></i>
                            </div>
                            <div class="split-panel-actions" onclick="event.stopPropagation();">
                                <span class="split-panel-indicator ${splitActivePanel === 'right' ? 'active' : ''}" title="Panneau actif">●</span>
                                <button class="split-panel-btn" onclick="closeSplitView(); event.stopPropagation();" title="Fermer le split">
                                    <i data-lucide="x" style="width:12px;height:12px;"></i>
                                </button>
                            </div>
                        </div>
                        <div class="split-panel-content" id="splitRightContent">
                            <!-- Content rendered by renderSplitPanelViewContent -->
                        </div>
                    </div>
                </div>
            `;
            
            // Render content for both panels
            renderSplitPanelViewContent('left');
            renderSplitPanelViewContent('right');
            
            // Update sidebar for active panel
            updateSidebarForSplitPanel(splitActivePanel);
            
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }
        
        function setActiveSplitPanel(panel) {
            if (splitActivePanel === panel) return;
            
            splitActivePanel = panel;
            
            // Update visual indicators
            document.getElementById('splitPanelLeft')?.classList.toggle('active', panel === 'left');
            document.getElementById('splitPanelRight')?.classList.toggle('active', panel === 'right');
            
            // Update indicators
            document.querySelectorAll('.split-panel-indicator').forEach((el, index) => {
                el.classList.toggle('active', (index === 0 && panel === 'left') || (index === 1 && panel === 'right'));
            });
            
            // Update sidebar for this panel's view
            updateSidebarForSplitPanel(panel);
            
            // Update header nav to reflect active panel's view
            const activeView = panel === 'left' ? splitViewState.left.view : splitViewState.right.view;
            if (activeView) {
                document.querySelectorAll('[id^="header-tab-"]').forEach(btn => btn.classList.remove('active'));
                const headerBtn = document.getElementById(`header-tab-${activeView}`);
                if (headerBtn) headerBtn.classList.add('active');
            }
        }
        
        function updateSidebarForSplitPanel(panel) {
            const state = panel === 'left' ? splitViewState.left : splitViewState.right;
            const view = state.view;
            
            if (!view) return;
            
            // Map views to their sidebar lists
            const sidebarViews = {
                'editor': 'chaptersList',
                'characters': 'charactersList',
                'world': 'worldList',
                'notes': 'notesList',
                'codex': 'codexList',
                'mindmap': 'mindmapList',
                'timelineviz': 'timelineVizList'
            };
            
            // Views that don't use sidebar (full-screen views)
            const noSidebarViews = ['stats', 'analysis', 'versions', 'todos', 'timeline', 'corkboard', 'plot', 'relations', 'map'];
            
            // Labels for views without sidebar
            const viewLabelsNoSidebar = {
                'stats': 'Statistiques',
                'analysis': 'Analyse',
                'versions': 'Versions',
                'todos': 'TODOs',
                'timeline': 'Timeline',
                'corkboard': 'Tableau',
                'plot': 'Intrigue',
                'relations': 'Relations',
                'map': 'Carte'
            };
            
            // Hide all sidebar lists including noSidebarMessage
            const allLists = [
                'chaptersList', 'charactersList', 'worldList', 'timelineList', 
                'notesList', 'codexList', 'statsList', 'versionsList', 'analysisList',
                'todosList', 'corkboardList', 'mindmapList', 'plotList', 
                'relationsList', 'mapList', 'timelineVizList', 'noSidebarMessage'
            ];
            allLists.forEach(listId => {
                const el = document.getElementById(listId);
                if (el) el.style.display = 'none';
            });
            
            // Show the appropriate list and refresh its content
            if (sidebarViews[view]) {
                const listEl = document.getElementById(sidebarViews[view]);
                if (listEl) listEl.style.display = 'block';
                
                // Refresh the list content based on view
                switch(view) {
                    case 'editor':
                        renderActsList();
                        break;
                    case 'characters':
                        if (typeof renderCharactersList === 'function') renderCharactersList();
                        break;
                    case 'world':
                        if (typeof renderWorldList === 'function') renderWorldList();
                        break;
                    case 'notes':
                        if (typeof renderNotesList === 'function') renderNotesList();
                        break;
                    case 'codex':
                        if (typeof renderCodexList === 'function') renderCodexList();
                        break;
                    case 'mindmap':
                        if (typeof renderMindmapList === 'function') renderMindmapList();
                        break;
                    case 'timelineviz':
                        if (typeof renderTimelineVizList === 'function') renderTimelineVizList();
                        break;
                }
            } else if (noSidebarViews.includes(view)) {
                // Show message for views without sidebar
                const noSidebarEl = document.getElementById('noSidebarMessage');
                if (noSidebarEl) {
                    const viewLabel = viewLabelsNoSidebar[view] || 'Cette vue';
                    noSidebarEl.innerHTML = `
                        <div style="padding: 2rem 1rem; text-align: center; color: var(--text-muted);">
                            <i data-lucide="layout-dashboard" style="width: 48px; height: 48px; opacity: 0.3; margin-bottom: 1rem;"></i>
                            <div style="font-size: 0.9rem; line-height: 1.6;">
                                <strong>${viewLabel}</strong> utilise tout l'espace disponible.
                            </div>
                            <div style="font-size: 0.85rem; margin-top: 0.5rem; opacity: 0.8;">
                                La barre latérale n'est pas utilisée dans cette vue.
                            </div>
                        </div>
                    `;
                    noSidebarEl.style.display = 'block';
                    
                    // Refresh icons
                    setTimeout(() => {
                        if (typeof lucide !== 'undefined') lucide.createIcons();
                    }, 50);
                }
            }
            
            // Update sidebar actions
            const actionsHTML = {
                editor: '<button class="btn btn-primary" onclick="openAddActModal()">+ Acte</button><button class="btn btn-primary" onclick="openAddChapterModal()">+ Chapitre</button><button class="btn btn-primary" onclick="openAddSceneModalQuick()">+ Scène</button>',
                characters: '<button class="btn btn-primary" onclick="openAddCharacterModal()">+ Personnage</button>',
                world: '<button class="btn btn-primary" onclick="openAddWorldModal()">+ Élément</button>',
                notes: '<button class="btn btn-primary" onclick="openAddNoteModal()">+ Note</button>',
                codex: '<button class="btn btn-primary" onclick="openAddCodexModal()">+ Entrée</button>'
            };
            const sidebarActions = document.getElementById('sidebarActions');
            if (sidebarActions) {
                sidebarActions.innerHTML = actionsHTML[view] || '';
            }
            
            // Update structure-only elements visibility
            const structureOnlyElements = ['projectProgressBar', 'statusFilters', 'sceneTools'];
            structureOnlyElements.forEach(id => {
                const el = document.getElementById(id);
                if (el) el.style.display = (view === 'editor') ? '' : 'none';
            });
            
            // Update tree collapse toolbar visibility (for views with collapsible groups)
            const treeCollapseToolbar = document.getElementById('treeCollapseToolbar');
            const viewsWithGroups = ['editor', 'world', 'notes', 'codex'];
            if (treeCollapseToolbar) {
                treeCollapseToolbar.style.display = viewsWithGroups.includes(view) ? '' : 'none';
            }
            
            // Refresh Lucide icons
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }
        
        function switchSplitPanelView(panel, view) {
            const state = panel === 'left' ? splitViewState.left : splitViewState.right;
            state.view = view;
            
            // Reset specific IDs when changing view type
            state.sceneId = null;
            state.characterId = null;
            state.worldId = null;
            state.noteId = null;
            
            // If switching to editor view and we have a current scene, use it
            if (view === 'editor' && currentSceneId) {
                state.sceneId = currentSceneId;
                state.actId = currentActId;
                state.chapterId = currentChapterId;
            }
            
            // Re-render the panel content
            renderSplitPanelViewContent(panel);
            
            // Update panel header
            updateSplitPanelHeader(panel);
            
            // Update sidebar if this is the active panel
            if (splitActivePanel === panel) {
                updateSidebarForSplitPanel(panel);
                
                // Update header nav
                document.querySelectorAll('[id^="header-tab-"]').forEach(btn => btn.classList.remove('active'));
                const headerBtn = document.getElementById(`header-tab-${view}`);
                if (headerBtn) headerBtn.classList.add('active');
            }
            
            saveSplitViewState();
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }
        
        function updateSplitPanelHeader(panel) {
            const state = panel === 'left' ? splitViewState.left : splitViewState.right;
            const titleEl = document.getElementById(panel === 'left' ? 'splitLeftTitle' : 'splitRightTitle');
            
            if (titleEl) {
                const label = state.view ? viewLabels[state.view] || 'Vue' : 'Vide';
                const icon = state.view ? viewIcons[state.view] || 'file' : 'plus-circle';
                titleEl.innerHTML = `
                    <i data-lucide="${icon}" style="width:14px;height:14px;"></i>
                    <span>${label}</span>
                    <i data-lucide="chevron-down" style="width:12px;height:12px;opacity:0.5;margin-left:4px;"></i>
                `;
                if (typeof lucide !== 'undefined') lucide.createIcons();
            }
        }
        
        function renderSplitPanelViewContent(panel) {
            const container = document.getElementById(panel === 'left' ? 'splitLeftContent' : 'splitRightContent');
            if (!container) return;
            
            const state = panel === 'left' ? splitViewState.left : splitViewState.right;
            const view = state.view;
            
            if (!view) {
                container.innerHTML = `
                    <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; color: var(--text-muted); text-align: center; padding: 2rem;">
                        <i data-lucide="plus-circle" style="width:48px;height:48px;stroke-width:1;margin-bottom:1rem;opacity:0.5;"></i>
                        <div style="font-size: 1rem; margin-bottom: 0.5rem;">Panneau vide</div>
                        <div style="font-size: 0.85rem; margin-bottom: 1rem;">Cliquez sur l'en-tête pour choisir une vue</div>
                    </div>
                `;
                if (typeof lucide !== 'undefined') lucide.createIcons();
                return;
            }
            
            // Create a unique container ID for this panel's content
            const contentId = `split-${panel}-view-content`;
            container.innerHTML = `<div id="${contentId}" style="height: 100%; overflow: auto;"></div>`;
            
            const contentContainer = document.getElementById(contentId);
            
            // Render the view content into this container
            renderViewInSplitPanel(view, contentContainer, state, panel);
        }
        
        function renderViewInSplitPanel(view, container, state, panel) {
            // Technique: créer un faux editorView temporaire pour que les fonctions de rendu existantes fonctionnent
            const realEditorView = document.getElementById('editorView');
            
            // Créer un conteneur temporaire avec l'ID editorView
            const tempContainer = document.createElement('div');
            tempContainer.id = 'editorView';
            tempContainer.style.cssText = 'height: 100%; overflow: auto;';
            container.innerHTML = '';
            container.appendChild(tempContainer);
            
            // Temporairement masquer le vrai editorView et changer son ID
            if (realEditorView) {
                realEditorView.id = 'editorView-backup';
            }
            
            // Fonction pour restaurer après le rendu
            const restoreEditorView = () => {
                // Restaurer l'ID du vrai editorView
                if (realEditorView) {
                    realEditorView.id = 'editorView';
                }
                // Le tempContainer garde le contenu rendu mais perd son ID
                tempContainer.id = 'splitPanelContent-' + panel;
            };
            
            switch(view) {
                case 'editor':
                    if (state.sceneId) {
                        const act = project.acts.find(a => a.id === state.actId);
                        const chapter = act?.chapters.find(c => c.id === state.chapterId);
                        const scene = chapter?.scenes.find(s => s.id === state.sceneId);
                        if (act && chapter && scene) {
                            renderEditorInContainer(act, chapter, scene, container, panel);
                            restoreEditorView();
                            return; // On sort car renderEditorInContainer gère tout
                        }
                    } else {
                        tempContainer.innerHTML = `
                            <div class="empty-state">
                                <div class="empty-state-icon">✍️</div>
                                <div class="empty-state-title">Sélectionnez une scène</div>
                                <div class="empty-state-text">Choisissez une scène dans la barre latérale</div>
                            </div>
                        `;
                    }
                    break;
                    
                case 'characters':
                    if (state.characterId) {
                        const char = project.characters.find(c => c.id === state.characterId);
                        if (char) {
                            migrateCharacterData(char);
                            tempContainer.innerHTML = renderCharacterSheet(char, false);
                            setTimeout(() => {
                                initCharacterRadar(char);
                                if (typeof lucide !== 'undefined') lucide.createIcons();
                            }, 100);
                        }
                    } else {
                        tempContainer.innerHTML = `
                            <div class="empty-state">
                                <div class="empty-state-icon"><i data-lucide="users" style="width:48px;height:48px;stroke-width:1.5;"></i></div>
                                <div class="empty-state-title">Personnages</div>
                                <div class="empty-state-text">Sélectionnez un personnage dans la barre latérale</div>
                            </div>
                        `;
                    }
                    break;
                    
                case 'world':
                    if (state.worldId) {
                        const elem = project.world?.find(e => e.id === state.worldId);
                        if (elem) {
                            // Appeler la vraie fonction openWorldDetail via le faux editorView
                            if (typeof renderWorldDetailFull === 'function') {
                                renderWorldDetailFull(elem, tempContainer);
                            } else {
                                // Générer le même HTML que openWorldDetail
                                tempContainer.innerHTML = `
                                    <div class="detail-view">
                                        <div class="detail-header">
                                            <div style="display: flex; align-items: center; gap: 1rem;">
                                                <div class="detail-title">${elem.name}</div>
                                                <span style="font-size: 0.9rem; padding: 0.5rem 1rem; background: var(--accent-gold); color: var(--bg-primary); border-radius: 2px;">${elem.type}</span>
                                            </div>
                                        </div>
                                        
                                        ${typeof renderElementLinkedScenes === 'function' ? renderElementLinkedScenes(elem) : ''}
                                        
                                        <div class="detail-section">
                                            <div class="detail-section-title">Informations de base</div>
                                            <div class="detail-field">
                                                <div class="detail-label">Nom</div>
                                                <input type="text" class="form-input" value="${elem.name}" 
                                                       onchange="updateWorldField(${elem.id}, 'name', this.value)">
                                            </div>
                                        </div>

                                        <div class="detail-section">
                                            <div class="detail-section-title">Type</div>
                                            <select class="form-input" onchange="updateWorldField(${elem.id}, 'type', this.value)">
                                                <option value="Lieu" ${elem.type === 'Lieu' ? 'selected' : ''}>Lieu</option>
                                                <option value="Objet" ${elem.type === 'Objet' ? 'selected' : ''}>Objet</option>
                                                <option value="Concept" ${elem.type === 'Concept' ? 'selected' : ''}>Concept</option>
                                                <option value="Organisation" ${elem.type === 'Organisation' ? 'selected' : ''}>Organisation</option>
                                                <option value="Événement" ${elem.type === 'Événement' ? 'selected' : ''}>Événement</option>
                                            </select>
                                        </div>

                                        <div class="detail-section">
                                            <div class="detail-section-title">Description</div>
                                            <textarea class="form-input" rows="6" 
                                                      onchange="updateWorldField(${elem.id}, 'description', this.value)">${elem.description || ''}</textarea>
                                        </div>

                                        <div class="detail-section">
                                            <div class="detail-section-title">Détails</div>
                                            <textarea class="form-input" rows="6" 
                                                      onchange="updateWorldField(${elem.id}, 'details', this.value)">${elem.details || ''}</textarea>
                                        </div>

                                        <div class="detail-section">
                                            <div class="detail-section-title">Histoire</div>
                                            <textarea class="form-input" rows="6" 
                                                      onchange="updateWorldField(${elem.id}, 'history', this.value)">${elem.history || ''}</textarea>
                                        </div>

                                        <div class="detail-section">
                                            <div class="detail-section-title">Notes</div>
                                            <textarea class="form-input" rows="4" 
                                                      onchange="updateWorldField(${elem.id}, 'notes', this.value)">${elem.notes || ''}</textarea>
                                        </div>
                                    </div>
                                `;
                            }
                        }
                    } else {
                        tempContainer.innerHTML = `
                            <div class="empty-state">
                                <div class="empty-state-icon"><i data-lucide="globe" style="width:48px;height:48px;stroke-width:1.5;"></i></div>
                                <div class="empty-state-title">Univers</div>
                                <div class="empty-state-text">Sélectionnez un élément dans la barre latérale</div>
                            </div>
                        `;
                    }
                    break;
                    
                case 'notes':
                    if (state.noteId) {
                        const note = project.notes?.find(n => n.id === state.noteId);
                        if (note) {
                            // Même HTML que openNoteDetail
                            tempContainer.innerHTML = `
                                <div class="detail-view">
                                    <div class="detail-header">
                                        <div style="display: flex; align-items: center; gap: 1rem; flex: 1;">
                                            <input type="text" class="form-input" value="${note.title || ''}" 
                                                   style="font-size: 1.8rem; font-weight: 600; font-family: 'Noto Serif JP', serif; padding: 0.5rem;"
                                                   onchange="updateNoteField(${note.id}, 'title', this.value)"
                                                   placeholder="Titre de la note">
                                            <span style="font-size: 0.8rem; padding: 0.4rem 0.8rem; background: var(--accent-gold); color: var(--bg-primary); border-radius: 2px;">${note.category || 'Note'}</span>
                                        </div>
                                    </div>
                                    
                                    <div class="detail-section">
                                        <div class="detail-section-title">Catégorie</div>
                                        <select class="form-input" onchange="updateNoteField(${note.id}, 'category', this.value)">
                                            <option value="Recherche" ${note.category === 'Recherche' ? 'selected' : ''}>Recherche</option>
                                            <option value="Idée" ${note.category === 'Idée' ? 'selected' : ''}>Idée</option>
                                            <option value="Référence" ${note.category === 'Référence' ? 'selected' : ''}>Référence</option>
                                            <option value="A faire" ${note.category === 'A faire' ? 'selected' : ''}>À faire</option>
                                            <option value="Question" ${note.category === 'Question' ? 'selected' : ''}>Question</option>
                                            <option value="Autre" ${note.category === 'Autre' ? 'selected' : ''}>Autre</option>
                                        </select>
                                    </div>

                                    <div class="detail-section">
                                        <div class="detail-section-title">Tags</div>
                                        <input type="text" class="form-input" value="${(note.tags || []).join(', ')}" 
                                               onchange="updateNoteTags(${note.id}, this.value)">
                                        <small style="color: var(--text-muted); font-style: italic;">Séparez les tags par des virgules</small>
                                    </div>

                                    <div class="detail-section">
                                        <div class="detail-section-title">Contenu</div>
                                        <textarea class="form-input" rows="20" 
                                                  oninput="updateNoteField(${note.id}, 'content', this.value)">${note.content || ''}</textarea>
                                    </div>

                                    <div style="font-size: 0.8rem; color: var(--text-muted); margin-top: 2rem; font-family: 'Source Code Pro', monospace;">
                                        Créée le ${new Date(note.createdAt).toLocaleDateString('fr-FR')} • 
                                        Modifiée le ${new Date(note.updatedAt).toLocaleDateString('fr-FR')}
                                    </div>
                                </div>
                            `;
                        }
                    } else {
                        tempContainer.innerHTML = `
                            <div class="empty-state">
                                <div class="empty-state-icon"><i data-lucide="sticky-note" style="width:48px;height:48px;stroke-width:1.5;"></i></div>
                                <div class="empty-state-title">Notes</div>
                                <div class="empty-state-text">Sélectionnez une note dans la barre latérale</div>
                            </div>
                        `;
                    }
                    break;
                    
                case 'mindmap':
                    // Appeler la vraie fonction renderMindmapView
                    if (typeof renderMindmapView === 'function') {
                        renderMindmapView();
                    }
                    break;
                    
                case 'corkboard':
                    // Call real render function
                    if (typeof openCorkBoardView === 'function') {
                        openCorkBoardView();
                    }
                    break;
                    
                case 'stats':
                    // Call real render function
                    if (typeof renderStats === 'function') {
                        renderStats();
                    }
                    break;
                    
                case 'analysis':
                    // Call real render function
                    if (typeof renderAnalysis === 'function') {
                        renderAnalysis();
                    }
                    break;
                    
                case 'map':
                    // Call real render function
                    if (typeof renderMapView === 'function') {
                        renderMapView();
                    }
                    break;
                    
                case 'codex':
                    if (state.codexId) {
                        // Render specific codex entry directly in the container
                        const entry = project.codex?.find(c => c.id === state.codexId);
                        if (entry) {
                            tempContainer.innerHTML = `
                                <div class="detail-view">
                                    <div class="detail-header">
                                        <div style="display: flex; align-items: center; gap: 1rem; flex: 1;">
                                            <input type="text" class="form-input" value="${entry.title}" 
                                                   style="font-size: 1.8rem; font-weight: 600; font-family: 'Noto Serif JP', serif; padding: 0.5rem;"
                                                   onchange="updateCodexField(${entry.id}, 'title', this.value)"
                                                   placeholder="Titre de l'entrée">
                                            <span style="font-size: 0.8rem; padding: 0.4rem 0.8rem; background: var(--accent-gold); color: var(--bg-primary); border-radius: 2px;">${entry.category}</span>
                                        </div>
                                    </div>
                                    
                                    <div class="detail-section">
                                        <div class="detail-section-title">Catégorie</div>
                                        <select class="form-input" onchange="updateCodexField(${entry.id}, 'category', this.value)">
                                            <option value="Culture" ${entry.category === 'Culture' ? 'selected' : ''}>Culture</option>
                                            <option value="Histoire" ${entry.category === 'Histoire' ? 'selected' : ''}>Histoire</option>
                                            <option value="Technologie" ${entry.category === 'Technologie' ? 'selected' : ''}>Technologie</option>
                                            <option value="Géographie" ${entry.category === 'Géographie' ? 'selected' : ''}>Géographie</option>
                                            <option value="Politique" ${entry.category === 'Politique' ? 'selected' : ''}>Politique</option>
                                            <option value="Magie/Pouvoir" ${entry.category === 'Magie/Pouvoir' ? 'selected' : ''}>Magie/Pouvoir</option>
                                            <option value="Religion" ${entry.category === 'Religion' ? 'selected' : ''}>Religion</option>
                                            <option value="Société" ${entry.category === 'Société' ? 'selected' : ''}>Société</option>
                                            <option value="Autre" ${entry.category === 'Autre' ? 'selected' : ''}>Autre</option>
                                        </select>
                                    </div>

                                    <div class="detail-section">
                                        <div class="detail-section-title">Résumé</div>
                                        <textarea class="form-input" rows="3" 
                                                  onchange="updateCodexField(${entry.id}, 'summary', this.value)">${entry.summary || ''}</textarea>
                                    </div>

                                    <div class="detail-section">
                                        <div class="detail-section-title">Contenu détaillé</div>
                                        <textarea class="form-input" rows="20" 
                                                  oninput="updateCodexField(${entry.id}, 'content', this.value)">${entry.content || ''}</textarea>
                                    </div>
                                </div>
                            `;
                        }
                    } else {
                        tempContainer.innerHTML = `
                            <div class="empty-state">
                                <div class="empty-state-icon"><i data-lucide="book-open" style="width:48px;height:48px;stroke-width:1.5;"></i></div>
                                <div class="empty-state-title">Codex</div>
                                <div class="empty-state-text">Sélectionnez une entrée dans la barre latérale</div>
                            </div>
                        `;
                    }
                    break;
                
                case 'plot':
                    // Call real render function
                    if (typeof renderPlotView === 'function') {
                        renderPlotView();
                    }
                    break;
                    
                case 'relations':
                    // Call real render function
                    if (typeof renderRelationsView === 'function') {
                        renderRelationsView();
                    }
                    break;
                    
                case 'timelineviz':
                    // Render timeline metro in split panel (without sidebar, just the main content)
                    const charCount = project.characters?.length || 0;
                    
                    if (charCount === 0) {
                        tempContainer.innerHTML = `
                            <div class="metro-empty-state">
                                <i data-lucide="users" style="width: 64px; height: 64px; opacity: 0.3;"></i>
                                <h3 style="margin: 1rem 0 0.5rem;">Aucun personnage</h3>
                                <p style="margin-bottom: 1.5rem;">Créez d'abord des personnages dans l'onglet "Personnages".</p>
                            </div>
                        `;
                    } else {
                        tempContainer.innerHTML = `
                            <div style="padding: 1rem; height: 100%; overflow: auto;">
                                <div class="metro-toolbar" style="margin-bottom: 1rem;">
                                    <button class="btn btn-primary" onclick="openMetroEventModal()">
                                        <i data-lucide="plus" style="width: 16px; height: 16px;"></i>
                                        Nouvel événement
                                    </button>
                                    <button class="btn" onclick="sortMetroByDate()">
                                        <i data-lucide="calendar" style="width: 16px; height: 16px;"></i>
                                        Trier par date
                                    </button>
                                </div>
                                
                                <div class="metro-timeline-container" id="metroTimelineContainer-split-${panel}">
                                    ${renderMetroSVG()}
                                </div>
                                
                                <div class="metro-legend" style="margin-top: 1rem;">
                                    ${project.characters.map(char => `
                                        <div class="metro-legend-item" onclick="openMetroColorPicker(${char.id})" style="cursor: pointer;" title="Cliquer pour changer la couleur">
                                            <div class="metro-legend-line" style="background: ${project.characterColors[char.id] || '#999'};"></div>
                                            <span>${char.name}</span>
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                        `;
                    }
                    break;
                    
                case 'versions':
                    // Call real render function
                    if (typeof renderVersionsList === 'function') {
                        renderVersionsList();
                    }
                    break;
                    
                case 'todos':
                    // Call real render function
                    if (typeof renderTodosList === 'function') {
                        renderTodosList();
                    }
                    break;
                    
                case 'timeline':
                    // Call real render function
                    if (typeof renderTimelineList === 'function') {
                        renderTimelineList();
                    }
                    break;
                    
                default:
                    tempContainer.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-state-icon"><i data-lucide="${viewIcons[view] || 'file'}" style="width:48px;height:48px;stroke-width:1.5;"></i></div>
                            <div class="empty-state-title">${viewLabels[view] || view}</div>
                            <div class="empty-state-text">Cette vue est disponible</div>
                        </div>
                    `;
            }
            
            // Restaurer l'ID du vrai editorView
            restoreEditorView();
            
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }
        
        // Render the full editor with toolbar in a container (for split view)
        function renderEditorInContainer(act, chapter, scene, container, panel) {
            const wordCount = getWordCount(scene.content || '');
            
            // Vérifier si une version finale existe
            const hasFinalVersion = scene.versions && scene.versions.some(v => v.isFinal === true);
            const finalVersion = hasFinalVersion ? scene.versions.find(v => v.isFinal === true) : null;
            const finalVersionBadge = hasFinalVersion 
                ? `<span style="display: inline-flex; align-items: center; gap: 0.25rem; background: var(--accent-gold); color: var(--bg-accent); font-size: 0.7rem; font-weight: 600; padding: 0.2rem 0.5rem; border-radius: 10px; margin-left: 0.5rem;" title="Version finale : ${finalVersion.number}">⭐ ${finalVersion.number}</span>`
                : '';
            
            container.innerHTML = `
                <div class="editor-fixed-top" style="position: relative;">
                    <div class="editor-header">
                        <div class="editor-breadcrumb">${act.title} > ${chapter.title}</div>
                        <div style="display: flex; align-items: center; gap: 1rem;">
                            <div class="editor-title" style="flex: 1;">${scene.title}${finalVersionBadge}</div>
                        </div>
                        <div class="editor-meta">
                            <span class="split-word-count-${panel}">${wordCount} mots</span>
                            <span>Dernière modification : ${new Date().toLocaleDateString('fr-FR')}</span>
                        </div>
                    </div>
                    <button class="toolbar-mobile-toggle" onclick="toggleSplitEditorToolbar('${panel}')">
                        <span><i data-lucide="pen-line" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Outils de formatage</span>
                    </button>
                    <div class="editor-toolbar" id="editorToolbar-${panel}">
                        <!-- Basic formatting -->
                        <div class="toolbar-group">
                            <button class="toolbar-btn" onclick="formatTextInPanel('${panel}', 'bold')" title="Gras (Ctrl+B)">
                                <strong>B</strong>
                            </button>
                            <button class="toolbar-btn" onclick="formatTextInPanel('${panel}', 'italic')" title="Italique (Ctrl+I)">
                                <em>I</em>
                            </button>
                            <button class="toolbar-btn" onclick="formatTextInPanel('${panel}', 'underline')" title="Souligné (Ctrl+U)">
                                <u>U</u>
                            </button>
                            <button class="toolbar-btn" onclick="formatTextInPanel('${panel}', 'strikeThrough')" title="Barré">
                                <s>S</s>
                            </button>
                        </div>
                        
                        <!-- Font family and size -->
                        <div class="toolbar-group">
                            <select class="font-family-selector" onchange="formatTextInPanel('${panel}', 'fontName', this.value)" title="Police de caractères">
                                <option value="Crimson Pro">Crimson Pro</option>
                                <option value="Arial">Arial</option>
                                <option value="Georgia">Georgia</option>
                                <option value="Times New Roman">Times New Roman</option>
                                <option value="Courier New">Courier New</option>
                                <option value="Verdana">Verdana</option>
                                <option value="Garamond">Garamond</option>
                                <option value="Palatino">Palatino</option>
                            </select>
                            <select class="font-size-selector" onchange="formatTextInPanel('${panel}', 'fontSize', this.value)" title="Taille de police">
                                <option value="1">Très petit</option>
                                <option value="2">Petit</option>
                                <option value="3" selected>Normal</option>
                                <option value="4">Grand</option>
                                <option value="5">Très grand</option>
                                <option value="6">Énorme</option>
                                <option value="7">Gigantesque</option>
                            </select>
                        </div>
                        
                        <!-- Alignment -->
                        <div class="toolbar-group">
                            <button class="toolbar-btn" onclick="formatTextInPanel('${panel}', 'justifyLeft')" title="Aligner à gauche">
                                ⫷
                            </button>
                            <button class="toolbar-btn" onclick="formatTextInPanel('${panel}', 'justifyCenter')" title="Centrer">
                                ⫶
                            </button>
                            <button class="toolbar-btn" onclick="formatTextInPanel('${panel}', 'justifyRight')" title="Aligner à droite">
                                ⫸
                            </button>
                            <button class="toolbar-btn" onclick="formatTextInPanel('${panel}', 'justifyFull')" title="Justifier">
                                ☰
                            </button>
                        </div>
                        
                        <!-- Headings -->
                        <div class="toolbar-group">
                            <button class="toolbar-btn" onclick="formatTextInPanel('${panel}', 'formatBlock', 'h1')" title="Titre 1">H1</button>
                            <button class="toolbar-btn" onclick="formatTextInPanel('${panel}', 'formatBlock', 'h2')" title="Titre 2">H2</button>
                            <button class="toolbar-btn" onclick="formatTextInPanel('${panel}', 'formatBlock', 'h3')" title="Titre 3">H3</button>
                            <button class="toolbar-btn" onclick="formatTextInPanel('${panel}', 'formatBlock', 'p')" title="Paragraphe">P</button>
                        </div>
                        
                        <!-- Lists and quotes -->
                        <div class="toolbar-group">
                            <button class="toolbar-btn" onclick="formatTextInPanel('${panel}', 'insertUnorderedList')" title="Liste à puces">• Liste</button>
                            <button class="toolbar-btn" onclick="formatTextInPanel('${panel}', 'insertOrderedList')" title="Liste numérotée">1. Liste</button>
                            <button class="toolbar-btn" onclick="formatTextInPanel('${panel}', 'formatBlock', 'blockquote')" title="Citation">❝ Citation</button>
                        </div>
                        
                        <!-- Indentation -->
                        <div class="toolbar-group">
                            <button class="toolbar-btn" onclick="formatTextInPanel('${panel}', 'indent')" title="Augmenter l'indentation">→|</button>
                            <button class="toolbar-btn" onclick="formatTextInPanel('${panel}', 'outdent')" title="Diminuer l'indentation">|←</button>
                        </div>
                        
                        <!-- Superscript, subscript -->
                        <div class="toolbar-group">
                            <button class="toolbar-btn" onclick="formatTextInPanel('${panel}', 'superscript')" title="Exposant">x²</button>
                            <button class="toolbar-btn" onclick="formatTextInPanel('${panel}', 'subscript')" title="Indice">x₂</button>
                        </div>
                        
                        <!-- Other -->
                        <div class="toolbar-group">
                            <button class="toolbar-btn" onclick="formatTextInPanel('${panel}', 'insertHorizontalRule')" title="Ligne horizontale">─</button>
                            <button class="toolbar-btn" onclick="formatTextInPanel('${panel}', 'removeFormat')" title="Supprimer le formatage">✕ Format</button>
                        </div>
                    </div>
                    <div class="links-panel-sticky" id="linksPanel-${panel}">
                        <div style="display: flex; gap: 2rem; align-items: start;">
                            <div style="flex: 1;">
                                <div style="font-size: 0.85rem; font-weight: 600; margin-bottom: 0.5rem; color: var(--text-muted);"><i data-lucide="users" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Personnages</div>
                                <div class="quick-links">
                                    ${renderSceneCharacters(act.id, chapter.id, scene)}
                                    <button class="btn btn-small" onclick="openCharacterLinker(${act.id}, ${chapter.id}, ${scene.id})" style="font-size: 0.75rem; padding: 0.3rem 0.6rem;">+ Lier</button>
                                </div>
                            </div>
                            <div style="flex: 1;">
                                <div style="font-size: 0.85rem; font-weight: 600; margin-bottom: 0.5rem; color: var(--text-muted);"><i data-lucide="globe" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Lieux/Éléments</div>
                                <div class="quick-links">
                                    ${renderSceneElements(act.id, chapter.id, scene)}
                                    <button class="btn btn-small" onclick="openElementLinker(${act.id}, ${chapter.id}, ${scene.id})" style="font-size: 0.75rem; padding: 0.3rem 0.6rem;">+ Lier</button>
                                </div>
                            </div>
                            <div style="flex: 1;">
                                <div style="font-size: 0.85rem; font-weight: 600; margin-bottom: 0.5rem; color: var(--text-muted);"><i data-lucide="train-track" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Timeline</div>
                                <div class="quick-links">
                                    ${renderSceneMetroEvents(scene.id)}
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="editor-workspace">
                    <div class="editor-content">
                        <div 
                            class="editor-textarea" 
                            contenteditable="true"
                            spellcheck="true"
                            id="editor-${panel}"
                            data-panel="${panel}"
                            data-scene-id="${scene.id}"
                            data-chapter-id="${chapter.id}"
                            data-act-id="${act.id}"
                            data-placeholder="Commencez à écrire votre scène..."
                            oninput="updateSplitSceneContent(this)"
                            onkeydown="handleEditorKeydown(event)"
                        >${scene.content || ''}</div>
                    </div>
                </div>
            `;
            
            // Initialize lucide icons
            setTimeout(() => {
                if (typeof lucide !== 'undefined') lucide.createIcons();
            }, 50);
        }
        
        // Toggle toolbar visibility in split panel
        function toggleSplitEditorToolbar(panel) {
            const toolbar = document.getElementById('editorToolbar-' + panel);
            if (toolbar) {
                toolbar.classList.toggle('visible');
            }
        }
        
        // Format text in a specific panel's editor
        function formatTextInPanel(panel, command, value = null) {
            const editor = document.getElementById('editor-' + panel);
            if (!editor) return;
            
            // Focus the editor first
            editor.focus();
            
            // Execute the command
            if (value) {
                document.execCommand(command, false, value);
            } else {
                document.execCommand(command, false, null);
            }
        }
        
        // Render full world detail in container
        function renderWorldDetailInContainer(element, container) {
            container.innerHTML = `
                <div class="detail-view" style="height: 100%; overflow-y: auto;">
                    <div class="detail-header" style="position: sticky; top: 0; background: var(--bg-primary); z-index: 10; padding: 1rem; border-bottom: 1px solid var(--border-color);">
                        <div style="display: flex; align-items: center; gap: 1rem;">
                            <div class="detail-title" style="font-size: 1.5rem; font-weight: 600;">${element.name}</div>
                            <span style="font-size: 0.85rem; padding: 0.4rem 0.8rem; background: var(--primary-color); color: white; border-radius: 4px;">${element.type}</span>
                        </div>
                    </div>
                    
                    <div style="padding: 1.5rem;">
                        <div class="detail-section" style="margin-bottom: 1.5rem;">
                            <div class="detail-section-title" style="font-size: 0.9rem; font-weight: 600; color: var(--text-muted); margin-bottom: 0.5rem;">Nom</div>
                            <input type="text" class="form-input" value="${element.name}" 
                                   onchange="updateWorldField(${element.id}, 'name', this.value)" style="width: 100%;">
                        </div>

                        <div class="detail-section" style="margin-bottom: 1.5rem;">
                            <div class="detail-section-title" style="font-size: 0.9rem; font-weight: 600; color: var(--text-muted); margin-bottom: 0.5rem;">Type</div>
                            <select class="form-input" onchange="updateWorldField(${element.id}, 'type', this.value)" style="width: 100%;">
                                <option value="Lieu" ${element.type === 'Lieu' ? 'selected' : ''}>Lieu</option>
                                <option value="Objet" ${element.type === 'Objet' ? 'selected' : ''}>Objet</option>
                                <option value="Concept" ${element.type === 'Concept' ? 'selected' : ''}>Concept</option>
                                <option value="Organisation" ${element.type === 'Organisation' ? 'selected' : ''}>Organisation</option>
                                <option value="Événement" ${element.type === 'Événement' ? 'selected' : ''}>Événement</option>
                            </select>
                        </div>

                        <div class="detail-section" style="margin-bottom: 1.5rem;">
                            <div class="detail-section-title" style="font-size: 0.9rem; font-weight: 600; color: var(--text-muted); margin-bottom: 0.5rem;">Description</div>
                            <textarea class="form-input" rows="6" style="width: 100%; resize: vertical;"
                                      onchange="updateWorldField(${element.id}, 'description', this.value)">${element.description || ''}</textarea>
                        </div>

                        <div class="detail-section" style="margin-bottom: 1.5rem;">
                            <div class="detail-section-title" style="font-size: 0.9rem; font-weight: 600; color: var(--text-muted); margin-bottom: 0.5rem;">Détails</div>
                            <textarea class="form-input" rows="6" style="width: 100%; resize: vertical;"
                                      onchange="updateWorldField(${element.id}, 'details', this.value)">${element.details || ''}</textarea>
                        </div>

                        <div class="detail-section" style="margin-bottom: 1.5rem;">
                            <div class="detail-section-title" style="font-size: 0.9rem; font-weight: 600; color: var(--text-muted); margin-bottom: 0.5rem;">Histoire</div>
                            <textarea class="form-input" rows="6" style="width: 100%; resize: vertical;"
                                      onchange="updateWorldField(${element.id}, 'history', this.value)">${element.history || ''}</textarea>
                        </div>

                        <div class="detail-section" style="margin-bottom: 1.5rem;">
                            <div class="detail-section-title" style="font-size: 0.9rem; font-weight: 600; color: var(--text-muted); margin-bottom: 0.5rem;">Notes</div>
                            <textarea class="form-input" rows="4" style="width: 100%; resize: vertical;"
                                      onchange="updateWorldField(${element.id}, 'notes', this.value)">${element.notes || ''}</textarea>
                        </div>
                    </div>
                </div>
            `;
        }
        
        // Render full note detail in container
        function renderNoteDetailInContainer(note, container) {
            container.innerHTML = `
                <div class="detail-view" style="height: 100%; display: flex; flex-direction: column; overflow: hidden;">
                    <div class="detail-header" style="padding: 1rem; background: var(--bg-secondary); border-bottom: 1px solid var(--border-color);">
                        <div style="display: flex; align-items: center; gap: 1rem;">
                            <input type="text" class="form-input" value="${note.title || ''}" 
                                   style="font-size: 1.3rem; font-weight: 600; flex: 1; border: none; background: transparent;"
                                   onchange="updateNoteField(${note.id}, 'title', this.value)"
                                   placeholder="Titre de la note">
                            <select class="form-input" onchange="updateNoteField(${note.id}, 'category', this.value)" style="width: auto;">
                                <option value="Recherche" ${note.category === 'Recherche' ? 'selected' : ''}>Recherche</option>
                                <option value="Idée" ${note.category === 'Idée' ? 'selected' : ''}>Idée</option>
                                <option value="Référence" ${note.category === 'Référence' ? 'selected' : ''}>Référence</option>
                                <option value="A faire" ${note.category === 'A faire' ? 'selected' : ''}>À faire</option>
                                <option value="Question" ${note.category === 'Question' ? 'selected' : ''}>Question</option>
                                <option value="Autre" ${note.category === 'Autre' ? 'selected' : ''}>Autre</option>
                            </select>
                        </div>
                        <div style="margin-top: 0.5rem;">
                            <input type="text" class="form-input" value="${(note.tags || []).join(', ')}" 
                                   style="font-size: 0.85rem; width: 100%;"
                                   onchange="updateNoteTags(${note.id}, this.value)"
                                   placeholder="Tags (séparés par des virgules)">
                        </div>
                    </div>
                    <div style="flex: 1; padding: 1rem; overflow: hidden;">
                        <textarea class="form-input" 
                                  style="width: 100%; height: 100%; resize: none; font-size: 1rem; line-height: 1.7; border: none; background: var(--bg-primary);"
                                  oninput="updateNoteField(${note.id}, 'content', this.value)"
                                  placeholder="Contenu de la note...">${note.content || ''}</textarea>
                    </div>
                    <div style="padding: 0.5rem 1rem; font-size: 0.75rem; color: var(--text-muted); background: var(--bg-secondary); border-top: 1px solid var(--border-color);">
                        Créée le ${new Date(note.createdAt).toLocaleDateString('fr-FR')} • 
                        Modifiée le ${new Date(note.updatedAt).toLocaleDateString('fr-FR')}
                    </div>
                </div>
            `;
        }
        
        function renderCorkboardInSplitPanel(containerId) {
            const container = document.getElementById(containerId);
            if (!container) return;
            
            container.innerHTML = `
                <div style="padding: 1rem;">
                    <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 1rem;">
                        ${project.acts.map(act => 
                            act.chapters.map(chapter => 
                                chapter.scenes.map(scene => `
                                    <div class="cork-card" onclick="openSceneFromSplit(${act.id}, ${chapter.id}, ${scene.id})" style="background: var(--bg-secondary); padding: 1rem; border-radius: 8px; border: 1px solid var(--border-color); cursor: pointer; transition: transform 0.15s, box-shadow 0.15s;">
                                        <div style="font-weight: 600; margin-bottom: 0.5rem;">${scene.title || 'Sans titre'}</div>
                                        <div style="font-size: 0.8rem; color: var(--text-muted);">${chapter.title}</div>
                                        <div style="font-size: 0.75rem; color: var(--text-muted); margin-top: 0.5rem;">${getWordCount(scene.content || '')} mots</div>
                                    </div>
                                `).join('')
                            ).join('')
                        ).join('')}
                    </div>
                </div>
            `;
        }
        
        // Helper to open a scene from corkboard in split mode
        function openSceneFromSplit(actId, chapterId, sceneId) {
            if (splitViewActive) {
                const state = splitActivePanel === 'left' ? splitViewState.left : splitViewState.right;
                state.view = 'editor';
                state.actId = actId;
                state.chapterId = chapterId;
                state.sceneId = sceneId;
                renderSplitPanelViewContent(splitActivePanel);
                updateSplitPanelHeader(splitActivePanel);
                updateSidebarForSplitPanel(splitActivePanel);
            } else {
                openScene(actId, chapterId, sceneId);
            }
        }
        
        function renderStatsInSplitPanel(containerId) {
            const container = document.getElementById(containerId);
            if (!container) return;
            
            let totalWords = 0;
            let totalScenes = 0;
            let totalChapters = 0;
            
            project.acts.forEach(act => {
                act.chapters.forEach(chapter => {
                    totalChapters++;
                    chapter.scenes.forEach(scene => {
                        totalScenes++;
                        totalWords += getWordCount(scene.content || '');
                    });
                });
            });
            
            container.innerHTML = `
                <div style="padding: 1.5rem;">
                    <h3 style="margin-bottom: 1.5rem;">Statistiques du projet</h3>
                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem;">
                        <div style="background: var(--bg-secondary); padding: 1.5rem; border-radius: 8px; text-align: center;">
                            <div style="font-size: 2rem; font-weight: 700; color: var(--primary-color);">${totalWords.toLocaleString()}</div>
                            <div style="color: var(--text-muted);">Mots</div>
                        </div>
                        <div style="background: var(--bg-secondary); padding: 1.5rem; border-radius: 8px; text-align: center;">
                            <div style="font-size: 2rem; font-weight: 700; color: var(--primary-color);">${totalScenes}</div>
                            <div style="color: var(--text-muted);">Scènes</div>
                        </div>
                        <div style="background: var(--bg-secondary); padding: 1.5rem; border-radius: 8px; text-align: center;">
                            <div style="font-size: 2rem; font-weight: 700; color: var(--primary-color);">${totalChapters}</div>
                            <div style="color: var(--text-muted);">Chapitres</div>
                        </div>
                        <div style="background: var(--bg-secondary); padding: 1.5rem; border-radius: 8px; text-align: center;">
                            <div style="font-size: 2rem; font-weight: 700; color: var(--primary-color);">${project.characters?.length || 0}</div>
                            <div style="color: var(--text-muted);">Personnages</div>
                        </div>
                    </div>
                </div>
            `;
        }
        
        // Render Plot view in split panel
        function renderPlotInSplitPanel(container) {
            // Initialiser les points d'intrigue si nécessaire
            if (typeof plotPoints === 'undefined' || plotPoints.length === 0) {
                if (typeof initPlotPoints === 'function') {
                    initPlotPoints();
                }
            }
            
            const svgWidth = 600;
            const svgHeight = 350;
            const padding = 50;
            const plotWidth = svgWidth - padding * 2;
            const plotHeight = svgHeight - padding * 2;
            
            let pathData = '';
            let pointsHTML = '';
            let gridLines = '';
            
            // Lignes de grille
            for (let i = 0; i <= 4; i++) {
                const y = padding + (plotHeight / 4) * i;
                gridLines += `<line x1="${padding}" y1="${y}" x2="${svgWidth - padding}" y2="${y}" stroke="var(--border-color)" stroke-width="1" opacity="0.3" stroke-dasharray="5,5"/>`;
            }
            
            // Générer la courbe si plotPoints existe
            if (typeof plotPoints !== 'undefined' && plotPoints.length > 0) {
                plotPoints.forEach((point, index) => {
                    const x = padding + (plotWidth / Math.max(plotPoints.length - 1, 1)) * index;
                    const y = padding + plotHeight - (point.intensity / 100) * plotHeight;
                    
                    if (index === 0) {
                        pathData = `M ${x} ${y}`;
                    } else {
                        pathData += ` L ${x} ${y}`;
                    }
                    
                    pointsHTML += `
                        <circle cx="${x}" cy="${y}" r="5" fill="var(--accent-gold)" stroke="white" stroke-width="2" 
                                style="cursor: pointer;" 
                                onclick="openScene(${point.actId}, ${point.chapterId}, ${point.sceneId})">
                            <title>${point.title} - Tension: ${Math.round(point.intensity)}%</title>
                        </circle>
                    `;
                });
            }
            
            container.innerHTML = `
                <div style="padding: 1.5rem;">
                    <h3 style="margin-bottom: 1rem;"><i data-lucide="trending-up" style="width:18px;height:18px;vertical-align:middle;margin-right:6px;"></i>Graphique d'Intrigue</h3>
                    <div style="background: var(--bg-secondary); border-radius: 8px; padding: 1rem; overflow-x: auto;">
                        <svg viewBox="0 0 ${svgWidth} ${svgHeight}" style="width: 100%; max-width: ${svgWidth}px; height: auto;">
                            ${gridLines}
                            ${pathData ? `<path d="${pathData}" fill="none" stroke="var(--primary-color)" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/>` : ''}
                            ${pointsHTML}
                        </svg>
                    </div>
                    <div style="margin-top: 1rem; font-size: 0.85rem; color: var(--text-muted);">
                        ${typeof plotPoints !== 'undefined' ? plotPoints.length : 0} points d'intrigue • Cliquez sur un point pour ouvrir la scène
                    </div>
                </div>
            `;
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }
        
        // Render Relations view in split panel
        function renderRelationsInSplitPanel(container) {
            const relationships = project.relationships || [];
            const characters = project.characters || [];
            
            if (characters.length < 2) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon"><i data-lucide="heart-handshake" style="width:48px;height:48px;stroke-width:1.5;"></i></div>
                        <div class="empty-state-title">Relations</div>
                        <div class="empty-state-text">Créez au moins 2 personnages pour définir leurs relations</div>
                    </div>
                `;
                if (typeof lucide !== 'undefined') lucide.createIcons();
                return;
            }
            
            let relationsHTML = '';
            if (relationships.length > 0) {
                relationsHTML = relationships.map(rel => {
                    const char1 = characters.find(c => c.id === rel.character1Id);
                    const char2 = characters.find(c => c.id === rel.character2Id);
                    if (!char1 || !char2) return '';
                    
                    return `
                        <div style="background: var(--bg-secondary); padding: 1rem; border-radius: 8px; margin-bottom: 0.75rem;">
                            <div style="display: flex; align-items: center; gap: 1rem;">
                                <span style="font-weight: 600;">${char1.name || char1.firstName || 'Personnage 1'}</span>
                                <span style="color: var(--primary-color);">↔</span>
                                <span style="font-weight: 600;">${char2.name || char2.firstName || 'Personnage 2'}</span>
                            </div>
                            <div style="font-size: 0.9rem; color: var(--text-muted); margin-top: 0.5rem;">${rel.type || 'Relation'}</div>
                            ${rel.description ? `<div style="font-size: 0.85rem; margin-top: 0.5rem;">${rel.description}</div>` : ''}
                        </div>
                    `;
                }).join('');
            } else {
                relationsHTML = '<div style="color: var(--text-muted); text-align: center; padding: 2rem;">Aucune relation définie</div>';
            }
            
            container.innerHTML = `
                <div style="padding: 1.5rem;">
                    <h3 style="margin-bottom: 1rem;"><i data-lucide="heart-handshake" style="width:18px;height:18px;vertical-align:middle;margin-right:6px;"></i>Relations entre personnages</h3>
                    <div>${relationsHTML}</div>
                    <button class="btn btn-primary" onclick="openAddRelationModal()" style="margin-top: 1rem;">+ Ajouter une relation</button>
                </div>
            `;
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }
        
        // Render Timeline view in split panel
        function renderTimelineInSplitPanel(container) {
            const events = project.timeline || [];
            
            if (events.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon"><i data-lucide="calendar-range" style="width:48px;height:48px;stroke-width:1.5;"></i></div>
                        <div class="empty-state-title">Timeline</div>
                        <div class="empty-state-text">Aucun événement dans la chronologie</div>
                        <button class="btn btn-primary" onclick="openAddTimelineModal()" style="margin-top: 1rem;">+ Ajouter un événement</button>
                    </div>
                `;
                if (typeof lucide !== 'undefined') lucide.createIcons();
                return;
            }
            
            // Trier par date si possible
            const sortedEvents = [...events].sort((a, b) => {
                if (a.date && b.date) return new Date(a.date) - new Date(b.date);
                return 0;
            });
            
            const eventsHTML = sortedEvents.map((event, index) => `
                <div style="display: flex; gap: 1rem; margin-bottom: 1.5rem;">
                    <div style="display: flex; flex-direction: column; align-items: center;">
                        <div style="width: 12px; height: 12px; background: var(--primary-color); border-radius: 50%;"></div>
                        ${index < sortedEvents.length - 1 ? '<div style="width: 2px; flex: 1; background: var(--border-color);"></div>' : ''}
                    </div>
                    <div style="flex: 1; background: var(--bg-secondary); padding: 1rem; border-radius: 8px;">
                        <div style="font-weight: 600;">${event.title}</div>
                        ${event.date ? `<div style="font-size: 0.85rem; color: var(--primary-color); margin-top: 0.25rem;">${event.date}</div>` : ''}
                        ${event.description ? `<div style="font-size: 0.9rem; color: var(--text-muted); margin-top: 0.5rem;">${event.description}</div>` : ''}
                    </div>
                </div>
            `).join('');
            
            container.innerHTML = `
                <div style="padding: 1.5rem;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
                        <h3 style="margin: 0;"><i data-lucide="calendar-range" style="width:18px;height:18px;vertical-align:middle;margin-right:6px;"></i>Chronologie</h3>
                        <button class="btn btn-small" onclick="openAddTimelineModal()">+ Événement</button>
                    </div>
                    <div>${eventsHTML}</div>
                </div>
            `;
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }
        
        // View selector for split panels
        let currentSplitSelectorPanel = null;
        
        function openSplitViewSelector(panel) {
            currentSplitSelectorPanel = panel;
            
            const content = document.getElementById('splitSelectorContent');
            if (!content) return;
            
            const currentView = panel === 'left' ? splitViewState.left.view : splitViewState.right.view;
            
            const views = [
                { id: 'editor', label: 'Structure', icon: 'pen-line', desc: 'Écrire vos scènes' },
                { id: 'characters', label: 'Personnages', icon: 'users', desc: 'Fiches personnages' },
                { id: 'world', label: 'Univers', icon: 'globe', desc: 'Lieux et éléments' },
                { id: 'notes', label: 'Notes', icon: 'sticky-note', desc: 'Vos notes' },
                { id: 'codex', label: 'Codex', icon: 'book-open', desc: 'Encyclopédie' },
                { id: 'corkboard', label: 'Tableau', icon: 'layout-grid', desc: 'Vue tableau liège' },
                { id: 'mindmap', label: 'Mindmap', icon: 'git-branch', desc: 'Carte mentale' },
                { id: 'plot', label: 'Intrigue', icon: 'trending-up', desc: 'Arcs narratifs' },
                { id: 'relations', label: 'Relations', icon: 'heart-handshake', desc: 'Liens entre personnages' },
                { id: 'map', label: 'Carte', icon: 'map', desc: 'Carte du monde' },
                { id: 'timelineviz', label: 'Timeline Métro', icon: 'train-track', desc: 'Timeline visuelle' },
                { id: 'timeline', label: 'Timeline', icon: 'calendar-range', desc: 'Timeline classique' },
                { id: 'stats', label: 'Statistiques', icon: 'bar-chart-3', desc: 'Stats du projet' },
                { id: 'analysis', label: 'Analyse', icon: 'trending-up', desc: 'Analyse du texte' },
                { id: 'versions', label: 'Versions', icon: 'file-clock', desc: 'Versions des scènes' },
                { id: 'todos', label: 'TODOs', icon: 'list-todo', desc: 'Liste des tâches' }
            ];
            
            content.innerHTML = `
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.5rem; padding: 0.5rem;">
                    ${views.map(v => `
                        <div class="split-view-option ${currentView === v.id ? 'active' : ''}" 
                             onclick="selectSplitPanelView('${v.id}')"
                             style="display: flex; flex-direction: column; align-items: center; gap: 0.5rem; padding: 1rem 0.5rem; border-radius: 8px; cursor: pointer; background: ${currentView === v.id ? 'var(--primary-color)' : 'var(--bg-secondary)'}; color: ${currentView === v.id ? 'white' : 'var(--text-primary)'}; transition: all 0.15s; text-align: center;">
                            <i data-lucide="${v.icon}" style="width:28px;height:28px;"></i>
                            <div>
                                <div style="font-weight: 600; font-size: 0.9rem;">${v.label}</div>
                                <div style="font-size: 0.7rem; opacity: 0.7; margin-top: 0.25rem;">${v.desc}</div>
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
            
            document.getElementById('splitSelectorModal').classList.add('active');
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }
        
        function selectSplitPanelView(view) {
            if (!currentSplitSelectorPanel) return;
            
            switchSplitPanelView(currentSplitSelectorPanel, view);
            closeModal('splitSelectorModal');
        }
        
        // Handle scene selection in split view
        function openSceneInSplitPanel(actId, chapterId, sceneId) {
            if (!splitViewActive) return;
            
            const state = splitActivePanel === 'left' ? splitViewState.left : splitViewState.right;
            
            // Only update if the active panel is showing editor view
            if (state.view === 'editor') {
                state.actId = actId;
                state.chapterId = chapterId;
                state.sceneId = sceneId;
                
                // Also update global current IDs
                currentActId = actId;
                currentChapterId = chapterId;
                currentSceneId = sceneId;
                
                renderSplitPanelViewContent(splitActivePanel);
                saveSplitViewState();
            }
        }
        
        // Handle character selection in split view
        function openCharacterInSplitPanel(charId) {
            if (!splitViewActive) return;
            
            const state = splitActivePanel === 'left' ? splitViewState.left : splitViewState.right;
            
            if (state.view === 'characters') {
                state.characterId = charId;
                renderSplitPanelViewContent(splitActivePanel);
                saveSplitViewState();
            }
        }
        
        // Handle world element selection in split view
        function openWorldElementInSplitPanel(elemId) {
            if (!splitViewActive) return;
            
            const state = splitActivePanel === 'left' ? splitViewState.left : splitViewState.right;
            
            if (state.view === 'world') {
                state.worldId = elemId;
                renderSplitPanelViewContent(splitActivePanel);
                saveSplitViewState();
            }
        }
        
        // Handle note selection in split view  
        function openNoteInSplitPanel(noteId) {
            if (!splitViewActive) return;
            
            const state = splitActivePanel === 'left' ? splitViewState.left : splitViewState.right;
            
            if (state.view === 'notes') {
                state.noteId = noteId;
                renderSplitPanelViewContent(splitActivePanel);
                saveSplitViewState();
            }
        }
        
        function updateSplitSceneContent(editor) {
            const sceneId = parseInt(editor.dataset.sceneId);
            const chapterId = parseInt(editor.dataset.chapterId);
            const actId = parseInt(editor.dataset.actId);
            const panel = editor.dataset.panel;
            
            const act = project.acts.find(a => a.id === actId);
            if (!act) return;
            const chapter = act.chapters.find(c => c.id === chapterId);
            if (!chapter) return;
            const scene = chapter.scenes.find(s => s.id === sceneId);
            if (!scene) return;
            
            scene.content = editor.innerHTML;
            const wordCount = getWordCount(editor.innerHTML);
            scene.wordCount = wordCount;
            
            // Update word count display
            const wcDisplay = document.querySelector(`.split-word-count-${panel}`);
            if (wcDisplay) wcDisplay.textContent = wordCount;
            
            saveProject();
        }
        
        function updateSplitNoteContent(textarea) {
            const noteId = parseInt(textarea.dataset.noteId);
            const note = project.notes?.find(n => n.id === noteId);
            if (note) {
                note.content = textarea.value;
                saveProject();
            }
        }
        
        // Resizer functionality
        let isResizing = false;
        
        function startSplitResize(e) {
            isResizing = true;
            
            const resizer = document.getElementById('splitResizer');
            if (resizer) resizer.classList.add('dragging');
            
            document.body.style.cursor = 'col-resize';
            document.body.style.userSelect = 'none';
            
            document.addEventListener('mousemove', doSplitResize);
            document.addEventListener('mouseup', stopSplitResize);
            document.addEventListener('touchmove', doSplitResize, { passive: false });
            document.addEventListener('touchend', stopSplitResize);
            
            e.preventDefault();
        }
        
        function doSplitResize(e) {
            if (!isResizing) return;
            
            const container = document.getElementById('splitViewContainer');
            if (!container) return;
            
            const currentX = e.clientX || (e.touches && e.touches[0].clientX);
            const containerRect = container.getBoundingClientRect();
            const containerWidth = containerRect.width;
            
            let newRatio = ((currentX - containerRect.left) / containerWidth) * 100;
            newRatio = Math.max(20, Math.min(80, newRatio));
            
            splitViewState.ratio = newRatio;
            
            const leftPanel = document.getElementById('splitPanelLeft');
            const rightPanel = document.getElementById('splitPanelRight');
            
            if (leftPanel) leftPanel.style.flex = newRatio;
            if (rightPanel) rightPanel.style.flex = 100 - newRatio;
            
            e.preventDefault();
        }
        
        function stopSplitResize() {
            isResizing = false;
            
            const resizer = document.getElementById('splitResizer');
            if (resizer) resizer.classList.remove('dragging');
            
            document.body.style.cursor = '';
            document.body.style.userSelect = '';
            
            document.removeEventListener('mousemove', doSplitResize);
            document.removeEventListener('mouseup', stopSplitResize);
            document.removeEventListener('touchmove', doSplitResize);
            document.removeEventListener('touchend', stopSplitResize);
            
            saveSplitViewState();
        }
        
        function saveSplitViewState() {
            if (splitViewState.persistOnReload) {
                localStorage.setItem('plume_splitViewState', JSON.stringify({
                    active: splitViewActive,
                    activePanel: splitActivePanel,
                    state: splitViewState
                }));
            }
        }
        
        function loadSplitViewState() {
            const saved = localStorage.getItem('plume_splitViewState');
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    if (data.state && data.state.persistOnReload) {
                        splitViewState = { ...splitViewState, ...data.state };
                        splitActivePanel = data.activePanel || 'left';
                        if (data.active) {
                            splitViewActive = true;
                            setTimeout(() => {
                                renderSplitView();
                                updateSplitToggleButton();
                            }, 500);
                        }
                    }
                } catch (e) {
                    console.error('Error loading split view state:', e);
                }
            }
        }
        
        // Legacy function for compatibility
        function openCharacterBeside(charId) {
            if (!splitViewActive) {
                activateSplitView();
            }
            
            // Set right panel to characters view with this character
            splitViewState.right.view = 'characters';
            splitViewState.right.characterId = charId;
            splitActivePanel = 'right';
            
            renderSplitView();
            showNotification('Personnage ouvert dans le panneau droit');
        }

        function updateCharacterField(id, field, value) {
            const character = project.characters.find(c => c.id === id);
            if (character) {
                character[field] = value;
                saveProject();
                renderCharactersList();
            }
        }

        // World Management
        function openAddWorldModal() {
            document.getElementById('addWorldModal').classList.add('active');
            setTimeout(() => document.getElementById('worldNameInput').focus(), 100);
        }

        function addWorldElement() {
            const name = document.getElementById('worldNameInput').value.trim();
            const type = document.getElementById('worldTypeInput').value;
            const description = document.getElementById('worldDescInput').value.trim();
            
            if (!name) return;

            const element = {
                id: Date.now(),
                name: name,
                type: type,
                description: description || '',
                details: '',
                history: '',
                notes: '',
                linkedScenes: [], // Array of scene IDs where this element appears
                linkedElements: [] // Array of {type, id} for related characters/timeline/etc
            };

            project.world.push(element);
            
            // Clear inputs
            document.getElementById('worldNameInput').value = '';
            document.getElementById('worldDescInput').value = '';
            
            closeModal('addWorldModal');
            saveProject();
            renderWorldList();
        }

        function deleteWorldElement(id) {
            if (!confirm('Êtes-vous sûr de vouloir supprimer cet élément ?')) return;
            project.world = project.world.filter(w => w.id !== id);
            saveProject();
            renderWorldList();
            showEmptyState();
        }

        function renderWorldList() {
            const container = document.getElementById('worldList');
            
            if (project.world.length === 0) {
                container.innerHTML = '<div style="padding: 1rem; text-align: center; color: var(--text-muted); font-size: 0.85rem;">Aucun élément</div>';
                return;
            }
            
            // Group by type
            const groups = {};
            project.world.forEach(elem => {
                const type = elem.type || 'Autre';
                if (!groups[type]) groups[type] = [];
                groups[type].push(elem);
            });
            
            // Icons for each type
            const typeIcons = {
                'Lieu': '📍',
                'Objet': '🔮',
                'Concept': '💡',
                'Organisation': '🏛️',
                'Événement': '📅',
                'Autre': '📄'
            };
            
            // Get collapsed state from localStorage
            const collapsedState = JSON.parse(localStorage.getItem('plume_treeview_collapsed') || '{}');
            
            let html = '';
            Object.keys(groups).sort().forEach(type => {
                const groupKey = 'world_' + type;
                const isCollapsed = collapsedState[groupKey] === true;
                
                // Sort elements alphabetically within each group
                const sortedElements = [...groups[type]].sort((a, b) => {
                    return (a.name || '').toLowerCase().localeCompare((b.name || '').toLowerCase(), 'fr');
                });
                
                html += `
                    <div class="treeview-group">
                        <div class="treeview-header" onclick="toggleTreeviewGroup('${groupKey}')">
                            <i data-lucide="${isCollapsed ? 'chevron-right' : 'chevron-down'}" class="treeview-chevron"></i>
                            <span class="treeview-label">${type}</span>
                            <span class="treeview-count">${groups[type].length}</span>
                        </div>
                        <div class="treeview-children ${isCollapsed ? 'collapsed' : ''}">
                            ${sortedElements.map(elem => `
                                <div class="treeview-item" onclick="openWorldDetail(${elem.id})">
                                    <span class="treeview-item-icon">${typeIcons[type] || '📄'}</span>
                                    <span class="treeview-item-label">${elem.name}</span>
                                    <button class="treeview-item-delete" onclick="event.stopPropagation(); deleteWorldElement(${elem.id})" title="Supprimer">×</button>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            });

            container.innerHTML = html;
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }

        function renderElementLinkedScenes(element) {
            const scenes = findScenesWithElement(element.id);
            if (scenes.length === 0) return '';

            return `
                <div class="detail-section">
                    <div class="detail-section-title"><i data-lucide="file-text" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Apparaît dans ${scenes.length} scène(s)</div>
                    <div class="quick-links">
                        ${scenes.map(scene => {
                            const actIndex = project.acts.findIndex(a => a.id === scene.actId);
                            const act = project.acts[actIndex];
                            const chapterIndex = act.chapters.findIndex(c => c.id === scene.chapterId);
                            const actNumber = toRoman(actIndex + 1);
                            const chapterNumber = chapterIndex + 1;
                            const breadcrumb = `Acte ${actNumber} › Chapitre ${chapterNumber} › ${scene.sceneTitle}`;
                            
                            return `
                            <span class="link-badge" onclick="openScene(${scene.actId}, ${scene.chapterId}, ${scene.sceneId})" title="${scene.actTitle} - ${scene.chapterTitle}">
                                ${breadcrumb}
                            </span>
                        `;
                        }).join('')}
                    </div>
                </div>
            `;
        }

        function openWorldDetail(id) {
            const element = project.world.find(w => w.id === id);
            if (!element) return;
            
            // Handle split view mode
            if (splitViewActive) {
                const state = splitActivePanel === 'left' ? splitViewState.left : splitViewState.right;
                if (state.view === 'world') {
                    state.worldId = id;
                    renderSplitPanelViewContent(splitActivePanel);
                    saveSplitViewState();
                    return;
                }
            }

            const editorView = document.getElementById('editorView');
            editorView.innerHTML = `
                <div class="detail-view">
                    <div class="detail-header">
                        <div style="display: flex; align-items: center; gap: 1rem;">
                            <div class="detail-title">${element.name}</div>
                            <span style="font-size: 0.9rem; padding: 0.5rem 1rem; background: var(--accent-gold); color: var(--bg-primary); border-radius: 2px;">${element.type}</span>
                        </div>
                        <div style="display: flex; gap: 0.5rem;">
                            <button class="btn btn-small" onclick="showReferencesForElement(${id})"><i data-lucide="link" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Voir les références</button>
                            <button class="btn" onclick="switchView('editor')">← Retour à l'éditeur</button>
                        </div>
                    </div>
                    
                    ${renderElementLinkedScenes(element)}
                    
                    <div class="detail-section">
                        <div class="detail-section-title">Informations de base</div>
                        <div class="detail-field">
                            <div class="detail-label">Nom</div>
                            <input type="text" class="form-input" value="${element.name}" 
                                   onchange="updateWorldField(${id}, 'name', this.value)">
                        </div>
                    </div>

                    <div class="detail-section">
                        <div class="detail-section-title">Type</div>
                        <select class="form-input" onchange="updateWorldField(${id}, 'type', this.value)">
                            <option value="Lieu" ${element.type === 'Lieu' ? 'selected' : ''}>Lieu</option>
                            <option value="Objet" ${element.type === 'Objet' ? 'selected' : ''}>Objet</option>
                            <option value="Concept" ${element.type === 'Concept' ? 'selected' : ''}>Concept</option>
                            <option value="Organisation" ${element.type === 'Organisation' ? 'selected' : ''}>Organisation</option>
                            <option value="Événement" ${element.type === 'Événement' ? 'selected' : ''}>Événement</option>
                        </select>
                    </div>

                    <div class="detail-section">
                        <div class="detail-section-title">Description</div>
                        <textarea class="form-input" rows="6" 
                                  onchange="updateWorldField(${id}, 'description', this.value)">${element.description}</textarea>
                    </div>

                    <div class="detail-section">
                        <div class="detail-section-title">Détails</div>
                        <textarea class="form-input" rows="6" 
                                  onchange="updateWorldField(${id}, 'details', this.value)">${element.details}</textarea>
                    </div>

                    <div class="detail-section">
                        <div class="detail-section-title">Histoire</div>
                        <textarea class="form-input" rows="6" 
                                  onchange="updateWorldField(${id}, 'history', this.value)">${element.history}</textarea>
                    </div>

                    <div class="detail-section">
                        <div class="detail-section-title">Notes</div>
                        <textarea class="form-input" rows="4" 
                                  onchange="updateWorldField(${id}, 'notes', this.value)">${element.notes}</textarea>
                    </div>
                </div>
            `;
        }

        function updateWorldField(id, field, value) {
            const element = project.world.find(w => w.id === id);
            if (element) {
                element[field] = value;
                saveProject();
                renderWorldList();
            }
        }

        // Timeline Management
        function openAddTimelineModal() {
            document.getElementById('addTimelineModal').classList.add('active');
            setTimeout(() => document.getElementById('timelineTitleInput').focus(), 100);
        }

        function addTimelineEvent() {
            const title = document.getElementById('timelineTitleInput').value.trim();
            const date = document.getElementById('timelineDateInput').value.trim();
            const location = document.getElementById('timelineLocationInput').value.trim();
            const characters = document.getElementById('timelineCharactersInput').value.trim();
            const description = document.getElementById('timelineDescInput').value.trim();
            
            if (!title) return;

            const event = {
                id: Date.now(),
                title: title,
                date: date || '',
                location: location || '',
                characters: characters || '',
                description: description || '',
                order: project.timeline.length, // For manual reordering
                consequences: '',
                notes: ''
            };

            project.timeline.push(event);
            
            // Clear inputs
            document.getElementById('timelineTitleInput').value = '';
            document.getElementById('timelineDateInput').value = '';
            document.getElementById('timelineLocationInput').value = '';
            document.getElementById('timelineCharactersInput').value = '';
            document.getElementById('timelineDescInput').value = '';
            
            closeModal('addTimelineModal');
            saveProject();
            renderTimelineList();
        }

        function deleteTimelineEvent(id) {
            if (!confirm('Êtes-vous sûr de vouloir supprimer cet événement ?')) return;
            project.timeline = project.timeline.filter(e => e.id !== id);
            saveProject();
            renderTimelineList();
            showEmptyState();
        }

        function renderTimelineList() {
            const container = document.getElementById('timelineList');
            
            if (project.timeline.length === 0) {
                container.innerHTML = '<div style="padding: 2rem; text-align: center; color: var(--text-muted);">Aucun événement</div>';
                return;
            }

            // Sort by order field for manual ordering
            const sortedTimeline = [...project.timeline].sort((a, b) => a.order - b.order);

            container.innerHTML = `
                <div class="timeline-container">
                    <div class="timeline-line"></div>
                    ${sortedTimeline.map(event => `
                        <div class="timeline-event" onclick="openTimelineDetail(${event.id})">
                            <div style="display: flex; justify-content: space-between; align-items: start;">
                                <div style="flex: 1;">
                                    ${event.date ? `<div class="timeline-date">📅 ${event.date}</div>` : ''}
                                    <div class="timeline-title">${event.title}</div>
                                    <div class="timeline-meta">
                                        ${event.location ? `<div class="timeline-meta-item">📍 ${event.location}</div>` : ''}
                                        ${event.characters ? `<div class="timeline-meta-item"><i data-lucide="users" style="width:12px;height:12px;vertical-align:middle;margin-right:4px;"></i>${event.characters}</div>` : ''}
                                    </div>
                                    ${event.description ? `<div class="timeline-description">${event.description}</div>` : ''}
                                </div>
                                <button class="btn btn-icon btn-small" onclick="event.stopPropagation(); deleteTimelineEvent(${event.id})" title="Supprimer">×</button>
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        function openTimelineDetail(id) {
            const event = project.timeline.find(e => e.id === id);
            if (!event) return;

            const editorView = document.getElementById('editorView');
            editorView.innerHTML = `
                <div class="detail-view">
                    <div class="detail-header">
                        <div class="detail-title">${event.title}</div>
                        <button class="btn" onclick="switchView('editor')">← Retour à l'éditeur</button>
                    </div>
                    
                    <div class="detail-section">
                        <div class="detail-section-title">Informations</div>
                        <div class="detail-field">
                            <div class="detail-label">Date / Moment</div>
                            <input type="text" class="form-input" value="${event.date}" 
                                   onchange="updateTimelineField(${id}, 'date', this.value)">
                        </div>
                        <div class="detail-field">
                            <div class="detail-label">Localisation</div>
                            <input type="text" class="form-input" value="${event.location}" 
                                   onchange="updateTimelineField(${id}, 'location', this.value)">
                        </div>
                        <div class="detail-field">
                            <div class="detail-label">Personnages impliqués</div>
                            <input type="text" class="form-input" value="${event.characters}" 
                                   onchange="updateTimelineField(${id}, 'characters', this.value)">
                        </div>
                    </div>

                    <div class="detail-section">
                        <div class="detail-section-title">Description</div>
                        <textarea class="form-input" rows="6" 
                                  onchange="updateTimelineField(${id}, 'description', this.value)">${event.description}</textarea>
                    </div>

                    <div class="detail-section">
                        <div class="detail-section-title">Conséquences</div>
                        <textarea class="form-input" rows="6" 
                                  onchange="updateTimelineField(${id}, 'consequences', this.value)">${event.consequences}</textarea>
                        <small style="color: var(--text-muted); font-style: italic;">Qu'est-ce que cet événement déclenche ou change dans l'histoire ?</small>
                    </div>

                    <div class="detail-section">
                        <div class="detail-section-title">Notes</div>
                        <textarea class="form-input" rows="4" 
                                  onchange="updateTimelineField(${id}, 'notes', this.value)">${event.notes}</textarea>
                    </div>
                </div>
            `;
        }

        function updateTimelineField(id, field, value) {
            const event = project.timeline.find(e => e.id === id);
            if (event) {
                event[field] = value;
                saveProject();
                renderTimelineList();
            }
        }

        // Notes Management
        function openAddNoteModal() {
            document.getElementById('addNoteModal').classList.add('active');
            setTimeout(() => document.getElementById('noteTitleInput').focus(), 100);
        }

        function addNote() {
            const title = document.getElementById('noteTitleInput').value.trim();
            const category = document.getElementById('noteCategoryInput').value;
            const tags = document.getElementById('noteTagsInput').value.trim();
            const content = document.getElementById('noteContentInput').value.trim();
            
            if (!title) return;

            const note = {
                id: Date.now(),
                title: title,
                category: category,
                tags: tags ? tags.split(',').map(t => t.trim()).filter(t => t) : [],
                content: content || '',
                medias: [], // Support pour les médias: {type: 'url'|'image'|'audio', url: '', title: ''}
                createdAt: new Date().toISOString(),
                updatedAt: new Date().toISOString()
            };

            project.notes.push(note);
            
            // Clear inputs
            document.getElementById('noteTitleInput').value = '';
            document.getElementById('noteTagsInput').value = '';
            document.getElementById('noteContentInput').value = '';
            
            closeModal('addNoteModal');
            saveProject();
            renderNotesList();
        }

        function deleteNote(id) {
            if (!confirm('Êtes-vous sûr de vouloir supprimer cette note ?')) return;
            project.notes = project.notes.filter(n => n.id !== id);
            saveProject();
            renderNotesList();
            showEmptyState();
        }

        // Expanded state for notes categories
        let expandedNoteCategories = new Set(['Idée', 'Recherche', 'Référence', 'A faire', 'Question', 'Autre']);

        function renderNotesList() {
            const container = document.getElementById('notesList');
            
            if (project.notes.length === 0) {
                container.innerHTML = '<div style="padding: 1rem; text-align: center; color: var(--text-muted); font-size: 0.85rem;">Aucune note</div>';
                return;
            }

            // Group notes by category
            const categories = {};
            const categoryIcons = {
                'Idée': '💡',
                'Recherche': '🔍',
                'Référence': '📚',
                'A faire': '✅',
                'Question': '❓',
                'Autre': '📝'
            };
            
            project.notes.forEach(note => {
                const cat = note.category || 'Autre';
                if (!categories[cat]) categories[cat] = [];
                categories[cat].push(note);
            });

            // Sort notes within categories alphabetically by title
            Object.keys(categories).forEach(cat => {
                categories[cat].sort((a, b) => {
                    return (a.title || '').toLowerCase().localeCompare((b.title || '').toLowerCase(), 'fr');
                });
            });

            let html = '';

            // Render each category as a collapsible group
            const categoryOrder = ['Idée', 'Recherche', 'Référence', 'A faire', 'Question', 'Autre'];
            categoryOrder.forEach(cat => {
                if (!categories[cat] || categories[cat].length === 0) return;
                
                const isExpanded = expandedNoteCategories.has(cat);
                const icon = categoryIcons[cat] || '📝';
                
                html += `
                    <div class="treeview-group" data-category="${cat}">
                        <div class="treeview-header" onclick="toggleNoteCategory('${cat}')">
                            <span class="treeview-icon ${isExpanded ? 'expanded' : ''}">▶</span>
                            <span class="treeview-category-icon">${icon}</span>
                            <span class="treeview-title">${cat}</span>
                            <span class="treeview-count">${categories[cat].length}</span>
                        </div>
                        <div class="treeview-children ${isExpanded ? '' : 'collapsed'}">
                            ${categories[cat].map(note => {
                                const hasMedia = note.medias && note.medias.length > 0;
                                const mediaIcon = hasMedia ? '📎' : '';
                                return `
                                    <div class="treeview-item" onclick="openNoteDetail(${note.id})">
                                        <span class="treeview-item-title">${note.title}</span>
                                        ${mediaIcon ? `<span class="treeview-media-icon">${mediaIcon}</span>` : ''}
                                        <button class="btn btn-icon btn-small delete-btn" onclick="event.stopPropagation(); deleteNote(${note.id})" title="Supprimer">×</button>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                `;
            });

            container.innerHTML = html;
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }

        function toggleNoteCategory(category) {
            if (expandedNoteCategories.has(category)) {
                expandedNoteCategories.delete(category);
            } else {
                expandedNoteCategories.add(category);
            }
            renderNotesList();
        }

        function expandAllNoteCategories() {
            expandedNoteCategories = new Set(['Idée', 'Recherche', 'Référence', 'A faire', 'Question', 'Autre']);
            renderNotesList();
        }

        function collapseAllNoteCategories() {
            expandedNoteCategories.clear();
            renderNotesList();
        }

        function openNoteDetail(id) {
            const note = project.notes.find(n => n.id === id);
            if (!note) return;
            
            // Ensure medias array exists
            if (!note.medias) note.medias = [];
            
            // Handle split view mode
            if (splitViewActive) {
                const state = splitActivePanel === 'left' ? splitViewState.left : splitViewState.right;
                if (state.view === 'notes') {
                    state.noteId = id;
                    renderSplitPanelViewContent(splitActivePanel);
                    saveSplitViewState();
                    return;
                }
            }

            const editorView = document.getElementById('editorView');
            editorView.innerHTML = `
                <div class="detail-view">
                    <div class="detail-header">
                        <div style="display: flex; align-items: center; gap: 1rem; flex: 1;">
                            <input type="text" class="form-input" value="${note.title}" 
                                   style="font-size: 1.8rem; font-weight: 600; font-family: 'Noto Serif JP', serif; padding: 0.5rem;"
                                   onchange="updateNoteField(${id}, 'title', this.value)"
                                   placeholder="Titre de la note">
                            <span style="font-size: 0.8rem; padding: 0.4rem 0.8rem; background: var(--accent-gold); color: var(--bg-primary); border-radius: 2px;">${note.category}</span>
                        </div>
                        <button class="btn" onclick="switchView('editor')">← Retour à l'éditeur</button>
                    </div>
                    
                    <div class="detail-section">
                        <div class="detail-section-title">Catégorie</div>
                        <select class="form-input" onchange="updateNoteField(${id}, 'category', this.value)">
                            <option value="Recherche" ${note.category === 'Recherche' ? 'selected' : ''}>Recherche</option>
                            <option value="Idée" ${note.category === 'Idée' ? 'selected' : ''}>Idée</option>
                            <option value="Référence" ${note.category === 'Référence' ? 'selected' : ''}>Référence</option>
                            <option value="A faire" ${note.category === 'A faire' ? 'selected' : ''}>À faire</option>
                            <option value="Question" ${note.category === 'Question' ? 'selected' : ''}>Question</option>
                            <option value="Autre" ${note.category === 'Autre' ? 'selected' : ''}>Autre</option>
                        </select>
                    </div>

                    <div class="detail-section">
                        <div class="detail-section-title">Tags</div>
                        <input type="text" class="form-input" value="${note.tags.join(', ')}" 
                               onchange="updateNoteTags(${id}, this.value)">
                        <small style="color: var(--text-muted); font-style: italic;">Séparez les tags par des virgules</small>
                    </div>

                    <div class="detail-section">
                        <div class="detail-section-title">Contenu</div>
                        <textarea class="form-input" rows="12" 
                                  oninput="updateNoteField(${id}, 'content', this.value)">${note.content}</textarea>
                    </div>

                    <div class="detail-section">
                        <div class="detail-section-title">
                            Médias
                            <button class="btn btn-small" onclick="openAddMediaModal(${id})" style="margin-left: 1rem;">
                                <i data-lucide="plus" style="width:14px;height:14px;margin-right:0.3rem;"></i>Ajouter
                            </button>
                        </div>
                        <div class="note-medias-container" id="noteMedias-${id}">
                            ${renderNoteMedias(note)}
                        </div>
                    </div>

                    <div style="font-size: 0.8rem; color: var(--text-muted); margin-top: 2rem; font-family: 'Source Code Pro', monospace;">
                        Créée le ${new Date(note.createdAt).toLocaleDateString('fr-FR')} • 
                        Modifiée le ${new Date(note.updatedAt).toLocaleDateString('fr-FR')}
                    </div>
                </div>
            `;
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }

        function renderNoteMedias(note) {
            if (!note.medias || note.medias.length === 0) {
                return '<div style="color: var(--text-muted); font-style: italic; padding: 1rem; text-align: center; border: 1px dashed var(--border-color); border-radius: 8px;">Aucun média ajouté</div>';
            }

            return `<div class="note-medias-grid">${note.medias.map((media, index) => {
                if (media.type === 'image') {
                    return `
                        <div class="note-media-item note-media-image">
                            <img src="${media.url}" alt="${media.title || 'Image'}" onclick="window.open('${media.url}', '_blank')">
                            <div class="note-media-overlay">
                                <span class="note-media-title">${media.title || 'Image'}</span>
                                <button class="note-media-delete" onclick="deleteNoteMedia(${note.id}, ${index})">×</button>
                            </div>
                        </div>
                    `;
                } else if (media.type === 'audio') {
                    return `
                        <div class="note-media-item note-media-audio">
                            <div class="note-media-audio-icon">🎵</div>
                            <div class="note-media-audio-info">
                                <span class="note-media-title">${media.title || 'Audio'}</span>
                                <audio controls src="${media.url}" style="width: 100%; margin-top: 0.5rem;"></audio>
                            </div>
                            <button class="note-media-delete" onclick="deleteNoteMedia(${note.id}, ${index})">×</button>
                        </div>
                    `;
                } else if (media.type === 'url') {
                    const domain = extractDomain(media.url);
                    return `
                        <div class="note-media-item note-media-url" onclick="window.open('${media.url}', '_blank')">
                            <div class="note-media-url-icon">🔗</div>
                            <div class="note-media-url-info">
                                <span class="note-media-title">${media.title || media.url}</span>
                                <span class="note-media-domain">${domain}</span>
                            </div>
                            <button class="note-media-delete" onclick="event.stopPropagation(); deleteNoteMedia(${note.id}, ${index})">×</button>
                        </div>
                    `;
                } else if (media.type === 'youtube') {
                    const videoId = extractYoutubeId(media.url);
                    return `
                        <div class="note-media-item note-media-youtube">
                            <div class="note-media-youtube-thumb" onclick="window.open('${media.url}', '_blank')">
                                <img src="https://img.youtube.com/vi/${videoId}/mqdefault.jpg" alt="YouTube">
                                <div class="note-media-youtube-play">▶</div>
                            </div>
                            <div class="note-media-overlay">
                                <span class="note-media-title">${media.title || 'Vidéo YouTube'}</span>
                                <button class="note-media-delete" onclick="deleteNoteMedia(${note.id}, ${index})">×</button>
                            </div>
                        </div>
                    `;
                }
                return '';
            }).join('')}</div>`;
        }

        function extractDomain(url) {
            try {
                const urlObj = new URL(url);
                return urlObj.hostname.replace('www.', '');
            } catch {
                return url;
            }
        }

        function extractYoutubeId(url) {
            const match = url.match(/(?:youtube\.com\/(?:watch\?v=|embed\/)|youtu\.be\/)([^&\s?]+)/);
            return match ? match[1] : '';
        }

        function openAddMediaModal(noteId) {
            // Create modal dynamically
            let modal = document.getElementById('addMediaModal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'addMediaModal';
                modal.className = 'modal';
                document.body.appendChild(modal);
            }
            
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 500px;">
                    <div class="modal-header">
                        <h3>Ajouter un média</h3>
                        <button class="modal-close" onclick="closeModal('addMediaModal')">×</button>
                    </div>
                    <div class="modal-body">
                        <div class="form-group">
                            <label class="form-label">Type de média</label>
                            <select id="mediaTypeInput" class="form-input" onchange="updateMediaInputPlaceholder()">
                                <option value="url">🔗 Lien URL</option>
                                <option value="image">🖼️ Image (URL)</option>
                                <option value="audio">🎵 Audio (URL)</option>
                                <option value="youtube">▶️ Vidéo YouTube</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label class="form-label">Titre (optionnel)</label>
                            <input type="text" id="mediaTitleInput" class="form-input" placeholder="Titre du média">
                        </div>
                        <div class="form-group">
                            <label class="form-label">URL</label>
                            <input type="text" id="mediaUrlInput" class="form-input" placeholder="https://...">
                        </div>
                        <div id="mediaPreview" style="margin-top: 1rem;"></div>
                    </div>
                    <div class="modal-footer">
                        <button class="btn" onclick="closeModal('addMediaModal')">Annuler</button>
                        <button class="btn btn-primary" onclick="addNoteMedia(${noteId})">Ajouter</button>
                    </div>
                </div>
            `;
            modal.classList.add('active');
        }

        function updateMediaInputPlaceholder() {
            const type = document.getElementById('mediaTypeInput').value;
            const urlInput = document.getElementById('mediaUrlInput');
            const placeholders = {
                'url': 'https://example.com/article',
                'image': 'https://example.com/image.jpg',
                'audio': 'https://example.com/music.mp3',
                'youtube': 'https://www.youtube.com/watch?v=...'
            };
            urlInput.placeholder = placeholders[type] || 'https://...';
        }

        function addNoteMedia(noteId) {
            const type = document.getElementById('mediaTypeInput').value;
            const title = document.getElementById('mediaTitleInput').value.trim();
            const url = document.getElementById('mediaUrlInput').value.trim();
            
            if (!url) {
                alert('Veuillez entrer une URL');
                return;
            }

            const note = project.notes.find(n => n.id === noteId);
            if (!note) return;

            if (!note.medias) note.medias = [];
            
            note.medias.push({
                type: type,
                title: title || '',
                url: url,
                addedAt: new Date().toISOString()
            });

            note.updatedAt = new Date().toISOString();
            saveProject();
            closeModal('addMediaModal');
            openNoteDetail(noteId);
            renderNotesList();
        }

        function deleteNoteMedia(noteId, mediaIndex) {
            if (!confirm('Supprimer ce média ?')) return;
            
            const note = project.notes.find(n => n.id === noteId);
            if (!note || !note.medias) return;

            note.medias.splice(mediaIndex, 1);
            note.updatedAt = new Date().toISOString();
            saveProject();
            openNoteDetail(noteId);
            renderNotesList();
        }

        function updateNoteField(id, field, value) {
            const note = project.notes.find(n => n.id === id);
            if (note) {
                note[field] = value;
                note.updatedAt = new Date().toISOString();
                saveProject();
                renderNotesList();
            }
        }

        function updateNoteTags(id, tagsString) {
            const note = project.notes.find(n => n.id === id);
            if (note) {
                note.tags = tagsString.split(',').map(t => t.trim()).filter(t => t);
                note.updatedAt = new Date().toISOString();
                saveProject();
                renderNotesList();
            }
        }

        // Version Control Management
        function createVersion() {
            const label = prompt('Nom de la version (ex: "Version 1.0", "Avant révision", etc.)');
            if (!label || !label.trim()) return;

            const totalWords = project.acts.reduce((sum, act) => {
                return sum + act.chapters.reduce((chSum, chapter) => {
                    return chSum + chapter.scenes.reduce((sceneSum, scene) => {
                        return sceneSum + getWordCount(scene.content);
                    }, 0);
                }, 0);
            }, 0);

            const version = {
                id: Date.now(),
                label: label.trim(),
                timestamp: new Date().toISOString(),
                wordCount: totalWords,
                snapshot: JSON.parse(JSON.stringify({ 
                    acts: project.acts,
                    characters: project.characters,
                    world: project.world,
                    timeline: project.timeline,
                    notes: project.notes,
                    codex: project.codex
                }))
            };

            project.versions.push(version);
            saveProject();
            renderVersionsList();
            alert('Version créée avec succès !');
        }

        function deleteVersion(id) {
            if (!confirm('Êtes-vous sûr de vouloir supprimer cette version ?')) return;
            project.versions = project.versions.filter(v => v.id !== id);
            saveProject();
            renderVersionsList();
        }

        function restoreVersion(id) {
            if (!confirm('⚠️ ATTENTION: Restaurer cette version va remplacer votre travail actuel. Voulez-vous créer une sauvegarde avant de continuer ?')) {
                return;
            }

            // Create backup of current state
            createVersion();

            const version = project.versions.find(v => v.id === id);
            if (!version) return;

            // Restore snapshot
            project.acts = JSON.parse(JSON.stringify(version.snapshot.acts));
            project.characters = JSON.parse(JSON.stringify(version.snapshot.characters || []));
            project.world = JSON.parse(JSON.stringify(version.snapshot.world || []));
            project.timeline = JSON.parse(JSON.stringify(version.snapshot.timeline || []));
            project.notes = JSON.parse(JSON.stringify(version.snapshot.notes || []));
            project.codex = JSON.parse(JSON.stringify(version.snapshot.codex || []));

            saveProject();
            switchView('editor');
            renderActsList();
            alert('Version restaurée avec succès !');
        }

        function renderVersionsList() {
            const editorView = document.getElementById('editorView');
            if (!editorView) {
                console.error('editorView not found');
                return;
            }
            
            // Sort by most recent first
            const sortedVersions = [...project.versions].sort((a, b) => 
                new Date(b.timestamp) - new Date(a.timestamp)
            );

            editorView.innerHTML = `
                <div style="height: 100%; overflow-y: auto; padding: 2rem 3rem;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 2rem;">
                        <h2 style="color: var(--accent-gold);"><i data-lucide="history" style="width:24px;height:24px;vertical-align:middle;margin-right:8px;"></i>Gestion des Versions</h2>
                        <button class="btn btn-primary" onclick="createVersion()">
                            + Créer une version
                        </button>
                    </div>
                    
                    ${project.versions.length === 0 ? `
                        <div style="text-align: center; padding: 4rem 2rem; color: var(--text-muted);">
                            <div style="font-size: 3rem; margin-bottom: 1rem;">📦</div>
                            <div style="font-size: 1.2rem; margin-bottom: 0.5rem;">Aucune version sauvegardée</div>
                            <div style="font-size: 0.9rem; margin-bottom: 2rem;">
                                Les versions vous permettent de créer des snapshots de votre projet<br>
                                pour revenir à un état antérieur si nécessaire.
                            </div>
                            <button class="btn btn-primary" onclick="createVersion()">
                                Créer votre première version
                            </button>
                        </div>
                    ` : `
                        <div style="display: grid; gap: 1rem;">
                            ${sortedVersions.map(version => `
                                <div style="background: var(--bg-secondary); padding: 1.5rem; border-radius: 8px; border-left: 4px solid var(--accent-gold);">
                                    <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 1rem;">
                                        <div>
                                            <div style="font-size: 1.1rem; font-weight: 600; color: var(--text-primary); margin-bottom: 0.25rem;">
                                                ${version.label}
                                            </div>
                                            <div style="font-size: 0.85rem; color: var(--text-muted);">
                                                ${new Date(version.timestamp).toLocaleString('fr-FR', { 
                                                    dateStyle: 'long', 
                                                    timeStyle: 'short' 
                                                })}
                                            </div>
                                        </div>
                                        <div style="text-align: right;">
                                            <div style="font-size: 1.5rem; font-weight: 700; color: var(--accent-gold);">
                                                ${version.wordCount.toLocaleString('fr-FR')}
                                            </div>
                                            <div style="font-size: 0.75rem; color: var(--text-muted);">
                                                mots
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                                        <button class="btn btn-small" onclick="restoreVersion(${version.id})" 
                                                style="background: var(--accent-gold); color: white; border: none;">
                                            ↺ Restaurer
                                        </button>
                                        <button class="btn btn-small" onclick="compareVersion(${version.id})">
                                            <i data-lucide="git-compare" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Comparer
                                        </button>
                                        <button class="btn btn-small" onclick="deleteVersion(${version.id})" 
                                                style="background: var(--accent-red); color: white; border: none;">
                                            🗑️ Supprimer
                                        </button>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    `}
                </div>
            `;
        }

        function compareVersion(id) {
            const version = project.versions.find(v => v.id === id);
            if (!version) return;

            const currentWords = project.acts.reduce((sum, act) => {
                return sum + act.chapters.reduce((chSum, chapter) => {
                    return chSum + chapter.scenes.reduce((sceneSum, scene) => {
                        return sceneSum + getWordCount(scene.content);
                    }, 0);
                }, 0);
            }, 0);

            const diff = currentWords - version.wordCount;
            const diffText = diff > 0 ? `+${diff}` : diff;

            alert(`Comparaison avec "${version.label}":\n\nVersion sauvegardée: ${version.wordCount.toLocaleString('fr-FR')} mots\nVersion actuelle: ${currentWords.toLocaleString('fr-FR')} mots\nDifférence: ${diffText} mots`);
        }

        // ==========================================
        // SCENE VERSION MANAGEMENT (Versions par scène)
        // ==========================================
        
        let sceneVersionsSidebarVisible = false;
        
        function toggleVersionsSidebar() {
            const sidebar = document.getElementById('sidebarVersions');
            const toggleBtn = document.getElementById('headerVersionsToggle');
            sceneVersionsSidebarVisible = !sceneVersionsSidebarVisible;
            
            if (sceneVersionsSidebarVisible) {
                sidebar.classList.remove('hidden');
                if (toggleBtn) {
                    toggleBtn.classList.add('active');
                    toggleBtn.title = 'Masquer les versions de scène';
                }
            } else {
                sidebar.classList.add('hidden');
                if (toggleBtn) {
                    toggleBtn.classList.remove('active');
                    toggleBtn.title = 'Afficher les versions de scène';
                }
            }
        }
        
        function showVersionsSidebar() {
            const sidebar = document.getElementById('sidebarVersions');
            const toggleBtn = document.getElementById('headerVersionsToggle');
            sceneVersionsSidebarVisible = true;
            sidebar.classList.remove('hidden');
            if (toggleBtn) {
                toggleBtn.classList.add('active');
            }
        }
        
        function getSceneVersions(actId, chapterId, sceneId) {
            const act = project.acts.find(a => a.id === actId);
            if (!act) return [];
            const chapter = act.chapters.find(c => c.id === chapterId);
            if (!chapter) return [];
            const scene = chapter.scenes.find(s => s.id === sceneId);
            if (!scene) return [];
            
            // Ensure versions array exists
            if (!scene.versions) {
                scene.versions = [];
            }
            return scene.versions;
        }
        
        function getCurrentSceneForVersions() {
            if (!currentActId || !currentChapterId || !currentSceneId) return null;
            
            const act = project.acts.find(a => a.id === currentActId);
            if (!act) return null;
            const chapter = act.chapters.find(c => c.id === currentChapterId);
            if (!chapter) return null;
            const scene = chapter.scenes.find(s => s.id === currentSceneId);
            
            return scene ? { act, chapter, scene } : null;
        }
        
        function createSceneVersion() {
            const current = getCurrentSceneForVersions();
            if (!current) {
                alert('Veuillez d\'abord sélectionner une scène.');
                return;
            }
            
            const { scene } = current;
            
            // Ensure versions array exists
            if (!scene.versions) {
                scene.versions = [];
            }
            
            // Sauvegarder le contenu actuel de l'éditeur dans la version active
            const editor = document.getElementById('sceneEditor');
            const currentContent = editor ? editor.innerHTML : (scene.content || '');
            
            // Obtenir les annotations de la version active actuelle (pour les copier)
            const currentAnnotations = getVersionAnnotations(scene);
            
            // Sauvegarder le contenu de la version active actuelle
            const currentActiveVersion = scene.versions.find(v => v.isActive);
            if (currentActiveVersion) {
                currentActiveVersion.content = currentContent;
                currentActiveVersion.wordCount = getWordCount(currentContent);
            }
            
            // Create version - GARDER les mêmes IDs d'annotations car le HTML contient ces IDs
            const versionNumber = scene.versions.length + 1;
            const version = {
                id: Date.now(),
                number: versionNumber,
                label: '',
                content: currentContent,
                wordCount: getWordCount(currentContent),
                createdAt: new Date().toISOString(),
                isActive: false,
                // Copier les annotations avec les MÊMES IDs (deep copy sans changer les IDs)
                annotations: currentAnnotations.map(a => ({...a}))
            };
            
            // Mark all previous versions as inactive
            scene.versions.forEach(v => v.isActive = false);
            
            // Add new version as active
            version.isActive = true;
            scene.versions.push(version);
            
            // Update scene content reference to this version
            scene.activeVersionId = version.id;
            scene.content = currentContent;
            
            saveProject();
            renderSceneVersionsList();
            
            // Rafraîchir le panneau d'annotations
            const annotationsPanel = document.getElementById('annotationsPanel');
            if (annotationsPanel && annotationsPanel.classList.contains('visible')) {
                renderAnnotationsPanel();
            }
            updateAnnotationsButton(false);
            
            showNotification(`✓ Version ${versionNumber} créée`);
        }
        
        function switchToSceneVersion(versionId) {
            const current = getCurrentSceneForVersions();
            if (!current) return;
            
            const { scene } = current;
            if (!scene.versions) return;
            
            const version = scene.versions.find(v => v.id === versionId);
            if (!version) return;
            
            // Save current editor content to current active version before switching
            const currentActiveVersion = scene.versions.find(v => v.isActive);
            if (currentActiveVersion) {
                const editor = document.getElementById('sceneEditor');
                const currentContent = editor ? editor.innerHTML : (scene.content || '');
                currentActiveVersion.content = currentContent;
                currentActiveVersion.wordCount = getWordCount(currentContent);
            }
            
            // Mark all versions as inactive
            scene.versions.forEach(v => v.isActive = false);
            
            // Activate the selected version
            version.isActive = true;
            scene.activeVersionId = version.id;
            
            // Load version content into scene
            scene.content = version.content;
            scene.wordCount = version.wordCount;
            
            saveProject();
            renderSceneVersionsList();
            
            // Refresh editor if this scene is currently open
            if (currentSceneId === scene.id) {
                const act = project.acts.find(a => a.id === currentActId);
                const chapter = act.chapters.find(c => c.id === currentChapterId);
                renderEditor(act, chapter, scene);
                
                // Réattacher les event listeners sur les marqueurs d'annotation
                setTimeout(() => {
                    reattachAnnotationMarkerListeners();
                }, 50);
                
                // Rafraîchir le panneau d'annotations pour la nouvelle version
                const annotationsPanel = document.getElementById('annotationsPanel');
                if (annotationsPanel && annotationsPanel.classList.contains('visible')) {
                    renderAnnotationsPanel();
                }
                updateAnnotationsButton(false);
            }
        }
        
        // Réattacher les event listeners sur les marqueurs d'annotation après changement de version
        function reattachAnnotationMarkerListeners() {
            const markers = document.querySelectorAll('[data-annotation-id]');
            markers.forEach(marker => {
                const annotationId = parseInt(marker.getAttribute('data-annotation-id'));
                marker.style.cursor = 'pointer';
                marker.onclick = function(e) {
                    e.stopPropagation();
                    highlightAnnotation(annotationId);
                };
            });
        }
        
        function deleteSceneVersion(versionId) {
            const current = getCurrentSceneForVersions();
            if (!current) return;
            
            const { scene } = current;
            if (!scene.versions || scene.versions.length <= 1) {
                alert('Impossible de supprimer la dernière version.');
                return;
            }
            
            const version = scene.versions.find(v => v.id === versionId);
            if (!version) return;
            
            if (!confirm(`Supprimer la version ${version.number} ?`)) return;
            
            const wasActive = version.isActive;
            scene.versions = scene.versions.filter(v => v.id !== versionId);
            
            // Renumber remaining versions
            scene.versions.forEach((v, index) => {
                v.number = index + 1;
            });
            
            // If deleted version was active, activate the last one
            if (wasActive && scene.versions.length > 0) {
                const lastVersion = scene.versions[scene.versions.length - 1];
                lastVersion.isActive = true;
                scene.activeVersionId = lastVersion.id;
                scene.content = lastVersion.content;
                scene.wordCount = lastVersion.wordCount;
                
                // Refresh editor
                if (currentSceneId === scene.id) {
                    const act = project.acts.find(a => a.id === currentActId);
                    const chapter = act.chapters.find(c => c.id === currentChapterId);
                    renderEditor(act, chapter, scene);
                }
            }
            
            saveProject();
            renderSceneVersionsList();
        }
        
        function renameSceneVersion(versionId) {
            const current = getCurrentSceneForVersions();
            if (!current) return;
            
            const { scene } = current;
            if (!scene.versions) return;
            
            const version = scene.versions.find(v => v.id === versionId);
            if (!version) return;
            
            const newLabel = prompt('Nom de la version (optionnel):', version.label || '');
            if (newLabel === null) return; // Cancelled
            
            version.label = newLabel.trim();
            saveProject();
            renderSceneVersionsList();
        }
        
        function renderSceneVersionsList() {
            const listContainer = document.getElementById('sceneVersionsList');
            const sceneNameEl = document.getElementById('versionsSceneName');
            const btnNewVersion = document.getElementById('btnNewVersion');
            
            if (!listContainer) return;
            
            const current = getCurrentSceneForVersions();
            
            if (!current) {
                // No scene selected
                sceneNameEl.textContent = 'Aucune scène sélectionnée';
                btnNewVersion.disabled = true;
                listContainer.innerHTML = `
                    <div class="versions-no-scene">
                        <div class="versions-no-scene-icon">📄</div>
                        <div class="versions-no-scene-text">
                            Sélectionnez une scène<br>dans la structure<br>pour voir ses versions
                        </div>
                    </div>
                `;
                return;
            }
            
            const { act, chapter, scene } = current;
            
            // Update scene name
            sceneNameEl.textContent = `${act.title} › ${chapter.title} › ${scene.title}`;
            btnNewVersion.disabled = false;
            
            // Ensure versions array exists
            if (!scene.versions) {
                scene.versions = [];
            }
            
            if (scene.versions.length === 0) {
                listContainer.innerHTML = `
                    <div class="versions-empty">
                        <div class="versions-empty-icon"><i data-lucide="git-branch" style="width:48px;height:48px;"></i></div>
                        <div class="versions-empty-text">
                            Aucune version<br>
                            Créez votre première version pour tester différentes idées
                        </div>
                    </div>
                `;
                return;
            }
            
            // Sort by most recent first
            const sortedVersions = [...scene.versions].sort((a, b) => 
                new Date(b.createdAt) - new Date(a.createdAt)
            );
            
            let html = '';
            sortedVersions.forEach(version => {
                const date = new Date(version.createdAt);
                const dateStr = date.toLocaleDateString('fr-FR');
                const timeStr = date.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' });
                const canCompare = scene.versions.length >= 2;
                const isFinal = version.isFinal === true;
                const finalClass = isFinal ? 'final' : '';
                const activeClass = version.isActive ? 'active' : '';
                
                html += `
                    <div class="version-card ${activeClass} ${finalClass}" 
                         onclick="switchToSceneVersion(${version.id})">
                        <div class="version-card-header">
                            <span class="version-card-number">
                                ${version.number}
                                ${isFinal ? '<span class="version-card-final-badge">Finale</span>' : ''}
                            </span>
                            <div class="version-card-actions">
                                <button class="version-card-btn final ${isFinal ? 'is-final' : ''}" onclick="event.stopPropagation(); toggleFinalVersion(${version.id})" title="${isFinal ? 'Retirer comme version finale' : 'Marquer comme version finale'}">⭐</button>
                                ${canCompare ? `<button class="version-card-btn compare" onclick="event.stopPropagation(); openDiffModal(${version.id})" title="Comparer">🔀</button>` : ''}
                                <button class="version-card-btn" onclick="event.stopPropagation(); renameSceneVersion(${version.id})" title="Renommer">✏️</button>
                                <button class="version-card-btn delete" onclick="event.stopPropagation(); deleteSceneVersion(${version.id})" title="Supprimer">🗑️</button>
                            </div>
                        </div>
                        <div class="version-card-date">${dateStr} ${timeStr}</div>
                        <div class="version-card-stats">${version.wordCount.toLocaleString('fr-FR')} mots</div>
                        ${version.label ? `<div class="version-card-label">${version.label}</div>` : ''}
                    </div>
                `;
            });
            
            listContainer.innerHTML = html;
        }
        
        // Marquer/démarquer une version comme finale
        function toggleFinalVersion(versionId) {
            const current = getCurrentSceneForVersions();
            if (!current) return;
            
            const { scene } = current;
            if (!scene.versions) return;
            
            const version = scene.versions.find(v => v.id === versionId);
            if (!version) return;
            
            if (version.isFinal) {
                // Retirer le statut final
                version.isFinal = false;
                showNotification('Version retirée comme finale');
            } else {
                // Retirer le statut final des autres versions
                scene.versions.forEach(v => v.isFinal = false);
                // Marquer cette version comme finale
                version.isFinal = true;
                showNotification(`⭐ Version "${version.number}" marquée comme finale`);
            }
            
            saveProject();
            renderSceneVersionsList();
        }
        
        // Obtenir le contenu à exporter pour une scène (version finale si existe, sinon contenu actuel)
        function getSceneExportContent(scene) {
            if (scene.versions && scene.versions.length > 0) {
                const finalVersion = scene.versions.find(v => v.isFinal === true);
                if (finalVersion) {
                    return finalVersion.content;
                }
            }
            return scene.content;
        }
        
        // Update scene content when editing (also updates active version)
        function updateSceneContentWithVersion(content) {
            const current = getCurrentSceneForVersions();
            if (!current) return;
            
            const { scene } = current;
            scene.content = content;
            scene.wordCount = getWordCount(content);
            
            // Also update active version if exists
            if (scene.versions && scene.versions.length > 0) {
                const activeVersion = scene.versions.find(v => v.isActive);
                if (activeVersion) {
                    activeVersion.content = content;
                    activeVersion.wordCount = scene.wordCount;
                }
            }
        }

        // ==========================================
        // DIFF VIEWER (Comparaison de versions)
        // ==========================================
        
        let currentDiffView = 'unified';
        let diffVersions = { old: null, new: null };
        
        function openDiffModal(versionId) {
            const current = getCurrentSceneForVersions();
            if (!current || !current.scene.versions || current.scene.versions.length < 2) {
                alert('Il faut au moins 2 versions pour comparer.');
                return;
            }
            
            const versions = current.scene.versions;
            const selectOld = document.getElementById('diffVersionOld');
            const selectNew = document.getElementById('diffVersionNew');
            
            // Remplir les sélecteurs
            selectOld.innerHTML = '';
            selectNew.innerHTML = '';
            
            versions.forEach((v, index) => {
                const label = v.label || `Version ${v.number}`;
                const date = new Date(v.createdAt).toLocaleDateString('fr-FR');
                const optionText = `${label} (${date})`;
                
                selectOld.innerHTML += `<option value="${v.id}">${optionText}</option>`;
                selectNew.innerHTML += `<option value="${v.id}">${optionText}</option>`;
            });
            
            // Sélectionner par défaut : version cliquée vs version active (ou la plus récente)
            const clickedVersion = versions.find(v => v.id === versionId);
            const activeVersion = versions.find(v => v.isActive);
            
            if (clickedVersion && activeVersion && clickedVersion.id !== activeVersion.id) {
                // Comparer la version cliquée avec l'active
                if (clickedVersion.number < activeVersion.number) {
                    selectOld.value = clickedVersion.id;
                    selectNew.value = activeVersion.id;
                } else {
                    selectOld.value = activeVersion.id;
                    selectNew.value = clickedVersion.id;
                }
            } else {
                // Comparer les 2 dernières versions
                const sorted = [...versions].sort((a, b) => b.number - a.number);
                if (sorted.length >= 2) {
                    selectOld.value = sorted[1].id;
                    selectNew.value = sorted[0].id;
                }
            }
            
            document.getElementById('diffModal').style.display = 'flex';
            updateDiff();
        }
        
        function closeDiffModal() {
            document.getElementById('diffModal').style.display = 'none';
        }
        
        function setDiffView(view) {
            currentDiffView = view;
            document.getElementById('btnDiffUnified').classList.toggle('active', view === 'unified');
            document.getElementById('btnDiffSide').classList.toggle('active', view === 'side');
            updateDiff();
        }
        
        function updateDiff() {
            const current = getCurrentSceneForVersions();
            if (!current) return;
            
            const versions = current.scene.versions;
            const oldId = parseInt(document.getElementById('diffVersionOld').value);
            const newId = parseInt(document.getElementById('diffVersionNew').value);
            
            const oldVersion = versions.find(v => v.id === oldId);
            const newVersion = versions.find(v => v.id === newId);
            
            if (!oldVersion || !newVersion) return;
            
            // Extraire le texte brut du HTML
            const oldText = stripHtml(oldVersion.content || '');
            const newText = stripHtml(newVersion.content || '');
            
            // Calculer le diff
            const diff = computeDiff(oldText, newText);
            
            // Afficher les statistiques
            updateDiffStats(diff);
            
            // Afficher le diff selon le mode
            if (currentDiffView === 'unified') {
                renderUnifiedDiff(diff, oldVersion, newVersion);
            } else {
                renderSideBySideDiff(diff, oldVersion, newVersion);
            }
        }
        
        function stripHtml(html) {
            // Remplacer les balises de bloc par des sauts de ligne
            let text = html
                .replace(/<br\s*\/?>/gi, '\n')
                .replace(/<\/p>/gi, '\n\n')
                .replace(/<\/div>/gi, '\n')
                .replace(/<\/h[1-6]>/gi, '\n\n')
                .replace(/<\/li>/gi, '\n')
                .replace(/<\/tr>/gi, '\n');
            
            // Supprimer toutes les autres balises HTML
            const tmp = document.createElement('div');
            tmp.innerHTML = text;
            text = tmp.textContent || tmp.innerText || '';
            
            // Normaliser les sauts de ligne multiples
            text = text.replace(/\n{3,}/g, '\n\n');
            
            return text.trim();
        }
        
        function computeDiff(oldText, newText) {
            // Normaliser les textes - préserver les sauts de ligne comme marqueurs
            const oldWords = tokenizeText(oldText);
            const newWords = tokenizeText(newText);
            
            // Utiliser l'algorithme de Myers (comme git)
            const diff = myersDiff(oldWords, newWords);
            
            // Convertir en format paragraphe unique pour le rendu
            return [{ type: 'paragraph', items: diff }];
        }
        
        function tokenizeText(text) {
            // Diviser le texte en tokens (mots + marqueurs de saut de ligne)
            const tokens = [];
            const lines = text.split(/\n/);
            
            lines.forEach((line, lineIndex) => {
                const words = line.split(/\s+/).filter(w => w.length > 0);
                words.forEach(word => {
                    tokens.push({ word: word, isBreak: false });
                });
                // Ajouter un marqueur de saut de ligne (sauf pour la dernière ligne)
                if (lineIndex < lines.length - 1) {
                    tokens.push({ word: '\n', isBreak: true });
                }
            });
            
            return tokens;
        }
        
        // Algorithme de Myers - le même que git utilise
        function myersDiff(oldTokens, newTokens) {
            const N = oldTokens.length;
            const M = newTokens.length;
            const MAX = N + M;
            
            // Fonction pour comparer deux tokens
            const tokensEqual = (a, b) => {
                if (a.isBreak && b.isBreak) return true;
                if (a.isBreak || b.isBreak) return false;
                return a.word === b.word;
            };
            
            // Cas simples
            if (N === 0 && M === 0) return [];
            if (N === 0) return newTokens.map(t => ({ type: 'added', text: t.word, isBreak: t.isBreak }));
            if (M === 0) return oldTokens.map(t => ({ type: 'removed', text: t.word, isBreak: t.isBreak }));
            
            // V contient les endpoints les plus éloignés pour chaque diagonale
            const V = new Map();
            V.set(1, 0);
            
            // Trace garde l'historique pour reconstruire le chemin
            const trace = [];
            
            // Chercher le chemin le plus court
            let found = false;
            for (let D = 0; D <= MAX && !found; D++) {
                trace.push(new Map(V));
                
                for (let k = -D; k <= D; k += 2) {
                    // Décider si on va vers le bas ou vers la droite
                    let x;
                    if (k === -D || (k !== D && (V.get(k - 1) || 0) < (V.get(k + 1) || 0))) {
                        x = V.get(k + 1) || 0; // Aller vers le bas (insertion)
                    } else {
                        x = (V.get(k - 1) || 0) + 1; // Aller vers la droite (suppression)
                    }
                    
                    let y = x - k;
                    
                    // Suivre la diagonale (éléments identiques)
                    while (x < N && y < M && tokensEqual(oldTokens[x], newTokens[y])) {
                        x++;
                        y++;
                    }
                    
                    V.set(k, x);
                    
                    // Vérifier si on a atteint la fin
                    if (x >= N && y >= M) {
                        found = true;
                        break;
                    }
                }
            }
            
            // Reconstruire le chemin (backtrack)
            const result = [];
            let x = N;
            let y = M;
            
            for (let d = trace.length - 1; d >= 0; d--) {
                const V = trace[d];
                const k = x - y;
                
                let prevK;
                if (k === -d || (k !== d && (V.get(k - 1) || 0) < (V.get(k + 1) || 0))) {
                    prevK = k + 1;
                } else {
                    prevK = k - 1;
                }
                
                const prevX = V.get(prevK) || 0;
                const prevY = prevX - prevK;
                
                // Ajouter les diagonales (éléments identiques)
                while (x > prevX && y > prevY) {
                    x--;
                    y--;
                    result.unshift({ type: 'same', text: oldTokens[x].word, isBreak: oldTokens[x].isBreak });
                }
                
                // Ajouter l'insertion ou la suppression
                if (d > 0) {
                    if (x === prevX) {
                        // Insertion
                        y--;
                        result.unshift({ type: 'added', text: newTokens[y].word, isBreak: newTokens[y].isBreak });
                    } else {
                        // Suppression
                        x--;
                        result.unshift({ type: 'removed', text: oldTokens[x].word, isBreak: oldTokens[x].isBreak });
                    }
                }
            }
            
            return result;
        }
        
        function addParagraphToResult(result, text, type) {
            const words = text.split(/\s+/).filter(w => w.length > 0);
            const items = words.map(word => ({ type: type, text: word }));
            result.push({ type: 'paragraph', status: type, items: items });
        }
        
        function updateDiffStats(diff) {
            let added = 0;
            let removed = 0;
            
            diff.forEach(para => {
                if (para.items) {
                    para.items.forEach(item => {
                        if (item.isBreak) return; // Ignorer les sauts de ligne
                        if (item.type === 'added' && item.text.trim()) added++;
                        if (item.type === 'removed' && item.text.trim()) removed++;
                    });
                }
            });
            
            document.getElementById('diffStats').innerHTML = `
                <span class="diff-stat added">+${added} mot${added > 1 ? 's' : ''} ajouté${added > 1 ? 's' : ''}</span>
                <span class="diff-stat removed">−${removed} mot${removed > 1 ? 's' : ''} supprimé${removed > 1 ? 's' : ''}</span>
            `;
        }
        
        function renderUnifiedDiff(diff, oldVersion, newVersion) {
            const container = document.getElementById('diffContent');
            
            if (diff.length === 0) {
                container.innerHTML = `
                    <div class="diff-empty-state">
                        <div class="diff-empty-state-icon"><i data-lucide="check" style="width:48px;height:48px;"></i></div>
                        <div>Les deux versions sont identiques</div>
                    </div>
                `;
                return;
            }
            
            let html = '<div class="diff-unified">';
            
            diff.forEach((para, paraIndex) => {
                if (paraIndex > 0) html += '<br><br>';
                
                const paraClass = para.status === 'added' ? 'diff-paragraph added' : 
                                  para.status === 'removed' ? 'diff-paragraph removed' : 
                                  'diff-paragraph';
                
                html += `<div class="${paraClass}">`;
                
                if (para.items) {
                    let needSpace = false;
                    para.items.forEach((item) => {
                        // Gérer les sauts de ligne
                        if (item.isBreak) {
                            html += '<br>';
                            needSpace = false;
                            return;
                        }
                        
                        const space = needSpace ? ' ' : '';
                        
                        if (item.type === 'same') {
                            html += space + escapeHtml(item.text);
                        } else if (item.type === 'added') {
                            html += space + `<span class="diff-word added">${escapeHtml(item.text)}</span>`;
                        } else if (item.type === 'removed') {
                            html += space + `<span class="diff-word removed">${escapeHtml(item.text)}</span>`;
                        }
                        needSpace = true;
                    });
                }
                
                html += '</div>';
            });
            
            html += '</div>';
            container.innerHTML = html;
        }
        
        function renderSideBySideDiff(diff, oldVersion, newVersion) {
            const container = document.getElementById('diffContent');
            
            const oldLabel = oldVersion.label || `Version ${oldVersion.number}`;
            const newLabel = newVersion.label || `Version ${newVersion.number}`;
            const oldDate = new Date(oldVersion.createdAt).toLocaleDateString('fr-FR');
            const newDate = new Date(newVersion.createdAt).toLocaleDateString('fr-FR');
            
            let oldHtml = '';
            let newHtml = '';
            
            diff.forEach((para, paraIndex) => {
                if (paraIndex > 0) {
                    oldHtml += '<br><br>';
                    newHtml += '<br><br>';
                }
                
                if (para.status === 'removed') {
                    // Paragraphe supprimé - seulement à gauche
                    oldHtml += '<div class="diff-paragraph removed">';
                    let needSpace = false;
                    para.items.forEach((item) => {
                        if (item.isBreak) {
                            oldHtml += '<br>';
                            needSpace = false;
                            return;
                        }
                        const space = needSpace ? ' ' : '';
                        oldHtml += space + `<span class="diff-word removed">${escapeHtml(item.text)}</span>`;
                        needSpace = true;
                    });
                    oldHtml += '</div>';
                } else if (para.status === 'added') {
                    // Paragraphe ajouté - seulement à droite
                    newHtml += '<div class="diff-paragraph added">';
                    let needSpace = false;
                    para.items.forEach((item) => {
                        if (item.isBreak) {
                            newHtml += '<br>';
                            needSpace = false;
                            return;
                        }
                        const space = needSpace ? ' ' : '';
                        newHtml += space + `<span class="diff-word added">${escapeHtml(item.text)}</span>`;
                        needSpace = true;
                    });
                    newHtml += '</div>';
                } else if (para.status === 'same') {
                    // Paragraphe identique
                    const text = para.items.filter(item => !item.isBreak).map(item => item.text).join(' ');
                    oldHtml += `<div class="diff-paragraph">${escapeHtml(text)}</div>`;
                    newHtml += `<div class="diff-paragraph">${escapeHtml(text)}</div>`;
                } else {
                    // Paragraphe modifié - afficher le diff mot par mot
                    oldHtml += '<div class="diff-paragraph modified">';
                    newHtml += '<div class="diff-paragraph modified">';
                    
                    let oldNeedSpace = false;
                    let newNeedSpace = false;
                    
                    para.items.forEach(item => {
                        if (item.isBreak) {
                            if (item.type === 'same' || item.type === 'removed') {
                                oldHtml += '<br>';
                                oldNeedSpace = false;
                            }
                            if (item.type === 'same' || item.type === 'added') {
                                newHtml += '<br>';
                                newNeedSpace = false;
                            }
                            return;
                        }
                        
                        if (item.type === 'same') {
                            const oldSpace = oldNeedSpace ? ' ' : '';
                            const newSpace = newNeedSpace ? ' ' : '';
                            oldHtml += oldSpace + escapeHtml(item.text);
                            newHtml += newSpace + escapeHtml(item.text);
                            oldNeedSpace = true;
                            newNeedSpace = true;
                        } else if (item.type === 'added') {
                            const space = newNeedSpace ? ' ' : '';
                            newHtml += space + `<span class="diff-word added">${escapeHtml(item.text)}</span>`;
                            newNeedSpace = true;
                        } else if (item.type === 'removed') {
                            const space = oldNeedSpace ? ' ' : '';
                            oldHtml += space + `<span class="diff-word removed">${escapeHtml(item.text)}</span>`;
                            oldNeedSpace = true;
                        }
                    });
                    
                    oldHtml += '</div>';
                    newHtml += '</div>';
                }
            });
            
            container.innerHTML = `
                <div class="diff-side-by-side">
                    <div class="diff-side">
                        <div class="diff-side-header old">
                            <span>${oldLabel}</span>
                            <span style="font-weight: normal; font-size: 0.75rem;">${oldDate} • ${oldVersion.wordCount} mots</span>
                        </div>
                        <div class="diff-side-content">${oldHtml}</div>
                    </div>
                    <div class="diff-side">
                        <div class="diff-side-header new">
                            <span>${newLabel}</span>
                            <span style="font-weight: normal; font-size: 0.75rem;">${newDate} • ${newVersion.wordCount} mots</span>
                        </div>
                        <div class="diff-side-content">${newHtml}</div>
                    </div>
                </div>
            `;
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Statistics Management
        function renderStats() {
            const editorView = document.getElementById('editorView');
            if (!editorView) {
                console.error('editorView not found');
                return;
            }
            
            // Calculate total words
            const totalWords = project.acts.reduce((sum, act) => {
                return sum + act.chapters.reduce((chSum, chapter) => {
                    return chSum + chapter.scenes.reduce((sceneSum, scene) => {
                        return sceneSum + getWordCount(scene.content);
                    }, 0);
                }, 0);
            }, 0);

            // Calculate today's words
            const today = new Date().toDateString();
            const todaySession = project.stats.writingSessions.find(s => new Date(s.date).toDateString() === today);
            const todayWords = todaySession ? todaySession.words : 0;

            // Progress percentages
            const dailyProgress = Math.min((todayWords / project.stats.dailyGoal) * 100, 100);
            const totalProgress = Math.min((totalWords / project.stats.totalGoal) * 100, 100);

            editorView.innerHTML = `
                <div style="height: 100%; overflow-y: auto; padding: 2rem 3rem;">
                    <h2 style="margin-bottom: 2rem; color: var(--accent-gold);"><i data-lucide="bar-chart-3" style="width:24px;height:24px;vertical-align:middle;margin-right:8px;"></i>Statistiques</h2>
                    
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 2rem;">
                        <div class="stat-box" style="background: var(--bg-secondary); padding: 2rem; border-radius: 8px; border-left: 4px solid var(--accent-gold);">
                            <div style="font-size: 0.9rem; color: var(--text-muted); margin-bottom: 0.5rem;">Total de mots</div>
                            <div style="font-size: 2.5rem; font-weight: 700; color: var(--accent-gold); margin-bottom: 0.5rem;">${totalWords.toLocaleString('fr-FR')}</div>
                            <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 1rem;">sur ${project.stats.totalGoal.toLocaleString('fr-FR')} mots</div>
                            <div style="background: var(--bg-primary); height: 8px; border-radius: 4px; overflow: hidden;">
                                <div style="background: var(--accent-gold); height: 100%; width: ${totalProgress}%; transition: width 0.3s;"></div>
                            </div>
                            <div style="margin-top: 1rem; display: flex; gap: 0.5rem; align-items: center;">
                                <input type="number" class="form-input" value="${project.stats.totalGoal}" 
                                       id="totalGoalInput"
                                       style="flex: 1;" placeholder="Objectif total">
                                <button class="btn btn-small" onclick="updateGoal('totalGoal', document.getElementById('totalGoalInput').value)">Mettre à jour</button>
                            </div>
                        </div>

                        <div class="stat-box" style="background: var(--bg-secondary); padding: 2rem; border-radius: 8px; border-left: 4px solid var(--accent-red);">
                            <div style="font-size: 0.9rem; color: var(--text-muted); margin-bottom: 0.5rem;">Aujourd'hui</div>
                            <div style="font-size: 2.5rem; font-weight: 700; color: var(--accent-red); margin-bottom: 0.5rem;">${todayWords}</div>
                            <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 1rem;">sur ${project.stats.dailyGoal} mots</div>
                            <div style="background: var(--bg-primary); height: 8px; border-radius: 4px; overflow: hidden;">
                                <div style="background: var(--accent-red); height: 100%; width: ${dailyProgress}%; transition: width 0.3s;"></div>
                            </div>
                            <div style="margin-top: 1rem; display: flex; gap: 0.5rem; align-items: center;">
                                <input type="number" class="form-input" value="${project.stats.dailyGoal}" 
                                       id="dailyGoalInput"
                                       style="flex: 1;" placeholder="Objectif quotidien">
                                <button class="btn btn-small" onclick="updateGoal('dailyGoal', document.getElementById('dailyGoalInput').value)">Mettre à jour</button>
                            </div>
                        </div>
                    </div>
                    
                    <div style="margin-top: 2rem;">
                        <h3 style="margin-bottom: 1rem; color: var(--text-primary);">Par acte</h3>
                        <div style="background: var(--bg-secondary); padding: 1.5rem; border-radius: 8px;">
                            ${project.acts.map(act => {
                                const actWords = act.chapters.reduce((sum, chapter) => {
                                    return sum + chapter.scenes.reduce((sceneSum, scene) => {
                                        return sceneSum + getWordCount(scene.content);
                                    }, 0);
                                }, 0);
                                return `
                                    <div style="display: flex; justify-content: space-between; padding: 0.75rem 0; border-bottom: 1px solid var(--border-color);">
                                        <span style="color: var(--text-primary);">${act.title}</span>
                                        <span style="font-weight: 600; color: var(--accent-gold);">${actWords.toLocaleString('fr-FR')} mots</span>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>

                    <div style="margin-top: 2rem;">
                        <h3 style="margin-bottom: 1rem; color: var(--text-primary);">Historique (7 derniers jours)</h3>
                        <div style="background: var(--bg-secondary); padding: 1.5rem; border-radius: 8px;">
                            ${renderWritingHistory()}
                        </div>
                    </div>
                </div>
            `;
        }

        function renderWritingHistory() {
            const last7Days = [];
            for (let i = 6; i >= 0; i--) {
                const date = new Date();
                date.setDate(date.getDate() - i);
                last7Days.push(date);
            }

            return last7Days.map(date => {
                const dateStr = date.toDateString();
                const session = project.stats.writingSessions.find(s => new Date(s.date).toDateString() === dateStr);
                const words = session ? session.words : 0;
                const dayName = date.toLocaleDateString('fr-FR', { weekday: 'short', day: 'numeric', month: 'short' });
                
                return `
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.5rem 0;">
                        <span style="font-size: 0.85rem;">${dayName}</span>
                        <div style="flex: 1; margin: 0 1rem;">
                            <div class="progress-bar" style="height: 4px;">
                                <div class="progress-fill" style="width: ${Math.min((words / project.stats.dailyGoal) * 100, 100)}%; background: ${words >= project.stats.dailyGoal ? 'var(--accent-gold)' : 'var(--text-muted)'}"></div>
                            </div>
                        </div>
                        <span style="font-size: 0.85rem; font-weight: 600; font-family: 'Source Code Pro', monospace;">${words}</span>
                    </div>
                `;
            }).join('');
        }

        function updateGoal(type, value) {
            const numValue = parseInt(value);
            if (numValue && numValue > 0) {
                project.stats[type] = numValue;
                saveProject();
                renderStats();
            }
        }

        function trackWritingSession() {
            // Track writing session for stats
            const today = new Date().toDateString();
            const totalWords = project.acts.reduce((sum, act) => {
                return sum + act.chapters.reduce((chSum, chapter) => {
                    return chSum + chapter.scenes.reduce((sceneSum, scene) => {
                        return sceneSum + getWordCount(scene.content);
                    }, 0);
                }, 0);
            }, 0);

            const sessionIndex = project.stats.writingSessions.findIndex(s => new Date(s.date).toDateString() === today);
            
            if (sessionIndex >= 0) {
                project.stats.writingSessions[sessionIndex].words = totalWords - (project.stats.writingSessions[sessionIndex].startWords || 0);
            } else {
                project.stats.writingSessions.push({
                    date: new Date().toISOString(),
                    words: 0,
                    startWords: totalWords
                });
            }
        }

        // Codex Management
        function openAddCodexModal() {
            document.getElementById('addCodexModal').classList.add('active');
            setTimeout(() => document.getElementById('codexTitleInput').focus(), 100);
        }

        function addCodexEntry() {
            const title = document.getElementById('codexTitleInput').value.trim();
            const category = document.getElementById('codexCategoryInput').value;
            const summary = document.getElementById('codexSummaryInput').value.trim();
            
            if (!title) return;

            const entry = {
                id: Date.now(),
                title: title,
                category: category,
                summary: summary || '',
                content: '',
                relatedTo: [] // IDs of related characters, world elements, etc.
            };

            project.codex.push(entry);
            
            // Clear inputs
            document.getElementById('codexTitleInput').value = '';
            document.getElementById('codexSummaryInput').value = '';
            
            closeModal('addCodexModal');
            saveProject();
            renderCodexList();
        }

        function deleteCodexEntry(id) {
            if (!confirm('Êtes-vous sûr de vouloir supprimer cette entrée ?')) return;
            project.codex = project.codex.filter(c => c.id !== id);
            saveProject();
            renderCodexList();
            showEmptyState();
        }

        function renderCodexList() {
            const container = document.getElementById('codexList');
            
            if (project.codex.length === 0) {
                container.innerHTML = '<div style="padding: 1rem; text-align: center; color: var(--text-muted); font-size: 0.85rem;">Aucune entrée</div>';
                return;
            }

            // Group by category
            const groups = {};
            project.codex.forEach(entry => {
                const cat = entry.category || 'Autre';
                if (!groups[cat]) groups[cat] = [];
                groups[cat].push(entry);
            });
            
            // Icons for each category
            const catIcons = {
                'Culture': '🎭',
                'Histoire': '📜',
                'Technologie': '⚙️',
                'Géographie': '🗺️',
                'Politique': '⚖️',
                'Magie/Pouvoir': '✨',
                'Religion': '🕯️',
                'Société': '👥',
                'Autre': '📄'
            };
            
            // Get collapsed state from localStorage
            const collapsedState = JSON.parse(localStorage.getItem('plume_treeview_collapsed') || '{}');
            
            let html = '';
            Object.keys(groups).sort().forEach(category => {
                const groupKey = 'codex_' + category;
                const isCollapsed = collapsedState[groupKey] === true;
                
                // Sort entries alphabetically within each group
                const sortedEntries = [...groups[category]].sort((a, b) => {
                    return (a.title || '').toLowerCase().localeCompare((b.title || '').toLowerCase(), 'fr');
                });
                
                html += `
                    <div class="treeview-group">
                        <div class="treeview-header" onclick="toggleTreeviewGroup('${groupKey}')">
                            <i data-lucide="${isCollapsed ? 'chevron-right' : 'chevron-down'}" class="treeview-chevron"></i>
                            <span class="treeview-label">${category}</span>
                            <span class="treeview-count">${groups[category].length}</span>
                        </div>
                        <div class="treeview-children ${isCollapsed ? 'collapsed' : ''}">
                            ${sortedEntries.map(entry => `
                                <div class="treeview-item" onclick="openCodexDetail(${entry.id})">
                                    <span class="treeview-item-icon">${catIcons[category] || '📄'}</span>
                                    <span class="treeview-item-label">${entry.title}</span>
                                    <button class="treeview-item-delete" onclick="event.stopPropagation(); deleteCodexEntry(${entry.id})" title="Supprimer">×</button>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            });

            container.innerHTML = html;
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }

        function openCodexDetail(id) {
            const entry = project.codex.find(c => c.id === id);
            if (!entry) return;
            
            // Handle split view mode
            if (splitViewActive) {
                const state = splitActivePanel === 'left' ? splitViewState.left : splitViewState.right;
                if (state.view === 'codex') {
                    state.codexId = id;
                    renderSplitPanelViewContent(splitActivePanel);
                    saveSplitViewState();
                    return;
                }
            }

            const editorView = document.getElementById('editorView');
            editorView.innerHTML = `
                <div class="detail-view">
                    <div class="detail-header">
                        <div style="display: flex; align-items: center; gap: 1rem; flex: 1;">
                            <input type="text" class="form-input" value="${entry.title}" 
                                   style="font-size: 1.8rem; font-weight: 600; font-family: 'Noto Serif JP', serif; padding: 0.5rem;"
                                   onchange="updateCodexField(${id}, 'title', this.value)"
                                   placeholder="Titre de l'entrée">
                            <span style="font-size: 0.8rem; padding: 0.4rem 0.8rem; background: var(--accent-gold); color: var(--bg-primary); border-radius: 2px;">${entry.category}</span>
                        </div>
                        <button class="btn" onclick="switchView('editor')">← Retour à l'éditeur</button>
                    </div>
                    
                    <div class="detail-section">
                        <div class="detail-section-title">Catégorie</div>
                        <select class="form-input" onchange="updateCodexField(${id}, 'category', this.value)">
                            <option value="Culture" ${entry.category === 'Culture' ? 'selected' : ''}>Culture</option>
                            <option value="Histoire" ${entry.category === 'Histoire' ? 'selected' : ''}>Histoire</option>
                            <option value="Technologie" ${entry.category === 'Technologie' ? 'selected' : ''}>Technologie</option>
                            <option value="Géographie" ${entry.category === 'Géographie' ? 'selected' : ''}>Géographie</option>
                            <option value="Politique" ${entry.category === 'Politique' ? 'selected' : ''}>Politique</option>
                            <option value="Magie/Pouvoir" ${entry.category === 'Magie/Pouvoir' ? 'selected' : ''}>Magie/Pouvoir</option>
                            <option value="Religion" ${entry.category === 'Religion' ? 'selected' : ''}>Religion</option>
                            <option value="Société" ${entry.category === 'Société' ? 'selected' : ''}>Société</option>
                            <option value="Autre" ${entry.category === 'Autre' ? 'selected' : ''}>Autre</option>
                        </select>
                    </div>

                    <div class="detail-section">
                        <div class="detail-section-title">Résumé</div>
                        <textarea class="form-input" rows="3" 
                                  onchange="updateCodexField(${id}, 'summary', this.value)">${entry.summary}</textarea>
                    </div>

                    <div class="detail-section">
                        <div class="detail-section-title">Contenu détaillé</div>
                        <textarea class="form-input" rows="20" 
                                  oninput="updateCodexField(${id}, 'content', this.value)">${entry.content}</textarea>
                    </div>
                </div>
            `;
        }

        function updateCodexField(id, field, value) {
            const entry = project.codex.find(c => c.id === id);
            if (entry) {
                entry[field] = value;
                saveProject();
                renderCodexList();
            }
        }

        // References and Links Management
        function showReferencesForCharacter(characterId) {
            const character = project.characters.find(c => c.id === characterId);
            if (!character) return;

            const scenes = findScenesWithCharacter(characterId);
            const relatedElements = character.linkedElements || [];

            document.getElementById('referencesModalTitle').textContent = `Références : ${character.name}`;
            document.getElementById('referencesModalContent').innerHTML = `
                <div class="references-section">
                    <div class="references-title"><i data-lucide="file-text" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Scènes où ${character.name} apparaît (${scenes.length})</div>
                    ${scenes.length > 0 ? scenes.map(scene => `
                        <div class="reference-item" onclick="openScene(${scene.actId}, ${scene.chapterId}, ${scene.sceneId}); closeModal('referencesModal');">
                            <div>
                                <div style="font-weight: 600;">${scene.sceneTitle}</div>
                                <div style="font-size: 0.8rem; color: var(--text-muted);">${scene.actTitle} > ${scene.chapterTitle}</div>
                            </div>
                            <span>→</span>
                        </div>
                    `).join('') : '<div style="padding: 1rem; color: var(--text-muted);">Aucune scène liée</div>'}
                </div>

                <div class="references-section">
                    <div class="references-title"><i data-lucide="link" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Gérer les liens</div>
                    <button class="btn btn-small" onclick="openLinkManagerForCharacter(${characterId})">+ Lier à des scènes</button>
                </div>
            `;

            document.getElementById('referencesModal').classList.add('active');
        }

        function findScenesWithCharacter(characterId) {
            const scenes = [];
            project.acts.forEach(act => {
                act.chapters.forEach(chapter => {
                    chapter.scenes.forEach(scene => {
                        if (scene.linkedCharacters && scene.linkedCharacters.includes(characterId)) {
                            scenes.push({
                                actId: act.id,
                                actTitle: act.title,
                                chapterId: chapter.id,
                                chapterTitle: chapter.title,
                                sceneId: scene.id,
                                sceneTitle: scene.title
                            });
                        }
                    });
                });
            });
            return scenes;
        }

        function findScenesWithElement(elementId) {
            const scenes = [];
            project.acts.forEach(act => {
                act.chapters.forEach(chapter => {
                    chapter.scenes.forEach(scene => {
                        if (scene.linkedElements && scene.linkedElements.includes(elementId)) {
                            scenes.push({
                                actId: act.id,
                                actTitle: act.title,
                                chapterId: chapter.id,
                                chapterTitle: chapter.title,
                                sceneId: scene.id,
                                sceneTitle: scene.title
                            });
                        }
                    });
                });
            });
            return scenes;
        }

        function showReferencesForElement(elementId) {
            const element = project.world.find(e => e.id === elementId);
            if (!element) return;

            const scenes = findScenesWithElement(elementId);

            document.getElementById('referencesModalTitle').textContent = `Références : ${element.name}`;
            document.getElementById('referencesModalContent').innerHTML = `
                <div class="references-section">
                    <div class="references-title"><i data-lucide="file-text" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Scènes où ${element.name} apparaît (${scenes.length})</div>
                    ${scenes.length > 0 ? scenes.map(scene => `
                        <div class="reference-item" onclick="openScene(${scene.actId}, ${scene.chapterId}, ${scene.sceneId}); closeModal('referencesModal');">
                            <div>
                                <div style="font-weight: 600;">${scene.sceneTitle}</div>
                                <div style="font-size: 0.8rem; color: var(--text-muted);">${scene.actTitle} > ${scene.chapterTitle}</div>
                            </div>
                            <span>→</span>
                        </div>
                    `).join('') : '<div style="padding: 1rem; color: var(--text-muted);">Aucune scène liée</div>'}
                </div>

                <div class="references-section">
                    <div class="references-title"><i data-lucide="link" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Gérer les liens</div>
                    <button class="btn btn-small" onclick="openLinkManagerForElement(${elementId})">+ Lier à des scènes</button>
                </div>
            `;

            document.getElementById('referencesModal').classList.add('active');
        }

        function toggleCharacterInScene(sceneActId, sceneChapterId, sceneId, characterId) {
            const act = project.acts.find(a => a.id === sceneActId);
            const chapter = act.chapters.find(c => c.id === sceneChapterId);
            const scene = chapter.scenes.find(s => s.id === sceneId);

            if (!scene.linkedCharacters) scene.linkedCharacters = [];

            const index = scene.linkedCharacters.indexOf(characterId);
            if (index > -1) {
                scene.linkedCharacters.splice(index, 1);
            } else {
                scene.linkedCharacters.push(characterId);
            }

            saveProject();
            
            // Rafraîchir le panneau de liens dans l'éditeur si la scène est ouverte
            if (currentSceneId === sceneId && currentActId === sceneActId && currentChapterId === sceneChapterId) {
                const linksPanel = document.getElementById('linksPanel');
                if (linksPanel) {
                    // Trouver le premier div flex (celui des personnages)
                    const flexDivs = linksPanel.querySelectorAll('[style*="flex: 1"]');
                    if (flexDivs.length >= 1) {
                        const charDiv = flexDivs[0];
                        const quickLinks = charDiv.querySelector('.quick-links');
                        if (quickLinks) {
                            quickLinks.innerHTML = `
                                ${renderSceneCharacters(sceneActId, sceneChapterId, scene)}
                                <button class="btn btn-small" onclick="openCharacterLinker(${sceneActId}, ${sceneChapterId}, ${sceneId})" style="font-size: 0.75rem; padding: 0.3rem 0.6rem;">+ Lier</button>
                            `;
                        }
                    }
                }
            }
        }

        function toggleElementInScene(sceneActId, sceneChapterId, sceneId, elementId) {
            const act = project.acts.find(a => a.id === sceneActId);
            const chapter = act.chapters.find(c => c.id === sceneChapterId);
            const scene = chapter.scenes.find(s => s.id === sceneId);

            if (!scene.linkedElements) scene.linkedElements = [];

            const index = scene.linkedElements.indexOf(elementId);
            if (index > -1) {
                scene.linkedElements.splice(index, 1);
            } else {
                scene.linkedElements.push(elementId);
            }

            saveProject();
            
            // Rafraîchir le panneau de liens dans l'éditeur si la scène est ouverte
            if (currentSceneId === sceneId && currentActId === sceneActId && currentChapterId === sceneChapterId) {
                const linksPanel = document.getElementById('linksPanel');
                if (linksPanel) {
                    // Trouver le deuxième div flex (celui des lieux)
                    const flexDivs = linksPanel.querySelectorAll('[style*="flex: 1"]');
                    if (flexDivs.length >= 2) {
                        const locationDiv = flexDivs[1];
                        const quickLinks = locationDiv.querySelector('.quick-links');
                        if (quickLinks) {
                            quickLinks.innerHTML = `
                                ${renderSceneElements(sceneActId, sceneChapterId, scene)}
                                <button class="btn btn-small" onclick="openElementLinker(${sceneActId}, ${sceneChapterId}, ${sceneId})" style="font-size: 0.75rem; padding: 0.3rem 0.6rem;">+ Lier</button>
                            `;
                        }
                    }
                }
            }
        }

        // Global Search
        let searchTimeout = null;

        function performGlobalSearch(query) {
            clearTimeout(searchTimeout);
            
            const resultsContainer = document.getElementById('searchResults');
            
            if (!query || query.trim().length < 2) {
                resultsContainer.classList.remove('active');
                return;
            }

            // Debounce search
            searchTimeout = setTimeout(() => {
                const results = searchEverywhere(query.trim());
                displaySearchResults(results, query.trim());
            }, 300);
        }

        function searchEverywhere(query) {
            const results = [];
            const lowerQuery = query.toLowerCase();

            // Search in scenes
            project.acts.forEach(act => {
                act.chapters.forEach(chapter => {
                    chapter.scenes.forEach(scene => {
                        const temp = document.createElement('div');
                        temp.innerHTML = scene.content;
                        const textContent = temp.textContent || temp.innerText || '';
                        
                        if (scene.title.toLowerCase().includes(lowerQuery) || 
                            textContent.toLowerCase().includes(lowerQuery)) {
                            
                            const matchIndex = textContent.toLowerCase().indexOf(lowerQuery);
                            const preview = matchIndex >= 0 
                                ? getPreview(textContent, matchIndex, query.length)
                                : textContent.substring(0, 150);

                            results.push({
                                type: 'Scène',
                                title: scene.title,
                                path: `${act.title} > ${chapter.title}`,
                                preview: preview,
                                action: () => openScene(act.id, chapter.id, scene.id)
                            });
                        }
                    });
                });
            });

            // Search in characters
            project.characters.forEach(char => {
                const searchText = `${char.name} ${char.role} ${char.description} ${char.personality} ${char.background}`.toLowerCase();
                if (searchText.includes(lowerQuery)) {
                    results.push({
                        type: 'Personnage',
                        title: char.name,
                        path: char.role || 'Personnage',
                        preview: char.description || 'Aucune description',
                        action: () => { switchView('characters'); openCharacterDetail(char.id); }
                    });
                }
            });

            // Search in world elements
            project.world.forEach(element => {
                const searchText = `${element.name} ${element.description} ${element.details}`.toLowerCase();
                if (searchText.includes(lowerQuery)) {
                    results.push({
                        type: 'Univers',
                        title: element.name,
                        path: element.type,
                        preview: element.description || 'Aucune description',
                        action: () => { switchView('world'); openWorldDetail(element.id); }
                    });
                }
            });

            // Search in timeline
            project.timeline.forEach(event => {
                const searchText = `${event.title} ${event.description} ${event.location} ${event.characters}`.toLowerCase();
                if (searchText.includes(lowerQuery)) {
                    results.push({
                        type: 'Chronologie',
                        title: event.title,
                        path: event.date || 'Événement',
                        preview: event.description || 'Aucune description',
                        action: () => { switchView('timeline'); openTimelineDetail(event.id); }
                    });
                }
            });

            // Search in notes
            project.notes.forEach(note => {
                const searchText = `${note.title} ${note.content}`.toLowerCase();
                if (searchText.includes(lowerQuery)) {
                    const matchIndex = note.content.toLowerCase().indexOf(lowerQuery);
                    const preview = matchIndex >= 0 
                        ? getPreview(note.content, matchIndex, query.length)
                        : note.content.substring(0, 150);

                    results.push({
                        type: 'Note',
                        title: note.title,
                        path: note.category,
                        preview: preview,
                        action: () => { switchView('notes'); openNoteDetail(note.id); }
                    });
                }
            });

            // Search in codex
            project.codex.forEach(entry => {
                const searchText = `${entry.title} ${entry.summary} ${entry.content}`.toLowerCase();
                if (searchText.includes(lowerQuery)) {
                    const matchIndex = entry.content.toLowerCase().indexOf(lowerQuery);
                    const preview = matchIndex >= 0 
                        ? getPreview(entry.content, matchIndex, query.length)
                        : entry.summary || entry.content.substring(0, 150);

                    results.push({
                        type: 'Codex',
                        title: entry.title,
                        path: entry.category,
                        preview: preview,
                        action: () => { switchView('codex'); openCodexDetail(entry.id); }
                    });
                }
            });

            return results;
        }

        function getPreview(text, matchIndex, queryLength) {
            const start = Math.max(0, matchIndex - 60);
            const end = Math.min(text.length, matchIndex + queryLength + 90);
            let preview = text.substring(start, end);
            
            if (start > 0) preview = '...' + preview;
            if (end < text.length) preview = preview + '...';
            
            return preview;
        }

        function displaySearchResults(results, query) {
            const container = document.getElementById('searchResults');
            
            if (results.length === 0) {
                container.innerHTML = '<div class="search-no-results">Aucun résultat trouvé</div>';
                container.classList.add('active');
                return;
            }

            const highlightQuery = (text) => {
                const regex = new RegExp(`(${query})`, 'gi');
                return text.replace(regex, '<span class="search-highlight">$1</span>');
            };

            container.innerHTML = results.map((result, index) => `
                <div class="search-result-item" onclick="executeSearchAction(${index}); closeSearchResults();">
                    <div class="search-result-type">${result.type}</div>
                    <div class="search-result-title">${highlightQuery(result.title)}</div>
                    <div class="search-result-path">${result.path}</div>
                    <div class="search-result-preview">${highlightQuery(result.preview)}</div>
                </div>
            `).join('');

            // Store actions for execution
            window.searchResultActions = results.map(r => r.action);

            container.classList.add('active');
        }

        function executeSearchAction(index) {
            if (window.searchResultActions && window.searchResultActions[index]) {
                window.searchResultActions[index]();
            }
        }

        function closeSearchResults() {
            document.getElementById('searchResults').classList.remove('active');
            document.getElementById('globalSearch').value = '';
        }

        // Close search results when clicking outside
        document.addEventListener('click', (e) => {
            const searchContainer = document.querySelector('.search-container');
            if (searchContainer && !searchContainer.contains(e.target)) {
                closeSearchResults();
            }
        });

        // Focus Mode Management
        let focusModeActive = false;
        let focusPanelOpen = false;
        let focusStartWordCount = 0;
        
        // Objectif de mots pour le projet (peut être configuré)
        let projectWordGoal = 50000;

        function updateWritingProgress() {
            if (!currentSceneId) return;
            
            const act = project.acts.find(a => a.id === currentActId);
            if (!act) return;
            const chapter = act.chapters.find(c => c.id === currentChapterId);
            if (!chapter) return;
            const scene = chapter.scenes.find(s => s.id === currentSceneId);
            if (!scene) return;
            
            const currentWords = getWordCount(scene.content || '');
            
            // Calculer le total de mots du projet
            const totalProjectWords = project.acts.reduce((sum, a) => 
                sum + a.chapters.reduce((s, ch) => 
                    s + ch.scenes.reduce((sc, scene) => sc + (scene.wordCount || 0), 0), 0), 0);
            
            // Mettre à jour la barre de progression
            const progressPercent = Math.min((totalProjectWords / projectWordGoal) * 100, 100);
            const progressFill = document.getElementById('writingProgressFill');
            if (progressFill) {
                progressFill.style.width = progressPercent + '%';
            }
            
            // Mettre à jour l'indicateur de position
            const positionIndicator = document.getElementById('positionIndicator');
            if (positionIndicator) {
                positionIndicator.textContent = `Mot ${currentWords.toLocaleString()} • Total: ${totalProjectWords.toLocaleString()} / ${projectWordGoal.toLocaleString()}`;
            }
        }

        function toggleFocusMode() {
            console.log('toggleFocusMode called, current state:', focusModeActive);
            
            focusModeActive = !focusModeActive;
            const appContainer = document.querySelector('.app-container');
            const focusBtn = document.querySelector('.focus-toggle-btn');
            
            console.log('App container found:', !!appContainer);
            console.log('Focus button found:', !!focusBtn);
            
            if (focusModeActive) {
                console.log('ACTIVATING FOCUS MODE');
                appContainer.classList.add('focus-mode');
                
                // Track starting word count
                if (currentSceneId) {
                    const act = project.acts.find(a => a.id === currentActId);
                    const chapter = act.chapters.find(c => c.id === currentChapterId);
                    const scene = chapter.scenes.find(s => s.id === currentSceneId);
                    focusStartWordCount = getWordCount(scene.content);
                }
                
                // Mettre à jour les indicateurs
                updateWritingProgress();
                
                // Request fullscreen on app-container
                if (appContainer.requestFullscreen) {
                    appContainer.requestFullscreen().catch((err) => {
                        console.log('Fullscreen not available or denied:', err);
                    });
                }
            } else {
                console.log('DEACTIVATING FOCUS MODE');
                appContainer.classList.remove('focus-mode');
                
                // Forcer la réinitialisation des styles inline si nécessaire
                const sidebar = document.querySelector('.sidebar');
                const sidebarVersions = document.querySelector('.sidebar-versions');
                const appContent = document.querySelector('.app-content');
                const editorContainer = document.querySelector('.editor-container');
                
                if (sidebar) sidebar.style.cssText = '';
                if (sidebarVersions && !sidebarVersions.classList.contains('hidden')) {
                    sidebarVersions.style.cssText = '';
                }
                if (appContent) appContent.style.cssText = '';
                if (editorContainer) editorContainer.style.cssText = '';
                
                // Exit fullscreen
                if (document.exitFullscreen && document.fullscreenElement) {
                    document.exitFullscreen();
                }
                focusPanelOpen = false;
                document.getElementById('focusPanel').classList.remove('active');
            }
        }

        function toggleFocusPanel() {
            focusPanelOpen = !focusPanelOpen;
            const panel = document.getElementById('focusPanel');
            
            if (focusPanelOpen) {
                panel.classList.add('active');
                console.log('Focus panel opened');
            } else {
                panel.classList.remove('active');
                console.log('Focus panel closed');
            }
        }

        function toggleToolbar() {
            const toolbar = document.getElementById('editorToolbar');
            if (toolbar) {
                toolbar.style.display = document.getElementById('hideToolbar').checked ? 'none' : 'flex';
            }
        }

        function toggleLinksPanelVisibility() {
            const linksPanel = document.getElementById('linksPanel');
            if (linksPanel) {
                linksPanel.style.display = document.getElementById('hideLinksPanel').checked ? 'none' : 'block';
            }
        }

        function updateFocusStats() {
            if (!focusModeActive || !currentSceneId) return;
            
            const act = project.acts.find(a => a.id === currentActId);
            const chapter = act.chapters.find(c => c.id === currentChapterId);
            const scene = chapter.scenes.find(s => s.id === currentSceneId);
            
            const currentWordCount = getWordCount(scene.content);
            const wordsWritten = Math.max(0, currentWordCount - focusStartWordCount);
            
            document.getElementById('focusWordCount').textContent = wordsWritten;
        }

        // Pomodoro Timer
        let pomodoroTime = 25 * 60; // 25 minutes in seconds
        let pomodoroInterval = null;
        let pomodoroRunning = false;
        let pomodorosCompleted = 0;

        function togglePomodoroPopup() {
            const popup = document.getElementById('pomodoroPopup');
            popup.classList.toggle('active');
        }
        
        // Fermer la popup si on clique ailleurs
        document.addEventListener('click', function(event) {
            const popup = document.getElementById('pomodoroPopup');
            const btn = document.getElementById('pomodoroHeaderBtn');
            if (popup && btn && !popup.contains(event.target) && !btn.contains(event.target)) {
                popup.classList.remove('active');
            }
        });

        function startPomodoro() {
            if (pomodoroRunning) return;
            
            pomodoroRunning = true;
            // Ajouter indicateur visuel sur le bouton header
            const headerBtn = document.getElementById('pomodoroHeaderBtn');
            if (headerBtn) headerBtn.classList.add('pomodoro-active');
            
            pomodoroInterval = setInterval(() => {
                if (pomodoroTime > 0) {
                    pomodoroTime--;
                    updatePomodoroDisplay();
                } else {
                    // Pomodoro completed
                    completedPomodoro();
                }
            }, 1000);
        }

        function pausePomodoro() {
            pomodoroRunning = false;
            // Retirer indicateur visuel
            const headerBtn = document.getElementById('pomodoroHeaderBtn');
            if (headerBtn) headerBtn.classList.remove('pomodoro-active');
            
            if (pomodoroInterval) {
                clearInterval(pomodoroInterval);
                pomodoroInterval = null;
            }
        }

        function resetPomodoro() {
            pausePomodoro();
            pomodoroTime = 25 * 60;
            updatePomodoroDisplay();
        }

        function completedPomodoro() {
            pausePomodoro();
            pomodorosCompleted++;
            document.getElementById('pomodorosCompleted').textContent = pomodorosCompleted;
            
            // Play notification sound (simple beep)
            playNotificationSound();
            
            // Alert user
            alert('🎉 Pomodoro terminé ! Temps de faire une pause de 5 minutes.');
            
            // Reset for next session
            pomodoroTime = 25 * 60;
            updatePomodoroDisplay();
        }

        function updatePomodoroDisplay() {
            const minutes = Math.floor(pomodoroTime / 60);
            const seconds = pomodoroTime % 60;
            document.getElementById('pomodoroDisplay').textContent = 
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        function playNotificationSound() {
            // Create a simple beep sound using Web Audio API
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.value = 800;
            oscillator.type = 'sine';
            
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.5);
        }

        // Update focus stats on content change
        const originalUpdateSceneContent = updateSceneContent;
        updateSceneContent = function() {
            originalUpdateSceneContent();
            updateFocusStats();
        };

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeModal('addChapterModal');
                closeModal('addSceneModal');
                closeModal('addActModal');
                closeModal('addCharacterModal');
                closeModal('addWorldModal');
                closeModal('addTimelineModal');
                closeModal('addNoteModal');
                closeModal('addCodexModal');
                closeModal('backupModal');
                closeModal('referencesModal');
                closeModal('projectsModal');
                closeModal('newProjectModal');
                closeSearchResults();
                
                // Close focus panel if open
                if (focusPanelOpen) {
                    toggleFocusPanel();
                }
            }
            if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
                e.preventDefault();
                document.getElementById('globalSearch').focus();
            }
            if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                e.preventDefault();
                saveProject();
            }
            if (e.key === 'F11') {
                e.preventDefault();
                toggleFocusMode();
            }
            // Raccourci pour le mode révision (Ctrl+R)
            if ((e.ctrlKey || e.metaKey) && e.key === 'r') {
                e.preventDefault();
                if (currentSceneId) {
                    toggleRevisionMode();
                }
            }
        });


        // ============================================
        // REVISION MODE FUNCTIONS
        // ============================================

        function toggleRevisionMode() {
            // Vérifier qu'une scène est ouverte
            if (!currentSceneId) {
                alert('Veuillez d\'abord ouvrir une scène pour activer le mode révision.');
                return;
            }
            
            revisionMode = !revisionMode;
            let toolbar = document.getElementById('editorToolbar');
            if (!toolbar) {
                toolbar = document.querySelector('.editor-toolbar, .revision-toolbar');
            }
            if (!toolbar) {
                console.error('Toolbar not found!');
                alert('Erreur: Barre d\'outils introuvable. Rechargez la page.');
                return;
            }
            const editor = document.querySelector('.editor-textarea');
            const panel = document.getElementById('annotationsPanel');

            if (revisionMode) {
                // Activer le mode révision
                toolbar.className = 'revision-toolbar';
                toolbar.innerHTML = `
                    <span class="revision-badge">✏️ MODE RÉVISION</span>
                    <button class="highlight-btn yellow ${selectedHighlightColor === 'yellow' ? 'active' : ''}" 
                            onclick="selectHighlightColor('yellow')">Jaune</button>
                    <button class="highlight-btn green ${selectedHighlightColor === 'green' ? 'active' : ''}" 
                            onclick="selectHighlightColor('green')">Vert</button>
                    <button class="highlight-btn blue ${selectedHighlightColor === 'blue' ? 'active' : ''}" 
                            onclick="selectHighlightColor('blue')">Bleu</button>
                    <button class="highlight-btn red ${selectedHighlightColor === 'red' ? 'active' : ''}" 
                            onclick="selectHighlightColor('red')">Rouge</button>
                    <button class="highlight-btn purple ${selectedHighlightColor === 'purple' ? 'active' : ''}" 
                            onclick="selectHighlightColor('purple')">Violet</button>
                    <button class="btn" onclick="applyHighlight()">🖍️ Surligner</button>
                    <button class="btn" onclick="removeHighlight()">🗑️ Retirer</button>
                    <button class="btn" onclick="openAnnotationPopup()">💬 Annoter</button>
                    <div style="flex: 1;"></div>
                    <button class="btn btn-primary" onclick="toggleRevisionMode()">✓ Quitter</button>
                `;
                if (editor) editor.contentEditable = 'false';
                // Ne pas afficher automatiquement le panneau
                // L'utilisateur cliquera sur "Voir annotations" s'il le souhaite
            } else {
                // Désactiver le mode révision
                toolbar.className = 'editor-toolbar';
                toolbar.innerHTML = `
                    <!-- Basic formatting -->
                    <div class="toolbar-group">
                        <button class="toolbar-btn" data-format="bold" onclick="formatText('bold')" title="Gras (Ctrl+B)">
                            <strong>B</strong>
                        </button>
                        <button class="toolbar-btn" data-format="italic" onclick="formatText('italic')" title="Italique (Ctrl+I)">
                            <em>I</em>
                        </button>
                        <button class="toolbar-btn" data-format="underline" onclick="formatText('underline')" title="Souligné (Ctrl+U)">
                            <u>U</u>
                        </button>
                        <button class="toolbar-btn" data-format="strikethrough" onclick="formatText('strikeThrough')" title="Barré">
                            <s>S</s>
                        </button>
                    </div>
                    
                    <!-- Font family and size -->
                    <div class="toolbar-group">
                        <select class="font-family-selector" onchange="formatText('fontName', this.value)" title="Police de caractères">
                            <option value="Crimson Pro">Crimson Pro</option>
                            <option value="Arial">Arial</option>
                            <option value="Georgia">Georgia</option>
                            <option value="Times New Roman">Times New Roman</option>
                            <option value="Courier New">Courier New</option>
                            <option value="Verdana">Verdana</option>
                            <option value="Garamond">Garamond</option>
                            <option value="Palatino">Palatino</option>
                        </select>
                        <select class="font-size-selector" onchange="formatText('fontSize', this.value)" title="Taille de police">
                            <option value="1">Très petit</option>
                            <option value="2">Petit</option>
                            <option value="3" selected>Normal</option>
                            <option value="4">Grand</option>
                            <option value="5">Très grand</option>
                            <option value="6">Énorme</option>
                            <option value="7">Gigantesque</option>
                        </select>
                    </div>
                    
                    <!-- Text color -->
                    <div class="toolbar-group">
                        <div class="color-picker-wrapper">
                            <button class="toolbar-btn" onclick="toggleColorPicker('text', event)" title="Couleur du texte">
                                <span style="border-bottom: 3px solid currentColor;">A</span>
                            </button>
                            <div class="color-picker-dropdown" id="textColorPicker">
                                <div class="color-grid" id="textColorGrid"></div>
                                <div class="color-input-wrapper">
                                    <input type="color" id="textColorInput" onchange="applyTextColor(this.value)">
                                    <input type="text" id="textColorHex" placeholder="#000000" maxlength="7" onchange="applyTextColor(this.value)">
                                </div>
                            </div>
                        </div>
                        <div class="color-picker-wrapper">
                            <button class="toolbar-btn" onclick="toggleColorPicker('background', event)" title="Couleur de fond">
                                <span style="background: yellow; padding: 0 4px;">A</span>
                            </button>
                            <div class="color-picker-dropdown" id="backgroundColorPicker">
                                <div class="color-grid" id="backgroundColorGrid"></div>
                                <div class="color-input-wrapper">
                                    <input type="color" id="bgColorInput" onchange="applyBackgroundColor(this.value)">
                                    <input type="text" id="bgColorHex" placeholder="#FFFF00" maxlength="7" onchange="applyBackgroundColor(this.value)">
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Alignment -->
                    <div class="toolbar-group">
                        <button class="toolbar-btn" onclick="formatText('justifyLeft')" title="Aligner à gauche">
                            ⫷
                        </button>
                        <button class="toolbar-btn" onclick="formatText('justifyCenter')" title="Centrer">
                            ⫶
                        </button>
                        <button class="toolbar-btn" onclick="formatText('justifyRight')" title="Aligner à droite">
                            ⫸
                        </button>
                        <button class="toolbar-btn" onclick="formatText('justifyFull')" title="Justifier">
                            ☰
                        </button>
                    </div>
                    
                    <!-- Headings -->
                    <div class="toolbar-group">
                        <button class="toolbar-btn" onclick="formatText('formatBlock', 'h1')" title="Titre 1">H1</button>
                        <button class="toolbar-btn" onclick="formatText('formatBlock', 'h2')" title="Titre 2">H2</button>
                        <button class="toolbar-btn" onclick="formatText('formatBlock', 'h3')" title="Titre 3">H3</button>
                        <button class="toolbar-btn" onclick="formatText('formatBlock', 'p')" title="Paragraphe">P</button>
                    </div>
                    
                    <!-- Lists and quotes -->
                    <div class="toolbar-group">
                        <button class="toolbar-btn" onclick="formatText('insertUnorderedList')" title="Liste à puces">• Liste</button>
                        <button class="toolbar-btn" onclick="formatText('insertOrderedList')" title="Liste numérotée">1. Liste</button>
                        <button class="toolbar-btn" onclick="formatText('formatBlock', 'blockquote')" title="Citation">❝ Citation</button>
                    </div>
                    
                    <!-- Indentation -->
                    <div class="toolbar-group">
                        <button class="toolbar-btn" onclick="formatText('indent')" title="Augmenter l'indentation">→|</button>
                        <button class="toolbar-btn" onclick="formatText('outdent')" title="Diminuer l'indentation">|←</button>
                    </div>
                    
                    <!-- Superscript, subscript -->
                    <div class="toolbar-group">
                        <button class="toolbar-btn" onclick="formatText('superscript')" title="Exposant">x²</button>
                        <button class="toolbar-btn" onclick="formatText('subscript')" title="Indice">x₂</button>
                    </div>
                    
                    <!-- Other -->
                    <div class="toolbar-group">
                        <button class="toolbar-btn" onclick="formatText('insertHorizontalRule')" title="Ligne horizontale">─</button>
                        <button class="toolbar-btn" onclick="formatText('removeFormat')" title="Supprimer le formatage">✕ Format</button>
                    </div>
                    
                    <!-- Revision mode button -->
                    <div class="toolbar-group">
                        <button class="toolbar-btn" onclick="toggleRevisionMode()" title="Mode Révision (Ctrl+R)"><strong>✏️ RÉVISION</strong></button>
                    </div>
                `;
                if (editor) editor.contentEditable = 'true';
                if (panel) panel.classList.remove('visible');
                
                // Réinitialiser les color pickers après reconstruction de la toolbar
                initializeColorPickers();
            }
        }

        function selectHighlightColor(color) {
            selectedHighlightColor = color;
            document.querySelectorAll('.highlight-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`.highlight-btn.${color}`).classList.add('active');
        }

        function applyHighlight() {
            const sel = window.getSelection();
            if (!sel.rangeCount || sel.isCollapsed) {
                alert('Sélectionnez du texte à surligner');
                return;
            }

            const range = sel.getRangeAt(0);
            const span = document.createElement('span');
            span.className = `highlight-${selectedHighlightColor}`;
            
            try {
                range.surroundContents(span);
                updateSceneContent();
            } catch (e) {
                alert('Impossible de surligner cette sélection (essayez une sélection plus simple)');
            }
            
            sel.removeAllRanges();
        }

        function removeHighlight() {
            const sel = window.getSelection();
            if (!sel.rangeCount) {
                alert('Sélectionnez un texte surligné à retirer');
                return;
            }

            const range = sel.getRangeAt(0);
            let node = range.commonAncestorContainer;
            
            if (node.nodeType === 3) {
                node = node.parentElement;
            }

            if (node.className && node.className.includes('highlight-')) {
                const parent = node.parentNode;
                while (node.firstChild) {
                    parent.insertBefore(node.firstChild, node);
                }
                parent.removeChild(node);
                updateSceneContent();
            } else {
                alert('Sélectionnez un texte surligné');
            }

            sel.removeAllRanges();
        }

        function openAnnotationPopup() {
            const sel = window.getSelection();
            if (!sel.rangeCount || sel.isCollapsed) {
                alert('Sélectionnez du texte à annoter');
                return;
            }

            currentSelection = {
                text: sel.toString(),
                range: sel.getRangeAt(0).cloneRange()
            };

            document.getElementById('annotationPopup').classList.add('visible');
            document.getElementById('annotationText').value = '';
            document.getElementById('annotationText').focus();
        }

        function closeAnnotationPopup() {
            document.getElementById('annotationPopup').classList.remove('visible');
            currentSelection = null;
        }

        function selectAnnotationType(type) {
            selectedAnnotationType = type;
            document.querySelectorAll('.annotation-type-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`.annotation-type-btn.${type}`).classList.add('active');
        }

        function saveAnnotation() {
            const text = document.getElementById('annotationText').value.trim();
            if (!text) {
                alert('Veuillez entrer une annotation');
                return;
            }

            const act = project.acts.find(a => a.id === currentActId);
            const chapter = act.chapters.find(c => c.id === currentChapterId);
            const scene = chapter.scenes.find(s => s.id === currentSceneId);

            const annotationId = Date.now();
            
            // Ajouter l'annotation à la version active
            addVersionAnnotation(scene, {
                id: annotationId,
                type: selectedAnnotationType,
                text: text,
                context: currentSelection ? currentSelection.text : '',
                completed: false,
                createdAt: new Date().toISOString()
            });

            // Wrapper le texte sélectionné avec un marqueur
            if (currentSelection && currentSelection.range) {
                try {
                    const span = document.createElement('span');
                    span.id = `annotation-${annotationId}`;
                    span.className = `annotation-marker ${selectedAnnotationType}`;
                    span.setAttribute('data-annotation-id', annotationId);
                    span.style.cursor = 'pointer';
                    span.title = `${getAnnotationTypeLabel(selectedAnnotationType)}: ${text}`;
                    
                    // Définir les styles selon le type
                    const styles = {
                        comment: 'background: rgba(255, 235, 59, 0.3); border-bottom: 2px solid #FBC02D;',
                        question: 'background: rgba(33, 150, 243, 0.3); border-bottom: 2px solid #1976D2;',
                        todo: 'background: rgba(244, 67, 54, 0.3); border-bottom: 2px solid #D32F2F;'
                    };
                    span.style.cssText = styles[selectedAnnotationType] || '';
                    
                    // Wrapper le contenu
                    currentSelection.range.surroundContents(span);
                    
                    // Ajouter un event listener pour cliquer sur le marqueur
                    span.onclick = function(e) {
                        e.stopPropagation();
                        highlightAnnotation(annotationId);
                    };
                    
                    // IMPORTANT: Mettre à jour le contenu de la scène ET de la version active avec le nouveau HTML
                    const editor = document.getElementById('sceneEditor') || document.querySelector('.editor-textarea');
                    if (editor) {
                        scene.content = editor.innerHTML;
                        // Mettre à jour aussi le contenu de la version active
                        const activeVersion = getActiveVersion(scene);
                        if (activeVersion) {
                            activeVersion.content = editor.innerHTML;
                        }
                    }
                } catch (e) {
                    console.warn('Impossible de wrapper le texte:', e);
                }
            }

            saveProject();
            closeAnnotationPopup();
            renderAnnotationsPanel();
            renderActsList();
        }

        function renderAnnotationsPanel() {
            const panel = document.getElementById('annotationsPanelContent');
            const parentPanel = document.getElementById('annotationsPanel');
            
            if (!panel || !parentPanel) {
                console.error('Panneau annotations introuvable');
                return;
            }
            
            // Vérifier qu'une scène est sélectionnée
            if (!currentSceneId || !currentChapterId || !currentActId) {
                panel.innerHTML = `
                    <div class="annotations-panel-header">
                        <h3 style="margin: 0;">Annotations</h3>
                        <span class="annotations-panel-close" onclick="closeAnnotationsPanel()" title="Fermer">×</span>
                    </div>
                    <p style="text-align: center; color: var(--text-muted); padding: 2rem;">Sélectionnez une scène pour voir ses annotations</p>
                `;
                parentPanel.classList.add('visible');
                return;
            }
            
            const act = project.acts.find(a => a.id === currentActId);
            const chapter = act ? act.chapters.find(c => c.id === currentChapterId) : null;
            const scene = chapter ? chapter.scenes.find(s => s.id === currentSceneId) : null;
            
            if (!scene) {
                panel.innerHTML = `
                    <div class="annotations-panel-header">
                        <h3 style="margin: 0;">Annotations</h3>
                        <span class="annotations-panel-close" onclick="closeAnnotationsPanel()" title="Fermer">×</span>
                    </div>
                    <p style="text-align: center; color: var(--text-muted); padding: 2rem;">Scène introuvable</p>
                `;
                parentPanel.classList.add('visible');
                return;
            }
            
            // Migrer les anciennes annotations si nécessaire
            migrateSceneAnnotationsToVersion(scene);

            // Obtenir les annotations de la version active
            const annotations = getVersionAnnotations(scene);
            const activeVersion = getActiveVersion(scene);
            const versionLabel = activeVersion ? (activeVersion.label || `Version ${activeVersion.number}`) : '';

            if (!annotations || annotations.length === 0) {
                panel.innerHTML = `
                    <div class="annotations-panel-header">
                        <h3 style="margin: 0;">Annotations (0)</h3>
                        <span class="annotations-panel-close" onclick="closeAnnotationsPanel()" title="Fermer">×</span>
                    </div>
                    ${versionLabel ? `<div style="font-size: 0.75rem; color: var(--text-muted); padding: 0.5rem 1rem; background: var(--bg-tertiary); border-bottom: 1px solid var(--border-color);">📌 ${versionLabel}</div>` : ''}
                    <p style="text-align: center; color: var(--text-muted); padding: 2rem;">Aucune annotation pour cette version</p>
                `;
            } else {
                panel.innerHTML = `
                    <div class="annotations-panel-header">
                        <h3 style="margin: 0;">Annotations (${annotations.length})</h3>
                        <span class="annotations-panel-close" onclick="closeAnnotationsPanel()" title="Fermer">×</span>
                    </div>
                    ${versionLabel ? `<div style="font-size: 0.75rem; color: var(--text-muted); padding: 0.5rem 1rem; background: var(--bg-tertiary); border-bottom: 1px solid var(--border-color);">📌 ${versionLabel}</div>` : ''}
                    ${annotations.map(a => `
                        <div class="annotation-card ${a.type}" onclick="scrollToAnnotation(${a.id})">
                            <div class="annotation-type ${a.type}">${getAnnotationTypeLabel(a.type)}</div>
                            <div class="annotation-content">${a.text}</div>
                            ${a.context ? `<div class="annotation-context">"${a.context}"</div>` : ''}
                            ${a.type === 'todo' ? `
                                <button class="btn btn-small ${a.completed ? 'btn-primary' : ''}" 
                                        onclick="event.stopPropagation(); toggleAnnotationComplete(${a.id})" 
                                        style="margin-top: 0.5rem;">
                                    ${a.completed ? '✓ Terminé' : '○ À faire'}
                                </button>
                            ` : ''}
                            <button class="btn btn-small" onclick="event.stopPropagation(); deleteAnnotation(${a.id})" 
                                    style="margin-top: 0.5rem;">Supprimer</button>
                        </div>
                    `).join('')}
                `;
            }

            // Afficher le panneau
            parentPanel.classList.add('visible');
        }



        function toggleAnnotationsPanel() {
            const panel = document.getElementById('annotationsPanel');
            if (panel.classList.contains('visible')) {
                panel.classList.remove('visible');
                updateAnnotationsButton(false);
            } else {
                renderAnnotationsPanel();
                updateAnnotationsButton(true);
            }
        }

        function closeAnnotationsPanel() {
            const panel = document.getElementById('annotationsPanel');
            if (panel) {
                panel.classList.remove('visible');
                updateAnnotationsButton(false);
            }
        }
        
        function updateAnnotationsButton(isOpen) {
            const toolbarBtn = document.getElementById('toolbarAnnotationsBtn');
            const sidebarBtn = document.getElementById('sidebarAnnotationsBtn');
            const sidebarBadge = document.getElementById('annotationsBadge');
            const todosBadge = document.getElementById('todosBadge');
            
            // Compter les annotations et TODOs de la scène courante (version active)
            let annotationCount = 0;
            let todoCount = 0;
            
            if (currentSceneId) {
                const act = project.acts.find(a => a.id === currentActId);
                if (act) {
                    const chapter = act.chapters.find(c => c.id === currentChapterId);
                    if (chapter) {
                        const scene = chapter.scenes.find(s => s.id === currentSceneId);
                        if (scene) {
                            const annotations = getVersionAnnotations(scene);
                            annotationCount = annotations.length;
                            todoCount = annotations.filter(a => a.type === 'todo' && !a.completed).length;
                        }
                    }
                }
            }
            
            // Compter tous les TODOs non complétés du projet (toutes versions actives)
            let totalTodos = 0;
            project.acts.forEach(act => {
                act.chapters.forEach(chapter => {
                    chapter.scenes.forEach(scene => {
                        const annotations = getVersionAnnotations(scene);
                        totalTodos += annotations.filter(a => a.type === 'todo' && !a.completed).length;
                    });
                });
            });
            
            // Mettre à jour le badge toolbar
            if (toolbarBtn) {
                if (annotationCount > 0) {
                    toolbarBtn.classList.add('has-annotations');
                    toolbarBtn.setAttribute('data-count', annotationCount > 9 ? '9+' : annotationCount);
                } else {
                    toolbarBtn.classList.remove('has-annotations');
                    toolbarBtn.removeAttribute('data-count');
                }
                
                if (isOpen) {
                    toolbarBtn.classList.add('panel-open');
                } else {
                    toolbarBtn.classList.remove('panel-open');
                }
            }
            
            // Mettre à jour le bouton sidebar annotations
            if (sidebarBtn) {
                if (isOpen) {
                    sidebarBtn.classList.add('active');
                } else {
                    sidebarBtn.classList.remove('active');
                }
            }
            
            // Mettre à jour le badge sidebar annotations
            if (sidebarBadge) {
                if (annotationCount > 0) {
                    sidebarBadge.style.display = 'inline';
                    sidebarBadge.textContent = annotationCount > 9 ? '9+' : annotationCount;
                } else {
                    sidebarBadge.style.display = 'none';
                }
            }
            
            // Mettre à jour le badge sidebar TODOs
            if (todosBadge) {
                if (totalTodos > 0) {
                    todosBadge.style.display = 'inline';
                    todosBadge.textContent = totalTodos > 9 ? '9+' : totalTodos;
                } else {
                    todosBadge.style.display = 'none';
                }
            }
        }

        function getAnnotationTypeLabel(type) {
            const labels = {
                comment: 'Commentaire',
                todo: 'TODO',
                note: 'Note',
                question: 'Question'
            };
            return labels[type] || type;
        }

        // ============ ANNOTATIONS LIÉES AUX VERSIONS ============
        
        // Obtenir la version active d'une scène (ou créer une version par défaut)
        function getActiveVersion(scene) {
            if (!scene.versions || scene.versions.length === 0) {
                return null;
            }
            return scene.versions.find(v => v.isActive) || scene.versions[scene.versions.length - 1];
        }
        
        // Obtenir les annotations de la version active
        function getVersionAnnotations(scene) {
            const activeVersion = getActiveVersion(scene);
            if (activeVersion) {
                if (!activeVersion.annotations) {
                    activeVersion.annotations = [];
                }
                return activeVersion.annotations;
            }
            // Fallback: annotations au niveau scène (anciennes données)
            if (!scene.annotations) {
                scene.annotations = [];
            }
            return scene.annotations;
        }
        
        // Ajouter une annotation à la version active
        function addVersionAnnotation(scene, annotation) {
            const activeVersion = getActiveVersion(scene);
            if (activeVersion) {
                if (!activeVersion.annotations) {
                    activeVersion.annotations = [];
                }
                activeVersion.annotations.push(annotation);
            } else {
                // Fallback si pas de version
                if (!scene.annotations) {
                    scene.annotations = [];
                }
                scene.annotations.push(annotation);
            }
        }
        
        // Supprimer une annotation de la version active
        function removeVersionAnnotation(scene, annotationId) {
            const activeVersion = getActiveVersion(scene);
            if (activeVersion && activeVersion.annotations) {
                activeVersion.annotations = activeVersion.annotations.filter(a => a.id !== annotationId);
            } else if (scene.annotations) {
                scene.annotations = scene.annotations.filter(a => a.id !== annotationId);
            }
        }
        
        // Trouver une annotation dans la version active
        function findVersionAnnotation(scene, annotationId) {
            const annotations = getVersionAnnotations(scene);
            return annotations.find(a => a.id === annotationId);
        }
        
        // Migrer les annotations d'une scène vers sa version active (migration one-time)
        function migrateSceneAnnotationsToVersion(scene) {
            if (scene.annotations && scene.annotations.length > 0) {
                const activeVersion = getActiveVersion(scene);
                if (activeVersion) {
                    if (!activeVersion.annotations) {
                        activeVersion.annotations = [];
                    }
                    // Migrer seulement si la version n'a pas déjà ces annotations
                    scene.annotations.forEach(ann => {
                        if (!activeVersion.annotations.find(a => a.id === ann.id)) {
                            activeVersion.annotations.push(ann);
                        }
                    });
                    // Vider les annotations au niveau scène après migration
                    scene.annotations = [];
                    return true; // Migration effectuée
                }
            }
            return false;
        }
        
        // ============ FIN ANNOTATIONS LIÉES AUX VERSIONS ============

        function toggleAnnotationComplete(annotationId) {
            const act = project.acts.find(a => a.id === currentActId);
            const chapter = act.chapters.find(c => c.id === currentChapterId);
            const scene = chapter.scenes.find(s => s.id === currentSceneId);
            const annotation = findVersionAnnotation(scene, annotationId);

            if (annotation) {
                annotation.completed = !annotation.completed;
                saveProject();
                renderAnnotationsPanel();
                renderActsList();
            }
        }

        function deleteAnnotation(annotationId) {
            if (!confirm('Supprimer cette annotation ?')) return;

            const act = project.acts.find(a => a.id === currentActId);
            const chapter = act.chapters.find(c => c.id === currentChapterId);
            const scene = chapter.scenes.find(s => s.id === currentSceneId);

            // Supprimer le marqueur visuel dans l'éditeur
            const marker = document.getElementById(`annotation-${annotationId}`);
            if (marker) {
                // Remplacer le span par son contenu textuel
                const textContent = marker.textContent;
                const textNode = document.createTextNode(textContent);
                marker.parentNode.replaceChild(textNode, marker);
                
                // Mettre à jour le contenu de la scène avec le HTML nettoyé
                const editor = document.querySelector('.editor-textarea');
                if (editor) {
                    scene.content = editor.innerHTML;
                    // Mettre à jour aussi la version active
                    const activeVersion = getActiveVersion(scene);
                    if (activeVersion) {
                        activeVersion.content = editor.innerHTML;
                    }
                }
            }
            
            // Aussi nettoyer dans scene.content si le marqueur est sauvegardé (fallback)
            if (scene.content) {
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = scene.content;
                const savedMarker = tempDiv.querySelector(`#annotation-${annotationId}, [data-annotation-id="${annotationId}"]`);
                if (savedMarker) {
                    const textContent = savedMarker.textContent;
                    const textNode = document.createTextNode(textContent);
                    savedMarker.parentNode.replaceChild(textNode, savedMarker);
                    scene.content = tempDiv.innerHTML;
                }
            }

            // Supprimer l'annotation de la version active
            removeVersionAnnotation(scene, annotationId);
            
            // Mettre à jour aussi le contenu de la version active (fallback)
            const activeVersion = getActiveVersion(scene);
            if (activeVersion && activeVersion.content) {
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = activeVersion.content;
                const versionMarker = tempDiv.querySelector(`#annotation-${annotationId}, [data-annotation-id="${annotationId}"]`);
                if (versionMarker) {
                    const textContent = versionMarker.textContent;
                    const textNode = document.createTextNode(textContent);
                    versionMarker.parentNode.replaceChild(textNode, versionMarker);
                    activeVersion.content = tempDiv.innerHTML;
                }
            }
            
            saveProject();
            renderAnnotationsPanel();
            renderActsList();
            showNotification('✓ Annotation supprimée');
        }

        function scrollToAnnotation(annotationId) {
            // NE PAS fermer le panneau - l'utilisateur veut peut-être voir plusieurs annotations
            
            // Trouver le marqueur dans le texte
            const marker = document.getElementById(`annotation-${annotationId}`);
            
            if (marker) {
                // Trouver le conteneur scrollable de l'éditeur
                const editorWorkspace = document.querySelector('.editor-workspace');
                
                if (editorWorkspace) {
                    // Calculer la position relative du marqueur
                    const markerRect = marker.getBoundingClientRect();
                    const workspaceRect = editorWorkspace.getBoundingClientRect();
                    
                    // Calculer le scroll nécessaire pour centrer le marqueur
                    const targetScroll = editorWorkspace.scrollTop + (markerRect.top - workspaceRect.top) - (workspaceRect.height / 2);
                    
                    editorWorkspace.scrollTo({
                        top: Math.max(0, targetScroll),
                        behavior: 'smooth'
                    });
                }
                
                // Highlighter temporairement
                highlightAnnotation(annotationId);
            } else {
                // Si le marqueur n'existe pas (ancienne annotation), juste informer
                console.warn(`Marqueur annotation-${annotationId} introuvable`);
                showNotification('Annotation non localisée dans le texte');
            }
        }
        
        function highlightAnnotation(annotationId) {
            const marker = document.getElementById(`annotation-${annotationId}`);
            if (!marker) return;
            
            // Sauvegarder le style original
            const originalStyle = marker.style.cssText;
            
            // Ajouter une animation de highlight
            marker.style.cssText = originalStyle + ' background: rgba(212, 175, 55, 0.8) !important; transition: background 0.3s;';
            
            // Pulser 3 fois
            let pulseCount = 0;
            const pulseInterval = setInterval(() => {
                if (pulseCount >= 6) {
                    clearInterval(pulseInterval);
                    // Restaurer le style original
                    marker.style.cssText = originalStyle;
                    return;
                }
                
                if (pulseCount % 2 === 0) {
                    marker.style.cssText = originalStyle + ' background: rgba(212, 175, 55, 0.8) !important;';
                } else {
                    marker.style.cssText = originalStyle;
                }
                pulseCount++;
            }, 400);
        }
        
        function closeAnnotationsPanel() {
            const panel = document.getElementById('annotationsPanel');
            if (panel) {
                panel.classList.remove('visible');
            }
        }

        // ==========================================
        // TODOS PANEL
        // ==========================================
        
        function toggleTodosPanel() {
            const panel = document.getElementById('todosPanel');
            const btn = document.getElementById('sidebarTodosBtn');
            
            if (panel.classList.contains('visible')) {
                panel.classList.remove('visible');
                if (btn) btn.classList.remove('active');
            } else {
                renderTodosPanel();
                panel.classList.add('visible');
                if (btn) btn.classList.add('active');
            }
        }
        
        function closeTodosPanel() {
            const panel = document.getElementById('todosPanel');
            const btn = document.getElementById('sidebarTodosBtn');
            if (panel) {
                panel.classList.remove('visible');
            }
            if (btn) btn.classList.remove('active');
        }
        
        function renderTodosPanel() {
            const panel = document.getElementById('todosPanelContent');
            const parentPanel = document.getElementById('todosPanel');
            
            if (!panel || !parentPanel) {
                console.error('Panneau TODOs introuvable');
                return;
            }
            
            // Collecter tous les TODOs du projet (de la version active de chaque scène)
            const todos = [];
            project.acts.forEach(act => {
                act.chapters.forEach(chapter => {
                    chapter.scenes.forEach(scene => {
                        const annotations = getVersionAnnotations(scene);
                        annotations
                            .filter(a => a.type === 'todo')
                            .forEach(todo => {
                                todos.push({
                                    ...todo,
                                    actId: act.id,
                                    actTitle: act.title,
                                    chapterId: chapter.id,
                                    chapterTitle: chapter.title,
                                    sceneId: scene.id,
                                    sceneTitle: scene.title
                                });
                            });
                    });
                });
            });
            
            const pendingTodos = todos.filter(t => !t.completed);
            const completedTodos = todos.filter(t => t.completed);
            
            if (todos.length === 0) {
                panel.innerHTML = `
                    <div class="annotations-panel-header">
                        <h3 style="margin: 0;"><i data-lucide="check-square" style="width:18px;height:18px;vertical-align:middle;margin-right:6px;"></i>TODOs (0)</h3>
                        <span class="annotations-panel-close" onclick="closeTodosPanel()" title="Fermer">×</span>
                    </div>
                    <p style="text-align: center; color: var(--text-muted); padding: 2rem;">Aucun TODO dans le projet</p>
                `;
            } else {
                panel.innerHTML = `
                    <div class="annotations-panel-header">
                        <h3 style="margin: 0;"><i data-lucide="check-square" style="width:18px;height:18px;vertical-align:middle;margin-right:6px;"></i>TODOs (${pendingTodos.length} actif${pendingTodos.length > 1 ? 's' : ''})</h3>
                        <span class="annotations-panel-close" onclick="closeTodosPanel()" title="Fermer">×</span>
                    </div>
                    
                    ${pendingTodos.length > 0 ? `
                        <div style="margin-bottom: 1rem;">
                            <div style="font-size: 0.75rem; font-weight: 600; color: var(--text-muted); margin-bottom: 0.5rem; text-transform: uppercase;">À faire</div>
                            ${pendingTodos.map(todo => `
                                <div class="annotation-card todo" onclick="goToTodoScene(${todo.actId}, ${todo.chapterId}, ${todo.sceneId})" style="cursor: pointer;">
                                    <div style="font-size: 0.7rem; color: var(--text-muted); margin-bottom: 0.25rem;">${todo.sceneTitle}</div>
                                    <div class="annotation-content">${todo.text}</div>
                                    <div style="display: flex; gap: 0.5rem; margin-top: 0.5rem;">
                                        <button class="btn btn-small" onclick="event.stopPropagation(); toggleTodoFromPanel(${todo.actId}, ${todo.chapterId}, ${todo.sceneId}, ${todo.id})">
                                            Marquer terminé
                                        </button>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    ` : ''}
                    
                    ${completedTodos.length > 0 ? `
                        <div>
                            <div style="font-size: 0.75rem; font-weight: 600; color: var(--text-muted); margin-bottom: 0.5rem; text-transform: uppercase;">Terminés (${completedTodos.length})</div>
                            ${completedTodos.map(todo => `
                                <div class="annotation-card" style="opacity: 0.6; cursor: pointer;" onclick="goToTodoScene(${todo.actId}, ${todo.chapterId}, ${todo.sceneId})">
                                    <div style="font-size: 0.7rem; color: var(--text-muted); margin-bottom: 0.25rem;">${todo.sceneTitle}</div>
                                    <div class="annotation-content" style="text-decoration: line-through;">${todo.text}</div>
                                    <div style="display: flex; gap: 0.5rem; margin-top: 0.5rem;">
                                        <button class="btn btn-small" onclick="event.stopPropagation(); toggleTodoFromPanel(${todo.actId}, ${todo.chapterId}, ${todo.sceneId}, ${todo.id})">
                                            Rouvrir
                                        </button>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    ` : ''}
                `;
            }
            
            // Afficher le panneau
            parentPanel.classList.add('visible');
            
            // Rafraîchir les icônes Lucide
            setTimeout(() => {
                if (typeof lucide !== 'undefined') lucide.createIcons();
            }, 10);
        }
        
        function goToTodoScene(actId, chapterId, sceneId) {
            openScene(actId, chapterId, sceneId);
            closeTodosPanel();
        }
        
        function toggleTodoFromPanel(actId, chapterId, sceneId, todoId) {
            const act = project.acts.find(a => a.id === actId);
            if (!act) return;
            const chapter = act.chapters.find(c => c.id === chapterId);
            if (!chapter) return;
            const scene = chapter.scenes.find(s => s.id === sceneId);
            if (!scene) return;
            
            const todo = findVersionAnnotation(scene, todoId);
            if (todo) {
                todo.completed = !todo.completed;
                saveProject();
                renderTodosPanel();
                updateAnnotationsButton(false);
                renderActsList();
            }
        }

        function getSceneAnnotationCount(scene) {
            const annotations = getVersionAnnotations(scene);
            return annotations.length;
        }

        function getSceneTodoCount(scene) {
            const annotations = getVersionAnnotations(scene);
            return annotations.filter(a => a.type === 'todo' && !a.completed).length;
        }

        // Modifier la fonction renderEditor pour ajouter le bouton révision
        const originalRenderEditor = renderEditor;
        renderEditor = function(act, chapter, scene) {
            originalRenderEditor(act, chapter, scene);
            
            // Ajouter le bouton révision dans la toolbar si pas déjà en mode révision
            if (!revisionMode) {
                const toolbar = document.getElementById('editorToolbar');
                if (toolbar && !toolbar.querySelector('[onclick*="toggleRevisionMode"]')) {
                    const revisionGroup = document.createElement('div');
                    revisionGroup.className = 'toolbar-group';
                    revisionGroup.innerHTML = '<button class="toolbar-btn" onclick="toggleRevisionMode()" title="Mode Révision (Ctrl+R)"><i data-lucide="pencil" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>RÉVISION</button>';
                    try {
                        toolbar.appendChild(revisionGroup);
                    } catch(e) {
                        console.error('Erreur appendChild toolbar:', e);
                    }
                }
            }
            
            // Rafraîchir les icônes Lucide après le rendu
            setTimeout(() => {
                if (typeof lucide !== 'undefined') lucide.createIcons();
                // Réattacher les event listeners sur les marqueurs d'annotation
                reattachAnnotationMarkerListeners();
            }, 10);
        };

        // Modifier renderActsList pour afficher les badges d'annotations
        const originalRenderActsList = renderActsList;
        renderActsList = function() {
            originalRenderActsList();
            
            // Ajouter les badges d'annotations aux scènes (version active)
            project.acts.forEach(act => {
                act.chapters.forEach(chapter => {
                    chapter.scenes.forEach(scene => {
                        const sceneElement = document.querySelector(`[data-scene-id="${scene.id}"]`);
                        const annotations = getVersionAnnotations(scene);
                        if (sceneElement && annotations.length > 0) {
                            const annotCount = annotations.length;
                            const todoCount = annotations.filter(a => a.type === 'todo' && !a.completed).length;
                            
                            let badgeHTML = `<span class="scene-badge">${annotCount}</span>`;
                            if (todoCount > 0) {
                                badgeHTML += `<span class="scene-badge" style="background: var(--accent-red);">✓${todoCount}</span>`;
                            }
                            
                            const textSpan = sceneElement.querySelector('div > span:not(.drag-handle)');
                            if (textSpan && !textSpan.querySelector('.scene-badge')) {
                                textSpan.innerHTML += badgeHTML;
                            }
                        }
                    });
                });
            });
        };

        // Initialiser les annotations dans les scènes existantes (migration vers versions)
        function ensureAnnotationsStructure() {
            let needsSave = false;
            project.acts.forEach(act => {
                act.chapters.forEach(chapter => {
                    chapter.scenes.forEach(scene => {
                        // Migrer les anciennes annotations vers la version active
                        if (migrateSceneAnnotationsToVersion(scene)) {
                            needsSave = true;
                        }
                    });
                });
            });
            if (needsSave) {
                saveProject();
                console.log('Migration des annotations vers les versions effectuée');
            }
        }

        // Appeler au chargement
        const originalInit = init;
        init = function() {
            originalInit();
            ensureAnnotationsStructure();
        };

        // ============================================
        // TODO LIST VIEW
        // ============================================



        function renderTodosList() {
            // Afficher dans editorView au lieu de la sidebar
            const editorView = document.getElementById('editorView');
            if (!editorView) {
                console.error('editorView not found');
                return;
            }
            
            // Collecter tous les TODOs (de la version active de chaque scène)
            const todos = [];
            project.acts.forEach(act => {
                act.chapters.forEach(chapter => {
                    chapter.scenes.forEach(scene => {
                        const annotations = getVersionAnnotations(scene);
                        annotations.filter(a => a.type === 'todo').forEach(todo => {
                            todos.push({
                                ...todo,
                                actId: act.id,
                                actTitle: act.title,
                                chapterId: chapter.id,
                                chapterTitle: chapter.title,
                                sceneId: scene.id,
                                sceneTitle: scene.title
                            });
                        });
                    });
                });
            });
            
            // Trier: non terminés d'abord
            todos.sort((a, b) => {
                if (a.completed === b.completed) return 0;
                return a.completed ? 1 : -1;
            });
            
            if (todos.length === 0) {
                editorView.innerHTML = '<div style="height: 100%; overflow-y: auto; padding: 3rem; text-align: center; color: var(--text-muted); font-size: 1.2rem;">📝 Aucun TODO<br><br><small style="font-size: 0.9rem;">Les TODOs apparaissent lorsque vous utilisez le mode révision</small></div>';
            } else {
                editorView.innerHTML = `
                    <div style="height: 100%; overflow-y: auto; padding: 2rem 3rem;">
                        <h2 style="margin-bottom: 2rem; color: var(--accent-gold);"><i data-lucide="check-square" style="width:24px;height:24px;vertical-align:middle;margin-right:8px;"></i>TODOs (${todos.filter(t => !t.completed).length} actifs)</h2>
                        <div style="display: flex; flex-direction: column; gap: 1rem;">
                        ${todos.map(todo => `
                            <div class="todo-item" onclick="openSceneFromTodo(${todo.actId}, ${todo.chapterId}, ${todo.sceneId})" 
                                 style="display: flex; gap: 1rem; padding: 1rem; background: var(--bg-secondary); border-left: 3px solid ${todo.completed ? 'var(--text-muted)' : 'var(--accent-gold)'}; border-radius: 4px; cursor: pointer; transition: all 0.2s;">
                                <input type="checkbox" ${todo.completed ? 'checked' : ''} 
                                       onclick="event.stopPropagation(); toggleTodoFromList(${todo.id}, ${todo.actId}, ${todo.chapterId}, ${todo.sceneId})"
                                       style="margin-top: 0.25rem;">
                                <div style="flex: 1;">
                                    <div style="font-size: 1rem; ${todo.completed ? 'text-decoration: line-through; opacity: 0.6;' : 'font-weight: 500;'}">${todo.text}</div>
                                    <div style="font-size: 0.85rem; color: var(--text-muted); margin-top: 0.5rem;">
                                        📍 ${todo.actTitle} › ${todo.chapterTitle} › ${todo.sceneTitle}
                                    </div>
                                </div>
                            </div>
                        `).join('')}
                        </div>
                    </div>
                `;
            }
        }

        function toggleTodoFromList(todoId, actId, chapterId, sceneId) {
            const act = project.acts.find(a => a.id === actId);
            const chapter = act.chapters.find(c => c.id === chapterId);
            const scene = chapter.scenes.find(s => s.id === sceneId);
            const todo = findVersionAnnotation(scene, todoId);
            
            if (todo) {
                todo.completed = !todo.completed;
                saveProject();
                renderTodosList();
                renderActsList();
            }
        }

        function openSceneFromTodo(actId, chapterId, sceneId) {
            switchView('editor');
            openScene(actId, chapterId, sceneId);
        }

        // ============================================
        // FIN REVISION MODE
        // ============================================

        // Initialize on load

        // Calculer la hauteur de la toolbar pour le panneau d'annotations
        function updateAnnotationsPanelPosition() {
            const header = document.querySelector('.editor-header');
            const toolbar = document.querySelector('.editor-toolbar, .revision-toolbar');
            const linksPanel = document.getElementById('linksPanel');
            const panel = document.getElementById('annotationsPanel');
            
            if (header && toolbar && panel) {
                let totalHeight = header.offsetHeight + toolbar.offsetHeight;
                if (linksPanel && linksPanel.style.display !== 'none') {
                    totalHeight += linksPanel.offsetHeight;
                }
                panel.style.setProperty('--toolbar-height', totalHeight + 'px');
            }
        }
        
        // Appeler lors de l'ouverture du panneau
        const originalRenderAnnotationsPanel = renderAnnotationsPanel;
        renderAnnotationsPanel = function() {
            originalRenderAnnotationsPanel();
            setTimeout(updateAnnotationsPanelPosition, 50);
        };


        // ============================================
        // CORK BOARD FUNCTIONS
        // ============================================
        
        let corkBoardFilter = {
            type: 'all', // 'all', 'act', 'chapter'
            actId: null,
            chapterId: null
        };
        
        function renderCorkBoard() {
            const container = document.getElementById('corkboardList');
            
            // Construire les options de chapitres
            let chaptersOptions = '';
            if (corkBoardFilter.actId) {
                const act = project.acts.find(a => a.id === parseInt(corkBoardFilter.actId));
                if (act) {
                    chaptersOptions = act.chapters.map(ch => 
                        `<option value="${ch.id}" ${corkBoardFilter.chapterId == ch.id ? 'selected' : ''}>${ch.title}</option>`
                    ).join('');
                }
            }
            
            container.innerHTML = `
                <div style="padding: 1.5rem;">
                    <div style="margin-bottom: 1.5rem;">
                        <h3 style="margin-bottom: 0.5rem;"><i data-lucide="layout-grid" style="width:18px;height:18px;vertical-align:middle;margin-right:6px;"></i>Tableau Cork Board</h3>
                        <p style="font-size: 0.85rem; color: var(--text-muted);">
                            Organisez vos scènes visuellement
                        </p>
                    </div>
                    
                    <div style="margin-bottom: 1rem;">
                        <label style="font-size: 0.85rem; color: var(--text-muted); display: block; margin-bottom: 0.5rem;">
                            Filtrer par acte :
                        </label>
                        <select id="corkActFilter" class="form-input" onchange="updateCorkActFilter(this.value)">
                            <option value="all" ${corkBoardFilter.type === 'all' ? 'selected' : ''}>Tous les actes</option>
                            ${project.acts.map(act => 
                                `<option value="${act.id}" ${corkBoardFilter.actId == act.id ? 'selected' : ''}>${act.title}</option>`
                            ).join('')}
                        </select>
                    </div>
                    
                    ${corkBoardFilter.actId ? `
                        <div style="margin-bottom: 1rem;">
                            <label style="font-size: 0.85rem; color: var(--text-muted); display: block; margin-bottom: 0.5rem;">
                                Filtrer par chapitre :
                            </label>
                            <select id="corkChapterFilter" class="form-input" onchange="updateCorkChapterFilter(this.value)">
                                <option value="all">Tous les chapitres de cet acte</option>
                                ${chaptersOptions}
                            </select>
                        </div>
                    ` : ''}
                    
                    <button class="btn btn-primary" style="width: 100%;" onclick="openCorkBoardView()">
                        Ouvrir le tableau
                    </button>
                </div>
            `;
        }
        
        function updateCorkActFilter(actId) {
            if (actId === 'all') {
                corkBoardFilter = { type: 'all', actId: null, chapterId: null };
            } else {
                corkBoardFilter = { type: 'act', actId: parseInt(actId), chapterId: null };
            }
            renderCorkBoard();
        }
        
        function updateCorkChapterFilter(chapterId) {
            if (chapterId === 'all') {
                corkBoardFilter.type = 'act';
                corkBoardFilter.chapterId = null;
            } else {
                corkBoardFilter.type = 'chapter';
                corkBoardFilter.chapterId = parseInt(chapterId);
            }
            renderCorkBoard();
        }
        
        function filterAndRefreshCork(actId, chapterId) {
            if (actId === 'all') {
                corkBoardFilter = { type: 'all', actId: null, chapterId: null };
            } else if (chapterId === 'all' || !chapterId) {
                corkBoardFilter = { type: 'act', actId: parseInt(actId), chapterId: null };
            } else {
                corkBoardFilter = { type: 'chapter', actId: parseInt(actId), chapterId: parseInt(chapterId) };
            }
            openCorkBoardView();
        }
        

        function closeCorkBoardView() {
            switchView('corkboard');
            renderCorkBoard();
        }

        function openCorkBoardView() {
            // Ouvrir la vue Cork Board dans l'éditeur
            const editorView = document.getElementById('editorView');
            editorView.innerHTML = renderCorkBoardFullView();
            
            // Setup drag and drop
            setupCorkBoardDragAndDrop();
        }
        
        function renderCorkBoardFullView() {
            // Collecter toutes les scènes selon le filtre
            let scenes = [];
            
            if (corkBoardFilter.type === 'all') {
                project.acts.forEach(act => {
                    act.chapters.forEach(chapter => {
                        chapter.scenes.forEach(scene => {
                            scenes.push({
                                ...scene,
                                actId: act.id,
                                actTitle: act.title,
                                chapterId: chapter.id,
                                chapterTitle: chapter.title
                            });
                        });
                    });
                });
            } else if (corkBoardFilter.type === 'act') {
                const act = project.acts.find(a => a.id === corkBoardFilter.actId);
                if (act) {
                    act.chapters.forEach(chapter => {
                        chapter.scenes.forEach(scene => {
                            scenes.push({
                                ...scene,
                                actId: act.id,
                                actTitle: act.title,
                                chapterId: chapter.id,
                                chapterTitle: chapter.title
                            });
                        });
                    });
                }
            } else if (corkBoardFilter.type === 'chapter') {
                const act = project.acts.find(a => a.id === corkBoardFilter.actId);
                if (act) {
                    const chapter = act.chapters.find(c => c.id === corkBoardFilter.chapterId);
                    if (chapter) {
                        chapter.scenes.forEach(scene => {
                            scenes.push({
                                ...scene,
                                actId: act.id,
                                actTitle: act.title,
                                chapterId: chapter.id,
                                chapterTitle: chapter.title
                            });
                        });
                    }
                }
            }
            
            // Vue organisée par actes et chapitres (style NovelCrafter)
            if (project.acts.length === 0 || (project.acts.length === 1 && project.acts[0].chapters.length === 0)) {
                return `
                    <div class="cork-board-container">
                        <div class="cork-board-header">
                            <div class="cork-board-title"><i data-lucide="layout-grid" style="width:16px;height:16px;vertical-align:middle;margin-right:6px;"></i>Cork Board</div>
                            <button class="btn" onclick="closeCorkBoardView()">← Retour</button>
                        </div>
                        <div class="cork-board-empty">
                            <div class="cork-board-empty-icon"><i data-lucide="layout-grid" style="width:48px;height:48px;"></i></div>
                            <div style="font-size: 1.2rem; margin-bottom: 0.5rem;">Aucun chapitre</div>
                            <div style="margin-bottom: 1rem;">Créez votre premier chapitre pour commencer à structurer votre histoire</div>
                            <button class="btn btn-primary" onclick="openAddChapterModal()">+ Créer un chapitre</button>
                        </div>
                    </div>
                `;
            }
            
            // Compter le total de chapitres
            const totalChapters = project.acts.reduce((sum, act) => sum + act.chapters.length, 0);
            
            // Vue organisée par actes et chapitres
            let html = `
                <div class="cork-board-container" style="min-height: 100vh; padding: 2rem;">
                    <div class="cork-board-header" style="margin-bottom: 2rem;">
                        <div class="cork-board-title">
                            <i data-lucide="list" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Vue Structure Organisée
                        </div>
                        <div style="display: flex; gap: 0.5rem;">
                            <button class="btn" onclick="closeCorkBoardView()">← Retour</button>
                        </div>
                    </div>
                    
                    <div style="display: flex; flex-direction: column; gap: 2rem;">
            `;
            
            // Générer les actes
            project.acts.forEach((act, actIndex) => {
                const actScenes = scenes.filter(s => s.actId === act.id);
                // Ne pas masquer les actes vides - les afficher quand même
                
                html += `
                    <div class="structured-act-container">
                        <div class="structured-act-header">
                            <button class="structured-collapse-btn" onclick="toggleStructuredAct(${act.id})">
                                <span class="collapse-icon" id="collapse-icon-${act.id}">▼</span>
                            </button>
                            <span class="structured-act-title">${act.title}</span>
                            <button class="btn btn-small" onclick="createChapterFromCork(${act.id})">+ Nouveau Chapitre</button>
                            <span class="structured-count">${act.chapters.length} chapitre${act.chapters.length > 1 ? 's' : ''}</span>
                        </div>
                        
                        <div class="structured-chapters-grid" id="act-content-${act.id}">
                `;
                
                // Générer les chapitres de l'acte
                act.chapters.forEach((chapter, chapIndex) => {
                    const chapterScenes = actScenes.filter(s => s.chapterId === chapter.id);
                    
                    html += `
                        <div class="structured-chapter-container">
                            <div class="structured-chapter-header">
                                <div style="display: flex; align-items: center; gap: 0.5rem;">
                                    <span class="structured-chapter-icon">::</span>
                                    <span class="structured-chapter-title">${chapter.title}</span>
                                </div>
                            </div>
                            
                            <div class="structured-scenes-list">
                    `;
                    
                    // Générer les scènes du chapitre
                    chapterScenes.forEach((scene, sceneIndex) => {
                        const synopsis = scene.synopsis || '';
                        const wordCount = scene.content ? scene.content.split(/\s+/).filter(w => w.length > 0).length : 0;
                        const color = scene.corkColor || 'default';
                        
                        html += `
                            <div class="structured-scene-card structured-color-${color}" 
                                 data-scene-id="${scene.id}"
                                 data-act-id="${scene.actId}"
                                 data-chapter-id="${scene.chapterId}"
                                 draggable="true"
                                 onclick="openSceneFromCork(${scene.actId}, ${scene.chapterId}, ${scene.id})">
                                <div class="structured-scene-header">
                                    <span class="structured-scene-icon">::</span>
                                    <span class="structured-scene-title">${scene.title}</span>
                                </div>
                                
                                <div class="structured-scene-synopsis" 
                                     contenteditable="true"
                                     onclick="event.stopPropagation()"
                                     onblur="updateSceneSynopsis(${scene.actId}, ${scene.chapterId}, ${scene.id}, this.innerText)"
                                     data-placeholder="Ajouter un résumé...">${synopsis}</div>
                                
                                <div class="structured-scene-meta" style="font-size: 0.75rem; color: var(--text-muted); margin-top: 0.5rem;">
                                    ${wordCount} mots
                                </div>
                            </div>
                        `;
                    });
                    
                    // Bouton + Nouvelle Scène
                    html += `
                                <button class="structured-add-scene-btn" onclick="openAddSceneModalFromCork(${act.id}, ${chapter.id})">
                                    <span style="font-size: 1.2rem;">+</span> Nouvelle Scène
                                </button>
                            </div>
                        </div>
                    `;
                });
                
                // Si l'acte n'a pas de chapitres, afficher un message
                if (act.chapters.length === 0) {
                    html += `
                        <div style="padding: 2rem; text-align: center; color: var(--bg-primary); opacity: 0.7; font-style: italic;">
                            Cet acte est vide. Cliquez sur "+ Nouveau Chapitre" pour commencer.
                        </div>
                    `;
                }
                
                html += `
                        </div>
                    </div>
                `;
            });
            
            html += `
                    </div>
                    
                    <div class="structured-bottom-actions">
                        <button class="btn btn-primary" onclick="createActFromCork()">+ Ajouter un Acte</button>
                    </div>
                </div>
            `;
            
            return html;
        }
        
        function renderCorkCard(scene, index) {
            const wordCount = scene.content ? getWordCount(scene.content) : 0;
            const synopsis = scene.synopsis || 'Pas de synopsis';
            const color = scene.corkColor || 'default';
            
            return `
                <div class="cork-card cork-color-${color}" 
                     data-scene-id="${scene.id}"
                     data-act-id="${scene.actId}"
                     data-chapter-id="${scene.chapterId}"
                     draggable="true">
                    <div class="cork-card-header">
                        <div class="cork-card-number">#${index + 1}</div>
                        <div style="position: relative;">
                            <div class="cork-card-color-tag cork-color-${color}" 
                                 onclick="toggleColorPalette(${scene.id})"></div>
                            <div class="cork-color-palette" id="palette-${scene.id}">
                                <div class="cork-color-option cork-color-yellow" onclick="setCorkColor(${scene.actId}, ${scene.chapterId}, ${scene.id}, 'yellow')"></div>
                                <div class="cork-color-option cork-color-pink" onclick="setCorkColor(${scene.actId}, ${scene.chapterId}, ${scene.id}, 'pink')"></div>
                                <div class="cork-color-option cork-color-blue" onclick="setCorkColor(${scene.actId}, ${scene.chapterId}, ${scene.id}, 'blue')"></div>
                                <div class="cork-color-option cork-color-green" onclick="setCorkColor(${scene.actId}, ${scene.chapterId}, ${scene.id}, 'green')"></div>
                                <div class="cork-color-option cork-color-purple" onclick="setCorkColor(${scene.actId}, ${scene.chapterId}, ${scene.id}, 'purple')"></div>
                                <div class="cork-color-option cork-color-orange" onclick="setCorkColor(${scene.actId}, ${scene.chapterId}, ${scene.id}, 'orange')"></div>
                                <div class="cork-color-option cork-color-red" onclick="setCorkColor(${scene.actId}, ${scene.chapterId}, ${scene.id}, 'red')"></div>
                                <div class="cork-color-option cork-color-teal" onclick="setCorkColor(${scene.actId}, ${scene.chapterId}, ${scene.id}, 'teal')"></div>
                                <div class="cork-color-option cork-color-default" onclick="setCorkColor(${scene.actId}, ${scene.chapterId}, ${scene.id}, 'default')">
                                    <span style="font-size: 1.2rem;">×</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="cork-card-title">${scene.title}</div>
                    
                    <div class="cork-card-synopsis" 
                         contenteditable="true" 
                         onblur="updateSceneSynopsis(${scene.actId}, ${scene.chapterId}, ${scene.id}, this.innerText)"
                         data-placeholder="Cliquez pour ajouter un synopsis...">${synopsis}</div>
                    
                    <div class="cork-card-meta">
                        <span>📍 ${scene.chapterTitle}</span>
                        <span>${wordCount} mots</span>
                    </div>
                    
                    <div class="cork-card-actions">
                        <button class="btn btn-small" onclick="openSceneFromCork(${scene.actId}, ${scene.chapterId}, ${scene.id})">
                            ✏️ Éditer
                        </button>
                    </div>
                </div>
            `;
        }
        
        function toggleColorPalette(sceneId) {
            // Fermer toutes les autres palettes
            document.querySelectorAll('.cork-color-palette').forEach(p => {
                if (p.id !== `palette-${sceneId}`) {
                    p.classList.remove('visible');
                }
            });
            
            const palette = document.getElementById(`palette-${sceneId}`);
            if (palette) {
                palette.classList.toggle('visible');
            }
        }
        
        function setCorkColor(actId, chapterId, sceneId, color) {
            const act = project.acts.find(a => a.id === actId);
            if (!act) return;
            
            const chapter = act.chapters.find(c => c.id === chapterId);
            if (!chapter) return;
            
            const scene = chapter.scenes.find(s => s.id === sceneId);
            if (!scene) return;
            
            scene.corkColor = color;
            saveProject();
            
            // Fermer la palette et re-render
            toggleColorPalette(sceneId);
            openCorkBoardView();
        }
        
        function updateSceneSynopsis(actId, chapterId, sceneId, synopsis) {
            const act = project.acts.find(a => a.id === actId);
            if (!act) return;
            
            const chapter = act.chapters.find(c => c.id === chapterId);
            if (!chapter) return;
            
            const scene = chapter.scenes.find(s => s.id === sceneId);
            if (!scene) return;
            
            scene.synopsis = synopsis;
            saveProject();
        }
        
        function openSceneFromCork(actId, chapterId, sceneId) {
            switchView('editor');
            openScene(actId, chapterId, sceneId);
        }
        
        function toggleStructuredAct(actId) {
            const content = document.getElementById(`act-content-${actId}`);
            const icon = document.getElementById(`collapse-icon-${actId}`);
            
            if (content.style.display === 'none') {
                content.style.display = 'grid';
                icon.textContent = '▼';
            } else {
                content.style.display = 'none';
                icon.textContent = '▶';
            }
        }
        
        function createChapterFromCork(actId) {
            // Sélectionner l'acte
            activeActId = actId;
            currentActId = actId;
            
            // Trouver l'acte
            const act = project.acts.find(a => a.id === actId);
            if (!act) return;
            
            // Demander le nom du chapitre
            const chapterTitle = prompt('Nom du nouveau chapitre:', `Chapitre ${act.chapters.length + 1}`);
            if (!chapterTitle || chapterTitle.trim() === '') return;
            
            // Créer le chapitre
            const newChapter = {
                id: Date.now(),
                title: chapterTitle.trim(),
                scenes: []
            };
            
            // Ajouter le chapitre à l'acte
            act.chapters.push(newChapter);
            
            // Sauvegarder
            saveProject();
            
            // Rafraîchir la sidebar (treeview)
            if (typeof renderActsList === 'function') renderActsList();
            
            // Rafraîchir la vue Cork Board
            openCorkBoardView();
            
            // Notification
            showNotification(`✓ Chapitre "${chapterTitle}" créé`);
        }
        
        function openAddSceneModalFromCork(actId, chapterId) {
            // Trouver l'acte et le chapitre
            const act = project.acts.find(a => a.id === actId);
            if (!act) return;
            
            const chapter = act.chapters.find(c => c.id === chapterId);
            if (!chapter) return;
            
            // Demander le nom de la scène
            const sceneTitle = prompt('Nom de la nouvelle scène:', `Scène ${chapter.scenes.length + 1}`);
            if (!sceneTitle || sceneTitle.trim() === '') return;
            
            // Créer la scène
            const newScene = {
                id: Date.now(),
                title: sceneTitle.trim(),
                content: '',
                synopsis: '',
                characters: [],
                locations: [],
                notes: ''
            };
            
            // Ajouter la scène au chapitre
            chapter.scenes.push(newScene);
            
            // Sauvegarder
            saveProject();
            
            // Rafraîchir la sidebar (treeview)
            if (typeof renderActsList === 'function') renderActsList();
            
            // Rafraîchir la vue Cork Board
            openCorkBoardView();
            
            // Notification
            showNotification(`✓ Scène "${sceneTitle}" créée`);
        }
        
        function createActFromCork() {
            // Demander le nom de l'acte
            const actTitle = prompt('Nom du nouvel acte:', `Acte ${project.acts.length + 1}`);
            if (!actTitle || actTitle.trim() === '') return;
            
            // Créer l'acte
            const newAct = {
                id: Date.now(),
                title: actTitle.trim(),
                chapters: []
            };
            
            // Ajouter l'acte au projet
            project.acts.push(newAct);
            
            // Sauvegarder
            saveProject();
            
            // Rafraîchir la sidebar (treeview)
            if (typeof renderActsList === 'function') renderActsList();
            
            // Rafraîchir la vue Cork Board
            openCorkBoardView();
            
            // Notification
            showNotification(`✓ Acte "${actTitle}" créé`);
        }
        
        function toggleSceneMenu(sceneId) {
            // À implémenter : menu contextuel pour la scène
            console.log('Toggle menu for scene:', sceneId);
        }
        
        function openCreateFromOutlineModal() {
            alert('Fonctionnalité "Create from Outline" à venir');
        }
        
        function showImportOptions() {
            alert('Fonctionnalité "Import" à venir');
        }
        
        function showActions() {
            alert('Fonctionnalité "Actions" à venir');
        }
        
        function setupCorkBoardDragAndDrop() {
            const cards = document.querySelectorAll('.cork-card, .structured-scene-card');
            
            cards.forEach(card => {
                card.addEventListener('dragstart', handleCorkDragStart);
                card.addEventListener('dragend', handleCorkDragEnd);
                card.addEventListener('dragover', handleCorkDragOver);
                card.addEventListener('drop', handleCorkDrop);
            });
        }
        
        let draggedCorkCard = null;
        
        function handleCorkDragStart(e) {
            draggedCorkCard = this;
            this.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
        }
        
        function handleCorkDragEnd(e) {
            this.classList.remove('dragging');
            draggedCorkCard = null;
        }
        
        function handleCorkDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
        }
        

        function showNotification(message) {
            const notif = document.createElement('div');
            notif.style.cssText = `
                position: fixed;
                top: 2rem;
                right: 2rem;
                background: var(--accent-gold);
                color: white;
                padding: 1rem 2rem;
                border-radius: 4px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                z-index: 10000;
                font-weight: 600;
                animation: slideIn 0.3s ease;
            `;
            notif.textContent = message;
            document.body.appendChild(notif);
            
            setTimeout(() => {
                notif.style.animation = 'slideOut 0.3s ease';
                setTimeout(() => notif.remove(), 300);
            }, 2000);
        }

        function handleCorkDrop(e) {
            e.preventDefault();
            
            if (!draggedCorkCard || draggedCorkCard === this) return;
            
            // Récupérer les IDs
            const draggedSceneId = parseInt(draggedCorkCard.dataset.sceneId);
            const draggedActId = parseInt(draggedCorkCard.dataset.actId);
            const draggedChapterId = parseInt(draggedCorkCard.dataset.chapterId);
            
            const targetSceneId = parseInt(this.dataset.sceneId);
            const targetActId = parseInt(this.dataset.actId);
            const targetChapterId = parseInt(this.dataset.chapterId);
            
            // Vérifier qu'on est dans le même chapitre
            if (draggedChapterId !== targetChapterId) {
                alert('Vous ne pouvez déplacer des scènes que dans le même chapitre.\n\nPour déplacer entre chapitres, utilisez la vue Structure (sidebar).');
                return;
            }
            
            // Trouver les objets
            const act = project.acts.find(a => a.id === draggedActId);
            if (!act) return;
            
            const chapter = act.chapters.find(c => c.id === draggedChapterId);
            if (!chapter) return;
            
            const draggedSceneIndex = chapter.scenes.findIndex(s => s.id === draggedSceneId);
            const targetSceneIndex = chapter.scenes.findIndex(s => s.id === targetSceneId);
            
            if (draggedSceneIndex === -1 || targetSceneIndex === -1) return;
            
            // Réorganiser dans le tableau
            const [draggedScene] = chapter.scenes.splice(draggedSceneIndex, 1);
            chapter.scenes.splice(targetSceneIndex, 0, draggedScene);
            
            // Sauvegarder
            saveProject();
            renderActsList();
            
            // Rafraîchir le Cork Board
            openCorkBoardView();
            
            // Notification
            showNotification('✓ Scènes réorganisées');
        }
        
        
        // ============================================
        // FIN CORK BOARD
        // ============================================

        // ============================================
        // NOUVELLES FONCTIONNALITÉS DE VISUALISATION
        // ============================================
        
        // Initialiser les données de visualisation si elles n'existent pas
        if (!project.mindmapNodes) project.mindmapNodes = [];
        if (!project.plotPoints) project.plotPoints = [];
        if (!project.relationships) project.relationships = [];
        if (!project.mapLocations) project.mapLocations = [];
        if (!project.mapImage) project.mapImage = null;
        if (!project.visualTimeline) project.visualTimeline = [];
        
        // ============================================
        // ========================================
        // MINDMAP SYSTEM - Custom drag & drop mindmaps
        // ========================================

        let mindmapState = {
            zoom: 1,
            panX: 0,
            panY: 0,
            isDragging: false,
            draggedNode: null,
            selectedNode: null,
            isPanning: false,
            lastMouseX: 0,
            lastMouseY: 0,
            linkStart: null,
            libraryCollapsed: false,
            activeLibraryTab: 'characters'
        };

        function renderMindmapView() {
            const container = document.getElementById('mindmapList');
            if (!container) return;

            // Initialiser mindmaps si nécessaire
            if (!project.mindmaps) {
                project.mindmaps = [];
            }

            container.innerHTML = `
                <div class="mindmap-sidebar-header">
                    <h3 style="margin-bottom: 0.5rem; font-size: 1.1rem;">🗺️ Mindmaps</h3>
                    <button class="btn btn-small" onclick="createNewMindmap()" style="width: 100%;">
                        ➕ Nouvelle Mindmap
                    </button>
                </div>
                <div class="mindmap-list">
                    ${project.mindmaps.length === 0 ? `
                        <div style="padding: 1rem; text-align: center; color: var(--text-muted); font-size: 0.9rem;">
                            Aucune mindmap.<br>Créez-en une !
                        </div>
                    ` : project.mindmaps.map(mm => `
                        <div class="mindmap-item ${currentMindmapId === mm.id ? 'active' : ''}" 
                             onclick="selectMindmap(${mm.id})">
                            <span style="flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
                                ${mm.title}
                            </span>
                            <span onclick="event.stopPropagation(); deleteMindmap(${mm.id})" 
                                  style="cursor: pointer; color: var(--accent-red); opacity: 0.7; padding: 0 0.5rem;"
                                  title="Supprimer">×</span>
                        </div>
                    `).join('')}
                </div>
            `;

            renderMindmapCanvas();
        }

        function createNewMindmap() {
            const title = prompt('Nom de la mindmap:', 'Nouvelle mindmap');
            if (!title) return;

            const newMindmap = {
                id: Date.now(),
                title: title,
                nodes: [],
                links: []
            };

            project.mindmaps.push(newMindmap);
            currentMindmapId = newMindmap.id;
            saveProject();
            renderMindmapView();
        }

        function deleteMindmap(id) {
            if (!confirm('Supprimer cette mindmap ?')) return;
            
            const index = project.mindmaps.findIndex(mm => mm.id === id);
            if (index !== -1) {
                project.mindmaps.splice(index, 1);
                if (currentMindmapId === id) {
                    currentMindmapId = project.mindmaps.length > 0 ? project.mindmaps[0].id : null;
                }
                saveProject();
                renderMindmapView();
            }
        }

        function selectMindmap(id) {
            currentMindmapId = id;
            renderMindmapCanvas();
            // Mettre à jour l'affichage de la sidebar
            document.querySelectorAll('.mindmap-item').forEach(item => {
                item.classList.remove('active');
            });
            event.currentTarget.classList.add('active');
        }

        function renameMindmap() {
            const mindmap = project.mindmaps.find(mm => mm.id === currentMindmapId);
            if (!mindmap) return;

            const newTitle = prompt('Nouveau nom:', mindmap.title);
            if (newTitle && newTitle.trim()) {
                mindmap.title = newTitle.trim();
                saveProject();
                renderMindmapView();
            }
        }

        function renderMindmapCanvas() {
            const editorView = document.getElementById('editorView');
            if (!editorView) return;

            const mindmap = project.mindmaps.find(mm => mm.id === currentMindmapId);

            if (!mindmap) {
                // Afficher un message d'accueil
                editorView.innerHTML = `
                    <div class="mindmap-empty">
                        <div class="mindmap-empty-icon">🗺️</div>
                        <h3 style="margin-bottom: 0.5rem;">Aucune mindmap sélectionnée</h3>
                        <p style="margin-bottom: 1rem;">Créez une mindmap pour commencer à organiser vos idées visuellement.</p>
                        <button class="btn" onclick="createNewMindmap()">➕ Créer une mindmap</button>
                    </div>
                `;
                return;
            }

            editorView.innerHTML = `
                <div class="mindmap-wrapper">
                    <div class="mindmap-main">
                        <div class="mindmap-toolbar">
                            <button class="btn btn-small" onclick="renameMindmap()" title="Renommer">✏️</button>
                            <button class="btn btn-small" onclick="addNoteNode()" title="Ajouter une note"><i data-lucide="sticky-note" style="width:14px;height:14px;"></i></button>
                            <button class="btn btn-small" onclick="resetMindmapView()" title="Réinitialiser la vue"><i data-lucide="target" style="width:14px;height:14px;"></i></button>
                            ${mindmapState.linkStart ? `
                                <button class="btn btn-small" onclick="cancelLinking()" style="background: var(--accent-red); color: white;" title="Annuler la liaison">
                                    <i data-lucide="x" style="width:14px;height:14px;"></i> Annuler
                                </button>
                                <span style="font-size: 0.85rem; color: var(--accent-red); font-weight: 600; animation: pulse-text 1s infinite;">
                                    <i data-lucide="link" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>
                                    Cliquez sur un autre nœud pour créer le lien
                                </span>
                            ` : `
                                <span style="font-size: 0.75rem; color: var(--text-muted); font-style: italic;">
                                    <i data-lucide="lightbulb" style="width:12px;height:12px;vertical-align:middle;margin-right:4px;"></i>Survolez un nœud et cliquez sur <i data-lucide="link" style="width:12px;height:12px;vertical-align:middle;"></i> pour créer un lien
                                </span>
                            `}
                            <div style="flex: 1;"></div>
                            <span style="font-size: 0.85rem; color: var(--text-muted);">
                                ${mindmap.nodes.length} nœud(s) · ${mindmap.links.length} lien(s)
                            </span>
                        </div>
                        <div class="mindmap-canvas-wrapper ${mindmapState.linkStart ? 'linking-mode' : ''}" id="mindmapCanvasWrapper">
                            <div class="mindmap-canvas" id="mindmapCanvas"
                                 style="transform: scale(${mindmapState.zoom}) translate(${mindmapState.panX}px, ${mindmapState.panY}px);">
                                <svg id="mindmapSvg" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0; pointer-events: painted;">
                                    ${renderMindmapLinks(mindmap)}
                                </svg>
                                ${renderMindmapNodes(mindmap)}
                            </div>
                        </div>
                    </div>
                    <div class="mindmap-library ${mindmapState.libraryCollapsed ? 'collapsed' : ''}">
                        <div class="mindmap-library-toggle" onclick="toggleLibrary()">
                            ${mindmapState.libraryCollapsed ? '◀' : '▶'}
                        </div>
                        <div class="mindmap-library-tabs">
                            <div class="mindmap-library-tab ${mindmapState.activeLibraryTab === 'characters' ? 'active' : ''}"
                                 onclick="setLibraryTab('characters')" title="Personnages"><i data-lucide="users" style="width:16px;height:16px;"></i></div>
                            <div class="mindmap-library-tab ${mindmapState.activeLibraryTab === 'elements' ? 'active' : ''}"
                                 onclick="setLibraryTab('elements')" title="Univers"><i data-lucide="globe" style="width:16px;height:16px;"></i></div>
                            <div class="mindmap-library-tab ${mindmapState.activeLibraryTab === 'codex' ? 'active' : ''}"
                                 onclick="setLibraryTab('codex')" title="Codex"><i data-lucide="book-open" style="width:16px;height:16px;"></i></div>
                            <div class="mindmap-library-tab ${mindmapState.activeLibraryTab === 'structure' ? 'active' : ''}"
                                 onclick="setLibraryTab('structure')" title="Structure"><i data-lucide="list-tree" style="width:16px;height:16px;"></i></div>
                        </div>
                        <div class="mindmap-library-content">
                            ${renderLibraryContent()}
                        </div>
                    </div>
                </div>
            `;

            // Initialiser les événements
            initMindmapEvents();
            
            // Réinitialiser les icônes Lucide après le rendu
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
        }

        function renderMindmapNodes(mindmap) {
            if (!mindmap.nodes || mindmap.nodes.length === 0) {
                return `
                    <div style="position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); 
                                text-align: center; color: var(--text-muted); pointer-events: none;">
                        <div style="font-size: 3rem; margin-bottom: 1rem; opacity: 0.3;">🗺️</div>
                        <p style="font-size: 0.9rem;">Glissez des éléments depuis la bibliothèque →</p>
                    </div>
                `;
            }

            return mindmap.nodes.map(node => {
                const icon = getNodeIcon(node);
                const typeClass = `type-${node.type}`;
                const content = getNodeContent(node);
                const isLinkingSource = mindmapState.linkStart === node.id;

                return `
                    <div class="mindmap-node ${typeClass} ${mindmapState.selectedNode === node.id ? 'selected' : ''} ${isLinkingSource ? 'linking-source' : ''}"
                         data-node-id="${node.id}"
                         style="left: ${node.x}px; top: ${node.y}px; background-color: ${node.color || 'var(--bg-primary)'};">
                        <div class="mindmap-node-header">
                            <span class="mindmap-node-icon">${icon}</span>
                            <span class="mindmap-node-title">${node.title || 'Sans titre'}</span>
                            <span class="mindmap-node-link-btn" onclick="event.stopPropagation(); startLinkFrom(${node.id})" title="Créer un lien"><i data-lucide="link" style="width:12px;height:12px;"></i></span>
                            <span class="mindmap-node-delete" onclick="event.stopPropagation(); deleteNode(${node.id})">×</span>
                        </div>
                        ${content ? `<div class="mindmap-node-content">${content}</div>` : ''}
                    </div>
                `;
            }).join('');
        }

        function renderMindmapLinks(mindmap) {
            if (!mindmap.links || mindmap.links.length === 0) return '';

            // Créer les markers pour chaque couleur de lien
            const linkColors = new Set(mindmap.links.map(l => l.color || 'var(--accent-gold)'));
            const markers = Array.from(linkColors).map((color, index) => `
                <marker id="arrowhead-${index}" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
                    <polygon points="0 0, 10 3, 0 6" fill="${color}" opacity="0.7"/>
                </marker>
            `).join('');

            const colorToMarkerId = {};
            Array.from(linkColors).forEach((color, index) => {
                colorToMarkerId[color] = `arrowhead-${index}`;
            });

            return mindmap.links.map(link => {
                const fromNode = mindmap.nodes.find(n => n.id === link.from);
                const toNode = mindmap.nodes.find(n => n.id === link.to);
                
                if (!fromNode || !toNode) return '';

                const x1 = fromNode.x + 100; // Centre approximatif du nœud
                const y1 = fromNode.y + 40;
                const x2 = toNode.x + 100;
                const y2 = toNode.y + 40;

                // Calculer la position du label au milieu
                const labelX = (x1 + x2) / 2;
                const labelY = (y1 + y2) / 2;

                const linkColor = link.color || 'var(--accent-gold)';
                const markerId = colorToMarkerId[linkColor];
                const escapedLabel = (link.label || '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');

                return `
                    <line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" 
                          stroke="${linkColor}" stroke-width="4" 
                          opacity="0.7" marker-end="url(#${markerId})"
                          data-link-id="${link.id}"
                          onclick="editLink(${link.id})"
                          style="cursor: pointer; pointer-events: stroke;"/>
                    ${link.label ? `
                        <text x="${labelX}" y="${labelY}" 
                              text-anchor="middle" 
                              dominant-baseline="middle"
                              style="font-size: 12px; fill: ${linkColor}; font-weight: 600; 
                                     cursor: pointer; pointer-events: auto; user-select: none;"
                              onclick="editLink(${link.id})">
                            <tspan x="${labelX}" dy="0" 
                                   style="paint-order: stroke; stroke: var(--bg-primary); 
                                          stroke-width: 3px; stroke-linejoin: round;">
                                ${escapedLabel}
                            </tspan>
                        </text>
                    ` : ''}
                `;
            }).join('') + `
                <defs>
                    ${markers}
                </defs>
            `;
        }

        function renderLibraryContent() {
            const tab = mindmapState.activeLibraryTab;

            if (tab === 'characters') {
                return project.characters.map(char => `
                    <div class="mindmap-library-item" draggable="true" 
                         data-type="character" data-id="${char.id}" data-title="${char.name}">
                        <span class="mindmap-library-item-icon"><i data-lucide="user" style="width:16px;height:16px;"></i></span>
                        <span class="mindmap-library-item-text">${char.name}</span>
                    </div>
                `).join('') || '<div style="padding: 1rem; text-align: center; color: var(--text-muted); font-size: 0.85rem;">Aucun personnage</div>';
            }

            if (tab === 'elements') {
                return project.world.map(elem => {
                    const elemType = elem.type || 'Lieu';
                    // Icônes Lucide selon le type
                    const iconMap = {
                        'Lieu': 'map-pin',
                        'Objet': 'box',
                        'Concept': 'lightbulb',
                        'Organisation': 'building-2',
                        'Événement': 'zap'
                    };
                    const iconName = iconMap[elemType] || 'map-pin';
                    
                    return `
                    <div class="mindmap-library-item" draggable="true" 
                         data-type="element" 
                         data-element-type="${elemType}"
                         data-id="${elem.id}" 
                         data-title="${elem.name}">
                        <span class="mindmap-library-item-icon"><i data-lucide="${iconName}" style="width:16px;height:16px;"></i></span>
                        <span class="mindmap-library-item-text">${elem.name}</span>
                    </div>
                `;
                }).join('') || '<div style="padding: 1rem; text-align: center; color: var(--text-muted); font-size: 0.85rem;">Aucun élément</div>';
            }

            if (tab === 'codex') {
                return (project.codex || []).map(entry => `
                    <div class="mindmap-library-item" draggable="true" 
                         data-type="codex" 
                         data-id="${entry.id}" 
                         data-title="${entry.title || entry.name || 'Sans titre'}">
                        <span class="mindmap-library-item-icon"><i data-lucide="book-open" style="width:16px;height:16px;"></i></span>
                        <span class="mindmap-library-item-text">${entry.title || entry.name || 'Sans titre'}</span>
                    </div>
                `).join('') || '<div style="padding: 1rem; text-align: center; color: var(--text-muted); font-size: 0.85rem;">Aucune entrée codex</div>';
            }

            if (tab === 'structure') {
                let structureHTML = '';
                project.acts.forEach((act, actIndex) => {
                    const actNum = toRoman(actIndex + 1);
                    // Ajouter l'acte
                    structureHTML += `
                        <div class="mindmap-library-item" draggable="true" 
                             data-type="act" 
                             data-id="${act.id}"
                             data-title="Acte ${actNum}: ${act.title || 'Sans titre'}">
                            <span class="mindmap-library-item-icon"><i data-lucide="folder" style="width:16px;height:16px;"></i></span>
                            <span class="mindmap-library-item-text" style="font-weight: 600;">Acte ${actNum}</span>
                        </div>
                    `;
                    
                    act.chapters.forEach((chapter, chapIndex) => {
                        const chapNum = chapIndex + 1;
                        // Ajouter le chapitre
                        structureHTML += `
                            <div class="mindmap-library-item" draggable="true" 
                                 data-type="chapter" 
                                 data-id="${chapter.id}"
                                 data-act="${act.id}"
                                 data-title="A${actNum} › Ch.${chapNum}: ${chapter.title || 'Sans titre'}"
                                 style="margin-left: 0.5rem;">
                                <span class="mindmap-library-item-icon"><i data-lucide="file-text" style="width:16px;height:16px;"></i></span>
                                <span class="mindmap-library-item-text" style="font-size: 0.8rem;">Ch.${chapNum}: ${chapter.title || 'Sans titre'}</span>
                            </div>
                        `;
                        
                        chapter.scenes.forEach(scene => {
                            const sceneLabel = scene.title || 'Sans titre';
                            structureHTML += `
                                <div class="mindmap-library-item" draggable="true" 
                                     data-type="scene" 
                                     data-id="${scene.id}"
                                     data-act="${act.id}"
                                     data-chapter="${chapter.id}"
                                     data-title="A${actNum} › C${chapNum} › ${sceneLabel}"
                                     style="margin-left: 1rem;">
                                    <span class="mindmap-library-item-icon"><i data-lucide="pen-line" style="width:16px;height:16px;"></i></span>
                                    <span class="mindmap-library-item-text" style="font-size: 0.75rem;">${sceneLabel}</span>
                                </div>
                            `;
                        });
                    });
                });
                return structureHTML || '<div style="padding: 1rem; text-align: center; color: var(--text-muted); font-size: 0.85rem;">Aucune structure</div>';
            }

            return '';
        }

        function getNodeIcon(node) {
            if (node.type === 'element') {
                // Icônes Lucide spécifiques selon le type d'élément d'univers
                const elementIconMap = {
                    'Lieu': 'map-pin',
                    'Objet': 'box',
                    'Concept': 'lightbulb',
                    'Organisation': 'building-2',
                    'Événement': 'zap'
                };
                const iconName = elementIconMap[node.elementType] || 'map-pin';
                return `<i data-lucide="${iconName}" style="width:16px;height:16px;"></i>`;
            }
            
            const icons = {
                'character': 'user',
                'scene': 'pen-line',
                'note': 'sticky-note',
                'codex': 'book-open',
                'act': 'folder',
                'chapter': 'file-text'
            };
            const iconName = icons[node.type] || 'pin';
            return `<i data-lucide="${iconName}" style="width:16px;height:16px;"></i>`;
        }

        function getNodeContent(node) {
            if (node.type === 'note') {
                return node.content || '';
            }
            return '';
        }

        function toggleLibrary() {
            mindmapState.libraryCollapsed = !mindmapState.libraryCollapsed;
            renderMindmapCanvas();
        }

        function setLibraryTab(tab) {
            mindmapState.activeLibraryTab = tab;
            document.querySelectorAll('.mindmap-library-tab').forEach(t => t.classList.remove('active'));
            event.currentTarget.classList.add('active');
            document.querySelector('.mindmap-library-content').innerHTML = renderLibraryContent();
            initLibraryDragEvents();
            
            // Réinitialiser les icônes Lucide
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
        }

        function startLinkFrom(nodeId) {
            if (mindmapState.linkStart === nodeId) {
                // Annuler si on reclique sur le même nœud
                cancelLinking();
            } else if (mindmapState.linkStart && mindmapState.linkStart !== nodeId) {
                // Créer le lien
                const mindmap = project.mindmaps.find(mm => mm.id === currentMindmapId);
                if (!mindmap) return;

                const newLink = {
                    id: Date.now(),
                    from: mindmapState.linkStart,
                    to: nodeId,
                    label: '',
                    color: '#d4af37' // Couleur or par défaut
                };
                mindmap.links.push(newLink);
                mindmapState.linkStart = null;
                saveProject();
                renderMindmapCanvas();
            } else {
                // Démarrer une nouvelle liaison
                mindmapState.linkStart = nodeId;
                renderMindmapCanvas();
            }
        }

        function cancelLinking() {
            mindmapState.linkStart = null;
            renderMindmapCanvas();
        }

        function addNoteNode() {
            const mindmap = project.mindmaps.find(mm => mm.id === currentMindmapId);
            if (!mindmap) return;

            const content = prompt('Contenu de la note:');
            if (!content) return;

            const newNode = {
                id: Date.now(),
                type: 'note',
                title: 'Note',
                content: content,
                x: 100 + Math.random() * 200,
                y: 100 + Math.random() * 200,
                color: 'var(--bg-primary)'
            };

            mindmap.nodes.push(newNode);
            saveProject();
            renderMindmapCanvas();
        }

        function deleteNode(nodeId) {
            const mindmap = project.mindmaps.find(mm => mm.id === currentMindmapId);
            if (!mindmap) return;

            if (!confirm('Supprimer ce nœud ?')) return;

            // Supprimer le nœud
            const nodeIndex = mindmap.nodes.findIndex(n => n.id === nodeId);
            if (nodeIndex !== -1) {
                mindmap.nodes.splice(nodeIndex, 1);
            }

            // Supprimer les liens associés
            mindmap.links = mindmap.links.filter(l => l.from !== nodeId && l.to !== nodeId);

            saveProject();
            renderMindmapCanvas();
        }

        function editLink(linkId) {
            const mindmap = project.mindmaps.find(mm => mm.id === currentMindmapId);
            if (!mindmap) return;

            const link = mindmap.links.find(l => l.id === linkId);
            if (!link) return;

            // Couleurs prédéfinies
            const colors = [
                { name: 'Or', value: '#d4af37' },
                { name: 'Rouge', value: '#c44536' },
                { name: 'Bleu', value: '#2196f3' },
                { name: 'Vert', value: '#4caf50' },
                { name: 'Violet', value: '#9c27b0' },
                { name: 'Orange', value: '#ff9800' },
                { name: 'Rose', value: '#e91e63' },
                { name: 'Gris', value: '#757575' }
            ];

            let selectedColor = link.color || '#d4af37';

            // Créer le modal
            const overlay = document.createElement('div');
            overlay.className = 'link-editor-overlay';
            overlay.innerHTML = `
                <div class="link-editor-modal">
                    <div class="link-editor-header">✏️ Éditer le lien</div>
                    
                    <div class="link-editor-field">
                        <label class="link-editor-label">Étiquette</label>
                        <input type="text" class="link-editor-input" id="linkLabelInput" 
                               value="${(link.label || '').replace(/"/g, '&quot;')}" 
                               placeholder="Ex: ennemi de, père de, aime...">
                    </div>
                    
                    <div class="link-editor-field">
                        <label class="link-editor-label">Couleur</label>
                        <div class="link-editor-colors" id="linkColorPicker">
                            ${colors.map(c => `
                                <div class="link-color-option ${c.value === selectedColor ? 'selected' : ''}" 
                                     style="background: ${c.value};"
                                     data-color="${c.value}"
                                     title="${c.name}"></div>
                            `).join('')}
                        </div>
                    </div>
                    
                    <div class="link-editor-buttons">
                        <button class="btn" id="saveLinkBtn" style="flex: 1;">💾 Enregistrer</button>
                        <button class="btn" id="deleteLinkBtn" style="background: var(--accent-red); color: white;">🗑️ Supprimer</button>
                        <button class="btn" id="cancelLinkBtn" style="background: var(--bg-secondary);">✕ Annuler</button>
                    </div>
                </div>
            `;

            if (!document.body) {
                console.error('document.body not available');
                return;
            }

            document.body.appendChild(overlay);

            // Gestionnaires d'événements
            const modal = overlay.querySelector('.link-editor-modal');
            
            // Empêcher la fermeture au clic sur le modal
            modal.addEventListener('click', (e) => {
                e.stopPropagation();
            });

            // Fermer au clic sur l'overlay
            overlay.addEventListener('click', () => {
                overlay.remove();
            });

            // Sélection de couleur
            document.querySelectorAll('.link-color-option').forEach(opt => {
                opt.addEventListener('click', () => {
                    selectedColor = opt.getAttribute('data-color');
                    document.querySelectorAll('.link-color-option').forEach(o => o.classList.remove('selected'));
                    opt.classList.add('selected');
                });
            });

            // Bouton Enregistrer
            document.getElementById('saveLinkBtn').addEventListener('click', () => {
                const newLabel = document.getElementById('linkLabelInput').value.trim();
                link.label = newLabel;
                link.color = selectedColor;
                saveProject();
                overlay.remove();
                renderMindmapCanvas();
            });

            // Bouton Supprimer
            document.getElementById('deleteLinkBtn').addEventListener('click', () => {
                if (!confirm('Supprimer ce lien ?')) return;
                const linkIndex = mindmap.links.findIndex(l => l.id === linkId);
                if (linkIndex !== -1) {
                    mindmap.links.splice(linkIndex, 1);
                    saveProject();
                    overlay.remove();
                    renderMindmapCanvas();
                }
            });

            // Bouton Annuler
            document.getElementById('cancelLinkBtn').addEventListener('click', () => {
                overlay.remove();
            });

            // Focus sur l'input
            document.getElementById('linkLabelInput').focus();
        }

        function resetMindmapView() {
            mindmapState.zoom = 1;
            mindmapState.panX = 0;
            mindmapState.panY = 0;
            renderMindmapCanvas();
        }

        function initMindmapEvents() {
            const canvas = document.getElementById('mindmapCanvas');
            const wrapper = document.getElementById('mindmapCanvasWrapper');
            if (!canvas || !wrapper) return;

            // Drag & drop des nœuds (souris + tactile)
            canvas.querySelectorAll('.mindmap-node').forEach(node => {
                node.addEventListener('mousedown', handleNodeMouseDown);
                node.addEventListener('click', handleNodeClick);
                node.addEventListener('touchstart', handleNodeTouchStart, { passive: false });
            });

            // Pan de la canvas (souris)
            wrapper.addEventListener('mousedown', handleCanvasMouseDown);
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);

            // Pan de la canvas (tactile)
            wrapper.addEventListener('touchstart', handleCanvasTouchStart, { passive: false });
            document.addEventListener('touchmove', handleTouchMove, { passive: false });
            document.addEventListener('touchend', handleTouchEnd);

            // Zoom
            wrapper.addEventListener('wheel', handleWheel);

            // Drop depuis la bibliothèque
            wrapper.addEventListener('dragover', handleDragOver);
            wrapper.addEventListener('drop', handleDrop);

            // Initialiser le drag des items de la bibliothèque
            initLibraryDragEvents();
        }

        function initLibraryDragEvents() {
            document.querySelectorAll('.mindmap-library-item').forEach(item => {
                // Support souris (desktop)
                item.addEventListener('dragstart', handleLibraryDragStart);
                
                // Support tactile (mobile)
                item.addEventListener('touchstart', handleLibraryTouchStart, { passive: false });
            });
        }

        // Variables pour le drag tactile
        let touchDragData = null;
        let touchDragElement = null;
        let touchDragClone = null;

        function handleLibraryTouchStart(e) {
            e.preventDefault();
            
            const item = e.currentTarget;
            const touch = e.touches[0];
            
            // Sauvegarder les données
            touchDragData = {
                type: item.getAttribute('data-type'),
                linkedId: item.getAttribute('data-id'),
                title: item.getAttribute('data-title'),
                actId: item.getAttribute('data-act'),
                chapterId: item.getAttribute('data-chapter'),
                elementType: item.getAttribute('data-element-type')
            };
            
            touchDragElement = item;
            
            // Créer un clone visuel
            touchDragClone = item.cloneNode(true);
            touchDragClone.style.position = 'fixed';
            touchDragClone.style.left = touch.clientX - 60 + 'px';
            touchDragClone.style.top = touch.clientY - 20 + 'px';
            touchDragClone.style.width = '120px';
            touchDragClone.style.opacity = '0.7';
            touchDragClone.style.pointerEvents = 'none';
            touchDragClone.style.zIndex = '10000';
            touchDragClone.style.transform = 'scale(0.9)';
            
            if (document.body) {
                document.body.appendChild(touchDragClone);
            }
            
            // Écouter les mouvements
            document.addEventListener('touchmove', handleLibraryTouchMove, { passive: false });
            document.addEventListener('touchend', handleLibraryTouchEnd);
        }

        function handleLibraryTouchMove(e) {
            e.preventDefault();
            
            if (!touchDragClone) return;
            
            const touch = e.touches[0];
            touchDragClone.style.left = touch.clientX - 60 + 'px';
            touchDragClone.style.top = touch.clientY - 20 + 'px';
        }

        function handleLibraryTouchEnd(e) {
            if (!touchDragClone || !touchDragData) {
                cleanupTouchDrag();
                return;
            }
            
            const touch = e.changedTouches[0];
            
            // Vérifier si on est sur la zone de drop
            const wrapper = document.getElementById('mindmapCanvasWrapper');
            if (!wrapper) {
                cleanupTouchDrag();
                return;
            }
            
            const rect = wrapper.getBoundingClientRect();
            if (touch.clientX >= rect.left && touch.clientX <= rect.right &&
                touch.clientY >= rect.top && touch.clientY <= rect.bottom) {
                
                // Drop sur la canvas
                const mindmap = project.mindmaps.find(mm => mm.id === currentMindmapId);
                if (mindmap) {
                    // Calculer la position en tenant compte du zoom et du pan
                    const x = (touch.clientX - rect.left - mindmapState.panX * mindmapState.zoom) / mindmapState.zoom;
                    const y = (touch.clientY - rect.top - mindmapState.panY * mindmapState.zoom) / mindmapState.zoom;

                    const newNode = {
                        id: Date.now(),
                        type: touchDragData.type,
                        linkedId: touchDragData.linkedId,
                        title: touchDragData.title,
                        x: x,
                        y: y,
                        color: 'var(--bg-primary)'
                    };

                    // Ajouter les données supplémentaires pour les scènes
                    if (touchDragData.type === 'scene') {
                        newNode.actId = touchDragData.actId;
                        newNode.chapterId = touchDragData.chapterId;
                    }

                    // Ajouter le type d'élément pour les éléments d'univers
                    if (touchDragData.type === 'element' && touchDragData.elementType) {
                        newNode.elementType = touchDragData.elementType;
                    }

                    mindmap.nodes.push(newNode);
                    saveProject();
                    renderMindmapCanvas();
                }
            }
            
            cleanupTouchDrag();
        }

        function cleanupTouchDrag() {
            if (touchDragClone && touchDragClone.parentNode) {
                touchDragClone.parentNode.removeChild(touchDragClone);
            }
            touchDragClone = null;
            touchDragData = null;
            touchDragElement = null;
            
            document.removeEventListener('touchmove', handleLibraryTouchMove);
            document.removeEventListener('touchend', handleLibraryTouchEnd);
        }

        function handleLibraryDragStart(e) {
            const type = e.currentTarget.getAttribute('data-type');
            const id = e.currentTarget.getAttribute('data-id');
            const title = e.currentTarget.getAttribute('data-title');
            const actId = e.currentTarget.getAttribute('data-act');
            const chapterId = e.currentTarget.getAttribute('data-chapter');
            const elementType = e.currentTarget.getAttribute('data-element-type');
            
            e.dataTransfer.setData('application/json', JSON.stringify({ 
                type, 
                linkedId: id, 
                title,
                actId,
                chapterId,
                elementType
            }));
            e.dataTransfer.effectAllowed = 'copy';
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'copy';
        }

        function handleDrop(e) {
            e.preventDefault();
            
            const mindmap = project.mindmaps.find(mm => mm.id === currentMindmapId);
            if (!mindmap) return;

            try {
                const data = JSON.parse(e.dataTransfer.getData('application/json'));
                const wrapper = document.getElementById('mindmapCanvasWrapper');
                const canvas = document.getElementById('mindmapCanvas');
                const rect = wrapper.getBoundingClientRect();
                
                // Calculer la position en tenant compte du zoom et du pan
                const x = (e.clientX - rect.left - mindmapState.panX * mindmapState.zoom) / mindmapState.zoom;
                const y = (e.clientY - rect.top - mindmapState.panY * mindmapState.zoom) / mindmapState.zoom;

                const newNode = {
                    id: Date.now(),
                    type: data.type,
                    linkedId: data.linkedId,
                    title: data.title,
                    x: x,
                    y: y,
                    color: 'var(--bg-primary)'
                };

                // Ajouter les données supplémentaires pour les scènes
                if (data.type === 'scene') {
                    newNode.actId = data.actId;
                    newNode.chapterId = data.chapterId;
                }

                // Ajouter le type d'élément pour les éléments d'univers
                if (data.type === 'element' && data.elementType) {
                    newNode.elementType = data.elementType;
                }

                mindmap.nodes.push(newNode);
                saveProject();
                renderMindmapCanvas();
            } catch (err) {
                console.error('Erreur lors du drop:', err);
            }
        }

        function handleNodeMouseDown(e) {
            e.stopPropagation();
            
            const mindmap = project.mindmaps.find(mm => mm.id === currentMindmapId);
            if (!mindmap) return;

            const nodeId = parseInt(e.currentTarget.getAttribute('data-node-id'));
            
            // Mode déplacement uniquement
            mindmapState.isDragging = true;
            mindmapState.draggedNode = nodeId;
            mindmapState.selectedNode = nodeId;
            
            const node = mindmap.nodes.find(n => n.id === nodeId);
            const canvas = document.getElementById('mindmapCanvas');
            const rect = canvas.getBoundingClientRect();
            
            mindmapState.dragOffsetX = (e.clientX - rect.left) / mindmapState.zoom - node.x;
            mindmapState.dragOffsetY = (e.clientY - rect.top) / mindmapState.zoom - node.y;
            
            e.currentTarget.classList.add('dragging');
        }

        function handleNodeClick(e) {
            const nodeId = parseInt(e.currentTarget.getAttribute('data-node-id'));
            const mindmap = project.mindmaps.find(mm => mm.id === currentMindmapId);
            if (!mindmap) return;

            const node = mindmap.nodes.find(n => n.id === nodeId);
            if (!node) return;

            // Double-clic pour ouvrir l'élément lié
            if (e.detail === 2 && node.linkedId) {
                if (node.type === 'character') {
                    switchView('characters');
                    setTimeout(() => openCharacterDetail(node.linkedId), 100);
                } else if (node.type === 'element') {
                    switchView('world');
                    setTimeout(() => openWorldDetail(node.linkedId), 100);
                } else if (node.type === 'codex') {
                    switchView('codex');
                    setTimeout(() => {
                        if (typeof openCodexDetail === 'function') {
                            openCodexDetail(node.linkedId);
                        }
                    }, 100);
                } else if (node.type === 'scene' && node.actId && node.chapterId) {
                    switchView('editor');
                    setTimeout(() => openScene(node.actId, node.chapterId, node.linkedId), 100);
                } else if (node.type === 'chapter' && node.actId) {
                    switchView('editor');
                    // Trouver la première scène du chapitre
                    const act = project.acts.find(a => a.id == node.actId);
                    if (act) {
                        const chapter = act.chapters.find(c => c.id == node.linkedId);
                        if (chapter && chapter.scenes.length > 0) {
                            setTimeout(() => openScene(node.actId, node.linkedId, chapter.scenes[0].id), 100);
                        }
                    }
                } else if (node.type === 'act') {
                    switchView('editor');
                    // Trouver le premier chapitre et scène de l'acte
                    const act = project.acts.find(a => a.id == node.linkedId);
                    if (act && act.chapters.length > 0 && act.chapters[0].scenes.length > 0) {
                        setTimeout(() => openScene(node.linkedId, act.chapters[0].id, act.chapters[0].scenes[0].id), 100);
                    }
                }
            }
            
            // Simple clic en mode liaison : créer le lien vers ce nœud
            if (e.detail === 1 && mindmapState.linkStart && mindmapState.linkStart !== nodeId) {
                // Créer le lien immédiatement
                const newLink = {
                    id: Date.now(),
                    from: mindmapState.linkStart,
                    to: nodeId,
                    label: '',
                    color: '#d4af37'
                };
                mindmap.links.push(newLink);
                mindmapState.linkStart = null;
                saveProject();
                renderMindmapCanvas();
            }
        }

        function handleCanvasMouseDown(e) {
            if (e.target.id === 'mindmapCanvasWrapper' || e.target.id === 'mindmapCanvas') {
                mindmapState.isPanning = true;
                mindmapState.lastMouseX = e.clientX;
                mindmapState.lastMouseY = e.clientY;
                document.getElementById('mindmapCanvas').classList.add('panning');
            }
        }

        function handleMouseMove(e) {
            const mindmap = project.mindmaps.find(mm => mm.id === currentMindmapId);
            if (!mindmap) return;

            if (mindmapState.isDragging && mindmapState.draggedNode) {
                const node = mindmap.nodes.find(n => n.id === mindmapState.draggedNode);
                if (node) {
                    const canvas = document.getElementById('mindmapCanvas');
                    const rect = canvas.getBoundingClientRect();
                    
                    node.x = (e.clientX - rect.left) / mindmapState.zoom - mindmapState.dragOffsetX;
                    node.y = (e.clientY - rect.top) / mindmapState.zoom - mindmapState.dragOffsetY;
                    
                    // Mise à jour en temps réel
                    const nodeElem = document.querySelector(`[data-node-id="${node.id}"]`);
                    if (nodeElem) {
                        nodeElem.style.left = node.x + 'px';
                        nodeElem.style.top = node.y + 'px';
                    }
                    
                    // Redessiner les liens
                    document.getElementById('mindmapSvg').innerHTML = renderMindmapLinks(mindmap);
                }
            } else if (mindmapState.isPanning) {
                const deltaX = e.clientX - mindmapState.lastMouseX;
                const deltaY = e.clientY - mindmapState.lastMouseY;
                
                mindmapState.panX += deltaX / mindmapState.zoom;
                mindmapState.panY += deltaY / mindmapState.zoom;
                
                mindmapState.lastMouseX = e.clientX;
                mindmapState.lastMouseY = e.clientY;
                
                const canvas = document.getElementById('mindmapCanvas');
                canvas.style.transform = `scale(${mindmapState.zoom}) translate(${mindmapState.panX}px, ${mindmapState.panY}px)`;
            }
        }

        function handleMouseUp(e) {
            if (mindmapState.isDragging) {
                const mindmap = project.mindmaps.find(mm => mm.id === currentMindmapId);
                if (mindmap) {
                    saveProject();
                }
                
                document.querySelectorAll('.mindmap-node').forEach(node => {
                    node.classList.remove('dragging');
                });
            }
            
            if (mindmapState.isPanning) {
                document.getElementById('mindmapCanvas').classList.remove('panning');
            }
            
            mindmapState.isDragging = false;
            mindmapState.draggedNode = null;
            mindmapState.isPanning = false;
        }

        // ========================================
        // TOUCH EVENTS FOR MOBILE
        // ========================================

        function handleNodeTouchStart(e) {
            // Empêcher le comportement par défaut mais permettre les boutons
            if (e.target.classList.contains('mindmap-node-link-btn') || 
                e.target.classList.contains('mindmap-node-delete')) {
                return; // Laisser les boutons fonctionner
            }
            
            e.preventDefault();
            e.stopPropagation();
            
            const mindmap = project.mindmaps.find(mm => mm.id === currentMindmapId);
            if (!mindmap) return;

            const nodeId = parseInt(e.currentTarget.getAttribute('data-node-id'));
            const touch = e.touches[0];
            
            // Mode déplacement
            mindmapState.isDragging = true;
            mindmapState.draggedNode = nodeId;
            mindmapState.selectedNode = nodeId;
            
            const node = mindmap.nodes.find(n => n.id === nodeId);
            const canvas = document.getElementById('mindmapCanvas');
            const rect = canvas.getBoundingClientRect();
            
            mindmapState.dragOffsetX = (touch.clientX - rect.left) / mindmapState.zoom - node.x;
            mindmapState.dragOffsetY = (touch.clientY - rect.top) / mindmapState.zoom - node.y;
            
            e.currentTarget.classList.add('dragging');
        }

        function handleCanvasTouchStart(e) {
            if (e.target.id === 'mindmapCanvasWrapper' || e.target.id === 'mindmapCanvas') {
                e.preventDefault();
                const touch = e.touches[0];
                mindmapState.isPanning = true;
                mindmapState.lastMouseX = touch.clientX;
                mindmapState.lastMouseY = touch.clientY;
                document.getElementById('mindmapCanvas').classList.add('panning');
            }
        }

        function handleTouchMove(e) {
            const mindmap = project.mindmaps.find(mm => mm.id === currentMindmapId);
            if (!mindmap) return;

            const touch = e.touches[0];

            if (mindmapState.isDragging && mindmapState.draggedNode) {
                e.preventDefault();
                const node = mindmap.nodes.find(n => n.id === mindmapState.draggedNode);
                if (node) {
                    const canvas = document.getElementById('mindmapCanvas');
                    const rect = canvas.getBoundingClientRect();
                    
                    node.x = (touch.clientX - rect.left) / mindmapState.zoom - mindmapState.dragOffsetX;
                    node.y = (touch.clientY - rect.top) / mindmapState.zoom - mindmapState.dragOffsetY;
                    
                    // Mise à jour en temps réel
                    const nodeElem = document.querySelector(`[data-node-id="${node.id}"]`);
                    if (nodeElem) {
                        nodeElem.style.left = node.x + 'px';
                        nodeElem.style.top = node.y + 'px';
                    }
                    
                    // Redessiner les liens
                    document.getElementById('mindmapSvg').innerHTML = renderMindmapLinks(mindmap);
                }
            } else if (mindmapState.isPanning) {
                e.preventDefault();
                const deltaX = touch.clientX - mindmapState.lastMouseX;
                const deltaY = touch.clientY - mindmapState.lastMouseY;
                
                mindmapState.panX += deltaX / mindmapState.zoom;
                mindmapState.panY += deltaY / mindmapState.zoom;
                
                mindmapState.lastMouseX = touch.clientX;
                mindmapState.lastMouseY = touch.clientY;
                
                const canvas = document.getElementById('mindmapCanvas');
                canvas.style.transform = `scale(${mindmapState.zoom}) translate(${mindmapState.panX}px, ${mindmapState.panY}px)`;
            }
        }

        function handleTouchEnd(e) {
            if (mindmapState.isDragging) {
                const mindmap = project.mindmaps.find(mm => mm.id === currentMindmapId);
                if (mindmap) {
                    saveProject();
                }
                
                document.querySelectorAll('.mindmap-node').forEach(node => {
                    node.classList.remove('dragging');
                });
            }
            
            if (mindmapState.isPanning) {
                const canvas = document.getElementById('mindmapCanvas');
                if (canvas) {
                    canvas.classList.remove('panning');
                }
            }
            
            mindmapState.isDragging = false;
            mindmapState.draggedNode = null;
            mindmapState.isPanning = false;
        }

        function handleWheel(e) {
            e.preventDefault();
            
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            const newZoom = Math.max(0.1, Math.min(3, mindmapState.zoom * delta));
            
            mindmapState.zoom = newZoom;
            
            const canvas = document.getElementById('mindmapCanvas');
            canvas.style.transform = `scale(${mindmapState.zoom}) translate(${mindmapState.panX}px, ${mindmapState.panY}px)`;
        }
        
        let plotPoints = [];
        
        // Algorithme d'analyse de tension basé sur le contenu
        function calculateSceneTension(scene, actIndex, totalActs, chapterIndex, totalChapters, sceneIndex, totalScenes) {
            let tension = 0;
            const content = (scene.content || '').toLowerCase();
            const title = (scene.title || '').toLowerCase();
            
            // 1. ANALYSE LEXICALE (0-40 points)
            // Charger les mots personnalisés ou utiliser les valeurs par défaut
            const tensionWords = getTensionWords();
            const highTensionWords = tensionWords.high;
            const mediumTensionWords = tensionWords.medium;
            const lowTensionWords = tensionWords.low;
            
            let lexicalScore = 0;
            highTensionWords.forEach(word => {
                if (content.includes(word) || title.includes(word)) lexicalScore += 3;
            });
            mediumTensionWords.forEach(word => {
                if (content.includes(word) || title.includes(word)) lexicalScore += 1.5;
            });
            lowTensionWords.forEach(word => {
                if (content.includes(word) || title.includes(word)) lexicalScore -= 2;
            });
            
            tension += Math.max(0, Math.min(40, lexicalScore));
            
            // 2. ANALYSE DE LA LONGUEUR (0-10 points)
            // Les scènes courtes intenses vs longues descriptives
            const wordCount = content.split(/\s+/).filter(w => w.length > 0).length;
            if (wordCount < 200) tension += 8; // Scène courte = souvent intense
            else if (wordCount < 500) tension += 5;
            else if (wordCount < 1000) tension += 3;
            else tension += 2; // Scène longue = souvent descriptive
            
            // 3. PONCTUATION EXPRESSIVE (0-10 points)
            const exclamations = (content.match(/!/g) || []).length;
            const questions = (content.match(/\?/g) || []).length;
            const suspensions = (content.match(/\.\.\./g) || []).length;
            
            tension += Math.min(10, (exclamations * 0.5 + questions * 0.3 + suspensions * 0.8));
            
            // 4. STRUCTURE NARRATIVE (0-40 points)
            // Position dans l'acte (courbe en 3 actes)
            const actProgress = actIndex / Math.max(totalActs - 1, 1);
            const chapterProgress = chapterIndex / Math.max(totalChapters - 1, 1);
            const sceneProgress = sceneIndex / Math.max(totalScenes - 1, 1);
            
            // Structure classique en 3 actes
            if (totalActs >= 3) {
                if (actIndex === 0) {
                    // Acte 1 : Montée progressive
                    tension += 10 + (chapterProgress * 15);
                } else if (actIndex === totalActs - 1) {
                    // Dernier acte : Haute tension jusqu'au climax, puis résolution
                    if (sceneProgress < 0.7) {
                        tension += 35 + (sceneProgress * 5);
                    } else {
                        // Résolution
                        tension += 40 - ((sceneProgress - 0.7) * 50);
                    }
                } else {
                    // Actes intermédiaires : Montée progressive
                    tension += 20 + (actProgress * 15);
                }
            } else if (totalActs === 2) {
                // Structure en 2 actes
                if (actIndex === 0) {
                    tension += 15 + (chapterProgress * 15);
                } else {
                    tension += 30 + (sceneProgress * 10);
                }
            } else {
                // Un seul acte : courbe progressive
                tension += 20 + (sceneProgress * 20);
            }
            
            // Bonus pour les scènes de fin de chapitre (cliffhangers)
            if (sceneIndex === totalScenes - 1) {
                tension += 5;
            }
            
            // 5. NORMALISATION (0-100)
            tension = Math.max(15, Math.min(95, tension)); // Entre 15 et 95
            
            return tension;
        }
        
        function renderPlotView() {
            const container = document.getElementById('editorView');
            if (!container) {
                console.error('editorView container not found');
                return;
            }
            // Initialiser les points d'intrigue avec calcul intelligent
            if (plotPoints.length === 0 && project.acts.length > 0) {
                let position = 0;
                const totalActs = project.acts.length;
                
                project.acts.forEach((act, actIndex) => {
                    const totalChapters = act.chapters.length;
                    
                    act.chapters.forEach((chapter, chapIndex) => {
                        const totalScenes = chapter.scenes.length;
                        
                        chapter.scenes.forEach((scene, sceneIndex) => {
                            const intensity = calculateSceneTension(
                                scene, 
                                actIndex, 
                                totalActs, 
                                chapIndex, 
                                totalChapters, 
                                sceneIndex, 
                                totalScenes
                            );
                            
                            plotPoints.push({
                                position: position++,
                                intensity: intensity,
                                title: scene.title,
                                actId: act.id,
                                chapterId: chapter.id,
                                sceneId: scene.id,
                                description: `${act.title} > ${chapter.title}`,
                                wordCount: scene.content ? scene.content.split(/\s+/).filter(w => w.length > 0).length : 0
                            });
                        });
                    });
                });
            }
            
            // Générer le graphique SVG
            const svgWidth = 800;
            const svgHeight = 500;
            const padding = 60;
            const plotWidth = svgWidth - padding * 2;
            const plotHeight = svgHeight - padding * 2;
            
            let pathData = '';
            let pointsHTML = '';
            let gridLines = '';
            
            // Lignes de grille
            for (let i = 0; i <= 4; i++) {
                const y = padding + (plotHeight / 4) * i;
                gridLines += `<line x1="${padding}" y1="${y}" x2="${svgWidth - padding}" y2="${y}" stroke="var(--border-color)" stroke-width="1" opacity="0.3" stroke-dasharray="5,5"/>`;
                gridLines += `<text x="${padding - 10}" y="${y + 5}" text-anchor="end" font-size="12" fill="var(--text-muted)">${100 - i * 25}%</text>`;
            }
            
            // Générer la courbe
            if (plotPoints.length > 0) {
                plotPoints.forEach((point, index) => {
                    const x = padding + (plotWidth / Math.max(plotPoints.length - 1, 1)) * index;
                    const y = padding + plotHeight - (point.intensity / 100) * plotHeight;
                    
                    if (index === 0) {
                        pathData = `M ${x} ${y}`;
                    } else {
                        pathData += ` L ${x} ${y}`;
                    }
                    
                    // Points cliquables avec menu contextuel
                    pointsHTML += `
                        <circle cx="${x}" cy="${y}" r="6" fill="var(--accent-gold)" stroke="white" stroke-width="2" 
                                style="cursor: pointer;" 
                                onclick="editPlotPointIntensity(${index})"
                                oncontextmenu="event.preventDefault(); openPlotPoint(${point.actId}, ${point.chapterId}, ${point.sceneId})">
                            <title>Clic gauche: Éditer tension (${Math.round(point.intensity)}%)
Clic droit: Ouvrir scène "${point.title}"</title>
                        </circle>
                    `;
                });
            }
            
            container.innerHTML = `
                <div style="padding: 2rem;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
                        <div>
                            <h3 style="margin: 0;"><i data-lucide="trending-up" style="width:18px;height:18px;vertical-align:middle;margin-right:6px;"></i>Graphique d'Intrigue</h3>
                            <div style="font-size: 0.85rem; color: var(--text-secondary); margin-top: 0.5rem;">
                                📊 ${plotPoints.length} point(s) d'intrigue • 🎯 Tension moyenne: ${plotPoints.length > 0 ? Math.round(plotPoints.reduce((sum, p) => sum + p.intensity, 0) / plotPoints.length) : 0}%
                            </div>
                        </div>
                        <button onclick="openTensionWordsEditor()" 
                                style="padding: 10px 18px; background: #3a7bc8; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.9rem; font-weight: 500; transition: all 0.2s; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"
                                onmouseover="this.style.background='#2d6bb3'; this.style.boxShadow='0 4px 8px rgba(0,0,0,0.15)'"
                                onmouseout="this.style.background='#3a7bc8'; this.style.boxShadow='0 2px 4px rgba(0,0,0,0.1)'">
                            ✏️ Personnaliser les mots de tension
                        </button>
                    </div>
                    <div class="visualization-toolbar">
                        <button class="viz-tool-btn active">Vue d'ensemble</button>
                        <button class="viz-tool-btn" onclick="analyzePlotCurve()">🔍 Analyser la courbe</button>
                        <button class="viz-tool-btn" onclick="showPlotSuggestions()"><i data-lucide="lightbulb" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Suggestions</button>
                        <button class="viz-tool-btn" onclick="resetPlotPoints()">🔄 Recalculer</button>
                        <button class="viz-tool-btn" onclick="exportPlot()">📤 Exporter</button>
                    </div>
                    <div class="visualization-canvas">
                        <div class="plot-graph">
                            <svg width="100%" height="${svgHeight}" viewBox="0 0 ${svgWidth} ${svgHeight}" id="plotSvg">
                                <!-- Axes -->
                                <line x1="${padding}" y1="${svgHeight - padding}" x2="${svgWidth - padding}" y2="${svgHeight - padding}" 
                                      stroke="var(--text-primary)" stroke-width="2"/>
                                <line x1="${padding}" y1="${padding}" x2="${padding}" y2="${svgHeight - padding}" 
                                      stroke="var(--text-primary)" stroke-width="2"/>
                                
                                <!-- Labels -->
                                <text x="${svgWidth / 2}" y="${svgHeight - 20}" text-anchor="middle" fill="var(--text-muted)" font-size="14">
                                    Progression du récit →
                                </text>
                                <text x="20" y="${svgHeight / 2}" text-anchor="middle" fill="var(--text-muted)" font-size="14" 
                                      transform="rotate(-90 20 ${svgHeight / 2})">
                                    ← Tension dramatique
                                </text>
                                
                                <!-- Grille -->
                                ${gridLines}
                                
                                <!-- Courbe d'intrigue -->
                                ${pathData ? `<path d="${pathData}" fill="none" stroke="var(--accent-gold)" stroke-width="3"/>` : ''}
                                
                                <!-- Points -->
                                ${pointsHTML}
                            </svg>
                        </div>
                    </div>
                    <div style="margin-top: 1rem; padding: 1rem; background: var(--bg-secondary); border-radius: 4px;">
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                            <div>
                                <p style="font-size: 0.9rem; color: var(--text-secondary); line-height: 1.6; margin: 0;">
                                    💡 <strong>Utilisation:</strong><br>
                                    • <strong>Clic gauche</strong> sur un point → Modifier manuellement la tension<br>
                                    • <strong>Clic droit</strong> sur un point → Ouvrir la scène pour l'éditer<br>
                                    • <strong>Analyser</strong> → Obtenez un rapport complet sur votre courbe<br>
                                    • <strong>Suggestions</strong> → Conseils personnalisés pour améliorer l'intrigue
                                </p>
                            </div>
                            <div style="padding: 0.75rem; background: var(--bg-primary); border-radius: 4px; border: 1px solid var(--border-color);">
                                <div style="font-size: 0.85rem; font-weight: 600; margin-bottom: 0.5rem; color: var(--text-primary);">Calcul de la tension :</div>
                                <div style="font-size: 0.75rem; line-height: 1.6; color: var(--text-secondary);">
                                    • Analyse lexicale (mots-clés personnalisables)<br>
                                    • Longueur de la scène<br>
                                    • Ponctuation expressive<br>
                                    • Position narrative (structure en 3 actes)
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }
        
        function openPlotPoint(actId, chapterId, sceneId) {
            switchView('editor');
            openScene(actId, chapterId, sceneId);
        }
        
        function editPlotPointIntensity(index) {
            if (index < 0 || index >= plotPoints.length) return;
            
            const point = plotPoints[index];
            const currentIntensity = Math.round(point.intensity);
            
            const newIntensity = prompt(
                `Modifier la tension de "${point.title}"\n\n` +
                `Tension actuelle: ${currentIntensity}%\n` +
                `Entrez une nouvelle valeur (0-100):`,
                currentIntensity
            );
            
            if (newIntensity === null) return;
            
            const intensity = parseInt(newIntensity);
            if (isNaN(intensity) || intensity < 0 || intensity > 100) {
                alert('Veuillez entrer un nombre entre 0 et 100');
                return;
            }
            
            point.intensity = intensity;
            renderPlotView();
            showNotification(`✓ Tension mise à jour: ${intensity}%`);
        }
        
        function analyzePlotCurve() {
            if (plotPoints.length === 0) {
                alert('Aucun point à analyser. Créez d\'abord des scènes.');
                return;
            }
            
            // Analyse de la courbe
            const tensions = plotPoints.map(p => p.intensity);
            const avg = tensions.reduce((a, b) => a + b, 0) / tensions.length;
            const max = Math.max(...tensions);
            const min = Math.min(...tensions);
            const maxIndex = tensions.indexOf(max);
            const minIndex = tensions.indexOf(min);
            
            // Calcul de la variance (mesure de variation)
            const variance = tensions.reduce((sum, t) => sum + Math.pow(t - avg, 2), 0) / tensions.length;
            const stdDev = Math.sqrt(variance);
            
            // Détection du climax
            const lastThird = Math.floor(plotPoints.length * 0.66);
            const climaxInLastThird = maxIndex >= lastThird;
            
            // Analyse de la progression
            const firstHalf = tensions.slice(0, Math.floor(tensions.length / 2));
            const secondHalf = tensions.slice(Math.floor(tensions.length / 2));
            const firstAvg = firstHalf.reduce((a, b) => a + b, 0) / firstHalf.length;
            const secondAvg = secondHalf.reduce((a, b) => a + b, 0) / secondHalf.length;
            const isRising = secondAvg > firstAvg;
            
            // Compter les pics (variations > 20%)
            let peaks = 0;
            for (let i = 1; i < tensions.length - 1; i++) {
                if (tensions[i] > tensions[i-1] + 20 && tensions[i] > tensions[i+1] + 20) {
                    peaks++;
                }
            }
            
            // Rapport d'analyse
            let analysis = `📊 ANALYSE DE VOTRE COURBE D'INTRIGUE\n\n`;
            
            analysis += `📈 STATISTIQUES\n`;
            analysis += `• Tension moyenne : ${Math.round(avg)}%\n`;
            analysis += `• Tension max : ${Math.round(max)}% (${plotPoints[maxIndex].title})\n`;
            analysis += `• Tension min : ${Math.round(min)}% (${plotPoints[minIndex].title})\n`;
            analysis += `• Amplitude : ${Math.round(max - min)}%\n`;
            analysis += `• Variation : ${stdDev < 10 ? 'Faible' : stdDev < 20 ? 'Modérée' : 'Forte'}\n`;
            analysis += `• Nombre de pics : ${peaks}\n\n`;
            
            analysis += `🎯 ÉVALUATION NARRATIVE\n`;
            
            // Évaluation de la tension moyenne
            if (avg < 40) {
                analysis += `⚠️ Tension moyenne BASSE (${Math.round(avg)}%)\n`;
                analysis += `   → Votre histoire manque peut-être de conflits\n`;
            } else if (avg > 70) {
                analysis += `⚠️ Tension moyenne ÉLEVÉE (${Math.round(avg)}%)\n`;
                analysis += `   → Le lecteur risque la fatigue. Ajoutez des pauses\n`;
            } else {
                analysis += `✅ Tension moyenne équilibrée (${Math.round(avg)}%)\n`;
            }
            
            // Évaluation du climax
            if (climaxInLastThird) {
                analysis += `✅ Climax bien placé (dernier tiers du récit)\n`;
            } else {
                analysis += `⚠️ Climax trop tôt (${Math.round((maxIndex / plotPoints.length) * 100)}% du récit)\n`;
                analysis += `   → Le climax devrait être vers 70-80%\n`;
            }
            
            // Évaluation de la progression
            if (isRising) {
                analysis += `✅ Tension croissante (bon rythme)\n`;
            } else {
                analysis += `⚠️ Tension décroissante en moyenne\n`;
                analysis += `   → La seconde moitié perd en intensité\n`;
            }
            
            // Évaluation de la variation
            if (stdDev < 10) {
                analysis += `⚠️ Courbe trop PLATE\n`;
                analysis += `   → Créez plus de contraste entre action et repos\n`;
            } else if (stdDev > 25) {
                analysis += `⚠️ Courbe très IRRÉGULIÈRE\n`;
                analysis += `   → Peut-être intentionnel (action frénétique)?\n`;
            } else {
                analysis += `✅ Variation équilibrée\n`;
            }
            
            // Évaluation des pics
            if (peaks === 0) {
                analysis += `⚠️ Aucun pic majeur détecté\n`;
                analysis += `   → Ajoutez des moments de tension forte\n`;
            } else if (peaks > plotPoints.length / 3) {
                analysis += `⚠️ Trop de pics (${peaks})\n`;
                analysis += `   → Le lecteur n'a pas le temps de souffler\n`;
            } else {
                analysis += `✅ Nombre de pics approprié (${peaks})\n`;
            }
            
            analysis += `\n💡 Cliquez sur "Suggestions" pour des conseils détaillés`;
            
            alert(analysis);
        }
        
        function showPlotSuggestions() {
            if (plotPoints.length === 0) {
                alert('Créez d\'abord des scènes pour obtenir des suggestions.');
                return;
            }
            
            const tensions = plotPoints.map(p => p.intensity);
            const avg = tensions.reduce((a, b) => a + b, 0) / tensions.length;
            
            let suggestions = `💡 SUGGESTIONS POUR AMÉLIORER VOTRE INTRIGUE\n\n`;
            
            // Analyser les zones plates
            let flatZones = [];
            for (let i = 0; i < tensions.length - 2; i++) {
                const range = tensions.slice(i, i + 3);
                const rangeAvg = range.reduce((a, b) => a + b, 0) / range.length;
                const rangeVariance = range.reduce((sum, t) => sum + Math.pow(t - rangeAvg, 2), 0) / range.length;
                if (rangeVariance < 5) {
                    flatZones.push(i);
                }
            }
            
            if (flatZones.length > 0) {
                suggestions += `📉 ZONES PLATES DÉTECTÉES\n`;
                suggestions += `${flatZones.length} séquences manquent de variation.\n`;
                suggestions += `→ Ajoutez un rebondissement ou un obstacle\n`;
                suggestions += `→ Variez le rythme (alternez dialogue et action)\n\n`;
            }
            
            // Suggestions selon la tension moyenne
            if (avg < 40) {
                suggestions += `🔥 AUGMENTER LA TENSION GLOBALE\n`;
                suggestions += `→ Ajoutez plus de conflits entre personnages\n`;
                suggestions += `→ Créez des obstacles plus grands\n`;
                suggestions += `→ Utilisez des mots plus percutants\n`;
                suggestions += `→ Raccourcissez les scènes d'action\n\n`;
            } else if (avg > 70) {
                suggestions += `😌 CRÉER DES PAUSES\n`;
                suggestions += `→ Ajoutez des scènes de réflexion\n`;
                suggestions += `→ Moments de calme après l'action\n`;
                suggestions += `→ Dialogues intimes ou humoristiques\n`;
                suggestions += `→ Descriptions contemplatives\n\n`;
            }
            
            // Suggestions de structure
            suggestions += `📐 STRUCTURE RECOMMANDÉE\n`;
            suggestions += `• Début (0-25%) : 20-40% tension\n`;
            suggestions += `• Milieu (25-66%) : 40-60% tension\n`;
            suggestions += `• Fin (66-90%) : 60-90% tension (climax)\n`;
            suggestions += `• Résolution (90-100%) : 20-40% tension\n\n`;
            
            // Conseils pratiques
            suggestions += `✍️ TECHNIQUES CONCRÈTES\n`;
            suggestions += `→ Pour augmenter la tension :\n`;
            suggestions += `  • Ajoutez des deadlines\n`;
            suggestions += `  • Mettez en danger un personnage aimé\n`;
            suggestions += `  • Révélez un secret\n`;
            suggestions += `  • Créez un dilemme moral\n\n`;
            suggestions += `→ Pour diminuer la tension :\n`;
            suggestions += `  • Résolvez un conflit mineur\n`;
            suggestions += `  • Moment de victoire temporaire\n`;
            suggestions += `  • Scène de camaraderie\n`;
            suggestions += `  • Description paisible\n`;
            
            alert(suggestions);
        }
        
        function resetPlotPoints() {
            if (confirm('Recalculer tous les points d\'intrigue ?\n\nLa tension sera recalculée automatiquement pour toutes les scènes.\n\nLes ajustements manuels seront perdus.')) {
                plotPoints = [];
                renderPlotView();
                showNotification('✓ Points recalculés automatiquement');
            }
        }
        
        function addPlotPoint() {
            alert('Les points sont générés automatiquement depuis vos scènes.\n\nPour ajuster la tension :\n• Clic gauche sur un point → Modifier manuellement\n• Clic droit sur un point → Ouvrir la scène');
        }
        
        function exportPlot() {
            const svg = document.getElementById('plotSvg');
            if (!svg) return;
            
            const svgData = new XMLSerializer().serializeToString(svg);
            const blob = new Blob([svgData], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${project.title}_plot.svg`;
            a.click();
            URL.revokeObjectURL(url);
        }
            
        
        // ============================================
        // RELATIONS GRAPH FUNCTIONS
        // ============================================
        
        function renderRelationsView() {
            const editorView = document.getElementById('editorView');
            if (!editorView) {
                console.error('editorView not found');
                return;
            }
            
            // S'assurer que relations existe
            if (!project.relations) project.relations = [];
            
            // S'assurer que les positions personnalisées existent
            if (!project.characterPositions) project.characterPositions = {};
            
            // Types de relations avec couleurs
            const relationTypes = {
                'amour': { color: '#e91e63', label: '❤️ Amour', icon: '❤️' },
                'amitie': { color: '#4caf50', label: '🤝 Amitié', icon: '🤝' },
                'rivalite': { color: '#f44336', label: '⚔️ Rivalité', icon: '⚔️' },
                'famille': { color: '#2196f3', label: '👨‍👩‍👧 Famille', icon: '👨‍👩‍👧' },
                'mentor': { color: '#ff9800', label: '📚 Mentor', icon: '📚' },
                'ennemi': { color: '#9c27b0', label: '💀 Ennemi', icon: '💀' },
                'alliance': { color: '#00bcd4', label: '🤜🤛 Alliance', icon: '🤜🤛' },
                'neutre': { color: '#757575', label: '😐 Neutre', icon: '😐' }
            };
            
            let graphHTML = '';
            if (project.characters.length >= 2) {
                const centerX = 400;
                const centerY = 350;
                const radius = 220;
                
                // Calculer les positions (personnalisées ou par défaut en cercle)
                const positions = project.characters.map((char, i) => {
                    if (project.characterPositions[char.id]) {
                        return project.characterPositions[char.id];
                    } else {
                        const angle = (i / project.characters.length) * 2 * Math.PI;
                        return {
                            x: centerX + radius * Math.cos(angle),
                            y: centerY + radius * Math.sin(angle)
                        };
                    }
                });
                
                // SVG pour les lignes de relation
                let svgLines = '<svg id="relationsSvg" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0; pointer-events: none;">';
                
                // Dessiner les relations existantes
                project.relations.forEach(rel => {
                    const char1 = project.characters.find(c => c.id === rel.char1Id);
                    const char2 = project.characters.find(c => c.id === rel.char2Id);
                    
                    if (char1 && char2) {
                        const i1 = project.characters.indexOf(char1);
                        const i2 = project.characters.indexOf(char2);
                        
                        const x1 = positions[i1].x;
                        const y1 = positions[i1].y;
                        const x2 = positions[i2].x;
                        const y2 = positions[i2].y;
                        
                        const relType = relationTypes[rel.type] || relationTypes['neutre'];
                        
                        svgLines += `
                            <line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" 
                                  stroke="${relType.color}" 
                                  stroke-width="3" 
                                  opacity="0.7"
                                  style="cursor: pointer;"
                                  onclick="editRelation('${rel.id}')"/>
                            <text x="${(x1 + x2) / 2}" y="${(y1 + y2) / 2 - 10}" 
                                  fill="${relType.color}" 
                                  font-size="20" 
                                  text-anchor="middle"
                                  style="pointer-events: none;">${relType.icon}</text>
                        `;
                    }
                });
                
                svgLines += '</svg>';
                
                // Positionner les personnages (draggables)
                project.characters.forEach((char, i) => {
                    const pos = positions[i];
                    
                    graphHTML += `
                        <div id="char-node-${char.id}" 
                             class="char-node-draggable"
                             data-char-id="${char.id}"
                             style="position: absolute; left: ${pos.x}px; top: ${pos.y}px; transform: translate(-50%, -50%); text-align: center; cursor: move;"
                             onmousedown="startDragCharacter(event, ${char.id})"
                             onclick="handleCharacterClick(event, ${char.id})">
                            <div style="width: 70px; height: 70px; border-radius: 50%; background: var(--accent-gold); 
                                        display: flex; align-items: center; justify-content: center; font-size: 2rem;
                                        border: 3px solid white; box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                                        ${selectedCharsForRelation.includes(char.id) ? 'border-color: var(--accent-red); border-width: 5px;' : ''}
                                        transition: transform 0.2s;">
                                ${char.avatar || '👤'}
                            </div>
                            <div style="margin-top: 0.5rem; font-weight: 600; font-size: 0.9rem; background: var(--bg-accent); color: white;
                                        padding: 0.25rem 0.5rem; border-radius: 4px; white-space: nowrap; pointer-events: none;">${char.name}</div>
                        </div>
                    `;
                });
                
                graphHTML = svgLines + graphHTML;
            } else {
                graphHTML = `
                    <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center;">
                        <div style="font-size: 4rem; margin-bottom: 1rem;"><i data-lucide="users" style="width:64px;height:64px;"></i></div>
                        <div style="font-size: 1.3rem; font-weight: 600; margin-bottom: 0.5rem;">Aucune relation à afficher</div>
                        <div style="color: var(--text-muted); margin-bottom: 1rem;">Créez au moins 2 personnages pour visualiser leurs relations</div>
                        <button class="btn btn-primary" onclick="switchView('characters')">+ Créer des personnages</button>
                    </div>
                `;
            }
            
            editorView.innerHTML = `
                <div style="height: 100%; overflow-y: auto; padding: 2rem 3rem;">
                    <h2 style="margin-bottom: 2rem; color: var(--accent-gold);"><i data-lucide="network" style="width:24px;height:24px;vertical-align:middle;margin-right:8px;"></i>Carte des Relations</h2>
                    
                    ${project.characters.length >= 2 ? `
                        <div style="margin-bottom: 2rem; display: flex; gap: 1rem; flex-wrap: wrap;">
                            <div style="flex: 1; min-width: 300px; padding: 1.5rem; background: var(--bg-secondary); border-radius: 8px; border-left: 4px solid var(--accent-gold);">
                                <div style="font-weight: 600; margin-bottom: 0.5rem;"><i data-lucide="pen-line" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Créer une relation:</div>
                                <div style="font-size: 0.9rem; color: var(--text-secondary); line-height: 1.6;">
                                    1. Cliquez sur un premier personnage<br>
                                    2. Cliquez sur un second personnage<br>
                                    3. Choisissez le type de relation
                                </div>
                            </div>
                            <div style="flex: 1; min-width: 300px; padding: 1.5rem; background: var(--bg-secondary); border-radius: 8px; border-left: 4px solid var(--accent-red);">
                                <div style="font-weight: 600; margin-bottom: 0.5rem;">🖱️ Déplacer les personnages:</div>
                                <div style="font-size: 0.9rem; color: var(--text-secondary); line-height: 1.6;">
                                    Faites glisser les personnages pour réorganiser le graphe<br>
                                    Les liens suivent automatiquement
                                </div>
                            </div>
                        </div>
                        <div style="margin-bottom: 1rem; display: flex; gap: 0.5rem;">
                            <button class="btn btn-small" onclick="resetCharacterPositions()">🔄 Réinitialiser positions</button>
                            <button class="btn btn-small" onclick="autoArrangeCharacters()"><i data-lucide="sparkles" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Arranger automatiquement</button>
                        </div>
                    ` : ''}
                    
                    <div id="relationsGraph" style="position: relative; height: 700px; background: var(--bg-secondary); border-radius: 8px; margin-bottom: 2rem;">
                        ${graphHTML}
                    </div>
                    
                    ${project.characters.length >= 2 ? `
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1rem; margin-bottom: 2rem;">
                            ${Object.entries(relationTypes).map(([key, rel]) => `
                                <div style="display: flex; align-items: center; gap: 0.75rem; padding: 1rem; background: var(--bg-secondary); border-radius: 8px; border-left: 4px solid ${rel.color};">
                                    <div style="font-size: 1.5rem;">${rel.icon}</div>
                                    <div style="flex: 1;">
                                        <div style="font-weight: 600; font-size: 0.95rem;">${rel.label.split(' ')[1]}</div>
                                        <div style="font-size: 0.75rem; color: var(--text-muted);">${getRelationCount(key)} relation(s)</div>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    ` : ''}
                    
                    ${project.relations && project.relations.length > 0 ? `
                        <div style="background: var(--bg-secondary); padding: 1.5rem; border-radius: 8px;">
                            <h3 style="margin-bottom: 1rem; color: var(--text-primary);"><i data-lucide="list" style="width:18px;height:18px;vertical-align:middle;margin-right:6px;"></i>Liste des relations (${project.relations.length})</h3>
                            <div style="display: flex; flex-direction: column; gap: 0.75rem;">
                                ${project.relations.map(rel => {
                                    const char1 = project.characters.find(c => c.id === rel.char1Id);
                                    const char2 = project.characters.find(c => c.id === rel.char2Id);
                                    const relType = relationTypes[rel.type] || relationTypes['neutre'];
                                    return char1 && char2 ? `
                                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 1rem; background: var(--bg-primary); border-radius: 4px; border-left: 4px solid ${relType.color};">
                                            <div style="display: flex; align-items: center; gap: 1rem;">
                                                <span style="font-size: 1.5rem;">${relType.icon}</span>
                                                <span style="font-weight: 600;">${char1.name}</span>
                                                <span style="color: var(--text-muted);">↔</span>
                                                <span style="font-weight: 600;">${char2.name}</span>
                                                ${rel.description ? `<span style="color: var(--text-muted); font-size: 0.85rem;">· ${rel.description}</span>` : ''}
                                            </div>
                                            <div style="display: flex; gap: 0.5rem;">
                                                <button class="btn btn-small" onclick="editRelation('${rel.id}')">✏️</button>
                                                <button class="btn btn-small" onclick="deleteRelation('${rel.id}')">🗑️</button>
                                            </div>
                                        </div>
                                    ` : '';
                                }).join('')}
                            </div>
                        </div>
                    ` : ''}
                </div>
            `;
            
            // Ajouter les événements de hover sur les personnages
            setTimeout(() => {
                document.querySelectorAll('.char-node-draggable').forEach(node => {
                    node.addEventListener('mouseenter', () => {
                        node.querySelector('div').style.transform = 'scale(1.1)';
                    });
                    node.addEventListener('mouseleave', () => {
                        node.querySelector('div').style.transform = 'scale(1)';
                    });
                });
            }, 0);
        }
        
        // Variables pour le drag-and-drop
        let draggedCharId = null;
        let dragStartX = 0;
        let dragStartY = 0;
        let isDragging = false;
        let dragMoved = false;
        
        function startDragCharacter(event, charId) {
            event.preventDefault();
            draggedCharId = charId;
            dragStartX = event.clientX;
            dragStartY = event.clientY;
            isDragging = true;
            dragMoved = false;
            
            document.addEventListener('mousemove', dragCharacter);
            document.addEventListener('mouseup', stopDragCharacter);
        }
        
        function dragCharacter(event) {
            if (!isDragging || !draggedCharId) return;
            
            const deltaX = event.clientX - dragStartX;
            const deltaY = event.clientY - dragStartY;
            
            // Considérer comme un drag si mouvement > 5px
            if (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5) {
                dragMoved = true;
            }
            
            const node = document.getElementById(`char-node-${draggedCharId}`);
            if (!node) return;
            
            const graph = document.getElementById('relationsGraph');
            const graphRect = graph.getBoundingClientRect();
            
            // Position actuelle
            const currentLeft = parseFloat(node.style.left);
            const currentTop = parseFloat(node.style.top);
            
            // Nouvelle position
            let newLeft = currentLeft + deltaX;
            let newTop = currentTop + deltaY;
            
            // Limiter aux bords du graphe
            newLeft = Math.max(50, Math.min(graphRect.width - 50, newLeft));
            newTop = Math.max(50, Math.min(graphRect.height - 50, newTop));
            
            node.style.left = newLeft + 'px';
            node.style.top = newTop + 'px';
            
            dragStartX = event.clientX;
            dragStartY = event.clientY;
            
            // Mettre à jour les lignes SVG
            updateRelationLines();
        }
        
        function stopDragCharacter(event) {
            if (!isDragging) return;
            
            document.removeEventListener('mousemove', dragCharacter);
            document.removeEventListener('mouseup', stopDragCharacter);
            
            if (dragMoved) {
                // Sauvegarder la nouvelle position
                const node = document.getElementById(`char-node-${draggedCharId}`);
                if (node) {
                    if (!project.characterPositions) project.characterPositions = {};
                    project.characterPositions[draggedCharId] = {
                        x: parseFloat(node.style.left),
                        y: parseFloat(node.style.top)
                    };
                    saveProject();
                    showNotification('📍 Position sauvegardée');
                }
            }
            
            isDragging = false;
            draggedCharId = null;
            dragMoved = false;
        }
        
        function handleCharacterClick(event, charId) {
            // Ne pas traiter comme un clic si c'était un drag
            if (dragMoved) {
                event.stopPropagation();
                return;
            }
            
            selectCharacterForRelation(charId);
        }
        
        function updateRelationLines() {
            const svg = document.getElementById('relationsSvg');
            if (!svg) return;
            
            const relationTypes = {
                'amour': { color: '#e91e63', icon: '❤️' },
                'amitie': { color: '#4caf50', icon: '🤝' },
                'rivalite': { color: '#f44336', icon: '⚔️' },
                'famille': { color: '#2196f3', icon: '👨‍👩‍👧' },
                'mentor': { color: '#ff9800', icon: '📚' },
                'ennemi': { color: '#9c27b0', icon: '💀' },
                'alliance': { color: '#00bcd4', icon: '🤜🤛' },
                'neutre': { color: '#757575', icon: '😐' }
            };
            
            let svgContent = '';
            
            project.relations.forEach(rel => {
                const char1 = project.characters.find(c => c.id === rel.char1Id);
                const char2 = project.characters.find(c => c.id === rel.char2Id);
                
                if (char1 && char2) {
                    const node1 = document.getElementById(`char-node-${char1.id}`);
                    const node2 = document.getElementById(`char-node-${char2.id}`);
                    
                    if (node1 && node2) {
                        const x1 = parseFloat(node1.style.left);
                        const y1 = parseFloat(node1.style.top);
                        const x2 = parseFloat(node2.style.left);
                        const y2 = parseFloat(node2.style.top);
                        
                        const relType = relationTypes[rel.type] || relationTypes['neutre'];
                        
                        svgContent += `
                            <line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" 
                                  stroke="${relType.color}" 
                                  stroke-width="3" 
                                  opacity="0.7"
                                  style="cursor: pointer;"
                                  onclick="editRelation('${rel.id}')"/>
                            <text x="${(x1 + x2) / 2}" y="${(y1 + y2) / 2 - 10}" 
                                  fill="${relType.color}" 
                                  font-size="20" 
                                  text-anchor="middle"
                                  style="pointer-events: none;">${relType.icon}</text>
                        `;
                    }
                }
            });
            
            svg.innerHTML = svgContent;
        }
        
        function resetCharacterPositions() {
            if (confirm('Réinitialiser toutes les positions des personnages ?')) {
                project.characterPositions = {};
                saveProject();
                renderRelationsView();
                showNotification('🔄 Positions réinitialisées');
            }
        }
        
        function autoArrangeCharacters() {
            // Arranger en cercle avec plus d'espace
            const centerX = 400;
            const centerY = 350;
            const radius = 220;
            
            project.characterPositions = {};
            project.characters.forEach((char, i) => {
                const angle = (i / project.characters.length) * 2 * Math.PI;
                project.characterPositions[char.id] = {
                    x: centerX + radius * Math.cos(angle),
                    y: centerY + radius * Math.sin(angle)
                };
            });
            
            saveProject();
            renderRelationsView();
            showNotification('✨ Personnages arrangés automatiquement');
        }
        
        // Variables pour la sélection de personnages
        let selectedCharsForRelation = [];
        
        function selectCharacterForRelation(charId) {
            if (selectedCharsForRelation.includes(charId)) {
                // Désélectionner
                selectedCharsForRelation = selectedCharsForRelation.filter(id => id !== charId);
            } else {
                selectedCharsForRelation.push(charId);
            }
            
            // Si 2 personnages sélectionnés, demander le type de relation
            if (selectedCharsForRelation.length === 2) {
                createRelationModal();
            } else {
                renderRelationsView();
            }
        }
        
        function createRelationModal() {
            const char1 = project.characters.find(c => c.id === selectedCharsForRelation[0]);
            const char2 = project.characters.find(c => c.id === selectedCharsForRelation[1]);
            
            const relationTypes = {
                'amour': { color: '#e91e63', label: '❤️ Amour' },
                'amitie': { color: '#4caf50', label: '🤝 Amitié' },
                'rivalite': { color: '#f44336', label: '⚔️ Rivalité' },
                'famille': { color: '#2196f3', label: '👨‍👩‍👧 Famille' },
                'mentor': { color: '#ff9800', label: '📚 Mentor' },
                'ennemi': { color: '#9c27b0', label: '💀 Ennemi' },
                'alliance': { color: '#00bcd4', label: '🤜🤛 Alliance' },
                'neutre': { color: '#757575', label: '😐 Neutre' }
            };
            
            const modalHTML = `
                <div class="modal active" id="relationModal" onclick="if(event.target===this) closeRelationModal()">
                    <div class="modal-content" style="max-width: 500px;">
                        <h2 style="margin-bottom: 1.5rem;"><i data-lucide="link" style="width:20px;height:20px;vertical-align:middle;margin-right:6px;"></i>Créer une relation</h2>
                        
                        <div style="margin-bottom: 1.5rem; padding: 1rem; background: var(--bg-secondary); border-radius: 8px; text-align: center;">
                            <span style="font-weight: 600; font-size: 1.1rem;">${char1.name}</span>
                            <span style="margin: 0 1rem; color: var(--text-muted);">↔</span>
                            <span style="font-weight: 600; font-size: 1.1rem;">${char2.name}</span>
                        </div>
                        
                        <div style="margin-bottom: 1.5rem;">
                            <label style="display: block; font-weight: 600; margin-bottom: 0.75rem;">Type de relation:</label>
                            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.5rem;">
                                ${Object.entries(relationTypes).map(([key, rel]) => `
                                    <button class="btn" onclick="selectRelationType('${key}')" 
                                            id="relType-${key}"
                                            style="justify-content: flex-start; text-align: left; padding: 0.75rem;">
                                        <div style="width: 4px; height: 100%; background: ${rel.color}; position: absolute; left: 0; top: 0; bottom: 0;"></div>
                                        ${rel.label}
                                    </button>
                                `).join('')}
                            </div>
                        </div>
                        
                        <div style="margin-bottom: 1.5rem;">
                            <label style="display: block; font-weight: 600; margin-bottom: 0.5rem;">Description (optionnel):</label>
                            <input type="text" class="form-input" id="relationDescription" placeholder="Ex: Frère et sœur, alliés depuis l'enfance...">
                        </div>
                        
                        <div style="display: flex; gap: 0.5rem; justify-content: flex-end;">
                            <button class="btn" onclick="closeRelationModal()">Annuler</button>
                            <button class="btn btn-primary" onclick="saveRelation()" id="saveRelationBtn" disabled>Créer la relation</button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', modalHTML);
        }
        
        let selectedRelationType = null;
        
        function selectRelationType(type) {
            selectedRelationType = type;
            
            // Mettre à jour l'UI
            document.querySelectorAll('[id^="relType-"]').forEach(btn => {
                btn.classList.remove('btn-primary');
            });
            document.getElementById(`relType-${type}`).classList.add('btn-primary');
            document.getElementById('saveRelationBtn').disabled = false;
        }
        
        function saveRelation() {
            if (!selectedRelationType) return;
            
            const description = document.getElementById('relationDescription').value;
            
            if (!project.relations) project.relations = [];
            
            project.relations.push({
                id: 'rel_' + Date.now(),
                char1Id: selectedCharsForRelation[0],
                char2Id: selectedCharsForRelation[1],
                type: selectedRelationType,
                description: description,
                createdAt: new Date().toISOString()
            });
            
            saveProject();
            closeRelationModal();
            selectedCharsForRelation = [];
            selectedRelationType = null;
            renderRelationsView();
            showNotification('🔗 Relation créée');
        }
        
        function closeRelationModal() {
            const modal = document.getElementById('relationModal');
            if (modal) modal.remove();
            selectedCharsForRelation = [];
            selectedRelationType = null;
            renderRelationsView();
        }
        
        function getRelationCount(type) {
            if (!project.relations) return 0;
            return project.relations.filter(r => r.type === type).length;
        }
        
        function editRelation(relId) {
            const relation = project.relations.find(r => r.id === relId);
            if (!relation) return;
            
            // Pour l'instant, juste permettre de changer la description
            const newDesc = prompt('Modifier la description:', relation.description || '');
            if (newDesc !== null) {
                relation.description = newDesc;
                saveProject();
                renderRelationsView();
                showNotification('✏️ Relation modifiée');
            }
        }
        
        function deleteRelation(relId) {
            if (confirm('Supprimer cette relation ?')) {
                project.relations = project.relations.filter(r => r.id !== relId);
                saveProject();
                renderRelationsView();
                showNotification('🗑️ Relation supprimée');
            }
        }
        
        function exportRelations() {
            alert('Export graphique des relations à venir');
        }
        
        // ============================================
        // MAP FUNCTIONS
        // ============================================
        
        function renderMapView() {
            const editorView = document.getElementById('editorView');
            if (!editorView) {
                console.error('editorView not found');
                return;
            }
            
            // S'assurer que mapLocations et mapImage existent
            if (!project.mapLocations) project.mapLocations = [];
            if (!project.mapImage) project.mapImage = null;
            
            let mapContent = '';
            if (project.mapImage) {
                mapContent = `
                    <div style="position: relative; display: inline-block; max-width: 100%;">
                        <img src="${project.mapImage}" 
                             id="worldMapImage"
                             style="max-width: 100%; height: auto; display: block; cursor: crosshair; border: 2px solid var(--border-color); border-radius: 4px;" 
                             alt="Carte du monde"
                             onclick="handleMapClick(event)">
                        ${project.mapLocations.map((loc, i) => `
                            <div class="map-location" 
                                 style="position: absolute; left: ${loc.x}%; top: ${loc.y}%; 
                                        width: 20px; height: 20px; 
                                        background: var(--accent-red); 
                                        border: 2px solid white;
                                        border-radius: 50%; 
                                        transform: translate(-50%, -50%);
                                        cursor: pointer;
                                        box-shadow: 0 2px 8px rgba(0,0,0,0.3);
                                        z-index: 10;"
                                 title="${loc.name}"
                                 onclick="event.stopPropagation(); editMapLocation(${i})">
                                <div style="position: absolute; top: -30px; left: 50%; transform: translateX(-50%);
                                           background: var(--bg-accent); color: white; padding: 0.25rem 0.5rem;
                                           border-radius: 4px; white-space: nowrap; font-size: 0.75rem;
                                           pointer-events: none; opacity: 0; transition: opacity 0.2s;"
                                     class="map-location-label">${loc.name}</div>
                            </div>
                        `).join('')}
                    </div>
                    <style>
                        .map-location:hover .map-location-label {
                            opacity: 1 !important;
                        }
                    </style>
                `;
            } else {
                mapContent = `
                    <div style="padding: 4rem; text-align: center; background: var(--bg-secondary); border-radius: 8px; border: 2px dashed var(--border-color);">
                        <div style="font-size: 4rem; margin-bottom: 1rem;">🗺️</div>
                        <div style="font-size: 1.2rem; font-weight: 600; margin-bottom: 0.5rem;">Aucune carte chargée</div>
                        <div style="color: var(--text-muted); margin-bottom: 1.5rem;">Cliquez sur "Charger carte" pour ajouter une image</div>
                        <button class="btn btn-primary" onclick="uploadMapImage()">📤 Charger une carte</button>
                    </div>
                `;
            }
            
            editorView.innerHTML = `
                <div style="height: 100%; overflow-y: auto; padding: 2rem 3rem;">
                    <h2 style="margin-bottom: 2rem; color: var(--accent-gold);">🗺️ Carte Géographique</h2>
                    
                    <div style="margin-bottom: 2rem; display: flex; gap: 0.5rem; flex-wrap: wrap;">
                        <button class="btn btn-primary" onclick="uploadMapImage()">🖼️ Charger carte</button>
                        <button class="btn" onclick="addMapLocation()" ${!project.mapImage ? 'disabled' : ''}>📍 Ajouter lieu</button>
                        <button class="btn btn-small" onclick="clearMap()" ${!project.mapImage ? 'disabled' : ''}>🗑️ Effacer carte</button>
                        <button class="btn btn-small" onclick="exportMapData()">💾 Exporter données</button>
                    </div>
                    
                    <div style="background: var(--bg-secondary); padding: 2rem; border-radius: 8px; text-align: center;">
                        ${mapContent}
                    </div>
                    
                    ${project.mapLocations.length > 0 ? `
                        <div style="margin-top: 2rem; background: var(--bg-secondary); padding: 1.5rem; border-radius: 8px;">
                            <h3 style="margin-bottom: 1rem; color: var(--text-primary);">📍 Lieux marqués (${project.mapLocations.length})</h3>
                            <div style="display: grid; gap: 0.5rem;">
                                ${project.mapLocations.map((loc, i) => `
                                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.75rem; background: var(--bg-primary); border-radius: 4px;">
                                        <span style="font-weight: 500;">${loc.name}</span>
                                        <div style="display: flex; gap: 0.5rem;">
                                            <button class="btn btn-small" onclick="editMapLocation(${i})">✏️</button>
                                            <button class="btn btn-small" onclick="deleteMapLocation(${i})">🗑️</button>
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    ` : ''}
                    
                    <div style="margin-top: 2rem; padding: 1.5rem; background: var(--bg-secondary); border-radius: 8px; border-left: 4px solid var(--accent-gold);">
                        <p style="font-size: 0.95rem; color: var(--text-secondary); line-height: 1.6;">
                            💡 <strong>Utilisation:</strong><br>
                            1. Chargez une image de carte (dessinée à la main, générée par IA, etc.)<br>
                            2. Cliquez directement sur la carte pour placer un marqueur<br>
                            3. Cliquez sur un marqueur existant pour le modifier ou le supprimer
                        </p>
                    </div>
                </div>
            `;
        }
        
        function handleMapClick(event) {
            // S'assurer que mapLocations existe
            if (!project.mapLocations) project.mapLocations = [];
            
            const img = event.target;
            const rect = img.getBoundingClientRect();
            const x = ((event.clientX - rect.left) / rect.width) * 100;
            const y = ((event.clientY - rect.top) / rect.height) * 100;
            
            const name = prompt('Nom du lieu:');
            if (name) {
                project.mapLocations.push({
                    name: name,
                    x: Math.max(0, Math.min(100, x)),
                    y: Math.max(0, Math.min(100, y)),
                    description: ''
                });
                saveProject();
                renderMapView();
                showNotification(`📍 Lieu "${name}" ajouté`);
            }
        }
        
        function uploadMapImage() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        project.mapImage = event.target.result;
                        saveProject();
                        renderMapView();
                    };
                    reader.readAsDataURL(file);
                }
            };
            input.click();
        }
        
        function addMapLocation() {
            if (!project.mapImage) {
                alert('Veuillez d\'abord charger une carte');
                return;
            }
            // S'assurer que mapLocations existe
            if (!project.mapLocations) project.mapLocations = [];
            
            const name = prompt('Nom du lieu:');
            if (name) {
                project.mapLocations.push({
                    name: name,
                    x: 50 + Math.random() * 40,
                    y: 30 + Math.random() * 40,
                    description: ''
                });
                saveProject();
                renderMapView();
            }
        }
        
        function editMapLocation(index) {
            const loc = project.mapLocations[index];
            const newName = prompt('Modifier le nom:', loc.name);
            if (newName) {
                loc.name = newName;
                saveProject();
                renderMapView();
                showNotification(`✏️ Lieu modifié: ${newName}`);
            }
        }
        
        function deleteMapLocation(index) {
            const loc = project.mapLocations[index];
            if (confirm(`Supprimer le lieu "${loc.name}" ?`)) {
                project.mapLocations.splice(index, 1);
                saveProject();
                renderMapView();
                showNotification(`🗑️ Lieu supprimé: ${loc.name}`);
            }
        }
        
        function clearMap() {
            if (confirm('Effacer la carte et tous les lieux ?')) {
                project.mapImage = null;
                project.mapLocations = [];
                saveProject();
                renderMapView();
                showNotification('🗑️ Carte effacée');
            }
        }
        
        function exportMapData() {
            const data = {
                image: project.mapImage ? 'Image présente' : 'Pas d\'image',
                locations: project.mapLocations
            };
            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `carte_${project.title.replace(/[^a-z0-9]/gi, '_')}.json`;
            a.click();
            showNotification('💾 Données de la carte exportées');
        }
        
        // ============================================
        // TIMELINE VIZ FUNCTIONS
        // ============================================
        
        function renderTimelineVizList() {
            const container = document.getElementById('timelineVizList');
            if (!container) {
                console.error('timelineVizList container not found');
                return;
            }
            
            // S'assurer que metroTimeline et characterColors existent
            if (!project.metroTimeline) {
                project.metroTimeline = [];
            }
            if (!project.characterColors) {
                project.characterColors = {};
            }
            
            // Assigner des couleurs par défaut aux personnages qui n'en ont pas
            const defaultColors = ['#E53935', '#1E88E5', '#43A047', '#FB8C00', '#8E24AA', '#00ACC1', '#FFB300', '#D81B60', '#5E35B1', '#00897B'];
            project.characters.forEach((char, i) => {
                if (!project.characterColors[char.id]) {
                    project.characterColors[char.id] = defaultColors[i % defaultColors.length];
                }
            });
            
            // Compter les événements
            const eventCount = project.metroTimeline.length;
            const charCount = project.characters.length;
            
            // Sidebar avec personnages et liste d'événements
            container.innerHTML = `
                <div style="padding: 1rem;">
                    <h3 style="margin-bottom: 1rem; display: flex; align-items: center; gap: 0.5rem;">
                        <i data-lucide="train-track" style="width: 20px; height: 20px;"></i>
                        Timeline Métro
                    </h3>
                    <div style="font-size: 0.85rem; color: var(--text-secondary); line-height: 1.6;">
                        <div style="margin-bottom: 0.5rem;">📅 ${eventCount} événement(s)</div>
                        <div style="margin-bottom: 0.5rem;">👥 ${charCount} personnage(s)</div>
                        <div style="margin-top: 1rem;">
                            <button class="btn btn-primary" onclick="openMetroEventModal()" style="width: 100%;">
                                + Nouvel événement
                            </button>
                        </div>
                    </div>
                    ${eventCount > 0 ? `
                        <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--border-color);">
                            <div style="font-size: 0.85rem; font-weight: 600; margin-bottom: 0.5rem;">
                                <span>Événements:</span>
                            </div>
                            <div id="metroEventsList" class="metro-events-sortable">
                                ${project.metroTimeline.sort((a,b) => (a.order || 0) - (b.order || 0)).map((event, i, arr) => `
                                    <div class="metro-event-item" data-event-id="${event.id}">
                                        <div class="metro-event-reorder-btns">
                                            <button class="metro-reorder-btn" onclick="moveMetroEvent(${event.id}, -1)" ${i === 0 ? 'disabled' : ''} title="Monter">▲</button>
                                            <button class="metro-reorder-btn" onclick="moveMetroEvent(${event.id}, 1)" ${i === arr.length - 1 ? 'disabled' : ''} title="Descendre">▼</button>
                                        </div>
                                        <div class="metro-event-item-content" onclick="openMetroEventModal(${event.id})">
                                            <div style="display: flex; align-items: center; gap: 0.5rem;">
                                                <div style="font-weight: 600; flex: 1;">${event.title}</div>
                                                ${event.sceneId ? `<i data-lucide="file-text" style="width: 14px; height: 14px; color: var(--accent-blue); cursor: pointer;" onclick="event.stopPropagation(); openMetroLinkedScene(${event.sceneId})" title="Scène liée"></i>` : ''}
                                            </div>
                                            <div style="color: var(--text-muted); font-size: 0.75rem;">${event.date || 'Sans date'}</div>
                                            <div style="display: flex; gap: 2px; margin-top: 4px;">
                                                ${(event.characters || []).map(charId => {
                                                    const char = project.characters.find(c => c.id === charId);
                                                    return char ? `<span style="width: 12px; height: 12px; border-radius: 50%; background: ${project.characterColors[charId] || '#999'};" title="${char.name}"></span>` : '';
                                                }).join('')}
                                            </div>
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    ` : ''}
                </div>
            `;
            
            // Rafraîchir les icônes Lucide pour la sidebar
            if (eventCount > 0) {
                if (typeof lucide !== 'undefined') lucide.createIcons();
            }
        }
        
        function renderTimelineVizView() {
            // Render sidebar first
            renderTimelineVizList();
            
            // Render main view
            const editorView = document.getElementById('editorView');
            if (!editorView) {
                console.error('editorView not found for metro timeline');
                return;
            }
            
            const charCount = project.characters?.length || 0;
            
            if (charCount === 0) {
                editorView.innerHTML = `
                    <div class="metro-empty-state">
                        <i data-lucide="users" style="width: 64px; height: 64px; opacity: 0.3;"></i>
                        <h3 style="margin: 1rem 0 0.5rem;">Aucun personnage</h3>
                        <p style="margin-bottom: 1.5rem;">Créez d'abord des personnages dans l'onglet "Personnages" pour pouvoir les lier aux événements de votre timeline.</p>
                        <button class="btn btn-primary" onclick="switchView('characters')">Créer des personnages</button>
                    </div>
                `;
                lucide.createIcons();
                return;
            }
            
            editorView.innerHTML = `
                <div style="padding: 2rem;">
                    <div class="metro-toolbar">
                        <button class="btn btn-primary" onclick="openMetroEventModal()">
                            <i data-lucide="plus" style="width: 16px; height: 16px;"></i>
                            Nouvel événement
                        </button>
                        <button class="btn" onclick="sortMetroByDate()">
                            <i data-lucide="calendar" style="width: 16px; height: 16px;"></i>
                            Trier par date
                        </button>
                        <button class="btn" onclick="exportMetroTimelineCSV()">
                            <i data-lucide="download" style="width: 16px; height: 16px;"></i>
                            Exporter CSV
                        </button>
                        <button class="btn" onclick="clearMetroTimeline()" style="margin-left: auto;">
                            <i data-lucide="trash-2" style="width: 16px; height: 16px;"></i>
                            Tout effacer
                        </button>
                    </div>
                    
                    <div class="metro-timeline-container" id="metroTimelineContainer">
                        ${renderMetroSVG()}
                    </div>
                    
                    <div class="metro-legend">
                        ${project.characters.map(char => `
                            <div class="metro-legend-item" onclick="openMetroColorPicker(${char.id})" style="cursor: pointer;" title="Cliquer pour changer la couleur">
                                <div class="metro-legend-line" style="background: ${project.characterColors[char.id] || '#999'};"></div>
                                <span>${char.name}</span>
                            </div>
                        `).join('')}
                    </div>
                    
                    <div style="margin-top: 1rem; padding: 1rem; background: var(--bg-secondary); border-radius: 4px;">
                        <p style="font-size: 0.9rem; color: var(--text-secondary);">
                            💡 <strong>Utilisation:</strong> Cliquez sur les cercles pour éditer les événements. Les petites icônes bleues 📄 permettent d'ouvrir directement la scène liée. Cliquez sur les couleurs dans la légende pour les personnaliser. Les lignes se rejoignent quand des personnages partagent un événement.
                        </p>
                    </div>
                </div>
            `;
            
            lucide.createIcons();
        }
        
        function renderMetroSVG() {
            const events = (project.metroTimeline || []).sort((a, b) => (a.order || 0) - (b.order || 0));
            const characters = project.characters || [];
            
            if (events.length === 0) {
                return `
                    <div class="metro-empty-state">
                        <i data-lucide="train-track" style="width: 64px; height: 64px; opacity: 0.3;"></i>
                        <h3 style="margin: 1rem 0 0.5rem;">Aucun événement</h3>
                        <p style="margin-bottom: 1.5rem;">Créez votre premier événement pour commencer à visualiser les interactions entre personnages.</p>
                        <button class="btn btn-primary" onclick="openMetroEventModal()">+ Créer un événement</button>
                    </div>
                `;
            }
            
            // Calculer les dimensions
            const rowHeight = 60;
            const eventWidth = 180;
            const leftMargin = 180;
            const topMargin = 40;
            const nodeRadius = 10;
            
            const svgWidth = leftMargin + (events.length * eventWidth) + 100;
            const svgHeight = Math.max(200, topMargin + (characters.length * rowHeight) + 60);
            
            // Générer les lignes horizontales et les paths courbes
            let pathsHTML = '';
            let nodesHTML = '';
            let labelsHTML = '';
            let characterLabelsHTML = '';
            
            // Pour chaque personnage, dessiner sa ligne
            characters.forEach((char, charIndex) => {
                const y = topMargin + (charIndex * rowHeight) + (rowHeight / 2);
                const color = project.characterColors[char.id] || '#999';
                
                // Label du personnage à gauche
                characterLabelsHTML += `
                    <g class="metro-char-label" onclick="openMetroColorPicker(${char.id})" style="cursor: pointer;">
                        <rect x="5" y="${y - 15}" width="160" height="30" fill="transparent"/>
                        <circle cx="25" cy="${y}" r="10" fill="${color}" stroke="white" stroke-width="2"/>
                        <text x="42" y="${y + 5}" font-size="13" fill="var(--text-primary)" font-weight="500">${char.name.substring(0, 18)}${char.name.length > 18 ? '...' : ''}</text>
                    </g>
                `;
                
                // Trouver les événements où ce personnage participe
                const charEvents = events.filter(e => (e.characters || []).includes(char.id));
                
                if (charEvents.length === 0) {
                    // Ligne en pointillés si pas d'événements
                    pathsHTML += `<line x1="${leftMargin}" y1="${y}" x2="${svgWidth - 50}" y2="${y}" stroke="${color}" stroke-width="3" stroke-dasharray="5,5" opacity="0.3"/>`;
                } else {
                    // Dessiner le chemin entre les événements
                    let pathD = '';
                    let lastX = leftMargin;
                    
                    charEvents.forEach((event, eventIdx) => {
                        const eventGlobalIdx = events.indexOf(event);
                        const eventX = leftMargin + (eventGlobalIdx * eventWidth) + (eventWidth / 2);
                        
                        // Calculer Y pour cet événement (converger vers le centre si plusieurs personnages)
                        const eventChars = event.characters || [];
                        const charPosInEvent = eventChars.indexOf(char.id);
                        const totalCharsInEvent = eventChars.length;
                        
                        // Y central de l'événement (moyenne des Y de tous les personnages présents)
                        const avgY = eventChars.reduce((sum, cId) => {
                            const cIdx = characters.findIndex(c => c.id === cId);
                            return sum + (cIdx >= 0 ? topMargin + (cIdx * rowHeight) + (rowHeight / 2) : 0);
                        }, 0) / totalCharsInEvent;
                        
                        const eventY = avgY;
                        
                        if (eventIdx === 0) {
                            // Premier segment: de la ligne de base vers le premier événement
                            pathD = `M ${lastX} ${y}`;
                            
                            // Courbe vers le point de convergence
                            const midX = (lastX + eventX) / 2;
                            pathD += ` C ${midX} ${y}, ${midX} ${eventY}, ${eventX} ${eventY}`;
                        } else {
                            // Segments intermédiaires
                            const prevEvent = charEvents[eventIdx - 1];
                            const prevEventIdx = events.indexOf(prevEvent);
                            const prevX = leftMargin + (prevEventIdx * eventWidth) + (eventWidth / 2);
                            
                            // Y du précédent événement
                            const prevEventChars = prevEvent.characters || [];
                            const prevAvgY = prevEventChars.reduce((sum, cId) => {
                                const cIdx = characters.findIndex(c => c.id === cId);
                                return sum + (cIdx >= 0 ? topMargin + (cIdx * rowHeight) + (rowHeight / 2) : 0);
                            }, 0) / prevEventChars.length;
                            
                            // Courbe du précédent vers l'actuel
                            const midX = (prevX + eventX) / 2;
                            pathD += ` C ${midX} ${prevAvgY}, ${midX} ${eventY}, ${eventX} ${eventY}`;
                        }
                        
                        lastX = eventX;
                    });
                    
                    // Prolonger la ligne après le dernier événement
                    const lastEvent = charEvents[charEvents.length - 1];
                    const lastEventIdx = events.indexOf(lastEvent);
                    const lastEventX = leftMargin + (lastEventIdx * eventWidth) + (eventWidth / 2);
                    const lastEventChars = lastEvent.characters || [];
                    const lastAvgY = lastEventChars.reduce((sum, cId) => {
                        const cIdx = characters.findIndex(c => c.id === cId);
                        return sum + (cIdx >= 0 ? topMargin + (cIdx * rowHeight) + (rowHeight / 2) : 0);
                    }, 0) / lastEventChars.length;
                    
                    const endX = svgWidth - 50;
                    const midX = (lastEventX + endX) / 2;
                    pathD += ` C ${midX} ${lastAvgY}, ${midX} ${y}, ${endX} ${y}`;
                    
                    pathsHTML += `<path d="${pathD}" class="metro-line" stroke="${color}" fill="none"/>`;
                }
            });
            
            // Dessiner les nœuds d'événements (par-dessus les lignes)
            events.forEach((event, eventIdx) => {
                const eventX = leftMargin + (eventIdx * eventWidth) + (eventWidth / 2);
                const eventChars = event.characters || [];
                
                if (eventChars.length > 0) {
                    // Calculer le Y moyen
                    const avgY = eventChars.reduce((sum, cId) => {
                        const cIdx = characters.findIndex(c => c.id === cId);
                        return sum + (cIdx >= 0 ? topMargin + (cIdx * rowHeight) + (rowHeight / 2) : 0);
                    }, 0) / eventChars.length;
                    
                    // Nœud principal
                    nodesHTML += `
                        <g class="metro-event-node" onclick="openMetroEventModal(${event.id})">
                            <circle cx="${eventX}" cy="${avgY}" r="${nodeRadius + 2}" fill="white" stroke="var(--border-color)" stroke-width="2"/>
                            <circle cx="${eventX}" cy="${avgY}" r="${nodeRadius - 2}" fill="var(--text-primary)"/>
                        </g>
                        ${event.sceneId ? `
                            <g onclick="event.stopPropagation(); openMetroLinkedScene(${event.sceneId})" style="cursor: pointer;" title="Ouvrir la scène">
                                <circle cx="${eventX + nodeRadius + 8}" cy="${avgY - nodeRadius - 8}" r="8" fill="var(--accent-blue)" stroke="white" stroke-width="1.5"/>
                                <text x="${eventX + nodeRadius + 8}" y="${avgY - nodeRadius - 4}" text-anchor="middle" font-size="9" fill="white" font-weight="bold">📄</text>
                            </g>
                        ` : ''}
                    `;
                    
                    // Label de l'événement
                    const labelY = avgY < svgHeight / 2 ? avgY - 25 : avgY + 30;
                    labelsHTML += `
                        <g class="metro-event-label-group" onclick="openMetroEventModal(${event.id})" style="cursor: pointer;">
                            <text x="${eventX}" y="${labelY}" text-anchor="middle" class="metro-event-label" font-weight="600">${event.title.substring(0, 20)}${event.title.length > 20 ? '...' : ''}</text>
                            <text x="${eventX}" y="${labelY + 14}" text-anchor="middle" class="metro-event-label" font-size="10" fill="var(--text-muted)">${event.date || ''}</text>
                        </g>
                    `;
                } else {
                    // Événement sans personnages - afficher en haut
                    const floatingY = topMargin - 10;
                    nodesHTML += `
                        <g class="metro-event-node" onclick="openMetroEventModal(${event.id})">
                            <circle cx="${eventX}" cy="${floatingY}" r="${nodeRadius}" fill="var(--text-muted)" stroke="white" stroke-width="2"/>
                        </g>
                    `;
                    labelsHTML += `
                        <g onclick="openMetroEventModal(${event.id})" style="cursor: pointer;">
                            <text x="${eventX}" y="${floatingY - 15}" text-anchor="middle" class="metro-event-label" fill="var(--text-muted)">${event.title.substring(0, 15)}...</text>
                        </g>
                    `;
                }
            });
            
            return `
                <svg width="${svgWidth}" height="${svgHeight}" class="metro-svg-container">
                    <!-- Fond -->
                    <rect width="100%" height="100%" fill="var(--bg-primary)"/>
                    
                    <!-- Lignes de grille légères -->
                    ${characters.map((_, i) => {
                        const y = topMargin + (i * rowHeight) + (rowHeight / 2);
                        return `<line x1="${leftMargin}" y1="${y}" x2="${svgWidth}" y2="${y}" stroke="var(--border-color)" stroke-width="1" opacity="0.3" stroke-dasharray="2,4"/>`;
                    }).join('')}
                    
                    <!-- Labels personnages -->
                    ${characterLabelsHTML}
                    
                    <!-- Chemins des lignes de métro -->
                    ${pathsHTML}
                    
                    <!-- Nœuds des événements -->
                    ${nodesHTML}
                    
                    <!-- Labels des événements -->
                    ${labelsHTML}
                </svg>
            `;
        }
        
        function openMetroEventModal(eventId = null) {
            const modal = document.getElementById('metroEventModal');
            const titleEl = document.getElementById('metroEventModalTitle');
            const deleteBtn = document.getElementById('metroDeleteBtn');
            
            // Reset form
            document.getElementById('metroEventId').value = '';
            document.getElementById('metroEventTitle').value = '';
            document.getElementById('metroEventDate').value = '';
            document.getElementById('metroEventOrder').value = '';
            document.getElementById('metroEventDesc').value = '';
            document.getElementById('metroEventScene').value = '';
            
            // Populate scene selector
            const sceneSelect = document.getElementById('metroEventScene');
            let sceneOptions = '<option value="">Aucune scène</option>';
            project.acts.forEach(act => {
                act.chapters.forEach(chapter => {
                    chapter.scenes.forEach(scene => {
                        const scenePath = `${act.title} > ${chapter.title} > ${scene.title}`;
                        sceneOptions += `<option value="${scene.id}">${scenePath}</option>`;
                    });
                });
            });
            sceneSelect.innerHTML = sceneOptions;
            
            // Populate position selector
            const positionSelect = document.getElementById('metroEventPosition');
            const sortedEvents = (project.metroTimeline || []).sort((a, b) => (a.order || 0) - (b.order || 0));
            
            let positionOptions = '<option value="0">🔼 Au début de la timeline</option>';
            sortedEvents.forEach((evt, idx) => {
                if (!eventId || evt.id !== eventId) {
                    positionOptions += `<option value="${evt.order || idx + 1}">↳ Après: ${evt.title}${evt.date ? ' (' + evt.date + ')' : ''}</option>`;
                }
            });
            positionSelect.innerHTML = positionOptions;
            
            // Populate character selector
            const selectorDiv = document.getElementById('metroCharactersSelector');
            selectorDiv.innerHTML = project.characters.map(char => `
                <label class="metro-char-option" data-char-id="${char.id}">
                    <input type="checkbox" value="${char.id}" onchange="updateMetroLinkedChars()">
                    <span class="metro-char-color-dot" style="background: ${project.characterColors[char.id] || '#999'};"></span>
                    <span>${char.name}</span>
                </label>
            `).join('');
            
            if (eventId) {
                // Edit mode
                const event = project.metroTimeline.find(e => e.id === eventId);
                if (!event) return;
                
                titleEl.textContent = 'Modifier l\'événement';
                deleteBtn.style.display = '';
                
                document.getElementById('metroEventId').value = event.id;
                document.getElementById('metroEventTitle').value = event.title || '';
                document.getElementById('metroEventDate').value = event.date || '';
                document.getElementById('metroEventOrder').value = event.order !== undefined ? event.order : '';
                document.getElementById('metroEventDesc').value = event.description || '';
                document.getElementById('metroEventScene').value = event.sceneId || '';
                
                // Select current position (the event just before this one)
                const currentIdx = sortedEvents.findIndex(e => e.id === eventId);
                if (currentIdx > 0) {
                    const prevEvent = sortedEvents[currentIdx - 1];
                    positionSelect.value = prevEvent.order || currentIdx;
                } else {
                    positionSelect.value = '0';
                }
                
                // Check characters
                (event.characters || []).forEach(charId => {
                    const checkbox = selectorDiv.querySelector(`input[value="${charId}"]`);
                    if (checkbox) {
                        checkbox.checked = true;
                        checkbox.closest('.metro-char-option').classList.add('selected');
                    }
                });
            } else {
                // Create mode
                titleEl.textContent = 'Nouvel événement';
                deleteBtn.style.display = 'none';
                
                // Default position = at the end
                if (sortedEvents.length > 0) {
                    const lastEvent = sortedEvents[sortedEvents.length - 1];
                    positionSelect.value = lastEvent.order || sortedEvents.length;
                } else {
                    positionSelect.value = '0';
                }
                document.getElementById('metroEventOrder').value = sortedEvents.length + 1;
            }
            
            updateMetroLinkedChars();
            modal.classList.add('active');
            document.getElementById('metroEventTitle').focus();
        }
        
        function updateMetroLinkedChars() {
            const selectorDiv = document.getElementById('metroCharactersSelector');
            const linkedDiv = document.getElementById('metroLinkedChars');
            
            const checked = Array.from(selectorDiv.querySelectorAll('input:checked'));
            
            // Update visual selection
            selectorDiv.querySelectorAll('.metro-char-option').forEach(opt => {
                const checkbox = opt.querySelector('input');
                opt.classList.toggle('selected', checkbox.checked);
            });
            
            // Update linked tags
            linkedDiv.innerHTML = checked.map(cb => {
                const charId = parseInt(cb.value);
                const char = project.characters.find(c => c.id === charId);
                if (!char) return '';
                const color = project.characterColors[charId] || '#999';
                return `
                    <span class="metro-linked-char-tag" style="background: ${color};">
                        ${char.name}
                        <span class="remove-char" onclick="removeMetroCharFromEvent(${charId})">×</span>
                    </span>
                `;
            }).join('');
        }
        
        function removeMetroCharFromEvent(charId) {
            const selectorDiv = document.getElementById('metroCharactersSelector');
            const checkbox = selectorDiv.querySelector(`input[value="${charId}"]`);
            if (checkbox) {
                checkbox.checked = false;
                updateMetroLinkedChars();
            }
        }
        
        function saveMetroEvent() {
            const eventId = document.getElementById('metroEventId').value;
            const title = document.getElementById('metroEventTitle').value.trim();
            const date = document.getElementById('metroEventDate').value.trim();
            const positionAfter = parseFloat(document.getElementById('metroEventPosition').value) || 0;
            const description = document.getElementById('metroEventDesc').value.trim();
            const sceneIdValue = document.getElementById('metroEventScene').value;
            const sceneId = sceneIdValue ? parseInt(sceneIdValue) : null;
            
            if (!title) {
                alert('Le titre est obligatoire');
                return;
            }
            
            // Get selected characters
            const selectorDiv = document.getElementById('metroCharactersSelector');
            const characters = Array.from(selectorDiv.querySelectorAll('input:checked')).map(cb => parseInt(cb.value));
            
            if (!project.metroTimeline) {
                project.metroTimeline = [];
            }
            
            // Calculate new order based on position selection
            // positionAfter = 0 means "at the beginning"
            // positionAfter = N means "after the event with order N"
            let newOrder;
            if (positionAfter === 0) {
                newOrder = 0.5; // Will be normalized to 1 after reordering
            } else {
                newOrder = positionAfter + 0.5; // Insert after the selected event
            }
            
            if (eventId) {
                // Update existing
                const event = project.metroTimeline.find(e => e.id === parseInt(eventId));
                if (event) {
                    event.title = title;
                    event.date = date;
                    event.order = newOrder;
                    event.description = description;
                    event.characters = characters;
                    event.sceneId = sceneId;
                }
                showNotification('✓ Événement mis à jour');
            } else {
                // Create new
                project.metroTimeline.push({
                    id: Date.now(),
                    title,
                    date,
                    order: newOrder,
                    description,
                    characters,
                    sceneId: sceneId
                });
                showNotification('✓ Événement créé');
            }
            
            // Reorder all events to have clean sequential numbers
            normalizeMetroEventOrder();
            
            saveProject();
            closeModal('metroEventModal');
            
            // Check if we're in split-view mode
            if (splitViewActive && (splitViewState.left.view === 'timelineviz' || splitViewState.right.view === 'timelineviz')) {
                // Refresh the split panel(s) showing timeline
                if (splitViewState.left.view === 'timelineviz') {
                    renderSplitPanelViewContent('left');
                }
                if (splitViewState.right.view === 'timelineviz') {
                    renderSplitPanelViewContent('right');
                }
                // Also refresh the editor panel if it's showing a scene (to update the timeline badge)
                if (splitViewState.left.view === 'editor' && splitViewState.left.sceneId) {
                    renderSplitPanelViewContent('left');
                }
                if (splitViewState.right.view === 'editor' && splitViewState.right.sceneId) {
                    renderSplitPanelViewContent('right');
                }
            } else if (currentView === 'timelineviz') {
                // Normal full-screen timeline view
                renderTimelineVizView();
            } else if (currentSceneId && currentView === 'editor') {
                // Normal full-screen editor view - refresh to show the new link
                const act = project.acts.find(a => a.id === currentActId);
                const chapter = act?.chapters.find(c => c.id === currentChapterId);
                const scene = chapter?.scenes.find(s => s.id === currentSceneId);
                if (act && chapter && scene) {
                    renderEditor(act, chapter, scene);
                }
            }
        }
        
        function normalizeMetroEventOrder() {
            // Sort by current order
            project.metroTimeline.sort((a, b) => (a.order || 0) - (b.order || 0));
            
            // Reassign clean sequential numbers (1, 2, 3, ...)
            project.metroTimeline.forEach((event, i) => {
                event.order = i + 1;
            });
        }
        
        function moveMetroEvent(eventId, direction) {
            // direction: -1 = monter, 1 = descendre
            const sortedEvents = project.metroTimeline.sort((a, b) => (a.order || 0) - (b.order || 0));
            const currentIndex = sortedEvents.findIndex(e => e.id === eventId);
            
            if (currentIndex === -1) return;
            
            const newIndex = currentIndex + direction;
            
            // Vérifier les limites
            if (newIndex < 0 || newIndex >= sortedEvents.length) return;
            
            // Échanger les positions
            const temp = sortedEvents[currentIndex];
            sortedEvents[currentIndex] = sortedEvents[newIndex];
            sortedEvents[newIndex] = temp;
            
            // Mettre à jour les ordres
            sortedEvents.forEach((event, i) => {
                event.order = i + 1;
            });
            
            project.metroTimeline = sortedEvents;
            
            saveProject();
            refreshTimelineView();
        }
        
        function deleteMetroEvent() {
            const eventId = document.getElementById('metroEventId').value;
            if (!eventId) return;
            
            if (!confirm('Supprimer cet événement ?')) return;
            
            project.metroTimeline = project.metroTimeline.filter(e => e.id !== parseInt(eventId));
            saveProject();
            closeModal('metroEventModal');
            
            // Check if we're in split-view mode
            if (splitViewActive && (splitViewState.left.view === 'timelineviz' || splitViewState.right.view === 'timelineviz')) {
                // Refresh the split panel(s) showing timeline
                if (splitViewState.left.view === 'timelineviz') {
                    renderSplitPanelViewContent('left');
                }
                if (splitViewState.right.view === 'timelineviz') {
                    renderSplitPanelViewContent('right');
                }
            } else if (currentView === 'timelineviz') {
                // Normal full-screen timeline view
                renderTimelineVizView();
            }
            
            showNotification('✓ Événement supprimé');
        }
        
        function openMetroLinkedScene(sceneId) {
            // Find the scene
            let foundScene = null;
            let foundChapter = null;
            let foundAct = null;
            
            for (const act of project.acts) {
                for (const chapter of act.chapters) {
                    const scene = chapter.scenes.find(s => s.id === sceneId);
                    if (scene) {
                        foundScene = scene;
                        foundChapter = chapter;
                        foundAct = act;
                        break;
                    }
                }
                if (foundScene) break;
            }
            
            if (!foundScene) {
                showNotification('❌ Scène introuvable', 'error');
                return;
            }
            
            // Switch to editor view and open the scene
            switchView('editor');
            
            // Use the proper openScene function which handles everything
            setTimeout(() => {
                openScene(foundAct.id, foundChapter.id, foundScene.id);
                showNotification(`📄 Scène ouverte : ${foundScene.title}`);
            }, 100);
        }
        
        function openMetroEventFromScene(eventId) {
            // Store the event ID and show the choice modal
            document.getElementById('metroViewChoiceEventId').value = eventId;
            document.getElementById('metroViewChoiceModal').classList.add('active');
            
            // Refresh icons
            setTimeout(() => {
                if (typeof lucide !== 'undefined') {
                    lucide.createIcons();
                }
            }, 50);
        }
        
        function openMetroEventFullView() {
            const eventId = parseInt(document.getElementById('metroViewChoiceEventId').value);
            closeModal('metroViewChoiceModal');
            
            // Switch to timeline viz view properly
            currentView = 'timelineviz';
            
            // Update nav buttons
            document.querySelectorAll('.nav-btn').forEach(btn => btn.classList.remove('active'));
            const timelineBtn = Array.from(document.querySelectorAll('.nav-btn')).find(btn => 
                btn.textContent.includes('Timeline') || btn.onclick?.toString().includes('timelineviz')
            );
            if (timelineBtn) timelineBtn.classList.add('active');
            
            // Hide all sidebar lists
            const sidebarLists = [
                'chaptersList', 'charactersList', 'worldList', 'timelineList', 
                'notesList', 'codexList', 'statsList', 'versionsList', 'analysisList',
                'todosList', 'corkboardList', 'mindmapList', 'plotList', 
                'relationsList', 'mapList', 'timelineVizList'
            ];
            
            sidebarLists.forEach(listId => {
                const el = document.getElementById(listId);
                if (el) el.style.display = 'none';
            });
            
            // Show the timelineVizList sidebar
            const timelineVizList = document.getElementById('timelineVizList');
            if (timelineVizList) timelineVizList.style.display = 'block';
            
            // Render the timeline viz view completely
            renderTimelineVizView();
            
            // Wait for rendering to complete, then open the modal
            setTimeout(() => {
                // Ensure icons are rendered
                if (typeof lucide !== 'undefined') {
                    lucide.createIcons();
                }
                // Open the event modal
                setTimeout(() => {
                    openMetroEventModal(eventId);
                }, 100);
            }, 300);
        }
        
        function openMetroEventSplitView() {
            const eventId = parseInt(document.getElementById('metroViewChoiceEventId').value);
            closeModal('metroViewChoiceModal');
            
            // Enable split view if not already active
            if (!splitViewActive) {
                toggleSplitView();
            }
            
            // Set the right panel to show timeline viz
            splitViewState.right.view = 'timelineviz';
            splitActivePanel = 'right';
            
            // Update the header to show "Timeline" instead of "Vide"
            updateSplitPanelHeader('right');
            
            // Render the right panel with timeline
            renderSplitPanelViewContent('right');
            
            // Wait for rendering, then open the event modal
            setTimeout(() => {
                if (typeof lucide !== 'undefined') {
                    lucide.createIcons();
                }
                setTimeout(() => {
                    openMetroEventModal(eventId);
                }, 100);
            }, 300);
            
            saveSplitViewState();
        }
        
        function openMetroColorPicker(charId) {
            const char = project.characters.find(c => c.id === charId);
            if (!char) return;
            
            document.getElementById('metroColorCharId').value = charId;
            document.getElementById('metroColorCharName').textContent = char.name;
            
            const currentColor = project.characterColors[charId] || '#999';
            document.getElementById('metroCustomColor').value = currentColor;
            
            // Highlight current color
            document.querySelectorAll('.metro-color-option').forEach(opt => {
                opt.classList.toggle('selected', opt.dataset.color === currentColor);
            });
            
            document.getElementById('metroColorModal').classList.add('active');
        }
        
        function selectMetroColor(color) {
            document.getElementById('metroCustomColor').value = color;
            document.querySelectorAll('.metro-color-option').forEach(opt => {
                opt.classList.toggle('selected', opt.dataset.color === color);
            });
        }
        
        function applyMetroColor() {
            const charId = parseInt(document.getElementById('metroColorCharId').value);
            const color = document.getElementById('metroCustomColor').value;
            
            if (!project.characterColors) {
                project.characterColors = {};
            }
            
            project.characterColors[charId] = color;
            saveProject();
            closeModal('metroColorModal');
            refreshTimelineView();
            showNotification('✓ Couleur mise à jour');
        }
        
        // Helper function to refresh timeline view (works in both normal and split view)
        function refreshTimelineView() {
            if (splitViewActive) {
                // In split view, refresh the active panel
                if (splitActivePanel === 'left' && splitViewState.left.view === 'timelineviz') {
                    renderSplitPanelViewContent('left');
                } else if (splitActivePanel === 'right' && splitViewState.right.view === 'timelineviz') {
                    renderSplitPanelViewContent('right');
                } else {
                    // If neither panel is showing timeline, just render normally
                    renderTimelineVizView();
                }
            } else {
                // Normal view
                renderTimelineVizView();
            }
        }
        
        function sortMetroByDate() {
            if (!project.metroTimeline || project.metroTimeline.length === 0) {
                showNotification('Aucun événement à trier');
                return;
            }
            
            // Helper function to parse date in DD/MM/YYYY format
            function parseRealDate(dateStr) {
                if (!dateStr || !dateStr.trim()) return null;
                
                const trimmed = dateStr.trim();
                const parts = trimmed.split('/');
                
                if (parts.length < 2 || parts.length > 3) return null;
                
                const day = parseInt(parts[0], 10);
                const month = parseInt(parts[1], 10);
                let year = parts[2] ? parseInt(parts[2], 10) : null;
                
                if (isNaN(day) || isNaN(month)) return null;
                if (year === null) return null;
                
                // Handle 2-digit years (assume 1900-1999 for < 50, 2000-2099 for >= 50)
                if (year < 100) {
                    year = year < 50 ? 2000 + year : 1900 + year;
                }
                
                // Create date object (month is 0-indexed in JavaScript Date)
                const date = new Date(year, month - 1, day);
                
                // Validate the date
                if (isNaN(date.getTime())) return null;
                
                return date;
            }
            
            // Helper function to extract a numeric value from fictional dates
            // Handles: "An 2157", "Année 5", "Year 42", "2157", "-500" (BCE), etc.
            function extractYearNumber(dateStr) {
                if (!dateStr || !dateStr.trim()) return null;
                
                const trimmed = dateStr.trim();
                
                // Try to match patterns like "An 2157", "Année 5", "Year 42"
                const yearMatch = trimmed.match(/(?:an|année|year|yr)\s*[:\-]?\s*(-?\d+)/i);
                if (yearMatch) {
                    return parseInt(yearMatch[1], 10);
                }
                
                // Try to match pure numbers (with optional negative for BCE)
                const numberMatch = trimmed.match(/^(-?\d+)/);
                if (numberMatch) {
                    return parseInt(numberMatch[1], 10);
                }
                
                return null;
            }
            
            // Sort by date (events without valid dates go to the end)
            project.metroTimeline.sort((a, b) => {
                const dateStrA = (a.date || '').trim();
                const dateStrB = (b.date || '').trim();
                
                // Without date = at the end
                if (!dateStrA && !dateStrB) return 0;
                if (!dateStrA) return 1;
                if (!dateStrB) return -1;
                
                // Try to parse as real dates first (DD/MM/YYYY)
                const realDateA = parseRealDate(dateStrA);
                const realDateB = parseRealDate(dateStrB);
                
                if (realDateA && realDateB) {
                    return realDateA.getTime() - realDateB.getTime();
                }
                
                // If one is real date and other is not, real date comes first
                if (realDateA) return -1;
                if (realDateB) return 1;
                
                // Try to extract year numbers for fictional calendars
                const yearA = extractYearNumber(dateStrA);
                const yearB = extractYearNumber(dateStrB);
                
                if (yearA !== null && yearB !== null) {
                    return yearA - yearB;
                }
                
                // If one has a year number and other doesn't, number comes first
                if (yearA !== null) return -1;
                if (yearB !== null) return 1;
                
                // Fallback to alphabetical sorting
                return dateStrA.localeCompare(dateStrB);
            });
            
            // Reassign orders sequentially
            project.metroTimeline.forEach((event, i) => {
                event.order = i + 1;
            });
            
            saveProject();
            refreshTimelineView();
            showNotification('✓ Timeline triée par date');
        }
        
        function clearMetroTimeline() {
            if (!project.metroTimeline || project.metroTimeline.length === 0) {
                showNotification('La timeline est déjà vide');
                return;
            }
            
            if (confirm(`Effacer les ${project.metroTimeline.length} événement(s) de la timeline ?`)) {
                project.metroTimeline = [];
                saveProject();
                refreshTimelineView();
                showNotification('✓ Timeline effacée');
            }
        }
        
        function exportMetroTimelineCSV() {
            if (!project.metroTimeline || project.metroTimeline.length === 0) {
                alert('Aucun événement à exporter');
                return;
            }
            
            let csv = 'Ordre,Titre,Date,Description,Personnages\n';
            
            project.metroTimeline.sort((a, b) => (a.order || 0) - (b.order || 0)).forEach(event => {
                const charNames = (event.characters || []).map(cId => {
                    const char = project.characters.find(c => c.id === cId);
                    return char ? char.name : '';
                }).filter(n => n).join('; ');
                
                csv += `${event.order || ''},${escapeCSVField(event.title)},${escapeCSVField(event.date || '')},${escapeCSVField(event.description || '')},${escapeCSVField(charNames)}\n`;
            });
            
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${project.title}_metro_timeline.csv`;
            a.click();
            URL.revokeObjectURL(url);
            
            showNotification(`✓ ${project.metroTimeline.length} événement(s) exporté(s)`);
        }
        
        // Legacy functions for old timeline (keeping for backward compatibility)
        function addTimelineVizEvent() {
            openMetroEventModal();
        }
        
        function editTimelineVizEvent(id) {
            // Try to find in new metro timeline first
            if (project.metroTimeline && project.metroTimeline.find(e => e.id === id)) {
                openMetroEventModal(id);
                return;
            }
            // Fallback to old visual timeline
            const event = project.visualTimeline?.find(e => e.id === id);
            if (!event) return;
            
            const newTitle = prompt('Modifier le titre:', event.title);
            if (newTitle === null) return;
            
            if (newTitle.trim() !== '') {
                event.title = newTitle.trim();
                
                const newDate = prompt('Modifier la date:', event.date);
                if (newDate !== null) {
                    event.date = newDate.trim();
                }
                
                const newDesc = prompt('Modifier la description:', event.description);
                if (newDesc !== null) {
                    event.description = newDesc.trim();
                }
                
                saveProject();
                refreshTimelineView();
                showNotification('✓ Événement mis à jour');
            }
        }
        
        function sortTimelineByDate() {
            sortMetroTimeline();
        }
        
        function clearTimeline() {
            clearMetroTimeline();
        }
        
        function exportTimelineViz() {
            exportMetroTimelineCSV();
        }
        
        // ============================================
        // IMPORT/EXPORT CSV POUR TIMELINE (Legacy)
        // ============================================
        
        function importTimelineCSV() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.csv';
            
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        parseMetroTimelineCSV(event.target.result);
                    } catch (error) {
                        alert('Erreur lors de la lecture du fichier CSV:\n' + error.message);
                    }
                };
                reader.readAsText(file);
            };
            
            input.click();
        }
        
        function parseMetroTimelineCSV(csvContent) {
            const lines = csvContent.split('\n').filter(line => line.trim() !== '');
            
            if (lines.length === 0) {
                alert('Le fichier CSV est vide');
                return;
            }
            
            // Skip header if present
            const header = lines[0].toLowerCase();
            if (header.includes('titre') || header.includes('title') || header.includes('ordre') || header.includes('order')) {
                lines.shift();
            }
            
            if (lines.length === 0) {
                alert('Le fichier CSV ne contient aucun événement');
                return;
            }
            
            if (!confirm(`Importer ${lines.length} événement(s) ? Les événements existants seront conservés.`)) {
                return;
            }
            
            if (!project.metroTimeline) {
                project.metroTimeline = [];
            }
            
            let imported = 0;
            const maxOrder = Math.max(0, ...project.metroTimeline.map(e => e.order || 0));
            
            lines.forEach((line, idx) => {
                const parts = parseCSVLine(line);
                const title = parts[1]?.trim() || parts[0]?.trim() || '';
                
                if (title) {
                    project.metroTimeline.push({
                        id: Date.now() + idx,
                        order: maxOrder + idx + 1,
                        title: title,
                        date: parts[2]?.trim() || '',
                        description: parts[3]?.trim() || '',
                        characters: []
                    });
                    imported++;
                }
            });
            
            saveProject();
            refreshTimelineView();
            showNotification(`✓ ${imported} événement(s) importé(s)`);
        }
        
        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                
                if (char === '"') {
                    if (inQuotes && line[i + 1] === '"') {
                        current += '"';
                        i++;
                    } else {
                        inQuotes = !inQuotes;
                    }
                } else if (char === ',' && !inQuotes) {
                    result.push(current);
                    current = '';
                } else {
                    current += char;
                }
            }
            
            result.push(current);
            return result;
        }
        
        function exportTimelineCSV() {
            exportMetroTimelineCSV();
        }
        
        function escapeCSVField(field) {
            if (!field) return '""';
            
            if (field.includes(',') || field.includes('"') || field.includes('\n')) {
                field = field.replace(/"/g, '""');
                return `"${field}"`;
            }
            
            return field;
        }

        // ===================================
        // SYSTÈME DE GESTION DES THÈMES
        // ===================================
        
        // Utilitaire : convertir rgba/rgb/hex en hex
        function rgbaToHex(color) {
            if (!color) return '#000000';
            
            // Si c'est déjà un hex
            if (color.startsWith('#')) {
                return color.length === 7 ? color : color + 'FF';
            }
            
            // Si c'est rgba ou rgb
            const match = color.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
            if (match) {
                const r = parseInt(match[1]);
                const g = parseInt(match[2]);
                const b = parseInt(match[3]);
                return '#' + [r, g, b].map(x => {
                    const hex = x.toString(16);
                    return hex.length === 1 ? '0' + hex : hex;
                }).join('');
            }
            
            return '#000000';
        }
        
        const themeManager = {
            currentTheme: null,
            customThemes: [],
            
            defaultVariables: {
                '--bg-primary': '#faf9f6',
                '--bg-secondary': '#f5f3ed',
                '--bg-accent': '#2a2622',
                '--text-primary': '#2a2622',
                '--text-secondary': '#5a5550',
                '--text-muted': '#8a847d',
                '--border-color': '#d4cfc5',
                '--primary-color': '#d4af37',
                '--primary-hover': '#b8941f',
                '--accent-red': '#c44536',
                '--accent-gold': '#d4af37',
                '--highlight-yellow': 'rgba(255, 235, 59, 0.4)',
                '--highlight-green': 'rgba(76, 175, 80, 0.3)',
                '--highlight-blue': 'rgba(33, 150, 243, 0.3)',
                '--highlight-red': 'rgba(244, 67, 54, 0.3)',
                '--highlight-purple': 'rgba(156, 39, 176, 0.3)'
            },
            
            presetThemes: {
                'Classique': {
                    '--bg-primary': '#faf9f6',
                    '--bg-secondary': '#f5f3ed',
                    '--bg-accent': '#2a2622',
                    '--text-primary': '#2a2622',
                    '--text-secondary': '#5a5550',
                    '--text-muted': '#8a847d',
                    '--border-color': '#d4cfc5',
                    '--primary-color': '#d4af37',
                    '--primary-hover': '#b8941f',
                    '--accent-red': '#c44536',
                    '--accent-gold': '#d4af37',
                    '--highlight-yellow': 'rgba(255, 235, 59, 0.4)',
                    '--highlight-green': 'rgba(76, 175, 80, 0.3)',
                    '--highlight-blue': 'rgba(33, 150, 243, 0.3)',
                    '--highlight-red': 'rgba(244, 67, 54, 0.3)',
                    '--highlight-purple': 'rgba(156, 39, 176, 0.3)'
                },
                'Sombre': {
                    '--bg-primary': '#1a1a1a',
                    '--bg-secondary': '#252525',
                    '--bg-accent': '#f5f3ed',
                    '--text-primary': '#e8e6e3',
                    '--text-secondary': '#b8b6b3',
                    '--text-muted': '#888683',
                    '--border-color': '#3a3a3a',
                    '--primary-color': '#ffd700',
                    '--primary-hover': '#ffed4e',
                    '--accent-red': '#ff6b5a',
                    '--accent-gold': '#ffd700',
                    '--highlight-yellow': 'rgba(255, 235, 59, 0.3)',
                    '--highlight-green': 'rgba(76, 175, 80, 0.25)',
                    '--highlight-blue': 'rgba(33, 150, 243, 0.25)',
                    '--highlight-red': 'rgba(244, 67, 54, 0.25)',
                    '--highlight-purple': 'rgba(156, 39, 176, 0.25)'
                },
                'Océan': {
                    '--bg-primary': '#e8f4f8',
                    '--bg-secondary': '#d0e8f0',
                    '--bg-accent': '#1e3a52',
                    '--text-primary': '#1e3a52',
                    '--text-secondary': '#2a5270',
                    '--text-muted': '#5a7a90',
                    '--border-color': '#a8c8d8',
                    '--primary-color': '#3498db',
                    '--primary-hover': '#2980b9',
                    '--accent-red': '#c84a4a',
                    '--accent-gold': '#3498db',
                    '--highlight-yellow': 'rgba(255, 235, 59, 0.3)',
                    '--highlight-green': 'rgba(46, 204, 113, 0.3)',
                    '--highlight-blue': 'rgba(52, 152, 219, 0.4)',
                    '--highlight-red': 'rgba(231, 76, 60, 0.3)',
                    '--highlight-purple': 'rgba(155, 89, 182, 0.3)'
                },
                'Forêt': {
                    '--bg-primary': '#f0f4ed',
                    '--bg-secondary': '#e1e8dc',
                    '--bg-accent': '#2d3e2d',
                    '--text-primary': '#2d3e2d',
                    '--text-secondary': '#4a5e4a',
                    '--text-muted': '#7a8a7a',
                    '--border-color': '#c1d0bb',
                    '--primary-color': '#6b8e23',
                    '--primary-hover': '#557a1c',
                    '--accent-red': '#c44536',
                    '--accent-gold': '#6b8e23',
                    '--highlight-yellow': 'rgba(255, 235, 59, 0.3)',
                    '--highlight-green': 'rgba(107, 142, 35, 0.4)',
                    '--highlight-blue': 'rgba(70, 130, 180, 0.3)',
                    '--highlight-red': 'rgba(178, 34, 34, 0.3)',
                    '--highlight-purple': 'rgba(147, 112, 219, 0.3)'
                },
                'Crépuscule': {
                    '--bg-primary': '#2b2d42',
                    '--bg-secondary': '#3a3d54',
                    '--bg-accent': '#edf2f4',
                    '--text-primary': '#edf2f4',
                    '--text-secondary': '#c5cad4',
                    '--text-muted': '#8d99ae',
                    '--border-color': '#4a4d64',
                    '--primary-color': '#ffd166',
                    '--primary-hover': '#ffbe3d',
                    '--accent-red': '#ef476f',
                    '--accent-gold': '#ffd166',
                    '--highlight-yellow': 'rgba(255, 209, 102, 0.3)',
                    '--highlight-green': 'rgba(6, 214, 160, 0.3)',
                    '--highlight-blue': 'rgba(118, 171, 174, 0.3)',
                    '--highlight-red': 'rgba(239, 71, 111, 0.3)',
                    '--highlight-purple': 'rgba(177, 98, 134, 0.3)'
                },
                'Sépia': {
                    '--bg-primary': '#f4ecd8',
                    '--bg-secondary': '#e8dcc4',
                    '--bg-accent': '#3e2723',
                    '--text-primary': '#3e2723',
                    '--text-secondary': '#5d4037',
                    '--text-muted': '#8d6e63',
                    '--border-color': '#d7cdb8',
                    '--primary-color': '#a1887f',
                    '--primary-hover': '#8d6e63',
                    '--accent-red': '#bf360c',
                    '--accent-gold': '#a1887f',
                    '--highlight-yellow': 'rgba(255, 224, 130, 0.4)',
                    '--highlight-green': 'rgba(139, 195, 74, 0.3)',
                    '--highlight-blue': 'rgba(121, 134, 203, 0.3)',
                    '--highlight-red': 'rgba(191, 54, 12, 0.3)',
                    '--highlight-purple': 'rgba(142, 110, 99, 0.3)'
                },
                'Minuit': {
                    '--bg-primary': '#0d1b2a',
                    '--bg-secondary': '#1b263b',
                    '--bg-accent': '#e0e1dd',
                    '--text-primary': '#e0e1dd',
                    '--text-secondary': '#c0c2be',
                    '--text-muted': '#778da9',
                    '--border-color': '#2b3a4f',
                    '--primary-color': '#457b9d',
                    '--primary-hover': '#5a92b5',
                    '--accent-red': '#e63946',
                    '--accent-gold': '#f1faee',
                    '--highlight-yellow': 'rgba(241, 250, 238, 0.2)',
                    '--highlight-green': 'rgba(168, 218, 220, 0.2)',
                    '--highlight-blue': 'rgba(69, 123, 157, 0.3)',
                    '--highlight-red': 'rgba(230, 57, 70, 0.3)',
                    '--highlight-purple': 'rgba(163, 177, 138, 0.2)'
                },
                'Pastel': {
                    '--bg-primary': '#fff5f7',
                    '--bg-secondary': '#ffe8ec',
                    '--bg-accent': '#4a4a4a',
                    '--text-primary': '#2a2a2a',
                    '--text-secondary': '#5a5a5a',
                    '--text-muted': '#8a8a8a',
                    '--border-color': '#ffd4dc',
                    '--primary-color': '#ff6b9d',
                    '--primary-hover': '#ff5285',
                    '--accent-red': '#ff6b9d',
                    '--accent-gold': '#c9ada7',
                    '--highlight-yellow': 'rgba(255, 223, 186, 0.5)',
                    '--highlight-green': 'rgba(186, 220, 180, 0.5)',
                    '--highlight-blue': 'rgba(173, 216, 230, 0.5)',
                    '--highlight-red': 'rgba(255, 182, 193, 0.5)',
                    '--highlight-purple': 'rgba(221, 160, 221, 0.5)'
                }
            },
            
            init() {
                this.loadCustomThemes();
                this.loadCurrentTheme();
            },
            
            applyTheme(colors) {
                const root = document.documentElement;
                Object.entries(colors).forEach(([variable, value]) => {
                    root.style.setProperty(variable, value);
                });
                this.currentTheme = colors;
                this.saveCurrentTheme();
            },
            
            saveCurrentTheme() {
                localStorage.setItem('novelcraft-current-theme', JSON.stringify(this.currentTheme));
            },
            
            loadCurrentTheme() {
                const saved = localStorage.getItem('novelcraft-current-theme');
                if (saved) {
                    try {
                        this.currentTheme = JSON.parse(saved);
                        this.applyTheme(this.currentTheme);
                    } catch (e) {
                        console.error('Erreur chargement thème', e);
                    }
                }
            },
            
            saveCustomThemes() {
                localStorage.setItem('novelcraft-custom-themes', JSON.stringify(this.customThemes));
            },
            
            loadCustomThemes() {
                const saved = localStorage.getItem('novelcraft-custom-themes');
                if (saved) {
                    try {
                        this.customThemes = JSON.parse(saved);
                    } catch (e) {
                        console.error('Erreur chargement thèmes personnalisés', e);
                    }
                }
            },
            
            addCustomTheme(name, colors) {
                this.customThemes.push({ name, colors });
                this.saveCustomThemes();
            },
            
            deleteCustomTheme(name) {
                this.customThemes = this.customThemes.filter(t => t.name !== name);
                this.saveCustomThemes();
            },
            
            exportTheme(colors, name) {
                const theme = {
                    name: name,
                    colors: colors,
                    version: '1.0'
                };
                
                const json = JSON.stringify(theme, null, 2);
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `theme-${name.toLowerCase().replace(/\s+/g, '-')}.json`;
                a.click();
                URL.revokeObjectURL(url);
            },
            
            importTheme(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const theme = JSON.parse(e.target.result);
                            if (theme.colors && theme.name) {
                                resolve(theme);
                            } else {
                                reject(new Error('Format de thème invalide'));
                            }
                        } catch (error) {
                            reject(error);
                        }
                    };
                    reader.onerror = () => reject(new Error('Erreur de lecture du fichier'));
                    reader.readAsText(file);
                });
            }
        };
        
        function openThemeManager() {
            const modal = document.createElement('div');
            modal.className = 'modal-overlay';
            modal.style.zIndex = '10000';
            
            const currentColors = {};
            Object.keys(themeManager.defaultVariables).forEach(variable => {
                const value = getComputedStyle(document.documentElement).getPropertyValue(variable);
                currentColors[variable] = value.trim();
            });
            
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 1000px; max-height: 90vh; overflow: hidden; display: flex; flex-direction: column;">
                    <div class="modal-header">
                        <h2>🎨 Gestionnaire de Thèmes</h2>
                        <button class="modal-close" onclick="this.closest('.modal-overlay').remove()">✕</button>
                    </div>
                    
                    <div style="flex: 1; overflow-y: auto; padding: 1.5rem;">
                        <!-- Thèmes prédéfinis -->
                        <div style="margin-bottom: 2rem;">
                            <h3 style="margin-bottom: 1rem; font-size: 1.2rem; color: var(--accent-gold);">
                                📚 Thèmes Prédéfinis
                            </h3>
                            <div id="presetThemesList" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 1rem;">
                            </div>
                        </div>
                        
                        <!-- Thèmes personnalisés -->
                        <div style="margin-bottom: 2rem;">
                            <h3 style="margin-bottom: 1rem; font-size: 1.2rem; color: var(--accent-gold);">
                                ✨ Mes Thèmes Personnalisés
                            </h3>
                            <div id="customThemesList" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 1rem;">
                            </div>
                        </div>
                        
                        <!-- Éditeur de couleurs -->
                        <div style="border-top: 2px solid var(--border-color); padding-top: 1.5rem;">
                            <h3 style="margin-bottom: 1rem; font-size: 1.2rem; color: var(--accent-gold);">
                                🎨 Éditeur de Thème
                            </h3>
                            
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 1rem; margin-bottom: 1.5rem;">
                                ${Object.entries(themeManager.defaultVariables).map(([variable, defaultValue]) => {
                                    const label = variable.replace('--', '').split('-').map(w => 
                                        w.charAt(0).toUpperCase() + w.slice(1)
                                    ).join(' ');
                                    
                                    const currentValue = currentColors[variable] || defaultValue;
                                    const hexColor = rgbaToHex(currentValue);
                                    
                                    return `
                                        <div class="color-input-group">
                                            <label style="display: block; margin-bottom: 0.5rem; font-weight: 500; font-size: 0.9rem;">
                                                ${label}
                                            </label>
                                            <div style="display: flex; gap: 0.5rem; align-items: center;">
                                                <input 
                                                    type="color" 
                                                    data-variable="${variable}"
                                                    value="${hexColor}"
                                                    style="width: 50px; height: 40px; border: 2px solid var(--border-color); border-radius: 4px; cursor: pointer;"
                                                >
                                                <input 
                                                    type="text" 
                                                    data-variable-text="${variable}"
                                                    value="${currentValue}"
                                                    placeholder="${currentValue}"
                                                    style="flex: 1; padding: 0.5rem; border: 1px solid var(--border-color); border-radius: 4px; font-family: 'Source Code Pro', monospace; font-size: 0.85rem;"
                                                >
                                            </div>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                            
                            <!-- Actions de l'éditeur -->
                            <div style="display: flex; gap: 0.75rem; flex-wrap: wrap; padding-top: 1rem; border-top: 1px solid var(--border-color);">
                                <button onclick="applyCurrentEditorColors()" class="btn-primary">
                                    ✓ Appliquer les Couleurs
                                </button>
                                <button onclick="saveThemeAsCustom()" class="btn-primary" style="background: var(--accent-gold);">
                                    💾 Sauvegarder comme Thème
                                </button>
                                <button onclick="exportCurrentTheme()" class="btn-secondary">
                                    📤 Exporter en JSON
                                </button>
                                <button onclick="importThemeFile()" class="btn-secondary">
                                    📥 Importer depuis JSON
                                </button>
                                <button onclick="resetToDefault()" class="btn-secondary" style="margin-left: auto;">
                                    🔄 Réinitialiser
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Remplir les thèmes prédéfinis
            renderPresetThemes();
            renderCustomThemes();
            
            // Lier les changements de couleur en temps réel
            modal.querySelectorAll('input[type="color"]').forEach(input => {
                input.addEventListener('input', (e) => {
                    const variable = e.target.dataset.variable;
                    const color = e.target.value;
                    const textInput = modal.querySelector(`input[data-variable-text="${variable}"]`);
                    textInput.value = color;
                    document.documentElement.style.setProperty(variable, color);
                });
            });
            
            modal.querySelectorAll('input[data-variable-text]').forEach(input => {
                input.addEventListener('change', (e) => {
                    const variable = e.target.dataset.variableText;
                    const color = e.target.value;
                    document.documentElement.style.setProperty(variable, color);
                    
                    // Mettre à jour le color picker si possible
                    const hexColor = rgbaToHex(color);
                    const colorInput = modal.querySelector(`input[data-variable="${variable}"]`);
                    if (colorInput && hexColor.match(/^#[0-9A-F]{6}$/i)) {
                        colorInput.value = hexColor;
                    }
                });
            });
        }
        
        function renderPresetThemes() {
            const container = document.getElementById('presetThemesList');
            container.innerHTML = Object.entries(themeManager.presetThemes).map(([name, colors]) => `
                <div class="theme-card" style="border: 2px solid var(--border-color); border-radius: 8px; padding: 1rem; cursor: pointer; transition: all 0.2s;"
                     onmouseover="this.style.borderColor='var(--accent-gold)'"
                     onmouseout="this.style.borderColor='var(--border-color)'"
                     onclick="applyPresetTheme('${name}')">
                    <div style="font-weight: 600; margin-bottom: 0.75rem; font-size: 1rem;">
                        ${name}
                    </div>
                    <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 0.25rem;">
                        ${Object.values(colors).slice(0, 10).map(color => `
                            <div style="width: 100%; padding-bottom: 100%; background: ${color}; border-radius: 2px; border: 1px solid rgba(0,0,0,0.1);"></div>
                        `).join('')}
                    </div>
                </div>
            `).join('');
        }
        
        function renderCustomThemes() {
            const container = document.getElementById('customThemesList');
            if (themeManager.customThemes.length === 0) {
                container.innerHTML = '<p style="color: var(--text-muted); font-style: italic;">Aucun thème personnalisé</p>';
                return;
            }
            
            container.innerHTML = themeManager.customThemes.map(theme => `
                <div class="theme-card" style="border: 2px solid var(--border-color); border-radius: 8px; padding: 1rem; position: relative;">
                    <button onclick="deleteCustomTheme('${theme.name}')" 
                            style="position: absolute; top: 0.5rem; right: 0.5rem; background: var(--accent-red); color: white; border: none; border-radius: 4px; width: 24px; height: 24px; cursor: pointer; font-size: 0.9rem;"
                            title="Supprimer">✕</button>
                    <div style="font-weight: 600; margin-bottom: 0.75rem; font-size: 1rem; padding-right: 2rem;">
                        ${theme.name}
                    </div>
                    <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 0.25rem; margin-bottom: 0.75rem;">
                        ${Object.values(theme.colors).slice(0, 10).map(color => `
                            <div style="width: 100%; padding-bottom: 100%; background: ${color}; border-radius: 2px; border: 1px solid rgba(0,0,0,0.1);"></div>
                        `).join('')}
                    </div>
                    <button onclick="applyCustomTheme('${theme.name}')" class="btn-secondary" style="width: 100%; padding: 0.5rem; font-size: 0.85rem;">
                        Appliquer
                    </button>
                </div>
            `).join('');
        }
        
        function applyPresetTheme(name) {
            const colors = themeManager.presetThemes[name];
            themeManager.applyTheme(colors);
            showNotification(`✓ Thème "${name}" appliqué`);
            
            // Mettre à jour l'éditeur
            Object.entries(colors).forEach(([variable, value]) => {
                const colorInput = document.querySelector(`input[data-variable="${variable}"]`);
                const textInput = document.querySelector(`input[data-variable-text="${variable}"]`);
                if (colorInput && textInput) {
                    textInput.value = value;
                    const hexColor = rgbaToHex(value);
                    if (hexColor.match(/^#[0-9A-F]{6}$/i)) {
                        colorInput.value = hexColor;
                    }
                }
            });
        }
        
        function applyCustomTheme(name) {
            const theme = themeManager.customThemes.find(t => t.name === name);
            if (theme) {
                themeManager.applyTheme(theme.colors);
                showNotification(`✓ Thème "${name}" appliqué`);
                
                // Mettre à jour l'éditeur
                Object.entries(theme.colors).forEach(([variable, value]) => {
                    const colorInput = document.querySelector(`input[data-variable="${variable}"]`);
                    const textInput = document.querySelector(`input[data-variable-text="${variable}"]`);
                    if (colorInput && textInput) {
                        textInput.value = value;
                        const hexColor = rgbaToHex(value);
                        if (hexColor.match(/^#[0-9A-F]{6}$/i)) {
                            colorInput.value = hexColor;
                        }
                    }
                });
            }
        }
        
        function deleteCustomTheme(name) {
            if (confirm(`Supprimer le thème "${name}" ?`)) {
                themeManager.deleteCustomTheme(name);
                renderCustomThemes();
                showNotification(`✓ Thème "${name}" supprimé`);
            }
        }
        
        function applyCurrentEditorColors() {
            const colors = {};
            document.querySelectorAll('input[data-variable-text]').forEach(input => {
                const variable = input.dataset.variableText;
                colors[variable] = input.value;
            });
            themeManager.applyTheme(colors);
            showNotification('✓ Couleurs appliquées');
        }
        
        function saveThemeAsCustom() {
            const name = prompt('Nom du thème :');
            if (!name) return;
            
            // Vérifier si le nom existe déjà
            if (themeManager.customThemes.find(t => t.name === name)) {
                if (!confirm(`Un thème nommé "${name}" existe déjà. Remplacer ?`)) {
                    return;
                }
                themeManager.deleteCustomTheme(name);
            }
            
            const colors = {};
            document.querySelectorAll('input[data-variable-text]').forEach(input => {
                const variable = input.dataset.variableText;
                colors[variable] = input.value;
            });
            
            themeManager.addCustomTheme(name, colors);
            renderCustomThemes();
            showNotification(`✓ Thème "${name}" sauvegardé`);
        }
        
        function exportCurrentTheme() {
            const name = prompt('Nom du thème pour l\'export :', 'Mon Thème');
            if (!name) return;
            
            const colors = {};
            document.querySelectorAll('input[data-variable-text]').forEach(input => {
                const variable = input.dataset.variableText;
                colors[variable] = input.value;
            });
            
            themeManager.exportTheme(colors, name);
            showNotification(`✓ Thème "${name}" exporté`);
        }
        
        function importThemeFile() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = async (e) => {
                try {
                    const file = e.target.files[0];
                    const theme = await themeManager.importTheme(file);
                    
                    // Demander si on veut l'appliquer ou le sauvegarder
                    const choice = confirm(`Thème "${theme.name}" importé.\n\nOK = Appliquer maintenant\nAnnuler = Sauvegarder dans mes thèmes`);
                    
                    if (choice) {
                        themeManager.applyTheme(theme.colors);
                        showNotification(`✓ Thème "${theme.name}" appliqué`);
                    } else {
                        // Vérifier si le nom existe
                        if (themeManager.customThemes.find(t => t.name === theme.name)) {
                            if (!confirm(`Un thème nommé "${theme.name}" existe déjà. Remplacer ?`)) {
                                return;
                            }
                            themeManager.deleteCustomTheme(theme.name);
                        }
                        themeManager.addCustomTheme(theme.name, theme.colors);
                        renderCustomThemes();
                        showNotification(`✓ Thème "${theme.name}" sauvegardé`);
                    }
                    
                    // Mettre à jour l'éditeur
                    Object.entries(theme.colors).forEach(([variable, value]) => {
                        const colorInput = document.querySelector(`input[data-variable="${variable}"]`);
                        const textInput = document.querySelector(`input[data-variable-text="${variable}"]`);
                        if (colorInput && textInput) {
                            textInput.value = value;
                            const hexColor = rgbaToHex(value);
                            if (hexColor.match(/^#[0-9A-F]{6}$/i)) {
                                colorInput.value = hexColor;
                            }
                        }
                    });
                    
                } catch (error) {
                    alert(`Erreur lors de l'import : ${error.message}`);
                }
            };
            input.click();
        }
        
        function resetToDefault() {
            if (confirm('Revenir au thème par défaut ?')) {
                themeManager.applyTheme(themeManager.defaultVariables);
                showNotification('✓ Thème par défaut restauré');
                
                // Mettre à jour l'éditeur
                Object.entries(themeManager.defaultVariables).forEach(([variable, value]) => {
                    const colorInput = document.querySelector(`input[data-variable="${variable}"]`);
                    const textInput = document.querySelector(`input[data-variable-text="${variable}"]`);
                    if (colorInput && textInput) {
                        textInput.value = value;
                        const hexColor = rgbaToHex(value);
                        if (hexColor.match(/^#[0-9A-F]{6}$/i)) {
                            colorInput.value = hexColor;
                        }
                    }
                });
            }
        }

        // === TENSION WORDS MANAGEMENT ===
        
        // Valeurs par défaut des mots de tension
        const DEFAULT_TENSION_WORDS = {
            high: [
                'combat', 'bataille', 'mort', 'tuer', 'danger', 'peur', 'terreur', 'cri', 'hurler',
                'sang', 'blessure', 'fuir', 'course', 'poursuite', 'menace', 'attaque', 'explosion',
                'feu', 'incendie', 'catastrophe', 'urgence', 'panique', 'désespoir', 'tragédie',
                'révélation', 'secret', 'trahison', 'conflit', 'confrontation', 'affrontement',
                'climax', 'crucial', 'décisif', 'critique', 'vital', 'dramatique'
            ],
            medium: [
                'mystère', 'suspense', 'intrigue', 'complot', 'enquête', 'découverte', 'surprise',
                'tension', 'stress', 'angoisse', 'inquiétude', 'doute', 'hésitation', 'dilemme',
                'choix', 'décision', 'tournant', 'changement', 'transformation'
            ],
            low: [
                'calme', 'paix', 'repos', 'détente', 'tranquille', 'paisible', 'serein',
                'conversation', 'discussion', 'réflexion', 'souvenir', 'rêve', 'pensée'
            ]
        };

        // Récupérer les mots de tension (personnalisés ou par défaut)
        function getTensionWords() {
            const stored = localStorage.getItem('tensionWords');
            if (stored) {
                try {
                    return JSON.parse(stored);
                } catch (e) {
                    console.error('Erreur lors du chargement des mots de tension:', e);
                    return DEFAULT_TENSION_WORDS;
                }
            }
            return DEFAULT_TENSION_WORDS;
        }

        // Sauvegarder les mots de tension
        function saveTensionWordsToStorage(words) {
            localStorage.setItem('tensionWords', JSON.stringify(words));
        }

        // Ouvrir l'éditeur de mots de tension
        function openTensionWordsEditor() {
            document.getElementById('tensionWordsModal').classList.add('active');
            loadTensionWordsInEditor();
        }

        // Charger les mots dans l'éditeur
        function loadTensionWordsInEditor() {
            const words = getTensionWords();
            
            // Charger les mots de haute tension
            const highList = document.getElementById('highTensionList');
            highList.innerHTML = '';
            words.high.forEach((word, index) => {
                highList.innerHTML += createWordElement(word, 'high', index);
            });
            
            // Charger les mots de tension moyenne
            const mediumList = document.getElementById('mediumTensionList');
            mediumList.innerHTML = '';
            words.medium.forEach((word, index) => {
                mediumList.innerHTML += createWordElement(word, 'medium', index);
            });
            
            // Charger les mots de faible tension
            const lowList = document.getElementById('lowTensionList');
            lowList.innerHTML = '';
            words.low.forEach((word, index) => {
                lowList.innerHTML += createWordElement(word, 'low', index);
            });
        }

        // Créer un élément de mot avec bouton de suppression
        function createWordElement(word, type, index) {
            const colors = {
                high: 'var(--accent-red)',
                medium: '#e6a23c',
                low: 'var(--accent-blue)'
            };
            
            return `
                <div style="display: flex; align-items: center; justify-content: space-between; padding: 0.5rem 0.75rem; background: var(--bg-primary); border-radius: 4px; border: 1px solid var(--border-color);">
                    <span style="font-size: 0.85rem; color: var(--text-primary);">${word}</span>
                    <button onclick="removeTensionWord('${type}', ${index})" 
                            style="background: none; border: none; color: ${colors[type]}; cursor: pointer; font-size: 1rem; padding: 0 0.25rem; opacity: 0.7; transition: opacity 0.2s;"
                            onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0.7'"
                            title="Supprimer ce mot">
                        ×
                    </button>
                </div>
            `;
        }

        // Ajouter un mot de tension
        function addTensionWord(type) {
            const input = document.getElementById(`${type}TensionInput`);
            const word = input.value.trim().toLowerCase();
            
            if (!word) {
                showNotification('⚠️ Veuillez entrer un mot', 'warning');
                return;
            }
            
            const words = getTensionWords();
            
            // Vérifier si le mot existe déjà
            if (words[type].includes(word)) {
                showNotification('⚠️ Ce mot existe déjà dans cette catégorie', 'warning');
                return;
            }
            
            // Vérifier si le mot existe dans une autre catégorie
            for (const category in words) {
                if (category !== type && words[category].includes(word)) {
                    showNotification(`⚠️ Ce mot existe déjà dans la catégorie "${category === 'high' ? 'haute' : category === 'medium' ? 'moyenne' : 'faible'} tension"`, 'warning');
                    return;
                }
            }
            
            // Ajouter le mot
            words[type].push(word);
            saveTensionWordsToStorage(words);
            
            // Recharger la liste
            loadTensionWordsInEditor();
            
            // Vider l'input
            input.value = '';
            
            showNotification(`✓ Mot "${word}" ajouté`, 'success');
        }

        // Supprimer un mot de tension
        function removeTensionWord(type, index) {
            const words = getTensionWords();
            const removedWord = words[type][index];
            
            words[type].splice(index, 1);
            saveTensionWordsToStorage(words);
            
            // Recharger la liste
            loadTensionWordsInEditor();
            
            showNotification(`✓ Mot "${removedWord}" supprimé`, 'success');
        }

        // Enregistrer les modifications
        function saveTensionWords() {
            closeModal('tensionWordsModal');
            showNotification('✓ Mots de tension enregistrés. Le graphique sera recalculé lors de la prochaine visualisation.', 'success');
        }

        // Réinitialiser aux valeurs par défaut
        function resetTensionWordsToDefault() {
            if (confirm('Êtes-vous sûr de vouloir réinitialiser tous les mots de tension aux valeurs par défaut ? Cette action est irréversible.')) {
                saveTensionWordsToStorage(DEFAULT_TENSION_WORDS);
                loadTensionWordsInEditor();
                showNotification('✓ Mots de tension réinitialisés aux valeurs par défaut', 'success');
            }
        }

        // Exporter les dictionnaires de mots de tension
        function exportTensionWords() {
            const words = getTensionWords();
            
            // Créer trois fichiers texte, un par catégorie
            const highWords = words.high.join('\n');
            const mediumWords = words.medium.join('\n');
            const lowWords = words.low.join('\n');
            
            // Créer un fichier ZIP virtuel avec les trois fichiers
            const content = `=== DICTIONNAIRES DE MOTS DE TENSION ===
Exporté le ${new Date().toLocaleString('fr-FR')}

=== HAUTE TENSION (${words.high.length} mots) ===
${highWords}

=== TENSION MOYENNE (${words.medium.length} mots) ===
${mediumWords}

=== FAIBLE TENSION (${words.low.length} mots) ===
${lowWords}
`;
            
            // Créer et télécharger le fichier
            const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `dictionnaires-tension-${new Date().toISOString().slice(0, 10)}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showNotification('✓ Dictionnaires exportés avec succès', 'success');
        }

        // === BULK IMPORT FOR TENSION WORDS ===
        
        let currentBulkImportType = null;

        // Ouvrir le modal d'import en masse
        function openBulkImport(type) {
            currentBulkImportType = type;
            
            const titles = {
                high: '📥 Import en masse - Haute tension',
                medium: '📥 Import en masse - Tension moyenne',
                low: '📥 Import en masse - Faible tension'
            };
            
            document.getElementById('bulkImportTitle').textContent = titles[type];
            document.getElementById('bulkImportText').value = '';
            document.getElementById('bulkImportFile').value = '';
            document.querySelector('input[name="importMode"][value="add"]').checked = true;
            
            document.getElementById('bulkImportModal').classList.add('active');
        }

        // Traiter l'import en masse
        function processBulkImport() {
            if (!currentBulkImportType) return;
            
            const textarea = document.getElementById('bulkImportText');
            const fileInput = document.getElementById('bulkImportFile');
            const mode = document.querySelector('input[name="importMode"]:checked').value;
            
            // Vérifier si un fichier est sélectionné
            if (fileInput.files && fileInput.files[0]) {
                const file = fileInput.files[0];
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    const content = e.target.result;
                    importWordsFromText(content, currentBulkImportType, mode);
                };
                
                reader.onerror = function() {
                    showNotification('❌ Erreur lors de la lecture du fichier', 'error');
                };
                
                reader.readAsText(file);
            } else if (textarea.value.trim()) {
                // Utiliser le texte collé
                importWordsFromText(textarea.value, currentBulkImportType, mode);
            } else {
                showNotification('⚠️ Veuillez coller du texte ou sélectionner un fichier', 'warning');
            }
        }

        // Importer les mots depuis du texte
        function importWordsFromText(text, type, mode) {
            // Nettoyer et parser le texte
            let words = [];
            
            // Séparer par retours à la ligne ET par virgules
            const lines = text.split(/\r?\n/);
            lines.forEach(line => {
                // Pour chaque ligne, séparer aussi par virgules
                const wordsInLine = line.split(',');
                wordsInLine.forEach(word => {
                    const cleaned = word.trim().toLowerCase();
                    if (cleaned && cleaned.length > 0) {
                        words.push(cleaned);
                    }
                });
            });
            
            // Supprimer les doublons
            words = [...new Set(words)];
            
            if (words.length === 0) {
                showNotification('⚠️ Aucun mot valide trouvé', 'warning');
                return;
            }
            
            // Récupérer les mots existants
            const tensionWords = getTensionWords();
            
            if (mode === 'replace') {
                // Remplacer tous les mots
                tensionWords[type] = words;
                showNotification(`✓ ${words.length} mots importés (remplacement)`, 'success');
            } else {
                // Ajouter aux mots existants (sans doublons)
                const existingWords = new Set(tensionWords[type]);
                let addedCount = 0;
                
                words.forEach(word => {
                    if (!existingWords.has(word)) {
                        tensionWords[type].push(word);
                        addedCount++;
                    }
                });
                
                const skippedCount = words.length - addedCount;
                if (addedCount > 0) {
                    showNotification(`✓ ${addedCount} mot(s) ajouté(s)${skippedCount > 0 ? ` (${skippedCount} doublon(s) ignoré(s))` : ''}`, 'success');
                } else {
                    showNotification(`⚠️ Tous les mots existent déjà (${skippedCount} doublon(s))`, 'warning');
                }
            }
            
            // Sauvegarder et recharger
            saveTensionWordsToStorage(tensionWords);
            loadTensionWordsInEditor();
            
            // Fermer le modal
            closeModal('bulkImportModal');
        }

        // Gestionnaire pour le changement de fichier
        document.addEventListener('DOMContentLoaded', function() {
            const fileInput = document.getElementById('bulkImportFile');
            if (fileInput) {
                fileInput.addEventListener('change', function() {
                    if (this.files && this.files[0]) {
                        // Vider le textarea si un fichier est sélectionné
                        document.getElementById('bulkImportText').value = '';
                    }
                });
            }
            
            const textarea = document.getElementById('bulkImportText');
            if (textarea) {
                textarea.addEventListener('input', function() {
                    if (this.value.trim()) {
                        // Vider le file input si du texte est saisi
                        document.getElementById('bulkImportFile').value = '';
                    }
                });
            }
        });

        // ============================================
        // EXPORT NOVEL FUNCTIONS
        // ============================================

        // Global variable to track selection state
        let exportSelectionState = {};

        function openExportNovelModal() {
            // Initialize selection state with all items checked
            exportSelectionState = {};
            project.acts.forEach(act => {
                exportSelectionState[`act-${act.id}`] = true;
                act.chapters.forEach(chapter => {
                    exportSelectionState[`chapter-${chapter.id}`] = true;
                    chapter.scenes.forEach(scene => {
                        exportSelectionState[`scene-${scene.id}`] = true;
                    });
                });
            });
            
            renderExportTree();
            updateExportFormatInfo();
            document.getElementById('exportNovelModal').classList.add('active');
        }

        function renderExportTree() {
            const container = document.getElementById('exportTreeContainer');
            console.log('renderExportTree called, container:', container);
            console.log('project.acts:', project.acts);
            if (!container) return;
            
            let html = '';
            
            if (!project.acts || project.acts.length === 0) {
                html = '<p style="color: var(--text-muted); text-align: center;">Aucun acte à exporter</p>';
                container.innerHTML = html;
                return;
            }
            
            project.acts.forEach((act, actIndex) => {
                const actChecked = exportSelectionState[`act-${act.id}`] ? 'checked' : '';
                html += `
                    <div style="margin-bottom: 1rem;">
                        <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-weight: 600; font-size: 1rem; margin-bottom: 0.5rem;">
                            <input type="checkbox" ${actChecked} onchange="toggleAct(${act.id})" id="export-act-${act.id}" style="cursor: pointer;">
                            <span>Acte ${actIndex + 1}</span>
                        </label>
                        <div style="margin-left: 1.5rem;">
                `;
                
                act.chapters.forEach((chapter, chapIndex) => {
                    const chapterChecked = exportSelectionState[`chapter-${chapter.id}`] ? 'checked' : '';
                    html += `
                        <div style="margin-bottom: 0.75rem;">
                            <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-weight: 500; font-size: 0.95rem; margin-bottom: 0.25rem;">
                                <input type="checkbox" ${chapterChecked} onchange="toggleChapter(${act.id}, ${chapter.id})" id="export-chapter-${chapter.id}" style="cursor: pointer;">
                                <span>Chapitre ${chapIndex + 1}</span>
                            </label>
                            <div style="margin-left: 1.5rem;">
                    `;
                    
                    chapter.scenes.forEach((scene, sceneIndex) => {
                        const sceneChecked = exportSelectionState[`scene-${scene.id}`] ? 'checked' : '';
                        html += `
                            <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-size: 0.9rem; color: var(--text-secondary); margin-bottom: 0.25rem;">
                                <input type="checkbox" ${sceneChecked} onchange="toggleScene(${act.id}, ${chapter.id}, ${scene.id})" id="export-scene-${scene.id}" style="cursor: pointer;">
                                <span>Scène ${sceneIndex + 1}</span>
                            </label>
                        `;
                    });
                    
                    html += `
                            </div>
                        </div>
                    `;
                });
                
                html += `
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }

        function toggleAllScenes() {
            // Check if all are currently selected
            const allSelected = Object.values(exportSelectionState).every(v => v === true);
            
            // Toggle all to opposite state
            const newState = !allSelected;
            
            project.acts.forEach(act => {
                exportSelectionState[`act-${act.id}`] = newState;
                act.chapters.forEach(chapter => {
                    exportSelectionState[`chapter-${chapter.id}`] = newState;
                    chapter.scenes.forEach(scene => {
                        exportSelectionState[`scene-${scene.id}`] = newState;
                    });
                });
            });
            
            renderExportTree();
        }

        // Act Management
        // Fonctions toggleAct et toggleChapter déjà définies plus haut (lignes ~5854 et ~5944)
        // Les définitions en double ont été supprimées pour éviter les conflits

        function toggleScene(actId, chapterId, sceneId) {
            const checkbox = document.getElementById(`export-scene-${sceneId}`);
            exportSelectionState[`scene-${sceneId}`] = checkbox.checked;
            
            // Update chapter checkbox
            const act = project.acts.find(a => a.id === actId);
            if (act) {
                const chapter = act.chapters.find(c => c.id === chapterId);
                if (chapter) {
                    const allScenesChecked = chapter.scenes.every(s => exportSelectionState[`scene-${s.id}`]);
                    exportSelectionState[`chapter-${chapterId}`] = allScenesChecked;
                    
                    // Update act checkbox
                    const allChaptersChecked = act.chapters.every(c => exportSelectionState[`chapter-${c.id}`]);
                    exportSelectionState[`act-${actId}`] = allChaptersChecked;
                }
            }
            
            renderExportTree();
        }

        function updateExportFormatInfo() {
            const format = document.getElementById('exportFormatSelect').value;
            const infoBox = document.getElementById('formatInfoBox');
            
            const messages = {
                docx: '<strong style="color: var(--text-primary);">ℹ️ Note :</strong> Toutes les fonctionnalités ne sont pas supportées en format DOCX. Le texte exporté pourrait ne pas ressembler exactement à l\'éditeur. Pour une compatibilité complète, utilisez un autre format.',
                markdown: '<strong style="color: var(--text-primary);">✅ Format Markdown :</strong> Excellent pour la portabilité et la compatibilité avec la plupart des éditeurs de texte et des plateformes de publication.',
                txt: '<strong style="color: var(--text-primary);">📋 Texte brut :</strong> Format universel sans formatage. Compatible avec tous les logiciels.',
                html: '<strong style="color: var(--text-primary);">🌐 HTML :</strong> Format web avec préservation complète du formatage. Ouvrez dans un navigateur ou importez dans des éditeurs HTML.',
                epub: '<strong style="color: var(--text-primary);">📚 EPUB :</strong> Format e-book standard. Compatible avec Kindle (via conversion), Kobo, Apple Books, et la plupart des liseuses.'
            };
            
            infoBox.innerHTML = messages[format] || messages.docx;
        }

        function executeNovelExport() {
            const format = document.getElementById('exportFormatSelect').value;
            const options = {
                exportSummaries: document.getElementById('exportSummariesCheck').checked,
                exportProse: document.getElementById('exportProseCheck').checked,
                includeActTitles: document.getElementById('includeActTitlesCheck').checked,
                includeSceneSubtitles: document.getElementById('includeSceneSubtitlesCheck').checked,
                sceneDivider: document.getElementById('sceneDividerSelect').value,
                includeCharacters: document.getElementById('includeCharactersCheck').checked,
                includeWorld: document.getElementById('includeWorldCheck').checked,
                includeTimeline: document.getElementById('includeTimelineCheck').checked,
                includeRelations: document.getElementById('includeRelationsCheck').checked,
                includeCodex: document.getElementById('includeCodexCheck').checked,
                includeNotes: document.getElementById('includeNotesCheck').checked
            };
            
            // Check if creating a ZIP archive (project export)
            const isProjectExport = options.includeCharacters || options.includeWorld || 
                                   options.includeTimeline || options.includeRelations || 
                                   options.includeCodex || options.includeNotes;
            
            if (isProjectExport) {
                exportProjectAsZip(format, options);
            } else {
                // Single file export
                switch(format) {
                    case 'docx':
                        exportAsDOCX(options);
                        break;
                    case 'markdown':
                        exportAsMarkdown(options);
                        break;
                    case 'txt':
                        exportAsTXT(options);
                        break;
                    case 'html':
                        exportAsHTML(options);
                        break;
                    case 'epub':
                        exportAsEPUB(options);
                        break;
                }
            }
        }
        
        function toggleAllExportOptions(selectAll) {
            const checkboxes = [
                'includeCharactersCheck', 'includeWorldCheck', 'includeTimelineCheck',
                'includeRelationsCheck', 'includeCodexCheck', 'includeNotesCheck'
            ];
            checkboxes.forEach(id => {
                const checkbox = document.getElementById(id);
                if (checkbox) checkbox.checked = selectAll;
            });
        }

        function getSelectedContent(options) {
            let content = {
                acts: []
            };
            
            project.acts.forEach((act, actIndex) => {
                if (!exportSelectionState[`act-${act.id}`]) return;
                
                let exportAct = {
                    title: `Acte ${actIndex + 1}`,
                    chapters: []
                };
                
                act.chapters.forEach((chapter, chapIndex) => {
                    if (!exportSelectionState[`chapter-${chapter.id}`]) return;
                    
                    let exportChapter = {
                        title: chapter.title || `Chapitre ${chapIndex + 1}`,
                        scenes: []
                    };
                    
                    chapter.scenes.forEach((scene, sceneIndex) => {
                        if (!exportSelectionState[`scene-${scene.id}`]) return;
                        
                        // Utiliser la version finale si elle existe, sinon le contenu actuel
                        const sceneContent = getSceneExportContent(scene);
                        
                        let exportScene = {
                            title: scene.title || `Scène ${sceneIndex + 1}`,
                            summary: scene.summary || '',
                            content: sceneContent || ''
                        };
                        
                        exportChapter.scenes.push(exportScene);
                    });
                    
                    if (exportChapter.scenes.length > 0) {
                        exportAct.chapters.push(exportChapter);
                    }
                });
                
                if (exportAct.chapters.length > 0) {
                    content.acts.push(exportAct);
                }
            });
            
            return content;
        }

        function getSceneDivider(dividerType) {
            switch(dividerType) {
                case 'asterisks':
                    return '\n\n* * *\n\n';
                case 'hash':
                    return '\n\n###\n\n';
                case 'line':
                    return '\n\n---\n\n';
                case 'space':
                    return '\n\n\n';
                case 'none':
                    return '\n\n';
                default:
                    return '\n\n* * *\n\n';
            }
        }

        function exportAsMarkdown(options) {
            const content = getSelectedContent(options);
            const divider = getSceneDivider(options.sceneDivider);
            let markdown = `# ${project.title}\n\n`;
            
            content.acts.forEach((act, actIndex) => {
                if (options.includeActTitles) {
                    markdown += `# ${act.title}\n\n`;
                }
                
                act.chapters.forEach((chapter, chapIndex) => {
                    markdown += `## ${chapter.title}\n\n`;
                    
                    chapter.scenes.forEach((scene, sceneIndex) => {
                        if (options.includeSceneSubtitles && scene.title) {
                            markdown += `### ${scene.title}\n\n`;
                        }
                        
                        if (options.exportSummaries && scene.summary) {
                            markdown += `> ${scene.summary}\n\n`;
                        }
                        
                        if (options.exportProse && scene.content) {
                            markdown += `${scene.content}\n`;
                        }
                        
                        // Add divider between scenes (except after last scene)
                        if (sceneIndex < chapter.scenes.length - 1) {
                            markdown += divider;
                        }
                    });
                    
                    markdown += '\n\n';
                });
            });
            
            downloadFile(markdown, `${project.title}.md`, 'text/markdown');
            showNotification('✓ Export Markdown terminé');
            closeModal('exportNovelModal');
        }

        function exportAsTXT(options) {
            const content = getSelectedContent(options);
            const divider = getSceneDivider(options.sceneDivider);
            let text = `${project.title}\n${'='.repeat(project.title.length)}\n\n`;
            
            content.acts.forEach((act, actIndex) => {
                if (options.includeActTitles) {
                    text += `${act.title}\n${'-'.repeat(act.title.length)}\n\n`;
                }
                
                act.chapters.forEach((chapter, chapIndex) => {
                    text += `${chapter.title}\n\n`;
                    
                    chapter.scenes.forEach((scene, sceneIndex) => {
                        if (options.includeSceneSubtitles && scene.title) {
                            text += `${scene.title}\n\n`;
                        }
                        
                        if (options.exportSummaries && scene.summary) {
                            text += `[Résumé: ${scene.summary}]\n\n`;
                        }
                        
                        if (options.exportProse && scene.content) {
                            text += `${scene.content}\n`;
                        }
                        
                        if (sceneIndex < chapter.scenes.length - 1) {
                            text += divider;
                        }
                    });
                    
                    text += '\n\n';
                });
            });
            
            downloadFile(text, `${project.title}.txt`, 'text/plain');
            showNotification('✓ Export TXT terminé');
            closeModal('exportNovelModal');
        }

        function exportAsHTML(options) {
            const content = getSelectedContent(options);
            const divider = getSceneDivider(options.sceneDivider).replace(/\n/g, '<br>');
            
            let html = `<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${project.title}</title>
    <style>
        body {
            font-family: 'Georgia', serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 2rem;
            line-height: 1.8;
            color: #333;
            background: #fafafa;
        }
        h1 {
            font-size: 2.5rem;
            margin-bottom: 2rem;
            text-align: center;
            border-bottom: 3px solid #333;
            padding-bottom: 1rem;
        }
        h2 {
            font-size: 2rem;
            margin-top: 3rem;
            margin-bottom: 1.5rem;
            border-bottom: 2px solid #666;
            padding-bottom: 0.5rem;
        }
        h3 {
            font-size: 1.5rem;
            margin-top: 2rem;
            margin-bottom: 1rem;
            color: #666;
        }
        h4 {
            font-size: 1.2rem;
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
            color: #888;
            font-style: italic;
        }
        p {
            margin-bottom: 1rem;
            text-align: justify;
        }
        .summary {
            background: #f0f0f0;
            padding: 1rem;
            border-left: 4px solid #999;
            margin: 1rem 0;
            font-style: italic;
            color: #666;
        }
        .divider {
            text-align: center;
            margin: 2rem 0;
            color: #999;
        }
    </style>
</head>
<body>
    <h1>${project.title}</h1>
`;
            
            content.acts.forEach((act, actIndex) => {
                if (options.includeActTitles) {
                    html += `    <h2>${act.title}</h2>\n`;
                }
                
                act.chapters.forEach((chapter, chapIndex) => {
                    html += `    <h3>${chapter.title}</h3>\n`;
                    
                    chapter.scenes.forEach((scene, sceneIndex) => {
                        if (options.includeSceneSubtitles && scene.title) {
                            html += `    <h4>${scene.title}</h4>\n`;
                        }
                        
                        if (options.exportSummaries && scene.summary) {
                            html += `    <div class="summary">${scene.summary}</div>\n`;
                        }
                        
                        if (options.exportProse && scene.content) {
                            // Convert line breaks to paragraphs
                            const paragraphs = scene.content.split('\n').filter(p => p.trim());
                            paragraphs.forEach(para => {
                                html += `    <p>${para}</p>\n`;
                            });
                        }
                        
                        if (sceneIndex < chapter.scenes.length - 1 && options.sceneDivider !== 'none') {
                            html += `    <div class="divider">${divider}</div>\n`;
                        }
                    });
                });
            });
            
            html += `</body>\n</html>`;
            
            downloadFile(html, `${project.title}.html`, 'text/html');
            showNotification('✓ Export HTML terminé');
            closeModal('exportNovelModal');
        }

        async function exportAsEPUB(options) {
            if (typeof JSZip === 'undefined') {
                alert('❌ Erreur : La bibliothèque JSZip n\'est pas chargée. Veuillez rafraîchir la page.');
                return;
            }

            const content = getSelectedContent(options);
            const zip = new JSZip();
            const bookId = 'plume-' + Date.now();
            const timestamp = new Date().toISOString().split('.')[0] + 'Z';
            
            // Helper to escape XML
            const escapeXML = (str) => {
                if (!str) return '';
                return str.replace(/&/g, '&amp;')
                         .replace(/</g, '&lt;')
                         .replace(/>/g, '&gt;')
                         .replace(/"/g, '&quot;')
                         .replace(/'/g, '&apos;');
            };
            
            // Helper to convert HTML content to XHTML
            const toXHTML = (text) => {
                if (!text) return '';
                const paragraphs = text.split('\n').filter(p => p.trim());
                return paragraphs.map(p => `<p>${escapeXML(p)}</p>`).join('\n');
            };
            
            // Get scene divider for EPUB
            const getDividerXHTML = () => {
                switch(options.sceneDivider) {
                    case 'asterisks': return '<p class="divider">* * *</p>';
                    case 'hash': return '<p class="divider">###</p>';
                    case 'line': return '<hr class="divider"/>';
                    case 'space': return '<p class="divider-space">&#160;</p>';
                    case 'none': return '';
                    default: return '<p class="divider">* * *</p>';
                }
            };
            
            // 1. mimetype (must be first and uncompressed)
            zip.file('mimetype', 'application/epub+zip', { compression: 'STORE' });
            
            // 2. META-INF/container.xml
            const containerXML = `<?xml version="1.0" encoding="UTF-8"?>
<container version="1.0" xmlns="urn:oasis:names:tc:opendocument:xmlns:container">
  <rootfiles>
    <rootfile full-path="OEBPS/content.opf" media-type="application/oebps-package+xml"/>
  </rootfiles>
</container>`;
            zip.file('META-INF/container.xml', containerXML);
            
            // 3. OEBPS/styles.css
            const stylesCSS = `
body {
    font-family: Georgia, "Times New Roman", serif;
    margin: 1em;
    line-height: 1.6;
}
h1 {
    font-size: 1.8em;
    text-align: center;
    margin: 1em 0;
    page-break-before: always;
}
h2 {
    font-size: 1.4em;
    margin: 1.5em 0 0.5em 0;
    page-break-before: always;
}
h3 {
    font-size: 1.1em;
    font-style: italic;
    margin: 1em 0 0.5em 0;
}
p {
    margin: 0;
    text-indent: 1.5em;
    text-align: justify;
}
p:first-of-type, h1 + p, h2 + p, h3 + p, .divider + p, .divider-space + p, hr + p {
    text-indent: 0;
}
.summary {
    font-style: italic;
    color: #666;
    margin: 1em 0;
    padding: 0.5em;
    border-left: 3px solid #ccc;
    text-indent: 0;
}
.divider {
    text-align: center;
    margin: 1.5em 0;
    text-indent: 0;
}
.divider-space {
    margin: 2em 0;
    text-indent: 0;
}
hr.divider {
    border: none;
    border-top: 1px solid #ccc;
    margin: 1.5em 2em;
}
.title-page {
    text-align: center;
    margin-top: 30%;
}
.title-page h1 {
    page-break-before: avoid;
}
`;
            zip.file('OEBPS/styles.css', stylesCSS);
            
            // 4. Generate chapter files and build manifest/spine
            const manifestItems = [];
            const spineItems = [];
            let chapterNum = 0;
            
            // Title page
            const titlePageXHTML = `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="fr" lang="fr">
<head>
    <meta charset="UTF-8"/>
    <title>${escapeXML(project.title)}</title>
    <link rel="stylesheet" type="text/css" href="styles.css"/>
</head>
<body>
    <div class="title-page">
        <h1>${escapeXML(project.title)}</h1>
    </div>
</body>
</html>`;
            zip.file('OEBPS/title.xhtml', titlePageXHTML);
            manifestItems.push('<item id="title" href="title.xhtml" media-type="application/xhtml+xml"/>');
            spineItems.push('<itemref idref="title"/>');
            
            // NAV document (EPUB 3 navigation)
            let navContent = `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="fr" lang="fr">
<head>
    <meta charset="UTF-8"/>
    <title>Table des matières</title>
    <link rel="stylesheet" type="text/css" href="styles.css"/>
</head>
<body>
    <nav epub:type="toc" id="toc">
        <h1>Table des matières</h1>
        <ol>
            <li><a href="title.xhtml">${escapeXML(project.title)}</a></li>
`;
            
            // Generate chapter files
            content.acts.forEach((act, actIndex) => {
                if (options.includeActTitles) {
                    navContent += `            <li><a href="chapter${chapterNum + 1}.xhtml">${escapeXML(act.title)}</a>
                <ol>\n`;
                }
                
                act.chapters.forEach((chapter, chapIndex) => {
                    chapterNum++;
                    const chapterId = `chapter${chapterNum}`;
                    const fileName = `${chapterId}.xhtml`;
                    
                    let chapterContent = `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="fr" lang="fr">
<head>
    <meta charset="UTF-8"/>
    <title>${escapeXML(chapter.title)}</title>
    <link rel="stylesheet" type="text/css" href="styles.css"/>
</head>
<body>
`;
                    
                    if (options.includeActTitles && chapIndex === 0) {
                        chapterContent += `    <h1>${escapeXML(act.title)}</h1>\n`;
                    }
                    
                    chapterContent += `    <h2>${escapeXML(chapter.title)}</h2>\n`;
                    
                    chapter.scenes.forEach((scene, sceneIndex) => {
                        if (options.includeSceneSubtitles && scene.title) {
                            chapterContent += `    <h3>${escapeXML(scene.title)}</h3>\n`;
                        }
                        
                        if (options.exportSummaries && scene.summary) {
                            chapterContent += `    <p class="summary">${escapeXML(scene.summary)}</p>\n`;
                        }
                        
                        if (options.exportProse && scene.content) {
                            chapterContent += toXHTML(scene.content) + '\n';
                        }
                        
                        if (sceneIndex < chapter.scenes.length - 1 && options.sceneDivider !== 'none') {
                            chapterContent += `    ${getDividerXHTML()}\n`;
                        }
                    });
                    
                    chapterContent += `</body>
</html>`;
                    
                    zip.file(`OEBPS/${fileName}`, chapterContent);
                    manifestItems.push(`<item id="${chapterId}" href="${fileName}" media-type="application/xhtml+xml"/>`);
                    spineItems.push(`<itemref idref="${chapterId}"/>`);
                    
                    if (options.includeActTitles) {
                        navContent += `                    <li><a href="${fileName}">${escapeXML(chapter.title)}</a></li>\n`;
                    } else {
                        navContent += `            <li><a href="${fileName}">${escapeXML(chapter.title)}</a></li>\n`;
                    }
                });
                
                if (options.includeActTitles) {
                    navContent += `                </ol>
            </li>\n`;
                }
            });
            
            navContent += `        </ol>
    </nav>
</body>
</html>`;
            
            zip.file('OEBPS/nav.xhtml', navContent);
            manifestItems.push('<item id="nav" href="nav.xhtml" media-type="application/xhtml+xml" properties="nav"/>');
            
            // 5. content.opf (package document)
            const contentOPF = `<?xml version="1.0" encoding="UTF-8"?>
<package xmlns="http://www.idpf.org/2007/opf" version="3.0" unique-identifier="BookId">
    <metadata xmlns:dc="http://purl.org/dc/elements/1.1/">
        <dc:identifier id="BookId">${bookId}</dc:identifier>
        <dc:title>${escapeXML(project.title)}</dc:title>
        <dc:language>fr</dc:language>
        <dc:creator>Plume</dc:creator>
        <meta property="dcterms:modified">${timestamp}</meta>
    </metadata>
    <manifest>
        <item id="css" href="styles.css" media-type="text/css"/>
        ${manifestItems.join('\n        ')}
    </manifest>
    <spine>
        ${spineItems.join('\n        ')}
    </spine>
</package>`;
            
            zip.file('OEBPS/content.opf', contentOPF);
            
            // Generate the EPUB file
            try {
                const blob = await zip.generateAsync({ 
                    type: 'blob',
                    mimeType: 'application/epub+zip',
                    compression: 'DEFLATE',
                    compressionOptions: { level: 9 }
                });
                saveAs(blob, `${project.title}.epub`);
                showNotification('✓ Export EPUB terminé');
                closeModal('exportNovelModal');
            } catch (error) {
                alert('❌ Erreur lors de l\'export EPUB : ' + error.message);
                console.error(error);
            }
        }

        async function exportAsDOCX(options) {
            // Check if docx library is loaded
            if (typeof docx === 'undefined') {
                alert('❌ Erreur : La bibliothèque DOCX n\'est pas chargée. Veuillez rafraîchir la page.');
                return;
            }

            const content = getSelectedContent(options);
            const { Document, Packer, Paragraph, TextRun, HeadingLevel, AlignmentType } = docx;
            
            const children = [];
            
            // Title
            children.push(
                new Paragraph({
                    text: project.title,
                    heading: HeadingLevel.TITLE,
                    alignment: AlignmentType.CENTER,
                    spacing: { after: 400 }
                })
            );
            
            content.acts.forEach((act, actIndex) => {
                if (options.includeActTitles) {
                    children.push(
                        new Paragraph({
                            text: act.title,
                            heading: HeadingLevel.HEADING_1,
                            spacing: { before: 400, after: 200 }
                        })
                    );
                }
                
                act.chapters.forEach((chapter, chapIndex) => {
                    children.push(
                        new Paragraph({
                            text: chapter.title,
                            heading: HeadingLevel.HEADING_2,
                            spacing: { before: 300, after: 200 }
                        })
                    );
                    
                    chapter.scenes.forEach((scene, sceneIndex) => {
                        if (options.includeSceneSubtitles && scene.title) {
                            children.push(
                                new Paragraph({
                                    text: scene.title,
                                    heading: HeadingLevel.HEADING_3,
                                    spacing: { before: 200, after: 100 }
                                })
                            );
                        }
                        
                        if (options.exportSummaries && scene.summary) {
                            children.push(
                                new Paragraph({
                                    children: [
                                        new TextRun({
                                            text: scene.summary,
                                            italics: true
                                        })
                                    ],
                                    spacing: { after: 200 }
                                })
                            );
                        }
                        
                        if (options.exportProse && scene.content) {
                            const paragraphs = scene.content.split('\n').filter(p => p.trim());
                            paragraphs.forEach(para => {
                                children.push(
                                    new Paragraph({
                                        text: para,
                                        spacing: { after: 200 }
                                    })
                                );
                            });
                        }
                        
                        // Add divider between scenes
                        if (sceneIndex < chapter.scenes.length - 1) {
                            const dividerText = options.sceneDivider === 'asterisks' ? '* * *' :
                                              options.sceneDivider === 'hash' ? '###' :
                                              options.sceneDivider === 'line' ? '---' : '';
                            
                            if (dividerText) {
                                children.push(
                                    new Paragraph({
                                        text: dividerText,
                                        alignment: AlignmentType.CENTER,
                                        spacing: { before: 200, after: 200 }
                                    })
                                );
                            }
                        }
                    });
                });
            });
            
            const doc = new Document({
                sections: [{
                    properties: {},
                    children: children
                }]
            });
            
            try {
                const blob = await Packer.toBlob(doc);
                saveAs(blob, `${project.title}.docx`);
                showNotification('✓ Export DOCX terminé');
                closeModal('exportNovelModal');
            } catch (error) {
                alert('❌ Erreur lors de l\'export DOCX : ' + error.message);
                console.error(error);
            }
        }

        async function exportProjectAsZip(format, options) {
            if (typeof JSZip === 'undefined') {
                alert('❌ Erreur : La bibliothèque JSZip n\'est pas chargée. Veuillez rafraîchir la page.');
                return;
            }

            const zip = new JSZip();
            
            // Add main novel file
            const content = getSelectedContent(options);
            let mainFileContent = '';
            let mainFileName = '';
            
            switch(format) {
                case 'markdown':
                    mainFileContent = await generateMarkdownContent(content, options);
                    mainFileName = `${project.title}.md`;
                    break;
                case 'txt':
                    mainFileContent = await generateTXTContent(content, options);
                    mainFileName = `${project.title}.txt`;
                    break;
                case 'html':
                    mainFileContent = await generateHTMLContent(content, options);
                    mainFileName = `${project.title}.html`;
                    break;
                case 'docx':
                    // DOCX is binary, handled separately below
                    break;
            }
            
            if (format !== 'docx') {
                zip.file(mainFileName, mainFileContent);
            } else {
                // For DOCX, we need to generate the binary blob
                const docxBlob = await generateDOCXBlob(content, options);
                zip.file(`${project.title}.docx`, docxBlob);
            }
            
            // Add Characters if requested
            if (options.includeCharacters && project.characters && project.characters.length > 0) {
                let charactersContent = '# Personnages\n\n';
                project.characters.forEach(char => {
                    charactersContent += `## ${char.name}\n\n`;
                    if (char.role) charactersContent += `**Rôle:** ${char.role}\n\n`;
                    if (char.age) charactersContent += `**Âge:** ${char.age}\n\n`;
                    if (char.description) charactersContent += `**Description:** ${char.description}\n\n`;
                    if (char.background) charactersContent += `**Histoire:** ${char.background}\n\n`;
                    if (char.personality) charactersContent += `**Personnalité:** ${char.personality}\n\n`;
                    if (char.goals) charactersContent += `**Objectifs:** ${char.goals}\n\n`;
                    if (char.strengths) charactersContent += `**Forces:** ${char.strengths}\n\n`;
                    if (char.weaknesses) charactersContent += `**Faiblesses:** ${char.weaknesses}\n\n`;
                    if (char.notes) charactersContent += `**Notes:** ${char.notes}\n\n`;
                    charactersContent += '---\n\n';
                });
                zip.file('Personnages.md', charactersContent);
            }
            
            // Add World/Universe if requested
            if (options.includeWorld && project.world && project.world.length > 0) {
                let worldContent = '# Univers\n\n';
                project.world.forEach(elem => {
                    worldContent += `## ${elem.name}\n\n`;
                    if (elem.type) worldContent += `**Type:** ${elem.type}\n\n`;
                    if (elem.description) worldContent += `${elem.description}\n\n`;
                    if (elem.history) worldContent += `**Histoire:** ${elem.history}\n\n`;
                    if (elem.culture) worldContent += `**Culture:** ${elem.culture}\n\n`;
                    if (elem.geography) worldContent += `**Géographie:** ${elem.geography}\n\n`;
                    if (elem.notes) worldContent += `**Notes:** ${elem.notes}\n\n`;
                    worldContent += '---\n\n';
                });
                zip.file('Univers.md', worldContent);
            }
            
            // Add Timeline if requested
            if (options.includeTimeline && project.timeline && project.timeline.length > 0) {
                let timelineContent = '# Timeline\n\n';
                const sortedEvents = [...project.timeline].sort((a, b) => {
                    if (a.date && b.date) return new Date(a.date) - new Date(b.date);
                    return (a.order || 0) - (b.order || 0);
                });
                sortedEvents.forEach(event => {
                    timelineContent += `## ${event.title}\n\n`;
                    if (event.date) timelineContent += `**Date:** ${event.date}\n\n`;
                    if (event.era) timelineContent += `**Ère:** ${event.era}\n\n`;
                    if (event.description) timelineContent += `${event.description}\n\n`;
                    if (event.characters && event.characters.length > 0) {
                        const charNames = event.characters.map(id => {
                            const char = project.characters?.find(c => c.id === id);
                            return char ? char.name : id;
                        }).join(', ');
                        timelineContent += `**Personnages impliqués:** ${charNames}\n\n`;
                    }
                    timelineContent += '---\n\n';
                });
                zip.file('Timeline.md', timelineContent);
            }
            
            // Add Relations if requested
            if (options.includeRelations && project.relationships && project.relationships.length > 0) {
                let relationsContent = '# Relations entre personnages\n\n';
                project.relationships.forEach(rel => {
                    const char1 = project.characters?.find(c => c.id === rel.source || c.id === rel.from);
                    const char2 = project.characters?.find(c => c.id === rel.target || c.id === rel.to);
                    const name1 = char1 ? char1.name : 'Inconnu';
                    const name2 = char2 ? char2.name : 'Inconnu';
                    relationsContent += `## ${name1} ↔ ${name2}\n\n`;
                    if (rel.type) relationsContent += `**Type:** ${rel.type}\n\n`;
                    if (rel.label) relationsContent += `**Relation:** ${rel.label}\n\n`;
                    if (rel.description) relationsContent += `${rel.description}\n\n`;
                    relationsContent += '---\n\n';
                });
                zip.file('Relations.md', relationsContent);
            }
            
            // Add Codex if requested
            if (options.includeCodex && project.codex && project.codex.length > 0) {
                let codexContent = '# Codex\n\n';
                project.codex.forEach(entry => {
                    codexContent += `## ${entry.title || entry.name}\n\n`;
                    if (entry.category) codexContent += `**Catégorie:** ${entry.category}\n\n`;
                    if (entry.content) codexContent += `${entry.content}\n\n`;
                    if (entry.description) codexContent += `${entry.description}\n\n`;
                    codexContent += '---\n\n';
                });
                zip.file('Codex.md', codexContent);
            }
            
            // Add Notes if requested  
            if (options.includeNotes && project.notes && project.notes.length > 0) {
                let notesContent = '# Notes\n\n';
                project.notes.forEach(note => {
                    notesContent += `## ${note.title}\n\n`;
                    if (note.category) notesContent += `**Catégorie:** ${note.category}\n\n`;
                    if (note.content) notesContent += `${note.content}\n\n`;
                    notesContent += '---\n\n';
                });
                zip.file('Notes.md', notesContent);
            }
            
            // Generate and download ZIP
            try {
                const blob = await zip.generateAsync({ type: 'blob' });
                saveAs(blob, `${project.title}_Export.zip`);
                showNotification('✓ Export du projet complet terminé');
                closeModal('exportNovelModal');
            } catch (error) {
                alert('❌ Erreur lors de la création du ZIP : ' + error.message);
                console.error(error);
            }
        }

        async function generateMarkdownContent(content, options) {
            const divider = getSceneDivider(options.sceneDivider);
            let markdown = `# ${project.title}\n\n`;
            
            content.acts.forEach((act, actIndex) => {
                if (options.includeActTitles) {
                    markdown += `# ${act.title}\n\n`;
                }
                
                act.chapters.forEach((chapter, chapIndex) => {
                    markdown += `## ${chapter.title}\n\n`;
                    
                    chapter.scenes.forEach((scene, sceneIndex) => {
                        if (options.includeSceneSubtitles && scene.title) {
                            markdown += `### ${scene.title}\n\n`;
                        }
                        
                        if (options.exportSummaries && scene.summary) {
                            markdown += `> ${scene.summary}\n\n`;
                        }
                        
                        if (options.exportProse && scene.content) {
                            markdown += `${scene.content}\n`;
                        }
                        
                        if (sceneIndex < chapter.scenes.length - 1) {
                            markdown += divider;
                        }
                    });
                    
                    markdown += '\n\n';
                });
            });
            
            return markdown;
        }

        async function generateTXTContent(content, options) {
            const divider = getSceneDivider(options.sceneDivider);
            let text = `${project.title}\n${'='.repeat(project.title.length)}\n\n`;
            
            content.acts.forEach((act, actIndex) => {
                if (options.includeActTitles) {
                    text += `${act.title}\n${'-'.repeat(act.title.length)}\n\n`;
                }
                
                act.chapters.forEach((chapter, chapIndex) => {
                    text += `${chapter.title}\n\n`;
                    
                    chapter.scenes.forEach((scene, sceneIndex) => {
                        if (options.includeSceneSubtitles && scene.title) {
                            text += `${scene.title}\n\n`;
                        }
                        
                        if (options.exportSummaries && scene.summary) {
                            text += `[Résumé: ${scene.summary}]\n\n`;
                        }
                        
                        if (options.exportProse && scene.content) {
                            text += `${scene.content}\n`;
                        }
                        
                        if (sceneIndex < chapter.scenes.length - 1) {
                            text += divider;
                        }
                    });
                    
                    text += '\n\n';
                });
            });
            
            return text;
        }

        async function generateHTMLContent(content, options) {
            const divider = getSceneDivider(options.sceneDivider).replace(/\n/g, '<br>');
            
            let html = `<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${project.title}</title>
    <style>
        body { font-family: 'Georgia', serif; max-width: 800px; margin: 0 auto; padding: 2rem; line-height: 1.8; color: #333; background: #fafafa; }
        h1 { font-size: 2.5rem; margin-bottom: 2rem; text-align: center; border-bottom: 3px solid #333; padding-bottom: 1rem; }
        h2 { font-size: 2rem; margin-top: 3rem; margin-bottom: 1.5rem; border-bottom: 2px solid #666; padding-bottom: 0.5rem; }
        h3 { font-size: 1.5rem; margin-top: 2rem; margin-bottom: 1rem; color: #666; }
        h4 { font-size: 1.2rem; margin-top: 1.5rem; margin-bottom: 0.75rem; color: #888; font-style: italic; }
        p { margin-bottom: 1rem; text-align: justify; }
        .summary { background: #f0f0f0; padding: 1rem; border-left: 4px solid #999; margin: 1rem 0; font-style: italic; color: #666; }
        .divider { text-align: center; margin: 2rem 0; color: #999; }
    </style>
</head>
<body>
    <h1>${project.title}</h1>
`;
            
            content.acts.forEach((act, actIndex) => {
                if (options.includeActTitles) {
                    html += `    <h2>${act.title}</h2>\n`;
                }
                
                act.chapters.forEach((chapter, chapIndex) => {
                    html += `    <h3>${chapter.title}</h3>\n`;
                    
                    chapter.scenes.forEach((scene, sceneIndex) => {
                        if (options.includeSceneSubtitles && scene.title) {
                            html += `    <h4>${scene.title}</h4>\n`;
                        }
                        
                        if (options.exportSummaries && scene.summary) {
                            html += `    <div class="summary">${scene.summary}</div>\n`;
                        }
                        
                        if (options.exportProse && scene.content) {
                            const paragraphs = scene.content.split('\n').filter(p => p.trim());
                            paragraphs.forEach(para => {
                                html += `    <p>${para}</p>\n`;
                            });
                        }
                        
                        if (sceneIndex < chapter.scenes.length - 1 && options.sceneDivider !== 'none') {
                            html += `    <div class="divider">${divider}</div>\n`;
                        }
                    });
                });
            });
            
            html += `</body>\n</html>`;
            return html;
        }

        async function generateDOCXBlob(content, options) {
            const { Document, Packer, Paragraph, TextRun, HeadingLevel, AlignmentType } = docx;
            
            const children = [];
            
            children.push(
                new Paragraph({
                    text: project.title,
                    heading: HeadingLevel.TITLE,
                    alignment: AlignmentType.CENTER,
                    spacing: { after: 400 }
                })
            );
            
            content.acts.forEach((act, actIndex) => {
                if (options.includeActTitles) {
                    children.push(
                        new Paragraph({
                            text: act.title,
                            heading: HeadingLevel.HEADING_1,
                            spacing: { before: 400, after: 200 }
                        })
                    );
                }
                
                act.chapters.forEach((chapter, chapIndex) => {
                    children.push(
                        new Paragraph({
                            text: chapter.title,
                            heading: HeadingLevel.HEADING_2,
                            spacing: { before: 300, after: 200 }
                        })
                    );
                    
                    chapter.scenes.forEach((scene, sceneIndex) => {
                        if (options.includeSceneSubtitles && scene.title) {
                            children.push(
                                new Paragraph({
                                    text: scene.title,
                                    heading: HeadingLevel.HEADING_3,
                                    spacing: { before: 200, after: 100 }
                                })
                            );
                        }
                        
                        if (options.exportSummaries && scene.summary) {
                            children.push(
                                new Paragraph({
                                    children: [
                                        new TextRun({
                                            text: scene.summary,
                                            italics: true
                                        })
                                    ],
                                    spacing: { after: 200 }
                                })
                            );
                        }
                        
                        if (options.exportProse && scene.content) {
                            const paragraphs = scene.content.split('\n').filter(p => p.trim());
                            paragraphs.forEach(para => {
                                children.push(
                                    new Paragraph({
                                        text: para,
                                        spacing: { after: 200 }
                                    })
                                );
                            });
                        }
                        
                        if (sceneIndex < chapter.scenes.length - 1) {
                            const dividerText = options.sceneDivider === 'asterisks' ? '* * *' :
                                              options.sceneDivider === 'hash' ? '###' :
                                              options.sceneDivider === 'line' ? '---' : '';
                            
                            if (dividerText) {
                                children.push(
                                    new Paragraph({
                                        text: dividerText,
                                        alignment: AlignmentType.CENTER,
                                        spacing: { before: 200, after: 200 }
                                    })
                                );
                            }
                        }
                    });
                });
            });
            
            const doc = new Document({
                sections: [{
                    properties: {},
                    children: children
                }]
            });
            
            return await Packer.toBlob(doc);
        }

        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: `${mimeType};charset=utf-8` });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }

        // ============================================
        // MOBILE SIDEBAR VIEWS
        // ============================================
        
        function renderMobileSidebarView(view) {
            const editorView = document.getElementById('editorView');
            if (!editorView) return;
            
            const viewConfig = {
                editor: {
                    icon: '📝',
                    title: 'Structure de votre roman',
                    description: 'Organisez votre roman en actes, chapitres et scènes',
                    emptyMessage: 'Aucun acte créé',
                    emptySubMessage: 'Commencez par créer votre premier acte pour structurer votre histoire',
                    actionButton: '<button class="btn btn-primary" style="font-size: 1.2rem; padding: 1rem 2rem;" onclick="openAddActModal()">+ Créer un acte</button>',
                    sidebarHint: 'Utilisez la poignée dorée sur le bord gauche pour naviguer dans votre structure'
                },
                characters: {
                    icon: '👥',
                    title: 'Personnages',
                    description: 'Gérez vos personnages et leurs caractéristiques',
                    emptyMessage: 'Aucun personnage créé',
                    emptySubMessage: 'Créez votre premier personnage pour donner vie à votre histoire',
                    actionButton: '<button class="btn btn-primary" style="font-size: 1.2rem; padding: 1rem 2rem;" onclick="openAddCharacterModal()">+ Créer un personnage</button>',
                    sidebarHint: 'Utilisez la poignée dorée sur le bord gauche pour voir la liste complète'
                },
                world: {
                    icon: '🌍',
                    title: 'Univers',
                    description: 'Créez les éléments de votre monde (lieux, objets, concepts)',
                    emptyMessage: 'Aucun élément créé',
                    emptySubMessage: 'Ajoutez des lieux, objets ou concepts pour enrichir votre univers',
                    actionButton: '<button class="btn btn-primary" style="font-size: 1.2rem; padding: 1rem 2rem;" onclick="openAddWorldModal()">+ Créer un élément</button>',
                    sidebarHint: 'Utilisez la poignée dorée sur le bord gauche pour voir tous vos éléments'
                },
                notes: {
                    icon: '📋',
                    title: 'Notes',
                    description: 'Prenez des notes et organisez vos recherches',
                    emptyMessage: 'Aucune note créée',
                    emptySubMessage: 'Créez des notes pour garder vos idées et recherches organisées',
                    actionButton: '<button class="btn btn-primary" style="font-size: 1.2rem; padding: 1rem 2rem;" onclick="openAddNoteModal()">+ Créer une note</button>',
                    sidebarHint: 'Utilisez la poignée dorée sur le bord gauche pour voir toutes vos notes'
                },
                codex: {
                    icon: '📖',
                    title: 'Codex',
                    description: 'Wiki de votre univers - glossaire et encyclopédie',
                    emptyMessage: 'Aucune entrée dans le codex',
                    emptySubMessage: 'Créez des entrées pour documenter votre univers',
                    actionButton: '<button class="btn btn-primary" style="font-size: 1.2rem; padding: 1rem 2rem;" onclick="openAddCodexModal()">+ Créer une entrée</button>',
                    sidebarHint: 'Utilisez la poignée dorée sur le bord gauche pour parcourir le codex'
                }
            };
            
            const config = viewConfig[view];
            if (!config) return;
            
            // Vérifier si vide
            let isEmpty = false;
            let count = 0;
            
            if (view === 'editor') {
                isEmpty = !project.acts || project.acts.length === 0;
                count = project.acts ? project.acts.length : 0;
            } else if (view === 'characters') {
                isEmpty = !project.characters || project.characters.length === 0;
                count = project.characters ? project.characters.length : 0;
            } else if (view === 'world') {
                isEmpty = !project.world || project.world.length === 0;
                count = project.world ? project.world.length : 0;
            } else if (view === 'notes') {
                isEmpty = !project.notes || project.notes.length === 0;
                count = project.notes ? project.notes.length : 0;
            } else if (view === 'codex') {
                isEmpty = !project.codex || project.codex.length === 0;
                count = project.codex ? project.codex.length : 0;
            }
            
            let html = `
                <div class="empty-state" style="padding: 2rem 1.5rem; text-align: center;">
                    <div class="empty-state-icon" style="font-size: 4rem; margin-bottom: 1rem;">
                        ${config.icon}
                    </div>
                    <div class="empty-state-title" style="font-size: 1.5rem; font-weight: 600; margin-bottom: 0.5rem; color: var(--text-primary);">
                        ${config.title}
                    </div>
                    <div class="empty-state-text" style="color: var(--text-secondary); margin-bottom: 1.5rem; line-height: 1.6;">
                        ${config.description}
                    </div>
            `;
            
            if (isEmpty) {
                html += `
                    <div style="background: var(--bg-secondary); padding: 1.5rem; border-radius: 8px; margin-bottom: 1.5rem; border-left: 3px solid var(--accent-gold);">
                        <div style="font-weight: 600; margin-bottom: 0.5rem; color: var(--text-primary);">
                            ${config.emptyMessage}
                        </div>
                        <div style="color: var(--text-secondary); font-size: 0.95rem;">
                            ${config.emptySubMessage}
                        </div>
                    </div>
                    ${config.actionButton}
                `;
            } else {
                html += `
                    <div style="background: var(--bg-secondary); padding: 1.5rem; border-radius: 8px; margin-bottom: 1.5rem;">
                        <div style="font-size: 2rem; font-weight: bold; color: var(--accent-gold); margin-bottom: 0.5rem;">
                            ${count}
                        </div>
                        <div style="color: var(--text-secondary);">
                            ${count === 1 ? 'élément' : 'éléments'}
                        </div>
                    </div>
                    ${config.actionButton}
                `;
            }
            
            html += `
                    <div style="margin-top: 2rem; padding: 1rem; background: rgba(212, 175, 55, 0.1); border-radius: 8px; border: 1px solid var(--accent-gold);">
                        <div style="font-size: 1.2rem; margin-bottom: 0.5rem;">💡</div>
                        <div style="font-size: 0.9rem; color: var(--text-secondary); line-height: 1.6;">
                            ${config.sidebarHint}
                        </div>
                    </div>
                </div>
            `;
            
            editorView.innerHTML = html;
        }
        
        // ============================================
        // END MOBILE SIDEBAR VIEWS
        // ============================================

        // ============================================
        // STORAGE QUOTA MONITORING FUNCTIONS
        // ============================================

        let storageWarningShown = false;
        let storageCriticalShown = false;

        function initStorageMonitoring() {
            console.log('🔍 Initialisation de la surveillance du stockage IndexedDB...');
            
            // Vérifier que les éléments existent
            const badge = document.getElementById('storage-badge');
            const percentage = document.getElementById('storage-percentage');
            
            if (!badge) {
                console.error('❌ Badge de stockage introuvable dans le DOM');
                return;
            }
            
            if (!percentage) {
                console.error('❌ Élément storage-percentage introuvable');
                return;
            }
            
            console.log('✅ Éléments trouvés, mise à jour du badge...');
            updateStorageBadge();
            checkStorageQuota();
            console.log('✅ Surveillance du stockage initialisée');
        }

        async function getStorageSize() {
            try {
                // Utiliser l'API Storage Estimate pour obtenir la taille réelle
                if ('storage' in navigator && 'estimate' in navigator.storage) {
                    const estimate = await navigator.storage.estimate();
                    return {
                        used: estimate.usage || 0,
                        quota: estimate.quota || (50 * 1024 * 1024) // Default 50 MB si non disponible
                    };
                } else {
                    // Fallback : calculer la taille approximative d'IndexedDB
                    const size = await getIndexedDBSize();
                    return {
                        used: size,
                        quota: 50 * 1024 * 1024 // 50 MB par défaut
                    };
                }
            } catch (error) {
                console.error('❌ Erreur calcul taille stockage:', error);
                return {
                    used: 0,
                    quota: 50 * 1024 * 1024
                };
            }
        }

        function formatBytes(bytes) {
            if (bytes === 0) return '0 MB';
            const mb = bytes / (1024 * 1024);
            return mb.toFixed(2) + ' MB';
        }

        async function updateStorageBadge() {
            try {
                const { used, quota } = await getStorageSize();
                const percentage = Math.min(100, Math.round((used / quota) * 100));
                
                const badge = document.getElementById('storage-badge');
                const percentageText = document.getElementById('storage-percentage');
                
                if (!badge || !percentageText) return;
                
                percentageText.textContent = percentage + '%';
                
                // Update badge status
                badge.className = 'storage-badge';
                if (percentage >= 95) {
                    badge.classList.add('status-danger');
                } else if (percentage >= 80) {
                    badge.classList.add('status-warning');
                } else {
                    badge.classList.add('status-ok');
                }
                
                // Check and show warnings
                await checkStorageQuota();
            } catch (error) {
                console.error('❌ Erreur mise à jour badge:', error);
            }
        }

        async function checkStorageQuota() {
            try {
                const { used, quota } = await getStorageSize();
                const percentage = (used / quota) * 100;
                
                if (percentage >= 95 && !storageCriticalShown) {
                    storageCriticalShown = true;
                    showStorageAlert(
                        '🚨 Espace critique !',
                        `Vous avez utilisé ${Math.round(percentage)}% de l'espace disponible (${formatBytes(used)} / ${formatBytes(quota)}).\n\n` +
                        `⚠️ ATTENTION : Vous risquez de perdre vos données !\n\n` +
                        `Actions urgentes :\n` +
                        `• Exportez immédiatement votre projet en JSON\n` +
                        `• Supprimez des versions anciennes\n` +
                        `• Réduisez le nombre de notes\n\n` +
                        `Voulez-vous exporter maintenant ?`,
                        'danger'
                    );
                } else if (percentage >= 80 && !storageWarningShown) {
                    storageWarningShown = true;
                    showStorageAlert(
                        '⚠️ Espace limité',
                        `Vous avez utilisé ${Math.round(percentage)}% de l'espace disponible.\n\n` +
                        `Recommandations :\n` +
                        `• Exportez régulièrement votre projet\n` +
                        `• Surveillez votre utilisation\n` +
                        `• Pensez à nettoyer les anciennes versions`,
                        'warning'
                    );
                }
                
                // Reset warnings if space freed
                if (percentage < 80) {
                    storageWarningShown = false;
                    storageCriticalShown = false;
                }
            } catch (error) {
                console.error('❌ Erreur vérification quota:', error);
            }
        }

        function showStorageAlert(title, message, level) {
            if (confirm(`${title}\n\n${message}`)) {
                if (level === 'danger') {
                    showExportModal();
                } else {
                    showStorageDetails();
                }
            }
        }

        async function showStorageDetails() {
            try {
                const { used, quota } = await getStorageSize();
                const percentage = Math.min(100, Math.round((used / quota) * 100));
                const available = quota - used;
                
                // Update storage bar
                const barFill = document.getElementById('storage-bar-fill');
                const barText = document.getElementById('storage-bar-text');
                
                if (barFill && barText) {
                    barFill.style.width = percentage + '%';
                    barText.textContent = percentage + '%';
                    
                    // Update bar color
                    barFill.className = 'storage-bar-fill';
                    if (percentage >= 95) {
                        barFill.classList.add('danger');
                    } else if (percentage >= 80) {
                        barFill.classList.add('warning');
                    } else {
                        barFill.classList.add('ok');
                    }
                }
                
                // Update stats
                const usedEl = document.getElementById('storage-used');
                const availableEl = document.getElementById('storage-available');
                
                if (usedEl) usedEl.textContent = formatBytes(used);
                if (availableEl) availableEl.textContent = formatBytes(available);
                
                // Update recommendations
                const recommendationsContainer = document.getElementById('storage-recommendations-container');
                const recommendationsDetails = document.getElementById('storage-recommendations-details');
                const recommendationsSummary = recommendationsDetails ? recommendationsDetails.querySelector('summary') : null;
                
                if (recommendationsContainer && recommendationsSummary) {
                    let recommendations = '';
                    let summaryText = '';
                    let summaryColor = 'var(--accent-green)';
                    
                    if (percentage >= 95) {
                        summaryText = '🚨 Actions urgentes';
                        summaryColor = 'var(--accent-red)';
                        recommendations = `
                            <ul style="font-size: 0.8rem; color: var(--text-secondary); line-height: 1.5; padding-left: 1.25rem; margin: 0;">
                                <li>Exportez immédiatement votre projet en JSON</li>
                                <li>Supprimez des versions anciennes</li>
                                <li>Réduisez le nombre de notes archivées</li>
                            </ul>
                        `;
                        // Ouvrir automatiquement si urgent
                        recommendationsDetails.open = true;
                    } else if (percentage >= 80) {
                        summaryText = '⚠️ Attention requise';
                        summaryColor = 'var(--accent-gold)';
                        recommendations = `
                            <ul style="font-size: 0.8rem; color: var(--text-secondary); line-height: 1.5; padding-left: 1.25rem; margin: 0;">
                                <li>Exportez régulièrement votre projet</li>
                                <li>Surveillez l'évolution de votre utilisation</li>
                                <li>Nettoyez les versions inutilisées</li>
                            </ul>
                        `;
                    } else {
                        summaryText = '✅ Espace suffisant';
                        summaryColor = 'var(--accent-green)';
                        recommendations = `
                            <ul style="font-size: 0.8rem; color: var(--text-secondary); line-height: 1.5; padding-left: 1.25rem; margin: 0;">
                                <li>Continuez à exporter régulièrement</li>
                                <li>Votre projet est dans la limite normale</li>
                                <li>IndexedDB : ${formatBytes(quota)} disponibles</li>
                            </ul>
                        `;
                    }
                    
                    recommendationsSummary.textContent = summaryText;
                    recommendationsSummary.style.color = summaryColor;
                    recommendationsContainer.innerHTML = recommendations;
                }
                
                // Show modal using Plume's modal system
                const modal = document.getElementById('storage-modal');
                if (modal) {
                    modal.classList.add('active');
                } else {
                    console.error('Modal storage-modal not found!');
                }
            } catch (error) {
                console.error('❌ Erreur affichage détails stockage:', error);
            }
        }

        function handleStorageError() {
            alert(
                '🚨 ERREUR DE SAUVEGARDE\n\n' +
                'Impossible de sauvegarder : espace de stockage insuffisant.\n\n' +
                'Actions à faire MAINTENANT :\n' +
                '1. Exportez votre projet en JSON\n' +
                '2. Supprimez des versions anciennes\n' +
                '3. Libérez de l\'espace\n\n' +
                'Sans cela, vos modifications récentes seront perdues !'
            );
            showStorageDetails();
        }

        // Avertir avant de quitter si l'espace est critique
        window.addEventListener('beforeunload', async function(e) {
            try {
                const { used, quota } = await getStorageSize();
                const percentage = (used / quota) * 100;
                
                if (percentage >= 95) {
                    e.preventDefault();
                    e.returnValue = 'ATTENTION : Votre espace de stockage est presque plein. Pensez à exporter votre projet !';
                    return e.returnValue;
                }
            } catch (error) {
                console.error('❌ Erreur vérification avant fermeture:', error);
            }
        });

        // ============================================
        // END STORAGE QUOTA MONITORING FUNCTIONS
        // ============================================

        // ============================================
        // MOBILE SWIPE GESTURE SUPPORT
        // ============================================
        
        let touchStartX = 0;
        let touchStartY = 0;
        let touchEndX = 0;
        let touchEndY = 0;
        
        // Détecter le swipe depuis le bord gauche
        document.addEventListener('touchstart', function(e) {
            touchStartX = e.changedTouches[0].screenX;
            touchStartY = e.changedTouches[0].screenY;
        }, false);
        
        document.addEventListener('touchend', function(e) {
            touchEndX = e.changedTouches[0].screenX;
            touchEndY = e.changedTouches[0].screenY;
            handleSwipe();
        }, false);
        
        function handleSwipe() {
            const diffX = touchEndX - touchStartX;
            const diffY = touchEndY - touchStartY;
            
            // Vérifier que c'est un swipe horizontal (pas vertical)
            if (Math.abs(diffX) > Math.abs(diffY)) {
                // Swipe depuis le bord gauche (moins de 50px du bord)
                if (touchStartX < 50 && diffX > 50) {
                    // Swipe vers la droite depuis le bord gauche
                    const sidebar = document.querySelector('.sidebar');
                    if (sidebar && !sidebar.classList.contains('mobile-open')) {
                        toggleMobileSidebar();
                    }
                }
                // Swipe vers la gauche pour fermer
                else if (diffX < -50) {
                    const sidebar = document.querySelector('.sidebar');
                    if (sidebar && sidebar.classList.contains('mobile-open')) {
                        toggleMobileSidebar();
                    }
                }
            }
        }
        
        // ============================================
        // END MOBILE SWIPE GESTURE SUPPORT
        // ============================================

        // ============================================
        // END EXPORT NOVEL FUNCTIONS
        // ============================================

        init();
        themeManager.init();
        
        // Initialize Lucide icons
        if (typeof lucide !== 'undefined') {
            lucide.createIcons();
        }
    </script>
</body>
</html>
