<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Outil d'Écriture - Organisation par Chapitres</title>
    <link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:wght@300;400;600;700&family=Noto+Serif+JP:wght@300;500;700&family=Source+Code+Pro:wght@400;500&display=swap" rel="stylesheet">
    <!-- Export Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/docx/7.8.2/docx.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        :root {
            --bg-primary: #faf9f6;
            --bg-secondary: #f5f3ed;
            --bg-accent: #2a2622;
            --text-primary: #2a2622;
            --text-secondary: #5a5550;
            --text-muted: #8a847d;
            --border-color: #d4cfc5;
            --accent-red: #c44536;
            --accent-gold: #d4af37;
            --shadow: rgba(42, 38, 34, 0.08);
            
            /* Revision colors */
            --highlight-yellow: rgba(255, 235, 59, 0.4);
            --highlight-green: rgba(76, 175, 80, 0.3);
            --highlight-blue: rgba(33, 150, 243, 0.3);
            --highlight-red: rgba(244, 67, 54, 0.3);
            --highlight-purple: rgba(156, 39, 176, 0.3);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: 'Crimson Pro', serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
        }

        .app-container {
            display: grid;
            grid-template-rows: 60px 1fr;
            grid-template-columns: 280px 1fr;
            height: 100vh;
            grid-template-areas:
                "header header"
                "sidebar main";
        }
        
        /* Top Header */
        .app-header {
            grid-area: header;
            background: var(--bg-secondary);
            border-bottom: 2px solid var(--accent-gold);
            display: flex;
            align-items: center;
            padding: 0 2rem;
            gap: 2rem;
            position: relative;
            z-index: 1000;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        
        .app-logo {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-size: 1.3rem;
            font-weight: 600;
            color: var(--accent-gold);
            font-family: 'Noto Serif JP', serif;
            white-space: nowrap;
            flex-shrink: 0;
        }
        
        .app-logo-icon {
            font-size: 1.5rem;
        }
        
        .header-nav {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex: 1;
            overflow-x: auto;
            overflow-y: hidden;
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE/Edge */
        }
        
        .header-nav::-webkit-scrollbar {
            display: none; /* Chrome/Safari */
        }
        
        .nav-group {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            padding-right: 1rem;
            border-right: 1px solid var(--border-color);
            flex-shrink: 0;
        }
        
        .nav-group:last-child {
            border-right: none;
        }
        
        .nav-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 0.25rem;
            padding: 0.5rem 0.5rem;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-family: 'Crimson Pro', serif;
            font-size: 0.7rem;
            border-radius: 4px;
            transition: all 0.2s ease;
            white-space: nowrap;
            flex-shrink: 0;
            min-width: 60px;
        }
        
        .nav-btn:hover {
            background: rgba(212, 175, 55, 0.1);
            color: var(--accent-gold);
        }
        
        .nav-btn.active {
            background: var(--accent-gold);
            color: var(--bg-primary);
            font-weight: 600;
        }
        
        .nav-btn-icon {
            font-size: 1.3rem;
            line-height: 1;
        }
        
        .nav-btn-text {
            font-size: 0.7rem;
            line-height: 1;
        }
        
        .header-actions {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-left: auto;
            flex-shrink: 0;
        }
        
        .header-action-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 36px;
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            cursor: pointer;
            font-size: 1.1rem;
            border-radius: 4px;
            transition: all 0.2s ease;
        }
        
        .header-action-btn:hover:not(:disabled) {
            background: var(--accent-gold);
            color: white;
            border-color: var(--accent-gold);
        }
        
        .header-action-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        /* Sidebar Navigation */
        .sidebar {
            grid-area: sidebar;
            background: var(--bg-secondary);
            border-right: 2px solid var(--border-color);
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
        }

        .sidebar::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 100%;
            background: 
                repeating-linear-gradient(
                    90deg,
                    transparent,
                    transparent 19px,
                    var(--border-color) 19px,
                    var(--border-color) 20px
                );
            opacity: 0.3;
            pointer-events: none;
        }

        .sidebar-header {
            padding: 1.5rem 1rem 1rem;
            border-bottom: 1px solid var(--border-color);
            position: relative;
            z-index: 2600;
            flex-shrink: 0;
        }

        .search-container {
            position: relative;
            margin-bottom: 1rem;
            z-index: 10;
        }

        .search-input {
            width: 100%;
            padding: 0.75rem 2.5rem 0.75rem 1rem;
            border: 1px solid var(--border-color);
            background: var(--bg-primary);
            font-family: 'Crimson Pro', serif;
            font-size: 0.9rem;
            color: var(--text-primary);
            border-radius: 2px;
            outline: none;
            transition: all 0.2s ease;
        }

        .search-input:focus {
            border-color: var(--accent-gold);
            box-shadow: 0 0 0 2px rgba(212, 175, 55, 0.1);
        }

        .search-icon {
            position: absolute;
            right: 0.75rem;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-muted);
            font-size: 1.2rem;
            pointer-events: none;
        }

        .search-results {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--bg-primary);
            border: 2px solid var(--accent-gold);
            border-radius: 4px;
            max-height: 400px;
            overflow-y: auto;
            z-index: 20;
            box-shadow: 0 4px 16px var(--shadow);
            margin-top: 0.5rem;
            display: none;
        }

        .search-results.active {
            display: block;
        }

        .search-result-item {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .search-result-item:last-child {
            border-bottom: none;
        }

        .search-result-item:hover {
            background: rgba(212, 175, 55, 0.1);
        }

        .search-result-type {
            font-size: 0.7rem;
            padding: 0.2rem 0.5rem;
            background: var(--accent-gold);
            color: var(--bg-primary);
            border-radius: 2px;
            margin-bottom: 0.5rem;
            display: inline-block;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            font-weight: 600;
        }

        .search-result-title {
            font-size: 0.9rem;
            font-weight: 600;
            margin-bottom: 0.25rem;
            color: var(--text-primary);
        }

        .search-result-path {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-bottom: 0.5rem;
        }

        .search-result-preview {
            font-size: 0.8rem;
            color: var(--text-secondary);
            line-height: 1.4;
        }

        .search-highlight {
            background: rgba(212, 175, 55, 0.3);
            font-weight: 600;
            padding: 0 2px;
        }

        .search-no-results {
            padding: 2rem;
            text-align: center;
            color: var(--text-muted);
            font-style: italic;
        }

        .view-tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .view-tab {
            flex: 1;
            padding: 0.5rem;
            border: 1px solid var(--border-color);
            background: var(--bg-primary);
            color: var(--text-secondary);
            cursor: pointer;
            font-family: 'Crimson Pro', serif;
            font-size: 0.85rem;
            font-weight: 500;
            transition: all 0.2s ease;
            border-radius: 2px;
            text-align: center;
        }

        .view-tab:hover {
            background: var(--bg-secondary);
        }

        .view-tab.active {
            background: var(--accent-gold);
            color: var(--bg-primary);
            border-color: var(--accent-gold);
        }

        .project-title {
            font-family: 'Noto Serif JP', serif;
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
            letter-spacing: 0.02em;
        }

        .project-stats {
            font-size: 0.85rem;
            color: var(--text-muted);
            font-weight: 300;
            display: flex;
            gap: 1rem;
        }

        .chapters-list {
            flex: 1;
            overflow-y: auto;
            padding: 1rem 0;
            position: relative;
            z-index: 1;
        }

        .database-list {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
            position: relative;
            z-index: 1;
        }
        
        .database-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 1rem;
            margin-bottom: 0.75rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .database-card:hover {
            border-color: var(--accent-gold);
            background: rgba(212, 175, 55, 0.05);
            transform: translateX(2px);
        }

        /* Acts Hierarchy */
        .act-group {
            margin-bottom: 1rem;
        }

        .act-header {
            padding: 0.5rem 1rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            transition: all 0.2s ease;
            position: relative;
            background: linear-gradient(to right, rgba(196, 69, 54, 0.1), transparent);
            border-left: 4px solid var(--accent-red);
            font-weight: 600;
        }

        .act-header:hover {
            background: linear-gradient(to right, rgba(196, 69, 54, 0.15), transparent);
        }

        .act-header.active {
            background: var(--accent-red);
            color: var(--bg-primary);
        }

        .act-icon {
            font-size: 0.75rem;
            transition: transform 0.2s ease;
            color: var(--accent-red);
        }

        .act-header.active .act-icon {
            color: var(--bg-primary);
        }

        .act-icon.expanded {
            transform: rotate(90deg);
        }

        .act-title {
            flex: 1;
            font-size: 0.95rem;
            font-family: 'Noto Serif JP', serif;
            letter-spacing: 0.02em;
        }

        .act-count {
            font-size: 0.75rem;
            opacity: 0.7;
            font-family: 'Source Code Pro', monospace;
        }

        .act-chapters {
            display: none;
            padding-left: 0.5rem;
        }

        .act-chapters.visible {
            display: block;
        }

        .chapter-group {
            margin-bottom: 0.25rem;
        }

        .chapter-header {
            padding: 0.4rem 1rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            transition: all 0.2s ease;
            position: relative;
        }

        .chapter-header:hover {
            background: rgba(212, 175, 55, 0.08);
        }

        .chapter-header.active {
            background: var(--accent-gold);
            color: var(--bg-primary);
        }

        .chapter-icon {
            font-size: 0.75rem;
            transition: transform 0.2s ease;
            color: var(--text-muted);
        }

        .chapter-header.active .chapter-icon {
            color: var(--bg-primary);
        }

        .chapter-icon.expanded {
            transform: rotate(90deg);
        }

        .chapter-title {
            flex: 1;
            font-size: 0.9rem;
            font-weight: 600;
            letter-spacing: 0.01em;
        }

        .chapter-count {
            font-size: 0.75rem;
            opacity: 0.7;
            font-family: 'Source Code Pro', monospace;
        }

        .scenes-list {
            display: none;
            padding-left: 1rem;
        }

        .scenes-list.visible {
            display: block;
        }

        .scene-item {
            padding: 0.35rem 1rem;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s ease;
            border-left: 2px solid transparent;
            color: var(--text-secondary);
        }

        .scene-item:hover {
            background: var(--bg-secondary);
            border-left-color: var(--accent-red);
        }

        .scene-item.active {
            background: rgba(196, 69, 54, 0.1);
            border-left-color: var(--accent-red);
            color: var(--text-primary);
            font-weight: 500;
        }

        .sidebar-actions {
            padding: 1rem 1.5rem;
            border-top: 1px solid var(--border-color);
            display: flex;
            gap: 0.5rem;
            position: relative;
            z-index: 1;
            flex-shrink: 0;
        }

        /* Main Editor */
        .editor-container {
            grid-area: main;
            display: flex;
            flex-direction: column;
            background: var(--bg-primary);
            height: calc(100vh - 60px);
            overflow: hidden;
        }

        .editor-fixed-top {
            flex-shrink: 0;
            z-index: 100;
        }

        .editor-header {
            padding: 2rem 3rem 1rem;
            border-bottom: 1px solid var(--border-color);
            background: var(--bg-primary);
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }

        .editor-breadcrumb {
            font-size: 0.85rem;
            color: var(--text-muted);
            margin-bottom: 0.75rem;
            font-weight: 300;
        }

        .editor-title {
            font-family: 'Noto Serif JP', serif;
            font-size: 2rem;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
            letter-spacing: 0.01em;
        }

        .editor-meta {
            display: flex;
            gap: 2rem;
            font-size: 0.85rem;
            color: var(--text-muted);
            font-family: 'Source Code Pro', monospace;
        }

        .editor-toolbar {
            display: flex;
            gap: 0.5rem;
            padding: 1rem 3rem;
            border-bottom: 1px solid var(--border-color);
            background: var(--bg-secondary);
            flex-wrap: wrap;
            align-items: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
            /* On desktop, always visible */
            max-height: none;
            overflow: visible;
        }

        .links-panel-sticky {
            padding: 1rem 3rem;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }

        .editor-workspace {
            flex: 1 1 auto;
            overflow-y: scroll;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
        }

        .editor-content {
            max-width: 750px;
            margin: 0 auto;
            padding: 3rem;
        }

        .editor-textarea {
            width: 100%;
            min-height: 1200px;
            border: none;
            background: transparent;
            font-family: 'Crimson Pro', serif;
            font-size: 1.15rem;
            line-height: 1.8;
            color: var(--text-primary);
            outline: none;
            font-weight: 400;
        }

        .editor-textarea:focus {
            outline: none;
        }

        .editor-textarea::placeholder {
            color: var(--text-muted);
            font-style: italic;
        }

        /* Buttons */
        .btn {
            padding: 0.6rem 1.2rem;
            border: 1px solid var(--border-color);
            background: var(--bg-primary);
            color: var(--text-primary);
            cursor: pointer;
            font-family: 'Crimson Pro', serif;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.2s ease;
            border-radius: 2px;
        }

        .btn:hover {
            background: var(--bg-accent);
            color: var(--bg-primary);
            border-color: var(--bg-accent);
        }

        .btn-primary {
            background: var(--accent-red);
            color: var(--bg-primary);
            border-color: var(--accent-red);
        }

        .btn-primary:hover {
            background: #a33829;
            border-color: #a33829;
        }

        .btn-small {
            padding: 0.4rem 0.8rem;
            font-size: 0.8rem;
        }

        .btn-icon {
            padding: 0.5rem;
            width: 32px;
            height: 32px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        /* Empty State */
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            text-align: center;
            padding: 3rem;
        }

        .empty-state-icon {
            font-size: 4rem;
            margin-bottom: 1.5rem;
            opacity: 0.3;
        }

        .empty-state-title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: var(--text-primary);
        }

        .empty-state-text {
            color: var(--text-muted);
            margin-bottom: 1.5rem;
            max-width: 400px;
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(42, 38, 34, 0.6);
            backdrop-filter: blur(4px);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: var(--bg-primary);
            padding: 2rem;
            border-radius: 4px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 8px 32px var(--shadow);
            border: 2px solid var(--border-color);
        }
        
        /* Modal overlay pour thèmes */
        .modal-overlay {
            display: flex;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(42, 38, 34, 0.85);
            backdrop-filter: blur(4px);
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 1rem;
            margin-bottom: 1.5rem;
            border-bottom: 2px solid var(--accent-gold);
        }
        
        .modal-header h2 {
            margin: 0;
            font-family: 'Noto Serif JP', serif;
        }
        
        .modal-close {
            background: transparent;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--text-muted);
            padding: 0.25rem 0.5rem;
            line-height: 1;
            transition: color 0.2s;
        }
        
        .modal-close:hover {
            color: var(--accent-red);
        }

        .modal-title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 1.5rem;
            font-family: 'Noto Serif JP', serif;
        }

        .form-group {
            margin-bottom: 1.5rem;
        }

        .form-label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: var(--text-secondary);
        }

        .form-input {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid var(--border-color);
            background: var(--bg-secondary);
            font-family: 'Crimson Pro', serif;
            font-size: 1rem;
            color: var(--text-primary);
            border-radius: 2px;
            outline: none;
            transition: all 0.2s ease;
        }

        .form-input:focus {
            border-color: var(--accent-gold);
            background: var(--bg-primary);
        }

        /* Detail View Styles (Characters, World, etc.) */
        .detail-view {
            padding: 2rem 3rem;
            max-width: 1400px;
            width: 100%;
            margin: 0 auto;
            height: 100vh;
            overflow-y: auto;
            box-sizing: border-box;
        }
        
        .detail-header {
            padding: 1.5rem;
            background: var(--bg-secondary);
            border-radius: 4px;
            margin-bottom: 2rem;
            border-left: 4px solid var(--accent-red);
        }
        
        .detail-title {
            font-size: 1.8rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--text-primary);
            font-family: 'Noto Serif JP', serif;
        }
        
        .detail-section {
            background: var(--bg-secondary);
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            border-radius: 4px;
            border: 1px solid var(--border-color);
        }
        
        .detail-section-title {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--text-primary);
            padding-bottom: 0.75rem;
            border-bottom: 2px solid var(--border-color);
        }
        
        .detail-field {
            margin-bottom: 1.25rem;
        }
        
        .detail-field:last-child {
            margin-bottom: 0;
        }
        
        .detail-label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: var(--text-secondary);
            font-size: 0.95rem;
        }

        .modal-actions {
            display: flex;
            gap: 0.75rem;
            justify-content: flex-end;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 12px;
            height: 12px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 6px;
            border: 2px solid var(--bg-secondary);
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }

        /* Better scrollbar for editor workspace */
        .editor-workspace::-webkit-scrollbar-thumb {
            background: var(--accent-gold);
            border: 2px solid var(--bg-primary);
        }

        .editor-workspace::-webkit-scrollbar-thumb:hover {
            background: var(--accent-red);
        }

        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .chapter-group {
            animation: fadeIn 0.3s ease forwards;
        }

        .delete-btn {
            opacity: 0;
            margin-left: auto;
            transition: opacity 0.2s ease;
        }

        .chapter-header:hover .delete-btn,
        .scene-item:hover .delete-btn {
            opacity: 1;
        }

        .scene-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        /* Drag and Drop */
        .draggable {
            cursor: move;
        }

        .draggable:active {
            cursor: grabbing;
        }

        .drag-over {
            background: rgba(212, 175, 55, 0.2);
            border-left: 3px solid var(--accent-gold);
        }

        .dragging {
            opacity: 0.5;
            background: var(--bg-accent);
            color: var(--bg-primary);
        }

        .drag-handle {
            cursor: grab;
            padding: 0 0.5rem;
            color: var(--text-muted);
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .chapter-header:hover .drag-handle,
        .scene-item:hover .drag-handle {
            opacity: 1;
        }

        .drag-handle:active {
            cursor: grabbing;
        }

        /* Inline Editing */
        .editing-input {
            background: var(--bg-primary);
            border: 2px solid var(--accent-gold);
            padding: 0.25rem 0.5rem;
            font-family: 'Crimson Pro', serif;
            font-size: inherit;
            font-weight: inherit;
            color: var(--text-primary);
            border-radius: 2px;
            outline: none;
            width: 100%;
        }

        .chapter-title,
        .scene-item > div > span:not(.drag-handle) {
            cursor: text;
        }

        .chapter-title:hover,
        .scene-item > div > span:not(.drag-handle):hover {
            background: rgba(212, 175, 55, 0.1);
            padding: 0.25rem 0.5rem;
            margin: -0.25rem -0.5rem;
            border-radius: 2px;
        }

        .edit-hint {
            font-size: 0.7rem;
            color: var(--text-muted);
            opacity: 0;
            transition: opacity 0.2s ease;
            font-style: italic;
            margin-left: 0.5rem;
        }

        .chapter-header:hover .edit-hint,
        .scene-item:hover .edit-hint {
            opacity: 1;
        }

        /* Rich Text Editor Toolbar - defined above in main structure */

        .toolbar-group {
            display: flex;
            gap: 0.25rem;
            padding-right: 0.75rem;
            border-right: 1px solid var(--border-color);
        }

        .toolbar-group:last-child {
            border-right: none;
        }

        .toolbar-btn {
            padding: 0.5rem 0.75rem;
            border: 1px solid var(--border-color);
            background: var(--bg-primary);
            color: var(--text-primary);
            cursor: pointer;
            font-family: 'Crimson Pro', serif;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.2s ease;
            border-radius: 2px;
            min-width: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .toolbar-btn:hover {
            background: var(--accent-gold);
            color: var(--bg-primary);
            border-color: var(--accent-gold);
        }

        .toolbar-btn.active {
            background: var(--accent-red);
            color: var(--bg-primary);
            border-color: var(--accent-red);
        }

        .toolbar-btn[data-format="bold"] {
            font-weight: 700;
        }

        .toolbar-btn[data-format="italic"] {
            font-style: italic;
        }

        .toolbar-btn[data-format="underline"] {
            text-decoration: underline;
        }

        /* Color Picker Dropdown */
        .color-picker-wrapper {
            position: relative;
            display: inline-block;
        }

        .color-picker-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            background: var(--bg-primary);
            border: 2px solid var(--border-color);
            border-radius: 4px;
            padding: 0.75rem;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 1000;
            display: none;
            min-width: 200px;
        }

        .color-picker-dropdown.active {
            display: block;
        }

        .color-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 0.25rem;
            margin-bottom: 0.5rem;
        }

        .color-swatch {
            width: 24px;
            height: 24px;
            border: 2px solid var(--border-color);
            border-radius: 2px;
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .color-swatch:hover {
            transform: scale(1.1);
            border-color: var(--accent-gold);
        }

        .color-input-wrapper {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-top: 0.5rem;
            padding-top: 0.5rem;
            border-top: 1px solid var(--border-color);
        }

        .color-input-wrapper input[type="color"] {
            width: 40px;
            height: 30px;
            border: 1px solid var(--border-color);
            border-radius: 2px;
            cursor: pointer;
        }

        .color-input-wrapper input[type="text"] {
            flex: 1;
            padding: 0.3rem 0.5rem;
            border: 1px solid var(--border-color);
            border-radius: 2px;
            font-family: 'Source Code Pro', monospace;
            font-size: 0.85rem;
        }

        /* Font Size Selector */
        .font-size-selector {
            padding: 0.5rem;
            border: 1px solid var(--border-color);
            background: var(--bg-primary);
            color: var(--text-primary);
            cursor: pointer;
            font-family: 'Crimson Pro', serif;
            font-size: 0.9rem;
            border-radius: 2px;
            min-width: 70px;
        }

        .font-size-selector:hover {
            background: var(--accent-gold);
            color: var(--bg-primary);
            border-color: var(--accent-gold);
        }

        /* Font Family Selector */
        .font-family-selector {
            padding: 0.5rem;
            border: 1px solid var(--border-color);
            background: var(--bg-primary);
            color: var(--text-primary);
            cursor: pointer;
            font-size: 0.9rem;
            border-radius: 2px;
            min-width: 150px;
        }

        .font-family-selector:hover {
            background: var(--accent-gold);
            color: var(--bg-primary);
            border-color: var(--accent-gold);
        }

        /* Toolbar separator */
        .toolbar-separator {
            width: 1px;
            height: 30px;
            background: var(--border-color);
            margin: 0 0.25rem;
        }

        /* Rich Text Editor Content */
        .editor-textarea[contenteditable="true"] {
            outline: none;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .editor-textarea[contenteditable="true"]:empty:before {
            content: attr(data-placeholder);
            color: var(--text-muted);
            font-style: italic;
            pointer-events: none;
        }

        .editor-textarea strong,
        .editor-textarea b {
            font-weight: 700;
        }

        .editor-textarea em,
        .editor-textarea i {
            font-style: italic;
        }

        .editor-textarea u {
            text-decoration: underline;
        }

        .editor-textarea h1 {
            font-size: 2em;
            font-weight: 700;
            margin: 1em 0 0.5em;
            font-family: 'Noto Serif JP', serif;
        }

        .editor-textarea h2 {
            font-size: 1.5em;
            font-weight: 600;
            margin: 1em 0 0.5em;
            font-family: 'Noto Serif JP', serif;
        }

        .editor-textarea h3 {
            font-size: 1.25em;
            font-weight: 600;
            margin: 1em 0 0.5em;
        }

        .editor-textarea blockquote {
            border-left: 4px solid var(--accent-gold);
            padding-left: 1.5rem;
            margin: 1.5rem 0;
            font-style: italic;
            color: var(--text-secondary);
        }

        .editor-textarea ul,
        .editor-textarea ol {
            margin: 1rem 0;
            padding-left: 2rem;
        }

        .editor-textarea li {
            margin: 0.5rem 0;
        }

        .editor-textarea hr {
            border: none;
            border-top: 2px solid var(--border-color);
            margin: 2rem 0;
        }

        /* Text alignment */
        .editor-textarea [style*="text-align: left"] {
            text-align: left;
        }

        .editor-textarea [style*="text-align: center"] {
            text-align: center;
        }

        .editor-textarea [style*="text-align: right"] {
            text-align: right;
        }

        .editor-textarea [style*="text-align: justify"] {
            text-align: justify;
        }

        /* Strikethrough */
        .editor-textarea s,
        .editor-textarea strike {
            text-decoration: line-through;
        }

        /* Superscript and subscript */
        .editor-textarea sup {
            vertical-align: super;
            font-size: 0.75em;
        }

        .editor-textarea sub {
            vertical-align: sub;
            font-size: 0.75em;
        }

        /* Timeline Styles */
        .timeline-container {
            position: relative;
            padding: 1rem 0 1rem 2.5rem;
        }

        .timeline-line {
            position: absolute;
            left: 0.75rem;
            top: 0;
            bottom: 0;
            width: 2px;
            background: var(--border-color);
        }

        .timeline-event {
            position: relative;
            margin-bottom: 1.5rem;
            padding: 0.75rem;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .timeline-event::before {
            content: '';
            position: absolute;
            left: -2rem;
            top: 1rem;
            width: 10px;
            height: 10px;
            background: var(--accent-red);
            border: 2px solid var(--bg-primary);
            border-radius: 50%;
            z-index: 2;
        }

        .timeline-event:hover {
            border-color: var(--accent-gold);
            box-shadow: 0 2px 8px var(--shadow);
        }

        .timeline-event.active {
            border-color: var(--accent-red);
            background: var(--bg-secondary);
        }

        .timeline-date {
            font-size: 0.75rem;
            color: var(--accent-gold);
            font-weight: 600;
            margin-bottom: 0.4rem;
            font-family: 'Source Code Pro', monospace;
        }

        .timeline-title {
            font-size: 0.95rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.4rem;
        }

        .timeline-meta {
            display: flex;
            gap: 0.75rem;
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-bottom: 0.4rem;
            flex-wrap: wrap;
        }

        .timeline-meta-item {
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .timeline-description {
            font-size: 0.85rem;
            color: var(--text-secondary);
            line-height: 1.4;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        /* Notes Styles */
        .note-card {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 1rem;
            margin-bottom: 1rem;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .note-card:hover {
            border-color: var(--accent-gold);
            box-shadow: 0 2px 8px var(--shadow);
        }

        .note-card.active {
            border-color: var(--accent-red);
            background: var(--bg-secondary);
        }

        .note-category-badge {
            display: inline-block;
            font-size: 0.7rem;
            padding: 0.25rem 0.5rem;
            background: var(--accent-gold);
            color: var(--bg-primary);
            border-radius: 2px;
            margin-bottom: 0.5rem;
            font-family: 'Source Code Pro', monospace;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .note-title {
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
        }

        .note-preview {
            font-size: 0.85rem;
            color: var(--text-secondary);
            line-height: 1.4;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
            overflow: hidden;
            margin-bottom: 0.5rem;
        }

        .note-tags {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .note-tag {
            font-size: 0.7rem;
            padding: 0.2rem 0.5rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 2px;
            color: var(--text-muted);
        }

        .note-date {
            font-size: 0.7rem;
            color: var(--text-muted);
            margin-top: 0.5rem;
            font-family: 'Source Code Pro', monospace;
        }

        /* Statistics Styles */
        .stat-box {
            background: var(--bg-primary);
            border: 2px solid var(--border-color);
            border-radius: 4px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
        }

        .stat-title {
            font-size: 0.85rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.5rem;
            font-weight: 500;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: 700;
            color: var(--text-primary);
            font-family: 'Noto Serif JP', serif;
        }

        .stat-label {
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-top: 0.25rem;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: var(--bg-secondary);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 0.5rem;
        }

        .progress-fill {
            height: 100%;
            background: var(--accent-gold);
            transition: width 0.3s ease;
        }

        .goal-input {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        /* Codex Styles */
        .codex-card {
            background: var(--bg-primary);
            border-left: 4px solid var(--accent-gold);
            border-right: 1px solid var(--border-color);
            border-top: 1px solid var(--border-color);
            border-bottom: 1px solid var(--border-color);
            border-radius: 0 4px 4px 0;
            padding: 1rem;
            margin-bottom: 1rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .codex-card:hover {
            border-left-color: var(--accent-red);
            box-shadow: 0 2px 8px var(--shadow);
        }

        /* Version Styles */
        .version-card {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 1rem;
            margin-bottom: 1rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .version-card:hover {
            border-color: var(--accent-gold);
            box-shadow: 0 2px 8px var(--shadow);
        }

        .version-timestamp {
            font-size: 0.85rem;
            color: var(--accent-gold);
            font-weight: 600;
            margin-bottom: 0.5rem;
            font-family: 'Source Code Pro', monospace;
        }

        .version-label {
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
        }

        .version-stats {
            font-size: 0.8rem;
            color: var(--text-muted);
        }

        /* References and Links Styles */
        .references-section {
            margin-bottom: 1.5rem;
        }

        .references-title {
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .reference-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.5rem 0.75rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 2px;
            margin-bottom: 0.5rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .reference-item:hover {
            background: rgba(212, 175, 55, 0.1);
            border-color: var(--accent-gold);
        }

        .reference-link {
            display: inline-block;
            padding: 0.25rem 0.5rem;
            background: var(--accent-gold);
            color: var(--bg-primary);
            border-radius: 2px;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s ease;
            text-decoration: none;
            margin: 0.25rem;
        }

        .reference-link:hover {
            background: var(--accent-red);
        }

        .tag-selector {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .tag-option {
            padding: 0.4rem 0.8rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 2px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s ease;
        }

        .tag-option:hover {
            border-color: var(--accent-gold);
        }

        .tag-option.selected {
            background: var(--accent-gold);
            color: var(--bg-primary);
            border-color: var(--accent-gold);
        }

        .link-badge {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.25rem 0.5rem;
            background: rgba(212, 175, 55, 0.2);
            border: 1px solid var(--accent-gold);
            border-radius: 2px;
            font-size: 0.75rem;
            color: var(--text-primary);
            margin: 0.25rem 0.25rem 0.25rem 0;
            cursor: pointer;
        }

        .link-badge:hover {
            background: rgba(212, 175, 55, 0.3);
        }

        .link-badge-remove {
            cursor: pointer;
            color: var(--accent-red);
            font-weight: bold;
            margin-left: 0.25rem;
        }

        .link-badge-remove:hover {
            color: #8b2a1f;
        }

        .quick-links {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-top: 0.5rem;
        }

        /* Projects Management Styles */
        .project-card {
            background: var(--bg-primary);
            border: 2px solid var(--border-color);
            border-radius: 4px;
            padding: 1.5rem;
            margin-bottom: 1rem;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .project-card:hover {
            border-color: var(--accent-gold);
            box-shadow: 0 2px 8px var(--shadow);
        }

        .project-card.active {
            border-color: var(--accent-red);
            background: var(--bg-secondary);
        }

        .project-card-header {
            display: flex;
            justify-content: space-between;
            align-items: start;
            margin-bottom: 0.75rem;
        }

        .project-card-title {
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--text-primary);
            font-family: 'Noto Serif JP', serif;
        }

        .project-card-genre {
            font-size: 0.75rem;
            padding: 0.25rem 0.5rem;
            background: var(--accent-gold);
            color: var(--bg-primary);
            border-radius: 2px;
            font-weight: 600;
        }

        .project-card-desc {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 0.75rem;
            line-height: 1.4;
        }

        .project-card-stats {
            display: flex;
            gap: 1.5rem;
            font-size: 0.85rem;
            color: var(--text-muted);
            font-family: 'Source Code Pro', monospace;
        }

        .project-card-actions {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        /* Focus Mode Styles */
        .app-container.focus-mode .sidebar {
            display: none;
        }
        
        .app-container.focus-mode .app-header {
            display: none;
        }

        .app-container.focus-mode {
            grid-template-columns: 1fr !important;
            grid-template-rows: 1fr !important;
            grid-template-areas: "main" !important;
        }

        .app-container.focus-mode .editor-container {
            background: var(--bg-primary);
            height: 100vh;
            grid-area: main;
        }

        .app-container.focus-mode .editor-header {
            background: var(--bg-primary);
            border-bottom: 1px solid var(--border-color);
        }

        .app-container.focus-mode .editor-toolbar {
            background: var(--bg-primary);
        }

        .focus-mode-panel {
            position: fixed;
            top: 0;
            right: 0;
            width: 350px;
            height: 100vh;
            background: var(--bg-primary);
            border-left: 2px solid var(--accent-gold);
            box-shadow: -8px 0 24px rgba(0, 0, 0, 0.3);
            transform: translateX(100%);
            transition: transform 0.3s ease;
            z-index: 2000;
            display: flex;
            flex-direction: column;
        }

        .focus-mode-panel.active {
            transform: translateX(0);
        }

        .app-container.focus-mode .focus-mode-panel {
            display: flex;
        }

        .focus-panel-header {
            padding: 1.5rem;
            border-bottom: 2px solid var(--border-color);
            background: var(--bg-accent);
            color: var(--bg-primary);
        }

        .focus-panel-title {
            font-size: 1.2rem;
            font-weight: 700;
            font-family: 'Noto Serif JP', serif;
        }

        .focus-panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 1.5rem;
        }

        .focus-section {
            margin-bottom: 2rem;
        }

        .focus-section-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .pomodoro-timer {
            text-align: center;
            padding: 2rem;
            background: var(--bg-primary);
            border-radius: 4px;
            border: 2px solid var(--border-color);
        }

        .pomodoro-display {
            font-size: 3rem;
            font-weight: 700;
            font-family: 'Source Code Pro', monospace;
            color: var(--text-primary);
            margin-bottom: 1rem;
        }

        .pomodoro-controls {
            display: flex;
            gap: 0.5rem;
            justify-content: center;
        }

        .ambient-music {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .focus-toggle-btn {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            z-index: 2001;
            background: var(--accent-gold);
            color: var(--bg-primary);
            border: none;
            padding: 0.75rem 1.25rem;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.9rem;
            transition: all 0.2s ease;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            display: none;
            font-family: 'Crimson Pro', serif;
        }

        .app-container.focus-mode .focus-toggle-btn {
            display: block !important;
        }

        .focus-toggle-btn:hover {
            background: var(--accent-red);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px var(--shadow);
        }

        .focus-stats {
            display: flex;
            gap: 1rem;
            margin-top: 1rem;
        }

        .focus-stat-box {
            flex: 1;
            padding: 0.75rem;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 2px;
            text-align: center;
        }

        .focus-stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--accent-gold);
            font-family: 'Source Code Pro', monospace;
        }

        .focus-stat-label {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-top: 0.25rem;
        }

        /* REVISION MODE STYLES */
        .highlight-yellow { background: var(--highlight-yellow); }
        .highlight-green { background: var(--highlight-green); }
        .highlight-blue { background: var(--highlight-blue); }
        .highlight-red { background: var(--highlight-red); }
        .highlight-purple { background: var(--highlight-purple); }

        .revision-toolbar {
            display: flex;
            gap: 0.5rem;
            padding: 1rem 3rem;
            border-bottom: 2px solid var(--accent-red);
            background: var(--bg-secondary);
            flex-wrap: wrap;
            align-items: center;
        }

        .revision-badge {
            padding: 0.5rem 1rem;
            background: var(--accent-red);
            color: var(--bg-primary);
            border-radius: 4px;
            font-weight: 600;
            margin-right: 1rem;
        }

        .highlight-btn {
            padding: 0.5rem 0.75rem;
            border: 1px solid var(--border-color);
            background: var(--bg-primary);
            cursor: pointer;
            font-size: 0.85rem;
            border-radius: 2px;
            transition: all 0.2s;
        }

        .highlight-btn.active {
            border-width: 2px;
            font-weight: 600;
        }

        .highlight-btn.yellow { background: var(--highlight-yellow); }
        .highlight-btn.green { background: var(--highlight-green); }
        .highlight-btn.blue { background: var(--highlight-blue); }
        .highlight-btn.red { background: var(--highlight-red); }
        .highlight-btn.purple { background: var(--highlight-purple); }

        .annotations-panel {
            position: fixed;
            right: -350px;
            top: 0;
            width: 320px;
            height: 100vh;
            background: var(--bg-secondary);
            border-left: 2px solid var(--border-color);
            padding: 0;
            overflow: hidden;
            transition: right 0.3s;
            box-shadow: -4px 0 12px rgba(0,0,0,0.1);
            z-index: 50;
            display: flex;
            flex-direction: column;
        }

        .annotations-panel.visible {
            right: 0;
        }
        
        .annotations-panel-spacer {
            height: 0;
            background: var(--bg-secondary);
            flex-shrink: 0;
            transition: height 0.3s;
            pointer-events: none;
            border-left: 2px solid var(--border-color);
        }
        
        .annotations-panel.visible .annotations-panel-spacer {
            height: var(--toolbar-height, 200px);
        }
        
        .annotations-panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
        }
        
        .annotations-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid var(--border-color);
        }
        
        .annotations-panel-close {
            cursor: pointer;
            font-size: 1.5rem;
            color: var(--text-muted);
            transition: color 0.2s;
            padding: 0.5rem;
            line-height: 1;
        }
        
        .annotations-panel-close:hover {
            color: var(--accent-red);
        }

        .annotation-card {
            background: var(--bg-primary);
            border-left: 4px solid var(--accent-gold);
            padding: 1rem;
            margin-bottom: 1rem;
            border-radius: 0 4px 4px 0;
            cursor: pointer;
        }

        .annotation-card:hover {
            transform: translateX(-4px);
        }

        .annotation-card.todo { border-left-color: var(--accent-red); }
        .annotation-card.note { border-left-color: #4CAF50; }
        .annotation-card.question { border-left-color: #2196F3; }

        .annotation-type {
            font-size: 0.7rem;
            padding: 0.25rem 0.5rem;
            border-radius: 2px;
            text-transform: uppercase;
            font-weight: 600;
            display: inline-block;
            margin-bottom: 0.5rem;
        }

        .annotation-type.comment { background: var(--accent-gold); color: white; }
        .annotation-type.todo { background: var(--accent-red); color: white; }
        .annotation-type.note { background: #4CAF50; color: white; }
        .annotation-type.question { background: #2196F3; color: white; }

        .annotation-content {
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
        }

        .annotation-context {
            font-size: 0.75rem;
            color: var(--text-muted);
            font-style: italic;
            padding: 0.5rem;
            background: var(--bg-secondary);
            border-radius: 2px;
            margin-bottom: 0.5rem;
        }

        .annotation-popup {
            position: fixed;
            background: var(--bg-primary);
            border: 2px solid var(--accent-gold);
            border-radius: 4px;
            padding: 1.5rem;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            z-index: 10000;
            min-width: 350px;
            display: none;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
        }

        .annotation-popup.visible {
            display: block;
        }

        .annotation-type-selector {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .annotation-type-btn {
            flex: 1;
            padding: 0.5rem;
            border: 1px solid var(--border-color);
            background: var(--bg-secondary);
            cursor: pointer;
            font-size: 0.75rem;
            border-radius: 2px;
        }

        .annotation-type-btn.active {
            border-width: 2px;
            font-weight: 600;
        }

        .annotation-type-btn.comment.active { border-color: var(--accent-gold); }
        .annotation-type-btn.todo.active { border-color: var(--accent-red); }
        .annotation-type-btn.note.active { border-color: #4CAF50; }
        .annotation-type-btn.question.active { border-color: #2196F3; }

        .annotation-popup textarea {
            width: 100%;
            min-height: 100px;
            padding: 0.75rem;
            border: 1px solid var(--border-color);
            border-radius: 2px;
            font-family: inherit;
            font-size: 0.95rem;
            margin-bottom: 1rem;
        }

        .todo-item {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            padding: 0.75rem;
            margin-bottom: 0.75rem;
            border-radius: 4px;
            display: flex;
            gap: 0.75rem;
            cursor: pointer;
        }

        .todo-item:hover {
            border-color: var(--accent-gold);
        }

        .todo-checkbox {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .todo-text {
            flex: 1;
        }

        .todo-text.done {
            text-decoration: line-through;
            color: var(--text-muted);
        }

        .scene-badge {
            font-size: 0.7rem;
            padding: 0.2rem 0.4rem;
            background: var(--accent-red);
            color: white;
            border-radius: 2px;
            margin-left: 0.5rem;
        }

        /* ============================================ */
        /* CORK BOARD STYLES */
        /* ============================================ */
        
        .cork-board-container {
            padding: 2rem;
            background: var(--bg-secondary);
            background-image: 
                radial-gradient(circle at 20% 30%, var(--shadow) 1px, transparent 1px),
                radial-gradient(circle at 70% 60%, var(--shadow) 1px, transparent 1px),
                radial-gradient(circle at 40% 80%, var(--shadow) 1px, transparent 1px);
            background-size: 100px 100px, 150px 150px, 120px 120px;
            min-height: calc(100vh - 200px);
            overflow-y: auto;
        }
        
        .cork-board-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            padding: 1rem 2rem;
            background: var(--bg-primary);
            border-radius: 8px;
            box-shadow: 0 2px 8px var(--shadow);
        }
        
        .cork-board-title {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--text-primary);
        }
        
        .cork-board-filters {
            display: flex;
            gap: 1rem;
            align-items: center;
        }
        
        .cork-board-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 2rem;
            padding: 1rem;
        }
        
        .cork-card {
            background: var(--bg-primary);
            padding: 1.5rem;
            border-radius: 4px;
            box-shadow: 
                0 2px 4px var(--shadow),
                0 4px 8px var(--shadow);
            cursor: move;
            transition: all 0.3s ease;
            position: relative;
            min-height: 200px;
            border: 1px solid var(--border-color);
        }
        
        .cork-card::before {
            content: '📌';
            position: absolute;
            top: -10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.5rem;
            filter: drop-shadow(0 2px 2px var(--shadow));
        }
        
        .cork-card:hover {
            transform: translateY(-5px) rotate(1deg);
            box-shadow: 
                0 4px 8px var(--shadow),
                0 8px 16px var(--shadow);
        }
        
        .cork-card.dragging {
            opacity: 0.5;
            transform: rotate(5deg);
        }
        
        .cork-card-header {
            display: flex;
            justify-content: space-between;
            align-items: start;
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 2px dashed var(--border-color);
        }
        
        .cork-card-number {
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--text-muted);
            font-family: 'Source Code Pro', monospace;
        }
        
        .cork-card-color-tag {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 2px solid rgba(0,0,0,0.2);
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        .cork-card-color-tag:hover {
            transform: scale(1.2);
        }
        
        .cork-card-title {
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 1rem;
            line-height: 1.3;
        }
        
        .cork-card-synopsis {
            font-size: 0.9rem;
            color: var(--text-secondary);
            line-height: 1.6;
            margin-bottom: 1rem;
            min-height: 60px;
        }
        
        .cork-card-meta {
            display: flex;
            gap: 1rem;
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-top: auto;
        }
        
        .cork-card-actions {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
            padding-top: 0.75rem;
            border-top: 1px dashed var(--border-color);
        }
        
        .cork-color-palette {
            position: absolute;
            top: 100%;
            right: 0;
            background: white;
            border: 2px solid var(--border-color);
            border-radius: 4px;
            padding: 0.5rem;
            display: none;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        
        .cork-color-palette.visible {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 0.5rem;
        }
        
        .cork-color-option {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 2px solid rgba(0,0,0,0.2);
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        .cork-color-option:hover {
            transform: scale(1.2);
        }
        
        /* Couleurs prédéfinies pour POV/Intrigues */
        .cork-color-yellow { background: #ffd93d; }
        .cork-color-pink { background: #ff6b9d; }
        .cork-color-blue { background: #6bcfff; }
        .cork-color-green { background: #6bff9d; }
        .cork-color-purple { background: #c26bff; }
        .cork-color-orange { background: #ffb56b; }
        .cork-color-red { background: #ff6b6b; }
        .cork-color-teal { background: #6bffd9; }
        .cork-color-default { background: #fef9e7; }
        
        .cork-board-empty {
            text-align: center;
            padding: 4rem;
            color: var(--text-muted);
        }
        
        .cork-board-empty-icon {
            font-size: 4rem;
            margin-bottom: 1rem;
            opacity: 0.5;
        }
        
        .cork-filter-btn {
            padding: 0.5rem 1rem;
            border: 2px solid var(--border-color);
            background: var(--bg-primary);
            color: var(--text-primary);
            cursor: pointer;
            font-size: 0.85rem;
            border-radius: 4px;
            transition: all 0.2s;
            font-weight: 500;
        }
        
        .cork-filter-btn:hover {
            background: var(--accent-gold);
            color: white;
            border-color: var(--accent-gold);
        }
        
        .cork-filter-btn.active {
            background: var(--accent-red);
            color: white;
            border-color: var(--accent-red);
        }

        /* ============================================
           STRUCTURED VIEW (Style NovelCrafter)
           ============================================ */
        
        .structured-act-container {
            background: var(--bg-accent);
            border-radius: 8px;
            padding: 1rem;
            border: 1px solid var(--border-color);
        }
        
        .structured-act-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
        }
        
        .structured-collapse-btn {
            background: transparent;
            border: none;
            color: var(--bg-primary);
            cursor: pointer;
            font-size: 0.9rem;
            padding: 0.25rem;
        }
        
        .structured-collapse-btn:hover {
            color: var(--accent-gold);
        }
        
        .structured-act-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--bg-primary);
        }
        
        .structured-count {
            color: var(--bg-primary);
            opacity: 0.7;
            font-size: 0.9rem;
            margin-left: auto;
        }
        
        .structured-chapters-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 1rem;
        }
        
        .structured-chapter-container {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 1rem;
        }
        
        .structured-chapter-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid var(--border-color);
        }
        
        .structured-chapter-icon {
            color: var(--text-muted);
            font-size: 1rem;
        }
        
        .structured-chapter-title {
            color: var(--text-primary);
            font-weight: 500;
            font-size: 0.95rem;
        }
        
        .structured-menu-btn {
            background: transparent;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            padding: 0.25rem 0.5rem;
            font-size: 1.2rem;
        }
        
        .structured-menu-btn:hover {
            color: var(--accent-gold);
        }
        
        .structured-scenes-list {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        
        .structured-scene-card {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 0.75rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .structured-scene-card:hover {
            border-color: var(--accent-gold);
            transform: translateX(2px);
        }
        
        .structured-scene-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }
        
        .structured-scene-icon {
            color: var(--text-muted);
            font-size: 0.9rem;
        }
        
        .structured-scene-title {
            color: var(--text-primary);
            font-size: 0.9rem;
            font-weight: 500;
        }
        
        .structured-scene-menu {
            background: transparent;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            padding: 0.25rem;
            margin-left: auto;
        }
        
        .structured-scene-menu:hover {
            color: var(--accent-gold);
        }
        
        .structured-scene-synopsis {
            color: var(--text-secondary);
            font-size: 0.85rem;
            line-height: 1.4;
            margin-bottom: 0.5rem;
            min-height: 2.5rem;
        }
        
        .structured-scene-synopsis:empty:before {
            content: attr(data-placeholder);
            color: var(--text-muted);
        }
        
        .structured-scene-synopsis:focus {
            outline: none;
            color: var(--text-primary);
        }
        
        .structured-scene-label {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            font-size: 0.8rem;
            color: var(--text-muted);
            cursor: pointer;
        }
        
        .structured-scene-label:hover {
            color: var(--accent-gold);
        }
        
        .label-icon {
            font-size: 0.9rem;
        }
        
        .structured-add-scene-btn {
            background: transparent;
            border: 1px dashed var(--border-color);
            border-radius: 4px;
            padding: 0.75rem;
            color: var(--text-muted);
            cursor: pointer;
            font-size: 0.85rem;
            width: 100%;
            transition: all 0.2s ease;
        }
        
        .structured-add-scene-btn:hover {
            border-color: var(--accent-gold);
            color: var(--accent-gold);
            background: rgba(212, 175, 55, 0.05);
        }
        
        .structured-bottom-actions {
            display: flex;
            gap: 0.75rem;
            margin-top: 2rem;
            padding-top: 2rem;
            border-top: 1px solid var(--border-color);
        }
        
        /* Couleurs pour les cartes de scène */
        .structured-color-yellow { border-left: 3px solid #f4c430; }
        .structured-color-pink { border-left: 3px solid #ff69b4; }
        .structured-color-blue { border-left: 3px solid #4a9eff; }
        .structured-color-green { border-left: 3px solid #4caf50; }
        .structured-color-purple { border-left: 3px solid #9b59b6; }
        .structured-color-orange { border-left: 3px solid #ff8c42; }
        .structured-color-red { border-left: 3px solid #e74c3c; }
        .structured-color-teal { border-left: 3px solid #1abc9c; }
        .structured-color-default { border-left: 3px solid #3a3a3a; }

        @keyframes slideIn {
            from { transform: translateX(400px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        @keyframes slideOut {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(400px); opacity: 0; }
        }

        /* ============================================
           STYLES POUR LES NOUVELLES VISUALISATIONS
           ============================================ */

        /* Canvas pour les visualisations */
        .visualization-canvas {
            width: 100%;
            height: 600px;
            background: white;
            border: 2px solid var(--border-color);
            border-radius: 4px;
            position: relative;
            overflow: hidden;
        }

        /* Mindmap Styles */
        .mindmap-container {
            width: 100%;
            height: 100%;
            position: relative;
            cursor: grab;
            overflow: auto;
        }

        .mindmap-container:active {
            cursor: grabbing;
        }

        .mindmap-node {
            position: absolute;
            padding: 1rem 1.5rem;
            background: var(--bg-primary);
            border: 2px solid var(--accent-gold);
            border-radius: 8px;
            cursor: move;
            box-shadow: 0 4px 12px var(--shadow);
            transition: all 0.2s ease;
            min-width: 150px;
            max-width: 250px;
            z-index: 1;
        }

        .mindmap-node:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(0,0,0,0.2);
            z-index: 10;
        }

        .mindmap-node.root {
            background: linear-gradient(135deg, var(--accent-gold) 0%, #c49d2e 100%);
            color: white;
            font-weight: 700;
            font-size: 1.2rem;
        }

        .mindmap-node.chapter {
            background: rgba(212, 175, 55, 0.1);
            border-color: var(--accent-gold);
        }

        .mindmap-node.character {
            background: rgba(196, 69, 54, 0.1);
            border-color: var(--accent-red);
        }

        .mindmap-node.location {
            background: rgba(76, 175, 80, 0.1);
            border-color: #4caf50;
        }

        /* Relation Graph Styles */
        .relation-graph {
            width: 100%;
            height: 100%;
            position: relative;
        }

        .relation-node {
            position: absolute;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: var(--bg-primary);
            border: 3px solid var(--accent-gold);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 4px 12px var(--shadow);
        }

        .relation-node:hover {
            transform: scale(1.2);
            z-index: 100;
        }

        .relation-node-avatar {
            font-size: 2rem;
        }

        .relation-node-label {
            position: absolute;
            bottom: -25px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.85rem;
            font-weight: 600;
            white-space: nowrap;
            background: white;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            box-shadow: 0 2px 4px var(--shadow);
        }

        .relation-legend {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: white;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 1rem;
            box-shadow: 0 4px 12px var(--shadow);
        }

        .relation-legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
            font-size: 0.85rem;
        }

        .relation-legend-line {
            width: 30px;
            height: 3px;
        }

        /* Timeline Viz Styles */
        .timeline-viz-container {
            width: 100%;
            padding: 2rem;
            overflow-x: auto;
        }

        .timeline-viz {
            display: flex;
            position: relative;
            min-width: 100%;
            padding: 2rem 0;
        }

        .timeline-viz-line {
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 4px;
            background: var(--accent-gold);
            transform: translateY(-50%);
        }

        .timeline-viz-item {
            position: relative;
            flex: 0 0 200px;
            padding: 0 1rem;
        }

        .timeline-viz-marker {
            width: 20px;
            height: 20px;
            background: var(--accent-gold);
            border: 4px solid white;
            border-radius: 50%;
            margin: 0 auto;
            position: relative;
            z-index: 2;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .timeline-viz-marker:hover {
            transform: scale(1.5);
            background: var(--accent-red);
        }

        .timeline-viz-content {
            background: white;
            border: 2px solid var(--border-color);
            border-radius: 4px;
            padding: 1rem;
            margin-top: 2rem;
            box-shadow: 0 4px 12px var(--shadow);
            transition: all 0.2s ease;
        }

        .timeline-viz-content:hover {
            border-color: var(--accent-gold);
            transform: translateY(-4px);
        }

        .timeline-viz-date {
            font-size: 0.8rem;
            color: var(--text-muted);
            margin-bottom: 0.5rem;
        }

        .timeline-viz-title {
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
        }

        .timeline-viz-description {
            font-size: 0.85rem;
            color: var(--text-secondary);
            line-height: 1.4;
        }

        /* Plot Graph Styles */
        .plot-graph {
            width: 100%;
            height: 100%;
            padding: 2rem;
        }

        .plot-legend {
            position: absolute;
            top: 2rem;
            right: 2rem;
            background: white;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 1rem;
            box-shadow: 0 4px 12px var(--shadow);
        }

        /* Map Styles */
        .world-map-container {
            width: 100%;
            height: 100%;
            position: relative;
            overflow: auto;
            background: #f0e6d2;
            background-image: 
                repeating-linear-gradient(0deg, transparent, transparent 20px, rgba(0,0,0,0.03) 20px, rgba(0,0,0,0.03) 21px),
                repeating-linear-gradient(90deg, transparent, transparent 20px, rgba(0,0,0,0.03) 20px, rgba(0,0,0,0.03) 21px);
        }

        .world-map {
            min-width: 100%;
            min-height: 100%;
            position: relative;
            cursor: grab;
        }

        .world-map:active {
            cursor: grabbing;
        }

        .map-location {
            position: absolute;
            width: 40px;
            height: 40px;
            background: var(--accent-red);
            border: 3px solid white;
            border-radius: 50% 50% 50% 0;
            transform: rotate(-45deg);
            cursor: pointer;
            box-shadow: 0 4px 12px var(--shadow);
            transition: all 0.2s ease;
        }

        .map-location:hover {
            transform: rotate(-45deg) scale(1.2);
            z-index: 100;
        }

        .map-location::after {
            content: attr(data-label);
            position: absolute;
            top: 45px;
            left: 50%;
            transform: translateX(-50%) rotate(45deg);
            background: white;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.85rem;
            font-weight: 600;
            white-space: nowrap;
            box-shadow: 0 2px 8px var(--shadow);
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .map-location:hover::after {
            opacity: 1;
        }

        .map-upload-zone {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border: 3px dashed var(--border-color);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .map-upload-zone:hover {
            border-color: var(--accent-gold);
            background: rgba(212, 175, 55, 0.05);
        }

        .map-upload-icon {
            font-size: 4rem;
            margin-bottom: 1rem;
            opacity: 0.5;
        }

        .map-uploaded-image {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        /* Toolbar pour les visualisations */
        .visualization-toolbar {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
            padding: 1rem;
            background: var(--bg-secondary);
            border-radius: 4px;
        }

        .viz-tool-btn {
            padding: 0.5rem 1rem;
            background: white;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Crimson Pro', serif;
            font-size: 0.9rem;
            transition: all 0.2s ease;
        }

        .viz-tool-btn:hover {
            background: var(--accent-gold);
            color: white;
            border-color: var(--accent-gold);
        }

        .viz-tool-btn.active {
            background: var(--accent-gold);
            color: white;
            border-color: var(--accent-gold);
        }

        /* ========================================
           RESPONSIVE DESIGN - MOBILE & TABLET
           ======================================== */

        /* Mobile Menu Toggle Button */
        .mobile-menu-toggle {
            display: none;
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 56px;
            height: 56px;
            background: var(--accent-gold);
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 1.5rem;
            cursor: pointer;
            z-index: 9999;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            transition: all 0.3s ease;
        }

        .mobile-menu-toggle:active {
            transform: scale(0.95);
        }

        /* Mobile Navigation Dropdown */
        .mobile-nav-dropdown {
            display: none;
            position: fixed;
            top: 56px;
            left: 0;
            right: 0;
            background: var(--bg-secondary);
            border-bottom: 2px solid var(--accent-gold);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            z-index: 998;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .mobile-nav-dropdown.active {
            max-height: 80vh;
            overflow-y: auto;
        }

        .mobile-nav-section {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--border-color);
        }

        .mobile-nav-section-title {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 0.5rem;
        }

        .mobile-nav-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 1rem;
            color: var(--text-primary);
            background: transparent;
            border: none;
            width: 100%;
            text-align: left;
        }

        .mobile-nav-item:active {
            background: var(--accent-gold);
            color: white;
        }

        .mobile-nav-item.active {
            background: var(--accent-gold);
            color: white;
            font-weight: 600;
        }

        .mobile-nav-item-icon {
            font-size: 1.3rem;
            width: 28px;
            text-align: center;
        }

        .mobile-nav-toggle-btn {
            display: none;
            position: absolute;
            right: 1rem;
            top: 50%;
            transform: translateY(-50%);
            background: var(--accent-gold);
            color: white;
            border: none;
            border-radius: 6px;
            width: 36px;
            height: 36px;
            font-size: 1.2rem;
            cursor: pointer;
            z-index: 1001;
        }

        .mobile-nav-toggle-btn:active {
            opacity: 0.7;
        }

        /* Collapsible Editor Toolbar on Mobile */
        .toolbar-mobile-toggle {
            display: none;
            width: 100%;
            padding: 0.5rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 0.9rem;
            color: var(--text-primary);
            cursor: pointer;
            margin-bottom: 0.5rem;
            text-align: center;
            font-weight: 600;
        }

        .toolbar-mobile-toggle:active {
            background: var(--accent-gold);
            color: white;
        }

        /* Mobile Sidebar Overlay */
        .sidebar-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 999;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .sidebar-overlay.active {
            opacity: 1;
        }

        /* Tablet styles (landscape phones and portrait tablets) */
        @media (max-width: 1024px) {
            .app-header {
                padding: 0 1rem;
                gap: 1rem;
            }

            .app-logo {
                font-size: 1.1rem;
            }

            .header-nav {
                gap: 0.25rem;
            }

            .nav-btn {
                padding: 0.5rem 0.75rem;
                font-size: 0.85rem;
            }

            .nav-btn-text {
                display: none;
            }

            .header-actions {
                gap: 0.25rem;
            }

            .header-action-btn {
                width: 36px;
                height: 36px;
                font-size: 1.1rem;
            }

            .app-container {
                grid-template-columns: 240px 1fr;
            }

            .sidebar {
                width: 240px;
            }

            .modal-content {
                max-width: 90%;
                margin: 2rem auto;
            }
        }

        /* Mobile styles (phones) */
        @media (max-width: 768px) {
            /* Show mobile menu toggle */
            .mobile-menu-toggle {
                display: flex;
                align-items: center;
                justify-content: center;
            }

            /* Show mobile nav toggle button */
            .mobile-nav-toggle-btn {
                display: block;
            }

            /* Show mobile nav dropdown */
            .mobile-nav-dropdown {
                display: block;
            }

            /* Hide original header nav on mobile */
            .header-nav {
                display: none !important;
            }

            /* Show toolbar toggle on mobile */
            .toolbar-mobile-toggle {
                display: block;
            }

            /* Toolbar collapsible on mobile */
            .editor-toolbar {
                max-height: 0 !important;
                overflow: hidden !important;
                transition: max-height 0.3s ease;
                padding: 0 !important;
            }

            .editor-toolbar.expanded {
                max-height: 500px !important;
                overflow: visible !important;
                margin-bottom: 1rem;
                padding: 1rem !important;
            }

            /* Header adjustments */
            .app-header {
                height: 56px;
                padding: 0 0.75rem;
                gap: 0.5rem;
            }

            .app-logo {
                font-size: 1rem;
                gap: 0.5rem;
            }

            .app-logo-icon {
                font-size: 1.2rem;
            }

            /* Hide less important header elements */
            #headerTotalWords,
            #headerTotalChapters,
            #headerUndoBtn,
            #headerRedoBtn {
                display: none;
            }

            /* Simplify header nav */
            .header-nav {
                flex: 1;
                overflow-x: auto;
                gap: 0.25rem;
                -webkit-overflow-scrolling: touch;
                padding: 0;
            }

            .nav-btn {
                flex-shrink: 0;
                padding: 0.4rem 0.6rem;
                font-size: 1rem;
                min-width: auto;
            }

            .nav-btn-icon {
                margin: 0;
            }

            .nav-btn-text {
                display: none;
            }

            /* Header actions */
            .header-actions {
                gap: 0.25rem;
            }

            .header-action-btn {
                width: 36px;
                height: 36px;
                font-size: 1rem;
            }

            /* App container for mobile */
            .app-container {
                grid-template-rows: 56px 1fr;
                grid-template-columns: 1fr;
                grid-template-areas:
                    "header"
                    "main";
            }

            /* Sidebar - hidden by default, slide in from left */
            .sidebar {
                position: fixed;
                top: 56px;
                left: -100%;
                width: 85%;
                max-width: 320px;
                height: calc(100vh - 56px);
                z-index: 1000;
                transition: left 0.3s ease;
                box-shadow: 2px 0 12px rgba(0,0,0,0.2);
                background: var(--bg-secondary);
            }

            .sidebar.mobile-open {
                left: 0;
            }

            /* Editor takes full width */
            .editor-container {
                grid-area: main;
                width: 100%;
            }

            /* Editor content padding adjustments */
            .scene-editor {
                padding: 1rem;
            }

            .scene-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 0.75rem;
            }

            .scene-title {
                font-size: 1.5rem;
            }

            .scene-toolbar {
                width: 100%;
                flex-wrap: wrap;
                gap: 0.5rem;
            }

            .toolbar-btn {
                padding: 0.4rem 0.6rem;
                font-size: 0.85rem;
            }

            /* Scene metadata */
            .scene-metadata {
                flex-direction: column;
                gap: 0.75rem;
            }

            .metadata-item {
                width: 100%;
            }

            /* Character and element links */
            .scene-links {
                flex-direction: column;
            }

            .link-group {
                width: 100%;
            }

            /* Content editor */
            #sceneContent {
                font-size: 1rem;
                line-height: 1.6;
                padding: 1rem;
            }

            /* Sidebar actions */
            .sidebar-actions {
                flex-direction: column;
                gap: 0.5rem;
            }

            .sidebar-actions .btn {
                width: 100%;
            }

            /* Modals */
            .modal-content {
                width: 95%;
                max-width: 95%;
                margin: 1rem auto;
                max-height: 90vh;
                overflow-y: auto;
            }

            .modal-title {
                font-size: 1.3rem;
            }

            /* Forms */
            .form-input,
            .form-textarea {
                font-size: 16px; /* Prevents zoom on iOS */
            }

            /* Buttons */
            .btn {
                padding: 0.65rem 1rem;
                font-size: 0.95rem;
                touch-action: manipulation;
                -webkit-tap-highlight-color: transparent;
            }

            .btn-small {
                padding: 0.4rem 0.6rem;
                font-size: 0.85rem;
            }

            /* Stats cards */
            .stats-cards {
                grid-template-columns: 1fr;
                gap: 1rem;
            }

            /* Character/World cards */
            .character-card,
            .world-card {
                padding: 1rem;
            }

            /* Act/Chapter structure */
            .act-header,
            .chapter-header {
                padding: 0.75rem;
            }

            .act-title,
            .chapter-title {
                font-size: 0.95rem;
            }

            .scene-item {
                padding: 0.65rem 0.75rem;
                font-size: 0.9rem;
            }

            /* Empty state */
            .empty-state {
                padding: 2rem 1rem;
            }

            .empty-state-icon {
                font-size: 3rem;
            }

            .empty-state-title {
                font-size: 1.3rem;
            }

            /* Timeline visualization */
            .timeline-item {
                padding: 1rem;
            }

            /* Cork board */
            .cork-card {
                min-width: 200px;
                font-size: 0.9rem;
            }

            /* Search */
            .search-input {
                font-size: 0.95rem;
                padding: 0.65rem 2.5rem 0.65rem 1rem;
            }

            /* Tabs */
            .tabs {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }

            .tab-btn {
                flex-shrink: 0;
                padding: 0.6rem 1rem;
                font-size: 0.9rem;
            }
        }

        /* Small mobile phones */
        @media (max-width: 480px) {
            .app-header {
                height: 52px;
                padding: 0 0.5rem;
            }

            .app-logo {
                font-size: 0.9rem;
            }

            .app-logo-icon {
                font-size: 1.1rem;
            }

            .nav-btn {
                padding: 0.35rem 0.5rem;
                font-size: 0.95rem;
            }

            .header-action-btn {
                width: 32px;
                height: 32px;
                font-size: 0.95rem;
            }

            .sidebar {
                width: 90%;
                max-width: 280px;
                top: 52px;
                height: calc(100vh - 52px);
            }

            .app-container {
                grid-template-rows: 52px 1fr;
            }

            .scene-editor {
                padding: 0.75rem;
            }

            .scene-title {
                font-size: 1.3rem;
            }

            #sceneContent {
                font-size: 0.95rem;
                padding: 0.75rem;
            }

            .mobile-menu-toggle {
                width: 52px;
                height: 52px;
                font-size: 1.3rem;
                bottom: 16px;
                right: 16px;
            }

            .modal-content {
                width: 98%;
                margin: 0.5rem auto;
                padding: 1rem;
            }

            .modal-title {
                font-size: 1.2rem;
            }

            .btn {
                padding: 0.6rem 0.85rem;
                font-size: 0.9rem;
            }
        }

        /* Landscape orientation on phones */
        @media (max-width: 768px) and (orientation: landscape) {
            .app-header {
                height: 48px;
            }

            .sidebar {
                top: 48px;
                height: calc(100vh - 48px);
            }

            .app-container {
                grid-template-rows: 48px 1fr;
            }

            .modal-content {
                max-height: 85vh;
            }

            .mobile-menu-toggle {
                width: 48px;
                height: 48px;
                bottom: 12px;
                right: 12px;
            }
        }

        /* iOS specific fixes */
        @supports (-webkit-touch-callout: none) {
            /* iOS safe area insets */
            .app-header {
                padding-top: max(env(safe-area-inset-top), 0px);
            }

            .sidebar {
                padding-bottom: max(env(safe-area-inset-bottom), 0px);
            }

            .mobile-menu-toggle {
                bottom: max(env(safe-area-inset-bottom, 20px) + 20px, 20px);
                right: max(env(safe-area-inset-right, 20px) + 20px, 20px);
            }

            /* Prevent elastic scrolling on body */
            body {
                position: fixed;
                width: 100%;
            }

            /* Fix textarea font size to prevent zoom */
            input,
            textarea,
            select {
                font-size: 16px !important;
            }
        }

        /* Android Chrome specific */
        @media screen and (-webkit-min-device-pixel-ratio: 0) {
            select,
            textarea,
            input {
                font-size: 16px;
            }
        }

        /* High DPI screens */
        @media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
            .app-header {
                border-bottom-width: 1px;
            }
        }

        /* Dark mode support (if device prefers dark) */
        @media (prefers-color-scheme: dark) {
            /* This is ready for future dark mode implementation */
        }

        /* Reduced motion for accessibility */
        @media (prefers-reduced-motion: reduce) {
            *,
            *::before,
            *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* Touch device optimizations */
        @media (hover: none) and (pointer: coarse) {
            /* Larger touch targets */
            .btn,
            .nav-btn,
            .toolbar-btn,
            button {
                min-height: 44px;
                min-width: 44px;
            }

            /* Remove hover effects on touch devices */
            .btn:hover,
            .nav-btn:hover,
            .toolbar-btn:hover {
                transform: none;
            }

            /* Add active state feedback */
            .btn:active,
            .nav-btn:active,
            .toolbar-btn:active {
                opacity: 0.7;
            }
        }
    </style>
</head>
<body>
    <!-- Mobile Menu Toggle Button -->
    <button class="mobile-menu-toggle" onclick="toggleMobileSidebar()" aria-label="Menu">
        ☰
    </button>
    
    <!-- Mobile Sidebar Overlay -->
    <div class="sidebar-overlay" onclick="toggleMobileSidebar()"></div>
    
    <div class="app-container">
        <!-- Top Header -->
        <div class="app-header">
            <div class="app-logo">
                <span class="app-logo-icon">🖊️</span>
                <span id="headerProjectTitle">NovelCraft</span>
            </div>

            <!-- Mobile Navigation Toggle -->
            <button class="mobile-nav-toggle-btn" onclick="toggleMobileNav()" id="mobileNavToggleBtn">
                ☰
            </button>
            
            <nav class="header-nav">
                <!-- Groupe Écriture -->
                <div class="nav-group">
                    <button class="nav-btn active" onclick="switchView('editor')" id="header-tab-editor">
                        <span class="nav-btn-icon">📝</span>
                        <span class="nav-btn-text">Structure</span>
                    </button>
                    <button class="nav-btn" onclick="switchView('versions')" id="header-tab-versions">
                        <span class="nav-btn-icon">🕐</span>
                        <span class="nav-btn-text">Versions</span>
                    </button>
                    <button class="nav-btn" onclick="switchView('todos')" id="header-tab-todos">
                        <span class="nav-btn-icon">✓</span>
                        <span class="nav-btn-text">TODOs</span>
                    </button>
                </div>
                
                <!-- Groupe Base de données -->
                <div class="nav-group">
                    <button class="nav-btn" onclick="switchView('characters')" id="header-tab-characters">
                        <span class="nav-btn-icon">👥</span>
                        <span class="nav-btn-text">Personnages</span>
                    </button>
                    <button class="nav-btn" onclick="switchView('world')" id="header-tab-world">
                        <span class="nav-btn-icon">🌍</span>
                        <span class="nav-btn-text">Univers</span>
                    </button>
                    <button class="nav-btn" onclick="switchView('timelineviz')" id="header-tab-timeline-viz">
                        <span class="nav-btn-icon">⏳</span>
                        <span class="nav-btn-text">Timeline</span>
                    </button>
                    <button class="nav-btn" onclick="switchView('notes')" id="header-tab-notes">
                        <span class="nav-btn-icon">📋</span>
                        <span class="nav-btn-text">Notes</span>
                    </button>
                    <button class="nav-btn" onclick="switchView('codex')" id="header-tab-codex">
                        <span class="nav-btn-icon">📖</span>
                        <span class="nav-btn-text">Codex</span>
                    </button>
                </div>
                
                <!-- Groupe Visualisation -->
                <div class="nav-group">
                    <button class="nav-btn" onclick="switchView('corkboard')" id="header-tab-corkboard">
                        <span class="nav-btn-icon">📋</span>
                        <span class="nav-btn-text">Tableau</span>
                    </button>
                    <button class="nav-btn" onclick="switchView('mindmap')" id="header-tab-mindmap">
                        <span class="nav-btn-icon">🗺️</span>
                        <span class="nav-btn-text">Mindmap</span>
                    </button>
                    <button class="nav-btn" onclick="switchView('plot')" id="header-tab-plot">
                        <span class="nav-btn-icon">📈</span>
                        <span class="nav-btn-text">Intrigue</span>
                    </button>
                    <button class="nav-btn" onclick="switchView('relations')" id="header-tab-relations">
                        <span class="nav-btn-icon">🔗</span>
                        <span class="nav-btn-text">Relations</span>
                    </button>
                    <button class="nav-btn" onclick="switchView('map')" id="header-tab-map">
                        <span class="nav-btn-icon">🗺️</span>
                        <span class="nav-btn-text">Carte</span>
                    </button>
                </div>
                
                <!-- Groupe Outils -->
                <div class="nav-group">
                    <button class="nav-btn" onclick="switchView('stats')" id="header-tab-stats">
                        <span class="nav-btn-icon">📊</span>
                        <span class="nav-btn-text">Stats</span>
                    </button>
                    <button class="nav-btn" onclick="switchView('analysis')" id="header-tab-analysis">
                        <span class="nav-btn-icon">🔬</span>
                        <span class="nav-btn-text">Analyse</span>
                    </button>
                </div>
            </nav>
            
            <!-- Actions à droite -->
            <div class="header-actions">
                <div style="font-size: 0.85rem; color: var(--text-muted); margin-right: 0.5rem;">
                    <span id="headerTotalWords">0 mots</span> · 
                    <span id="headerTotalChapters">0 chapitres</span>
                </div>
                <button class="header-action-btn" onclick="undo()" id="headerUndoBtn" title="Annuler (Ctrl+Z)" disabled>↶</button>
                <button class="header-action-btn" onclick="redo()" id="headerRedoBtn" title="Rétablir (Ctrl+Y)" disabled>↷</button>
                <button class="header-action-btn" onclick="openThemeManager()" title="Gérer les thèmes">🎨</button>
                <button class="header-action-btn" onclick="openProjectsModal()" title="Gérer les projets">📂</button>
            </div>
        </div>

        <!-- Mobile Navigation Dropdown -->
        <div class="mobile-nav-dropdown" id="mobileNavDropdown">
            <div class="mobile-nav-section">
                <div class="mobile-nav-section-title">✍️ Écriture</div>
                <button class="mobile-nav-item active" onclick="switchViewMobile('editor')" data-view="editor">
                    <span class="mobile-nav-item-icon">📝</span>
                    <span>Structure</span>
                </button>
                <button class="mobile-nav-item" onclick="switchViewMobile('versions')" data-view="versions">
                    <span class="mobile-nav-item-icon">🕐</span>
                    <span>Versions</span>
                </button>
                <button class="mobile-nav-item" onclick="switchViewMobile('todos')" data-view="todos">
                    <span class="mobile-nav-item-icon">✓</span>
                    <span>TODOs</span>
                </button>
            </div>

            <div class="mobile-nav-section">
                <div class="mobile-nav-section-title">📚 Base de données</div>
                <button class="mobile-nav-item" onclick="switchViewMobile('characters')" data-view="characters">
                    <span class="mobile-nav-item-icon">👥</span>
                    <span>Personnages</span>
                </button>
                <button class="mobile-nav-item" onclick="switchViewMobile('world')" data-view="world">
                    <span class="mobile-nav-item-icon">🌍</span>
                    <span>Univers</span>
                </button>
                <button class="mobile-nav-item" onclick="switchViewMobile('timelineviz')" data-view="timelineviz">
                    <span class="mobile-nav-item-icon">⏳</span>
                    <span>Timeline</span>
                </button>
                <button class="mobile-nav-item" onclick="switchViewMobile('notes')" data-view="notes">
                    <span class="mobile-nav-item-icon">📋</span>
                    <span>Notes</span>
                </button>
                <button class="mobile-nav-item" onclick="switchViewMobile('codex')" data-view="codex">
                    <span class="mobile-nav-item-icon">📖</span>
                    <span>Codex</span>
                </button>
            </div>

            <div class="mobile-nav-section">
                <div class="mobile-nav-section-title">🎨 Visualisation</div>
                <button class="mobile-nav-item" onclick="switchViewMobile('corkboard')" data-view="corkboard">
                    <span class="mobile-nav-item-icon">📋</span>
                    <span>Tableau</span>
                </button>
                <button class="mobile-nav-item" onclick="switchViewMobile('mindmap')" data-view="mindmap">
                    <span class="mobile-nav-item-icon">🗺️</span>
                    <span>Mindmap</span>
                </button>
                <button class="mobile-nav-item" onclick="switchViewMobile('plot')" data-view="plot">
                    <span class="mobile-nav-item-icon">📈</span>
                    <span>Intrigue</span>
                </button>
                <button class="mobile-nav-item" onclick="switchViewMobile('relations')" data-view="relations">
                    <span class="mobile-nav-item-icon">🔗</span>
                    <span>Relations</span>
                </button>
                <button class="mobile-nav-item" onclick="switchViewMobile('map')" data-view="map">
                    <span class="mobile-nav-item-icon">🗺️</span>
                    <span>Carte</span>
                </button>
            </div>

            <div class="mobile-nav-section">
                <div class="mobile-nav-section-title">📊 Outils</div>
                <button class="mobile-nav-item" onclick="switchViewMobile('stats')" data-view="stats">
                    <span class="mobile-nav-item-icon">📊</span>
                    <span>Stats</span>
                </button>
                <button class="mobile-nav-item" onclick="switchViewMobile('analysis')" data-view="analysis">
                    <span class="mobile-nav-item-icon">🔬</span>
                    <span>Analyse</span>
                </button>
            </div>
        </div>
        
        <!-- Sidebar Navigation -->
        <div class="sidebar">
            <div class="sidebar-header">
                <div class="search-container">
                    <input type="text" 
                           class="search-input" 
                           id="globalSearch" 
                           placeholder="🔍 Rechercher dans tout le projet..."
                           oninput="performGlobalSearch(this.value)"
                           onfocus="this.select()">
                    <span class="search-icon">🔍</span>
                    <div class="search-results" id="searchResults"></div>
                </div>
            </div>

            <div class="chapters-list" id="chaptersList">
                <!-- Structure will be dynamically inserted here -->
            </div>

            <div class="database-list" id="charactersList" style="display: none;">
                <!-- Characters will be dynamically inserted here -->
            </div>

            <div class="database-list" id="worldList" style="display: none;">
                <!-- World elements will be dynamically inserted here -->
            </div>

            <div class="database-list" id="timelineList" style="display: none;">
                <!-- Timeline events will be dynamically inserted here -->
            </div>

            <div class="database-list" id="notesList" style="display: none;">
                <!-- Notes will be dynamically inserted here -->
            </div>

            <div class="database-list" id="codexList" style="display: none;">
                <!-- Codex entries will be dynamically inserted here -->
            </div>

            <div class="database-list" id="statsList" style="display: none;">
                <!-- Statistics will be dynamically inserted here -->
            </div>

            <div class="database-list" id="versionsList" style="display: none;">
                <!-- Versions will be dynamically inserted here -->
            </div>

            <div class="database-list" id="analysisList" style="display: none;">
                <!-- Analysis will be dynamically inserted here -->
            </div>

            <div class="database-list" id="corkboardList" style="display: none;">
                <!-- Cork Board info will be here -->
            </div>

            <div class="database-list" id="mindmapList" style="display: none;">
                <!-- Mindmap will be here -->
            </div>

            <div class="database-list" id="plotList" style="display: none;">
                <!-- Plot graph will be here -->
            </div>

            <div class="database-list" id="relationsList" style="display: none;">
                <!-- Relations graph will be here -->
            </div>

            <div class="database-list" id="mapList" style="display: none;">
                <!-- World map will be here -->
            </div>

            <div class="database-list" id="timelineVizList" style="display: none;">
                <!-- Visual timeline will be here -->
            </div>

            <div class="database-list" id="todosList" style="display: none;">
                <!-- TODOs list will be here -->
            </div>

            <div class="sidebar-actions" id="sidebarActions">
                <button class="btn btn-primary" onclick="openAddActModal()">+ Acte</button>
                <button class="btn" onclick="showBackupMenu()">💾 Sauvegarde</button>
            </div>
        </div>

        <!-- Main Editor -->
        <div class="editor-container" id="editorView">
            <div class="empty-state">
                <div class="empty-state-icon">✍️</div>
                <div class="empty-state-title">Commencez votre histoire</div>
                <div class="empty-state-text">
                    Créez votre premier chapitre pour commencer à écrire votre roman.
                </div>
                    <button class="btn btn-primary" onclick="openAddChapterModal()">Créer un chapitre</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Add Act Modal -->
    <div class="modal" id="addActModal">
        <div class="modal-content">
            <div class="modal-title">Nouvel Acte</div>
            <div class="form-group">
                <label class="form-label">Titre de l'acte</label>
                <input type="text" class="form-input" id="actTitleInput" placeholder="Acte I : L'Éveil">
            </div>
            <div class="modal-actions">
                <button class="btn" onclick="closeModal('addActModal')">Annuler</button>
                <button class="btn btn-primary" onclick="addAct()">Créer</button>
            </div>
        </div>
    </div>

    <!-- Add Chapter Modal -->
    <div class="modal" id="addChapterModal">
        <div class="modal-content">
            <div class="modal-title">Nouveau Chapitre</div>
            <div class="form-group">
                <label class="form-label">Titre du chapitre</label>
                <input type="text" class="form-input" id="chapterTitleInput" placeholder="Chapitre 1 : Le Début">
            </div>
            <div class="modal-actions">
                <button class="btn" onclick="closeModal('addChapterModal')">Annuler</button>
                <button class="btn btn-primary" onclick="addChapter()">Créer</button>
            </div>
        </div>
    </div>

    <!-- Add Scene Modal -->
    <div class="modal" id="addSceneModal">
        <div class="modal-content">
            <div class="modal-title">Nouvelle Scène</div>
            <div class="form-group">
                <label class="form-label">Titre de la scène</label>
                <input type="text" class="form-input" id="sceneTitleInput" placeholder="Scène 1 : Rencontre">
            </div>
            <div class="modal-actions">
                <button class="btn" onclick="closeModal('addSceneModal')">Annuler</button>
                <button class="btn btn-primary" onclick="addScene()">Créer</button>
            </div>
        </div>
    </div>

    <!-- Add Character Modal -->
    <div class="modal" id="addCharacterModal">
        <div class="modal-content">
            <div class="modal-title">Nouveau Personnage</div>
            <div class="form-group">
                <label class="form-label">Nom du personnage</label>
                <input type="text" class="form-input" id="characterNameInput" placeholder="Akiko">
            </div>
            <div class="form-group">
                <label class="form-label">Rôle</label>
                <input type="text" class="form-input" id="characterRoleInput" placeholder="Protagoniste, Antagoniste, Allié...">
            </div>
            <div class="form-group">
                <label class="form-label">Description rapide</label>
                <textarea class="form-input" id="characterDescInput" placeholder="Description du personnage..." rows="3"></textarea>
            </div>
            <div class="modal-actions">
                <button class="btn" onclick="closeModal('addCharacterModal')">Annuler</button>
                <button class="btn btn-primary" onclick="addCharacter()">Créer</button>
            </div>
        </div>
    </div>

    <!-- Add World Element Modal -->
    <div class="modal" id="addWorldModal">
        <div class="modal-content">
            <div class="modal-title">Nouvel Élément d'Univers</div>
            <div class="form-group">
                <label class="form-label">Nom</label>
                <input type="text" class="form-input" id="worldNameInput" placeholder="Cité de Voile">
            </div>
            <div class="form-group">
                <label class="form-label">Type</label>
                <select class="form-input" id="worldTypeInput">
                    <option value="Lieu">Lieu</option>
                    <option value="Objet">Objet</option>
                    <option value="Concept">Concept</option>
                    <option value="Organisation">Organisation</option>
                    <option value="Événement">Événement</option>
                </select>
            </div>
            <div class="form-group">
                <label class="form-label">Description rapide</label>
                <textarea class="form-input" id="worldDescInput" placeholder="Description de l'élément..." rows="3"></textarea>
            </div>
            <div class="modal-actions">
                <button class="btn" onclick="closeModal('addWorldModal')">Annuler</button>
                <button class="btn btn-primary" onclick="addWorldElement()">Créer</button>
            </div>
        </div>
    </div>

    <!-- Add Timeline Event Modal -->
    <div class="modal" id="addTimelineModal">
        <div class="modal-content">
            <div class="modal-title">Nouvel Événement</div>
            <div class="form-group">
                <label class="form-label">Titre de l'événement</label>
                <input type="text" class="form-input" id="timelineTitleInput" placeholder="La grande bataille">
            </div>
            <div class="form-group">
                <label class="form-label">Date / Moment</label>
                <input type="text" class="form-input" id="timelineDateInput" placeholder="An 2157, Printemps / Chapitre 5 / Jour 3...">
            </div>
            <div class="form-group">
                <label class="form-label">Localisation</label>
                <input type="text" class="form-input" id="timelineLocationInput" placeholder="Cité de Voile">
            </div>
            <div class="form-group">
                <label class="form-label">Personnages impliqués</label>
                <input type="text" class="form-input" id="timelineCharactersInput" placeholder="Akiko, Sora, Kumi...">
            </div>
            <div class="form-group">
                <label class="form-label">Description</label>
                <textarea class="form-input" id="timelineDescInput" placeholder="Description de l'événement..." rows="4"></textarea>
            </div>
            <div class="modal-actions">
                <button class="btn" onclick="closeModal('addTimelineModal')">Annuler</button>
                <button class="btn btn-primary" onclick="addTimelineEvent()">Créer</button>
            </div>
        </div>
    </div>

    <!-- Add Note Modal -->
    <div class="modal" id="addNoteModal">
        <div class="modal-content">
            <div class="modal-title">Nouvelle Note</div>
            <div class="form-group">
                <label class="form-label">Titre de la note</label>
                <input type="text" class="form-input" id="noteTitleInput" placeholder="Recherche sur les sanctuaires Shinto">
            </div>
            <div class="form-group">
                <label class="form-label">Catégorie</label>
                <select class="form-input" id="noteCategoryInput">
                    <option value="Recherche">Recherche</option>
                    <option value="Idée">Idée</option>
                    <option value="Référence">Référence</option>
                    <option value="A faire">À faire</option>
                    <option value="Question">Question</option>
                    <option value="Autre">Autre</option>
                </select>
            </div>
            <div class="form-group">
                <label class="form-label">Tags (séparés par des virgules)</label>
                <input type="text" class="form-input" id="noteTagsInput" placeholder="shinto, religion, japon">
            </div>
            <div class="form-group">
                <label class="form-label">Contenu</label>
                <textarea class="form-input" id="noteContentInput" placeholder="Contenu de la note..." rows="6"></textarea>
            </div>
            <div class="modal-actions">
                <button class="btn" onclick="closeModal('addNoteModal')">Annuler</button>
                <button class="btn btn-primary" onclick="addNote()">Créer</button>
            </div>
        </div>
    </div>

    <!-- Add Codex Entry Modal -->
    <div class="modal" id="addCodexModal">
        <div class="modal-content">
            <div class="modal-title">Nouvelle Entrée Codex</div>
            <div class="form-group">
                <label class="form-label">Titre</label>
                <input type="text" class="form-input" id="codexTitleInput" placeholder="Les Sanctuaires Shinto">
            </div>
            <div class="form-group">
                <label class="form-label">Catégorie</label>
                <select class="form-input" id="codexCategoryInput">
                    <option value="Culture">Culture</option>
                    <option value="Histoire">Histoire</option>
                    <option value="Technologie">Technologie</option>
                    <option value="Géographie">Géographie</option>
                    <option value="Politique">Politique</option>
                    <option value="Magie/Pouvoir">Magie/Pouvoir</option>
                    <option value="Religion">Religion</option>
                    <option value="Société">Société</option>
                    <option value="Autre">Autre</option>
                </select>
            </div>
            <div class="form-group">
                <label class="form-label">Résumé rapide</label>
                <textarea class="form-input" id="codexSummaryInput" placeholder="Description courte..." rows="3"></textarea>
            </div>
            <div class="modal-actions">
                <button class="btn" onclick="closeModal('addCodexModal')">Annuler</button>
                <button class="btn btn-primary" onclick="addCodexEntry()">Créer</button>
            </div>
        </div>
    </div>

    <!-- Focus Mode Toggle Button -->
    <button class="focus-toggle-btn" onclick="toggleFocusPanel()">⚙️ Paramètres Focus</button>

    <!-- Focus Mode Panel -->
    <div class="focus-mode-panel" id="focusPanel">
        <div class="focus-panel-header">
            <div class="focus-panel-title">🧘 Mode Focus</div>
        </div>
        <div class="focus-panel-content">
            <!-- Pomodoro Timer -->
            <div class="focus-section">
                <div class="focus-section-title">⏱️ Timer Pomodoro</div>
                <div class="pomodoro-timer">
                    <div class="pomodoro-display" id="pomodoroDisplay">25:00</div>
                    <div class="pomodoro-controls">
                        <button class="btn btn-small" onclick="startPomodoro()">▶ Démarrer</button>
                        <button class="btn btn-small" onclick="pausePomodoro()">⏸ Pause</button>
                        <button class="btn btn-small" onclick="resetPomodoro()">↻ Reset</button>
                    </div>
                    <div class="focus-stats">
                        <div class="focus-stat-box">
                            <div class="focus-stat-value" id="pomodorosCompleted">0</div>
                            <div class="focus-stat-label">Pomodoros</div>
                        </div>
                        <div class="focus-stat-box">
                            <div class="focus-stat-value" id="focusWordCount">0</div>
                            <div class="focus-stat-label">Mots</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Focus Settings -->
            <div class="focus-section">
                <div class="focus-section-title">⚙️ Paramètres</div>
                <div style="display: flex; flex-direction: column; gap: 0.75rem;">
                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                        <input type="checkbox" id="hideToolbar" onchange="toggleToolbar()">
                        <span>Masquer la barre d'outils</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                        <input type="checkbox" id="hideLinksPanel" onchange="toggleLinksPanel()">
                        <span>Masquer le panneau de liens</span>
                    </label>
                </div>
            </div>

            <!-- Exit Focus Mode -->
            <div class="focus-section">
                <button class="btn btn-primary" style="width: 100%;" onclick="toggleFocusMode()">
                    ← Quitter le mode Focus
                </button>
            </div>
        </div>
    </div>

    <!-- Projects Management Modal -->
    <div class="modal" id="projectsModal">
        <div class="modal-content" style="max-width: 800px;">
            <div class="modal-title">📂 Mes Projets</div>
            
            <div style="margin-bottom: 2rem;">
                <button class="btn btn-primary" onclick="openNewProjectModal()">+ Nouveau Projet</button>
                <button class="btn" onclick="importProject()">📥 Importer un projet</button>
            </div>

            <div id="projectsList" style="max-height: 400px; overflow-y: auto;">
                <!-- Projects will be listed here -->
            </div>

            <div class="modal-actions">
                <button class="btn" onclick="closeModal('projectsModal')">Fermer</button>
            </div>
        </div>
    </div>

    <!-- New Project Modal -->
    <div class="modal" id="newProjectModal">
        <div class="modal-content">
            <div class="modal-title">Nouveau Projet</div>
            
            <div class="form-group">
                <label class="form-label">Titre du projet</label>
                <input type="text" class="form-input" id="newProjectTitle" placeholder="Mon Roman">
            </div>
            
            <div class="form-group">
                <label class="form-label">Description (optionnel)</label>
                <textarea class="form-input" id="newProjectDesc" placeholder="Un roman de fantasy épique..." rows="3"></textarea>
            </div>
            
            <div class="form-group">
                <label class="form-label">Genre</label>
                <select class="form-input" id="newProjectGenre">
                    <option value="">Aucun</option>
                    <option value="Fantasy">Fantasy</option>
                    <option value="Science-Fiction">Science-Fiction</option>
                    <option value="Thriller">Thriller</option>
                    <option value="Romance">Romance</option>
                    <option value="Policier">Policier</option>
                    <option value="Horreur">Horreur</option>
                    <option value="Historique">Historique</option>
                    <option value="Aventure">Aventure</option>
                    <option value="Drame">Drame</option>
                    <option value="Autre">Autre</option>
                </select>
            </div>

            <div class="form-group">
                <label class="form-label">Utiliser un template ?</label>
                <select class="form-input" id="newProjectTemplate">
                    <option value="">Projet vide</option>
                    <option value="fantasy">Fantasy (3 actes + personnages types)</option>
                    <option value="thriller">Thriller (Structure suspense)</option>
                    <option value="scifi">Science-Fiction (Worldbuilding avancé)</option>
                </select>
            </div>
            
            <div class="modal-actions">
                <button class="btn" onclick="closeModal('newProjectModal')">Annuler</button>
                <button class="btn btn-primary" onclick="createNewProject()">Créer</button>
            </div>
        </div>
    </div>

    <input type="file" id="importProjectInput" accept=".json" style="display: none;" onchange="handleProjectImport(event)">

    <!-- Backup Menu Modal -->
    <div class="modal" id="backupModal">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-title">💾 Sauvegardes et Exports</div>
            
            <div style="margin-bottom: 2rem;">
                <div style="font-size: 1rem; font-weight: 600; margin-bottom: 1rem; color: var(--text-primary);">📥 Importer des données</div>
                <div style="display: flex; flex-direction: column; gap: 0.75rem;">
                    <button class="btn" onclick="importFromFile()">
                        📂 Importer depuis un fichier JSON
                    </button>
                    <input type="file" id="importFileInput" accept=".json" style="display: none;" onchange="handleFileImport(event)">
                </div>
            </div>

            <div style="margin-bottom: 2rem;">
                <div style="font-size: 1rem; font-weight: 600; margin-bottom: 1rem; color: var(--text-primary);">📤 Exporter les données</div>
                <div style="display: flex; flex-direction: column; gap: 0.75rem;">
                    <button class="btn btn-primary" onclick="openExportNovelModal()" style="font-weight: 600;">
                        📖 Exporter le roman (DOCX, MD, TXT...)
                    </button>
                    <button class="btn" onclick="exportToJSON()">
                        💾 Télécharger en JSON (sauvegarde complète)
                    </button>
                    <button class="btn" onclick="exportProject()">
                        📄 Exporter en TXT (texte seulement)
                    </button>
                </div>
            </div>

            <div style="margin-bottom: 2rem;">
                <div style="font-size: 1rem; font-weight: 600; margin-bottom: 1rem; color: var(--text-primary);">☁️ Cloud (manuel)</div>
                <div style="padding: 1rem; background: var(--bg-secondary); border-radius: 4px; border: 1px solid var(--border-color);">
                    <p style="font-size: 0.9rem; color: var(--text-secondary); margin-bottom: 1rem; line-height: 1.6;">
                        Pour sauvegarder sur Google Drive, Dropbox, ou tout autre service cloud :
                    </p>
                    <ol style="font-size: 0.85rem; color: var(--text-secondary); line-height: 1.8; padding-left: 1.5rem;">
                        <li>Clique sur "Télécharger en JSON"</li>
                        <li>Le fichier contient TOUTES tes données</li>
                        <li>Uploade-le manuellement sur ton service cloud préféré</li>
                        <li>Pour restaurer : télécharge le fichier et utilise "Importer depuis un fichier"</li>
                    </ol>
                </div>
            </div>

            <div style="padding: 1rem; background: rgba(196, 69, 54, 0.1); border-radius: 4px; border: 1px solid var(--accent-red);">
                <div style="font-size: 0.85rem; font-weight: 600; color: var(--accent-red); margin-bottom: 0.5rem;">
                    ⚠️ Important : Sauvegarde régulière
                </div>
                <p style="font-size: 0.8rem; color: var(--text-secondary); line-height: 1.6;">
                    Le localStorage peut être effacé par le navigateur. Pense à exporter régulièrement ton projet en JSON et à le sauvegarder dans un endroit sûr (Google Drive, Dropbox, disque dur, etc.).
                </p>
            </div>

            <div class="modal-actions" style="margin-top: 1.5rem;">
                <button class="btn" onclick="closeModal('backupModal')">Fermer</button>
            </div>
        </div>
    </div>

    <!-- Export Novel Modal -->
    <div class="modal" id="exportNovelModal">
        <div class="modal-content" style="max-width: 700px; max-height: 90vh; overflow-y: auto;">
            <div class="modal-title">📖 Exporter votre roman</div>
            
            <p style="font-size: 0.95rem; color: var(--text-secondary); margin-bottom: 1.5rem; line-height: 1.6;">
                Vous pouvez exporter votre roman dans plusieurs formats. Vous pouvez ensuite importer les données dans d'autres logiciels d'écriture.
            </p>

            <!-- Toggle All Button -->
            <div style="margin-bottom: 1.5rem;">
                <button class="btn btn-small" onclick="toggleAllScenes()" style="width: 100%;">
                    🔄 Tout sélectionner / Tout désélectionner
                </button>
            </div>

            <!-- Acts/Chapters/Scenes Selection Tree -->
            <div style="margin-bottom: 1.5rem; max-height: 300px; overflow-y: auto; border: 1px solid var(--border-color); border-radius: 6px; padding: 1rem; background: var(--bg-secondary);" id="exportTreeContainer">
                <!-- Will be populated by JavaScript -->
            </div>

            <!-- Format Selection -->
            <div style="margin-bottom: 1.5rem;">
                <label style="display: block; font-weight: 600; margin-bottom: 0.75rem; color: var(--text-primary);">
                    Format du fichier
                </label>
                <select id="exportFormatSelect" onchange="updateExportFormatInfo()" style="width: 100%; padding: 0.75rem; background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); font-size: 0.95rem; font-family: 'Crimson Pro', serif;">
                    <option value="docx">📄 Word (.docx)</option>
                    <option value="markdown">📝 Markdown (.md)</option>
                    <option value="txt">📋 Texte brut (.txt)</option>
                    <option value="html">🌐 HTML (.html)</option>
                </select>
                <div id="formatInfoBox" style="margin-top: 0.75rem; padding: 0.75rem; background: rgba(212, 175, 55, 0.1); border-radius: 4px; border: 1px solid var(--accent-gold); font-size: 0.85rem; color: var(--text-secondary); line-height: 1.5;">
                    <strong style="color: var(--text-primary);">ℹ️ Note :</strong> 
                    Toutes les fonctionnalités ne sont pas supportées en format DOCX. Le texte exporté pourrait ne pas ressembler exactement à l'éditeur. Pour une compatibilité complète, utilisez un autre format.
                </div>
            </div>

            <!-- General Options -->
            <div style="margin-bottom: 1.5rem;">
                <label style="display: block; font-weight: 600; margin-bottom: 0.75rem; color: var(--text-primary);">
                    Options générales
                </label>
                <div style="display: flex; flex-direction: column; gap: 0.5rem;">
                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-size: 0.95rem;">
                        <input type="checkbox" id="exportSummariesCheck" style="cursor: pointer;">
                        <span>Exporter les résumés</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-size: 0.95rem;">
                        <input type="checkbox" id="exportProseCheck" checked style="cursor: pointer;">
                        <span>Exporter le texte</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-size: 0.95rem;">
                        <input type="checkbox" id="includeActTitlesCheck" checked style="cursor: pointer;">
                        <span>Inclure les titres d'actes <span style="color: var(--text-muted); font-size: 0.85rem;">(désactiver pour ex. Vellum, Atticus)</span></span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-size: 0.95rem;">
                        <input type="checkbox" id="includeSceneSubtitlesCheck" checked style="cursor: pointer;">
                        <span>Inclure les sous-titres de scènes</span>
                    </label>
                </div>
            </div>

            <!-- Scene Dividers -->
            <div style="margin-bottom: 1.5rem;">
                <label style="display: block; font-weight: 600; margin-bottom: 0.75rem; color: var(--text-primary);">
                    Séparateurs de scènes
                </label>
                <select id="sceneDividerSelect" style="width: 100%; padding: 0.75rem; background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); font-size: 0.95rem; font-family: 'Crimson Pro', serif;">
                    <option value="asterisks">Astérisques ( * * * )</option>
                    <option value="hash">Dièse ( ### )</option>
                    <option value="line">Ligne horizontale (---)</option>
                    <option value="space">Espace vide</option>
                    <option value="none">Aucun séparateur</option>
                </select>
            </div>

            <!-- Project Export (ZIP with all data) -->
            <div style="margin-bottom: 1.5rem; padding: 1rem; background: var(--bg-secondary); border-radius: 6px; border: 1px solid var(--border-color);">
                <label style="display: block; font-weight: 600; margin-bottom: 0.75rem; color: var(--text-primary);">
                    Export du projet complet
                </label>
                <p style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 1rem; line-height: 1.5;">
                    En exportant le projet complet, le fichier résultant sera une archive ZIP contenant tout le contenu sélectionné.
                </p>
                <div style="display: flex; flex-direction: column; gap: 0.5rem;">
                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-size: 0.95rem;">
                        <input type="checkbox" id="includeFullCodexCheck" style="cursor: pointer;">
                        <span>Inclure le Codex complet</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-size: 0.95rem;">
                        <input type="checkbox" id="includeAllSnippetsCheck" style="cursor: pointer;">
                        <span>Inclure tous les extraits</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-size: 0.95rem;">
                        <input type="checkbox" id="includeAllChatsCheck" style="cursor: pointer;">
                        <span>Inclure tous les dialogues</span>
                    </label>
                </div>
            </div>

            <!-- Export Button -->
            <div style="text-align: center; padding-top: 1rem; border-top: 1px solid var(--border-color);">
                <button class="btn btn-primary" onclick="executeNovelExport()" style="padding: 0.75rem 2rem; font-size: 1rem; font-weight: 600;">
                    📥 Exporter
                </button>
            </div>

            <div class="modal-actions" style="margin-top: 1rem;">
                <button class="btn" onclick="closeModal('exportNovelModal')">Annuler</button>
            </div>
        </div>
    </div>

    <!-- Tension Words Editor Modal -->
    <div class="modal" id="tensionWordsModal">
        <div class="modal-content" style="max-width: 900px;">
            <div class="modal-title">✏️ Personnaliser les mots de tension</div>
            
            <div style="margin-bottom: 1.5rem; padding: 1rem; background: var(--bg-secondary); border-radius: 6px; border: 1px solid var(--border-color);">
                <p style="font-size: 0.9rem; color: var(--text-secondary); line-height: 1.6; margin: 0;">
                    Ces mots sont utilisés pour calculer automatiquement la tension narrative de vos scènes. 
                    Personnalisez-les selon votre style d'écriture et le genre de votre roman.
                </p>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 1.5rem; margin-bottom: 1.5rem;">
                <!-- High Tension Words -->
                <div style="background: var(--bg-secondary); border-radius: 8px; padding: 1.25rem; border: 2px solid rgba(196, 69, 54, 0.3);">
                    <h3 style="margin: 0 0 0.75rem 0; font-size: 1rem; color: var(--accent-red); display: flex; align-items: center; gap: 0.5rem;">
                        🔥 Haute tension
                        <span style="font-size: 0.75rem; color: var(--text-muted); font-weight: normal;">(+3 pts chacun)</span>
                    </h3>
                    <div style="margin-bottom: 0.75rem;">
                        <input type="text" id="highTensionInput" placeholder="Ajouter un mot..." 
                               style="width: 100%; padding: 0.5rem; background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); font-size: 0.85rem;"
                               onkeypress="if(event.key==='Enter') addTensionWord('high')">
                        <button onclick="addTensionWord('high')" 
                                style="width: 100%; margin-top: 0.5rem; padding: 0.5rem; background: var(--accent-red); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85rem; font-weight: 500;">
                            + Ajouter
                        </button>
                        <button onclick="openBulkImport('high')" 
                                style="width: 100%; margin-top: 0.5rem; padding: 0.5rem; background: rgba(196, 69, 54, 0.2); color: var(--accent-red); border: 1px solid var(--accent-red); border-radius: 4px; cursor: pointer; font-size: 0.85rem; font-weight: 500;">
                            📥 Import en masse
                        </button>
                    </div>
                    <div id="highTensionList" style="max-height: 300px; overflow-y: auto; display: flex; flex-direction: column; gap: 0.4rem;">
                        <!-- Words will be added here -->
                    </div>
                </div>

                <!-- Medium Tension Words -->
                <div style="background: var(--bg-secondary); border-radius: 8px; padding: 1.25rem; border: 2px solid rgba(230, 162, 60, 0.3);">
                    <h3 style="margin: 0 0 0.75rem 0; font-size: 1rem; color: #e6a23c; display: flex; align-items: center; gap: 0.5rem;">
                        ⚡ Tension moyenne
                        <span style="font-size: 0.75rem; color: var(--text-muted); font-weight: normal;">(+1.5 pts chacun)</span>
                    </h3>
                    <div style="margin-bottom: 0.75rem;">
                        <input type="text" id="mediumTensionInput" placeholder="Ajouter un mot..." 
                               style="width: 100%; padding: 0.5rem; background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); font-size: 0.85rem;"
                               onkeypress="if(event.key==='Enter') addTensionWord('medium')">
                        <button onclick="addTensionWord('medium')" 
                                style="width: 100%; margin-top: 0.5rem; padding: 0.5rem; background: #e6a23c; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85rem; font-weight: 500;">
                            + Ajouter
                        </button>
                        <button onclick="openBulkImport('medium')" 
                                style="width: 100%; margin-top: 0.5rem; padding: 0.5rem; background: rgba(230, 162, 60, 0.2); color: #e6a23c; border: 1px solid #e6a23c; border-radius: 4px; cursor: pointer; font-size: 0.85rem; font-weight: 500;">
                            📥 Import en masse
                        </button>
                    </div>
                    <div id="mediumTensionList" style="max-height: 300px; overflow-y: auto; display: flex; flex-direction: column; gap: 0.4rem;">
                        <!-- Words will be added here -->
                    </div>
                </div>

                <!-- Low Tension Words -->
                <div style="background: var(--bg-secondary); border-radius: 8px; padding: 1.25rem; border: 2px solid rgba(74, 144, 226, 0.3);">
                    <h3 style="margin: 0 0 0.75rem 0; font-size: 1rem; color: var(--accent-blue); display: flex; align-items: center; gap: 0.5rem;">
                        🌊 Faible tension
                        <span style="font-size: 0.75rem; color: var(--text-muted); font-weight: normal;">(-2 pts chacun)</span>
                    </h3>
                    <div style="margin-bottom: 0.75rem;">
                        <input type="text" id="lowTensionInput" placeholder="Ajouter un mot..." 
                               style="width: 100%; padding: 0.5rem; background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); font-size: 0.85rem;"
                               onkeypress="if(event.key==='Enter') addTensionWord('low')">
                        <button onclick="addTensionWord('low')" 
                                style="width: 100%; margin-top: 0.5rem; padding: 0.5rem; background: #2d6bb3; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85rem; font-weight: 500;">
                            + Ajouter
                        </button>
                        <button onclick="openBulkImport('low')" 
                                style="width: 100%; margin-top: 0.5rem; padding: 0.5rem; background: rgba(45, 107, 179, 0.15); color: #2d6bb3; border: 1px solid #2d6bb3; border-radius: 4px; cursor: pointer; font-size: 0.85rem; font-weight: 500;">
                            📥 Import en masse
                        </button>
                    </div>
                    <div id="lowTensionList" style="max-height: 300px; overflow-y: auto; display: flex; flex-direction: column; gap: 0.4rem;">
                        <!-- Words will be added here -->
                    </div>
                </div>
            </div>

            <div class="modal-actions" style="display: flex; justify-content: space-between; align-items: center;">
                <div style="display: flex; gap: 0.75rem;">
                    <button class="btn" onclick="exportTensionWords()" style="background: #2d6bb3; color: white; border: 1px solid #2d6bb3;">
                        📤 Exporter les dictionnaires
                    </button>
                    <button class="btn" onclick="resetTensionWordsToDefault()" style="background: var(--accent-red); color: white;">
                        🔄 Réinitialiser aux valeurs par défaut
                    </button>
                </div>
                <div style="display: flex; gap: 0.75rem;">
                    <button class="btn" onclick="closeModal('tensionWordsModal')">Annuler</button>
                    <button class="btn btn-primary" onclick="saveTensionWords()">💾 Enregistrer</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Bulk Import Modal -->
    <div class="modal" id="bulkImportModal">
        <div class="modal-content" style="max-width: 700px;">
            <div class="modal-title" id="bulkImportTitle">📥 Import en masse</div>
            
            <div style="margin-bottom: 1.5rem;">
                <p style="font-size: 0.9rem; color: var(--text-secondary); line-height: 1.6; margin-bottom: 1rem;">
                    Importez une liste de mots en masse. Vous pouvez :
                </p>
                <ul style="font-size: 0.85rem; color: var(--text-secondary); line-height: 1.8; padding-left: 1.5rem;">
                    <li><strong>Coller du texte</strong> : Un mot par ligne ou séparés par des virgules</li>
                    <li><strong>Importer un fichier</strong> : Fichier .txt avec un mot par ligne</li>
                </ul>
            </div>

            <div style="margin-bottom: 1.5rem;">
                <label class="form-label">Collez vos mots ici :</label>
                <textarea id="bulkImportText" 
                          placeholder="Ex: combat, bataille, mort&#10;tuer, danger, peur&#10;terreur, cri, hurler" 
                          style="width: 100%; min-height: 200px; padding: 0.75rem; background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); font-size: 0.85rem; font-family: monospace; resize: vertical;">
                </textarea>
                <div style="font-size: 0.75rem; color: var(--text-muted); margin-top: 0.5rem;">
                    💡 Formats acceptés : un mot par ligne, ou plusieurs mots séparés par des virgules
                </div>
            </div>

            <div style="margin-bottom: 1.5rem;">
                <label class="form-label">Ou importez un fichier .txt :</label>
                <input type="file" id="bulkImportFile" accept=".txt" 
                       style="width: 100%; padding: 0.5rem; background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); font-size: 0.85rem;">
            </div>

            <div style="padding: 1rem; background: rgba(74, 144, 226, 0.1); border-radius: 4px; border: 1px solid var(--accent-blue); margin-bottom: 1.5rem;">
                <div style="font-size: 0.85rem; font-weight: 600; color: var(--accent-blue); margin-bottom: 0.5rem;">
                    ℹ️ Mode de fusion
                </div>
                <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; margin-bottom: 0.5rem;">
                    <input type="radio" name="importMode" value="add" checked>
                    <span style="font-size: 0.85rem; color: var(--text-primary);">Ajouter aux mots existants (recommandé)</span>
                </label>
                <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                    <input type="radio" name="importMode" value="replace">
                    <span style="font-size: 0.85rem; color: var(--text-primary);">Remplacer tous les mots existants</span>
                </label>
            </div>

            <div class="modal-actions">
                <button class="btn" onclick="closeModal('bulkImportModal')">Annuler</button>
                <button class="btn btn-primary" onclick="processBulkImport()">📥 Importer les mots</button>
            </div>
        </div>
    </div>

    <!-- References Panel Modal -->
    <div class="modal" id="referencesModal">
        <div class="modal-content" style="max-width: 700px;">
            <div class="modal-title" id="referencesModalTitle">Références et Liens</div>
            <div id="referencesModalContent"></div>
            <div class="modal-actions">
                <button class="btn" onclick="closeModal('referencesModal')">Fermer</button>
            </div>
        </div>
    </div>


    <!-- Annotations Panel -->
    <div class="annotations-panel" id="annotationsPanel">
        <div class="annotations-panel-spacer"></div>
        <div class="annotations-panel-content" id="annotationsPanelContent"></div>
    </div>

    <!-- Annotation Popup -->
    <div class="annotation-popup" id="annotationPopup">
        <h3 style="margin-bottom: 1rem;">Ajouter une annotation</h3>
        <div class="annotation-type-selector">
            <div class="annotation-type-btn comment active" onclick="selectAnnotationType('comment')">💬 Commentaire</div>
            <div class="annotation-type-btn todo" onclick="selectAnnotationType('todo')">✓ TODO</div>
            <div class="annotation-type-btn note" onclick="selectAnnotationType('note')">📝 Note</div>
            <div class="annotation-type-btn question" onclick="selectAnnotationType('question')">? Question</div>
        </div>
        <textarea id="annotationText" placeholder="Votre annotation..."></textarea>
        <div style="display: flex; gap: 0.75rem; justify-content: flex-end;">
            <button class="btn" onclick="closeAnnotationPopup()">Annuler</button>
            <button class="btn btn-primary" onclick="saveAnnotation()">Enregistrer</button>
        </div>
    </div>

    <script>
        // Data Structure
        let projects = []; // Array of all projects
        let currentProjectId = null;
        let project = {
            id: null,
            title: "Mon Roman",
            description: "",
            genre: "",
            createdAt: null,
            updatedAt: null,
            acts: [], // Acts contain chapters, chapters contain scenes
            characters: [], // Character database
            world: [], // World elements (locations, objects, concepts)
            timeline: [], // Timeline events
            notes: [], // Standalone notes and research
            codex: [], // Wiki/Codex entries for worldbuilding
            stats: {
                dailyGoal: 500,
                totalGoal: 80000,
                writingSessions: [] // Track writing sessions with word count and date
            },
            versions: [], // Version history snapshots
            relationships: [], // Cross-references between elements
            relations: [], // Character relations with types and colors
            characterPositions: {}, // Custom positions for relations graph
            mapLocations: [], // Geographic map markers
            mapImage: null, // Map image data URL
            visualTimeline: [] // Timeline visualization events
        };

        let currentActId = null;
        let currentChapterId = null;
        let currentSceneId = null;
        let activeActId = null;
        let activeChapterId = null;
        let currentView = 'editor'; // 'editor', 'characters', 'world', 'timeline', 'notes', 'stats', 'codex', 'versions'

        // TREE STATE - pour mémoriser l'état d'expansion
        let expandedActs = new Set(); // IDs des actes dépliés
        let expandedChapters = new Set(); // IDs des chapitres dépliés

        // REVISION MODE VARIABLES
        let revisionMode = false;
        let selectedHighlightColor = 'yellow';
        let selectedAnnotationType = 'comment';
        let currentSelection = null; // 'editor', 'characters', 'world', 'timeline', 'notes', 'stats', 'codex', 'versions'

        // UNDO/REDO SYSTEM
        let historyStack = []; // Stack pour les états précédents
        let redoStack = []; // Stack pour redo
        let maxHistorySize = 50; // Garder max 50 états
        let isUndoRedoAction = false; // Flag pour éviter de sauvegarder pendant undo/redo
        let historyDebounceTimer = null; // Timer pour debounce
        let historyDebounceDelay = 2000; // 2 secondes de délai

        // View Management (définie tôt pour être accessible partout)
        function switchView(view) {
            currentView = view;
            
            // Update header nav buttons
            document.querySelectorAll('[id^="header-tab-"]').forEach(btn => {
                btn.classList.remove('active');
            });
            const headerBtn = document.getElementById(`header-tab-${view}`);
            if (headerBtn) {
                headerBtn.classList.add('active');
            }
            
            // Cacher toutes les listes de la sidebar
            const sidebarLists = [
                'chaptersList', 'charactersList', 'worldList', 'timelineList', 
                'notesList', 'codexList', 'statsList', 'versionsList', 'analysisList',
                'todosList', 'corkboardList', 'mindmapList', 'plotList', 
                'relationsList', 'mapList', 'timelineVizList'
            ];
            
            sidebarLists.forEach(listId => {
                const el = document.getElementById(listId);
                if (el) el.style.display = 'none';
            });
            
            // Vues qui utilisent la sidebar (listes à gauche)
            const sidebarViews = {
                'editor': 'chaptersList',
                'characters': 'charactersList',
                'world': 'worldList',
                'notes': 'notesList',
                'codex': 'codexList'
            };
            
            // Vues qui utilisent editorView entièrement (visualisations)
            const editorViewVues = ['stats', 'analysis', 'versions', 'todos', 'corkboard', 
                                    'mindmap', 'plot', 'relations', 'map', 'timelineviz'];
            
            // Afficher la bonne liste sidebar si applicable
            if (sidebarViews[view]) {
                const listEl = document.getElementById(sidebarViews[view]);
                if (listEl) listEl.style.display = 'block';
            }
            
            // Pour les vues editorView, on cache la structure et on affiche dans editorView
            const editorView = document.getElementById('editorView');
            if (editorViewVues.includes(view)) {
                // Ces vues remplissent l'editorView
                if (editorView) {
                    // Le contenu sera rempli par les fonctions de rendu
                }
            }
            
            // Update sidebar actions
            const actionsHTML = {
                editor: '<button class="btn btn-primary" onclick="openAddActModal()">+ Acte</button><button class="btn" onclick="showBackupMenu()">💾 Sauvegarde</button>',
                characters: '<button class="btn btn-primary" onclick="openAddCharacterModal()">+ Personnage</button><button class="btn btn-small" onclick="showBackupMenu()">💾</button>',
                world: '<button class="btn btn-primary" onclick="openAddWorldModal()">+ Élément</button><button class="btn btn-small" onclick="showBackupMenu()">💾</button>',
                notes: '<button class="btn btn-primary" onclick="openAddNoteModal()">+ Note</button><button class="btn btn-small" onclick="showBackupMenu()">💾</button>',
                codex: '<button class="btn btn-primary" onclick="openAddCodexModal()">+ Entrée</button><button class="btn btn-small" onclick="showBackupMenu()">💾</button>'
            };
            const sidebarActions = document.getElementById('sidebarActions');
            if (sidebarActions) {
                sidebarActions.innerHTML = actionsHTML[view] || '<button class="btn" onclick="showBackupMenu()">💾 Sauvegarde</button>';
            }
            
            // Render appropriate content
            if (view === 'characters') {
                if (typeof renderCharactersList === 'function') renderCharactersList();
            } else if (view === 'world') {
                if (typeof renderWorldList === 'function') renderWorldList();
            } else if (view === 'notes') {
                if (typeof renderNotesList === 'function') renderNotesList();
            } else if (view === 'codex') {
                if (typeof renderCodexList === 'function') renderCodexList();
            } else if (view === 'stats') {
                if (typeof renderStats === 'function') renderStats();
            } else if (view === 'analysis') {
                if (typeof renderAnalysis === 'function') renderAnalysis();
            } else if (view === 'versions') {
                if (typeof renderVersionsList === 'function') renderVersionsList();
            } else if (view === 'todos') {
                if (typeof renderTodosList === 'function') renderTodosList();
            } else if (view === 'corkboard') {
                if (typeof openCorkBoardView === 'function') openCorkBoardView();
            } else if (view === 'mindmap') {
                if (typeof renderMindmapView === 'function') renderMindmapView();
            } else if (view === 'plot') {
                if (typeof renderPlotView === 'function') renderPlotView();
            } else if (view === 'relations') {
                if (typeof renderRelationsView === 'function') renderRelationsView();
            } else if (view === 'map') {
                if (typeof renderMapView === 'function') renderMapView();
            } else if (view === 'timelineviz') {
                if (typeof renderTimelineVizView === 'function') renderTimelineVizView();
            }
        }

        let lastSavedState = null; // Dernier état sauvegardé pour détecter les changements

        // Projects Management
        function openProjectsModal() {
            renderProjectsList();
            document.getElementById('projectsModal').classList.add('active');
        }

        function openNewProjectModal() {
            document.getElementById('newProjectModal').classList.add('active');
            setTimeout(() => document.getElementById('newProjectTitle').focus(), 100);
        }

        function createNewProject() {
            const title = document.getElementById('newProjectTitle').value.trim();
            const description = document.getElementById('newProjectDesc').value.trim();
            const genre = document.getElementById('newProjectGenre').value;
            const template = document.getElementById('newProjectTemplate').value;

            if (!title) {
                alert('Veuillez entrer un titre pour le projet');
                return;
            }

            const newProject = {
                id: Date.now(),
                title: title,
                description: description,
                genre: genre,
                createdAt: new Date().toISOString(),
                updatedAt: new Date().toISOString(),
                acts: [],
                characters: [],
                world: [],
                timeline: [],
                notes: [],
                codex: [],
                stats: { dailyGoal: 500, totalGoal: 80000, writingSessions: [] },
                versions: [],
                relationships: []
            };

            // Apply template if selected
            if (template === 'fantasy') {
                newProject.acts = [
                    { id: Date.now(), title: "Acte I - Le Monde Ordinaire", chapters: [] },
                    { id: Date.now() + 1, title: "Acte II - L'Aventure", chapters: [] },
                    { id: Date.now() + 2, title: "Acte III - Le Retour", chapters: [] }
                ];
                newProject.stats.dailyGoal = 1000;
                newProject.stats.totalGoal = 120000;
            } else if (template === 'thriller') {
                newProject.acts = [
                    { id: Date.now(), title: "Acte I - L'Incident", chapters: [] },
                    { id: Date.now() + 1, title: "Acte II - La Tension", chapters: [] },
                    { id: Date.now() + 2, title: "Acte III - Le Dénouement", chapters: [] }
                ];
                newProject.stats.dailyGoal = 800;
                newProject.stats.totalGoal = 90000;
            } else if (template === 'scifi') {
                newProject.acts = [
                    { id: Date.now(), title: "Acte I - Découverte", chapters: [] },
                    { id: Date.now() + 1, title: "Acte II - Exploration", chapters: [] },
                    { id: Date.now() + 2, title: "Acte III - Révélation", chapters: [] }
                ];
                newProject.stats.dailyGoal = 1000;
                newProject.stats.totalGoal = 150000;
            }

            projects.push(newProject);
            saveAllProjects();
            
            document.getElementById('newProjectTitle').value = '';
            document.getElementById('newProjectDesc').value = '';
            document.getElementById('newProjectGenre').value = '';
            document.getElementById('newProjectTemplate').value = '';
            
            closeModal('newProjectModal');
            switchToProject(newProject.id);
            closeModal('projectsModal');
        }

        function switchToProject(projectId) {
            currentProjectId = projectId;
            project = projects.find(p => p.id === projectId);
            
            if (!project) return;

            const headerTitle = document.getElementById('headerProjectTitle');
            if (headerTitle) headerTitle.textContent = project.title;
            
            currentActId = null;
            currentChapterId = null;
            currentSceneId = null;
            
            switchView('editor');
            renderActsList();
            showEmptyState();
            
            localStorage.setItem('novelcraft_current_project', projectId);
        }

        function deleteProject(projectId) {
            const proj = projects.find(p => p.id === projectId);
            if (!proj) return;

            if (!confirm(`Supprimer "${proj.title}" ?\n\nIrréversible !`)) return;

            projects = projects.filter(p => p.id !== projectId);
            saveAllProjects();

            if (currentProjectId === projectId) {
                if (projects.length > 0) {
                    switchToProject(projects[0].id);
                } else {
                    createDefaultProject();
                }
            }

            renderProjectsList();
        }

        function exportProjectIndividual(projectId) {
            const proj = projects.find(p => p.id === projectId);
            if (!proj) return;

            const dataStr = JSON.stringify(proj, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${proj.title.replace(/\s+/g, '_')}_${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function importProject() {
            document.getElementById('importProjectInput').click();
        }

        function handleProjectImport(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const imported = JSON.parse(e.target.result);
                    if (!imported.title) throw new Error('Format invalide');

                    imported.id = Date.now();
                    imported.title += " (Importé)";
                    imported.createdAt = new Date().toISOString();
                    imported.updatedAt = new Date().toISOString();

                    projects.push(imported);
                    saveAllProjects();
                    renderProjectsList();
                    alert(`✅ "${imported.title}" importé !`);
                } catch (error) {
                    alert('❌ Erreur: ' + error.message);
                }
                event.target.value = '';
            };
            reader.readAsText(file);
        }

        function renderProjectsList() {
            const container = document.getElementById('projectsList');
            
            if (projects.length === 0) {
                container.innerHTML = '<div style="padding: 2rem; text-align: center; color: var(--text-muted);">Aucun projet</div>';
                return;
            }

            container.innerHTML = projects.map(proj => {
                const wordCount = proj.acts.reduce((sum, act) => sum + act.chapters.reduce((ch, chapter) => ch + chapter.scenes.reduce((sc, scene) => sc + getWordCount(scene.content), 0), 0), 0);
                const isActive = proj.id === currentProjectId;

                return `
                    <div class="project-card ${isActive ? 'active' : ''}" onclick="switchToProject(${proj.id}); closeModal('projectsModal');">
                        <div class="project-card-header">
                            <div>
                                <div class="project-card-title">${proj.title}</div>
                                ${proj.genre ? `<span class="project-card-genre">${proj.genre}</span>` : ''}
                            </div>
                            ${isActive ? '<span style="color: var(--accent-red); font-weight: 600;">● Actif</span>' : ''}
                        </div>
                        ${proj.description ? `<div class="project-card-desc">${proj.description}</div>` : ''}
                        <div class="project-card-stats">
                            <span>${wordCount.toLocaleString('fr-FR')} mots</span>
                            <span>${proj.acts.length} actes</span>
                            <span>${proj.characters.length} personnages</span>
                        </div>
                        <div class="project-card-actions">
                            <button class="btn btn-small" onclick="event.stopPropagation(); exportProjectIndividual(${proj.id})">📤 Exporter</button>
                            <button class="btn btn-small" onclick="event.stopPropagation(); deleteProject(${proj.id})">🗑️ Supprimer</button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function saveAllProjects() {
            if (currentProjectId) {
                const index = projects.findIndex(p => p.id === currentProjectId);
                if (index >= 0) {
                    projects[index] = { ...project, updatedAt: new Date().toISOString() };
                }
            }
            localStorage.setItem('novelcraft_projects', JSON.stringify(projects));
            localStorage.setItem('novelcraft_current_project', currentProjectId);
        }

        function loadAllProjects() {
            const saved = localStorage.getItem('novelcraft_projects');
            const savedId = localStorage.getItem('novelcraft_current_project');

            if (saved) {
                projects = JSON.parse(saved);
                if (savedId) {
                    currentProjectId = parseInt(savedId);
                    project = projects.find(p => p.id === currentProjectId);
                }
                if (!project && projects.length > 0) {
                    project = projects[0];
                    currentProjectId = project.id;
                }
            } else {
                const old = localStorage.getItem('novelcraft_project');
                if (old) {
                    const parsed = JSON.parse(old);
                    project = {
                        id: Date.now(),
                        title: parsed.title || "Mon Roman",
                        description: "",
                        genre: "",
                        createdAt: new Date().toISOString(),
                        updatedAt: new Date().toISOString(),
                        ...parsed
                    };
                    projects = [project];
                    currentProjectId = project.id;
                } else {
                    createDefaultProject();
                }
            }

            ensureProjectStructure();
            if (project?.title) {
                const headerTitle = document.getElementById('headerProjectTitle');
                if (headerTitle) headerTitle.textContent = project.title;
            }
        }

        function createDefaultProject() {
            project = {
                id: Date.now(),
                title: "Mon Roman",
                description: "",
                genre: "",
                createdAt: new Date().toISOString(),
                updatedAt: new Date().toISOString(),
                acts: [],
                characters: [],
                world: [],
                timeline: [],
                notes: [],
                codex: [],
                stats: { dailyGoal: 500, totalGoal: 80000, writingSessions: [] },
                versions: [],
                relationships: []
            };
            projects = [project];
            currentProjectId = project.id;
        }

        function ensureProjectStructure() {
            if (!project) return;
            project.characters = project.characters || [];
            project.world = project.world || [];
            project.timeline = project.timeline || [];
            project.notes = project.notes || [];
            project.codex = project.codex || [];
            project.stats = project.stats || { dailyGoal: 500, totalGoal: 80000, writingSessions: [] };
            project.versions = project.versions || [];
            project.relationships = project.relationships || [];
        }

        const originalSaveProject = saveProject;
        saveProject = function() {
            saveAllProjects();
        };

        // Text Analysis Tools
        function renderAnalysis() {
            const editorView = document.getElementById('editorView');
            if (!editorView) {
                console.error('editorView not found');
                return;
            }
            
            editorView.innerHTML = `
                <div style="height: 100%; overflow-y: auto; padding: 2rem 3rem;">
                    <h2 style="margin-bottom: 2rem; color: var(--accent-gold);">🔬 Analyse du texte</h2>
                    
                    <div style="background: var(--bg-secondary); padding: 2rem; border-radius: 8px; margin-bottom: 2rem;">
                        <label style="display: block; font-weight: 600; margin-bottom: 1rem; font-size: 1rem;">Portée de l'analyse :</label>
                        <select id="analysisScope" class="form-input" style="width: 100%; max-width: 400px; font-size: 1rem;">
                            <option value="current">Scène actuelle</option>
                            <option value="chapter">Chapitre actuel</option>
                            <option value="act">Acte actuel</option>
                            <option value="all">Tout le projet</option>
                        </select>
                    </div>
                    
                    <div id="analysisResults"></div>
                </div>
            `;
            
            // Attach event listener after DOM is updated
            setTimeout(() => {
                const scopeSelect = document.getElementById('analysisScope');
                if (scopeSelect) {
                    scopeSelect.addEventListener('change', runTextAnalysis);
                }
                runTextAnalysis();
            }, 0);
        }

        function runTextAnalysis() {
            const scope = document.getElementById('analysisScope')?.value || 'current';
            const text = getTextForAnalysis(scope);
            
            if (!text || text.trim().length === 0) {
                document.getElementById('analysisResults').innerHTML = '<div style="padding: 2rem; text-align: center; color: var(--text-muted);">Aucun texte à analyser</div>';
                return;
            }

            const analysis = {
                wordCount: getWordCount(text),
                repetitions: detectRepetitions(text),
                readability: calculateReadability(text),
                wordFrequency: calculateWordFrequency(text),
                sentenceLength: calculateSentenceLength(text),
                narrativeDistribution: analyzeNarrativeDistribution(text)
            };

            displayAnalysisResults(analysis);
        }

        function getTextForAnalysis(scope) {
            console.log('getTextForAnalysis called with scope:', scope);
            console.log('currentActId:', currentActId, 'currentChapterId:', currentChapterId, 'currentSceneId:', currentSceneId);
            
            if (scope === 'current' && currentSceneId) {
                const act = project.acts.find(a => a.id === currentActId);
                if (!act) return '';
                const chapter = act.chapters.find(c => c.id === currentChapterId);
                if (!chapter) return '';
                const scene = chapter.scenes.find(s => s.id === currentSceneId);
                if (!scene) return '';
                console.log('Current scene text length:', stripHTML(scene.content).length);
                return stripHTML(scene.content);
            } else if (scope === 'chapter') {
                if (!currentChapterId) {
                    // Try to use first chapter of first act
                    if (project.acts.length > 0 && project.acts[0].chapters.length > 0) {
                        const chapter = project.acts[0].chapters[0];
                        const text = chapter.scenes.map(s => stripHTML(s.content)).join('\n\n');
                        console.log('Using first chapter, text length:', text.length);
                        return text;
                    }
                    return '';
                }
                const act = project.acts.find(a => a.id === currentActId);
                if (!act) return '';
                const chapter = act.chapters.find(c => c.id === currentChapterId);
                if (!chapter) return '';
                const text = chapter.scenes.map(s => stripHTML(s.content)).join('\n\n');
                console.log('Chapter text length:', text.length);
                return text;
            } else if (scope === 'act') {
                if (!currentActId) {
                    // Try to use first act
                    if (project.acts.length > 0) {
                        const act = project.acts[0];
                        const text = act.chapters.flatMap(ch => ch.scenes.map(s => stripHTML(s.content))).join('\n\n');
                        console.log('Using first act, text length:', text.length);
                        return text;
                    }
                    return '';
                }
                const act = project.acts.find(a => a.id === currentActId);
                if (!act) return '';
                const text = act.chapters.flatMap(ch => ch.scenes.map(s => stripHTML(s.content))).join('\n\n');
                console.log('Act text length:', text.length);
                return text;
            } else if (scope === 'all') {
                const text = project.acts.flatMap(a => a.chapters.flatMap(ch => ch.scenes.map(s => stripHTML(s.content)))).join('\n\n');
                console.log('All project text length:', text.length);
                return text;
            }
            return '';
        }

        function stripHTML(html) {
            const div = document.createElement('div');
            div.innerHTML = html;
            return div.textContent || div.innerText || '';
        }

        function detectRepetitions(text) {
            // Correction pour inclure les caractères accentués français et autres Unicode
            const words = text.toLowerCase().match(/[\p{L}]{4,}/gu) || []; 
            const frequency = {};
            words.forEach(word => frequency[word] = (frequency[word] || 0) + 1);
            
            const repeated = Object.entries(frequency)
                .filter(([word, count]) => count >= 5)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10);
            
            return repeated;
        }

        function calculateReadability(text) {
            const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
            // Correction pour inclure les caractères accentués français et autres Unicode
            const words = text.match(/[\p{L}]+/gu) || []; 
            const syllables = words.reduce((sum, word) => sum + countSyllables(word), 0);
            
            if (sentences.length === 0 || words.length === 0) return { score: 0, level: 'N/A' };
            
            // Flesch Reading Ease (adapted for French)
            const avgWordsPerSentence = words.length / sentences.length;
            const avgSyllablesPerWord = syllables / words.length;
            const score = 206.835 - (1.015 * avgWordsPerSentence) - (84.6 * avgSyllablesPerWord);
            
            let level = '';
            if (score >= 90) level = 'Très facile';
            else if (score >= 80) level = 'Facile';
            else if (score >= 70) level = 'Assez facile';
            else if (score >= 60) level = 'Standard';
            else if (score >= 50) level = 'Assez difficile';
            else if (score >= 30) level = 'Difficile';
            else level = 'Très difficile';
            
            return { score: Math.max(0, Math.min(100, score)).toFixed(1), level };
        }

        function countSyllables(word) {
            word = word.toLowerCase();
            const vowels = /[aeiouyàâäéèêëïîôùûü]/g;
            const matches = word.match(vowels);
            if (!matches) return 1;
            
            let count = matches.length;
            // Adjustments for French
            if (word.endsWith('e')) count--;
            if (word.match(/[aeiouy]{2,}/)) count--;
            return Math.max(1, count);
        }

        function calculateWordFrequency(text) {
            // Correction pour inclure les caractères accentués français et autres Unicode
            const words = text.toLowerCase().match(/[\p{L}]{3,}/gu) || []; 
            const stopWords = new Set(['le', 'la', 'les', 'un', 'une', 'des', 'de', 'du', 'et', 'ou', 'où', 'qui', 'que', 'quoi', 'dont', 'ce', 'cette', 'ces', 'son', 'sa', 'ses', 'mon', 'ma', 'mes', 'ton', 'ta', 'tes', 'notre', 'nos', 'votre', 'vos', 'leur', 'leurs', 'je', 'tu', 'il', 'elle', 'nous', 'vous', 'ils', 'elles', 'on', 'ne', 'pas', 'plus', 'dans', 'sur', 'pour', 'par', 'avec', 'sans', 'est', 'était', 'être', 'avoir', 'fait', 'faire', 'dit', 'dire', 'peut', 'bien', 'tout', 'tous', 'comme', 'très', 'aussi', 'encore', 'mais', 'donc', 'ainsi']);
            
            const frequency = {};
            words.forEach(word => {
                if (!stopWords.has(word)) {
                    frequency[word] = (frequency[word] || 0) + 1;
                }
            });
            
            return Object.entries(frequency)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 15);
        }

        function calculateSentenceLength(text) {
            const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
            const lengths = sentences.map(s => s.trim().split(/\s+/).length);
            
            if (lengths.length === 0) return { avg: 0, min: 0, max: 0, distribution: [] };
            
            const avg = lengths.reduce((a, b) => a + b, 0) / lengths.length;
            const min = Math.min(...lengths);
            const max = Math.max(...lengths);
            
            // Distribution
            const ranges = [
                { label: '1-5 mots', count: lengths.filter(l => l >= 1 && l <= 5).length },
                { label: '6-10 mots', count: lengths.filter(l => l >= 6 && l <= 10).length },
                { label: '11-15 mots', count: lengths.filter(l => l >= 11 && l <= 15).length },
                { label: '16-20 mots', count: lengths.filter(l => l >= 16 && l <= 20).length },
                { label: '20+ mots', count: lengths.filter(l => l > 20).length }
            ];
            
            return { avg: avg.toFixed(1), min, max, distribution: ranges };
        }

        function analyzeNarrativeDistribution(text) {
            const dialogRegex = /[«"—–]\s*[^»"—–]{10,}?\s*[»"—–]/g;
            const dialogs = text.match(dialogRegex) || [];
            const dialogLength = dialogs.join('').length;
            const totalLength = text.length;
            
            const dialogPercent = totalLength > 0 ? (dialogLength / totalLength * 100).toFixed(1) : 0;
            const narrativePercent = totalLength > 0 ? (100 - dialogPercent).toFixed(1) : 0;
            
            return {
                dialogue: dialogPercent,
                narrative: narrativePercent,
                dialogCount: dialogs.length
            };
        }

        function displayAnalysisResults(analysis) {
            const container = document.getElementById('analysisResults');
            
            container.innerHTML = `
                <div style="margin-top: 1rem;">
                    <!-- General Stats -->
                    <div style="background: var(--bg-primary); padding: 1rem; border-radius: 4px; border: 1px solid var(--border-color); margin-bottom: 1rem;">
                        <div style="font-weight: 700; font-size: 1rem; margin-bottom: 0.75rem; color: var(--accent-gold);">📊 Statistiques générales</div>
                        <div style="font-size: 1.2rem; font-weight: 600;">${analysis.wordCount.toLocaleString('fr-FR')} mots</div>
                    </div>

                    <!-- Readability -->
                    <div style="background: var(--bg-primary); padding: 1rem; border-radius: 4px; border: 1px solid var(--border-color); margin-bottom: 1rem;">
                        <div style="font-weight: 700; font-size: 1rem; margin-bottom: 0.75rem; color: var(--accent-gold);">📖 Lisibilité (Flesch)</div>
                        <div style="font-size: 1.1rem; margin-bottom: 0.25rem;">Score: <strong>${analysis.readability.score}</strong> / 100</div>
                        <div style="color: var(--text-muted);">Niveau: ${analysis.readability.level}</div>
                        <div style="margin-top: 0.5rem; font-size: 0.75rem; color: var(--text-muted); line-height: 1.4;">
                            Plus le score est élevé, plus le texte est facile à lire. 60-70 = Standard, 70-80 = Facile.
                        </div>
                    </div>

                    <!-- Sentence Length -->
                    <div style="background: var(--bg-primary); padding: 1rem; border-radius: 4px; border: 1px solid var(--border-color); margin-bottom: 1rem;">
                        <div style="font-weight: 700; font-size: 1rem; margin-bottom: 0.75rem; color: var(--accent-gold);">📏 Longueur des phrases</div>
                        <div style="display: flex; gap: 1rem; margin-bottom: 0.75rem;">
                            <div><strong>Moyenne:</strong> ${analysis.sentenceLength.avg} mots</div>
                            <div><strong>Min:</strong> ${analysis.sentenceLength.min}</div>
                            <div><strong>Max:</strong> ${analysis.sentenceLength.max}</div>
                        </div>
                        <div style="font-size: 0.8rem; font-weight: 600; margin-bottom: 0.5rem;">Distribution:</div>
                        ${analysis.sentenceLength.distribution.map(r => `
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.25rem;">
                                <span style="font-size: 0.75rem;">${r.label}</span>
                                <div style="flex: 1; margin: 0 0.5rem; height: 8px; background: var(--bg-secondary); border-radius: 4px; overflow: hidden;">
                                    <div style="height: 100%; width: ${r.count * 100 / analysis.sentenceLength.distribution.reduce((s, d) => s + d.count, 0)}%; background: var(--accent-gold);"></div>
                                </div>
                                <span style="font-size: 0.75rem; font-weight: 600; min-width: 30px; text-align: right;">${r.count}</span>
                            </div>
                        `).join('')}
                    </div>

                    <!-- Narrative Distribution -->
                    <div style="background: var(--bg-primary); padding: 1rem; border-radius: 4px; border: 1px solid var(--border-color); margin-bottom: 1rem;">
                        <div style="font-weight: 700; font-size: 1rem; margin-bottom: 0.75rem; color: var(--accent-gold);">💬 Distribution narrative</div>
                        <div style="display: flex; gap: 1rem; margin-bottom: 0.75rem;">
                            <div><strong>Dialogues:</strong> ${analysis.narrativeDistribution.dialogue}%</div>
                            <div><strong>Narration:</strong> ${analysis.narrativeDistribution.narrative}%</div>
                        </div>
                        <div style="height: 20px; background: var(--bg-secondary); border-radius: 4px; overflow: hidden; display: flex;">
                            <div style="height: 100%; width: ${analysis.narrativeDistribution.dialogue}%; background: #4CAF50;" title="Dialogues"></div>
                            <div style="height: 100%; width: ${analysis.narrativeDistribution.narrative}%; background: var(--accent-gold);" title="Narration"></div>
                        </div>
                        <div style="margin-top: 0.5rem; font-size: 0.75rem; color: var(--text-muted);">
                            ${analysis.narrativeDistribution.dialogCount} segments de dialogue détectés
                        </div>
                    </div>

                    <!-- Word Frequency -->
                    <div style="background: var(--bg-primary); padding: 1rem; border-radius: 4px; border: 1px solid var(--border-color); margin-bottom: 1rem;">
                        <div style="font-weight: 700; font-size: 1rem; margin-bottom: 0.75rem; color: var(--accent-gold);">🔤 Mots les plus fréquents</div>
                        <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 0.5rem;">
                            ${analysis.wordFrequency.map(([word, count]) => `
                                <div style="padding: 0.4rem 0.6rem; background: var(--bg-secondary); border-radius: 2px; font-size: 0.75rem;">
                                    <strong>${word}</strong>: ${count}×
                                </div>
                            `).join('')}
                        </div>
                    </div>

                    <!-- Repetitions -->
                    <div style="background: var(--bg-primary); padding: 1rem; border-radius: 4px; border: 1px solid var(--border-color);">
                        <div style="font-weight: 700; font-size: 1rem; margin-bottom: 0.75rem; color: var(--accent-red);">⚠️ Répétitions à surveiller (5+ occurrences)</div>
                        ${analysis.repetitions.length > 0 ? `
                            <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 0.5rem;">
                                ${analysis.repetitions.map(([word, count]) => `
                                    <div style="padding: 0.4rem 0.6rem; background: rgba(196, 69, 54, 0.1); border: 1px solid var(--accent-red); border-radius: 2px; font-size: 0.75rem;">
                                        <strong>${word}</strong>: ${count}×
                                    </div>
                                `).join('')}
                            </div>
                        ` : '<div style="color: var(--text-muted); font-size: 0.85rem;">Aucune répétition excessive détectée</div>'}
                    </div>
                </div>
            `;
        }

        // Initialize
        function init() {
            loadAllProjects();
            loadTreeState(); // Charger l'état d'expansion
            
            // Forcer la vue Structure au démarrage
            currentView = 'editor';
            
            // S'assurer que les autres vues sont cachées
            setTimeout(() => {
                // Masquer toutes les vues
                const viewsToHide = ['charactersList', 'worldList', 'notesList', 'codexList', 'statsList', 
                                     'versionsList', 'analysisList', 'todosList', 'corkboardList'];
                viewsToHide.forEach(viewId => {
                    const el = document.getElementById(viewId);
                    if (el) el.style.display = 'none';
                });
                
                // Afficher la structure
                const chaptersList = document.getElementById('chaptersList');
                if (chaptersList) chaptersList.style.display = 'block';
                
                // Activer l'onglet Structure
                document.querySelectorAll('[id^="tab-"]').forEach(tab => {
                    tab.classList.remove('btn-primary');
                });
                const editorTab = document.getElementById('tab-editor');
                if (editorTab) editorTab.classList.add('btn-primary');
            }, 100);
            
            switchView('editor');
            renderActsList();
            
            // Initialiser l'historique avec l'état initial
            saveToHistory();
            
            // Initialize color pickers
            initializeColorPickers();
            
            // Auto-save every 30 seconds
            setInterval(saveProject, 30000);
        }

        // Save/Load from localStorage
        function saveProject() {
            // Sauvegarder dans localStorage immédiatement
            const currentState = JSON.stringify(project);
            localStorage.setItem('novelcraft_project', currentState);
            
            console.log('💾 saveProject appelé - isUndoRedoAction:', isUndoRedoAction);
            
            // Si c'est une action undo/redo, ne pas sauvegarder dans l'historique
            if (isUndoRedoAction) {
                console.log('⏭️ Action undo/redo, pas de sauvegarde historique');
                return;
            }
            
            // Si c'est le premier changement (pas de timer actif)
            if (!historyDebounceTimer) {
                console.log('🆕 Premier changement - sauvegarde immédiate');
                // Sauvegarder l'état ACTUEL comme point de départ
                saveToHistory();
                lastSavedState = currentState;
            } else {
                console.log('⏱️ Timer existant, réinitialisation');
            }
            
            // Annuler le timer précédent
            if (historyDebounceTimer) {
                clearTimeout(historyDebounceTimer);
            }
            
            // Créer un nouveau timer
            historyDebounceTimer = setTimeout(() => {
                console.log('⏰ Timer expiré - vérification changements');
                // Sauvegarder l'état final après la pause
                const finalState = JSON.stringify(project);
                
                // Ne sauvegarder que si l'état a changé
                if (finalState !== lastSavedState) {
                    console.log('✏️ État modifié - sauvegarde finale');
                    saveToHistory();
                    lastSavedState = finalState;
                } else {
                    console.log('⏭️ Aucun changement détecté');
                }
                
                historyDebounceTimer = null; // Réinitialiser
            }, historyDebounceDelay);
        }
        
        function saveToHistory() {
            // Créer une copie profonde du projet
            const snapshot = JSON.parse(JSON.stringify(project));
            
            console.log('📝 saveToHistory appelé - historyStack.length:', historyStack.length);
            
            // Ajouter à l'historique
            historyStack.push(snapshot);
            
            // Limiter la taille de l'historique
            if (historyStack.length > maxHistorySize) {
                historyStack.shift(); // Retirer le plus ancien
            }
            
            // Vider le redo stack car on a fait une nouvelle action
            redoStack = [];
            
            console.log('✓ État sauvegardé - Total dans historique:', historyStack.length);
            
            // Mettre à jour l'UI
            updateUndoRedoButtons();
        }
        
        // Sauvegarder immédiatement dans l'historique (pour actions importantes)
        function saveToHistoryImmediate() {
            // Annuler le timer de debounce en cours
            if (historyDebounceTimer) {
                clearTimeout(historyDebounceTimer);
                historyDebounceTimer = null;
            }
            
            // Sauvegarder immédiatement
            saveToHistory();
        }
        
        function undo() {
            console.log('🔙 Undo appelé - historyStack.length:', historyStack.length);
            
            if (historyStack.length === 0) {
                console.log('⚠️ Historique vide !');
                showNotification('⚠️ Aucune action à annuler');
                return;
            }
            
            // Sauvegarder l'état actuel dans le redo stack
            redoStack.push(JSON.parse(JSON.stringify(project)));
            console.log('💾 État actuel sauvegardé dans redoStack');
            
            // Restaurer l'état précédent
            const previousState = historyStack.pop();
            console.log('📂 État précédent récupéré - reste dans historique:', historyStack.length);
            
            // Flag pour éviter de sauvegarder cette restauration
            isUndoRedoAction = true;
            project = JSON.parse(JSON.stringify(previousState));
            console.log('✓ Projet restauré');
            
            // Sauvegarder et rafraîchir
            saveProject();
            refreshAllViews();
            
            isUndoRedoAction = false;
            updateUndoRedoButtons();
            showNotification('↶ Annulé');
        }
        
        function redo() {
            if (redoStack.length === 0) {
                showNotification('⚠️ Aucune action à rétablir');
                return;
            }
            
            // Sauvegarder l'état actuel dans l'historique
            historyStack.push(JSON.parse(JSON.stringify(project)));
            
            // Restaurer l'état suivant
            const nextState = redoStack.pop();
            
            // Flag pour éviter de sauvegarder cette restauration
            isUndoRedoAction = true;
            project = JSON.parse(JSON.stringify(nextState));
            
            // Sauvegarder et rafraîchir
            saveProject();
            refreshAllViews();
            
            isUndoRedoAction = false;
            updateUndoRedoButtons();
            showNotification('↷ Rétabli');
        }
        
        function updateUndoRedoButtons() {
            // Boutons dans le header
            const headerUndoBtn = document.getElementById('headerUndoBtn');
            const headerRedoBtn = document.getElementById('headerRedoBtn');
            
            if (headerUndoBtn) {
                headerUndoBtn.disabled = historyStack.length === 0;
                headerUndoBtn.title = historyStack.length > 0 
                    ? `Annuler (${historyStack.length} action(s) disponible(s)) - Ctrl+Z`
                    : 'Aucune action à annuler';
            }
            
            if (headerRedoBtn) {
                headerRedoBtn.disabled = redoStack.length === 0;
                headerRedoBtn.title = redoStack.length > 0 
                    ? `Rétablir (${redoStack.length} action(s) disponible(s)) - Ctrl+Y`
                    : 'Aucune action à rétablir';
            }
        }
        
        function refreshAllViews() {
            // Rafraîchir tous les affichages après un undo/redo
            renderActsList();
            
            // Restaurer l'état d'expansion immédiatement après le rendu
            setTimeout(() => restoreTreeState(), 100);
            
            updateStats();
            
            // Rafraîchir la vue actuelle
            switch(currentView) {
                case 'editor':
                    // Rafraîchir l'éditeur si une scène est ouverte
                    if (currentActId && currentChapterId && currentSceneId) {
                        const act = project.acts.find(a => a.id === currentActId);
                        if (act) {
                            const chapter = act.chapters.find(c => c.id === currentChapterId);
                            if (chapter) {
                                const scene = chapter.scenes.find(s => s.id === currentSceneId);
                                if (scene) {
                                    renderEditor(act, chapter, scene);
                                }
                            }
                        }
                    }
                    break;
                case 'characters':
                    renderCharactersList();
                    break;
                case 'world':
                    renderWorldList();
                    break;
                case 'timeline':
                    renderTimelineList();
                    break;
                case 'notes':
                    renderNotesList();
                    break;
                case 'codex':
                    renderCodexList();
                    break;
                case 'stats':
                    renderStats();
                    break;
                case 'analysis':
                    renderAnalysis();
                    break;
                case 'versions':
                    renderVersionsList();
                    break;
                case 'todos':
                    if (typeof renderTodosList === 'function') renderTodosList();
                    break;
                case 'corkboard':
                    if (typeof renderCorkBoard === 'function') renderCorkBoard();
                    break;
                case 'mindmap':
                    if (typeof renderMindmapView === 'function') renderMindmapView();
                    break;
                case 'plot':
                    if (typeof renderPlotView === 'function') renderPlotView();
                    break;
                case 'relations':
                    if (typeof renderRelationsView === 'function') renderRelationsView();
                    break;
                case 'map':
                    if (typeof renderMapView === 'function') renderMapView();
                    break;
                case 'timelineviz':
                    if (typeof renderTimelineVizView === 'function') renderTimelineVizView();
                    break;
            }
            
            // Rafraîchir l'éditeur si une scène est ouverte
            if (currentSceneId) {
                const scene = findScene(currentActId, currentChapterId, currentSceneId);
                if (scene) {
                    document.getElementById('sceneTitle').value = scene.title;
                    document.getElementById('sceneContent').value = scene.content || '';
                    updateWordCount();
                }
            }
        }
        
        // Raccourcis clavier pour undo/redo
        document.addEventListener('keydown', function(e) {
            // Ctrl+Z ou Cmd+Z pour undo
            if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                undo();
            }
            // Ctrl+Y ou Cmd+Shift+Z pour redo
            else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
                e.preventDefault();
                redo();
            }
        });

        function loadProject() {
            const saved = localStorage.getItem('novelcraft_project');
            if (saved) {
                const loadedProject = JSON.parse(saved);
                
                // Migration: Convert old structure (chapters array) to new structure (acts array)
                if (loadedProject.chapters && !loadedProject.acts) {
                    console.log('Migrating old project structure to acts-based structure...');
                    project = {
                        title: loadedProject.title || "Mon Roman",
                        acts: [
                            {
                                id: Date.now(),
                                title: "Acte I",
                                chapters: loadedProject.chapters || []
                            }
                        ],
                        characters: loadedProject.characters || [],
                        world: loadedProject.world || []
                    };
                    // Save migrated structure
                    saveProject();
                    console.log('Migration complete!');
                } else {
                    // Ensure all data structures exist
                    project = {
                        ...loadedProject,
                        characters: loadedProject.characters || [],
                        world: loadedProject.world || [],
                        timeline: loadedProject.timeline || [],
                        notes: loadedProject.notes || [],
                        codex: loadedProject.codex || [],
                        stats: loadedProject.stats || {
                            dailyGoal: 500,
                            totalGoal: 80000,
                            writingSessions: []
                        },
                        versions: loadedProject.versions || [],
                        relationships: loadedProject.relationships || []
                    };
                    
                    // Ensure all scenes have linked arrays
                    project.acts.forEach(act => {
                        act.chapters.forEach(chapter => {
                            chapter.scenes.forEach(scene => {
                                if (!scene.linkedCharacters) scene.linkedCharacters = [];
                                if (!scene.linkedElements) scene.linkedElements = [];
                            });
                        });
                    });
                    
                    // Ensure all characters have linked arrays
                    project.characters.forEach(char => {
                        if (!char.linkedScenes) char.linkedScenes = [];
                        if (!char.linkedElements) char.linkedElements = [];
                    });
                    
                    // Ensure all world elements have linked arrays
                    project.world.forEach(elem => {
                        if (!elem.linkedScenes) elem.linkedScenes = [];
                        if (!elem.linkedElements) elem.linkedElements = [];
                    });
                }
            }
        }

        // Act Management
        function addAct() {
            const title = document.getElementById('actTitleInput').value.trim();
            if (!title) return;

            const act = {
                id: Date.now(),
                title: title,
                chapters: []
            };

            project.acts.push(act);
            document.getElementById('actTitleInput').value = '';
            closeModal('addActModal');
            saveProject();
            renderActsList();
        }

        function deleteAct(actId) {
            if (!confirm('Êtes-vous sûr de vouloir supprimer cet acte et tous ses chapitres ?')) return;
            
            project.acts = project.acts.filter(a => a.id !== actId);
            if (currentActId === actId) {
                currentActId = null;
                currentChapterId = null;
                currentSceneId = null;
                showEmptyState();
            }
            saveProject();
            renderActsList();
        }

        function toggleAct(actId) {
            const element = document.getElementById(`act-${actId}`);
            const icon = element.querySelector('.act-icon');
            const chaptersContainer = element.querySelector('.act-chapters');
            
            const isExpanded = icon.classList.contains('expanded');
            
            icon.classList.toggle('expanded');
            chaptersContainer.classList.toggle('visible');
            
            // Sauvegarder l'état
            if (isExpanded) {
                expandedActs.delete(actId);
            } else {
                expandedActs.add(actId);
            }
            saveTreeState();
        }

        function startEditingAct(actId, element) {
            const act = project.acts.find(a => a.id === actId);
            if (!act) return;

            const originalText = act.title;
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'editing-input';
            input.value = originalText;
            
            element.textContent = '';
            element.appendChild(input);
            input.focus();
            input.select();

            const finishEditing = () => {
                const newTitle = input.value.trim();
                if (newTitle && newTitle !== originalText) {
                    act.title = newTitle;
                    saveProject();
                }
                renderActsList();
            };

            input.addEventListener('blur', finishEditing);
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    finishEditing();
                } else if (e.key === 'Escape') {
                    renderActsList();
                }
            });
        }

        // Chapter Management
        function addChapter() {
            const title = document.getElementById('chapterTitleInput').value.trim();
            if (!title || !activeActId) return;

            const act = project.acts.find(a => a.id === activeActId);
            if (!act) return;

            const chapter = {
                id: Date.now(),
                title: title,
                scenes: []
            };

            act.chapters.push(chapter);
            document.getElementById('chapterTitleInput').value = '';
            closeModal('addChapterModal');
            saveProject();
            renderActsList();
        }

        function deleteChapter(actId, chapterId) {
            if (!confirm('Êtes-vous sûr de vouloir supprimer ce chapitre et toutes ses scènes ?')) return;
            
            const act = project.acts.find(a => a.id === actId);
            if (!act) return;

            act.chapters = act.chapters.filter(c => c.id !== chapterId);
            if (currentChapterId === chapterId) {
                currentChapterId = null;
                currentSceneId = null;
                showEmptyState();
            }
            saveProject();
            renderActsList();
        }

        function toggleChapter(actId, chapterId) {
            const element = document.getElementById(`chapter-${chapterId}`);
            const icon = element.querySelector('.chapter-icon');
            const scenesList = element.querySelector('.scenes-list');
            
            const isExpanded = icon.classList.contains('expanded');
            
            icon.classList.toggle('expanded');
            scenesList.classList.toggle('visible');
            
            // Sauvegarder l'état
            if (isExpanded) {
                expandedChapters.delete(chapterId);
            } else {
                expandedChapters.add(chapterId);
            }
            saveTreeState();
        }
        
        function saveTreeState() {
            // Sauvegarder l'état d'expansion dans localStorage
            localStorage.setItem('novelcraft_expanded_acts', JSON.stringify([...expandedActs]));
            localStorage.setItem('novelcraft_expanded_chapters', JSON.stringify([...expandedChapters]));
        }
        
        function loadTreeState() {
            // Charger l'état d'expansion depuis localStorage
            try {
                const savedActs = localStorage.getItem('novelcraft_expanded_acts');
                const savedChapters = localStorage.getItem('novelcraft_expanded_chapters');
                
                if (savedActs) {
                    expandedActs = new Set(JSON.parse(savedActs));
                }
                if (savedChapters) {
                    expandedChapters = new Set(JSON.parse(savedChapters));
                }
            } catch (e) {
                console.error('Erreur chargement état arborescence:', e);
            }
        }
        
        function restoreTreeState() {
            // Restaurer visuellement l'état d'expansion après le rendu
            expandedActs.forEach(actId => {
                const element = document.getElementById(`act-${actId}`);
                if (element) {
                    const icon = element.querySelector('.act-icon');
                    const chaptersContainer = element.querySelector('.act-chapters');
                    if (icon && chaptersContainer) {
                        icon.classList.add('expanded');
                        chaptersContainer.classList.add('visible');
                    }
                }
            });
            
            expandedChapters.forEach(chapterId => {
                const element = document.getElementById(`chapter-${chapterId}`);
                if (element) {
                    const icon = element.querySelector('.chapter-icon');
                    const scenesList = element.querySelector('.scenes-list');
                    if (icon && scenesList) {
                        icon.classList.add('expanded');
                        scenesList.classList.add('visible');
                    }
                }
            });
        }

        function startEditingChapter(actId, chapterId, element) {
            const act = project.acts.find(a => a.id === actId);
            if (!act) return;

            const chapter = act.chapters.find(c => c.id === chapterId);
            if (!chapter) return;

            const originalText = chapter.title;
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'editing-input';
            input.value = originalText;
            
            element.textContent = '';
            element.appendChild(input);
            input.focus();
            input.select();

            const finishEditing = () => {
                const newTitle = input.value.trim();
                if (newTitle && newTitle !== originalText) {
                    chapter.title = newTitle;
                    saveProject();
                    
                    // Update editor if this chapter is currently open
                    if (currentChapterId === chapterId) {
                        const breadcrumb = document.querySelector('.editor-breadcrumb');
                        if (breadcrumb) breadcrumb.textContent = `${act.title} > ${newTitle}`;
                    }
                }
                renderActsList();
            };

            input.addEventListener('blur', finishEditing);
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    finishEditing();
                } else if (e.key === 'Escape') {
                    renderActsList();
                }
            });
        }

        // Scene Management
        function openAddSceneModal(actId, chapterId) {
            activeActId = actId;
            activeChapterId = chapterId;
            document.getElementById('addSceneModal').classList.add('active');
        }

        function addScene() {
            const title = document.getElementById('sceneTitleInput').value.trim();
            if (!title || !activeActId || !activeChapterId) return;

            const act = project.acts.find(a => a.id === activeActId);
            if (!act) return;

            const chapter = act.chapters.find(c => c.id === activeChapterId);
            if (!chapter) return;

            const scene = {
                id: Date.now(),
                title: title,
                content: '',
                linkedCharacters: [], // IDs of characters in this scene
                linkedElements: [] // IDs of world elements/locations in this scene
            };

            chapter.scenes.push(scene);
            document.getElementById('sceneTitleInput').value = '';
            closeModal('addSceneModal');
            saveProject();
            renderActsList();
            
            // Auto-open the new scene
            openScene(activeActId, activeChapterId, scene.id);
        }

        function deleteScene(actId, chapterId, sceneId) {
            if (!confirm('Êtes-vous sûr de vouloir supprimer cette scène ?')) return;
            
            const act = project.acts.find(a => a.id === actId);
            if (!act) return;

            const chapter = act.chapters.find(c => c.id === chapterId);
            if (!chapter) return;

            chapter.scenes = chapter.scenes.filter(s => s.id !== sceneId);
            if (currentSceneId === sceneId) {
                currentSceneId = null;
                showEmptyState();
            }
            saveProject();
            renderActsList();
        }

        function startEditingScene(actId, chapterId, sceneId, element) {
            const act = project.acts.find(a => a.id === actId);
            if (!act) return;

            const chapter = act.chapters.find(c => c.id === chapterId);
            if (!chapter) return;
            
            const scene = chapter.scenes.find(s => s.id === sceneId);
            if (!scene) return;

            const originalText = scene.title;
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'editing-input';
            input.value = originalText;
            
            element.textContent = '';
            element.appendChild(input);
            input.focus();
            input.select();

            const finishEditing = () => {
                const newTitle = input.value.trim();
                if (newTitle && newTitle !== originalText) {
                    scene.title = newTitle;
                    saveProject();
                    
                    // Update editor if this scene is currently open
                    if (currentSceneId === sceneId) {
                        const editorTitle = document.querySelector('.editor-title');
                        if (editorTitle) editorTitle.textContent = newTitle;
                    }
                }
                renderActsList();
            };

            input.addEventListener('blur', finishEditing);
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    finishEditing();
                } else if (e.key === 'Escape') {
                    renderActsList();
                }
            });
        }

        // Navigation
        function openScene(actId, chapterId, sceneId) {
            // Close mobile sidebar if open (for mobile devices)
            if (window.innerWidth <= 768 && typeof closeMobileSidebar === 'function') {
                closeMobileSidebar();
            }
            
            // Sauvegarder l'état avant d'ouvrir une nouvelle scène
            // Cela crée un point de restauration
            saveToHistoryImmediate();
            
            currentActId = actId;
            currentChapterId = chapterId;
            currentSceneId = sceneId;
            
            const act = project.acts.find(a => a.id === actId);
            const chapter = act.chapters.find(c => c.id === chapterId);
            const scene = chapter.scenes.find(s => s.id === sceneId);
            
            // Update active states
            document.querySelectorAll('.act-header, .chapter-header, .scene-item').forEach(el => {
                el.classList.remove('active');
            });
            
            const sceneElement = document.querySelector(`[data-scene-id="${sceneId}"]`);
            if (sceneElement) {
                sceneElement.classList.add('active');
                
                // Expand parent chapter and act if needed
                const chapterElement = document.getElementById(`chapter-${chapterId}`);
                if (chapterElement) {
                    const chapterIcon = chapterElement.querySelector('.chapter-icon');
                    const scenesList = chapterElement.querySelector('.scenes-list');
                    if (!scenesList.classList.contains('visible')) {
                        chapterIcon.classList.add('expanded');
                        scenesList.classList.add('visible');
                    }
                }
                
                const actElement = document.getElementById(`act-${actId}`);
                if (actElement) {
                    const actIcon = actElement.querySelector('.act-icon');
                    const chaptersContainer = actElement.querySelector('.act-chapters');
                    if (!chaptersContainer.classList.contains('visible')) {
                        actIcon.classList.add('expanded');
                        chaptersContainer.classList.add('visible');
                    }
                }
                
                // Scroll the scene into view in the sidebar
                setTimeout(() => {
                    const chaptersList = document.getElementById('chaptersList');
                    if (chaptersList && sceneElement) {
                        const containerRect = chaptersList.getBoundingClientRect();
                        const elementRect = sceneElement.getBoundingClientRect();
                        
                        if (elementRect.top < containerRect.top || elementRect.bottom > containerRect.bottom) {
                            sceneElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        }
                    }
                }, 100);
            }
            
            renderEditor(act, chapter, scene);
        }

        // Rendering
        // Expand/Collapse All
        function expandAll() {
            project.acts.forEach(act => {
                const actElement = document.getElementById(`act-${act.id}`);
                if (actElement) {
                    const icon = actElement.querySelector('.act-icon');
                    const chaptersContainer = actElement.querySelector('.act-chapters');
                    if (icon && chaptersContainer) {
                        icon.classList.add('expanded');
                        chaptersContainer.classList.add('visible');
                    }
                }
                
                act.chapters.forEach(chapter => {
                    const chapterElement = document.getElementById(`chapter-${chapter.id}`);
                    if (chapterElement) {
                        const icon = chapterElement.querySelector('.chapter-icon');
                        const scenesContainer = chapterElement.querySelector('.scenes-list');
                        if (icon && scenesContainer) {
                            icon.classList.add('expanded');
                            scenesContainer.classList.add('visible');
                        }
                    }
                });
            });
        }

        function collapseAll() {
            project.acts.forEach(act => {
                const actElement = document.getElementById(`act-${act.id}`);
                if (actElement) {
                    const icon = actElement.querySelector('.act-icon');
                    const chaptersContainer = actElement.querySelector('.act-chapters');
                    if (icon && chaptersContainer) {
                        icon.classList.remove('expanded');
                        chaptersContainer.classList.remove('visible');
                    }
                }
                
                act.chapters.forEach(chapter => {
                    const chapterElement = document.getElementById(`chapter-${chapter.id}`);
                    if (chapterElement) {
                        const icon = chapterElement.querySelector('.chapter-icon');
                        const scenesContainer = chapterElement.querySelector('.scenes-list');
                        if (icon && scenesContainer) {
                            icon.classList.remove('expanded');
                            scenesContainer.classList.remove('visible');
                        }
                    }
                });
            });
        }

        function renderActsList() {
            const container = document.getElementById('chaptersList');
            
            if (project.acts.length === 0) {
                container.innerHTML = '<div style="padding: 2rem; text-align: center; color: var(--text-muted);">Aucun acte</div>';
                updateStats();
                return;
            }

            container.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; padding: 0 1.5rem; margin-bottom: 0.5rem;">
                    <div style="font-size: 0.75rem; color: var(--text-muted); font-weight: 600;">STRUCTURE</div>
                    <div style="display: flex; gap: 0.25rem;">
                        <button class="btn btn-small" onclick="expandAll()" title="Tout déplier" style="font-size: 0.7rem; padding: 0.25rem 0.5rem;">▼ Tout</button>
                        <button class="btn btn-small" onclick="collapseAll()" title="Tout replier" style="font-size: 0.7rem; padding: 0.25rem 0.5rem;">▶ Tout</button>
                    </div>
                </div>
            ` + project.acts.map((act) => `
                <div class="act-group" id="act-${act.id}" data-act-id="${act.id}">
                    <div class="act-header draggable" 
                         draggable="true" 
                         data-act-id="${act.id}"
                         onclick="toggleAct(${act.id})">
                        <span class="drag-handle" title="Glisser pour réorganiser">⋮⋮</span>
                        <span class="act-icon">▶</span>
                        <span class="act-title" 
                              ondblclick="event.stopPropagation(); startEditingAct(${act.id}, this)"
                              title="Double-cliquer pour renommer">${act.title}</span>
                        <span class="edit-hint">✏️</span>
                        <span class="act-count">${act.chapters.length} ch.</span>
                        <button class="btn btn-icon btn-small delete-btn" onclick="event.stopPropagation(); deleteAct(${act.id})" title="Supprimer">×</button>
                    </div>
                    <div class="act-chapters">
                        ${act.chapters.map((chapter) => `
                            <div class="chapter-group" id="chapter-${chapter.id}" data-chapter-id="${chapter.id}" data-act-id="${act.id}">
                                <div class="chapter-header draggable" 
                                     draggable="true" 
                                     data-chapter-id="${chapter.id}"
                                     data-act-id="${act.id}"
                                     onclick="toggleChapter(${act.id}, ${chapter.id})">
                                    <span class="drag-handle" title="Glisser pour réorganiser">⋮⋮</span>
                                    <span class="chapter-icon">▶</span>
                                    <span class="chapter-title" 
                                          ondblclick="event.stopPropagation(); startEditingChapter(${act.id}, ${chapter.id}, this)"
                                          title="Double-cliquer pour renommer">${chapter.title}</span>
                                    <span class="edit-hint">✏️</span>
                                    <span class="chapter-count">${chapter.scenes.length}</span>
                                    <button class="btn btn-icon btn-small delete-btn" onclick="event.stopPropagation(); deleteChapter(${act.id}, ${chapter.id})" title="Supprimer">×</button>
                                </div>
                                <div class="scenes-list">
                                    ${chapter.scenes.map((scene) => `
                                        <div class="scene-item draggable" 
                                             draggable="true"
                                             data-scene-id="${scene.id}" 
                                             data-chapter-id="${chapter.id}"
                                             data-act-id="${act.id}"
                                             onclick="openScene(${act.id}, ${chapter.id}, ${scene.id})">
                                            <div style="display: flex; align-items: center; gap: 0.5rem; flex: 1;">
                                                <span class="drag-handle" title="Glisser pour réorganiser">⋮⋮</span>
                                                <span ondblclick="event.stopPropagation(); startEditingScene(${act.id}, ${chapter.id}, ${scene.id}, this)"
                                                      title="Double-cliquer pour renommer">${scene.title}</span>
                                                <span class="edit-hint">✏️</span>
                                            </div>
                                            <button class="btn btn-icon btn-small delete-btn" onclick="event.stopPropagation(); deleteScene(${act.id}, ${chapter.id}, ${scene.id})" title="Supprimer">×</button>
                                        </div>
                                    `).join('')}
                                    <div class="scene-item" onclick="openAddSceneModal(${act.id}, ${chapter.id})" style="opacity: 0.6; font-style: italic;">
                                        + Ajouter une scène
                                    </div>
                                </div>
                            </div>
                        `).join('')}
                        <div class="scene-item" onclick="openAddChapterModal(${act.id})" style="opacity: 0.6; font-style: italic; margin-left: 1rem;">
                            + Ajouter un chapitre
                        </div>
                    </div>
                </div>
            `).join('');
            
            // Setup drag and drop
            setupActDragAndDrop();
            setupChapterDragAndDrop();
            setupSceneDragAndDrop();

            updateStats();
            
            // Restaurer l'état d'expansion après le rendu
            setTimeout(() => restoreTreeState(), 50);
        }

        function renderSceneCharacters(actId, chapterId, scene) {
            if (!scene.linkedCharacters || scene.linkedCharacters.length === 0) {
                return '<span style="font-size: 0.8rem; color: var(--text-muted); font-style: italic;">Aucun personnage lié</span>';
            }

            return scene.linkedCharacters.map(charId => {
                const character = project.characters.find(c => c.id === charId);
                if (!character) return '';
                return `
                    <span class="link-badge" onclick="event.stopPropagation(); switchView('characters'); openCharacterDetail(${charId});">
                        ${character.name}
                        <span class="link-badge-remove" onclick="event.stopPropagation(); toggleCharacterInScene(${actId}, ${chapterId}, ${scene.id}, ${charId}); openScene(${actId}, ${chapterId}, ${scene.id});">×</span>
                    </span>
                `;
            }).join('');
        }

        function renderSceneElements(actId, chapterId, scene) {
            if (!scene.linkedElements || scene.linkedElements.length === 0) {
                return '<span style="font-size: 0.8rem; color: var(--text-muted); font-style: italic;">Aucun élément lié</span>';
            }

            return scene.linkedElements.map(elemId => {
                const element = project.world.find(e => e.id === elemId);
                if (!element) return '';
                return `
                    <span class="link-badge" onclick="event.stopPropagation(); switchView('world'); openWorldDetail(${elemId});">
                        ${element.name}
                        <span class="link-badge-remove" onclick="event.stopPropagation(); toggleElementInScene(${actId}, ${chapterId}, ${scene.id}, ${elemId}); openScene(${actId}, ${chapterId}, ${scene.id});">×</span>
                    </span>
                `;
            }).join('');
        }

        function openCharacterLinker(actId, chapterId, sceneId) {
            const act = project.acts.find(a => a.id === actId);
            const chapter = act.chapters.find(c => c.id === chapterId);
            const scene = chapter.scenes.find(s => s.id === sceneId);

            document.getElementById('referencesModalTitle').textContent = 'Lier des personnages à cette scène';
            document.getElementById('referencesModalContent').innerHTML = `
                <div class="tag-selector">
                    ${project.characters.map(char => {
                        const isLinked = scene.linkedCharacters && scene.linkedCharacters.includes(char.id);
                        return `
                            <div class="tag-option ${isLinked ? 'selected' : ''}" 
                                 onclick="toggleCharacterInScene(${actId}, ${chapterId}, ${sceneId}, ${char.id}); this.classList.toggle('selected');">
                                ${char.name}
                            </div>
                        `;
                    }).join('')}
                </div>
                ${project.characters.length === 0 ? '<p style="color: var(--text-muted); margin-top: 1rem;">Aucun personnage créé. Créez des personnages dans l\'onglet Personnages.</p>' : ''}
            `;

            document.getElementById('referencesModal').classList.add('active');
        }

        function openElementLinker(actId, chapterId, sceneId) {
            const act = project.acts.find(a => a.id === actId);
            const chapter = act.chapters.find(c => c.id === chapterId);
            const scene = chapter.scenes.find(s => s.id === sceneId);

            document.getElementById('referencesModalTitle').textContent = 'Lier des lieux/éléments à cette scène';
            document.getElementById('referencesModalContent').innerHTML = `
                <div class="tag-selector">
                    ${project.world.map(elem => {
                        const isLinked = scene.linkedElements && scene.linkedElements.includes(elem.id);
                        return `
                            <div class="tag-option ${isLinked ? 'selected' : ''}" 
                                 onclick="toggleElementInScene(${actId}, ${chapterId}, ${sceneId}, ${elem.id}); this.classList.toggle('selected');">
                                ${elem.name} <small>(${elem.type})</small>
                            </div>
                        `;
                    }).join('')}
                </div>
                ${project.world.length === 0 ? '<p style="color: var(--text-muted); margin-top: 1rem;">Aucun élément créé. Créez des lieux dans l\'onglet Univers.</p>' : ''}
            `;

            document.getElementById('referencesModal').classList.add('active');
        }

        function renderEditor(act, chapter, scene) {
            const editorView = document.getElementById('editorView');
            const wordCount = getWordCount(scene.content);
            
            editorView.innerHTML = `
                <div class="editor-fixed-top">
                    <div class="editor-header">
                        <div class="editor-breadcrumb">${act.title} > ${chapter.title}</div>
                        <div style="display: flex; align-items: center; gap: 1rem;">
                            <div class="editor-title" style="flex: 1;">${scene.title}</div>
                            <button class="btn btn-small" onclick="toggleFocusMode()" title="Mode Focus (F11)" style="white-space: nowrap;">
                                🧘 Focus
                            </button>
                        </div>
                        <div class="editor-meta">
                            <span id="sceneWordCount">${wordCount} mots</span>
                            <span>Dernière modification : ${new Date().toLocaleDateString('fr-FR')}</span>
                        </div>
                    </div>
                    <button class="toolbar-mobile-toggle" onclick="toggleEditorToolbar()">
                        <span id="toolbarToggleText">📝 Afficher les outils de formatage</span>
                    </button>
                    <div class="editor-toolbar" id="editorToolbar">
                        <!-- Basic formatting -->
                        <div class="toolbar-group">
                            <button class="toolbar-btn" data-format="bold" onclick="formatText('bold')" title="Gras (Ctrl+B)">
                                <strong>B</strong>
                            </button>
                            <button class="toolbar-btn" data-format="italic" onclick="formatText('italic')" title="Italique (Ctrl+I)">
                                <em>I</em>
                            </button>
                            <button class="toolbar-btn" data-format="underline" onclick="formatText('underline')" title="Souligné (Ctrl+U)">
                                <u>U</u>
                            </button>
                            <button class="toolbar-btn" data-format="strikethrough" onclick="formatText('strikeThrough')" title="Barré">
                                <s>S</s>
                            </button>
                        </div>
                        
                        <!-- Font family and size -->
                        <div class="toolbar-group">
                            <select class="font-family-selector" onchange="formatText('fontName', this.value)" title="Police de caractères">
                                <option value="Crimson Pro">Crimson Pro</option>
                                <option value="Arial">Arial</option>
                                <option value="Georgia">Georgia</option>
                                <option value="Times New Roman">Times New Roman</option>
                                <option value="Courier New">Courier New</option>
                                <option value="Verdana">Verdana</option>
                                <option value="Garamond">Garamond</option>
                                <option value="Palatino">Palatino</option>
                            </select>
                            <select class="font-size-selector" onchange="formatText('fontSize', this.value)" title="Taille de police">
                                <option value="1">Très petit</option>
                                <option value="2">Petit</option>
                                <option value="3" selected>Normal</option>
                                <option value="4">Grand</option>
                                <option value="5">Très grand</option>
                                <option value="6">Énorme</option>
                                <option value="7">Gigantesque</option>
                            </select>
                        </div>
                        
                        <!-- Text color -->
                        <div class="toolbar-group">
                            <div class="color-picker-wrapper">
                                <button class="toolbar-btn" onclick="toggleColorPicker('text')" title="Couleur du texte">
                                    <span style="border-bottom: 3px solid currentColor;">A</span>
                                </button>
                                <div class="color-picker-dropdown" id="textColorPicker">
                                    <div class="color-grid" id="textColorGrid"></div>
                                    <div class="color-input-wrapper">
                                        <input type="color" id="textColorInput" onchange="applyTextColor(this.value)">
                                        <input type="text" id="textColorHex" placeholder="#000000" maxlength="7" onchange="applyTextColor(this.value)">
                                    </div>
                                </div>
                            </div>
                            <div class="color-picker-wrapper">
                                <button class="toolbar-btn" onclick="toggleColorPicker('background')" title="Couleur de fond">
                                    <span style="background: yellow; padding: 0 4px;">A</span>
                                </button>
                                <div class="color-picker-dropdown" id="backgroundColorPicker">
                                    <div class="color-grid" id="backgroundColorGrid"></div>
                                    <div class="color-input-wrapper">
                                        <input type="color" id="bgColorInput" onchange="applyBackgroundColor(this.value)">
                                        <input type="text" id="bgColorHex" placeholder="#FFFF00" maxlength="7" onchange="applyBackgroundColor(this.value)">
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Alignment -->
                        <div class="toolbar-group">
                            <button class="toolbar-btn" onclick="formatText('justifyLeft')" title="Aligner à gauche">
                                ⫷
                            </button>
                            <button class="toolbar-btn" onclick="formatText('justifyCenter')" title="Centrer">
                                ⫶
                            </button>
                            <button class="toolbar-btn" onclick="formatText('justifyRight')" title="Aligner à droite">
                                ⫸
                            </button>
                            <button class="toolbar-btn" onclick="formatText('justifyFull')" title="Justifier">
                                ☰
                            </button>
                        </div>
                        
                        <!-- Headings -->
                        <div class="toolbar-group">
                            <button class="toolbar-btn" onclick="formatText('formatBlock', 'h1')" title="Titre 1">H1</button>
                            <button class="toolbar-btn" onclick="formatText('formatBlock', 'h2')" title="Titre 2">H2</button>
                            <button class="toolbar-btn" onclick="formatText('formatBlock', 'h3')" title="Titre 3">H3</button>
                            <button class="toolbar-btn" onclick="formatText('formatBlock', 'p')" title="Paragraphe">P</button>
                        </div>
                        
                        <!-- Lists and quotes -->
                        <div class="toolbar-group">
                            <button class="toolbar-btn" onclick="formatText('insertUnorderedList')" title="Liste à puces">• Liste</button>
                            <button class="toolbar-btn" onclick="formatText('insertOrderedList')" title="Liste numérotée">1. Liste</button>
                            <button class="toolbar-btn" onclick="formatText('formatBlock', 'blockquote')" title="Citation">❝ Citation</button>
                        </div>
                        
                        <!-- Indentation -->
                        <div class="toolbar-group">
                            <button class="toolbar-btn" onclick="formatText('indent')" title="Augmenter l'indentation">→|</button>
                            <button class="toolbar-btn" onclick="formatText('outdent')" title="Diminuer l'indentation">|←</button>
                        </div>
                        
                        <!-- Superscript, subscript -->
                        <div class="toolbar-group">
                            <button class="toolbar-btn" onclick="formatText('superscript')" title="Exposant">x²</button>
                            <button class="toolbar-btn" onclick="formatText('subscript')" title="Indice">x₂</button>
                        </div>
                        
                        <!-- Other -->
                        <div class="toolbar-group">
                            <button class="toolbar-btn" onclick="formatText('insertHorizontalRule')" title="Ligne horizontale">─</button>
                            <button class="toolbar-btn" onclick="formatText('removeFormat')" title="Supprimer le formatage">✕ Format</button>
                        </div>
                    </div>
                    <div class="links-panel-sticky" id="linksPanel">
                        <div style="display: flex; gap: 2rem; align-items: start;">
                            <div style="flex: 1;">
                                <div style="font-size: 0.85rem; font-weight: 600; margin-bottom: 0.5rem; color: var(--text-muted);">👥 Personnages</div>
                                <div class="quick-links">
                                    ${renderSceneCharacters(act.id, chapter.id, scene)}
                                    <button class="btn btn-small" onclick="openCharacterLinker(${act.id}, ${chapter.id}, ${scene.id})" style="font-size: 0.75rem; padding: 0.3rem 0.6rem;">+ Lier</button>
                                </div>
                            </div>
                            <div style="flex: 1;">
                                <div style="font-size: 0.85rem; font-weight: 600; margin-bottom: 0.5rem; color: var(--text-muted);">🌍 Lieux/Éléments</div>
                                <div class="quick-links">
                                    ${renderSceneElements(act.id, chapter.id, scene)}
                                    <button class="btn btn-small" onclick="openElementLinker(${act.id}, ${chapter.id}, ${scene.id})" style="font-size: 0.75rem; padding: 0.3rem 0.6rem;">+ Lier</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="editor-workspace">
                    <div class="editor-content">
                        <div 
                            class="editor-textarea" 
                            contenteditable="true"
                            spellcheck="true"
                            data-placeholder="Commencez à écrire votre scène..."
                            oninput="updateSceneContent()"
                            onkeydown="handleEditorKeydown(event)"
                        >${scene.content}</div>
                    </div>
                </div>
            `;
            
            // Focus the editor
            setTimeout(() => {
                const editor = document.querySelector('.editor-textarea');
                if (editor && editor.textContent.trim() === '') {
                    editor.focus();
                }
            }, 100);
        }

        function showEmptyState() {
            const editorView = document.getElementById('editorView');
            editorView.innerHTML = `
                <div class="empty-state">
                    <div class="empty-state-icon">✍️</div>
                    <div class="empty-state-title">Sélectionnez une scène</div>
                    <div class="empty-state-text">
                        Choisissez une scène dans la barre latérale pour commencer à écrire.
                    </div>
                </div>
            `;
        }

        function updateSceneContent() {
            const editor = document.querySelector('.editor-textarea');
            const act = project.acts.find(a => a.id === currentActId);
            const chapter = act.chapters.find(c => c.id === currentChapterId);
            const scene = chapter.scenes.find(s => s.id === currentSceneId);
            
            scene.content = editor.innerHTML;
            
            const wordCount = getWordCount(editor.innerHTML);
            document.getElementById('sceneWordCount').textContent = `${wordCount} mots`;
            
            saveProject();
            updateStats();
            trackWritingSession(); // Track writing for statistics
        }

        function getWordCount(html) {
            // Create temporary div to strip HTML tags
            const temp = document.createElement('div');
            temp.innerHTML = html;
            const text = temp.textContent || temp.innerText || '';
            return text.split(/\s+/).filter(w => w.length > 0).length;
        }

        // Rich Text Formatting
        function formatText(command, value = null) {
            document.execCommand(command, false, value);
            document.querySelector('.editor-textarea').focus();
        }

        // Color palette for quick selection
        const colorPalette = [
            '#000000', '#434343', '#666666', '#999999', '#b7b7b7', '#cccccc', '#d9d9d9', '#efefef',
            '#f3f3f3', '#ffffff', '#980000', '#ff0000', '#ff9900', '#ffff00', '#00ff00', '#00ffff',
            '#4a86e8', '#0000ff', '#9900ff', '#ff00ff', '#e6b8af', '#f4cccc', '#fce5cd', '#fff2cc',
            '#d9ead3', '#d0e0e3', '#c9daf8', '#cfe2f3', '#d9d2e9', '#ead1dc', '#dd7e6b', '#ea9999',
            '#f9cb9c', '#ffe599', '#b6d7a8', '#a2c4c9', '#a4c2f4', '#9fc5e8', '#b4a7d6', '#d5a6bd',
            '#cc4125', '#e06666', '#f6b26b', '#ffd966', '#93c47d', '#76a5af', '#6d9eeb', '#6fa8dc',
            '#8e7cc3', '#c27ba0', '#a61c00', '#cc0000', '#e69138', '#f1c232', '#6aa84f', '#45818e',
            '#3c78d8', '#3d85c6', '#674ea7', '#a64d79', '#85200c', '#990000', '#b45f06', '#bf9000',
            '#38761d', '#134f5c', '#1155cc', '#0b5394', '#351c75', '#741b47', '#5b0f00', '#660000'
        ];

        // Initialize color pickers
        function initializeColorPickers() {
            const textColorGrid = document.getElementById('textColorGrid');
            const bgColorGrid = document.getElementById('backgroundColorGrid');
            
            colorPalette.forEach(color => {
                // Text color swatch
                const textSwatch = document.createElement('div');
                textSwatch.className = 'color-swatch';
                textSwatch.style.backgroundColor = color;
                textSwatch.title = color;
                textSwatch.onclick = () => applyTextColor(color);
                textColorGrid.appendChild(textSwatch);
                
                // Background color swatch
                const bgSwatch = document.createElement('div');
                bgSwatch.className = 'color-swatch';
                bgSwatch.style.backgroundColor = color;
                bgSwatch.title = color;
                bgSwatch.onclick = () => applyBackgroundColor(color);
                bgColorGrid.appendChild(bgSwatch);
            });
        }

        // Toggle color picker dropdown
        function toggleColorPicker(type) {
            const textPicker = document.getElementById('textColorPicker');
            const bgPicker = document.getElementById('backgroundColorPicker');
            
            if (type === 'text') {
                textPicker.classList.toggle('active');
                bgPicker.classList.remove('active');
            } else {
                bgPicker.classList.toggle('active');
                textPicker.classList.remove('active');
            }
        }

        // Apply text color
        function applyTextColor(color) {
            document.execCommand('foreColor', false, color);
            document.getElementById('textColorInput').value = color;
            document.getElementById('textColorHex').value = color.toUpperCase();
            document.querySelector('.editor-textarea').focus();
        }

        // Apply background color
        function applyBackgroundColor(color) {
            document.execCommand('hiliteColor', false, color);
            document.getElementById('bgColorInput').value = color;
            document.getElementById('bgColorHex').value = color.toUpperCase();
            document.querySelector('.editor-textarea').focus();
        }

        // Close color pickers when clicking outside
        document.addEventListener('click', function(event) {
            if (!event.target.closest('.color-picker-wrapper')) {
                document.querySelectorAll('.color-picker-dropdown').forEach(picker => {
                    picker.classList.remove('active');
                });
            }
        });

        function handleEditorKeydown(event) {
            // Handle keyboard shortcuts
            if (event.ctrlKey || event.metaKey) {
                switch(event.key.toLowerCase()) {
                    case 'b':
                        event.preventDefault();
                        formatText('bold');
                        break;
                    case 'i':
                        event.preventDefault();
                        formatText('italic');
                        break;
                    case 'u':
                        event.preventDefault();
                        formatText('underline');
                        break;
                }
            }
        }

        function updateStats() {
            const totalActs = project.acts.length;
            const totalChapters = project.acts.reduce((sum, act) => sum + act.chapters.length, 0);
            const totalWords = project.acts.reduce((sum, act) => {
                return sum + act.chapters.reduce((chSum, chapter) => {
                    return chSum + chapter.scenes.reduce((sceneSum, scene) => {
                        return sceneSum + getWordCount(scene.content);
                    }, 0);
                }, 0);
            }, 0);

            // Mettre à jour les stats dans le header
            const headerWords = document.getElementById('headerTotalWords');
            const headerChapters = document.getElementById('headerTotalChapters');
            if (headerWords) headerWords.textContent = `${totalWords} mots`;
            if (headerChapters) headerChapters.textContent = `${totalChapters} chapitres`;
            
            // Mettre à jour le titre du projet dans le header
            const headerTitle = document.getElementById('headerProjectTitle');
            if (headerTitle) headerTitle.textContent = project.title;
        }

        // Backup and Import Management
        function showBackupMenu() {
            document.getElementById('backupModal').classList.add('active');
        }

        function exportToJSON() {
            const dataStr = JSON.stringify(project, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const filename = `${project.title.replace(/\s+/g, '_')}_${new Date().toISOString().split('T')[0]}.json`;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
            
            alert(`✅ Fichier JSON téléchargé !\n\nNom : ${filename}\n\nTu peux maintenant l'uploader sur Google Drive, Dropbox, ou tout autre service cloud.`);
        }

        function importFromFile() {
            document.getElementById('importFileInput').click();
        }

        function handleFileImport(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (!file.name.endsWith('.json')) {
                alert('❌ Erreur : Le fichier doit être au format JSON');
                return;
            }

            if (!confirm('⚠️ ATTENTION : L\'import va remplacer toutes vos données actuelles.\n\nVoulez-vous créer une sauvegarde avant de continuer ?')) {
                event.target.value = ''; // Reset input
                return;
            }

            // Create backup before import
            exportToJSON();

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedData = JSON.parse(e.target.result);
                    
                    // Validate imported data
                    if (!importedData.acts || !Array.isArray(importedData.acts)) {
                        throw new Error('Format de fichier invalide');
                    }

                    // Merge with current structure to ensure all fields exist
                    project = {
                        title: importedData.title || "Mon Roman",
                        acts: importedData.acts || [],
                        characters: importedData.characters || [],
                        world: importedData.world || [],
                        timeline: importedData.timeline || [],
                        notes: importedData.notes || [],
                        codex: importedData.codex || [],
                        stats: importedData.stats || {
                            dailyGoal: 500,
                            totalGoal: 80000,
                            writingSessions: []
                        },
                        versions: importedData.versions || []
                    };

                    saveProject();
                    switchView('editor');
                    renderActsList();
                    closeModal('backupModal');
                    
                    alert('✅ Import réussi !\n\nToutes vos données ont été restaurées.');
                } catch (error) {
                    alert('❌ Erreur lors de l\'import : ' + error.message);
                }
                
                event.target.value = ''; // Reset input
            };
            
            reader.onerror = function() {
                alert('❌ Erreur lors de la lecture du fichier');
                event.target.value = ''; // Reset input
            };
            
            reader.readAsText(file);
        }

        // Export
        function exportProject() {
            let text = `${project.title}\n${'='.repeat(project.title.length)}\n\n`;
            
            project.acts.forEach(act => {
                text += `\n\n${act.title}\n${'='.repeat(act.title.length)}\n\n`;
                
                act.chapters.forEach(chapter => {
                    text += `\n${chapter.title}\n${'-'.repeat(chapter.title.length)}\n\n`;
                    chapter.scenes.forEach(scene => {
                        // Convert HTML to plain text for export
                        const temp = document.createElement('div');
                        temp.innerHTML = scene.content;
                        const plainText = temp.textContent || temp.innerText || '';
                        
                        text += `\n${scene.title}\n\n${plainText}\n\n`;
                    });
                });
            });

            const blob = new Blob([text], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${project.title.replace(/\s+/g, '_')}.txt`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // Modal Management
        function openAddActModal() {
            document.getElementById('addActModal').classList.add('active');
            setTimeout(() => document.getElementById('actTitleInput').focus(), 100);
        }

        function openAddChapterModal(actId) {
            activeActId = actId;
            document.getElementById('addChapterModal').classList.add('active');
            setTimeout(() => document.getElementById('chapterTitleInput').focus(), 100);
        }

        function closeModal(modalId) {
            document.getElementById(modalId).classList.remove('active');
        }

        // ========================================
        // MOBILE MENU FUNCTIONS
        // ========================================
        
        function toggleMobileSidebar() {
            const sidebar = document.querySelector('.sidebar');
            const overlay = document.querySelector('.sidebar-overlay');
            const menuBtn = document.querySelector('.mobile-menu-toggle');
            
            // Toggle sidebar
            sidebar.classList.toggle('mobile-open');
            
            // Toggle overlay
            if (sidebar.classList.contains('mobile-open')) {
                overlay.style.display = 'block';
                setTimeout(() => overlay.classList.add('active'), 10);
                menuBtn.innerHTML = '✕';
                // Prevent body scroll when menu is open
                document.body.style.overflow = 'hidden';
            } else {
                overlay.classList.remove('active');
                setTimeout(() => overlay.style.display = 'none', 300);
                menuBtn.innerHTML = '☰';
                // Restore body scroll
                document.body.style.overflow = '';
            }
        }
        
        function closeMobileSidebar() {
            const sidebar = document.querySelector('.sidebar');
            const overlay = document.querySelector('.sidebar-overlay');
            const menuBtn = document.querySelector('.mobile-menu-toggle');
            
            if (sidebar.classList.contains('mobile-open')) {
                sidebar.classList.remove('mobile-open');
                overlay.classList.remove('active');
                setTimeout(() => overlay.style.display = 'none', 300);
                menuBtn.innerHTML = '☰';
                document.body.style.overflow = '';
            }
        }
        
        // ========================================
        // MOBILE NAVIGATION FUNCTIONS
        // ========================================
        
        function toggleMobileNav() {
            const dropdown = document.getElementById('mobileNavDropdown');
            const toggleBtn = document.getElementById('mobileNavToggleBtn');
            
            if (dropdown.classList.contains('active')) {
                dropdown.classList.remove('active');
                toggleBtn.innerHTML = '☰';
            } else {
                dropdown.classList.add('active');
                toggleBtn.innerHTML = '✕';
            }
        }
        
        function closeMobileNav() {
            const dropdown = document.getElementById('mobileNavDropdown');
            const toggleBtn = document.getElementById('mobileNavToggleBtn');
            
            if (dropdown.classList.contains('active')) {
                dropdown.classList.remove('active');
                toggleBtn.innerHTML = '☰';
            }
        }
        
        function switchViewMobile(view) {
            // Update active state in mobile menu
            document.querySelectorAll('.mobile-nav-item').forEach(item => {
                item.classList.remove('active');
            });
            const activeItem = document.querySelector(`[data-view="${view}"]`);
            if (activeItem) {
                activeItem.classList.add('active');
            }
            
            // Close mobile nav
            closeMobileNav();
            
            // Switch to the view
            switchView(view);
        }
        
        // ========================================
        // MOBILE EDITOR TOOLBAR FUNCTIONS
        // ========================================
        
        function toggleEditorToolbar() {
            const toolbar = document.getElementById('editorToolbar');
            const toggleText = document.getElementById('toolbarToggleText');
            
            if (toolbar.classList.contains('expanded')) {
                toolbar.classList.remove('expanded');
                toggleText.textContent = '📝 Afficher les outils de formatage';
            } else {
                toolbar.classList.add('expanded');
                toggleText.textContent = '✕ Masquer les outils de formatage';
            }
        }
        
        // Override switchView to close mobile sidebar
        const originalSwitchView = switchView;
        switchView = function(view) {
            if (window.innerWidth <= 768) {
                closeMobileSidebar();
            }
            originalSwitchView(view);
        };
        
        // Handle window resize
        let resizeTimeout;
        window.addEventListener('resize', function() {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(function() {
                // If resizing to desktop, ensure sidebar is visible and overlay hidden
                if (window.innerWidth > 768) {
                    const sidebar = document.querySelector('.sidebar');
                    const overlay = document.querySelector('.sidebar-overlay');
                    const menuBtn = document.querySelector('.mobile-menu-toggle');
                    
                    sidebar.classList.remove('mobile-open');
                    overlay.classList.remove('active');
                    overlay.style.display = 'none';
                    menuBtn.innerHTML = '☰';
                    document.body.style.overflow = '';
                }
            }, 250);
        });

        // Drag and Drop for Acts
        let draggedAct = null;

        function setupActDragAndDrop() {
            const actHeaders = document.querySelectorAll('.act-header.draggable');
            
            actHeaders.forEach(header => {
                header.addEventListener('dragstart', (e) => {
                    draggedAct = parseInt(e.target.dataset.actId);
                    e.target.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('type', 'act');
                });

                header.addEventListener('dragend', (e) => {
                    e.target.classList.remove('dragging');
                    draggedAct = null;
                });

                header.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    
                    const targetActId = parseInt(e.currentTarget.dataset.actId);
                    if (draggedAct && draggedAct !== targetActId) {
                        e.currentTarget.classList.add('drag-over');
                    }
                });

                header.addEventListener('dragleave', (e) => {
                    e.currentTarget.classList.remove('drag-over');
                });

                header.addEventListener('drop', (e) => {
                    e.preventDefault();
                    e.currentTarget.classList.remove('drag-over');
                    
                    const targetActId = parseInt(e.currentTarget.dataset.actId);
                    
                    if (draggedAct && draggedAct !== targetActId) {
                        reorderActs(draggedAct, targetActId);
                    }
                });
            });
        }

        function reorderActs(draggedId, targetId) {
            const draggedIndex = project.acts.findIndex(a => a.id === draggedId);
            const targetIndex = project.acts.findIndex(a => a.id === targetId);
            
            if (draggedIndex === -1 || targetIndex === -1) return;
            
            const [removed] = project.acts.splice(draggedIndex, 1);
            project.acts.splice(targetIndex, 0, removed);
            
            saveProject();
            renderActsList();
        }

        // Drag and Drop for Chapters
        let draggedChapter = { chapterId: null, actId: null };

        function setupChapterDragAndDrop() {
            const chapterHeaders = document.querySelectorAll('.chapter-header.draggable');
            
            chapterHeaders.forEach(header => {
                header.addEventListener('dragstart', (e) => {
                    draggedChapter.chapterId = parseInt(e.target.dataset.chapterId);
                    draggedChapter.actId = parseInt(e.target.dataset.actId);
                    e.target.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('type', 'chapter');
                });

                header.addEventListener('dragend', (e) => {
                    e.target.classList.remove('dragging');
                    draggedChapter = { chapterId: null, actId: null };
                });

                header.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    
                    const targetChapterId = parseInt(e.currentTarget.dataset.chapterId);
                    const targetActId = parseInt(e.currentTarget.dataset.actId);
                    
                    if (draggedChapter.chapterId && draggedChapter.chapterId !== targetChapterId) {
                        e.currentTarget.classList.add('drag-over');
                    } else if (draggedScene.sceneId && draggedScene.chapterId !== targetChapterId) {
                        e.currentTarget.classList.add('drag-over');
                    }
                });

                header.addEventListener('dragleave', (e) => {
                    e.currentTarget.classList.remove('drag-over');
                });

                header.addEventListener('drop', (e) => {
                    e.preventDefault();
                    e.currentTarget.classList.remove('drag-over');
                    
                    const targetChapterId = parseInt(e.currentTarget.dataset.chapterId);
                    const targetActId = parseInt(e.currentTarget.dataset.actId);
                    
                    if (draggedChapter.chapterId && draggedChapter.chapterId !== targetChapterId) {
                        reorderChapters(draggedChapter.chapterId, draggedChapter.actId, targetChapterId, targetActId);
                    } else if (draggedScene.sceneId && draggedScene.chapterId !== targetChapterId) {
                        moveSceneToChapter(draggedScene.sceneId, draggedScene.actId, draggedScene.chapterId, targetActId, targetChapterId);
                    }
                });
            });
        }

        function reorderChapters(draggedChapterId, draggedActId, targetChapterId, targetActId) {
            const sourceAct = project.acts.find(a => a.id === draggedActId);
            const targetAct = project.acts.find(a => a.id === targetActId);
            
            if (!sourceAct || !targetAct) return;
            
            const draggedIndex = sourceAct.chapters.findIndex(c => c.id === draggedChapterId);
            const targetIndex = targetAct.chapters.findIndex(c => c.id === targetChapterId);
            
            if (draggedIndex === -1 || targetIndex === -1) return;
            
            const [removed] = sourceAct.chapters.splice(draggedIndex, 1);
            
            if (draggedActId === targetActId) {
                targetAct.chapters.splice(targetIndex, 0, removed);
            } else {
                targetAct.chapters.splice(targetIndex, 0, removed);
            }
            
            saveProject();
            renderActsList();
        }

        // Drag and Drop for Scenes
        let draggedScene = { sceneId: null, chapterId: null, actId: null };

        function setupSceneDragAndDrop() {
            const sceneItems = document.querySelectorAll('.scene-item.draggable');
            
            sceneItems.forEach(item => {
                item.addEventListener('dragstart', (e) => {
                    draggedScene.sceneId = parseInt(e.target.dataset.sceneId);
                    draggedScene.chapterId = parseInt(e.target.dataset.chapterId);
                    draggedScene.actId = parseInt(e.target.dataset.actId);
                    e.target.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                });

                item.addEventListener('dragend', (e) => {
                    e.target.classList.remove('dragging');
                    draggedScene = { sceneId: null, chapterId: null, actId: null };
                });

                item.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    
                    const targetSceneId = parseInt(e.currentTarget.dataset.sceneId);
                    const targetChapterId = parseInt(e.currentTarget.dataset.chapterId);
                    
                    if (draggedScene.sceneId && draggedScene.sceneId !== targetSceneId) {
                        e.currentTarget.classList.add('drag-over');
                    }
                });

                item.addEventListener('dragleave', (e) => {
                    e.currentTarget.classList.remove('drag-over');
                });

                item.addEventListener('drop', (e) => {
                    e.preventDefault();
                    e.currentTarget.classList.remove('drag-over');
                    
                    const targetSceneId = parseInt(e.currentTarget.dataset.sceneId);
                    const targetChapterId = parseInt(e.currentTarget.dataset.chapterId);
                    const targetActId = parseInt(e.currentTarget.dataset.actId);
                    
                    if (draggedScene.sceneId && draggedScene.sceneId !== targetSceneId) {
                        reorderScenes(
                            draggedScene.sceneId, 
                            draggedScene.actId,
                            draggedScene.chapterId,
                            targetSceneId,
                            targetActId,
                            targetChapterId
                        );
                    }
                });
            });
        }

        function reorderScenes(draggedSceneId, draggedActId, draggedChapterId, targetSceneId, targetActId, targetChapterId) {
            const sourceAct = project.acts.find(a => a.id === draggedActId);
            const targetAct = project.acts.find(a => a.id === targetActId);
            
            if (!sourceAct || !targetAct) return;
            
            const sourceChapter = sourceAct.chapters.find(c => c.id === draggedChapterId);
            const targetChapter = targetAct.chapters.find(c => c.id === targetChapterId);
            
            if (!sourceChapter || !targetChapter) return;
            
            const draggedIndex = sourceChapter.scenes.findIndex(s => s.id === draggedSceneId);
            const targetIndex = targetChapter.scenes.findIndex(s => s.id === targetSceneId);
            
            if (draggedIndex === -1 || targetIndex === -1) return;
            
            const [removed] = sourceChapter.scenes.splice(draggedIndex, 1);
            
            if (draggedChapterId === targetChapterId) {
                targetChapter.scenes.splice(targetIndex, 0, removed);
            } else {
                targetChapter.scenes.splice(targetIndex, 0, removed);
            }
            
            saveProject();
            renderActsList();
        }

        function moveSceneToChapter(sceneId, sourceActId, sourceChapterId, targetActId, targetChapterId) {
            const sourceAct = project.acts.find(a => a.id === sourceActId);
            const targetAct = project.acts.find(a => a.id === targetActId);
            
            if (!sourceAct || !targetAct) return;
            
            const sourceChapter = sourceAct.chapters.find(c => c.id === sourceChapterId);
            const targetChapter = targetAct.chapters.find(c => c.id === targetChapterId);
            
            if (!sourceChapter || !targetChapter) return;
            
            const sceneIndex = sourceChapter.scenes.findIndex(s => s.id === sceneId);
            if (sceneIndex === -1) return;
            
            const [removed] = sourceChapter.scenes.splice(sceneIndex, 1);
            targetChapter.scenes.push(removed);
            
            saveProject();
            renderActsList();
            
            // Auto-expand target chapter
            setTimeout(() => {
                const targetChapterElement = document.getElementById(`chapter-${targetChapterId}`);
                if (targetChapterElement) {
                    const icon = targetChapterElement.querySelector('.chapter-icon');
                    const scenesList = targetChapterElement.querySelector('.scenes-list');
                    if (!scenesList.classList.contains('visible')) {
                        icon.classList.add('expanded');
                        scenesList.classList.add('visible');
                    }
                }
            }, 100);
        }

        // View Management

        // Character Management
        function openAddCharacterModal() {
            document.getElementById('addCharacterModal').classList.add('active');
            setTimeout(() => document.getElementById('characterNameInput').focus(), 100);
        }

        function addCharacter() {
            const name = document.getElementById('characterNameInput').value.trim();
            const role = document.getElementById('characterRoleInput').value.trim();
            const description = document.getElementById('characterDescInput').value.trim();
            
            if (!name) return;

            const character = {
                id: Date.now(),
                name: name,
                role: role || '',
                description: description || '',
                age: '',
                appearance: '',
                personality: '',
                background: '',
                relationships: '',
                notes: '',
                linkedScenes: [], // Array of scene IDs where this character appears
                linkedElements: [] // Array of {type, id} for related world/timeline/etc
            };

            project.characters.push(character);
            
            // Clear inputs
            document.getElementById('characterNameInput').value = '';
            document.getElementById('characterRoleInput').value = '';
            document.getElementById('characterDescInput').value = '';
            
            closeModal('addCharacterModal');
            saveProject();
            renderCharactersList();
        }

        function deleteCharacter(id) {
            if (!confirm('Êtes-vous sûr de vouloir supprimer ce personnage ?')) return;
            project.characters = project.characters.filter(c => c.id !== id);
            saveProject();
            renderCharactersList();
            showEmptyState();
        }

        function renderCharactersList() {
            const container = document.getElementById('charactersList');
            
            if (project.characters.length === 0) {
                container.innerHTML = '<div style="padding: 2rem; text-align: center; color: var(--text-muted);">Aucun personnage</div>';
                return;
            }

            container.innerHTML = project.characters.map(char => `
                <div class="database-card" onclick="openCharacterDetail(${char.id})">
                    <div style="display: flex; justify-content: space-between; align-items: start;">
                        <div style="flex: 1;">
                            <div style="font-size: 1.1rem; font-weight: 600; margin-bottom: 0.25rem;">${char.name}</div>
                            <div style="font-size: 0.85rem; color: var(--text-muted); margin-bottom: 0.5rem;">${char.role || 'Personnage'}</div>
                            <div style="font-size: 0.9rem; color: var(--text-secondary); line-height: 1.4;">${char.description || 'Aucune description'}</div>
                        </div>
                        <button class="btn btn-icon btn-small" onclick="event.stopPropagation(); deleteCharacter(${char.id})" title="Supprimer">×</button>
                    </div>
                </div>
            `).join('');
        }

        function renderCharacterLinkedScenes(character) {
            const scenes = findScenesWithCharacter(character.id);
            if (scenes.length === 0) return '';

            return `
                <div class="detail-section">
                    <div class="detail-section-title">📝 Apparaît dans ${scenes.length} scène(s)</div>
                    <div class="quick-links">
                        ${scenes.map(scene => `
                            <span class="link-badge" onclick="openScene(${scene.actId}, ${scene.chapterId}, ${scene.sceneId})">
                                ${scene.sceneTitle}
                            </span>
                        `).join('')}
                    </div>
                </div>
            `;
        }

        function openCharacterDetail(id) {
            const character = project.characters.find(c => c.id === id);
            if (!character) return;

            const editorView = document.getElementById('editorView');
            editorView.innerHTML = `
                <div class="detail-view">
                    <div class="detail-header">
                        <div class="detail-title">${character.name}</div>
                        <div style="display: flex; gap: 0.5rem;">
                            <button class="btn btn-small" onclick="showReferencesForCharacter(${id})">🔗 Voir les références</button>
                            <button class="btn" onclick="switchView('editor')">← Retour à l'éditeur</button>
                        </div>
                    </div>
                    
                    ${renderCharacterLinkedScenes(character)}
                    
                    <div class="detail-section">
                        <div class="detail-section-title">Informations de base</div>
                        <div class="detail-field">
                            <div class="detail-label">Nom</div>
                            <input type="text" class="form-input" value="${character.name}" 
                                   onchange="updateCharacterField(${id}, 'name', this.value)">
                        </div>
                        <div class="detail-field">
                            <div class="detail-label">Rôle</div>
                            <input type="text" class="form-input" value="${character.role}" 
                                   onchange="updateCharacterField(${id}, 'role', this.value)">
                        </div>
                        <div class="detail-field">
                            <div class="detail-label">Âge</div>
                            <input type="text" class="form-input" value="${character.age}" 
                                   onchange="updateCharacterField(${id}, 'age', this.value)">
                        </div>
                        <div class="detail-field">
                            <div class="detail-label">Description</div>
                            <textarea class="form-input" rows="4" 
                                      onchange="updateCharacterField(${id}, 'description', this.value)">${character.description}</textarea>
                        </div>
                    </div>

                    <div class="detail-section">
                        <div class="detail-section-title">Apparence</div>
                        <textarea class="form-input" rows="4" 
                                  onchange="updateCharacterField(${id}, 'appearance', this.value)">${character.appearance}</textarea>
                    </div>

                    <div class="detail-section">
                        <div class="detail-section-title">Personnalité</div>
                        <textarea class="form-input" rows="4" 
                                  onchange="updateCharacterField(${id}, 'personality', this.value)">${character.personality}</textarea>
                    </div>

                    <div class="detail-section">
                        <div class="detail-section-title">Histoire / Passé</div>
                        <textarea class="form-input" rows="6" 
                                  onchange="updateCharacterField(${id}, 'background', this.value)">${character.background}</textarea>
                    </div>

                    <div class="detail-section">
                        <div class="detail-section-title">Relations</div>
                        <textarea class="form-input" rows="4" 
                                  onchange="updateCharacterField(${id}, 'relationships', this.value)">${character.relationships}</textarea>
                    </div>

                    <div class="detail-section">
                        <div class="detail-section-title">Notes diverses</div>
                        <textarea class="form-input" rows="4" 
                                  onchange="updateCharacterField(${id}, 'notes', this.value)">${character.notes}</textarea>
                    </div>
                </div>
            `;
        }

        function updateCharacterField(id, field, value) {
            const character = project.characters.find(c => c.id === id);
            if (character) {
                character[field] = value;
                saveProject();
                renderCharactersList();
            }
        }

        // World Management
        function openAddWorldModal() {
            document.getElementById('addWorldModal').classList.add('active');
            setTimeout(() => document.getElementById('worldNameInput').focus(), 100);
        }

        function addWorldElement() {
            const name = document.getElementById('worldNameInput').value.trim();
            const type = document.getElementById('worldTypeInput').value;
            const description = document.getElementById('worldDescInput').value.trim();
            
            if (!name) return;

            const element = {
                id: Date.now(),
                name: name,
                type: type,
                description: description || '',
                details: '',
                history: '',
                notes: '',
                linkedScenes: [], // Array of scene IDs where this element appears
                linkedElements: [] // Array of {type, id} for related characters/timeline/etc
            };

            project.world.push(element);
            
            // Clear inputs
            document.getElementById('worldNameInput').value = '';
            document.getElementById('worldDescInput').value = '';
            
            closeModal('addWorldModal');
            saveProject();
            renderWorldList();
        }

        function deleteWorldElement(id) {
            if (!confirm('Êtes-vous sûr de vouloir supprimer cet élément ?')) return;
            project.world = project.world.filter(w => w.id !== id);
            saveProject();
            renderWorldList();
            showEmptyState();
        }

        function renderWorldList() {
            const container = document.getElementById('worldList');
            
            if (project.world.length === 0) {
                container.innerHTML = '<div style="padding: 2rem; text-align: center; color: var(--text-muted);">Aucun élément</div>';
                return;
            }

            container.innerHTML = project.world.map(element => `
                <div class="database-card" onclick="openWorldDetail(${element.id})">
                    <div style="display: flex; justify-content: space-between; align-items: start;">
                        <div style="flex: 1;">
                            <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.25rem;">
                                <div style="font-size: 1.1rem; font-weight: 600;">${element.name}</div>
                                <span style="font-size: 0.75rem; padding: 0.25rem 0.5rem; background: var(--accent-gold); color: var(--bg-primary); border-radius: 2px;">${element.type}</span>
                            </div>
                            <div style="font-size: 0.9rem; color: var(--text-secondary); line-height: 1.4;">${element.description || 'Aucune description'}</div>
                        </div>
                        <button class="btn btn-icon btn-small" onclick="event.stopPropagation(); deleteWorldElement(${element.id})" title="Supprimer">×</button>
                    </div>
                </div>
            `).join('');
        }

        function renderElementLinkedScenes(element) {
            const scenes = findScenesWithElement(element.id);
            if (scenes.length === 0) return '';

            return `
                <div class="detail-section">
                    <div class="detail-section-title">📝 Apparaît dans ${scenes.length} scène(s)</div>
                    <div class="quick-links">
                        ${scenes.map(scene => `
                            <span class="link-badge" onclick="openScene(${scene.actId}, ${scene.chapterId}, ${scene.sceneId})">
                                ${scene.sceneTitle}
                            </span>
                        `).join('')}
                    </div>
                </div>
            `;
        }

        function openWorldDetail(id) {
            const element = project.world.find(w => w.id === id);
            if (!element) return;

            const editorView = document.getElementById('editorView');
            editorView.innerHTML = `
                <div class="detail-view">
                    <div class="detail-header">
                        <div style="display: flex; align-items: center; gap: 1rem;">
                            <div class="detail-title">${element.name}</div>
                            <span style="font-size: 0.9rem; padding: 0.5rem 1rem; background: var(--accent-gold); color: var(--bg-primary); border-radius: 2px;">${element.type}</span>
                        </div>
                        <div style="display: flex; gap: 0.5rem;">
                            <button class="btn btn-small" onclick="showReferencesForElement(${id})">🔗 Voir les références</button>
                            <button class="btn" onclick="switchView('editor')">← Retour à l'éditeur</button>
                        </div>
                    </div>
                    
                    ${renderElementLinkedScenes(element)}
                    
                    <div class="detail-section">
                        <div class="detail-section-title">Informations de base</div>
                        <div class="detail-field">
                            <div class="detail-label">Nom</div>
                            <input type="text" class="form-input" value="${element.name}" 
                                   onchange="updateWorldField(${id}, 'name', this.value)">
                        </div>
                    </div>

                    <div class="detail-section">
                        <div class="detail-section-title">Type</div>
                        <select class="form-input" onchange="updateWorldField(${id}, 'type', this.value)">
                            <option value="Lieu" ${element.type === 'Lieu' ? 'selected' : ''}>Lieu</option>
                            <option value="Objet" ${element.type === 'Objet' ? 'selected' : ''}>Objet</option>
                            <option value="Concept" ${element.type === 'Concept' ? 'selected' : ''}>Concept</option>
                            <option value="Organisation" ${element.type === 'Organisation' ? 'selected' : ''}>Organisation</option>
                            <option value="Événement" ${element.type === 'Événement' ? 'selected' : ''}>Événement</option>
                        </select>
                    </div>

                    <div class="detail-section">
                        <div class="detail-section-title">Description</div>
                        <textarea class="form-input" rows="6" 
                                  onchange="updateWorldField(${id}, 'description', this.value)">${element.description}</textarea>
                    </div>

                    <div class="detail-section">
                        <div class="detail-section-title">Détails</div>
                        <textarea class="form-input" rows="6" 
                                  onchange="updateWorldField(${id}, 'details', this.value)">${element.details}</textarea>
                    </div>

                    <div class="detail-section">
                        <div class="detail-section-title">Histoire</div>
                        <textarea class="form-input" rows="6" 
                                  onchange="updateWorldField(${id}, 'history', this.value)">${element.history}</textarea>
                    </div>

                    <div class="detail-section">
                        <div class="detail-section-title">Notes</div>
                        <textarea class="form-input" rows="4" 
                                  onchange="updateWorldField(${id}, 'notes', this.value)">${element.notes}</textarea>
                    </div>
                </div>
            `;
        }

        function updateWorldField(id, field, value) {
            const element = project.world.find(w => w.id === id);
            if (element) {
                element[field] = value;
                saveProject();
                renderWorldList();
            }
        }

        // Timeline Management
        function openAddTimelineModal() {
            document.getElementById('addTimelineModal').classList.add('active');
            setTimeout(() => document.getElementById('timelineTitleInput').focus(), 100);
        }

        function addTimelineEvent() {
            const title = document.getElementById('timelineTitleInput').value.trim();
            const date = document.getElementById('timelineDateInput').value.trim();
            const location = document.getElementById('timelineLocationInput').value.trim();
            const characters = document.getElementById('timelineCharactersInput').value.trim();
            const description = document.getElementById('timelineDescInput').value.trim();
            
            if (!title) return;

            const event = {
                id: Date.now(),
                title: title,
                date: date || '',
                location: location || '',
                characters: characters || '',
                description: description || '',
                order: project.timeline.length, // For manual reordering
                consequences: '',
                notes: ''
            };

            project.timeline.push(event);
            
            // Clear inputs
            document.getElementById('timelineTitleInput').value = '';
            document.getElementById('timelineDateInput').value = '';
            document.getElementById('timelineLocationInput').value = '';
            document.getElementById('timelineCharactersInput').value = '';
            document.getElementById('timelineDescInput').value = '';
            
            closeModal('addTimelineModal');
            saveProject();
            renderTimelineList();
        }

        function deleteTimelineEvent(id) {
            if (!confirm('Êtes-vous sûr de vouloir supprimer cet événement ?')) return;
            project.timeline = project.timeline.filter(e => e.id !== id);
            saveProject();
            renderTimelineList();
            showEmptyState();
        }

        function renderTimelineList() {
            const container = document.getElementById('timelineList');
            
            if (project.timeline.length === 0) {
                container.innerHTML = '<div style="padding: 2rem; text-align: center; color: var(--text-muted);">Aucun événement</div>';
                return;
            }

            // Sort by order field for manual ordering
            const sortedTimeline = [...project.timeline].sort((a, b) => a.order - b.order);

            container.innerHTML = `
                <div class="timeline-container">
                    <div class="timeline-line"></div>
                    ${sortedTimeline.map(event => `
                        <div class="timeline-event" onclick="openTimelineDetail(${event.id})">
                            <div style="display: flex; justify-content: space-between; align-items: start;">
                                <div style="flex: 1;">
                                    ${event.date ? `<div class="timeline-date">📅 ${event.date}</div>` : ''}
                                    <div class="timeline-title">${event.title}</div>
                                    <div class="timeline-meta">
                                        ${event.location ? `<div class="timeline-meta-item">📍 ${event.location}</div>` : ''}
                                        ${event.characters ? `<div class="timeline-meta-item">👥 ${event.characters}</div>` : ''}
                                    </div>
                                    ${event.description ? `<div class="timeline-description">${event.description}</div>` : ''}
                                </div>
                                <button class="btn btn-icon btn-small" onclick="event.stopPropagation(); deleteTimelineEvent(${event.id})" title="Supprimer">×</button>
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        function openTimelineDetail(id) {
            const event = project.timeline.find(e => e.id === id);
            if (!event) return;

            const editorView = document.getElementById('editorView');
            editorView.innerHTML = `
                <div class="detail-view">
                    <div class="detail-header">
                        <div class="detail-title">${event.title}</div>
                        <button class="btn" onclick="switchView('editor')">← Retour à l'éditeur</button>
                    </div>
                    
                    <div class="detail-section">
                        <div class="detail-section-title">Informations</div>
                        <div class="detail-field">
                            <div class="detail-label">Date / Moment</div>
                            <input type="text" class="form-input" value="${event.date}" 
                                   onchange="updateTimelineField(${id}, 'date', this.value)">
                        </div>
                        <div class="detail-field">
                            <div class="detail-label">Localisation</div>
                            <input type="text" class="form-input" value="${event.location}" 
                                   onchange="updateTimelineField(${id}, 'location', this.value)">
                        </div>
                        <div class="detail-field">
                            <div class="detail-label">Personnages impliqués</div>
                            <input type="text" class="form-input" value="${event.characters}" 
                                   onchange="updateTimelineField(${id}, 'characters', this.value)">
                        </div>
                    </div>

                    <div class="detail-section">
                        <div class="detail-section-title">Description</div>
                        <textarea class="form-input" rows="6" 
                                  onchange="updateTimelineField(${id}, 'description', this.value)">${event.description}</textarea>
                    </div>

                    <div class="detail-section">
                        <div class="detail-section-title">Conséquences</div>
                        <textarea class="form-input" rows="6" 
                                  onchange="updateTimelineField(${id}, 'consequences', this.value)">${event.consequences}</textarea>
                        <small style="color: var(--text-muted); font-style: italic;">Qu'est-ce que cet événement déclenche ou change dans l'histoire ?</small>
                    </div>

                    <div class="detail-section">
                        <div class="detail-section-title">Notes</div>
                        <textarea class="form-input" rows="4" 
                                  onchange="updateTimelineField(${id}, 'notes', this.value)">${event.notes}</textarea>
                    </div>
                </div>
            `;
        }

        function updateTimelineField(id, field, value) {
            const event = project.timeline.find(e => e.id === id);
            if (event) {
                event[field] = value;
                saveProject();
                renderTimelineList();
            }
        }

        // Notes Management
        function openAddNoteModal() {
            document.getElementById('addNoteModal').classList.add('active');
            setTimeout(() => document.getElementById('noteTitleInput').focus(), 100);
        }

        function addNote() {
            const title = document.getElementById('noteTitleInput').value.trim();
            const category = document.getElementById('noteCategoryInput').value;
            const tags = document.getElementById('noteTagsInput').value.trim();
            const content = document.getElementById('noteContentInput').value.trim();
            
            if (!title) return;

            const note = {
                id: Date.now(),
                title: title,
                category: category,
                tags: tags ? tags.split(',').map(t => t.trim()).filter(t => t) : [],
                content: content || '',
                createdAt: new Date().toISOString(),
                updatedAt: new Date().toISOString()
            };

            project.notes.push(note);
            
            // Clear inputs
            document.getElementById('noteTitleInput').value = '';
            document.getElementById('noteTagsInput').value = '';
            document.getElementById('noteContentInput').value = '';
            
            closeModal('addNoteModal');
            saveProject();
            renderNotesList();
        }

        function deleteNote(id) {
            if (!confirm('Êtes-vous sûr de vouloir supprimer cette note ?')) return;
            project.notes = project.notes.filter(n => n.id !== id);
            saveProject();
            renderNotesList();
            showEmptyState();
        }

        function renderNotesList() {
            const container = document.getElementById('notesList');
            
            if (project.notes.length === 0) {
                container.innerHTML = '<div style="padding: 2rem; text-align: center; color: var(--text-muted);">Aucune note</div>';
                return;
            }

            // Sort by most recent first
            const sortedNotes = [...project.notes].sort((a, b) => 
                new Date(b.updatedAt) - new Date(a.updatedAt)
            );

            container.innerHTML = sortedNotes.map(note => `
                <div class="note-card" onclick="openNoteDetail(${note.id})">
                    <div style="display: flex; justify-content: space-between; align-items: start;">
                        <div style="flex: 1;">
                            <div class="note-category-badge">${note.category}</div>
                            <div class="note-title">${note.title}</div>
                            ${note.content ? `<div class="note-preview">${note.content}</div>` : ''}
                            ${note.tags.length > 0 ? `
                                <div class="note-tags">
                                    ${note.tags.map(tag => `<span class="note-tag">${tag}</span>`).join('')}
                                </div>
                            ` : ''}
                            <div class="note-date">${new Date(note.updatedAt).toLocaleDateString('fr-FR')}</div>
                        </div>
                        <button class="btn btn-icon btn-small" onclick="event.stopPropagation(); deleteNote(${note.id})" title="Supprimer">×</button>
                    </div>
                </div>
            `).join('');
        }

        function openNoteDetail(id) {
            const note = project.notes.find(n => n.id === id);
            if (!note) return;

            const editorView = document.getElementById('editorView');
            editorView.innerHTML = `
                <div class="detail-view">
                    <div class="detail-header">
                        <div style="display: flex; align-items: center; gap: 1rem; flex: 1;">
                            <input type="text" class="form-input" value="${note.title}" 
                                   style="font-size: 1.8rem; font-weight: 600; font-family: 'Noto Serif JP', serif; padding: 0.5rem;"
                                   onchange="updateNoteField(${id}, 'title', this.value)"
                                   placeholder="Titre de la note">
                            <span style="font-size: 0.8rem; padding: 0.4rem 0.8rem; background: var(--accent-gold); color: var(--bg-primary); border-radius: 2px;">${note.category}</span>
                        </div>
                        <button class="btn" onclick="switchView('editor')">← Retour à l'éditeur</button>
                    </div>
                    
                    <div class="detail-section">
                        <div class="detail-section-title">Catégorie</div>
                        <select class="form-input" onchange="updateNoteField(${id}, 'category', this.value)">
                            <option value="Recherche" ${note.category === 'Recherche' ? 'selected' : ''}>Recherche</option>
                            <option value="Idée" ${note.category === 'Idée' ? 'selected' : ''}>Idée</option>
                            <option value="Référence" ${note.category === 'Référence' ? 'selected' : ''}>Référence</option>
                            <option value="A faire" ${note.category === 'A faire' ? 'selected' : ''}>À faire</option>
                            <option value="Question" ${note.category === 'Question' ? 'selected' : ''}>Question</option>
                            <option value="Autre" ${note.category === 'Autre' ? 'selected' : ''}>Autre</option>
                        </select>
                    </div>

                    <div class="detail-section">
                        <div class="detail-section-title">Tags</div>
                        <input type="text" class="form-input" value="${note.tags.join(', ')}" 
                               onchange="updateNoteTags(${id}, this.value)">
                        <small style="color: var(--text-muted); font-style: italic;">Séparez les tags par des virgules</small>
                    </div>

                    <div class="detail-section">
                        <div class="detail-section-title">Contenu</div>
                        <textarea class="form-input" rows="20" 
                                  oninput="updateNoteField(${id}, 'content', this.value)">${note.content}</textarea>
                    </div>

                    <div style="font-size: 0.8rem; color: var(--text-muted); margin-top: 2rem; font-family: 'Source Code Pro', monospace;">
                        Créée le ${new Date(note.createdAt).toLocaleDateString('fr-FR')} • 
                        Modifiée le ${new Date(note.updatedAt).toLocaleDateString('fr-FR')}
                    </div>
                </div>
            `;
        }

        function updateNoteField(id, field, value) {
            const note = project.notes.find(n => n.id === id);
            if (note) {
                note[field] = value;
                note.updatedAt = new Date().toISOString();
                saveProject();
                renderNotesList();
            }
        }

        function updateNoteTags(id, tagsString) {
            const note = project.notes.find(n => n.id === id);
            if (note) {
                note.tags = tagsString.split(',').map(t => t.trim()).filter(t => t);
                note.updatedAt = new Date().toISOString();
                saveProject();
                renderNotesList();
            }
        }

        // Version Control Management
        function createVersion() {
            const label = prompt('Nom de la version (ex: "Version 1.0", "Avant révision", etc.)');
            if (!label || !label.trim()) return;

            const totalWords = project.acts.reduce((sum, act) => {
                return sum + act.chapters.reduce((chSum, chapter) => {
                    return chSum + chapter.scenes.reduce((sceneSum, scene) => {
                        return sceneSum + getWordCount(scene.content);
                    }, 0);
                }, 0);
            }, 0);

            const version = {
                id: Date.now(),
                label: label.trim(),
                timestamp: new Date().toISOString(),
                wordCount: totalWords,
                snapshot: JSON.parse(JSON.stringify({ 
                    acts: project.acts,
                    characters: project.characters,
                    world: project.world,
                    timeline: project.timeline,
                    notes: project.notes,
                    codex: project.codex
                }))
            };

            project.versions.push(version);
            saveProject();
            renderVersionsList();
            alert('Version créée avec succès !');
        }

        function deleteVersion(id) {
            if (!confirm('Êtes-vous sûr de vouloir supprimer cette version ?')) return;
            project.versions = project.versions.filter(v => v.id !== id);
            saveProject();
            renderVersionsList();
        }

        function restoreVersion(id) {
            if (!confirm('⚠️ ATTENTION: Restaurer cette version va remplacer votre travail actuel. Voulez-vous créer une sauvegarde avant de continuer ?')) {
                return;
            }

            // Create backup of current state
            createVersion();

            const version = project.versions.find(v => v.id === id);
            if (!version) return;

            // Restore snapshot
            project.acts = JSON.parse(JSON.stringify(version.snapshot.acts));
            project.characters = JSON.parse(JSON.stringify(version.snapshot.characters || []));
            project.world = JSON.parse(JSON.stringify(version.snapshot.world || []));
            project.timeline = JSON.parse(JSON.stringify(version.snapshot.timeline || []));
            project.notes = JSON.parse(JSON.stringify(version.snapshot.notes || []));
            project.codex = JSON.parse(JSON.stringify(version.snapshot.codex || []));

            saveProject();
            switchView('editor');
            renderActsList();
            alert('Version restaurée avec succès !');
        }

        function renderVersionsList() {
            const editorView = document.getElementById('editorView');
            if (!editorView) {
                console.error('editorView not found');
                return;
            }
            
            // Sort by most recent first
            const sortedVersions = [...project.versions].sort((a, b) => 
                new Date(b.timestamp) - new Date(a.timestamp)
            );

            editorView.innerHTML = `
                <div style="height: 100%; overflow-y: auto; padding: 2rem 3rem;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 2rem;">
                        <h2 style="color: var(--accent-gold);">🕐 Gestion des Versions</h2>
                        <button class="btn btn-primary" onclick="createVersion()">
                            + Créer une version
                        </button>
                    </div>
                    
                    ${project.versions.length === 0 ? `
                        <div style="text-align: center; padding: 4rem 2rem; color: var(--text-muted);">
                            <div style="font-size: 3rem; margin-bottom: 1rem;">📦</div>
                            <div style="font-size: 1.2rem; margin-bottom: 0.5rem;">Aucune version sauvegardée</div>
                            <div style="font-size: 0.9rem; margin-bottom: 2rem;">
                                Les versions vous permettent de créer des snapshots de votre projet<br>
                                pour revenir à un état antérieur si nécessaire.
                            </div>
                            <button class="btn btn-primary" onclick="createVersion()">
                                Créer votre première version
                            </button>
                        </div>
                    ` : `
                        <div style="display: grid; gap: 1rem;">
                            ${sortedVersions.map(version => `
                                <div style="background: var(--bg-secondary); padding: 1.5rem; border-radius: 8px; border-left: 4px solid var(--accent-gold);">
                                    <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 1rem;">
                                        <div>
                                            <div style="font-size: 1.1rem; font-weight: 600; color: var(--text-primary); margin-bottom: 0.25rem;">
                                                ${version.label}
                                            </div>
                                            <div style="font-size: 0.85rem; color: var(--text-muted);">
                                                ${new Date(version.timestamp).toLocaleString('fr-FR', { 
                                                    dateStyle: 'long', 
                                                    timeStyle: 'short' 
                                                })}
                                            </div>
                                        </div>
                                        <div style="text-align: right;">
                                            <div style="font-size: 1.5rem; font-weight: 700; color: var(--accent-gold);">
                                                ${version.wordCount.toLocaleString('fr-FR')}
                                            </div>
                                            <div style="font-size: 0.75rem; color: var(--text-muted);">
                                                mots
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                                        <button class="btn btn-small" onclick="restoreVersion(${version.id})" 
                                                style="background: var(--accent-gold); color: white; border: none;">
                                            ↺ Restaurer
                                        </button>
                                        <button class="btn btn-small" onclick="compareVersion(${version.id})">
                                            📊 Comparer
                                        </button>
                                        <button class="btn btn-small" onclick="deleteVersion(${version.id})" 
                                                style="background: var(--accent-red); color: white; border: none;">
                                            🗑️ Supprimer
                                        </button>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    `}
                </div>
            `;
        }

        function compareVersion(id) {
            const version = project.versions.find(v => v.id === id);
            if (!version) return;

            const currentWords = project.acts.reduce((sum, act) => {
                return sum + act.chapters.reduce((chSum, chapter) => {
                    return chSum + chapter.scenes.reduce((sceneSum, scene) => {
                        return sceneSum + getWordCount(scene.content);
                    }, 0);
                }, 0);
            }, 0);

            const diff = currentWords - version.wordCount;
            const diffText = diff > 0 ? `+${diff}` : diff;

            alert(`Comparaison avec "${version.label}":\n\nVersion sauvegardée: ${version.wordCount.toLocaleString('fr-FR')} mots\nVersion actuelle: ${currentWords.toLocaleString('fr-FR')} mots\nDifférence: ${diffText} mots`);
        }

        // Statistics Management
        function renderStats() {
            const editorView = document.getElementById('editorView');
            if (!editorView) {
                console.error('editorView not found');
                return;
            }
            
            // Calculate total words
            const totalWords = project.acts.reduce((sum, act) => {
                return sum + act.chapters.reduce((chSum, chapter) => {
                    return chSum + chapter.scenes.reduce((sceneSum, scene) => {
                        return sceneSum + getWordCount(scene.content);
                    }, 0);
                }, 0);
            }, 0);

            // Calculate today's words
            const today = new Date().toDateString();
            const todaySession = project.stats.writingSessions.find(s => new Date(s.date).toDateString() === today);
            const todayWords = todaySession ? todaySession.words : 0;

            // Progress percentages
            const dailyProgress = Math.min((todayWords / project.stats.dailyGoal) * 100, 100);
            const totalProgress = Math.min((totalWords / project.stats.totalGoal) * 100, 100);

            editorView.innerHTML = `
                <div style="height: 100%; overflow-y: auto; padding: 2rem 3rem;">
                    <h2 style="margin-bottom: 2rem; color: var(--accent-gold);">📊 Statistiques</h2>
                    
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 2rem;">
                        <div class="stat-box" style="background: var(--bg-secondary); padding: 2rem; border-radius: 8px; border-left: 4px solid var(--accent-gold);">
                            <div style="font-size: 0.9rem; color: var(--text-muted); margin-bottom: 0.5rem;">Total de mots</div>
                            <div style="font-size: 2.5rem; font-weight: 700; color: var(--accent-gold); margin-bottom: 0.5rem;">${totalWords.toLocaleString('fr-FR')}</div>
                            <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 1rem;">sur ${project.stats.totalGoal.toLocaleString('fr-FR')} mots</div>
                            <div style="background: var(--bg-primary); height: 8px; border-radius: 4px; overflow: hidden;">
                                <div style="background: var(--accent-gold); height: 100%; width: ${totalProgress}%; transition: width 0.3s;"></div>
                            </div>
                            <div style="margin-top: 1rem; display: flex; gap: 0.5rem; align-items: center;">
                                <input type="number" class="form-input" value="${project.stats.totalGoal}" 
                                       id="totalGoalInput"
                                       style="flex: 1;" placeholder="Objectif total">
                                <button class="btn btn-small" onclick="updateGoal('totalGoal', document.getElementById('totalGoalInput').value)">Mettre à jour</button>
                            </div>
                        </div>

                        <div class="stat-box" style="background: var(--bg-secondary); padding: 2rem; border-radius: 8px; border-left: 4px solid var(--accent-red);">
                            <div style="font-size: 0.9rem; color: var(--text-muted); margin-bottom: 0.5rem;">Aujourd'hui</div>
                            <div style="font-size: 2.5rem; font-weight: 700; color: var(--accent-red); margin-bottom: 0.5rem;">${todayWords}</div>
                            <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 1rem;">sur ${project.stats.dailyGoal} mots</div>
                            <div style="background: var(--bg-primary); height: 8px; border-radius: 4px; overflow: hidden;">
                                <div style="background: var(--accent-red); height: 100%; width: ${dailyProgress}%; transition: width 0.3s;"></div>
                            </div>
                            <div style="margin-top: 1rem; display: flex; gap: 0.5rem; align-items: center;">
                                <input type="number" class="form-input" value="${project.stats.dailyGoal}" 
                                       id="dailyGoalInput"
                                       style="flex: 1;" placeholder="Objectif quotidien">
                                <button class="btn btn-small" onclick="updateGoal('dailyGoal', document.getElementById('dailyGoalInput').value)">Mettre à jour</button>
                            </div>
                        </div>
                    </div>
                    
                    <div style="margin-top: 2rem;">
                        <h3 style="margin-bottom: 1rem; color: var(--text-primary);">Par acte</h3>
                        <div style="background: var(--bg-secondary); padding: 1.5rem; border-radius: 8px;">
                            ${project.acts.map(act => {
                                const actWords = act.chapters.reduce((sum, chapter) => {
                                    return sum + chapter.scenes.reduce((sceneSum, scene) => {
                                        return sceneSum + getWordCount(scene.content);
                                    }, 0);
                                }, 0);
                                return `
                                    <div style="display: flex; justify-content: space-between; padding: 0.75rem 0; border-bottom: 1px solid var(--border-color);">
                                        <span style="color: var(--text-primary);">${act.title}</span>
                                        <span style="font-weight: 600; color: var(--accent-gold);">${actWords.toLocaleString('fr-FR')} mots</span>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>

                    <div style="margin-top: 2rem;">
                        <h3 style="margin-bottom: 1rem; color: var(--text-primary);">Historique (7 derniers jours)</h3>
                        <div style="background: var(--bg-secondary); padding: 1.5rem; border-radius: 8px;">
                            ${renderWritingHistory()}
                        </div>
                    </div>
                </div>
            `;
        }

        function renderWritingHistory() {
            const last7Days = [];
            for (let i = 6; i >= 0; i--) {
                const date = new Date();
                date.setDate(date.getDate() - i);
                last7Days.push(date);
            }

            return last7Days.map(date => {
                const dateStr = date.toDateString();
                const session = project.stats.writingSessions.find(s => new Date(s.date).toDateString() === dateStr);
                const words = session ? session.words : 0;
                const dayName = date.toLocaleDateString('fr-FR', { weekday: 'short', day: 'numeric', month: 'short' });
                
                return `
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.5rem 0;">
                        <span style="font-size: 0.85rem;">${dayName}</span>
                        <div style="flex: 1; margin: 0 1rem;">
                            <div class="progress-bar" style="height: 4px;">
                                <div class="progress-fill" style="width: ${Math.min((words / project.stats.dailyGoal) * 100, 100)}%; background: ${words >= project.stats.dailyGoal ? 'var(--accent-gold)' : 'var(--text-muted)'}"></div>
                            </div>
                        </div>
                        <span style="font-size: 0.85rem; font-weight: 600; font-family: 'Source Code Pro', monospace;">${words}</span>
                    </div>
                `;
            }).join('');
        }

        function updateGoal(type, value) {
            const numValue = parseInt(value);
            if (numValue && numValue > 0) {
                project.stats[type] = numValue;
                saveProject();
                renderStats();
            }
        }

        function trackWritingSession() {
            // Track writing session for stats
            const today = new Date().toDateString();
            const totalWords = project.acts.reduce((sum, act) => {
                return sum + act.chapters.reduce((chSum, chapter) => {
                    return chSum + chapter.scenes.reduce((sceneSum, scene) => {
                        return sceneSum + getWordCount(scene.content);
                    }, 0);
                }, 0);
            }, 0);

            const sessionIndex = project.stats.writingSessions.findIndex(s => new Date(s.date).toDateString() === today);
            
            if (sessionIndex >= 0) {
                project.stats.writingSessions[sessionIndex].words = totalWords - (project.stats.writingSessions[sessionIndex].startWords || 0);
            } else {
                project.stats.writingSessions.push({
                    date: new Date().toISOString(),
                    words: 0,
                    startWords: totalWords
                });
            }
        }

        // Codex Management
        function openAddCodexModal() {
            document.getElementById('addCodexModal').classList.add('active');
            setTimeout(() => document.getElementById('codexTitleInput').focus(), 100);
        }

        function addCodexEntry() {
            const title = document.getElementById('codexTitleInput').value.trim();
            const category = document.getElementById('codexCategoryInput').value;
            const summary = document.getElementById('codexSummaryInput').value.trim();
            
            if (!title) return;

            const entry = {
                id: Date.now(),
                title: title,
                category: category,
                summary: summary || '',
                content: '',
                relatedTo: [] // IDs of related characters, world elements, etc.
            };

            project.codex.push(entry);
            
            // Clear inputs
            document.getElementById('codexTitleInput').value = '';
            document.getElementById('codexSummaryInput').value = '';
            
            closeModal('addCodexModal');
            saveProject();
            renderCodexList();
        }

        function deleteCodexEntry(id) {
            if (!confirm('Êtes-vous sûr de vouloir supprimer cette entrée ?')) return;
            project.codex = project.codex.filter(c => c.id !== id);
            saveProject();
            renderCodexList();
            showEmptyState();
        }

        function renderCodexList() {
            const container = document.getElementById('codexList');
            
            if (project.codex.length === 0) {
                container.innerHTML = '<div style="padding: 2rem; text-align: center; color: var(--text-muted);">Aucune entrée</div>';
                return;
            }

            // Group by category
            const grouped = {};
            project.codex.forEach(entry => {
                if (!grouped[entry.category]) grouped[entry.category] = [];
                grouped[entry.category].push(entry);
            });

            let html = '';
            Object.keys(grouped).sort().forEach(category => {
                html += `<div style="margin-bottom: 1.5rem;">
                    <div style="font-size: 0.9rem; font-weight: 600; color: var(--accent-gold); margin-bottom: 0.75rem; text-transform: uppercase; letter-spacing: 0.05em;">${category}</div>`;
                
                grouped[category].forEach(entry => {
                    html += `
                        <div class="codex-card" onclick="openCodexDetail(${entry.id})">
                            <div style="display: flex; justify-content: space-between; align-items: start;">
                                <div style="flex: 1;">
                                    <div style="font-size: 1rem; font-weight: 600; margin-bottom: 0.5rem;">${entry.title}</div>
                                    ${entry.summary ? `<div style="font-size: 0.85rem; color: var(--text-secondary); line-height: 1.4;">${entry.summary}</div>` : ''}
                                </div>
                                <button class="btn btn-icon btn-small" onclick="event.stopPropagation(); deleteCodexEntry(${entry.id})" title="Supprimer">×</button>
                            </div>
                        </div>
                    `;
                });
                
                html += '</div>';
            });

            container.innerHTML = html;
        }

        function openCodexDetail(id) {
            const entry = project.codex.find(c => c.id === id);
            if (!entry) return;

            const editorView = document.getElementById('editorView');
            editorView.innerHTML = `
                <div class="detail-view">
                    <div class="detail-header">
                        <div style="display: flex; align-items: center; gap: 1rem; flex: 1;">
                            <input type="text" class="form-input" value="${entry.title}" 
                                   style="font-size: 1.8rem; font-weight: 600; font-family: 'Noto Serif JP', serif; padding: 0.5rem;"
                                   onchange="updateCodexField(${id}, 'title', this.value)"
                                   placeholder="Titre de l'entrée">
                            <span style="font-size: 0.8rem; padding: 0.4rem 0.8rem; background: var(--accent-gold); color: var(--bg-primary); border-radius: 2px;">${entry.category}</span>
                        </div>
                        <button class="btn" onclick="switchView('editor')">← Retour à l'éditeur</button>
                    </div>
                    
                    <div class="detail-section">
                        <div class="detail-section-title">Catégorie</div>
                        <select class="form-input" onchange="updateCodexField(${id}, 'category', this.value)">
                            <option value="Culture" ${entry.category === 'Culture' ? 'selected' : ''}>Culture</option>
                            <option value="Histoire" ${entry.category === 'Histoire' ? 'selected' : ''}>Histoire</option>
                            <option value="Technologie" ${entry.category === 'Technologie' ? 'selected' : ''}>Technologie</option>
                            <option value="Géographie" ${entry.category === 'Géographie' ? 'selected' : ''}>Géographie</option>
                            <option value="Politique" ${entry.category === 'Politique' ? 'selected' : ''}>Politique</option>
                            <option value="Magie/Pouvoir" ${entry.category === 'Magie/Pouvoir' ? 'selected' : ''}>Magie/Pouvoir</option>
                            <option value="Religion" ${entry.category === 'Religion' ? 'selected' : ''}>Religion</option>
                            <option value="Société" ${entry.category === 'Société' ? 'selected' : ''}>Société</option>
                            <option value="Autre" ${entry.category === 'Autre' ? 'selected' : ''}>Autre</option>
                        </select>
                    </div>

                    <div class="detail-section">
                        <div class="detail-section-title">Résumé</div>
                        <textarea class="form-input" rows="3" 
                                  onchange="updateCodexField(${id}, 'summary', this.value)">${entry.summary}</textarea>
                    </div>

                    <div class="detail-section">
                        <div class="detail-section-title">Contenu détaillé</div>
                        <textarea class="form-input" rows="20" 
                                  oninput="updateCodexField(${id}, 'content', this.value)">${entry.content}</textarea>
                    </div>
                </div>
            `;
        }

        function updateCodexField(id, field, value) {
            const entry = project.codex.find(c => c.id === id);
            if (entry) {
                entry[field] = value;
                saveProject();
                renderCodexList();
            }
        }

        // References and Links Management
        function showReferencesForCharacter(characterId) {
            const character = project.characters.find(c => c.id === characterId);
            if (!character) return;

            const scenes = findScenesWithCharacter(characterId);
            const relatedElements = character.linkedElements || [];

            document.getElementById('referencesModalTitle').textContent = `Références : ${character.name}`;
            document.getElementById('referencesModalContent').innerHTML = `
                <div class="references-section">
                    <div class="references-title">📝 Scènes où ${character.name} apparaît (${scenes.length})</div>
                    ${scenes.length > 0 ? scenes.map(scene => `
                        <div class="reference-item" onclick="openScene(${scene.actId}, ${scene.chapterId}, ${scene.sceneId}); closeModal('referencesModal');">
                            <div>
                                <div style="font-weight: 600;">${scene.sceneTitle}</div>
                                <div style="font-size: 0.8rem; color: var(--text-muted);">${scene.actTitle} > ${scene.chapterTitle}</div>
                            </div>
                            <span>→</span>
                        </div>
                    `).join('') : '<div style="padding: 1rem; color: var(--text-muted);">Aucune scène liée</div>'}
                </div>

                <div class="references-section">
                    <div class="references-title">🔗 Gérer les liens</div>
                    <button class="btn btn-small" onclick="openLinkManagerForCharacter(${characterId})">+ Lier à des scènes</button>
                </div>
            `;

            document.getElementById('referencesModal').classList.add('active');
        }

        function findScenesWithCharacter(characterId) {
            const scenes = [];
            project.acts.forEach(act => {
                act.chapters.forEach(chapter => {
                    chapter.scenes.forEach(scene => {
                        if (scene.linkedCharacters && scene.linkedCharacters.includes(characterId)) {
                            scenes.push({
                                actId: act.id,
                                actTitle: act.title,
                                chapterId: chapter.id,
                                chapterTitle: chapter.title,
                                sceneId: scene.id,
                                sceneTitle: scene.title
                            });
                        }
                    });
                });
            });
            return scenes;
        }

        function findScenesWithElement(elementId) {
            const scenes = [];
            project.acts.forEach(act => {
                act.chapters.forEach(chapter => {
                    chapter.scenes.forEach(scene => {
                        if (scene.linkedElements && scene.linkedElements.includes(elementId)) {
                            scenes.push({
                                actId: act.id,
                                actTitle: act.title,
                                chapterId: chapter.id,
                                chapterTitle: chapter.title,
                                sceneId: scene.id,
                                sceneTitle: scene.title
                            });
                        }
                    });
                });
            });
            return scenes;
        }

        function showReferencesForElement(elementId) {
            const element = project.world.find(e => e.id === elementId);
            if (!element) return;

            const scenes = findScenesWithElement(elementId);

            document.getElementById('referencesModalTitle').textContent = `Références : ${element.name}`;
            document.getElementById('referencesModalContent').innerHTML = `
                <div class="references-section">
                    <div class="references-title">📝 Scènes où ${element.name} apparaît (${scenes.length})</div>
                    ${scenes.length > 0 ? scenes.map(scene => `
                        <div class="reference-item" onclick="openScene(${scene.actId}, ${scene.chapterId}, ${scene.sceneId}); closeModal('referencesModal');">
                            <div>
                                <div style="font-weight: 600;">${scene.sceneTitle}</div>
                                <div style="font-size: 0.8rem; color: var(--text-muted);">${scene.actTitle} > ${scene.chapterTitle}</div>
                            </div>
                            <span>→</span>
                        </div>
                    `).join('') : '<div style="padding: 1rem; color: var(--text-muted);">Aucune scène liée</div>'}
                </div>

                <div class="references-section">
                    <div class="references-title">🔗 Gérer les liens</div>
                    <button class="btn btn-small" onclick="openLinkManagerForElement(${elementId})">+ Lier à des scènes</button>
                </div>
            `;

            document.getElementById('referencesModal').classList.add('active');
        }

        function toggleCharacterInScene(sceneActId, sceneChapterId, sceneId, characterId) {
            const act = project.acts.find(a => a.id === sceneActId);
            const chapter = act.chapters.find(c => c.id === sceneChapterId);
            const scene = chapter.scenes.find(s => s.id === sceneId);

            if (!scene.linkedCharacters) scene.linkedCharacters = [];

            const index = scene.linkedCharacters.indexOf(characterId);
            if (index > -1) {
                scene.linkedCharacters.splice(index, 1);
            } else {
                scene.linkedCharacters.push(characterId);
            }

            saveProject();
            
            // Rafraîchir le panneau de liens dans l'éditeur si la scène est ouverte
            if (currentSceneId === sceneId && currentActId === sceneActId && currentChapterId === sceneChapterId) {
                const linksPanel = document.getElementById('linksPanel');
                if (linksPanel) {
                    // Trouver le premier div flex (celui des personnages)
                    const flexDivs = linksPanel.querySelectorAll('[style*="flex: 1"]');
                    if (flexDivs.length >= 1) {
                        const charDiv = flexDivs[0];
                        const quickLinks = charDiv.querySelector('.quick-links');
                        if (quickLinks) {
                            quickLinks.innerHTML = `
                                ${renderSceneCharacters(sceneActId, sceneChapterId, scene)}
                                <button class="btn btn-small" onclick="openCharacterLinker(${sceneActId}, ${sceneChapterId}, ${sceneId})" style="font-size: 0.75rem; padding: 0.3rem 0.6rem;">+ Lier</button>
                            `;
                        }
                    }
                }
            }
        }

        function toggleElementInScene(sceneActId, sceneChapterId, sceneId, elementId) {
            const act = project.acts.find(a => a.id === sceneActId);
            const chapter = act.chapters.find(c => c.id === sceneChapterId);
            const scene = chapter.scenes.find(s => s.id === sceneId);

            if (!scene.linkedElements) scene.linkedElements = [];

            const index = scene.linkedElements.indexOf(elementId);
            if (index > -1) {
                scene.linkedElements.splice(index, 1);
            } else {
                scene.linkedElements.push(elementId);
            }

            saveProject();
            
            // Rafraîchir le panneau de liens dans l'éditeur si la scène est ouverte
            if (currentSceneId === sceneId && currentActId === sceneActId && currentChapterId === sceneChapterId) {
                const linksPanel = document.getElementById('linksPanel');
                if (linksPanel) {
                    // Trouver le deuxième div flex (celui des lieux)
                    const flexDivs = linksPanel.querySelectorAll('[style*="flex: 1"]');
                    if (flexDivs.length >= 2) {
                        const locationDiv = flexDivs[1];
                        const quickLinks = locationDiv.querySelector('.quick-links');
                        if (quickLinks) {
                            quickLinks.innerHTML = `
                                ${renderSceneElements(sceneActId, sceneChapterId, scene)}
                                <button class="btn btn-small" onclick="openElementLinker(${sceneActId}, ${sceneChapterId}, ${sceneId})" style="font-size: 0.75rem; padding: 0.3rem 0.6rem;">+ Lier</button>
                            `;
                        }
                    }
                }
            }
        }

        // Global Search
        let searchTimeout = null;

        function performGlobalSearch(query) {
            clearTimeout(searchTimeout);
            
            const resultsContainer = document.getElementById('searchResults');
            
            if (!query || query.trim().length < 2) {
                resultsContainer.classList.remove('active');
                return;
            }

            // Debounce search
            searchTimeout = setTimeout(() => {
                const results = searchEverywhere(query.trim());
                displaySearchResults(results, query.trim());
            }, 300);
        }

        function searchEverywhere(query) {
            const results = [];
            const lowerQuery = query.toLowerCase();

            // Search in scenes
            project.acts.forEach(act => {
                act.chapters.forEach(chapter => {
                    chapter.scenes.forEach(scene => {
                        const temp = document.createElement('div');
                        temp.innerHTML = scene.content;
                        const textContent = temp.textContent || temp.innerText || '';
                        
                        if (scene.title.toLowerCase().includes(lowerQuery) || 
                            textContent.toLowerCase().includes(lowerQuery)) {
                            
                            const matchIndex = textContent.toLowerCase().indexOf(lowerQuery);
                            const preview = matchIndex >= 0 
                                ? getPreview(textContent, matchIndex, query.length)
                                : textContent.substring(0, 150);

                            results.push({
                                type: 'Scène',
                                title: scene.title,
                                path: `${act.title} > ${chapter.title}`,
                                preview: preview,
                                action: () => openScene(act.id, chapter.id, scene.id)
                            });
                        }
                    });
                });
            });

            // Search in characters
            project.characters.forEach(char => {
                const searchText = `${char.name} ${char.role} ${char.description} ${char.personality} ${char.background}`.toLowerCase();
                if (searchText.includes(lowerQuery)) {
                    results.push({
                        type: 'Personnage',
                        title: char.name,
                        path: char.role || 'Personnage',
                        preview: char.description || 'Aucune description',
                        action: () => { switchView('characters'); openCharacterDetail(char.id); }
                    });
                }
            });

            // Search in world elements
            project.world.forEach(element => {
                const searchText = `${element.name} ${element.description} ${element.details}`.toLowerCase();
                if (searchText.includes(lowerQuery)) {
                    results.push({
                        type: 'Univers',
                        title: element.name,
                        path: element.type,
                        preview: element.description || 'Aucune description',
                        action: () => { switchView('world'); openWorldDetail(element.id); }
                    });
                }
            });

            // Search in timeline
            project.timeline.forEach(event => {
                const searchText = `${event.title} ${event.description} ${event.location} ${event.characters}`.toLowerCase();
                if (searchText.includes(lowerQuery)) {
                    results.push({
                        type: 'Chronologie',
                        title: event.title,
                        path: event.date || 'Événement',
                        preview: event.description || 'Aucune description',
                        action: () => { switchView('timeline'); openTimelineDetail(event.id); }
                    });
                }
            });

            // Search in notes
            project.notes.forEach(note => {
                const searchText = `${note.title} ${note.content}`.toLowerCase();
                if (searchText.includes(lowerQuery)) {
                    const matchIndex = note.content.toLowerCase().indexOf(lowerQuery);
                    const preview = matchIndex >= 0 
                        ? getPreview(note.content, matchIndex, query.length)
                        : note.content.substring(0, 150);

                    results.push({
                        type: 'Note',
                        title: note.title,
                        path: note.category,
                        preview: preview,
                        action: () => { switchView('notes'); openNoteDetail(note.id); }
                    });
                }
            });

            // Search in codex
            project.codex.forEach(entry => {
                const searchText = `${entry.title} ${entry.summary} ${entry.content}`.toLowerCase();
                if (searchText.includes(lowerQuery)) {
                    const matchIndex = entry.content.toLowerCase().indexOf(lowerQuery);
                    const preview = matchIndex >= 0 
                        ? getPreview(entry.content, matchIndex, query.length)
                        : entry.summary || entry.content.substring(0, 150);

                    results.push({
                        type: 'Codex',
                        title: entry.title,
                        path: entry.category,
                        preview: preview,
                        action: () => { switchView('codex'); openCodexDetail(entry.id); }
                    });
                }
            });

            return results;
        }

        function getPreview(text, matchIndex, queryLength) {
            const start = Math.max(0, matchIndex - 60);
            const end = Math.min(text.length, matchIndex + queryLength + 90);
            let preview = text.substring(start, end);
            
            if (start > 0) preview = '...' + preview;
            if (end < text.length) preview = preview + '...';
            
            return preview;
        }

        function displaySearchResults(results, query) {
            const container = document.getElementById('searchResults');
            
            if (results.length === 0) {
                container.innerHTML = '<div class="search-no-results">Aucun résultat trouvé</div>';
                container.classList.add('active');
                return;
            }

            const highlightQuery = (text) => {
                const regex = new RegExp(`(${query})`, 'gi');
                return text.replace(regex, '<span class="search-highlight">$1</span>');
            };

            container.innerHTML = results.map((result, index) => `
                <div class="search-result-item" onclick="executeSearchAction(${index}); closeSearchResults();">
                    <div class="search-result-type">${result.type}</div>
                    <div class="search-result-title">${highlightQuery(result.title)}</div>
                    <div class="search-result-path">${result.path}</div>
                    <div class="search-result-preview">${highlightQuery(result.preview)}</div>
                </div>
            `).join('');

            // Store actions for execution
            window.searchResultActions = results.map(r => r.action);

            container.classList.add('active');
        }

        function executeSearchAction(index) {
            if (window.searchResultActions && window.searchResultActions[index]) {
                window.searchResultActions[index]();
            }
        }

        function closeSearchResults() {
            document.getElementById('searchResults').classList.remove('active');
            document.getElementById('globalSearch').value = '';
        }

        // Close search results when clicking outside
        document.addEventListener('click', (e) => {
            const searchContainer = document.querySelector('.search-container');
            if (searchContainer && !searchContainer.contains(e.target)) {
                closeSearchResults();
            }
        });

        // Focus Mode Management
        let focusModeActive = false;
        let focusPanelOpen = false;
        let focusStartWordCount = 0;

        function toggleFocusMode() {
            console.log('toggleFocusMode called, current state:', focusModeActive);
            
            focusModeActive = !focusModeActive;
            const appContainer = document.querySelector('.app-container');
            const focusBtn = document.querySelector('.focus-toggle-btn');
            
            console.log('App container found:', !!appContainer);
            console.log('Focus button found:', !!focusBtn);
            
            if (focusModeActive) {
                console.log('ACTIVATING FOCUS MODE');
                appContainer.classList.add('focus-mode');
                
                // Force button display
                if (focusBtn) {
                    focusBtn.style.display = 'block';
                    console.log('Focus button display set to block');
                }
                
                // Track starting word count
                if (currentSceneId) {
                    const act = project.acts.find(a => a.id === currentActId);
                    const chapter = act.chapters.find(c => c.id === currentChapterId);
                    const scene = chapter.scenes.find(s => s.id === currentSceneId);
                    focusStartWordCount = getWordCount(scene.content);
                }
                
                // Request fullscreen (optional, may require user gesture)
                if (document.documentElement.requestFullscreen) {
                    document.documentElement.requestFullscreen().catch((err) => {
                        console.log('Fullscreen not available or denied:', err);
                    });
                }
                
                // Verify class was added
                setTimeout(() => {
                    const hasClass = appContainer.classList.contains('focus-mode');
                    console.log('Focus mode class added:', hasClass);
                    console.log('Button display:', focusBtn ? focusBtn.style.display : 'button not found');
                }, 100);
            } else {
                console.log('DEACTIVATING FOCUS MODE');
                appContainer.classList.remove('focus-mode');
                
                // Hide button
                if (focusBtn) {
                    focusBtn.style.display = 'none';
                }
                
                // Exit fullscreen
                if (document.exitFullscreen && document.fullscreenElement) {
                    document.exitFullscreen();
                }
                focusPanelOpen = false;
                document.getElementById('focusPanel').classList.remove('active');
            }
        }

        function toggleFocusPanel() {
            focusPanelOpen = !focusPanelOpen;
            const panel = document.getElementById('focusPanel');
            
            if (focusPanelOpen) {
                panel.classList.add('active');
                console.log('Focus panel opened');
            } else {
                panel.classList.remove('active');
                console.log('Focus panel closed');
            }
        }

        function toggleToolbar() {
            const toolbar = document.getElementById('editorToolbar');
            if (toolbar) {
                toolbar.style.display = document.getElementById('hideToolbar').checked ? 'none' : 'flex';
            }
        }

        function toggleLinksPanel() {
            const linksPanel = document.getElementById('linksPanel');
            if (linksPanel) {
                linksPanel.style.display = document.getElementById('hideLinksPanel').checked ? 'none' : 'block';
            }
        }

        function updateFocusStats() {
            if (!focusModeActive || !currentSceneId) return;
            
            const act = project.acts.find(a => a.id === currentActId);
            const chapter = act.chapters.find(c => c.id === currentChapterId);
            const scene = chapter.scenes.find(s => s.id === currentSceneId);
            
            const currentWordCount = getWordCount(scene.content);
            const wordsWritten = Math.max(0, currentWordCount - focusStartWordCount);
            
            document.getElementById('focusWordCount').textContent = wordsWritten;
        }

        // Pomodoro Timer
        let pomodoroTime = 25 * 60; // 25 minutes in seconds
        let pomodoroInterval = null;
        let pomodoroRunning = false;
        let pomodorosCompleted = 0;

        function startPomodoro() {
            if (pomodoroRunning) return;
            
            pomodoroRunning = true;
            pomodoroInterval = setInterval(() => {
                if (pomodoroTime > 0) {
                    pomodoroTime--;
                    updatePomodoroDisplay();
                } else {
                    // Pomodoro completed
                    completedPomodoro();
                }
            }, 1000);
        }

        function pausePomodoro() {
            pomodoroRunning = false;
            if (pomodoroInterval) {
                clearInterval(pomodoroInterval);
                pomodoroInterval = null;
            }
        }

        function resetPomodoro() {
            pausePomodoro();
            pomodoroTime = 25 * 60;
            updatePomodoroDisplay();
        }

        function completedPomodoro() {
            pausePomodoro();
            pomodorosCompleted++;
            document.getElementById('pomodorosCompleted').textContent = pomodorosCompleted;
            
            // Play notification sound (simple beep)
            playNotificationSound();
            
            // Alert user
            alert('🎉 Pomodoro terminé ! Temps de faire une pause de 5 minutes.');
            
            // Reset for next session
            pomodoroTime = 25 * 60;
            updatePomodoroDisplay();
        }

        function updatePomodoroDisplay() {
            const minutes = Math.floor(pomodoroTime / 60);
            const seconds = pomodoroTime % 60;
            document.getElementById('pomodoroDisplay').textContent = 
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        function playNotificationSound() {
            // Create a simple beep sound using Web Audio API
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.value = 800;
            oscillator.type = 'sine';
            
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.5);
        }

        // Update focus stats on content change
        const originalUpdateSceneContent = updateSceneContent;
        updateSceneContent = function() {
            originalUpdateSceneContent();
            updateFocusStats();
        };

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeModal('addChapterModal');
                closeModal('addSceneModal');
                closeModal('addActModal');
                closeModal('addCharacterModal');
                closeModal('addWorldModal');
                closeModal('addTimelineModal');
                closeModal('addNoteModal');
                closeModal('addCodexModal');
                closeModal('backupModal');
                closeModal('referencesModal');
                closeModal('projectsModal');
                closeModal('newProjectModal');
                closeSearchResults();
                
                // Close focus panel if open
                if (focusPanelOpen) {
                    toggleFocusPanel();
                }
            }
            if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
                e.preventDefault();
                document.getElementById('globalSearch').focus();
            }
            if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                e.preventDefault();
                saveProject();
            }
            if (e.key === 'F11') {
                e.preventDefault();
                toggleFocusMode();
            }
            // Raccourci pour le mode révision (Ctrl+R)
            if ((e.ctrlKey || e.metaKey) && e.key === 'r') {
                e.preventDefault();
                if (currentSceneId) {
                    toggleRevisionMode();
                }
            }
        });


        // ============================================
        // REVISION MODE FUNCTIONS
        // ============================================

        function toggleRevisionMode() {
            // Vérifier qu'une scène est ouverte
            if (!currentSceneId) {
                alert('Veuillez d\'abord ouvrir une scène pour activer le mode révision.');
                return;
            }
            
            revisionMode = !revisionMode;
            let toolbar = document.getElementById('editorToolbar');
            if (!toolbar) {
                toolbar = document.querySelector('.editor-toolbar, .revision-toolbar');
            }
            if (!toolbar) {
                console.error('Toolbar not found!');
                alert('Erreur: Barre d\'outils introuvable. Rechargez la page.');
                return;
            }
            const editor = document.querySelector('.editor-textarea');
            const panel = document.getElementById('annotationsPanel');

            if (revisionMode) {
                // Activer le mode révision
                toolbar.className = 'revision-toolbar';
                toolbar.innerHTML = `
                    <span class="revision-badge">✏️ MODE RÉVISION</span>
                    <button class="highlight-btn yellow ${selectedHighlightColor === 'yellow' ? 'active' : ''}" 
                            onclick="selectHighlightColor('yellow')">Jaune</button>
                    <button class="highlight-btn green ${selectedHighlightColor === 'green' ? 'active' : ''}" 
                            onclick="selectHighlightColor('green')">Vert</button>
                    <button class="highlight-btn blue ${selectedHighlightColor === 'blue' ? 'active' : ''}" 
                            onclick="selectHighlightColor('blue')">Bleu</button>
                    <button class="highlight-btn red ${selectedHighlightColor === 'red' ? 'active' : ''}" 
                            onclick="selectHighlightColor('red')">Rouge</button>
                    <button class="highlight-btn purple ${selectedHighlightColor === 'purple' ? 'active' : ''}" 
                            onclick="selectHighlightColor('purple')">Violet</button>
                    <button class="btn" onclick="applyHighlight()">🖍️ Surligner</button>
                    <button class="btn" onclick="removeHighlight()">🗑️ Retirer</button>
                    <button class="btn" onclick="openAnnotationPopup()">💬 Annoter</button>
                    <button class="btn" onclick="toggleAnnotationsPanel()" title="Afficher/Masquer les annotations">📋 Annotations</button>
                    <div style="flex: 1;"></div>
                    <button class="btn btn-primary" onclick="toggleRevisionMode()">✓ Quitter</button>
                `;
                if (editor) editor.contentEditable = 'false';
                // Ne pas afficher automatiquement le panneau
                // L'utilisateur cliquera sur "Voir annotations" s'il le souhaite
            } else {
                // Désactiver le mode révision
                toolbar.className = 'editor-toolbar';
                toolbar.innerHTML = `
                    <!-- Basic formatting -->
                    <div class="toolbar-group">
                        <button class="toolbar-btn" data-format="bold" onclick="formatText('bold')" title="Gras (Ctrl+B)">
                            <strong>B</strong>
                        </button>
                        <button class="toolbar-btn" data-format="italic" onclick="formatText('italic')" title="Italique (Ctrl+I)">
                            <em>I</em>
                        </button>
                        <button class="toolbar-btn" data-format="underline" onclick="formatText('underline')" title="Souligné (Ctrl+U)">
                            <u>U</u>
                        </button>
                        <button class="toolbar-btn" data-format="strikethrough" onclick="formatText('strikeThrough')" title="Barré">
                            <s>S</s>
                        </button>
                    </div>
                    
                    <!-- Font family and size -->
                    <div class="toolbar-group">
                        <select class="font-family-selector" onchange="formatText('fontName', this.value)" title="Police de caractères">
                            <option value="Crimson Pro">Crimson Pro</option>
                            <option value="Arial">Arial</option>
                            <option value="Georgia">Georgia</option>
                            <option value="Times New Roman">Times New Roman</option>
                            <option value="Courier New">Courier New</option>
                            <option value="Verdana">Verdana</option>
                            <option value="Garamond">Garamond</option>
                            <option value="Palatino">Palatino</option>
                        </select>
                        <select class="font-size-selector" onchange="formatText('fontSize', this.value)" title="Taille de police">
                            <option value="1">Très petit</option>
                            <option value="2">Petit</option>
                            <option value="3" selected>Normal</option>
                            <option value="4">Grand</option>
                            <option value="5">Très grand</option>
                            <option value="6">Énorme</option>
                            <option value="7">Gigantesque</option>
                        </select>
                    </div>
                    
                    <!-- Text color -->
                    <div class="toolbar-group">
                        <div class="color-picker-wrapper">
                            <button class="toolbar-btn" onclick="toggleColorPicker('text')" title="Couleur du texte">
                                <span style="border-bottom: 3px solid currentColor;">A</span>
                            </button>
                            <div class="color-picker-dropdown" id="textColorPicker">
                                <div class="color-grid" id="textColorGrid"></div>
                                <div class="color-input-wrapper">
                                    <input type="color" id="textColorInput" onchange="applyTextColor(this.value)">
                                    <input type="text" id="textColorHex" placeholder="#000000" maxlength="7" onchange="applyTextColor(this.value)">
                                </div>
                            </div>
                        </div>
                        <div class="color-picker-wrapper">
                            <button class="toolbar-btn" onclick="toggleColorPicker('background')" title="Couleur de fond">
                                <span style="background: yellow; padding: 0 4px;">A</span>
                            </button>
                            <div class="color-picker-dropdown" id="backgroundColorPicker">
                                <div class="color-grid" id="backgroundColorGrid"></div>
                                <div class="color-input-wrapper">
                                    <input type="color" id="bgColorInput" onchange="applyBackgroundColor(this.value)">
                                    <input type="text" id="bgColorHex" placeholder="#FFFF00" maxlength="7" onchange="applyBackgroundColor(this.value)">
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Alignment -->
                    <div class="toolbar-group">
                        <button class="toolbar-btn" onclick="formatText('justifyLeft')" title="Aligner à gauche">
                            ⫷
                        </button>
                        <button class="toolbar-btn" onclick="formatText('justifyCenter')" title="Centrer">
                            ⫶
                        </button>
                        <button class="toolbar-btn" onclick="formatText('justifyRight')" title="Aligner à droite">
                            ⫸
                        </button>
                        <button class="toolbar-btn" onclick="formatText('justifyFull')" title="Justifier">
                            ☰
                        </button>
                    </div>
                    
                    <!-- Headings -->
                    <div class="toolbar-group">
                        <button class="toolbar-btn" onclick="formatText('formatBlock', 'h1')" title="Titre 1">H1</button>
                        <button class="toolbar-btn" onclick="formatText('formatBlock', 'h2')" title="Titre 2">H2</button>
                        <button class="toolbar-btn" onclick="formatText('formatBlock', 'h3')" title="Titre 3">H3</button>
                        <button class="toolbar-btn" onclick="formatText('formatBlock', 'p')" title="Paragraphe">P</button>
                    </div>
                    
                    <!-- Lists and quotes -->
                    <div class="toolbar-group">
                        <button class="toolbar-btn" onclick="formatText('insertUnorderedList')" title="Liste à puces">• Liste</button>
                        <button class="toolbar-btn" onclick="formatText('insertOrderedList')" title="Liste numérotée">1. Liste</button>
                        <button class="toolbar-btn" onclick="formatText('formatBlock', 'blockquote')" title="Citation">❝ Citation</button>
                    </div>
                    
                    <!-- Indentation -->
                    <div class="toolbar-group">
                        <button class="toolbar-btn" onclick="formatText('indent')" title="Augmenter l'indentation">→|</button>
                        <button class="toolbar-btn" onclick="formatText('outdent')" title="Diminuer l'indentation">|←</button>
                    </div>
                    
                    <!-- Superscript, subscript -->
                    <div class="toolbar-group">
                        <button class="toolbar-btn" onclick="formatText('superscript')" title="Exposant">x²</button>
                        <button class="toolbar-btn" onclick="formatText('subscript')" title="Indice">x₂</button>
                    </div>
                    
                    <!-- Other -->
                    <div class="toolbar-group">
                        <button class="toolbar-btn" onclick="formatText('insertHorizontalRule')" title="Ligne horizontale">─</button>
                        <button class="toolbar-btn" onclick="formatText('removeFormat')" title="Supprimer le formatage">✕ Format</button>
                    </div>
                    
                    <!-- Revision mode button -->
                    <div class="toolbar-group">
                        <button class="toolbar-btn" onclick="toggleRevisionMode()" title="Mode Révision (Ctrl+R)"><strong>✏️ RÉVISION</strong></button>
                    </div>
                `;
                if (editor) editor.contentEditable = 'true';
                if (panel) panel.classList.remove('visible');
                
                // Réinitialiser les color pickers après reconstruction de la toolbar
                initializeColorPickers();
            }
        }

        function selectHighlightColor(color) {
            selectedHighlightColor = color;
            document.querySelectorAll('.highlight-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`.highlight-btn.${color}`).classList.add('active');
        }

        function applyHighlight() {
            const sel = window.getSelection();
            if (!sel.rangeCount || sel.isCollapsed) {
                alert('Sélectionnez du texte à surligner');
                return;
            }

            const range = sel.getRangeAt(0);
            const span = document.createElement('span');
            span.className = `highlight-${selectedHighlightColor}`;
            
            try {
                range.surroundContents(span);
                updateSceneContent();
            } catch (e) {
                alert('Impossible de surligner cette sélection (essayez une sélection plus simple)');
            }
            
            sel.removeAllRanges();
        }

        function removeHighlight() {
            const sel = window.getSelection();
            if (!sel.rangeCount) {
                alert('Sélectionnez un texte surligné à retirer');
                return;
            }

            const range = sel.getRangeAt(0);
            let node = range.commonAncestorContainer;
            
            if (node.nodeType === 3) {
                node = node.parentElement;
            }

            if (node.className && node.className.includes('highlight-')) {
                const parent = node.parentNode;
                while (node.firstChild) {
                    parent.insertBefore(node.firstChild, node);
                }
                parent.removeChild(node);
                updateSceneContent();
            } else {
                alert('Sélectionnez un texte surligné');
            }

            sel.removeAllRanges();
        }

        function openAnnotationPopup() {
            const sel = window.getSelection();
            if (!sel.rangeCount || sel.isCollapsed) {
                alert('Sélectionnez du texte à annoter');
                return;
            }

            currentSelection = {
                text: sel.toString(),
                range: sel.getRangeAt(0).cloneRange()
            };

            document.getElementById('annotationPopup').classList.add('visible');
            document.getElementById('annotationText').value = '';
            document.getElementById('annotationText').focus();
        }

        function closeAnnotationPopup() {
            document.getElementById('annotationPopup').classList.remove('visible');
            currentSelection = null;
        }

        function selectAnnotationType(type) {
            selectedAnnotationType = type;
            document.querySelectorAll('.annotation-type-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`.annotation-type-btn.${type}`).classList.add('active');
        }

        function saveAnnotation() {
            const text = document.getElementById('annotationText').value.trim();
            if (!text) {
                alert('Veuillez entrer une annotation');
                return;
            }

            const act = project.acts.find(a => a.id === currentActId);
            const chapter = act.chapters.find(c => c.id === currentChapterId);
            const scene = chapter.scenes.find(s => s.id === currentSceneId);

            if (!scene.annotations) {
                scene.annotations = [];
            }

            scene.annotations.push({
                id: Date.now(),
                type: selectedAnnotationType,
                text: text,
                context: currentSelection ? currentSelection.text : '',
                completed: false,
                createdAt: new Date().toISOString()
            });

            saveProject();
            closeAnnotationPopup();
            renderAnnotationsPanel();
            renderActsList();
        }

        function renderAnnotationsPanel() {
            const panel = document.getElementById('annotationsPanelContent');
            const act = project.acts.find(a => a.id === currentActId);
            const chapter = act.chapters.find(c => c.id === currentChapterId);
            const scene = chapter.scenes.find(s => s.id === currentSceneId);

            if (!scene.annotations || scene.annotations.length === 0) {
                panel.innerHTML = `
                    <div class="annotations-panel-header">
                        <h3 style="margin: 0;">Annotations (0)</h3>
                        <span class="annotations-panel-close" onclick="closeAnnotationsPanel()" title="Fermer">×</span>
                    </div>
                    <p style="text-align: center; color: var(--text-muted); padding: 2rem;">Aucune annotation</p>
                `;
            } else {
                panel.innerHTML = `
                    <div class="annotations-panel-header">
                        <h3 style="margin: 0;">Annotations (${scene.annotations.length})</h3>
                        <span class="annotations-panel-close" onclick="closeAnnotationsPanel()" title="Fermer">×</span>
                    </div>
                    ${scene.annotations.map(a => `
                        <div class="annotation-card ${a.type}" onclick="scrollToAnnotation(${a.id})">
                            <div class="annotation-type ${a.type}">${getAnnotationTypeLabel(a.type)}</div>
                            <div class="annotation-content">${a.text}</div>
                            ${a.context ? `<div class="annotation-context">"${a.context}"</div>` : ''}
                            ${a.type === 'todo' ? `
                                <button class="btn btn-small ${a.completed ? 'btn-primary' : ''}" 
                                        onclick="event.stopPropagation(); toggleAnnotationComplete(${a.id})" 
                                        style="margin-top: 0.5rem;">
                                    ${a.completed ? '✓ Terminé' : '○ À faire'}
                                </button>
                            ` : ''}
                            <button class="btn btn-small" onclick="event.stopPropagation(); deleteAnnotation(${a.id})" 
                                    style="margin-top: 0.5rem;">🗑️ Supprimer</button>
                        </div>
                    `).join('')}
                `;
            }

            // Afficher le panneau parent
            const parentPanel = document.getElementById('annotationsPanel');
            if (parentPanel && !parentPanel.classList.contains('visible')) {
                parentPanel.classList.add('visible');
            }
        }



        function toggleAnnotationsPanel() {
            const panel = document.getElementById('annotationsPanel');
            if (panel.classList.contains('visible')) {
                panel.classList.remove('visible');
            } else {
                renderAnnotationsPanel();
            }
        }

        function closeAnnotationsPanel() {
            const panel = document.getElementById('annotationsPanel');
            if (panel) {
                panel.classList.remove('visible');
            }
        }

        function getAnnotationTypeLabel(type) {
            const labels = {
                comment: '💬 Commentaire',
                todo: '✓ TODO',
                note: '📝 Note',
                question: '? Question'
            };
            return labels[type] || type;
        }

        function toggleAnnotationComplete(annotationId) {
            const act = project.acts.find(a => a.id === currentActId);
            const chapter = act.chapters.find(c => c.id === currentChapterId);
            const scene = chapter.scenes.find(s => s.id === currentSceneId);
            const annotation = scene.annotations.find(a => a.id === annotationId);

            if (annotation) {
                annotation.completed = !annotation.completed;
                saveProject();
                renderAnnotationsPanel();
                renderActsList();
            }
        }

        function deleteAnnotation(annotationId) {
            if (!confirm('Supprimer cette annotation ?')) return;

            const act = project.acts.find(a => a.id === currentActId);
            const chapter = act.chapters.find(c => c.id === currentChapterId);
            const scene = chapter.scenes.find(s => s.id === currentSceneId);

            scene.annotations = scene.annotations.filter(a => a.id !== annotationId);
            saveProject();
            renderAnnotationsPanel();
            renderActsList();
        }

        function scrollToAnnotation(annotationId) {
            // Simple: juste fermer le panel pour voir le texte
            // Une implémentation plus avancée pourrait scroller au texte exact
        }

        function getSceneAnnotationCount(scene) {
            return scene.annotations ? scene.annotations.length : 0;
        }

        function getSceneTodoCount(scene) {
            if (!scene.annotations) return 0;
            return scene.annotations.filter(a => a.type === 'todo' && !a.completed).length;
        }

        // Modifier la fonction renderEditor pour ajouter le bouton révision
        const originalRenderEditor = renderEditor;
        renderEditor = function(act, chapter, scene) {
            originalRenderEditor(act, chapter, scene);
            
            // Ajouter le bouton révision dans la toolbar si pas déjà en mode révision
            if (!revisionMode) {
                const toolbar = document.getElementById('editorToolbar');
                if (toolbar && !toolbar.querySelector('[onclick*="toggleRevisionMode"]')) {
                    const revisionGroup = document.createElement('div');
                    revisionGroup.className = 'toolbar-group';
                    revisionGroup.innerHTML = '<button class="toolbar-btn" onclick="toggleRevisionMode()" title="Mode Révision (Ctrl+R)"><strong>✏️ RÉVISION</strong></button>';
                    try {
                        toolbar.appendChild(revisionGroup);
                    } catch(e) {
                        console.error('Erreur appendChild toolbar:', e);
                    }
                }
            }
        };

        // Modifier renderActsList pour afficher les badges d'annotations
        const originalRenderActsList = renderActsList;
        renderActsList = function() {
            originalRenderActsList();
            
            // Ajouter les badges d'annotations aux scènes
            project.acts.forEach(act => {
                act.chapters.forEach(chapter => {
                    chapter.scenes.forEach(scene => {
                        const sceneElement = document.querySelector(`[data-scene-id="${scene.id}"]`);
                        if (sceneElement && scene.annotations && scene.annotations.length > 0) {
                            const annotCount = scene.annotations.length;
                            const todoCount = scene.annotations.filter(a => a.type === 'todo' && !a.completed).length;
                            
                            let badgeHTML = `<span class="scene-badge">${annotCount}</span>`;
                            if (todoCount > 0) {
                                badgeHTML += `<span class="scene-badge" style="background: var(--accent-red);">✓${todoCount}</span>`;
                            }
                            
                            const textSpan = sceneElement.querySelector('div > span:not(.drag-handle)');
                            if (textSpan && !textSpan.querySelector('.scene-badge')) {
                                textSpan.innerHTML += badgeHTML;
                            }
                        }
                    });
                });
            });
        };

        // Initialiser les annotations dans les scènes existantes
        function ensureAnnotationsStructure() {
            project.acts.forEach(act => {
                act.chapters.forEach(chapter => {
                    chapter.scenes.forEach(scene => {
                        if (!scene.annotations) {
                            scene.annotations = [];
                        }
                    });
                });
            });
        }

        // Appeler au chargement
        const originalInit = init;
        init = function() {
            originalInit();
            ensureAnnotationsStructure();
        };

        // ============================================
        // TODO LIST VIEW
        // ============================================



        function renderTodosList() {
            // Afficher dans editorView au lieu de la sidebar
            const editorView = document.getElementById('editorView');
            if (!editorView) {
                console.error('editorView not found');
                return;
            }
            
            // Collecter tous les TODOs
            const todos = [];
            project.acts.forEach(act => {
                act.chapters.forEach(chapter => {
                    chapter.scenes.forEach(scene => {
                        if (scene.annotations) {
                            scene.annotations.filter(a => a.type === 'todo').forEach(todo => {
                                todos.push({
                                    ...todo,
                                    actId: act.id,
                                    actTitle: act.title,
                                    chapterId: chapter.id,
                                    chapterTitle: chapter.title,
                                    sceneId: scene.id,
                                    sceneTitle: scene.title
                                });
                            });
                        }
                    });
                });
            });
            
            // Trier: non terminés d'abord
            todos.sort((a, b) => {
                if (a.completed === b.completed) return 0;
                return a.completed ? 1 : -1;
            });
            
            if (todos.length === 0) {
                editorView.innerHTML = '<div style="height: 100%; overflow-y: auto; padding: 3rem; text-align: center; color: var(--text-muted); font-size: 1.2rem;">📝 Aucun TODO<br><br><small style="font-size: 0.9rem;">Les TODOs apparaissent lorsque vous utilisez le mode révision</small></div>';
            } else {
                editorView.innerHTML = `
                    <div style="height: 100%; overflow-y: auto; padding: 2rem 3rem;">
                        <h2 style="margin-bottom: 2rem; color: var(--accent-gold);">✓ TODOs (${todos.filter(t => !t.completed).length} actifs)</h2>
                        <div style="display: flex; flex-direction: column; gap: 1rem;">
                        ${todos.map(todo => `
                            <div class="todo-item" onclick="openSceneFromTodo(${todo.actId}, ${todo.chapterId}, ${todo.sceneId})" 
                                 style="display: flex; gap: 1rem; padding: 1rem; background: var(--bg-secondary); border-left: 3px solid ${todo.completed ? 'var(--text-muted)' : 'var(--accent-gold)'}; border-radius: 4px; cursor: pointer; transition: all 0.2s;">
                                <input type="checkbox" ${todo.completed ? 'checked' : ''} 
                                       onclick="event.stopPropagation(); toggleTodoFromList(${todo.id}, ${todo.actId}, ${todo.chapterId}, ${todo.sceneId})"
                                       style="margin-top: 0.25rem;">
                                <div style="flex: 1;">
                                    <div style="font-size: 1rem; ${todo.completed ? 'text-decoration: line-through; opacity: 0.6;' : 'font-weight: 500;'}">${todo.text}</div>
                                    <div style="font-size: 0.85rem; color: var(--text-muted); margin-top: 0.5rem;">
                                        📍 ${todo.actTitle} › ${todo.chapterTitle} › ${todo.sceneTitle}
                                    </div>
                                </div>
                            </div>
                        `).join('')}
                        </div>
                    </div>
                `;
            }
        }

        function toggleTodoFromList(todoId, actId, chapterId, sceneId) {
            const act = project.acts.find(a => a.id === actId);
            const chapter = act.chapters.find(c => c.id === chapterId);
            const scene = chapter.scenes.find(s => s.id === sceneId);
            const todo = scene.annotations.find(a => a.id === todoId);
            
            if (todo) {
                todo.completed = !todo.completed;
                saveProject();
                renderTodosList();
                renderActsList();
            }
        }

        function openSceneFromTodo(actId, chapterId, sceneId) {
            switchView('editor');
            openScene(actId, chapterId, sceneId);
        }

        // ============================================
        // FIN REVISION MODE
        // ============================================

        // Initialize on load

        // Calculer la hauteur de la toolbar pour le panneau d'annotations
        function updateAnnotationsPanelPosition() {
            const header = document.querySelector('.editor-header');
            const toolbar = document.querySelector('.editor-toolbar, .revision-toolbar');
            const linksPanel = document.getElementById('linksPanel');
            const panel = document.getElementById('annotationsPanel');
            
            if (header && toolbar && panel) {
                let totalHeight = header.offsetHeight + toolbar.offsetHeight;
                if (linksPanel && linksPanel.style.display !== 'none') {
                    totalHeight += linksPanel.offsetHeight;
                }
                panel.style.setProperty('--toolbar-height', totalHeight + 'px');
            }
        }
        
        // Appeler lors de l'ouverture du panneau
        const originalRenderAnnotationsPanel = renderAnnotationsPanel;
        renderAnnotationsPanel = function() {
            originalRenderAnnotationsPanel();
            setTimeout(updateAnnotationsPanelPosition, 50);
        };


        // ============================================
        // CORK BOARD FUNCTIONS
        // ============================================
        
        let corkBoardFilter = {
            type: 'all', // 'all', 'act', 'chapter'
            actId: null,
            chapterId: null
        };
        
        function renderCorkBoard() {
            const container = document.getElementById('corkboardList');
            
            // Construire les options de chapitres
            let chaptersOptions = '';
            if (corkBoardFilter.actId) {
                const act = project.acts.find(a => a.id === parseInt(corkBoardFilter.actId));
                if (act) {
                    chaptersOptions = act.chapters.map(ch => 
                        `<option value="${ch.id}" ${corkBoardFilter.chapterId == ch.id ? 'selected' : ''}>${ch.title}</option>`
                    ).join('');
                }
            }
            
            container.innerHTML = `
                <div style="padding: 1.5rem;">
                    <div style="margin-bottom: 1.5rem;">
                        <h3 style="margin-bottom: 0.5rem;">📋 Tableau Cork Board</h3>
                        <p style="font-size: 0.85rem; color: var(--text-muted);">
                            Organisez vos scènes visuellement
                        </p>
                    </div>
                    
                    <div style="margin-bottom: 1rem;">
                        <label style="font-size: 0.85rem; color: var(--text-muted); display: block; margin-bottom: 0.5rem;">
                            Filtrer par acte :
                        </label>
                        <select id="corkActFilter" class="form-input" onchange="updateCorkActFilter(this.value)">
                            <option value="all" ${corkBoardFilter.type === 'all' ? 'selected' : ''}>Tous les actes</option>
                            ${project.acts.map(act => 
                                `<option value="${act.id}" ${corkBoardFilter.actId == act.id ? 'selected' : ''}>${act.title}</option>`
                            ).join('')}
                        </select>
                    </div>
                    
                    ${corkBoardFilter.actId ? `
                        <div style="margin-bottom: 1rem;">
                            <label style="font-size: 0.85rem; color: var(--text-muted); display: block; margin-bottom: 0.5rem;">
                                Filtrer par chapitre :
                            </label>
                            <select id="corkChapterFilter" class="form-input" onchange="updateCorkChapterFilter(this.value)">
                                <option value="all">Tous les chapitres de cet acte</option>
                                ${chaptersOptions}
                            </select>
                        </div>
                    ` : ''}
                    
                    <button class="btn btn-primary" style="width: 100%;" onclick="openCorkBoardView()">
                        Ouvrir le tableau
                    </button>
                </div>
            `;
        }
        
        function updateCorkActFilter(actId) {
            if (actId === 'all') {
                corkBoardFilter = { type: 'all', actId: null, chapterId: null };
            } else {
                corkBoardFilter = { type: 'act', actId: parseInt(actId), chapterId: null };
            }
            renderCorkBoard();
        }
        
        function updateCorkChapterFilter(chapterId) {
            if (chapterId === 'all') {
                corkBoardFilter.type = 'act';
                corkBoardFilter.chapterId = null;
            } else {
                corkBoardFilter.type = 'chapter';
                corkBoardFilter.chapterId = parseInt(chapterId);
            }
            renderCorkBoard();
        }
        
        function filterAndRefreshCork(actId, chapterId) {
            if (actId === 'all') {
                corkBoardFilter = { type: 'all', actId: null, chapterId: null };
            } else if (chapterId === 'all' || !chapterId) {
                corkBoardFilter = { type: 'act', actId: parseInt(actId), chapterId: null };
            } else {
                corkBoardFilter = { type: 'chapter', actId: parseInt(actId), chapterId: parseInt(chapterId) };
            }
            openCorkBoardView();
        }
        

        function closeCorkBoardView() {
            switchView('corkboard');
            renderCorkBoard();
        }

        function openCorkBoardView() {
            // Ouvrir la vue Cork Board dans l'éditeur
            const editorView = document.getElementById('editorView');
            editorView.innerHTML = renderCorkBoardFullView();
            
            // Setup drag and drop
            setupCorkBoardDragAndDrop();
        }
        
        function renderCorkBoardFullView() {
            // Collecter toutes les scènes selon le filtre
            let scenes = [];
            
            if (corkBoardFilter.type === 'all') {
                project.acts.forEach(act => {
                    act.chapters.forEach(chapter => {
                        chapter.scenes.forEach(scene => {
                            scenes.push({
                                ...scene,
                                actId: act.id,
                                actTitle: act.title,
                                chapterId: chapter.id,
                                chapterTitle: chapter.title
                            });
                        });
                    });
                });
            } else if (corkBoardFilter.type === 'act') {
                const act = project.acts.find(a => a.id === corkBoardFilter.actId);
                if (act) {
                    act.chapters.forEach(chapter => {
                        chapter.scenes.forEach(scene => {
                            scenes.push({
                                ...scene,
                                actId: act.id,
                                actTitle: act.title,
                                chapterId: chapter.id,
                                chapterTitle: chapter.title
                            });
                        });
                    });
                }
            } else if (corkBoardFilter.type === 'chapter') {
                const act = project.acts.find(a => a.id === corkBoardFilter.actId);
                if (act) {
                    const chapter = act.chapters.find(c => c.id === corkBoardFilter.chapterId);
                    if (chapter) {
                        chapter.scenes.forEach(scene => {
                            scenes.push({
                                ...scene,
                                actId: act.id,
                                actTitle: act.title,
                                chapterId: chapter.id,
                                chapterTitle: chapter.title
                            });
                        });
                    }
                }
            }
            
            // Vue organisée par actes et chapitres (style NovelCrafter)
            if (scenes.length === 0) {
                return `
                    <div class="cork-board-container">
                        <div class="cork-board-header">
                            <div class="cork-board-title">📋 Cork Board</div>
                            <button class="btn" onclick="closeCorkBoardView()">← Retour</button>
                        </div>
                        <div class="cork-board-empty">
                            <div class="cork-board-empty-icon">📋</div>
                            <div style="font-size: 1.2rem; margin-bottom: 0.5rem;">Aucune scène</div>
                            <div>Créez des scènes pour les organiser visuellement</div>
                        </div>
                    </div>
                `;
            }
            
            // Vue organisée par actes et chapitres
            let html = `
                <div class="cork-board-container" style="min-height: 100vh; padding: 2rem;">
                    <div class="cork-board-header" style="margin-bottom: 2rem;">
                        <div class="cork-board-title">
                            📋 Vue Structure Organisée
                        </div>
                        <div style="display: flex; gap: 0.5rem;">
                            <button class="btn" onclick="closeCorkBoardView()">← Retour</button>
                        </div>
                    </div>
                    
                    <div style="display: flex; flex-direction: column; gap: 2rem;">
            `;
            
            // Générer les actes
            project.acts.forEach((act, actIndex) => {
                const actScenes = scenes.filter(s => s.actId === act.id);
                // Ne pas masquer les actes vides - les afficher quand même
                
                html += `
                    <div class="structured-act-container">
                        <div class="structured-act-header">
                            <button class="structured-collapse-btn" onclick="toggleStructuredAct(${act.id})">
                                <span class="collapse-icon" id="collapse-icon-${act.id}">▼</span>
                            </button>
                            <span class="structured-act-title">${act.title}</span>
                            <button class="btn btn-small" onclick="createChapterFromCork(${act.id})">+ Nouveau Chapitre</button>
                            <span class="structured-count">${act.chapters.length} chapitre${act.chapters.length > 1 ? 's' : ''}</span>
                        </div>
                        
                        <div class="structured-chapters-grid" id="act-content-${act.id}">
                `;
                
                // Générer les chapitres de l'acte
                act.chapters.forEach((chapter, chapIndex) => {
                    const chapterScenes = actScenes.filter(s => s.chapterId === chapter.id);
                    
                    html += `
                        <div class="structured-chapter-container">
                            <div class="structured-chapter-header">
                                <div style="display: flex; align-items: center; gap: 0.5rem;">
                                    <span class="structured-chapter-icon">::</span>
                                    <span class="structured-chapter-title">${chapter.title}</span>
                                </div>
                            </div>
                            
                            <div class="structured-scenes-list">
                    `;
                    
                    // Générer les scènes du chapitre
                    chapterScenes.forEach((scene, sceneIndex) => {
                        const synopsis = scene.synopsis || '';
                        const wordCount = scene.content ? scene.content.split(/\s+/).filter(w => w.length > 0).length : 0;
                        const color = scene.corkColor || 'default';
                        
                        html += `
                            <div class="structured-scene-card structured-color-${color}" 
                                 data-scene-id="${scene.id}"
                                 data-act-id="${scene.actId}"
                                 data-chapter-id="${scene.chapterId}"
                                 draggable="true"
                                 onclick="openSceneFromCork(${scene.actId}, ${scene.chapterId}, ${scene.id})">
                                <div class="structured-scene-header">
                                    <span class="structured-scene-icon">::</span>
                                    <span class="structured-scene-title">${scene.title}</span>
                                </div>
                                
                                <div class="structured-scene-synopsis" 
                                     contenteditable="true"
                                     onclick="event.stopPropagation()"
                                     onblur="updateSceneSynopsis(${scene.actId}, ${scene.chapterId}, ${scene.id}, this.innerText)"
                                     data-placeholder="Ajouter un résumé...">${synopsis}</div>
                                
                                <div class="structured-scene-meta" style="font-size: 0.75rem; color: var(--text-muted); margin-top: 0.5rem;">
                                    ${wordCount} mots
                                </div>
                            </div>
                        `;
                    });
                    
                    // Bouton + Nouvelle Scène
                    html += `
                                <button class="structured-add-scene-btn" onclick="openAddSceneModalFromCork(${act.id}, ${chapter.id})">
                                    <span style="font-size: 1.2rem;">+</span> Nouvelle Scène
                                </button>
                            </div>
                        </div>
                    `;
                });
                
                // Si l'acte n'a pas de chapitres, afficher un message
                if (act.chapters.length === 0) {
                    html += `
                        <div style="padding: 2rem; text-align: center; color: var(--bg-primary); opacity: 0.7; font-style: italic;">
                            Cet acte est vide. Cliquez sur "+ Nouveau Chapitre" pour commencer.
                        </div>
                    `;
                }
                
                html += `
                        </div>
                    </div>
                `;
            });
            
            html += `
                    </div>
                    
                    <div class="structured-bottom-actions">
                        <button class="btn btn-primary" onclick="createActFromCork()">+ Ajouter un Acte</button>
                    </div>
                </div>
            `;
            
            return html;
        }
        
        function renderCorkCard(scene, index) {
            const wordCount = scene.content ? getWordCount(scene.content) : 0;
            const synopsis = scene.synopsis || 'Pas de synopsis';
            const color = scene.corkColor || 'default';
            
            return `
                <div class="cork-card cork-color-${color}" 
                     data-scene-id="${scene.id}"
                     data-act-id="${scene.actId}"
                     data-chapter-id="${scene.chapterId}"
                     draggable="true">
                    <div class="cork-card-header">
                        <div class="cork-card-number">#${index + 1}</div>
                        <div style="position: relative;">
                            <div class="cork-card-color-tag cork-color-${color}" 
                                 onclick="toggleColorPalette(${scene.id})"></div>
                            <div class="cork-color-palette" id="palette-${scene.id}">
                                <div class="cork-color-option cork-color-yellow" onclick="setCorkColor(${scene.actId}, ${scene.chapterId}, ${scene.id}, 'yellow')"></div>
                                <div class="cork-color-option cork-color-pink" onclick="setCorkColor(${scene.actId}, ${scene.chapterId}, ${scene.id}, 'pink')"></div>
                                <div class="cork-color-option cork-color-blue" onclick="setCorkColor(${scene.actId}, ${scene.chapterId}, ${scene.id}, 'blue')"></div>
                                <div class="cork-color-option cork-color-green" onclick="setCorkColor(${scene.actId}, ${scene.chapterId}, ${scene.id}, 'green')"></div>
                                <div class="cork-color-option cork-color-purple" onclick="setCorkColor(${scene.actId}, ${scene.chapterId}, ${scene.id}, 'purple')"></div>
                                <div class="cork-color-option cork-color-orange" onclick="setCorkColor(${scene.actId}, ${scene.chapterId}, ${scene.id}, 'orange')"></div>
                                <div class="cork-color-option cork-color-red" onclick="setCorkColor(${scene.actId}, ${scene.chapterId}, ${scene.id}, 'red')"></div>
                                <div class="cork-color-option cork-color-teal" onclick="setCorkColor(${scene.actId}, ${scene.chapterId}, ${scene.id}, 'teal')"></div>
                                <div class="cork-color-option cork-color-default" onclick="setCorkColor(${scene.actId}, ${scene.chapterId}, ${scene.id}, 'default')">
                                    <span style="font-size: 1.2rem;">×</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="cork-card-title">${scene.title}</div>
                    
                    <div class="cork-card-synopsis" 
                         contenteditable="true" 
                         onblur="updateSceneSynopsis(${scene.actId}, ${scene.chapterId}, ${scene.id}, this.innerText)"
                         data-placeholder="Cliquez pour ajouter un synopsis...">${synopsis}</div>
                    
                    <div class="cork-card-meta">
                        <span>📍 ${scene.chapterTitle}</span>
                        <span>${wordCount} mots</span>
                    </div>
                    
                    <div class="cork-card-actions">
                        <button class="btn btn-small" onclick="openSceneFromCork(${scene.actId}, ${scene.chapterId}, ${scene.id})">
                            ✏️ Éditer
                        </button>
                    </div>
                </div>
            `;
        }
        
        function toggleColorPalette(sceneId) {
            // Fermer toutes les autres palettes
            document.querySelectorAll('.cork-color-palette').forEach(p => {
                if (p.id !== `palette-${sceneId}`) {
                    p.classList.remove('visible');
                }
            });
            
            const palette = document.getElementById(`palette-${sceneId}`);
            if (palette) {
                palette.classList.toggle('visible');
            }
        }
        
        function setCorkColor(actId, chapterId, sceneId, color) {
            const act = project.acts.find(a => a.id === actId);
            if (!act) return;
            
            const chapter = act.chapters.find(c => c.id === chapterId);
            if (!chapter) return;
            
            const scene = chapter.scenes.find(s => s.id === sceneId);
            if (!scene) return;
            
            scene.corkColor = color;
            saveProject();
            
            // Fermer la palette et re-render
            toggleColorPalette(sceneId);
            openCorkBoardView();
        }
        
        function updateSceneSynopsis(actId, chapterId, sceneId, synopsis) {
            const act = project.acts.find(a => a.id === actId);
            if (!act) return;
            
            const chapter = act.chapters.find(c => c.id === chapterId);
            if (!chapter) return;
            
            const scene = chapter.scenes.find(s => s.id === sceneId);
            if (!scene) return;
            
            scene.synopsis = synopsis;
            saveProject();
        }
        
        function openSceneFromCork(actId, chapterId, sceneId) {
            switchView('editor');
            openScene(actId, chapterId, sceneId);
        }
        
        function toggleStructuredAct(actId) {
            const content = document.getElementById(`act-content-${actId}`);
            const icon = document.getElementById(`collapse-icon-${actId}`);
            
            if (content.style.display === 'none') {
                content.style.display = 'grid';
                icon.textContent = '▼';
            } else {
                content.style.display = 'none';
                icon.textContent = '▶';
            }
        }
        
        function createChapterFromCork(actId) {
            // Sélectionner l'acte
            activeActId = actId;
            currentActId = actId;
            
            // Trouver l'acte
            const act = project.acts.find(a => a.id === actId);
            if (!act) return;
            
            // Demander le nom du chapitre
            const chapterTitle = prompt('Nom du nouveau chapitre:', `Chapitre ${act.chapters.length + 1}`);
            if (!chapterTitle || chapterTitle.trim() === '') return;
            
            // Créer le chapitre
            const newChapter = {
                id: Date.now(),
                title: chapterTitle.trim(),
                scenes: []
            };
            
            // Ajouter le chapitre à l'acte
            act.chapters.push(newChapter);
            
            // Sauvegarder
            saveProject();
            
            // Rafraîchir la vue Cork Board
            openCorkBoardView();
            
            // Notification
            showNotification(`✓ Chapitre "${chapterTitle}" créé`);
        }
        
        function openAddSceneModalFromCork(actId, chapterId) {
            // Trouver l'acte et le chapitre
            const act = project.acts.find(a => a.id === actId);
            if (!act) return;
            
            const chapter = act.chapters.find(c => c.id === chapterId);
            if (!chapter) return;
            
            // Demander le nom de la scène
            const sceneTitle = prompt('Nom de la nouvelle scène:', `Scène ${chapter.scenes.length + 1}`);
            if (!sceneTitle || sceneTitle.trim() === '') return;
            
            // Créer la scène
            const newScene = {
                id: Date.now(),
                title: sceneTitle.trim(),
                content: '',
                synopsis: '',
                characters: [],
                locations: [],
                notes: ''
            };
            
            // Ajouter la scène au chapitre
            chapter.scenes.push(newScene);
            
            // Sauvegarder
            saveProject();
            
            // Rafraîchir la vue Cork Board
            openCorkBoardView();
            
            // Notification
            showNotification(`✓ Scène "${sceneTitle}" créée`);
        }
        
        function createActFromCork() {
            // Demander le nom de l'acte
            const actTitle = prompt('Nom du nouvel acte:', `Acte ${project.acts.length + 1}`);
            if (!actTitle || actTitle.trim() === '') return;
            
            // Créer l'acte
            const newAct = {
                id: Date.now(),
                title: actTitle.trim(),
                chapters: []
            };
            
            // Ajouter l'acte au projet
            project.acts.push(newAct);
            
            // Sauvegarder
            saveProject();
            
            // Rafraîchir la vue Cork Board
            openCorkBoardView();
            
            // Notification
            showNotification(`✓ Acte "${actTitle}" créé`);
        }
        
        function toggleSceneMenu(sceneId) {
            // À implémenter : menu contextuel pour la scène
            console.log('Toggle menu for scene:', sceneId);
        }
        
        function openCreateFromOutlineModal() {
            alert('Fonctionnalité "Create from Outline" à venir');
        }
        
        function showImportOptions() {
            alert('Fonctionnalité "Import" à venir');
        }
        
        function showActions() {
            alert('Fonctionnalité "Actions" à venir');
        }
        
        function setupCorkBoardDragAndDrop() {
            const cards = document.querySelectorAll('.cork-card, .structured-scene-card');
            
            cards.forEach(card => {
                card.addEventListener('dragstart', handleCorkDragStart);
                card.addEventListener('dragend', handleCorkDragEnd);
                card.addEventListener('dragover', handleCorkDragOver);
                card.addEventListener('drop', handleCorkDrop);
            });
        }
        
        let draggedCorkCard = null;
        
        function handleCorkDragStart(e) {
            draggedCorkCard = this;
            this.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
        }
        
        function handleCorkDragEnd(e) {
            this.classList.remove('dragging');
            draggedCorkCard = null;
        }
        
        function handleCorkDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
        }
        

        function showNotification(message) {
            const notif = document.createElement('div');
            notif.style.cssText = `
                position: fixed;
                top: 2rem;
                right: 2rem;
                background: var(--accent-gold);
                color: white;
                padding: 1rem 2rem;
                border-radius: 4px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                z-index: 10000;
                font-weight: 600;
                animation: slideIn 0.3s ease;
            `;
            notif.textContent = message;
            document.body.appendChild(notif);
            
            setTimeout(() => {
                notif.style.animation = 'slideOut 0.3s ease';
                setTimeout(() => notif.remove(), 300);
            }, 2000);
        }

        function handleCorkDrop(e) {
            e.preventDefault();
            
            if (!draggedCorkCard || draggedCorkCard === this) return;
            
            // Récupérer les IDs
            const draggedSceneId = parseInt(draggedCorkCard.dataset.sceneId);
            const draggedActId = parseInt(draggedCorkCard.dataset.actId);
            const draggedChapterId = parseInt(draggedCorkCard.dataset.chapterId);
            
            const targetSceneId = parseInt(this.dataset.sceneId);
            const targetActId = parseInt(this.dataset.actId);
            const targetChapterId = parseInt(this.dataset.chapterId);
            
            // Vérifier qu'on est dans le même chapitre
            if (draggedChapterId !== targetChapterId) {
                alert('Vous ne pouvez déplacer des scènes que dans le même chapitre.\n\nPour déplacer entre chapitres, utilisez la vue Structure (sidebar).');
                return;
            }
            
            // Trouver les objets
            const act = project.acts.find(a => a.id === draggedActId);
            if (!act) return;
            
            const chapter = act.chapters.find(c => c.id === draggedChapterId);
            if (!chapter) return;
            
            const draggedSceneIndex = chapter.scenes.findIndex(s => s.id === draggedSceneId);
            const targetSceneIndex = chapter.scenes.findIndex(s => s.id === targetSceneId);
            
            if (draggedSceneIndex === -1 || targetSceneIndex === -1) return;
            
            // Réorganiser dans le tableau
            const [draggedScene] = chapter.scenes.splice(draggedSceneIndex, 1);
            chapter.scenes.splice(targetSceneIndex, 0, draggedScene);
            
            // Sauvegarder
            saveProject();
            renderActsList();
            
            // Rafraîchir le Cork Board
            openCorkBoardView();
            
            // Notification
            showNotification('✓ Scènes réorganisées');
        }
        
        
        // ============================================
        // FIN CORK BOARD
        // ============================================

        // ============================================
        // NOUVELLES FONCTIONNALITÉS DE VISUALISATION
        // ============================================
        
        // Initialiser les données de visualisation si elles n'existent pas
        if (!project.mindmapNodes) project.mindmapNodes = [];
        if (!project.plotPoints) project.plotPoints = [];
        if (!project.relationships) project.relationships = [];
        if (!project.mapLocations) project.mapLocations = [];
        if (!project.mapImage) project.mapImage = null;
        if (!project.visualTimeline) project.visualTimeline = [];
        
        // ============================================
        // MINDMAP FUNCTIONS
        // ============================================
        
        let mindmapFilter = 'all';
        
        function renderMindmapView() {
            const container = document.getElementById('mindmapList');
            if (!container) {
                console.error('mindmapList container not found');
                return;
            }
            
            // Compter les éléments
            let actCount = project.acts.length;
            let chapterCount = project.acts.reduce((sum, act) => sum + act.chapters.length, 0);
            let sceneCount = project.acts.reduce((sum, act) => 
                sum + act.chapters.reduce((s, ch) => s + ch.scenes.length, 0), 0);
            
            container.innerHTML = `
                <div style="padding: 1rem;">
                    <h3 style="margin-bottom: 1rem;">🗺️ Carte Mentale</h3>
                    <div style="font-size: 0.85rem; color: var(--text-secondary); line-height: 1.6;">
                        <div style="margin-bottom: 0.5rem;">📚 ${actCount} acte(s)</div>
                        <div style="margin-bottom: 0.5rem;">📖 ${chapterCount} chapitre(s)</div>
                        <div style="margin-bottom: 0.5rem;">✍️ ${sceneCount} scène(s)</div>
                        <div style="margin-bottom: 0.5rem;">👥 ${project.characters.length} personnage(s)</div>
                        <div>🌍 ${project.world.length} lieu(x)</div>
                    </div>
                </div>
            `;
            
            const editorView = document.getElementById('editorView');
            
            // Générer les nœuds de la mindmap
            let nodesHTML = '';
            let linesHTML = '';
            let svgLines = [];
            
            // Nœud central (projet)
            const centerX = 300;
            const centerY = 300;
            nodesHTML += `
                <div class="mindmap-node root" style="left: ${centerX}px; top: ${centerY}px; transform: translate(-50%, -50%);">
                    ${project.title}
                </div>
            `;
            
            // Positionner les actes autour du centre
            if (mindmapFilter === 'all' || mindmapFilter === 'chapters') {
                project.acts.forEach((act, actIndex) => {
                    const angle = (actIndex / project.acts.length) * 2 * Math.PI - Math.PI / 2;
                    const radius = 150;
                    const actX = centerX + radius * Math.cos(angle);
                    const actY = centerY + radius * Math.sin(angle);
                    
                    nodesHTML += `
                        <div class="mindmap-node chapter" style="left: ${actX}px; top: ${actY}px; transform: translate(-50%, -50%);" 
                             onclick="openActInEditor(${act.id})">
                            <div style="font-weight: 700; margin-bottom: 0.25rem;">${act.title}</div>
                            <div style="font-size: 0.75rem; opacity: 0.7;">${act.chapters.length} chapitres</div>
                        </div>
                    `;
                    
                    // Ligne du centre vers l'acte
                    svgLines.push(`<line x1="${centerX}" y1="${centerY}" x2="${actX}" y2="${actY}" stroke="var(--accent-gold)" stroke-width="2" opacity="0.5"/>`);
                    
                    // Positionner les chapitres autour de l'acte
                    act.chapters.forEach((chapter, chapIndex) => {
                        const chapAngle = angle + (chapIndex - act.chapters.length / 2) * 0.3;
                        const chapRadius = 120;
                        const chapX = actX + chapRadius * Math.cos(chapAngle);
                        const chapY = actY + chapRadius * Math.sin(chapAngle);
                        
                        nodesHTML += `
                            <div class="mindmap-node" style="left: ${chapX}px; top: ${chapY}px; transform: translate(-50%, -50%); font-size: 0.85rem; padding: 0.75rem 1rem;" 
                                 onclick="openChapterInEditor(${act.id}, ${chapter.id})">
                                ${chapter.title}
                            </div>
                        `;
                        
                        svgLines.push(`<line x1="${actX}" y1="${actY}" x2="${chapX}" y2="${chapY}" stroke="var(--accent-gold)" stroke-width="1" opacity="0.3"/>`);
                    });
                });
            }
            
            // Ajouter les personnages
            if (mindmapFilter === 'all' || mindmapFilter === 'characters') {
                project.characters.forEach((char, i) => {
                    const angle = (i / project.characters.length) * 2 * Math.PI + Math.PI / 4;
                    const radius = 200;
                    const charX = centerX + radius * Math.cos(angle);
                    const charY = centerY + radius * Math.sin(angle);
                    
                    nodesHTML += `
                        <div class="mindmap-node character" style="left: ${charX}px; top: ${charY}px; transform: translate(-50%, -50%);"
                             onclick="openCharacterDetail(${char.id})">
                            <div style="font-size: 1.2rem; margin-bottom: 0.25rem;">👤</div>
                            <div style="font-size: 0.9rem;">${char.name}</div>
                        </div>
                    `;
                    
                    svgLines.push(`<line x1="${centerX}" y1="${centerY}" x2="${charX}" y2="${charY}" stroke="var(--accent-red)" stroke-width="1" opacity="0.3" stroke-dasharray="5,5"/>`);
                });
            }
            
            // Ajouter les lieux
            if (mindmapFilter === 'all' || mindmapFilter === 'locations') {
                project.world.forEach((loc, i) => {
                    const angle = (i / project.world.length) * 2 * Math.PI - Math.PI / 4;
                    const radius = 220;
                    const locX = centerX + radius * Math.cos(angle);
                    const locY = centerY + radius * Math.sin(angle);
                    
                    nodesHTML += `
                        <div class="mindmap-node location" style="left: ${locX}px; top: ${locY}px; transform: translate(-50%, -50%);"
                             onclick="openWorldDetail(${loc.id})">
                            <div style="font-size: 1.2rem; margin-bottom: 0.25rem;">🏛️</div>
                            <div style="font-size: 0.9rem;">${loc.name}</div>
                        </div>
                    `;
                    
                    svgLines.push(`<line x1="${centerX}" y1="${centerY}" x2="${locX}" y2="${locY}" stroke="#4caf50" stroke-width="1" opacity="0.3" stroke-dasharray="3,3"/>`);
                });
            }
            
            editorView.innerHTML = `
                <div style="padding: 2rem;">
                    <div class="visualization-toolbar">
                        <button class="viz-tool-btn ${mindmapFilter === 'all' ? 'active' : ''}" onclick="mindmapShowAll()">Tout afficher</button>
                        <button class="viz-tool-btn ${mindmapFilter === 'chapters' ? 'active' : ''}" onclick="mindmapShowChapters()">Chapitres</button>
                        <button class="viz-tool-btn ${mindmapFilter === 'characters' ? 'active' : ''}" onclick="mindmapShowCharacters()">Personnages</button>
                        <button class="viz-tool-btn ${mindmapFilter === 'locations' ? 'active' : ''}" onclick="mindmapShowLocations()">Lieux</button>
                        <button class="viz-tool-btn" onclick="exportMindmap()">📤 Exporter</button>
                    </div>
                    <div class="visualization-canvas">
                        <div class="mindmap-container" id="mindmapCanvas" style="position: relative; width: 100%; height: 100%;">
                            <svg id="mindmapLines" style="position: absolute; width: 100%; height: 100%; pointer-events: none; top: 0; left: 0;">
                                ${svgLines.join('')}
                            </svg>
                            ${nodesHTML}
                        </div>
                    </div>
                    <div style="margin-top: 1rem; padding: 1rem; background: var(--bg-secondary); border-radius: 4px;">
                        <p style="font-size: 0.9rem; color: var(--text-secondary);">
                            💡 <strong>Info:</strong> Cliquez sur les nœuds pour naviguer vers les éléments correspondants. La carte se génère automatiquement depuis votre structure.
                        </p>
                    </div>
                </div>
            `;
        }
        
        function openActInEditor(actId) {
            switchView('editor');
            // Ouvrir le premier chapitre du premier acte si disponible
            const act = project.acts.find(a => a.id === actId);
            if (act && act.chapters.length > 0) {
                const chapter = act.chapters[0];
                if (chapter.scenes.length > 0) {
                    openScene(actId, chapter.id, chapter.scenes[0].id);
                }
            }
        }
        
        function openChapterInEditor(actId, chapterId) {
            switchView('editor');
            const act = project.acts.find(a => a.id === actId);
            if (act) {
                const chapter = act.chapters.find(c => c.id === chapterId);
                if (chapter && chapter.scenes.length > 0) {
                    openScene(actId, chapterId, chapter.scenes[0].id);
                }
            }
        }
        
        function addMindmapNode() {
            alert('Les nœuds sont générés automatiquement depuis vos actes, chapitres, personnages et lieux. Créez-les dans leurs sections respectives.');
        }
        
        function exportMindmap() {
            const canvas = document.getElementById('mindmapCanvas');
            if (!canvas) return;
            
            // Créer un canvas pour l'export
            const svgContent = document.getElementById('mindmapLines').outerHTML;
            const nodesContent = Array.from(canvas.querySelectorAll('.mindmap-node')).map(node => {
                return `<div style="${node.getAttribute('style')}" class="${node.className}">${node.innerHTML}</div>`;
            }).join('');
            
            const fullHTML = `
                <html>
                <head><title>${project.title} - Mindmap</title></head>
                <body style="margin: 0; padding: 20px;">
                    <h1>${project.title} - Carte Mentale</h1>
                    <div style="position: relative; width: 800px; height: 600px; border: 1px solid #ccc;">
                        ${svgContent}
                        ${nodesContent}
                    </div>
                </body>
                </html>
            `;
            
            const blob = new Blob([fullHTML], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${project.title}_mindmap.html`;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        function mindmapShowAll() { 
            mindmapFilter = 'all';
            renderMindmapView(); 
        }
        
        function mindmapShowChapters() { 
            mindmapFilter = 'chapters';
            renderMindmapView(); 
        }
        
        function mindmapShowCharacters() { 
            mindmapFilter = 'characters';
            renderMindmapView(); 
        }
        
        function mindmapShowLocations() { 
            mindmapFilter = 'locations';
            renderMindmapView(); 
        }
        
        function resetMindmapZoom() { 
            renderMindmapView(); 
        }
        
        let plotPoints = [];
        
        // Algorithme d'analyse de tension basé sur le contenu
        function calculateSceneTension(scene, actIndex, totalActs, chapterIndex, totalChapters, sceneIndex, totalScenes) {
            let tension = 0;
            const content = (scene.content || '').toLowerCase();
            const title = (scene.title || '').toLowerCase();
            
            // 1. ANALYSE LEXICALE (0-40 points)
            // Charger les mots personnalisés ou utiliser les valeurs par défaut
            const tensionWords = getTensionWords();
            const highTensionWords = tensionWords.high;
            const mediumTensionWords = tensionWords.medium;
            const lowTensionWords = tensionWords.low;
            
            let lexicalScore = 0;
            highTensionWords.forEach(word => {
                if (content.includes(word) || title.includes(word)) lexicalScore += 3;
            });
            mediumTensionWords.forEach(word => {
                if (content.includes(word) || title.includes(word)) lexicalScore += 1.5;
            });
            lowTensionWords.forEach(word => {
                if (content.includes(word) || title.includes(word)) lexicalScore -= 2;
            });
            
            tension += Math.max(0, Math.min(40, lexicalScore));
            
            // 2. ANALYSE DE LA LONGUEUR (0-10 points)
            // Les scènes courtes intenses vs longues descriptives
            const wordCount = content.split(/\s+/).filter(w => w.length > 0).length;
            if (wordCount < 200) tension += 8; // Scène courte = souvent intense
            else if (wordCount < 500) tension += 5;
            else if (wordCount < 1000) tension += 3;
            else tension += 2; // Scène longue = souvent descriptive
            
            // 3. PONCTUATION EXPRESSIVE (0-10 points)
            const exclamations = (content.match(/!/g) || []).length;
            const questions = (content.match(/\?/g) || []).length;
            const suspensions = (content.match(/\.\.\./g) || []).length;
            
            tension += Math.min(10, (exclamations * 0.5 + questions * 0.3 + suspensions * 0.8));
            
            // 4. STRUCTURE NARRATIVE (0-40 points)
            // Position dans l'acte (courbe en 3 actes)
            const actProgress = actIndex / Math.max(totalActs - 1, 1);
            const chapterProgress = chapterIndex / Math.max(totalChapters - 1, 1);
            const sceneProgress = sceneIndex / Math.max(totalScenes - 1, 1);
            
            // Structure classique en 3 actes
            if (totalActs >= 3) {
                if (actIndex === 0) {
                    // Acte 1 : Montée progressive
                    tension += 10 + (chapterProgress * 15);
                } else if (actIndex === totalActs - 1) {
                    // Dernier acte : Haute tension jusqu'au climax, puis résolution
                    if (sceneProgress < 0.7) {
                        tension += 35 + (sceneProgress * 5);
                    } else {
                        // Résolution
                        tension += 40 - ((sceneProgress - 0.7) * 50);
                    }
                } else {
                    // Actes intermédiaires : Montée progressive
                    tension += 20 + (actProgress * 15);
                }
            } else if (totalActs === 2) {
                // Structure en 2 actes
                if (actIndex === 0) {
                    tension += 15 + (chapterProgress * 15);
                } else {
                    tension += 30 + (sceneProgress * 10);
                }
            } else {
                // Un seul acte : courbe progressive
                tension += 20 + (sceneProgress * 20);
            }
            
            // Bonus pour les scènes de fin de chapitre (cliffhangers)
            if (sceneIndex === totalScenes - 1) {
                tension += 5;
            }
            
            // 5. NORMALISATION (0-100)
            tension = Math.max(15, Math.min(95, tension)); // Entre 15 et 95
            
            return tension;
        }
        
        function renderPlotView() {
            const container = document.getElementById('editorView');
            if (!container) {
                console.error('editorView container not found');
                return;
            }
            // Initialiser les points d'intrigue avec calcul intelligent
            if (plotPoints.length === 0 && project.acts.length > 0) {
                let position = 0;
                const totalActs = project.acts.length;
                
                project.acts.forEach((act, actIndex) => {
                    const totalChapters = act.chapters.length;
                    
                    act.chapters.forEach((chapter, chapIndex) => {
                        const totalScenes = chapter.scenes.length;
                        
                        chapter.scenes.forEach((scene, sceneIndex) => {
                            const intensity = calculateSceneTension(
                                scene, 
                                actIndex, 
                                totalActs, 
                                chapIndex, 
                                totalChapters, 
                                sceneIndex, 
                                totalScenes
                            );
                            
                            plotPoints.push({
                                position: position++,
                                intensity: intensity,
                                title: scene.title,
                                actId: act.id,
                                chapterId: chapter.id,
                                sceneId: scene.id,
                                description: `${act.title} > ${chapter.title}`,
                                wordCount: scene.content ? scene.content.split(/\s+/).filter(w => w.length > 0).length : 0
                            });
                        });
                    });
                });
            }
            
            // Générer le graphique SVG
            const svgWidth = 800;
            const svgHeight = 500;
            const padding = 60;
            const plotWidth = svgWidth - padding * 2;
            const plotHeight = svgHeight - padding * 2;
            
            let pathData = '';
            let pointsHTML = '';
            let gridLines = '';
            
            // Lignes de grille
            for (let i = 0; i <= 4; i++) {
                const y = padding + (plotHeight / 4) * i;
                gridLines += `<line x1="${padding}" y1="${y}" x2="${svgWidth - padding}" y2="${y}" stroke="var(--border-color)" stroke-width="1" opacity="0.3" stroke-dasharray="5,5"/>`;
                gridLines += `<text x="${padding - 10}" y="${y + 5}" text-anchor="end" font-size="12" fill="var(--text-muted)">${100 - i * 25}%</text>`;
            }
            
            // Générer la courbe
            if (plotPoints.length > 0) {
                plotPoints.forEach((point, index) => {
                    const x = padding + (plotWidth / Math.max(plotPoints.length - 1, 1)) * index;
                    const y = padding + plotHeight - (point.intensity / 100) * plotHeight;
                    
                    if (index === 0) {
                        pathData = `M ${x} ${y}`;
                    } else {
                        pathData += ` L ${x} ${y}`;
                    }
                    
                    // Points cliquables avec menu contextuel
                    pointsHTML += `
                        <circle cx="${x}" cy="${y}" r="6" fill="var(--accent-gold)" stroke="white" stroke-width="2" 
                                style="cursor: pointer;" 
                                onclick="editPlotPointIntensity(${index})"
                                oncontextmenu="event.preventDefault(); openPlotPoint(${point.actId}, ${point.chapterId}, ${point.sceneId})">
                            <title>Clic gauche: Éditer tension (${Math.round(point.intensity)}%)
Clic droit: Ouvrir scène "${point.title}"</title>
                        </circle>
                    `;
                });
            }
            
            container.innerHTML = `
                <div style="padding: 2rem;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
                        <div>
                            <h3 style="margin: 0;">📈 Graphique d'Intrigue</h3>
                            <div style="font-size: 0.85rem; color: var(--text-secondary); margin-top: 0.5rem;">
                                📊 ${plotPoints.length} point(s) d'intrigue • 🎯 Tension moyenne: ${plotPoints.length > 0 ? Math.round(plotPoints.reduce((sum, p) => sum + p.intensity, 0) / plotPoints.length) : 0}%
                            </div>
                        </div>
                        <button onclick="openTensionWordsEditor()" 
                                style="padding: 10px 18px; background: #3a7bc8; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.9rem; font-weight: 500; transition: all 0.2s; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"
                                onmouseover="this.style.background='#2d6bb3'; this.style.boxShadow='0 4px 8px rgba(0,0,0,0.15)'"
                                onmouseout="this.style.background='#3a7bc8'; this.style.boxShadow='0 2px 4px rgba(0,0,0,0.1)'">
                            ✏️ Personnaliser les mots de tension
                        </button>
                    </div>
                    <div class="visualization-toolbar">
                        <button class="viz-tool-btn active">Vue d'ensemble</button>
                        <button class="viz-tool-btn" onclick="analyzePlotCurve()">🔍 Analyser la courbe</button>
                        <button class="viz-tool-btn" onclick="showPlotSuggestions()">💡 Suggestions</button>
                        <button class="viz-tool-btn" onclick="resetPlotPoints()">🔄 Recalculer</button>
                        <button class="viz-tool-btn" onclick="exportPlot()">📤 Exporter</button>
                    </div>
                    <div class="visualization-canvas">
                        <div class="plot-graph">
                            <svg width="100%" height="${svgHeight}" viewBox="0 0 ${svgWidth} ${svgHeight}" id="plotSvg">
                                <!-- Axes -->
                                <line x1="${padding}" y1="${svgHeight - padding}" x2="${svgWidth - padding}" y2="${svgHeight - padding}" 
                                      stroke="var(--text-primary)" stroke-width="2"/>
                                <line x1="${padding}" y1="${padding}" x2="${padding}" y2="${svgHeight - padding}" 
                                      stroke="var(--text-primary)" stroke-width="2"/>
                                
                                <!-- Labels -->
                                <text x="${svgWidth / 2}" y="${svgHeight - 20}" text-anchor="middle" fill="var(--text-muted)" font-size="14">
                                    Progression du récit →
                                </text>
                                <text x="20" y="${svgHeight / 2}" text-anchor="middle" fill="var(--text-muted)" font-size="14" 
                                      transform="rotate(-90 20 ${svgHeight / 2})">
                                    ← Tension dramatique
                                </text>
                                
                                <!-- Grille -->
                                ${gridLines}
                                
                                <!-- Courbe d'intrigue -->
                                ${pathData ? `<path d="${pathData}" fill="none" stroke="var(--accent-gold)" stroke-width="3"/>` : ''}
                                
                                <!-- Points -->
                                ${pointsHTML}
                            </svg>
                        </div>
                    </div>
                    <div style="margin-top: 1rem; padding: 1rem; background: var(--bg-secondary); border-radius: 4px;">
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                            <div>
                                <p style="font-size: 0.9rem; color: var(--text-secondary); line-height: 1.6; margin: 0;">
                                    💡 <strong>Utilisation:</strong><br>
                                    • <strong>Clic gauche</strong> sur un point → Modifier manuellement la tension<br>
                                    • <strong>Clic droit</strong> sur un point → Ouvrir la scène pour l'éditer<br>
                                    • <strong>Analyser</strong> → Obtenez un rapport complet sur votre courbe<br>
                                    • <strong>Suggestions</strong> → Conseils personnalisés pour améliorer l'intrigue
                                </p>
                            </div>
                            <div style="padding: 0.75rem; background: var(--bg-primary); border-radius: 4px; border: 1px solid var(--border-color);">
                                <div style="font-size: 0.85rem; font-weight: 600; margin-bottom: 0.5rem; color: var(--text-primary);">Calcul de la tension :</div>
                                <div style="font-size: 0.75rem; line-height: 1.6; color: var(--text-secondary);">
                                    • Analyse lexicale (mots-clés personnalisables)<br>
                                    • Longueur de la scène<br>
                                    • Ponctuation expressive<br>
                                    • Position narrative (structure en 3 actes)
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }
        
        function openPlotPoint(actId, chapterId, sceneId) {
            switchView('editor');
            openScene(actId, chapterId, sceneId);
        }
        
        function editPlotPointIntensity(index) {
            if (index < 0 || index >= plotPoints.length) return;
            
            const point = plotPoints[index];
            const currentIntensity = Math.round(point.intensity);
            
            const newIntensity = prompt(
                `Modifier la tension de "${point.title}"\n\n` +
                `Tension actuelle: ${currentIntensity}%\n` +
                `Entrez une nouvelle valeur (0-100):`,
                currentIntensity
            );
            
            if (newIntensity === null) return;
            
            const intensity = parseInt(newIntensity);
            if (isNaN(intensity) || intensity < 0 || intensity > 100) {
                alert('Veuillez entrer un nombre entre 0 et 100');
                return;
            }
            
            point.intensity = intensity;
            renderPlotView();
            showNotification(`✓ Tension mise à jour: ${intensity}%`);
        }
        
        function analyzePlotCurve() {
            if (plotPoints.length === 0) {
                alert('Aucun point à analyser. Créez d\'abord des scènes.');
                return;
            }
            
            // Analyse de la courbe
            const tensions = plotPoints.map(p => p.intensity);
            const avg = tensions.reduce((a, b) => a + b, 0) / tensions.length;
            const max = Math.max(...tensions);
            const min = Math.min(...tensions);
            const maxIndex = tensions.indexOf(max);
            const minIndex = tensions.indexOf(min);
            
            // Calcul de la variance (mesure de variation)
            const variance = tensions.reduce((sum, t) => sum + Math.pow(t - avg, 2), 0) / tensions.length;
            const stdDev = Math.sqrt(variance);
            
            // Détection du climax
            const lastThird = Math.floor(plotPoints.length * 0.66);
            const climaxInLastThird = maxIndex >= lastThird;
            
            // Analyse de la progression
            const firstHalf = tensions.slice(0, Math.floor(tensions.length / 2));
            const secondHalf = tensions.slice(Math.floor(tensions.length / 2));
            const firstAvg = firstHalf.reduce((a, b) => a + b, 0) / firstHalf.length;
            const secondAvg = secondHalf.reduce((a, b) => a + b, 0) / secondHalf.length;
            const isRising = secondAvg > firstAvg;
            
            // Compter les pics (variations > 20%)
            let peaks = 0;
            for (let i = 1; i < tensions.length - 1; i++) {
                if (tensions[i] > tensions[i-1] + 20 && tensions[i] > tensions[i+1] + 20) {
                    peaks++;
                }
            }
            
            // Rapport d'analyse
            let analysis = `📊 ANALYSE DE VOTRE COURBE D'INTRIGUE\n\n`;
            
            analysis += `📈 STATISTIQUES\n`;
            analysis += `• Tension moyenne : ${Math.round(avg)}%\n`;
            analysis += `• Tension max : ${Math.round(max)}% (${plotPoints[maxIndex].title})\n`;
            analysis += `• Tension min : ${Math.round(min)}% (${plotPoints[minIndex].title})\n`;
            analysis += `• Amplitude : ${Math.round(max - min)}%\n`;
            analysis += `• Variation : ${stdDev < 10 ? 'Faible' : stdDev < 20 ? 'Modérée' : 'Forte'}\n`;
            analysis += `• Nombre de pics : ${peaks}\n\n`;
            
            analysis += `🎯 ÉVALUATION NARRATIVE\n`;
            
            // Évaluation de la tension moyenne
            if (avg < 40) {
                analysis += `⚠️ Tension moyenne BASSE (${Math.round(avg)}%)\n`;
                analysis += `   → Votre histoire manque peut-être de conflits\n`;
            } else if (avg > 70) {
                analysis += `⚠️ Tension moyenne ÉLEVÉE (${Math.round(avg)}%)\n`;
                analysis += `   → Le lecteur risque la fatigue. Ajoutez des pauses\n`;
            } else {
                analysis += `✅ Tension moyenne équilibrée (${Math.round(avg)}%)\n`;
            }
            
            // Évaluation du climax
            if (climaxInLastThird) {
                analysis += `✅ Climax bien placé (dernier tiers du récit)\n`;
            } else {
                analysis += `⚠️ Climax trop tôt (${Math.round((maxIndex / plotPoints.length) * 100)}% du récit)\n`;
                analysis += `   → Le climax devrait être vers 70-80%\n`;
            }
            
            // Évaluation de la progression
            if (isRising) {
                analysis += `✅ Tension croissante (bon rythme)\n`;
            } else {
                analysis += `⚠️ Tension décroissante en moyenne\n`;
                analysis += `   → La seconde moitié perd en intensité\n`;
            }
            
            // Évaluation de la variation
            if (stdDev < 10) {
                analysis += `⚠️ Courbe trop PLATE\n`;
                analysis += `   → Créez plus de contraste entre action et repos\n`;
            } else if (stdDev > 25) {
                analysis += `⚠️ Courbe très IRRÉGULIÈRE\n`;
                analysis += `   → Peut-être intentionnel (action frénétique)?\n`;
            } else {
                analysis += `✅ Variation équilibrée\n`;
            }
            
            // Évaluation des pics
            if (peaks === 0) {
                analysis += `⚠️ Aucun pic majeur détecté\n`;
                analysis += `   → Ajoutez des moments de tension forte\n`;
            } else if (peaks > plotPoints.length / 3) {
                analysis += `⚠️ Trop de pics (${peaks})\n`;
                analysis += `   → Le lecteur n'a pas le temps de souffler\n`;
            } else {
                analysis += `✅ Nombre de pics approprié (${peaks})\n`;
            }
            
            analysis += `\n💡 Cliquez sur "Suggestions" pour des conseils détaillés`;
            
            alert(analysis);
        }
        
        function showPlotSuggestions() {
            if (plotPoints.length === 0) {
                alert('Créez d\'abord des scènes pour obtenir des suggestions.');
                return;
            }
            
            const tensions = plotPoints.map(p => p.intensity);
            const avg = tensions.reduce((a, b) => a + b, 0) / tensions.length;
            
            let suggestions = `💡 SUGGESTIONS POUR AMÉLIORER VOTRE INTRIGUE\n\n`;
            
            // Analyser les zones plates
            let flatZones = [];
            for (let i = 0; i < tensions.length - 2; i++) {
                const range = tensions.slice(i, i + 3);
                const rangeAvg = range.reduce((a, b) => a + b, 0) / range.length;
                const rangeVariance = range.reduce((sum, t) => sum + Math.pow(t - rangeAvg, 2), 0) / range.length;
                if (rangeVariance < 5) {
                    flatZones.push(i);
                }
            }
            
            if (flatZones.length > 0) {
                suggestions += `📉 ZONES PLATES DÉTECTÉES\n`;
                suggestions += `${flatZones.length} séquences manquent de variation.\n`;
                suggestions += `→ Ajoutez un rebondissement ou un obstacle\n`;
                suggestions += `→ Variez le rythme (alternez dialogue et action)\n\n`;
            }
            
            // Suggestions selon la tension moyenne
            if (avg < 40) {
                suggestions += `🔥 AUGMENTER LA TENSION GLOBALE\n`;
                suggestions += `→ Ajoutez plus de conflits entre personnages\n`;
                suggestions += `→ Créez des obstacles plus grands\n`;
                suggestions += `→ Utilisez des mots plus percutants\n`;
                suggestions += `→ Raccourcissez les scènes d'action\n\n`;
            } else if (avg > 70) {
                suggestions += `😌 CRÉER DES PAUSES\n`;
                suggestions += `→ Ajoutez des scènes de réflexion\n`;
                suggestions += `→ Moments de calme après l'action\n`;
                suggestions += `→ Dialogues intimes ou humoristiques\n`;
                suggestions += `→ Descriptions contemplatives\n\n`;
            }
            
            // Suggestions de structure
            suggestions += `📐 STRUCTURE RECOMMANDÉE\n`;
            suggestions += `• Début (0-25%) : 20-40% tension\n`;
            suggestions += `• Milieu (25-66%) : 40-60% tension\n`;
            suggestions += `• Fin (66-90%) : 60-90% tension (climax)\n`;
            suggestions += `• Résolution (90-100%) : 20-40% tension\n\n`;
            
            // Conseils pratiques
            suggestions += `✍️ TECHNIQUES CONCRÈTES\n`;
            suggestions += `→ Pour augmenter la tension :\n`;
            suggestions += `  • Ajoutez des deadlines\n`;
            suggestions += `  • Mettez en danger un personnage aimé\n`;
            suggestions += `  • Révélez un secret\n`;
            suggestions += `  • Créez un dilemme moral\n\n`;
            suggestions += `→ Pour diminuer la tension :\n`;
            suggestions += `  • Résolvez un conflit mineur\n`;
            suggestions += `  • Moment de victoire temporaire\n`;
            suggestions += `  • Scène de camaraderie\n`;
            suggestions += `  • Description paisible\n`;
            
            alert(suggestions);
        }
        
        function resetPlotPoints() {
            if (confirm('Recalculer tous les points d\'intrigue ?\n\nLa tension sera recalculée automatiquement pour toutes les scènes.\n\nLes ajustements manuels seront perdus.')) {
                plotPoints = [];
                renderPlotView();
                showNotification('✓ Points recalculés automatiquement');
            }
        }
        
        function addPlotPoint() {
            alert('Les points sont générés automatiquement depuis vos scènes.\n\nPour ajuster la tension :\n• Clic gauche sur un point → Modifier manuellement\n• Clic droit sur un point → Ouvrir la scène');
        }
        
        function exportPlot() {
            const svg = document.getElementById('plotSvg');
            if (!svg) return;
            
            const svgData = new XMLSerializer().serializeToString(svg);
            const blob = new Blob([svgData], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${project.title}_plot.svg`;
            a.click();
            URL.revokeObjectURL(url);
        }
            editorView.innerHTML = `
                <div style="padding: 2rem;">
                    <div class="visualization-toolbar">
                        <button class="viz-tool-btn active">Graphique de Tension</button>
                        <button class="viz-tool-btn">Arcs Narratifs</button>
                        <button class="viz-tool-btn">Points Clés</button>
                        <select class="viz-tool-btn" style="width: auto;">
                            <option>Tout le roman</option>
                            ${project.acts.map(act => `<option>Acte: ${act.title}</option>`).join('')}
                        </select>
                    </div>
                    <div class="visualization-canvas">
                        <div class="plot-graph">
                            <svg width="100%" height="550" id="plotSvg">
                                <!-- Axes -->
                                <line x1="50" y1="500" x2="750" y2="500" stroke="var(--border-color)" stroke-width="2"/>
                                <line x1="50" y1="50" x2="50" y2="500" stroke="var(--border-color)" stroke-width="2"/>
                                
                                <!-- Labels -->
                                <text x="400" y="540" text-anchor="middle" fill="var(--text-muted)" font-size="14">Progression du récit →</text>
                                <text x="20" y="275" text-anchor="middle" fill="var(--text-muted)" font-size="14" transform="rotate(-90 20 275)">← Tension dramatique</text>
                                
                                <!-- Grille -->
                                <line x1="50" y1="400" x2="750" y2="400" stroke="var(--border-color)" stroke-width="1" opacity="0.3" stroke-dasharray="5,5"/>
                                <line x1="50" y1="300" x2="750" y2="300" stroke="var(--border-color)" stroke-width="1" opacity="0.3" stroke-dasharray="5,5"/>
                                <line x1="50" y1="200" x2="750" y2="200" stroke="var(--border-color)" stroke-width="1" opacity="0.3" stroke-dasharray="5,5"/>
                                <line x1="50" y1="100" x2="750" y2="100" stroke="var(--border-color)" stroke-width="1" opacity="0.3" stroke-dasharray="5,5"/>
                                
                                <!-- Courbe d'intrigue typique (Structure en 3 actes) -->
                                <path d="M 50 450 Q 150 400, 250 350 T 450 200 T 650 100 L 750 120" 
                                      fill="none" stroke="var(--accent-gold)" stroke-width="3" opacity="0.7"/>
                                
                                <!-- Points clés -->
                                <circle cx="250" cy="350" r="6" fill="var(--accent-red)" cursor="pointer"/>
                                <text x="250" y="340" text-anchor="middle" font-size="12" fill="var(--text-secondary)">Incident déclencheur</text>
                                
                                <circle cx="450" cy="200" r="6" fill="var(--accent-red)" cursor="pointer"/>
                                <text x="450" y="190" text-anchor="middle" font-size="12" fill="var(--text-secondary)">Point médian</text>
                                
                                <circle cx="650" cy="100" r="6" fill="var(--accent-red)" cursor="pointer"/>
                                <text x="650" y="90" text-anchor="middle" font-size="12" fill="var(--text-secondary)">Climax</text>
                            </svg>
                        </div>
                    </div>
                    <div style="margin-top: 1rem; padding: 1rem; background: var(--bg-secondary); border-radius: 4px;">
                        <p style="font-size: 0.9rem; color: var(--text-secondary);">
                            💡 <strong>Astuce:</strong> Analysez la tension dramatique de votre récit. Les moments clés (incident déclencheur, climax, résolution) devraient créer une courbe ascendante pour maintenir l'intérêt du lecteur.
                        </p>
                    </div>
                </div>
            `;
        
        // ============================================
        // RELATIONS GRAPH FUNCTIONS
        // ============================================
        
        function renderRelationsView() {
            const editorView = document.getElementById('editorView');
            if (!editorView) {
                console.error('editorView not found');
                return;
            }
            
            // S'assurer que relations existe
            if (!project.relations) project.relations = [];
            
            // S'assurer que les positions personnalisées existent
            if (!project.characterPositions) project.characterPositions = {};
            
            // Types de relations avec couleurs
            const relationTypes = {
                'amour': { color: '#e91e63', label: '❤️ Amour', icon: '❤️' },
                'amitie': { color: '#4caf50', label: '🤝 Amitié', icon: '🤝' },
                'rivalite': { color: '#f44336', label: '⚔️ Rivalité', icon: '⚔️' },
                'famille': { color: '#2196f3', label: '👨‍👩‍👧 Famille', icon: '👨‍👩‍👧' },
                'mentor': { color: '#ff9800', label: '📚 Mentor', icon: '📚' },
                'ennemi': { color: '#9c27b0', label: '💀 Ennemi', icon: '💀' },
                'alliance': { color: '#00bcd4', label: '🤜🤛 Alliance', icon: '🤜🤛' },
                'neutre': { color: '#757575', label: '😐 Neutre', icon: '😐' }
            };
            
            let graphHTML = '';
            if (project.characters.length >= 2) {
                const centerX = 400;
                const centerY = 350;
                const radius = 220;
                
                // Calculer les positions (personnalisées ou par défaut en cercle)
                const positions = project.characters.map((char, i) => {
                    if (project.characterPositions[char.id]) {
                        return project.characterPositions[char.id];
                    } else {
                        const angle = (i / project.characters.length) * 2 * Math.PI;
                        return {
                            x: centerX + radius * Math.cos(angle),
                            y: centerY + radius * Math.sin(angle)
                        };
                    }
                });
                
                // SVG pour les lignes de relation
                let svgLines = '<svg id="relationsSvg" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0; pointer-events: none;">';
                
                // Dessiner les relations existantes
                project.relations.forEach(rel => {
                    const char1 = project.characters.find(c => c.id === rel.char1Id);
                    const char2 = project.characters.find(c => c.id === rel.char2Id);
                    
                    if (char1 && char2) {
                        const i1 = project.characters.indexOf(char1);
                        const i2 = project.characters.indexOf(char2);
                        
                        const x1 = positions[i1].x;
                        const y1 = positions[i1].y;
                        const x2 = positions[i2].x;
                        const y2 = positions[i2].y;
                        
                        const relType = relationTypes[rel.type] || relationTypes['neutre'];
                        
                        svgLines += `
                            <line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" 
                                  stroke="${relType.color}" 
                                  stroke-width="3" 
                                  opacity="0.7"
                                  style="cursor: pointer;"
                                  onclick="editRelation('${rel.id}')"/>
                            <text x="${(x1 + x2) / 2}" y="${(y1 + y2) / 2 - 10}" 
                                  fill="${relType.color}" 
                                  font-size="20" 
                                  text-anchor="middle"
                                  style="pointer-events: none;">${relType.icon}</text>
                        `;
                    }
                });
                
                svgLines += '</svg>';
                
                // Positionner les personnages (draggables)
                project.characters.forEach((char, i) => {
                    const pos = positions[i];
                    
                    graphHTML += `
                        <div id="char-node-${char.id}" 
                             class="char-node-draggable"
                             data-char-id="${char.id}"
                             style="position: absolute; left: ${pos.x}px; top: ${pos.y}px; transform: translate(-50%, -50%); text-align: center; cursor: move;"
                             onmousedown="startDragCharacter(event, ${char.id})"
                             onclick="handleCharacterClick(event, ${char.id})">
                            <div style="width: 70px; height: 70px; border-radius: 50%; background: var(--accent-gold); 
                                        display: flex; align-items: center; justify-content: center; font-size: 2rem;
                                        border: 3px solid white; box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                                        ${selectedCharsForRelation.includes(char.id) ? 'border-color: var(--accent-red); border-width: 5px;' : ''}
                                        transition: transform 0.2s;">
                                ${char.avatar || '👤'}
                            </div>
                            <div style="margin-top: 0.5rem; font-weight: 600; font-size: 0.9rem; background: var(--bg-accent); color: white;
                                        padding: 0.25rem 0.5rem; border-radius: 4px; white-space: nowrap; pointer-events: none;">${char.name}</div>
                        </div>
                    `;
                });
                
                graphHTML = svgLines + graphHTML;
            } else {
                graphHTML = `
                    <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center;">
                        <div style="font-size: 4rem; margin-bottom: 1rem;">👥</div>
                        <div style="font-size: 1.3rem; font-weight: 600; margin-bottom: 0.5rem;">Aucune relation à afficher</div>
                        <div style="color: var(--text-muted); margin-bottom: 1rem;">Créez au moins 2 personnages pour visualiser leurs relations</div>
                        <button class="btn btn-primary" onclick="switchView('characters')">+ Créer des personnages</button>
                    </div>
                `;
            }
            
            editorView.innerHTML = `
                <div style="height: 100%; overflow-y: auto; padding: 2rem 3rem;">
                    <h2 style="margin-bottom: 2rem; color: var(--accent-gold);">🔗 Carte des Relations</h2>
                    
                    ${project.characters.length >= 2 ? `
                        <div style="margin-bottom: 2rem; display: flex; gap: 1rem; flex-wrap: wrap;">
                            <div style="flex: 1; min-width: 300px; padding: 1.5rem; background: var(--bg-secondary); border-radius: 8px; border-left: 4px solid var(--accent-gold);">
                                <div style="font-weight: 600; margin-bottom: 0.5rem;">📝 Créer une relation:</div>
                                <div style="font-size: 0.9rem; color: var(--text-secondary); line-height: 1.6;">
                                    1. Cliquez sur un premier personnage<br>
                                    2. Cliquez sur un second personnage<br>
                                    3. Choisissez le type de relation
                                </div>
                            </div>
                            <div style="flex: 1; min-width: 300px; padding: 1.5rem; background: var(--bg-secondary); border-radius: 8px; border-left: 4px solid var(--accent-red);">
                                <div style="font-weight: 600; margin-bottom: 0.5rem;">🖱️ Déplacer les personnages:</div>
                                <div style="font-size: 0.9rem; color: var(--text-secondary); line-height: 1.6;">
                                    Faites glisser les personnages pour réorganiser le graphe<br>
                                    Les liens suivent automatiquement
                                </div>
                            </div>
                        </div>
                        <div style="margin-bottom: 1rem; display: flex; gap: 0.5rem;">
                            <button class="btn btn-small" onclick="resetCharacterPositions()">🔄 Réinitialiser positions</button>
                            <button class="btn btn-small" onclick="autoArrangeCharacters()">✨ Arranger automatiquement</button>
                        </div>
                    ` : ''}
                    
                    <div id="relationsGraph" style="position: relative; height: 700px; background: var(--bg-secondary); border-radius: 8px; margin-bottom: 2rem;">
                        ${graphHTML}
                    </div>
                    
                    ${project.characters.length >= 2 ? `
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1rem; margin-bottom: 2rem;">
                            ${Object.entries(relationTypes).map(([key, rel]) => `
                                <div style="display: flex; align-items: center; gap: 0.75rem; padding: 1rem; background: var(--bg-secondary); border-radius: 8px; border-left: 4px solid ${rel.color};">
                                    <div style="font-size: 1.5rem;">${rel.icon}</div>
                                    <div style="flex: 1;">
                                        <div style="font-weight: 600; font-size: 0.95rem;">${rel.label.split(' ')[1]}</div>
                                        <div style="font-size: 0.75rem; color: var(--text-muted);">${getRelationCount(key)} relation(s)</div>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    ` : ''}
                    
                    ${project.relations && project.relations.length > 0 ? `
                        <div style="background: var(--bg-secondary); padding: 1.5rem; border-radius: 8px;">
                            <h3 style="margin-bottom: 1rem; color: var(--text-primary);">📋 Liste des relations (${project.relations.length})</h3>
                            <div style="display: flex; flex-direction: column; gap: 0.75rem;">
                                ${project.relations.map(rel => {
                                    const char1 = project.characters.find(c => c.id === rel.char1Id);
                                    const char2 = project.characters.find(c => c.id === rel.char2Id);
                                    const relType = relationTypes[rel.type] || relationTypes['neutre'];
                                    return char1 && char2 ? `
                                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 1rem; background: var(--bg-primary); border-radius: 4px; border-left: 4px solid ${relType.color};">
                                            <div style="display: flex; align-items: center; gap: 1rem;">
                                                <span style="font-size: 1.5rem;">${relType.icon}</span>
                                                <span style="font-weight: 600;">${char1.name}</span>
                                                <span style="color: var(--text-muted);">↔</span>
                                                <span style="font-weight: 600;">${char2.name}</span>
                                                ${rel.description ? `<span style="color: var(--text-muted); font-size: 0.85rem;">· ${rel.description}</span>` : ''}
                                            </div>
                                            <div style="display: flex; gap: 0.5rem;">
                                                <button class="btn btn-small" onclick="editRelation('${rel.id}')">✏️</button>
                                                <button class="btn btn-small" onclick="deleteRelation('${rel.id}')">🗑️</button>
                                            </div>
                                        </div>
                                    ` : '';
                                }).join('')}
                            </div>
                        </div>
                    ` : ''}
                </div>
            `;
            
            // Ajouter les événements de hover sur les personnages
            setTimeout(() => {
                document.querySelectorAll('.char-node-draggable').forEach(node => {
                    node.addEventListener('mouseenter', () => {
                        node.querySelector('div').style.transform = 'scale(1.1)';
                    });
                    node.addEventListener('mouseleave', () => {
                        node.querySelector('div').style.transform = 'scale(1)';
                    });
                });
            }, 0);
        }
        
        // Variables pour le drag-and-drop
        let draggedCharId = null;
        let dragStartX = 0;
        let dragStartY = 0;
        let isDragging = false;
        let dragMoved = false;
        
        function startDragCharacter(event, charId) {
            event.preventDefault();
            draggedCharId = charId;
            dragStartX = event.clientX;
            dragStartY = event.clientY;
            isDragging = true;
            dragMoved = false;
            
            document.addEventListener('mousemove', dragCharacter);
            document.addEventListener('mouseup', stopDragCharacter);
        }
        
        function dragCharacter(event) {
            if (!isDragging || !draggedCharId) return;
            
            const deltaX = event.clientX - dragStartX;
            const deltaY = event.clientY - dragStartY;
            
            // Considérer comme un drag si mouvement > 5px
            if (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5) {
                dragMoved = true;
            }
            
            const node = document.getElementById(`char-node-${draggedCharId}`);
            if (!node) return;
            
            const graph = document.getElementById('relationsGraph');
            const graphRect = graph.getBoundingClientRect();
            
            // Position actuelle
            const currentLeft = parseFloat(node.style.left);
            const currentTop = parseFloat(node.style.top);
            
            // Nouvelle position
            let newLeft = currentLeft + deltaX;
            let newTop = currentTop + deltaY;
            
            // Limiter aux bords du graphe
            newLeft = Math.max(50, Math.min(graphRect.width - 50, newLeft));
            newTop = Math.max(50, Math.min(graphRect.height - 50, newTop));
            
            node.style.left = newLeft + 'px';
            node.style.top = newTop + 'px';
            
            dragStartX = event.clientX;
            dragStartY = event.clientY;
            
            // Mettre à jour les lignes SVG
            updateRelationLines();
        }
        
        function stopDragCharacter(event) {
            if (!isDragging) return;
            
            document.removeEventListener('mousemove', dragCharacter);
            document.removeEventListener('mouseup', stopDragCharacter);
            
            if (dragMoved) {
                // Sauvegarder la nouvelle position
                const node = document.getElementById(`char-node-${draggedCharId}`);
                if (node) {
                    if (!project.characterPositions) project.characterPositions = {};
                    project.characterPositions[draggedCharId] = {
                        x: parseFloat(node.style.left),
                        y: parseFloat(node.style.top)
                    };
                    saveProject();
                    showNotification('📍 Position sauvegardée');
                }
            }
            
            isDragging = false;
            draggedCharId = null;
            dragMoved = false;
        }
        
        function handleCharacterClick(event, charId) {
            // Ne pas traiter comme un clic si c'était un drag
            if (dragMoved) {
                event.stopPropagation();
                return;
            }
            
            selectCharacterForRelation(charId);
        }
        
        function updateRelationLines() {
            const svg = document.getElementById('relationsSvg');
            if (!svg) return;
            
            const relationTypes = {
                'amour': { color: '#e91e63', icon: '❤️' },
                'amitie': { color: '#4caf50', icon: '🤝' },
                'rivalite': { color: '#f44336', icon: '⚔️' },
                'famille': { color: '#2196f3', icon: '👨‍👩‍👧' },
                'mentor': { color: '#ff9800', icon: '📚' },
                'ennemi': { color: '#9c27b0', icon: '💀' },
                'alliance': { color: '#00bcd4', icon: '🤜🤛' },
                'neutre': { color: '#757575', icon: '😐' }
            };
            
            let svgContent = '';
            
            project.relations.forEach(rel => {
                const char1 = project.characters.find(c => c.id === rel.char1Id);
                const char2 = project.characters.find(c => c.id === rel.char2Id);
                
                if (char1 && char2) {
                    const node1 = document.getElementById(`char-node-${char1.id}`);
                    const node2 = document.getElementById(`char-node-${char2.id}`);
                    
                    if (node1 && node2) {
                        const x1 = parseFloat(node1.style.left);
                        const y1 = parseFloat(node1.style.top);
                        const x2 = parseFloat(node2.style.left);
                        const y2 = parseFloat(node2.style.top);
                        
                        const relType = relationTypes[rel.type] || relationTypes['neutre'];
                        
                        svgContent += `
                            <line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" 
                                  stroke="${relType.color}" 
                                  stroke-width="3" 
                                  opacity="0.7"
                                  style="cursor: pointer;"
                                  onclick="editRelation('${rel.id}')"/>
                            <text x="${(x1 + x2) / 2}" y="${(y1 + y2) / 2 - 10}" 
                                  fill="${relType.color}" 
                                  font-size="20" 
                                  text-anchor="middle"
                                  style="pointer-events: none;">${relType.icon}</text>
                        `;
                    }
                }
            });
            
            svg.innerHTML = svgContent;
        }
        
        function resetCharacterPositions() {
            if (confirm('Réinitialiser toutes les positions des personnages ?')) {
                project.characterPositions = {};
                saveProject();
                renderRelationsView();
                showNotification('🔄 Positions réinitialisées');
            }
        }
        
        function autoArrangeCharacters() {
            // Arranger en cercle avec plus d'espace
            const centerX = 400;
            const centerY = 350;
            const radius = 220;
            
            project.characterPositions = {};
            project.characters.forEach((char, i) => {
                const angle = (i / project.characters.length) * 2 * Math.PI;
                project.characterPositions[char.id] = {
                    x: centerX + radius * Math.cos(angle),
                    y: centerY + radius * Math.sin(angle)
                };
            });
            
            saveProject();
            renderRelationsView();
            showNotification('✨ Personnages arrangés automatiquement');
        }
        
        // Variables pour la sélection de personnages
        let selectedCharsForRelation = [];
        
        function selectCharacterForRelation(charId) {
            if (selectedCharsForRelation.includes(charId)) {
                // Désélectionner
                selectedCharsForRelation = selectedCharsForRelation.filter(id => id !== charId);
            } else {
                selectedCharsForRelation.push(charId);
            }
            
            // Si 2 personnages sélectionnés, demander le type de relation
            if (selectedCharsForRelation.length === 2) {
                createRelationModal();
            } else {
                renderRelationsView();
            }
        }
        
        function createRelationModal() {
            const char1 = project.characters.find(c => c.id === selectedCharsForRelation[0]);
            const char2 = project.characters.find(c => c.id === selectedCharsForRelation[1]);
            
            const relationTypes = {
                'amour': { color: '#e91e63', label: '❤️ Amour' },
                'amitie': { color: '#4caf50', label: '🤝 Amitié' },
                'rivalite': { color: '#f44336', label: '⚔️ Rivalité' },
                'famille': { color: '#2196f3', label: '👨‍👩‍👧 Famille' },
                'mentor': { color: '#ff9800', label: '📚 Mentor' },
                'ennemi': { color: '#9c27b0', label: '💀 Ennemi' },
                'alliance': { color: '#00bcd4', label: '🤜🤛 Alliance' },
                'neutre': { color: '#757575', label: '😐 Neutre' }
            };
            
            const modalHTML = `
                <div class="modal active" id="relationModal" onclick="if(event.target===this) closeRelationModal()">
                    <div class="modal-content" style="max-width: 500px;">
                        <h2 style="margin-bottom: 1.5rem;">🔗 Créer une relation</h2>
                        
                        <div style="margin-bottom: 1.5rem; padding: 1rem; background: var(--bg-secondary); border-radius: 8px; text-align: center;">
                            <span style="font-weight: 600; font-size: 1.1rem;">${char1.name}</span>
                            <span style="margin: 0 1rem; color: var(--text-muted);">↔</span>
                            <span style="font-weight: 600; font-size: 1.1rem;">${char2.name}</span>
                        </div>
                        
                        <div style="margin-bottom: 1.5rem;">
                            <label style="display: block; font-weight: 600; margin-bottom: 0.75rem;">Type de relation:</label>
                            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.5rem;">
                                ${Object.entries(relationTypes).map(([key, rel]) => `
                                    <button class="btn" onclick="selectRelationType('${key}')" 
                                            id="relType-${key}"
                                            style="justify-content: flex-start; text-align: left; padding: 0.75rem;">
                                        <div style="width: 4px; height: 100%; background: ${rel.color}; position: absolute; left: 0; top: 0; bottom: 0;"></div>
                                        ${rel.label}
                                    </button>
                                `).join('')}
                            </div>
                        </div>
                        
                        <div style="margin-bottom: 1.5rem;">
                            <label style="display: block; font-weight: 600; margin-bottom: 0.5rem;">Description (optionnel):</label>
                            <input type="text" class="form-input" id="relationDescription" placeholder="Ex: Frère et sœur, alliés depuis l'enfance...">
                        </div>
                        
                        <div style="display: flex; gap: 0.5rem; justify-content: flex-end;">
                            <button class="btn" onclick="closeRelationModal()">Annuler</button>
                            <button class="btn btn-primary" onclick="saveRelation()" id="saveRelationBtn" disabled>Créer la relation</button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', modalHTML);
        }
        
        let selectedRelationType = null;
        
        function selectRelationType(type) {
            selectedRelationType = type;
            
            // Mettre à jour l'UI
            document.querySelectorAll('[id^="relType-"]').forEach(btn => {
                btn.classList.remove('btn-primary');
            });
            document.getElementById(`relType-${type}`).classList.add('btn-primary');
            document.getElementById('saveRelationBtn').disabled = false;
        }
        
        function saveRelation() {
            if (!selectedRelationType) return;
            
            const description = document.getElementById('relationDescription').value;
            
            if (!project.relations) project.relations = [];
            
            project.relations.push({
                id: 'rel_' + Date.now(),
                char1Id: selectedCharsForRelation[0],
                char2Id: selectedCharsForRelation[1],
                type: selectedRelationType,
                description: description,
                createdAt: new Date().toISOString()
            });
            
            saveProject();
            closeRelationModal();
            selectedCharsForRelation = [];
            selectedRelationType = null;
            renderRelationsView();
            showNotification('🔗 Relation créée');
        }
        
        function closeRelationModal() {
            const modal = document.getElementById('relationModal');
            if (modal) modal.remove();
            selectedCharsForRelation = [];
            selectedRelationType = null;
            renderRelationsView();
        }
        
        function getRelationCount(type) {
            if (!project.relations) return 0;
            return project.relations.filter(r => r.type === type).length;
        }
        
        function editRelation(relId) {
            const relation = project.relations.find(r => r.id === relId);
            if (!relation) return;
            
            // Pour l'instant, juste permettre de changer la description
            const newDesc = prompt('Modifier la description:', relation.description || '');
            if (newDesc !== null) {
                relation.description = newDesc;
                saveProject();
                renderRelationsView();
                showNotification('✏️ Relation modifiée');
            }
        }
        
        function deleteRelation(relId) {
            if (confirm('Supprimer cette relation ?')) {
                project.relations = project.relations.filter(r => r.id !== relId);
                saveProject();
                renderRelationsView();
                showNotification('🗑️ Relation supprimée');
            }
        }
        
        function exportRelations() {
            alert('Export graphique des relations à venir');
        }
        
        // ============================================
        // MAP FUNCTIONS
        // ============================================
        
        function renderMapView() {
            const editorView = document.getElementById('editorView');
            if (!editorView) {
                console.error('editorView not found');
                return;
            }
            
            // S'assurer que mapLocations et mapImage existent
            if (!project.mapLocations) project.mapLocations = [];
            if (!project.mapImage) project.mapImage = null;
            
            let mapContent = '';
            if (project.mapImage) {
                mapContent = `
                    <div style="position: relative; display: inline-block; max-width: 100%;">
                        <img src="${project.mapImage}" 
                             id="worldMapImage"
                             style="max-width: 100%; height: auto; display: block; cursor: crosshair; border: 2px solid var(--border-color); border-radius: 4px;" 
                             alt="Carte du monde"
                             onclick="handleMapClick(event)">
                        ${project.mapLocations.map((loc, i) => `
                            <div class="map-location" 
                                 style="position: absolute; left: ${loc.x}%; top: ${loc.y}%; 
                                        width: 20px; height: 20px; 
                                        background: var(--accent-red); 
                                        border: 2px solid white;
                                        border-radius: 50%; 
                                        transform: translate(-50%, -50%);
                                        cursor: pointer;
                                        box-shadow: 0 2px 8px rgba(0,0,0,0.3);
                                        z-index: 10;"
                                 title="${loc.name}"
                                 onclick="event.stopPropagation(); editMapLocation(${i})">
                                <div style="position: absolute; top: -30px; left: 50%; transform: translateX(-50%);
                                           background: var(--bg-accent); color: white; padding: 0.25rem 0.5rem;
                                           border-radius: 4px; white-space: nowrap; font-size: 0.75rem;
                                           pointer-events: none; opacity: 0; transition: opacity 0.2s;"
                                     class="map-location-label">${loc.name}</div>
                            </div>
                        `).join('')}
                    </div>
                    <style>
                        .map-location:hover .map-location-label {
                            opacity: 1 !important;
                        }
                    </style>
                `;
            } else {
                mapContent = `
                    <div style="padding: 4rem; text-align: center; background: var(--bg-secondary); border-radius: 8px; border: 2px dashed var(--border-color);">
                        <div style="font-size: 4rem; margin-bottom: 1rem;">🗺️</div>
                        <div style="font-size: 1.2rem; font-weight: 600; margin-bottom: 0.5rem;">Aucune carte chargée</div>
                        <div style="color: var(--text-muted); margin-bottom: 1.5rem;">Cliquez sur "Charger carte" pour ajouter une image</div>
                        <button class="btn btn-primary" onclick="uploadMapImage()">📤 Charger une carte</button>
                    </div>
                `;
            }
            
            editorView.innerHTML = `
                <div style="height: 100%; overflow-y: auto; padding: 2rem 3rem;">
                    <h2 style="margin-bottom: 2rem; color: var(--accent-gold);">🗺️ Carte Géographique</h2>
                    
                    <div style="margin-bottom: 2rem; display: flex; gap: 0.5rem; flex-wrap: wrap;">
                        <button class="btn btn-primary" onclick="uploadMapImage()">🖼️ Charger carte</button>
                        <button class="btn" onclick="addMapLocation()" ${!project.mapImage ? 'disabled' : ''}>📍 Ajouter lieu</button>
                        <button class="btn btn-small" onclick="clearMap()" ${!project.mapImage ? 'disabled' : ''}>🗑️ Effacer carte</button>
                        <button class="btn btn-small" onclick="exportMapData()">💾 Exporter données</button>
                    </div>
                    
                    <div style="background: var(--bg-secondary); padding: 2rem; border-radius: 8px; text-align: center;">
                        ${mapContent}
                    </div>
                    
                    ${project.mapLocations.length > 0 ? `
                        <div style="margin-top: 2rem; background: var(--bg-secondary); padding: 1.5rem; border-radius: 8px;">
                            <h3 style="margin-bottom: 1rem; color: var(--text-primary);">📍 Lieux marqués (${project.mapLocations.length})</h3>
                            <div style="display: grid; gap: 0.5rem;">
                                ${project.mapLocations.map((loc, i) => `
                                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.75rem; background: var(--bg-primary); border-radius: 4px;">
                                        <span style="font-weight: 500;">${loc.name}</span>
                                        <div style="display: flex; gap: 0.5rem;">
                                            <button class="btn btn-small" onclick="editMapLocation(${i})">✏️</button>
                                            <button class="btn btn-small" onclick="deleteMapLocation(${i})">🗑️</button>
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    ` : ''}
                    
                    <div style="margin-top: 2rem; padding: 1.5rem; background: var(--bg-secondary); border-radius: 8px; border-left: 4px solid var(--accent-gold);">
                        <p style="font-size: 0.95rem; color: var(--text-secondary); line-height: 1.6;">
                            💡 <strong>Utilisation:</strong><br>
                            1. Chargez une image de carte (dessinée à la main, générée par IA, etc.)<br>
                            2. Cliquez directement sur la carte pour placer un marqueur<br>
                            3. Cliquez sur un marqueur existant pour le modifier ou le supprimer
                        </p>
                    </div>
                </div>
            `;
        }
        
        function handleMapClick(event) {
            // S'assurer que mapLocations existe
            if (!project.mapLocations) project.mapLocations = [];
            
            const img = event.target;
            const rect = img.getBoundingClientRect();
            const x = ((event.clientX - rect.left) / rect.width) * 100;
            const y = ((event.clientY - rect.top) / rect.height) * 100;
            
            const name = prompt('Nom du lieu:');
            if (name) {
                project.mapLocations.push({
                    name: name,
                    x: Math.max(0, Math.min(100, x)),
                    y: Math.max(0, Math.min(100, y)),
                    description: ''
                });
                saveProject();
                renderMapView();
                showNotification(`📍 Lieu "${name}" ajouté`);
            }
        }
        
        function uploadMapImage() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        project.mapImage = event.target.result;
                        saveProject();
                        renderMapView();
                    };
                    reader.readAsDataURL(file);
                }
            };
            input.click();
        }
        
        function addMapLocation() {
            if (!project.mapImage) {
                alert('Veuillez d\'abord charger une carte');
                return;
            }
            // S'assurer que mapLocations existe
            if (!project.mapLocations) project.mapLocations = [];
            
            const name = prompt('Nom du lieu:');
            if (name) {
                project.mapLocations.push({
                    name: name,
                    x: 50 + Math.random() * 40,
                    y: 30 + Math.random() * 40,
                    description: ''
                });
                saveProject();
                renderMapView();
            }
        }
        
        function editMapLocation(index) {
            const loc = project.mapLocations[index];
            const newName = prompt('Modifier le nom:', loc.name);
            if (newName) {
                loc.name = newName;
                saveProject();
                renderMapView();
                showNotification(`✏️ Lieu modifié: ${newName}`);
            }
        }
        
        function deleteMapLocation(index) {
            const loc = project.mapLocations[index];
            if (confirm(`Supprimer le lieu "${loc.name}" ?`)) {
                project.mapLocations.splice(index, 1);
                saveProject();
                renderMapView();
                showNotification(`🗑️ Lieu supprimé: ${loc.name}`);
            }
        }
        
        function clearMap() {
            if (confirm('Effacer la carte et tous les lieux ?')) {
                project.mapImage = null;
                project.mapLocations = [];
                saveProject();
                renderMapView();
                showNotification('🗑️ Carte effacée');
            }
        }
        
        function exportMapData() {
            const data = {
                image: project.mapImage ? 'Image présente' : 'Pas d\'image',
                locations: project.mapLocations
            };
            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `carte_${project.title.replace(/[^a-z0-9]/gi, '_')}.json`;
            a.click();
            showNotification('💾 Données de la carte exportées');
        }
        
        // ============================================
        // TIMELINE VIZ FUNCTIONS
        // ============================================
        
        function renderTimelineVizView() {
            const container = document.getElementById('timelineVizList');
            if (!container) {
                console.error('timelineVizList container not found');
                return;
            }
            
            // S'assurer que visualTimeline existe
            if (!project.visualTimeline) {
                project.visualTimeline = [];
            }
            
            // Compter les événements
            const eventCount = project.visualTimeline.length;
            
            container.innerHTML = `
                <div style="padding: 1rem;">
                    <h3 style="margin-bottom: 1rem;">⏳ Timeline Visuelle</h3>
                    <div style="font-size: 0.85rem; color: var(--text-secondary); line-height: 1.6;">
                        <div style="margin-bottom: 0.5rem;">📅 ${eventCount} événement(s)</div>
                        <div style="margin-top: 1rem;">
                            <button class="btn btn-primary" onclick="addTimelineVizEvent()" style="width: 100%;">
                                + Ajouter événement
                            </button>
                        </div>
                    </div>
                    ${eventCount > 0 ? `
                        <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--border-color);">
                            <div style="font-size: 0.85rem; font-weight: 600; margin-bottom: 0.5rem;">Événements:</div>
                            ${project.visualTimeline.map((event, i) => `
                                <div style="padding: 0.5rem; margin-bottom: 0.5rem; background: var(--bg-primary); border-radius: 4px; font-size: 0.85rem;">
                                    <div style="font-weight: 600;">${event.title}</div>
                                    <div style="color: var(--text-muted); font-size: 0.75rem;">${event.date || 'Sans date'}</div>
                                </div>
                            `).join('')}
                        </div>
                    ` : ''}
                </div>
            `;
            
            const editorView = document.getElementById('editorView');
            
            // Générer la timeline à partir des événements
            let timelineHTML = '';
            if (project.visualTimeline.length > 0) {
                timelineHTML = project.visualTimeline.map((event, index) => `
                    <div class="timeline-viz-item">
                        <div class="timeline-viz-marker" onclick="editTimelineVizEvent(${event.id})" title="Cliquez pour éditer"></div>
                        <div class="timeline-viz-content">
                            <div class="timeline-viz-date">${event.date || 'Date non définie'}</div>
                            <div class="timeline-viz-title">${event.title}</div>
                            <div class="timeline-viz-description">${event.description || 'Aucune description'}</div>
                        </div>
                    </div>
                `).join('');
            } else {
                timelineHTML = `
                    <div style="position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); text-align: center; color: var(--text-muted); max-width: 400px;">
                        <div style="font-size: 4rem; margin-bottom: 1rem; opacity: 0.5;">⏳</div>
                        <div style="font-size: 1.2rem; font-weight: 600; margin-bottom: 0.5rem;">Aucun événement dans la timeline</div>
                        <div style="margin-bottom: 1.5rem;">Cliquez sur "+ Événement" pour ajouter votre premier événement chronologique</div>
                        <button class="btn btn-primary" onclick="addTimelineVizEvent()">+ Créer le premier événement</button>
                    </div>
                `;
            }
            
            editorView.innerHTML = `
                <div style="padding: 2rem;">
                    <div class="visualization-toolbar">
                        <button class="viz-tool-btn active">Vue chronologique</button>
                        <button class="viz-tool-btn" onclick="sortTimelineByDate()">Trier par date</button>
                        <button class="viz-tool-btn" onclick="addTimelineVizEvent()">+ Événement</button>
                        <button class="viz-tool-btn" onclick="importTimelineCSV()">📥 Importer CSV</button>
                        <button class="viz-tool-btn" onclick="exportTimelineCSV()">📤 Exporter CSV</button>
                        <button class="viz-tool-btn" onclick="clearTimeline()">🗑️ Tout effacer</button>
                    </div>
                    <div class="visualization-canvas">
                        <div class="timeline-viz-container" style="min-height: 400px; position: relative;">
                            <div class="timeline-viz" style="position: relative;">
                                ${project.visualTimeline.length > 0 ? '<div class="timeline-viz-line"></div>' : ''}
                                ${timelineHTML}
                            </div>
                        </div>
                    </div>
                    <div style="margin-top: 1rem; padding: 1rem; background: var(--bg-secondary); border-radius: 4px;">
                        <p style="font-size: 0.9rem; color: var(--text-secondary);">
                            💡 <strong>Organisation:</strong> Visualisez chronologiquement les événements majeurs de votre histoire. Cliquez sur les marqueurs pour éditer les événements.
                        </p>
                    </div>
                </div>
            `;
        }
        
        function addTimelineVizEvent() {
            const title = prompt('Titre de l\'événement:');
            if (!title || title.trim() === '') {
                return;
            }
            
            const date = prompt('Date de l\'événement (optionnel):');
            const description = prompt('Description (optionnel):');
            
            const event = {
                id: Date.now(),
                title: title.trim(),
                date: date ? date.trim() : '',
                description: description ? description.trim() : '',
                order: project.visualTimeline.length
            };
            
            if (!project.visualTimeline) {
                project.visualTimeline = [];
            }
            
            project.visualTimeline.push(event);
            saveProject();
            renderTimelineVizView();
            
            // Notification de succès
            showNotification('✓ Événement ajouté à la timeline');
        }
        
        function editTimelineVizEvent(id) {
            const event = project.visualTimeline.find(e => e.id === id);
            if (!event) return;
            
            const newTitle = prompt('Modifier le titre:', event.title);
            if (newTitle === null) return;
            
            if (newTitle.trim() !== '') {
                event.title = newTitle.trim();
                
                const newDate = prompt('Modifier la date:', event.date);
                if (newDate !== null) {
                    event.date = newDate.trim();
                }
                
                const newDesc = prompt('Modifier la description:', event.description);
                if (newDesc !== null) {
                    event.description = newDesc.trim();
                }
                
                saveProject();
                renderTimelineVizView();
                showNotification('✓ Événement mis à jour');
            }
        }
        
        function sortTimelineByDate() {
            if (!project.visualTimeline || project.visualTimeline.length === 0) return;
            
            // Trier par date (les événements sans date vont à la fin)
            project.visualTimeline.sort((a, b) => {
                if (!a.date && !b.date) return 0;
                if (!a.date) return 1;
                if (!b.date) return -1;
                return a.date.localeCompare(b.date);
            });
            
            saveProject();
            renderTimelineVizView();
            showNotification('✓ Timeline triée par date');
        }
        
        function clearTimeline() {
            if (!project.visualTimeline || project.visualTimeline.length === 0) return;
            
            if (confirm(`Effacer tous les ${project.visualTimeline.length} événements de la timeline ?`)) {
                project.visualTimeline = [];
                saveProject();
                renderTimelineVizView();
                showNotification('✓ Timeline effacée');
            }
        }
        
        function exportTimelineViz() {
            if (!project.visualTimeline || project.visualTimeline.length === 0) {
                alert('Aucun événement à exporter');
                return;
            }
            
            // Créer un export HTML de la timeline
            let html = `
                <!DOCTYPE html>
                <html lang="fr">
                <head>
                    <meta charset="UTF-8">
                    <meta name="viewport" content="width=device-width, initial-scale=1.0">
                    <title>${project.title} - Timeline</title>
                    <style>
                        body { font-family: Arial, sans-serif; padding: 2rem; background: #f5f5f5; }
                        h1 { color: #333; }
                        .timeline-container { background: white; padding: 2rem; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
                        .event { margin-bottom: 2rem; padding: 1rem; border-left: 4px solid #d4af37; background: #fafafa; }
                        .event-date { font-size: 0.9rem; color: #666; margin-bottom: 0.5rem; }
                        .event-title { font-size: 1.2rem; font-weight: bold; color: #333; margin-bottom: 0.5rem; }
                        .event-description { color: #555; line-height: 1.6; }
                    </style>
                </head>
                <body>
                    <h1>${project.title} - Timeline</h1>
                    <div class="timeline-container">
                        ${project.visualTimeline.map((event, i) => `
                            <div class="event">
                                <div class="event-date">${event.date || 'Date non définie'}</div>
                                <div class="event-title">${i + 1}. ${event.title}</div>
                                ${event.description ? `<div class="event-description">${event.description}</div>` : ''}
                            </div>
                        `).join('')}
                    </div>
                </body>
                </html>
            `;
            
            const blob = new Blob([html], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${project.title}_timeline.html`;
            a.click();
            URL.revokeObjectURL(url);
            
            showNotification('✓ Timeline exportée');
        }
        
        // ============================================
        // IMPORT/EXPORT CSV POUR TIMELINE
        // ============================================
        
        function importTimelineCSV() {
            // Créer un input file invisible
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.csv';
            
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        parseTimelineCSV(event.target.result);
                    } catch (error) {
                        alert('Erreur lors de la lecture du fichier CSV:\n' + error.message);
                    }
                };
                reader.readAsText(file);
            };
            
            input.click();
        }
        
        function parseTimelineCSV(csvContent) {
            // Parser le CSV
            const lines = csvContent.split('\n').filter(line => line.trim() !== '');
            
            if (lines.length === 0) {
                alert('Le fichier CSV est vide');
                return;
            }
            
            // Vérifier l'en-tête
            const header = lines[0].toLowerCase();
            let hasHeader = false;
            
            // Formats acceptés:
            // - titre,date,description
            // - title,date,description
            // - événement,date,description
            if (header.includes('titre') || header.includes('title') || header.includes('événement') || 
                header.includes('date') || header.includes('description')) {
                hasHeader = true;
                lines.shift(); // Retirer l'en-tête
            }
            
            if (lines.length === 0) {
                alert('Le fichier CSV ne contient aucun événement (uniquement l\'en-tête)');
                return;
            }
            
            // Confirmer l'import
            const confirmMsg = `Importer ${lines.length} événement(s) ?\n\n` +
                              (project.visualTimeline.length > 0 
                                ? `⚠️ Les ${project.visualTimeline.length} événements existants seront remplacés.`
                                : 'La timeline actuelle est vide.');
            
            if (!confirm(confirmMsg)) {
                return;
            }
            
            // Parser les événements
            const newEvents = [];
            let errors = [];
            
            lines.forEach((line, index) => {
                try {
                    // Parser la ligne CSV (gère les guillemets)
                    const parts = parseCSVLine(line);
                    
                    if (parts.length < 1) {
                        errors.push(`Ligne ${index + 1}: vide`);
                        return;
                    }
                    
                    const title = parts[0]?.trim() || '';
                    const date = parts[1]?.trim() || '';
                    const description = parts[2]?.trim() || '';
                    
                    if (!title) {
                        errors.push(`Ligne ${index + 1}: titre manquant`);
                        return;
                    }
                    
                    newEvents.push({
                        id: Date.now() + index,
                        title: title,
                        date: date,
                        description: description,
                        order: newEvents.length
                    });
                } catch (error) {
                    errors.push(`Ligne ${index + 1}: ${error.message}`);
                }
            });
            
            // Afficher les erreurs s'il y en a
            if (errors.length > 0 && errors.length < 5) {
                alert('⚠️ Erreurs détectées:\n\n' + errors.join('\n') + '\n\nLes autres événements seront importés.');
            } else if (errors.length >= 5) {
                alert(`⚠️ ${errors.length} erreurs détectées. Les événements valides seront importés.`);
            }
            
            // Remplacer la timeline
            if (newEvents.length > 0) {
                project.visualTimeline = newEvents;
                saveProject();
                renderTimelineVizView();
                showNotification(`✓ ${newEvents.length} événement(s) importé(s)`);
            } else {
                alert('❌ Aucun événement valide trouvé dans le fichier CSV');
            }
        }
        
        function parseCSVLine(line) {
            // Parser une ligne CSV en gérant les guillemets
            const result = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                
                if (char === '"') {
                    if (inQuotes && line[i + 1] === '"') {
                        // Double guillemet = guillemet échappé
                        current += '"';
                        i++;
                    } else {
                        // Toggle quotes
                        inQuotes = !inQuotes;
                    }
                } else if (char === ',' && !inQuotes) {
                    // Séparateur de colonne
                    result.push(current);
                    current = '';
                } else {
                    current += char;
                }
            }
            
            // Ajouter le dernier champ
            result.push(current);
            
            return result;
        }
        
        function exportTimelineCSV() {
            if (!project.visualTimeline || project.visualTimeline.length === 0) {
                alert('Aucun événement à exporter');
                return;
            }
            
            // Créer le CSV avec en-tête
            let csv = 'Titre,Date,Description\n';
            
            project.visualTimeline.forEach(event => {
                // Échapper les guillemets et entourer de guillemets si nécessaire
                const title = escapeCSVField(event.title);
                const date = escapeCSVField(event.date || '');
                const description = escapeCSVField(event.description || '');
                
                csv += `${title},${date},${description}\n`;
            });
            
            // Télécharger le fichier
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${project.title}_timeline.csv`;
            a.click();
            URL.revokeObjectURL(url);
            
            showNotification(`✓ ${project.visualTimeline.length} événement(s) exporté(s) en CSV`);
        }
        
        function escapeCSVField(field) {
            if (!field) return '""';
            
            // Si le champ contient des virgules, guillemets ou retours à la ligne, l'entourer de guillemets
            if (field.includes(',') || field.includes('"') || field.includes('\n')) {
                // Doubler les guillemets existants
                field = field.replace(/"/g, '""');
                return `"${field}"`;
            }
            
            return field;
        }

        // ===================================
        // SYSTÈME DE GESTION DES THÈMES
        // ===================================
        
        // Utilitaire : convertir rgba/rgb/hex en hex
        function rgbaToHex(color) {
            if (!color) return '#000000';
            
            // Si c'est déjà un hex
            if (color.startsWith('#')) {
                return color.length === 7 ? color : color + 'FF';
            }
            
            // Si c'est rgba ou rgb
            const match = color.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
            if (match) {
                const r = parseInt(match[1]);
                const g = parseInt(match[2]);
                const b = parseInt(match[3]);
                return '#' + [r, g, b].map(x => {
                    const hex = x.toString(16);
                    return hex.length === 1 ? '0' + hex : hex;
                }).join('');
            }
            
            return '#000000';
        }
        
        const themeManager = {
            currentTheme: null,
            customThemes: [],
            
            defaultVariables: {
                '--bg-primary': '#faf9f6',
                '--bg-secondary': '#f5f3ed',
                '--bg-accent': '#2a2622',
                '--text-primary': '#2a2622',
                '--text-secondary': '#5a5550',
                '--text-muted': '#8a847d',
                '--border-color': '#d4cfc5',
                '--accent-red': '#c44536',
                '--accent-gold': '#d4af37',
                '--highlight-yellow': 'rgba(255, 235, 59, 0.4)',
                '--highlight-green': 'rgba(76, 175, 80, 0.3)',
                '--highlight-blue': 'rgba(33, 150, 243, 0.3)',
                '--highlight-red': 'rgba(244, 67, 54, 0.3)',
                '--highlight-purple': 'rgba(156, 39, 176, 0.3)'
            },
            
            presetThemes: {
                'Classique': {
                    '--bg-primary': '#faf9f6',
                    '--bg-secondary': '#f5f3ed',
                    '--bg-accent': '#2a2622',
                    '--text-primary': '#2a2622',
                    '--text-secondary': '#5a5550',
                    '--text-muted': '#8a847d',
                    '--border-color': '#d4cfc5',
                    '--accent-red': '#c44536',
                    '--accent-gold': '#d4af37',
                    '--highlight-yellow': 'rgba(255, 235, 59, 0.4)',
                    '--highlight-green': 'rgba(76, 175, 80, 0.3)',
                    '--highlight-blue': 'rgba(33, 150, 243, 0.3)',
                    '--highlight-red': 'rgba(244, 67, 54, 0.3)',
                    '--highlight-purple': 'rgba(156, 39, 176, 0.3)'
                },
                'Sombre': {
                    '--bg-primary': '#1a1a1a',
                    '--bg-secondary': '#252525',
                    '--bg-accent': '#f5f3ed',
                    '--text-primary': '#e8e6e3',
                    '--text-secondary': '#b8b6b3',
                    '--text-muted': '#888683',
                    '--border-color': '#3a3a3a',
                    '--accent-red': '#ff6b5a',
                    '--accent-gold': '#ffd700',
                    '--highlight-yellow': 'rgba(255, 235, 59, 0.3)',
                    '--highlight-green': 'rgba(76, 175, 80, 0.25)',
                    '--highlight-blue': 'rgba(33, 150, 243, 0.25)',
                    '--highlight-red': 'rgba(244, 67, 54, 0.25)',
                    '--highlight-purple': 'rgba(156, 39, 176, 0.25)'
                },
                'Océan': {
                    '--bg-primary': '#e8f4f8',
                    '--bg-secondary': '#d0e8f0',
                    '--bg-accent': '#1e3a52',
                    '--text-primary': '#1e3a52',
                    '--text-secondary': '#2a5270',
                    '--text-muted': '#5a7a90',
                    '--border-color': '#a8c8d8',
                    '--accent-red': '#c84a4a',
                    '--accent-gold': '#3498db',
                    '--highlight-yellow': 'rgba(255, 235, 59, 0.3)',
                    '--highlight-green': 'rgba(46, 204, 113, 0.3)',
                    '--highlight-blue': 'rgba(52, 152, 219, 0.4)',
                    '--highlight-red': 'rgba(231, 76, 60, 0.3)',
                    '--highlight-purple': 'rgba(155, 89, 182, 0.3)'
                },
                'Forêt': {
                    '--bg-primary': '#f0f4ed',
                    '--bg-secondary': '#e1e8dc',
                    '--bg-accent': '#2d3e2d',
                    '--text-primary': '#2d3e2d',
                    '--text-secondary': '#4a5e4a',
                    '--text-muted': '#7a8a7a',
                    '--border-color': '#c1d0bb',
                    '--accent-red': '#c44536',
                    '--accent-gold': '#6b8e23',
                    '--highlight-yellow': 'rgba(255, 235, 59, 0.3)',
                    '--highlight-green': 'rgba(107, 142, 35, 0.4)',
                    '--highlight-blue': 'rgba(70, 130, 180, 0.3)',
                    '--highlight-red': 'rgba(178, 34, 34, 0.3)',
                    '--highlight-purple': 'rgba(147, 112, 219, 0.3)'
                },
                'Crépuscule': {
                    '--bg-primary': '#2b2d42',
                    '--bg-secondary': '#3a3d54',
                    '--bg-accent': '#edf2f4',
                    '--text-primary': '#edf2f4',
                    '--text-secondary': '#c5cad4',
                    '--text-muted': '#8d99ae',
                    '--border-color': '#4a4d64',
                    '--accent-red': '#ef476f',
                    '--accent-gold': '#ffd166',
                    '--highlight-yellow': 'rgba(255, 209, 102, 0.3)',
                    '--highlight-green': 'rgba(6, 214, 160, 0.3)',
                    '--highlight-blue': 'rgba(118, 171, 174, 0.3)',
                    '--highlight-red': 'rgba(239, 71, 111, 0.3)',
                    '--highlight-purple': 'rgba(177, 98, 134, 0.3)'
                },
                'Sépia': {
                    '--bg-primary': '#f4ecd8',
                    '--bg-secondary': '#e8dcc4',
                    '--bg-accent': '#3e2723',
                    '--text-primary': '#3e2723',
                    '--text-secondary': '#5d4037',
                    '--text-muted': '#8d6e63',
                    '--border-color': '#d7cdb8',
                    '--accent-red': '#bf360c',
                    '--accent-gold': '#a1887f',
                    '--highlight-yellow': 'rgba(255, 224, 130, 0.4)',
                    '--highlight-green': 'rgba(139, 195, 74, 0.3)',
                    '--highlight-blue': 'rgba(121, 134, 203, 0.3)',
                    '--highlight-red': 'rgba(191, 54, 12, 0.3)',
                    '--highlight-purple': 'rgba(142, 110, 99, 0.3)'
                },
                'Minuit': {
                    '--bg-primary': '#0d1b2a',
                    '--bg-secondary': '#1b263b',
                    '--bg-accent': '#e0e1dd',
                    '--text-primary': '#e0e1dd',
                    '--text-secondary': '#c0c2be',
                    '--text-muted': '#778da9',
                    '--border-color': '#2b3a4f',
                    '--accent-red': '#e63946',
                    '--accent-gold': '#f1faee',
                    '--highlight-yellow': 'rgba(241, 250, 238, 0.2)',
                    '--highlight-green': 'rgba(168, 218, 220, 0.2)',
                    '--highlight-blue': 'rgba(69, 123, 157, 0.3)',
                    '--highlight-red': 'rgba(230, 57, 70, 0.3)',
                    '--highlight-purple': 'rgba(163, 177, 138, 0.2)'
                },
                'Pastel': {
                    '--bg-primary': '#fff5f7',
                    '--bg-secondary': '#ffe8ec',
                    '--bg-accent': '#4a4a4a',
                    '--text-primary': '#2a2a2a',
                    '--text-secondary': '#5a5a5a',
                    '--text-muted': '#8a8a8a',
                    '--border-color': '#ffd4dc',
                    '--accent-red': '#ff6b9d',
                    '--accent-gold': '#c9ada7',
                    '--highlight-yellow': 'rgba(255, 223, 186, 0.5)',
                    '--highlight-green': 'rgba(186, 220, 180, 0.5)',
                    '--highlight-blue': 'rgba(173, 216, 230, 0.5)',
                    '--highlight-red': 'rgba(255, 182, 193, 0.5)',
                    '--highlight-purple': 'rgba(221, 160, 221, 0.5)'
                }
            },
            
            init() {
                this.loadCustomThemes();
                this.loadCurrentTheme();
            },
            
            applyTheme(colors) {
                const root = document.documentElement;
                Object.entries(colors).forEach(([variable, value]) => {
                    root.style.setProperty(variable, value);
                });
                this.currentTheme = colors;
                this.saveCurrentTheme();
            },
            
            saveCurrentTheme() {
                localStorage.setItem('novelcraft-current-theme', JSON.stringify(this.currentTheme));
            },
            
            loadCurrentTheme() {
                const saved = localStorage.getItem('novelcraft-current-theme');
                if (saved) {
                    try {
                        this.currentTheme = JSON.parse(saved);
                        this.applyTheme(this.currentTheme);
                    } catch (e) {
                        console.error('Erreur chargement thème', e);
                    }
                }
            },
            
            saveCustomThemes() {
                localStorage.setItem('novelcraft-custom-themes', JSON.stringify(this.customThemes));
            },
            
            loadCustomThemes() {
                const saved = localStorage.getItem('novelcraft-custom-themes');
                if (saved) {
                    try {
                        this.customThemes = JSON.parse(saved);
                    } catch (e) {
                        console.error('Erreur chargement thèmes personnalisés', e);
                    }
                }
            },
            
            addCustomTheme(name, colors) {
                this.customThemes.push({ name, colors });
                this.saveCustomThemes();
            },
            
            deleteCustomTheme(name) {
                this.customThemes = this.customThemes.filter(t => t.name !== name);
                this.saveCustomThemes();
            },
            
            exportTheme(colors, name) {
                const theme = {
                    name: name,
                    colors: colors,
                    version: '1.0'
                };
                
                const json = JSON.stringify(theme, null, 2);
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `theme-${name.toLowerCase().replace(/\s+/g, '-')}.json`;
                a.click();
                URL.revokeObjectURL(url);
            },
            
            importTheme(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const theme = JSON.parse(e.target.result);
                            if (theme.colors && theme.name) {
                                resolve(theme);
                            } else {
                                reject(new Error('Format de thème invalide'));
                            }
                        } catch (error) {
                            reject(error);
                        }
                    };
                    reader.onerror = () => reject(new Error('Erreur de lecture du fichier'));
                    reader.readAsText(file);
                });
            }
        };
        
        function openThemeManager() {
            const modal = document.createElement('div');
            modal.className = 'modal-overlay';
            modal.style.zIndex = '10000';
            
            const currentColors = {};
            Object.keys(themeManager.defaultVariables).forEach(variable => {
                const value = getComputedStyle(document.documentElement).getPropertyValue(variable);
                currentColors[variable] = value.trim();
            });
            
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 1000px; max-height: 90vh; overflow: hidden; display: flex; flex-direction: column;">
                    <div class="modal-header">
                        <h2>🎨 Gestionnaire de Thèmes</h2>
                        <button class="modal-close" onclick="this.closest('.modal-overlay').remove()">✕</button>
                    </div>
                    
                    <div style="flex: 1; overflow-y: auto; padding: 1.5rem;">
                        <!-- Thèmes prédéfinis -->
                        <div style="margin-bottom: 2rem;">
                            <h3 style="margin-bottom: 1rem; font-size: 1.2rem; color: var(--accent-gold);">
                                📚 Thèmes Prédéfinis
                            </h3>
                            <div id="presetThemesList" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 1rem;">
                            </div>
                        </div>
                        
                        <!-- Thèmes personnalisés -->
                        <div style="margin-bottom: 2rem;">
                            <h3 style="margin-bottom: 1rem; font-size: 1.2rem; color: var(--accent-gold);">
                                ✨ Mes Thèmes Personnalisés
                            </h3>
                            <div id="customThemesList" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 1rem;">
                            </div>
                        </div>
                        
                        <!-- Éditeur de couleurs -->
                        <div style="border-top: 2px solid var(--border-color); padding-top: 1.5rem;">
                            <h3 style="margin-bottom: 1rem; font-size: 1.2rem; color: var(--accent-gold);">
                                🎨 Éditeur de Thème
                            </h3>
                            
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 1rem; margin-bottom: 1.5rem;">
                                ${Object.entries(themeManager.defaultVariables).map(([variable, defaultValue]) => {
                                    const label = variable.replace('--', '').split('-').map(w => 
                                        w.charAt(0).toUpperCase() + w.slice(1)
                                    ).join(' ');
                                    
                                    const currentValue = currentColors[variable] || defaultValue;
                                    const hexColor = rgbaToHex(currentValue);
                                    
                                    return `
                                        <div class="color-input-group">
                                            <label style="display: block; margin-bottom: 0.5rem; font-weight: 500; font-size: 0.9rem;">
                                                ${label}
                                            </label>
                                            <div style="display: flex; gap: 0.5rem; align-items: center;">
                                                <input 
                                                    type="color" 
                                                    data-variable="${variable}"
                                                    value="${hexColor}"
                                                    style="width: 50px; height: 40px; border: 2px solid var(--border-color); border-radius: 4px; cursor: pointer;"
                                                >
                                                <input 
                                                    type="text" 
                                                    data-variable-text="${variable}"
                                                    value="${currentValue}"
                                                    placeholder="${currentValue}"
                                                    style="flex: 1; padding: 0.5rem; border: 1px solid var(--border-color); border-radius: 4px; font-family: 'Source Code Pro', monospace; font-size: 0.85rem;"
                                                >
                                            </div>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                            
                            <!-- Actions de l'éditeur -->
                            <div style="display: flex; gap: 0.75rem; flex-wrap: wrap; padding-top: 1rem; border-top: 1px solid var(--border-color);">
                                <button onclick="applyCurrentEditorColors()" class="btn-primary">
                                    ✓ Appliquer les Couleurs
                                </button>
                                <button onclick="saveThemeAsCustom()" class="btn-primary" style="background: var(--accent-gold);">
                                    💾 Sauvegarder comme Thème
                                </button>
                                <button onclick="exportCurrentTheme()" class="btn-secondary">
                                    📤 Exporter en JSON
                                </button>
                                <button onclick="importThemeFile()" class="btn-secondary">
                                    📥 Importer depuis JSON
                                </button>
                                <button onclick="resetToDefault()" class="btn-secondary" style="margin-left: auto;">
                                    🔄 Réinitialiser
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Remplir les thèmes prédéfinis
            renderPresetThemes();
            renderCustomThemes();
            
            // Lier les changements de couleur en temps réel
            modal.querySelectorAll('input[type="color"]').forEach(input => {
                input.addEventListener('input', (e) => {
                    const variable = e.target.dataset.variable;
                    const color = e.target.value;
                    const textInput = modal.querySelector(`input[data-variable-text="${variable}"]`);
                    textInput.value = color;
                    document.documentElement.style.setProperty(variable, color);
                });
            });
            
            modal.querySelectorAll('input[data-variable-text]').forEach(input => {
                input.addEventListener('change', (e) => {
                    const variable = e.target.dataset.variableText;
                    const color = e.target.value;
                    document.documentElement.style.setProperty(variable, color);
                    
                    // Mettre à jour le color picker si possible
                    const hexColor = rgbaToHex(color);
                    const colorInput = modal.querySelector(`input[data-variable="${variable}"]`);
                    if (colorInput && hexColor.match(/^#[0-9A-F]{6}$/i)) {
                        colorInput.value = hexColor;
                    }
                });
            });
        }
        
        function renderPresetThemes() {
            const container = document.getElementById('presetThemesList');
            container.innerHTML = Object.entries(themeManager.presetThemes).map(([name, colors]) => `
                <div class="theme-card" style="border: 2px solid var(--border-color); border-radius: 8px; padding: 1rem; cursor: pointer; transition: all 0.2s;"
                     onmouseover="this.style.borderColor='var(--accent-gold)'"
                     onmouseout="this.style.borderColor='var(--border-color)'"
                     onclick="applyPresetTheme('${name}')">
                    <div style="font-weight: 600; margin-bottom: 0.75rem; font-size: 1rem;">
                        ${name}
                    </div>
                    <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 0.25rem;">
                        ${Object.values(colors).slice(0, 10).map(color => `
                            <div style="width: 100%; padding-bottom: 100%; background: ${color}; border-radius: 2px; border: 1px solid rgba(0,0,0,0.1);"></div>
                        `).join('')}
                    </div>
                </div>
            `).join('');
        }
        
        function renderCustomThemes() {
            const container = document.getElementById('customThemesList');
            if (themeManager.customThemes.length === 0) {
                container.innerHTML = '<p style="color: var(--text-muted); font-style: italic;">Aucun thème personnalisé</p>';
                return;
            }
            
            container.innerHTML = themeManager.customThemes.map(theme => `
                <div class="theme-card" style="border: 2px solid var(--border-color); border-radius: 8px; padding: 1rem; position: relative;">
                    <button onclick="deleteCustomTheme('${theme.name}')" 
                            style="position: absolute; top: 0.5rem; right: 0.5rem; background: var(--accent-red); color: white; border: none; border-radius: 4px; width: 24px; height: 24px; cursor: pointer; font-size: 0.9rem;"
                            title="Supprimer">✕</button>
                    <div style="font-weight: 600; margin-bottom: 0.75rem; font-size: 1rem; padding-right: 2rem;">
                        ${theme.name}
                    </div>
                    <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 0.25rem; margin-bottom: 0.75rem;">
                        ${Object.values(theme.colors).slice(0, 10).map(color => `
                            <div style="width: 100%; padding-bottom: 100%; background: ${color}; border-radius: 2px; border: 1px solid rgba(0,0,0,0.1);"></div>
                        `).join('')}
                    </div>
                    <button onclick="applyCustomTheme('${theme.name}')" class="btn-secondary" style="width: 100%; padding: 0.5rem; font-size: 0.85rem;">
                        Appliquer
                    </button>
                </div>
            `).join('');
        }
        
        function applyPresetTheme(name) {
            const colors = themeManager.presetThemes[name];
            themeManager.applyTheme(colors);
            showNotification(`✓ Thème "${name}" appliqué`);
            
            // Mettre à jour l'éditeur
            Object.entries(colors).forEach(([variable, value]) => {
                const colorInput = document.querySelector(`input[data-variable="${variable}"]`);
                const textInput = document.querySelector(`input[data-variable-text="${variable}"]`);
                if (colorInput && textInput) {
                    textInput.value = value;
                    const hexColor = rgbaToHex(value);
                    if (hexColor.match(/^#[0-9A-F]{6}$/i)) {
                        colorInput.value = hexColor;
                    }
                }
            });
        }
        
        function applyCustomTheme(name) {
            const theme = themeManager.customThemes.find(t => t.name === name);
            if (theme) {
                themeManager.applyTheme(theme.colors);
                showNotification(`✓ Thème "${name}" appliqué`);
                
                // Mettre à jour l'éditeur
                Object.entries(theme.colors).forEach(([variable, value]) => {
                    const colorInput = document.querySelector(`input[data-variable="${variable}"]`);
                    const textInput = document.querySelector(`input[data-variable-text="${variable}"]`);
                    if (colorInput && textInput) {
                        textInput.value = value;
                        const hexColor = rgbaToHex(value);
                        if (hexColor.match(/^#[0-9A-F]{6}$/i)) {
                            colorInput.value = hexColor;
                        }
                    }
                });
            }
        }
        
        function deleteCustomTheme(name) {
            if (confirm(`Supprimer le thème "${name}" ?`)) {
                themeManager.deleteCustomTheme(name);
                renderCustomThemes();
                showNotification(`✓ Thème "${name}" supprimé`);
            }
        }
        
        function applyCurrentEditorColors() {
            const colors = {};
            document.querySelectorAll('input[data-variable-text]').forEach(input => {
                const variable = input.dataset.variableText;
                colors[variable] = input.value;
            });
            themeManager.applyTheme(colors);
            showNotification('✓ Couleurs appliquées');
        }
        
        function saveThemeAsCustom() {
            const name = prompt('Nom du thème :');
            if (!name) return;
            
            // Vérifier si le nom existe déjà
            if (themeManager.customThemes.find(t => t.name === name)) {
                if (!confirm(`Un thème nommé "${name}" existe déjà. Remplacer ?`)) {
                    return;
                }
                themeManager.deleteCustomTheme(name);
            }
            
            const colors = {};
            document.querySelectorAll('input[data-variable-text]').forEach(input => {
                const variable = input.dataset.variableText;
                colors[variable] = input.value;
            });
            
            themeManager.addCustomTheme(name, colors);
            renderCustomThemes();
            showNotification(`✓ Thème "${name}" sauvegardé`);
        }
        
        function exportCurrentTheme() {
            const name = prompt('Nom du thème pour l\'export :', 'Mon Thème');
            if (!name) return;
            
            const colors = {};
            document.querySelectorAll('input[data-variable-text]').forEach(input => {
                const variable = input.dataset.variableText;
                colors[variable] = input.value;
            });
            
            themeManager.exportTheme(colors, name);
            showNotification(`✓ Thème "${name}" exporté`);
        }
        
        function importThemeFile() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = async (e) => {
                try {
                    const file = e.target.files[0];
                    const theme = await themeManager.importTheme(file);
                    
                    // Demander si on veut l'appliquer ou le sauvegarder
                    const choice = confirm(`Thème "${theme.name}" importé.\n\nOK = Appliquer maintenant\nAnnuler = Sauvegarder dans mes thèmes`);
                    
                    if (choice) {
                        themeManager.applyTheme(theme.colors);
                        showNotification(`✓ Thème "${theme.name}" appliqué`);
                    } else {
                        // Vérifier si le nom existe
                        if (themeManager.customThemes.find(t => t.name === theme.name)) {
                            if (!confirm(`Un thème nommé "${theme.name}" existe déjà. Remplacer ?`)) {
                                return;
                            }
                            themeManager.deleteCustomTheme(theme.name);
                        }
                        themeManager.addCustomTheme(theme.name, theme.colors);
                        renderCustomThemes();
                        showNotification(`✓ Thème "${theme.name}" sauvegardé`);
                    }
                    
                    // Mettre à jour l'éditeur
                    Object.entries(theme.colors).forEach(([variable, value]) => {
                        const colorInput = document.querySelector(`input[data-variable="${variable}"]`);
                        const textInput = document.querySelector(`input[data-variable-text="${variable}"]`);
                        if (colorInput && textInput) {
                            textInput.value = value;
                            const hexColor = rgbaToHex(value);
                            if (hexColor.match(/^#[0-9A-F]{6}$/i)) {
                                colorInput.value = hexColor;
                            }
                        }
                    });
                    
                } catch (error) {
                    alert(`Erreur lors de l'import : ${error.message}`);
                }
            };
            input.click();
        }
        
        function resetToDefault() {
            if (confirm('Revenir au thème par défaut ?')) {
                themeManager.applyTheme(themeManager.defaultVariables);
                showNotification('✓ Thème par défaut restauré');
                
                // Mettre à jour l'éditeur
                Object.entries(themeManager.defaultVariables).forEach(([variable, value]) => {
                    const colorInput = document.querySelector(`input[data-variable="${variable}"]`);
                    const textInput = document.querySelector(`input[data-variable-text="${variable}"]`);
                    if (colorInput && textInput) {
                        textInput.value = value;
                        const hexColor = rgbaToHex(value);
                        if (hexColor.match(/^#[0-9A-F]{6}$/i)) {
                            colorInput.value = hexColor;
                        }
                    }
                });
            }
        }

        // === TENSION WORDS MANAGEMENT ===
        
        // Valeurs par défaut des mots de tension
        const DEFAULT_TENSION_WORDS = {
            high: [
                'combat', 'bataille', 'mort', 'tuer', 'danger', 'peur', 'terreur', 'cri', 'hurler',
                'sang', 'blessure', 'fuir', 'course', 'poursuite', 'menace', 'attaque', 'explosion',
                'feu', 'incendie', 'catastrophe', 'urgence', 'panique', 'désespoir', 'tragédie',
                'révélation', 'secret', 'trahison', 'conflit', 'confrontation', 'affrontement',
                'climax', 'crucial', 'décisif', 'critique', 'vital', 'dramatique'
            ],
            medium: [
                'mystère', 'suspense', 'intrigue', 'complot', 'enquête', 'découverte', 'surprise',
                'tension', 'stress', 'angoisse', 'inquiétude', 'doute', 'hésitation', 'dilemme',
                'choix', 'décision', 'tournant', 'changement', 'transformation'
            ],
            low: [
                'calme', 'paix', 'repos', 'détente', 'tranquille', 'paisible', 'serein',
                'conversation', 'discussion', 'réflexion', 'souvenir', 'rêve', 'pensée'
            ]
        };

        // Récupérer les mots de tension (personnalisés ou par défaut)
        function getTensionWords() {
            const stored = localStorage.getItem('tensionWords');
            if (stored) {
                try {
                    return JSON.parse(stored);
                } catch (e) {
                    console.error('Erreur lors du chargement des mots de tension:', e);
                    return DEFAULT_TENSION_WORDS;
                }
            }
            return DEFAULT_TENSION_WORDS;
        }

        // Sauvegarder les mots de tension
        function saveTensionWordsToStorage(words) {
            localStorage.setItem('tensionWords', JSON.stringify(words));
        }

        // Ouvrir l'éditeur de mots de tension
        function openTensionWordsEditor() {
            document.getElementById('tensionWordsModal').classList.add('active');
            loadTensionWordsInEditor();
        }

        // Charger les mots dans l'éditeur
        function loadTensionWordsInEditor() {
            const words = getTensionWords();
            
            // Charger les mots de haute tension
            const highList = document.getElementById('highTensionList');
            highList.innerHTML = '';
            words.high.forEach((word, index) => {
                highList.innerHTML += createWordElement(word, 'high', index);
            });
            
            // Charger les mots de tension moyenne
            const mediumList = document.getElementById('mediumTensionList');
            mediumList.innerHTML = '';
            words.medium.forEach((word, index) => {
                mediumList.innerHTML += createWordElement(word, 'medium', index);
            });
            
            // Charger les mots de faible tension
            const lowList = document.getElementById('lowTensionList');
            lowList.innerHTML = '';
            words.low.forEach((word, index) => {
                lowList.innerHTML += createWordElement(word, 'low', index);
            });
        }

        // Créer un élément de mot avec bouton de suppression
        function createWordElement(word, type, index) {
            const colors = {
                high: 'var(--accent-red)',
                medium: '#e6a23c',
                low: 'var(--accent-blue)'
            };
            
            return `
                <div style="display: flex; align-items: center; justify-content: space-between; padding: 0.5rem 0.75rem; background: var(--bg-primary); border-radius: 4px; border: 1px solid var(--border-color);">
                    <span style="font-size: 0.85rem; color: var(--text-primary);">${word}</span>
                    <button onclick="removeTensionWord('${type}', ${index})" 
                            style="background: none; border: none; color: ${colors[type]}; cursor: pointer; font-size: 1rem; padding: 0 0.25rem; opacity: 0.7; transition: opacity 0.2s;"
                            onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0.7'"
                            title="Supprimer ce mot">
                        ×
                    </button>
                </div>
            `;
        }

        // Ajouter un mot de tension
        function addTensionWord(type) {
            const input = document.getElementById(`${type}TensionInput`);
            const word = input.value.trim().toLowerCase();
            
            if (!word) {
                showNotification('⚠️ Veuillez entrer un mot', 'warning');
                return;
            }
            
            const words = getTensionWords();
            
            // Vérifier si le mot existe déjà
            if (words[type].includes(word)) {
                showNotification('⚠️ Ce mot existe déjà dans cette catégorie', 'warning');
                return;
            }
            
            // Vérifier si le mot existe dans une autre catégorie
            for (const category in words) {
                if (category !== type && words[category].includes(word)) {
                    showNotification(`⚠️ Ce mot existe déjà dans la catégorie "${category === 'high' ? 'haute' : category === 'medium' ? 'moyenne' : 'faible'} tension"`, 'warning');
                    return;
                }
            }
            
            // Ajouter le mot
            words[type].push(word);
            saveTensionWordsToStorage(words);
            
            // Recharger la liste
            loadTensionWordsInEditor();
            
            // Vider l'input
            input.value = '';
            
            showNotification(`✓ Mot "${word}" ajouté`, 'success');
        }

        // Supprimer un mot de tension
        function removeTensionWord(type, index) {
            const words = getTensionWords();
            const removedWord = words[type][index];
            
            words[type].splice(index, 1);
            saveTensionWordsToStorage(words);
            
            // Recharger la liste
            loadTensionWordsInEditor();
            
            showNotification(`✓ Mot "${removedWord}" supprimé`, 'success');
        }

        // Enregistrer les modifications
        function saveTensionWords() {
            closeModal('tensionWordsModal');
            showNotification('✓ Mots de tension enregistrés. Le graphique sera recalculé lors de la prochaine visualisation.', 'success');
        }

        // Réinitialiser aux valeurs par défaut
        function resetTensionWordsToDefault() {
            if (confirm('Êtes-vous sûr de vouloir réinitialiser tous les mots de tension aux valeurs par défaut ? Cette action est irréversible.')) {
                saveTensionWordsToStorage(DEFAULT_TENSION_WORDS);
                loadTensionWordsInEditor();
                showNotification('✓ Mots de tension réinitialisés aux valeurs par défaut', 'success');
            }
        }

        // Exporter les dictionnaires de mots de tension
        function exportTensionWords() {
            const words = getTensionWords();
            
            // Créer trois fichiers texte, un par catégorie
            const highWords = words.high.join('\n');
            const mediumWords = words.medium.join('\n');
            const lowWords = words.low.join('\n');
            
            // Créer un fichier ZIP virtuel avec les trois fichiers
            const content = `=== DICTIONNAIRES DE MOTS DE TENSION ===
Exporté le ${new Date().toLocaleString('fr-FR')}

=== HAUTE TENSION (${words.high.length} mots) ===
${highWords}

=== TENSION MOYENNE (${words.medium.length} mots) ===
${mediumWords}

=== FAIBLE TENSION (${words.low.length} mots) ===
${lowWords}
`;
            
            // Créer et télécharger le fichier
            const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `dictionnaires-tension-${new Date().toISOString().slice(0, 10)}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showNotification('✓ Dictionnaires exportés avec succès', 'success');
        }

        // === BULK IMPORT FOR TENSION WORDS ===
        
        let currentBulkImportType = null;

        // Ouvrir le modal d'import en masse
        function openBulkImport(type) {
            currentBulkImportType = type;
            
            const titles = {
                high: '📥 Import en masse - Haute tension',
                medium: '📥 Import en masse - Tension moyenne',
                low: '📥 Import en masse - Faible tension'
            };
            
            document.getElementById('bulkImportTitle').textContent = titles[type];
            document.getElementById('bulkImportText').value = '';
            document.getElementById('bulkImportFile').value = '';
            document.querySelector('input[name="importMode"][value="add"]').checked = true;
            
            document.getElementById('bulkImportModal').classList.add('active');
        }

        // Traiter l'import en masse
        function processBulkImport() {
            if (!currentBulkImportType) return;
            
            const textarea = document.getElementById('bulkImportText');
            const fileInput = document.getElementById('bulkImportFile');
            const mode = document.querySelector('input[name="importMode"]:checked').value;
            
            // Vérifier si un fichier est sélectionné
            if (fileInput.files && fileInput.files[0]) {
                const file = fileInput.files[0];
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    const content = e.target.result;
                    importWordsFromText(content, currentBulkImportType, mode);
                };
                
                reader.onerror = function() {
                    showNotification('❌ Erreur lors de la lecture du fichier', 'error');
                };
                
                reader.readAsText(file);
            } else if (textarea.value.trim()) {
                // Utiliser le texte collé
                importWordsFromText(textarea.value, currentBulkImportType, mode);
            } else {
                showNotification('⚠️ Veuillez coller du texte ou sélectionner un fichier', 'warning');
            }
        }

        // Importer les mots depuis du texte
        function importWordsFromText(text, type, mode) {
            // Nettoyer et parser le texte
            let words = [];
            
            // Séparer par retours à la ligne ET par virgules
            const lines = text.split(/\r?\n/);
            lines.forEach(line => {
                // Pour chaque ligne, séparer aussi par virgules
                const wordsInLine = line.split(',');
                wordsInLine.forEach(word => {
                    const cleaned = word.trim().toLowerCase();
                    if (cleaned && cleaned.length > 0) {
                        words.push(cleaned);
                    }
                });
            });
            
            // Supprimer les doublons
            words = [...new Set(words)];
            
            if (words.length === 0) {
                showNotification('⚠️ Aucun mot valide trouvé', 'warning');
                return;
            }
            
            // Récupérer les mots existants
            const tensionWords = getTensionWords();
            
            if (mode === 'replace') {
                // Remplacer tous les mots
                tensionWords[type] = words;
                showNotification(`✓ ${words.length} mots importés (remplacement)`, 'success');
            } else {
                // Ajouter aux mots existants (sans doublons)
                const existingWords = new Set(tensionWords[type]);
                let addedCount = 0;
                
                words.forEach(word => {
                    if (!existingWords.has(word)) {
                        tensionWords[type].push(word);
                        addedCount++;
                    }
                });
                
                const skippedCount = words.length - addedCount;
                if (addedCount > 0) {
                    showNotification(`✓ ${addedCount} mot(s) ajouté(s)${skippedCount > 0 ? ` (${skippedCount} doublon(s) ignoré(s))` : ''}`, 'success');
                } else {
                    showNotification(`⚠️ Tous les mots existent déjà (${skippedCount} doublon(s))`, 'warning');
                }
            }
            
            // Sauvegarder et recharger
            saveTensionWordsToStorage(tensionWords);
            loadTensionWordsInEditor();
            
            // Fermer le modal
            closeModal('bulkImportModal');
        }

        // Gestionnaire pour le changement de fichier
        document.addEventListener('DOMContentLoaded', function() {
            const fileInput = document.getElementById('bulkImportFile');
            if (fileInput) {
                fileInput.addEventListener('change', function() {
                    if (this.files && this.files[0]) {
                        // Vider le textarea si un fichier est sélectionné
                        document.getElementById('bulkImportText').value = '';
                    }
                });
            }
            
            const textarea = document.getElementById('bulkImportText');
            if (textarea) {
                textarea.addEventListener('input', function() {
                    if (this.value.trim()) {
                        // Vider le file input si du texte est saisi
                        document.getElementById('bulkImportFile').value = '';
                    }
                });
            }
        });

        // ============================================
        // EXPORT NOVEL FUNCTIONS
        // ============================================

        // Global variable to track selection state
        let exportSelectionState = {};

        function openExportNovelModal() {
            // Initialize selection state with all items checked
            exportSelectionState = {};
            project.acts.forEach(act => {
                exportSelectionState[`act-${act.id}`] = true;
                act.chapters.forEach(chapter => {
                    exportSelectionState[`chapter-${chapter.id}`] = true;
                    chapter.scenes.forEach(scene => {
                        exportSelectionState[`scene-${scene.id}`] = true;
                    });
                });
            });
            
            renderExportTree();
            updateExportFormatInfo();
            document.getElementById('exportNovelModal').classList.add('active');
        }

        function renderExportTree() {
            const container = document.getElementById('exportTreeContainer');
            if (!container) return;
            
            let html = '';
            
            project.acts.forEach((act, actIndex) => {
                const actChecked = exportSelectionState[`act-${act.id}`] ? 'checked' : '';
                html += `
                    <div style="margin-bottom: 1rem;">
                        <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-weight: 600; font-size: 1rem; margin-bottom: 0.5rem;">
                            <input type="checkbox" ${actChecked} onchange="toggleAct(${act.id})" id="export-act-${act.id}" style="cursor: pointer;">
                            <span>Acte ${actIndex + 1}</span>
                        </label>
                        <div style="margin-left: 1.5rem;">
                `;
                
                act.chapters.forEach((chapter, chapIndex) => {
                    const chapterChecked = exportSelectionState[`chapter-${chapter.id}`] ? 'checked' : '';
                    html += `
                        <div style="margin-bottom: 0.75rem;">
                            <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-weight: 500; font-size: 0.95rem; margin-bottom: 0.25rem;">
                                <input type="checkbox" ${chapterChecked} onchange="toggleChapter(${act.id}, ${chapter.id})" id="export-chapter-${chapter.id}" style="cursor: pointer;">
                                <span>Chapitre ${chapIndex + 1}</span>
                            </label>
                            <div style="margin-left: 1.5rem;">
                    `;
                    
                    chapter.scenes.forEach((scene, sceneIndex) => {
                        const sceneChecked = exportSelectionState[`scene-${scene.id}`] ? 'checked' : '';
                        html += `
                            <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-size: 0.9rem; color: var(--text-secondary); margin-bottom: 0.25rem;">
                                <input type="checkbox" ${sceneChecked} onchange="toggleScene(${act.id}, ${chapter.id}, ${scene.id})" id="export-scene-${scene.id}" style="cursor: pointer;">
                                <span>Scène ${sceneIndex + 1}</span>
                            </label>
                        `;
                    });
                    
                    html += `
                            </div>
                        </div>
                    `;
                });
                
                html += `
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }

        function toggleAllScenes() {
            // Check if all are currently selected
            const allSelected = Object.values(exportSelectionState).every(v => v === true);
            
            // Toggle all to opposite state
            const newState = !allSelected;
            
            project.acts.forEach(act => {
                exportSelectionState[`act-${act.id}`] = newState;
                act.chapters.forEach(chapter => {
                    exportSelectionState[`chapter-${chapter.id}`] = newState;
                    chapter.scenes.forEach(scene => {
                        exportSelectionState[`scene-${scene.id}`] = newState;
                    });
                });
            });
            
            renderExportTree();
        }

        function toggleAct(actId) {
            const checkbox = document.getElementById(`export-act-${actId}`);
            const isChecked = checkbox.checked;
            
            exportSelectionState[`act-${actId}`] = isChecked;
            
            // Find the act and toggle all its children
            const act = project.acts.find(a => a.id === actId);
            if (act) {
                act.chapters.forEach(chapter => {
                    exportSelectionState[`chapter-${chapter.id}`] = isChecked;
                    chapter.scenes.forEach(scene => {
                        exportSelectionState[`scene-${scene.id}`] = isChecked;
                    });
                });
            }
            
            renderExportTree();
        }

        function toggleChapter(actId, chapterId) {
            const checkbox = document.getElementById(`export-chapter-${chapterId}`);
            const isChecked = checkbox.checked;
            
            exportSelectionState[`chapter-${chapterId}`] = isChecked;
            
            // Find the chapter and toggle all its scenes
            const act = project.acts.find(a => a.id === actId);
            if (act) {
                const chapter = act.chapters.find(c => c.id === chapterId);
                if (chapter) {
                    chapter.scenes.forEach(scene => {
                        exportSelectionState[`scene-${scene.id}`] = isChecked;
                    });
                }
                
                // Update act checkbox if needed
                const allChaptersChecked = act.chapters.every(c => exportSelectionState[`chapter-${c.id}`]);
                exportSelectionState[`act-${actId}`] = allChaptersChecked;
            }
            
            renderExportTree();
        }

        function toggleScene(actId, chapterId, sceneId) {
            const checkbox = document.getElementById(`export-scene-${sceneId}`);
            exportSelectionState[`scene-${sceneId}`] = checkbox.checked;
            
            // Update chapter checkbox
            const act = project.acts.find(a => a.id === actId);
            if (act) {
                const chapter = act.chapters.find(c => c.id === chapterId);
                if (chapter) {
                    const allScenesChecked = chapter.scenes.every(s => exportSelectionState[`scene-${s.id}`]);
                    exportSelectionState[`chapter-${chapterId}`] = allScenesChecked;
                    
                    // Update act checkbox
                    const allChaptersChecked = act.chapters.every(c => exportSelectionState[`chapter-${c.id}`]);
                    exportSelectionState[`act-${actId}`] = allChaptersChecked;
                }
            }
            
            renderExportTree();
        }

        function updateExportFormatInfo() {
            const format = document.getElementById('exportFormatSelect').value;
            const infoBox = document.getElementById('formatInfoBox');
            
            const messages = {
                docx: '<strong style="color: var(--text-primary);">ℹ️ Note :</strong> Toutes les fonctionnalités ne sont pas supportées en format DOCX. Le texte exporté pourrait ne pas ressembler exactement à l\'éditeur. Pour une compatibilité complète, utilisez un autre format.',
                markdown: '<strong style="color: var(--text-primary);">✅ Format Markdown :</strong> Excellent pour la portabilité et la compatibilité avec la plupart des éditeurs de texte et des plateformes de publication.',
                txt: '<strong style="color: var(--text-primary);">📋 Texte brut :</strong> Format universel sans formatage. Compatible avec tous les logiciels.',
                html: '<strong style="color: var(--text-primary);">🌐 HTML :</strong> Format web avec préservation complète du formatage. Ouvrez dans un navigateur ou importez dans des éditeurs HTML.'
            };
            
            infoBox.innerHTML = messages[format] || messages.docx;
        }

        function executeNovelExport() {
            const format = document.getElementById('exportFormatSelect').value;
            const options = {
                exportSummaries: document.getElementById('exportSummariesCheck').checked,
                exportProse: document.getElementById('exportProseCheck').checked,
                includeActTitles: document.getElementById('includeActTitlesCheck').checked,
                includeSceneSubtitles: document.getElementById('includeSceneSubtitlesCheck').checked,
                sceneDivider: document.getElementById('sceneDividerSelect').value,
                includeFullCodex: document.getElementById('includeFullCodexCheck').checked,
                includeAllSnippets: document.getElementById('includeAllSnippetsCheck').checked,
                includeAllChats: document.getElementById('includeAllChatsCheck').checked
            };
            
            // Check if creating a ZIP archive (project export)
            const isProjectExport = options.includeFullCodex || options.includeAllSnippets || options.includeAllChats;
            
            if (isProjectExport) {
                exportProjectAsZip(format, options);
            } else {
                // Single file export
                switch(format) {
                    case 'docx':
                        exportAsDOCX(options);
                        break;
                    case 'markdown':
                        exportAsMarkdown(options);
                        break;
                    case 'txt':
                        exportAsTXT(options);
                        break;
                    case 'html':
                        exportAsHTML(options);
                        break;
                }
            }
        }

        function getSelectedContent(options) {
            let content = {
                acts: []
            };
            
            project.acts.forEach((act, actIndex) => {
                if (!exportSelectionState[`act-${act.id}`]) return;
                
                let exportAct = {
                    title: `Acte ${actIndex + 1}`,
                    chapters: []
                };
                
                act.chapters.forEach((chapter, chapIndex) => {
                    if (!exportSelectionState[`chapter-${chapter.id}`]) return;
                    
                    let exportChapter = {
                        title: chapter.title || `Chapitre ${chapIndex + 1}`,
                        scenes: []
                    };
                    
                    chapter.scenes.forEach((scene, sceneIndex) => {
                        if (!exportSelectionState[`scene-${scene.id}`]) return;
                        
                        let exportScene = {
                            title: scene.title || `Scène ${sceneIndex + 1}`,
                            summary: scene.summary || '',
                            content: scene.content || ''
                        };
                        
                        exportChapter.scenes.push(exportScene);
                    });
                    
                    if (exportChapter.scenes.length > 0) {
                        exportAct.chapters.push(exportChapter);
                    }
                });
                
                if (exportAct.chapters.length > 0) {
                    content.acts.push(exportAct);
                }
            });
            
            return content;
        }

        function getSceneDivider(dividerType) {
            switch(dividerType) {
                case 'asterisks':
                    return '\n\n* * *\n\n';
                case 'hash':
                    return '\n\n###\n\n';
                case 'line':
                    return '\n\n---\n\n';
                case 'space':
                    return '\n\n\n';
                case 'none':
                    return '\n\n';
                default:
                    return '\n\n* * *\n\n';
            }
        }

        function exportAsMarkdown(options) {
            const content = getSelectedContent(options);
            const divider = getSceneDivider(options.sceneDivider);
            let markdown = `# ${project.title}\n\n`;
            
            content.acts.forEach((act, actIndex) => {
                if (options.includeActTitles) {
                    markdown += `# ${act.title}\n\n`;
                }
                
                act.chapters.forEach((chapter, chapIndex) => {
                    markdown += `## ${chapter.title}\n\n`;
                    
                    chapter.scenes.forEach((scene, sceneIndex) => {
                        if (options.includeSceneSubtitles && scene.title) {
                            markdown += `### ${scene.title}\n\n`;
                        }
                        
                        if (options.exportSummaries && scene.summary) {
                            markdown += `> ${scene.summary}\n\n`;
                        }
                        
                        if (options.exportProse && scene.content) {
                            markdown += `${scene.content}\n`;
                        }
                        
                        // Add divider between scenes (except after last scene)
                        if (sceneIndex < chapter.scenes.length - 1) {
                            markdown += divider;
                        }
                    });
                    
                    markdown += '\n\n';
                });
            });
            
            downloadFile(markdown, `${project.title}.md`, 'text/markdown');
            showNotification('✓ Export Markdown terminé');
            closeModal('exportNovelModal');
        }

        function exportAsTXT(options) {
            const content = getSelectedContent(options);
            const divider = getSceneDivider(options.sceneDivider);
            let text = `${project.title}\n${'='.repeat(project.title.length)}\n\n`;
            
            content.acts.forEach((act, actIndex) => {
                if (options.includeActTitles) {
                    text += `${act.title}\n${'-'.repeat(act.title.length)}\n\n`;
                }
                
                act.chapters.forEach((chapter, chapIndex) => {
                    text += `${chapter.title}\n\n`;
                    
                    chapter.scenes.forEach((scene, sceneIndex) => {
                        if (options.includeSceneSubtitles && scene.title) {
                            text += `${scene.title}\n\n`;
                        }
                        
                        if (options.exportSummaries && scene.summary) {
                            text += `[Résumé: ${scene.summary}]\n\n`;
                        }
                        
                        if (options.exportProse && scene.content) {
                            text += `${scene.content}\n`;
                        }
                        
                        if (sceneIndex < chapter.scenes.length - 1) {
                            text += divider;
                        }
                    });
                    
                    text += '\n\n';
                });
            });
            
            downloadFile(text, `${project.title}.txt`, 'text/plain');
            showNotification('✓ Export TXT terminé');
            closeModal('exportNovelModal');
        }

        function exportAsHTML(options) {
            const content = getSelectedContent(options);
            const divider = getSceneDivider(options.sceneDivider).replace(/\n/g, '<br>');
            
            let html = `<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${project.title}</title>
    <style>
        body {
            font-family: 'Georgia', serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 2rem;
            line-height: 1.8;
            color: #333;
            background: #fafafa;
        }
        h1 {
            font-size: 2.5rem;
            margin-bottom: 2rem;
            text-align: center;
            border-bottom: 3px solid #333;
            padding-bottom: 1rem;
        }
        h2 {
            font-size: 2rem;
            margin-top: 3rem;
            margin-bottom: 1.5rem;
            border-bottom: 2px solid #666;
            padding-bottom: 0.5rem;
        }
        h3 {
            font-size: 1.5rem;
            margin-top: 2rem;
            margin-bottom: 1rem;
            color: #666;
        }
        h4 {
            font-size: 1.2rem;
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
            color: #888;
            font-style: italic;
        }
        p {
            margin-bottom: 1rem;
            text-align: justify;
        }
        .summary {
            background: #f0f0f0;
            padding: 1rem;
            border-left: 4px solid #999;
            margin: 1rem 0;
            font-style: italic;
            color: #666;
        }
        .divider {
            text-align: center;
            margin: 2rem 0;
            color: #999;
        }
    </style>
</head>
<body>
    <h1>${project.title}</h1>
`;
            
            content.acts.forEach((act, actIndex) => {
                if (options.includeActTitles) {
                    html += `    <h2>${act.title}</h2>\n`;
                }
                
                act.chapters.forEach((chapter, chapIndex) => {
                    html += `    <h3>${chapter.title}</h3>\n`;
                    
                    chapter.scenes.forEach((scene, sceneIndex) => {
                        if (options.includeSceneSubtitles && scene.title) {
                            html += `    <h4>${scene.title}</h4>\n`;
                        }
                        
                        if (options.exportSummaries && scene.summary) {
                            html += `    <div class="summary">${scene.summary}</div>\n`;
                        }
                        
                        if (options.exportProse && scene.content) {
                            // Convert line breaks to paragraphs
                            const paragraphs = scene.content.split('\n').filter(p => p.trim());
                            paragraphs.forEach(para => {
                                html += `    <p>${para}</p>\n`;
                            });
                        }
                        
                        if (sceneIndex < chapter.scenes.length - 1 && options.sceneDivider !== 'none') {
                            html += `    <div class="divider">${divider}</div>\n`;
                        }
                    });
                });
            });
            
            html += `</body>\n</html>`;
            
            downloadFile(html, `${project.title}.html`, 'text/html');
            showNotification('✓ Export HTML terminé');
            closeModal('exportNovelModal');
        }

        async function exportAsDOCX(options) {
            // Check if docx library is loaded
            if (typeof docx === 'undefined') {
                alert('❌ Erreur : La bibliothèque DOCX n\'est pas chargée. Veuillez rafraîchir la page.');
                return;
            }

            const content = getSelectedContent(options);
            const { Document, Packer, Paragraph, TextRun, HeadingLevel, AlignmentType } = docx;
            
            const children = [];
            
            // Title
            children.push(
                new Paragraph({
                    text: project.title,
                    heading: HeadingLevel.TITLE,
                    alignment: AlignmentType.CENTER,
                    spacing: { after: 400 }
                })
            );
            
            content.acts.forEach((act, actIndex) => {
                if (options.includeActTitles) {
                    children.push(
                        new Paragraph({
                            text: act.title,
                            heading: HeadingLevel.HEADING_1,
                            spacing: { before: 400, after: 200 }
                        })
                    );
                }
                
                act.chapters.forEach((chapter, chapIndex) => {
                    children.push(
                        new Paragraph({
                            text: chapter.title,
                            heading: HeadingLevel.HEADING_2,
                            spacing: { before: 300, after: 200 }
                        })
                    );
                    
                    chapter.scenes.forEach((scene, sceneIndex) => {
                        if (options.includeSceneSubtitles && scene.title) {
                            children.push(
                                new Paragraph({
                                    text: scene.title,
                                    heading: HeadingLevel.HEADING_3,
                                    spacing: { before: 200, after: 100 }
                                })
                            );
                        }
                        
                        if (options.exportSummaries && scene.summary) {
                            children.push(
                                new Paragraph({
                                    children: [
                                        new TextRun({
                                            text: scene.summary,
                                            italics: true
                                        })
                                    ],
                                    spacing: { after: 200 }
                                })
                            );
                        }
                        
                        if (options.exportProse && scene.content) {
                            const paragraphs = scene.content.split('\n').filter(p => p.trim());
                            paragraphs.forEach(para => {
                                children.push(
                                    new Paragraph({
                                        text: para,
                                        spacing: { after: 200 }
                                    })
                                );
                            });
                        }
                        
                        // Add divider between scenes
                        if (sceneIndex < chapter.scenes.length - 1) {
                            const dividerText = options.sceneDivider === 'asterisks' ? '* * *' :
                                              options.sceneDivider === 'hash' ? '###' :
                                              options.sceneDivider === 'line' ? '---' : '';
                            
                            if (dividerText) {
                                children.push(
                                    new Paragraph({
                                        text: dividerText,
                                        alignment: AlignmentType.CENTER,
                                        spacing: { before: 200, after: 200 }
                                    })
                                );
                            }
                        }
                    });
                });
            });
            
            const doc = new Document({
                sections: [{
                    properties: {},
                    children: children
                }]
            });
            
            try {
                const blob = await Packer.toBlob(doc);
                saveAs(blob, `${project.title}.docx`);
                showNotification('✓ Export DOCX terminé');
                closeModal('exportNovelModal');
            } catch (error) {
                alert('❌ Erreur lors de l\'export DOCX : ' + error.message);
                console.error(error);
            }
        }

        async function exportProjectAsZip(format, options) {
            if (typeof JSZip === 'undefined') {
                alert('❌ Erreur : La bibliothèque JSZip n\'est pas chargée. Veuillez rafraîchir la page.');
                return;
            }

            const zip = new JSZip();
            
            // Add main novel file
            const content = getSelectedContent(options);
            let mainFileContent = '';
            let mainFileName = '';
            
            switch(format) {
                case 'markdown':
                    mainFileContent = await generateMarkdownContent(content, options);
                    mainFileName = `${project.title}.md`;
                    break;
                case 'txt':
                    mainFileContent = await generateTXTContent(content, options);
                    mainFileName = `${project.title}.txt`;
                    break;
                case 'html':
                    mainFileContent = await generateHTMLContent(content, options);
                    mainFileName = `${project.title}.html`;
                    break;
                case 'docx':
                    // DOCX is binary, handled separately below
                    break;
            }
            
            if (format !== 'docx') {
                zip.file(mainFileName, mainFileContent);
            } else {
                // For DOCX, we need to generate the binary blob
                const docxBlob = await generateDOCXBlob(content, options);
                zip.file(`${project.title}.docx`, docxBlob);
            }
            
            // Add Codex if requested
            if (options.includeFullCodex && project.codex && project.codex.length > 0) {
                let codexContent = '# Codex\n\n';
                project.codex.forEach(entry => {
                    codexContent += `## ${entry.title}\n\n${entry.content}\n\n---\n\n`;
                });
                zip.file('Codex.md', codexContent);
            }
            
            // Add Snippets if requested  
            if (options.includeAllSnippets && project.notes && project.notes.length > 0) {
                let snippetsContent = '# Extraits et Notes\n\n';
                project.notes.forEach(note => {
                    snippetsContent += `## ${note.title}\n\n${note.content}\n\n---\n\n`;
                });
                zip.file('Extraits.md', snippetsContent);
            }
            
            // Add Chats/Dialogues if requested (using timeline as placeholder)
            if (options.includeAllChats && project.timeline && project.timeline.length > 0) {
                let chatsContent = '# Timeline / Dialogues\n\n';
                project.timeline.forEach(event => {
                    chatsContent += `## ${event.title}\n\n${event.description || ''}\n\n---\n\n`;
                });
                zip.file('Timeline.md', chatsContent);
            }
            
            // Generate and download ZIP
            try {
                const blob = await zip.generateAsync({ type: 'blob' });
                saveAs(blob, `${project.title}_Export.zip`);
                showNotification('✓ Export du projet complet terminé');
                closeModal('exportNovelModal');
            } catch (error) {
                alert('❌ Erreur lors de la création du ZIP : ' + error.message);
                console.error(error);
            }
        }

        async function generateMarkdownContent(content, options) {
            const divider = getSceneDivider(options.sceneDivider);
            let markdown = `# ${project.title}\n\n`;
            
            content.acts.forEach((act, actIndex) => {
                if (options.includeActTitles) {
                    markdown += `# ${act.title}\n\n`;
                }
                
                act.chapters.forEach((chapter, chapIndex) => {
                    markdown += `## ${chapter.title}\n\n`;
                    
                    chapter.scenes.forEach((scene, sceneIndex) => {
                        if (options.includeSceneSubtitles && scene.title) {
                            markdown += `### ${scene.title}\n\n`;
                        }
                        
                        if (options.exportSummaries && scene.summary) {
                            markdown += `> ${scene.summary}\n\n`;
                        }
                        
                        if (options.exportProse && scene.content) {
                            markdown += `${scene.content}\n`;
                        }
                        
                        if (sceneIndex < chapter.scenes.length - 1) {
                            markdown += divider;
                        }
                    });
                    
                    markdown += '\n\n';
                });
            });
            
            return markdown;
        }

        async function generateTXTContent(content, options) {
            const divider = getSceneDivider(options.sceneDivider);
            let text = `${project.title}\n${'='.repeat(project.title.length)}\n\n`;
            
            content.acts.forEach((act, actIndex) => {
                if (options.includeActTitles) {
                    text += `${act.title}\n${'-'.repeat(act.title.length)}\n\n`;
                }
                
                act.chapters.forEach((chapter, chapIndex) => {
                    text += `${chapter.title}\n\n`;
                    
                    chapter.scenes.forEach((scene, sceneIndex) => {
                        if (options.includeSceneSubtitles && scene.title) {
                            text += `${scene.title}\n\n`;
                        }
                        
                        if (options.exportSummaries && scene.summary) {
                            text += `[Résumé: ${scene.summary}]\n\n`;
                        }
                        
                        if (options.exportProse && scene.content) {
                            text += `${scene.content}\n`;
                        }
                        
                        if (sceneIndex < chapter.scenes.length - 1) {
                            text += divider;
                        }
                    });
                    
                    text += '\n\n';
                });
            });
            
            return text;
        }

        async function generateHTMLContent(content, options) {
            const divider = getSceneDivider(options.sceneDivider).replace(/\n/g, '<br>');
            
            let html = `<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${project.title}</title>
    <style>
        body { font-family: 'Georgia', serif; max-width: 800px; margin: 0 auto; padding: 2rem; line-height: 1.8; color: #333; background: #fafafa; }
        h1 { font-size: 2.5rem; margin-bottom: 2rem; text-align: center; border-bottom: 3px solid #333; padding-bottom: 1rem; }
        h2 { font-size: 2rem; margin-top: 3rem; margin-bottom: 1.5rem; border-bottom: 2px solid #666; padding-bottom: 0.5rem; }
        h3 { font-size: 1.5rem; margin-top: 2rem; margin-bottom: 1rem; color: #666; }
        h4 { font-size: 1.2rem; margin-top: 1.5rem; margin-bottom: 0.75rem; color: #888; font-style: italic; }
        p { margin-bottom: 1rem; text-align: justify; }
        .summary { background: #f0f0f0; padding: 1rem; border-left: 4px solid #999; margin: 1rem 0; font-style: italic; color: #666; }
        .divider { text-align: center; margin: 2rem 0; color: #999; }
    </style>
</head>
<body>
    <h1>${project.title}</h1>
`;
            
            content.acts.forEach((act, actIndex) => {
                if (options.includeActTitles) {
                    html += `    <h2>${act.title}</h2>\n`;
                }
                
                act.chapters.forEach((chapter, chapIndex) => {
                    html += `    <h3>${chapter.title}</h3>\n`;
                    
                    chapter.scenes.forEach((scene, sceneIndex) => {
                        if (options.includeSceneSubtitles && scene.title) {
                            html += `    <h4>${scene.title}</h4>\n`;
                        }
                        
                        if (options.exportSummaries && scene.summary) {
                            html += `    <div class="summary">${scene.summary}</div>\n`;
                        }
                        
                        if (options.exportProse && scene.content) {
                            const paragraphs = scene.content.split('\n').filter(p => p.trim());
                            paragraphs.forEach(para => {
                                html += `    <p>${para}</p>\n`;
                            });
                        }
                        
                        if (sceneIndex < chapter.scenes.length - 1 && options.sceneDivider !== 'none') {
                            html += `    <div class="divider">${divider}</div>\n`;
                        }
                    });
                });
            });
            
            html += `</body>\n</html>`;
            return html;
        }

        async function generateDOCXBlob(content, options) {
            const { Document, Packer, Paragraph, TextRun, HeadingLevel, AlignmentType } = docx;
            
            const children = [];
            
            children.push(
                new Paragraph({
                    text: project.title,
                    heading: HeadingLevel.TITLE,
                    alignment: AlignmentType.CENTER,
                    spacing: { after: 400 }
                })
            );
            
            content.acts.forEach((act, actIndex) => {
                if (options.includeActTitles) {
                    children.push(
                        new Paragraph({
                            text: act.title,
                            heading: HeadingLevel.HEADING_1,
                            spacing: { before: 400, after: 200 }
                        })
                    );
                }
                
                act.chapters.forEach((chapter, chapIndex) => {
                    children.push(
                        new Paragraph({
                            text: chapter.title,
                            heading: HeadingLevel.HEADING_2,
                            spacing: { before: 300, after: 200 }
                        })
                    );
                    
                    chapter.scenes.forEach((scene, sceneIndex) => {
                        if (options.includeSceneSubtitles && scene.title) {
                            children.push(
                                new Paragraph({
                                    text: scene.title,
                                    heading: HeadingLevel.HEADING_3,
                                    spacing: { before: 200, after: 100 }
                                })
                            );
                        }
                        
                        if (options.exportSummaries && scene.summary) {
                            children.push(
                                new Paragraph({
                                    children: [
                                        new TextRun({
                                            text: scene.summary,
                                            italics: true
                                        })
                                    ],
                                    spacing: { after: 200 }
                                })
                            );
                        }
                        
                        if (options.exportProse && scene.content) {
                            const paragraphs = scene.content.split('\n').filter(p => p.trim());
                            paragraphs.forEach(para => {
                                children.push(
                                    new Paragraph({
                                        text: para,
                                        spacing: { after: 200 }
                                    })
                                );
                            });
                        }
                        
                        if (sceneIndex < chapter.scenes.length - 1) {
                            const dividerText = options.sceneDivider === 'asterisks' ? '* * *' :
                                              options.sceneDivider === 'hash' ? '###' :
                                              options.sceneDivider === 'line' ? '---' : '';
                            
                            if (dividerText) {
                                children.push(
                                    new Paragraph({
                                        text: dividerText,
                                        alignment: AlignmentType.CENTER,
                                        spacing: { before: 200, after: 200 }
                                    })
                                );
                            }
                        }
                    });
                });
            });
            
            const doc = new Document({
                sections: [{
                    properties: {},
                    children: children
                }]
            });
            
            return await Packer.toBlob(doc);
        }

        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: `${mimeType};charset=utf-8` });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }

        // ============================================
        // END EXPORT NOVEL FUNCTIONS
        // ============================================

        init();
        themeManager.init();
    </script>
</body>
</html>
