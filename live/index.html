<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Outil d'Écriture - Organisation par Chapitres</title>
    <link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:wght@300;400;600;700&family=Noto+Serif+JP:wght@300;500;700&family=Source+Code+Pro:wght@400;500&display=swap" rel="stylesheet">
    <!-- Export Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/docx/7.8.2/docx.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <!-- IndexedDB wrapper for easier usage -->
    <script src="https://cdn.jsdelivr.net/npm/idb@7/build/umd.js"></script>
    <!-- Excel Support -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <!-- Mammoth.js for DOCX import -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>
    <!-- Lucide Icons - Modern line icons -->
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.min.js"></script>
    <!-- Driver.js - Product Tour Library (bundled in CSS and JS) -->
    <style>
/* ========== vendor/driver.css ========== */
.driver-active .driver-overlay,.driver-active *{pointer-events:none}.driver-active .driver-active-element,.driver-active .driver-active-element *,.driver-popover,.driver-popover *{pointer-events:auto}@keyframes animate-fade-in{0%{opacity:0}to{opacity:1}}.driver-fade .driver-overlay{animation:animate-fade-in .2s ease-in-out}.driver-fade .driver-popover{animation:animate-fade-in .2s}.driver-popover{all:unset;box-sizing:border-box;color:#2d2d2d;margin:0;padding:15px;border-radius:5px;min-width:250px;max-width:300px;box-shadow:0 1px 10px #0006;z-index:1000000000;position:fixed;top:0;right:0;background-color:#fff}.driver-popover *{font-family:Helvetica Neue,Inter,ui-sans-serif,"Apple Color Emoji",Helvetica,Arial,sans-serif}.driver-popover-title{font:19px/normal sans-serif;font-weight:700;display:block;position:relative;line-height:1.5;zoom:1;margin:0}.driver-popover-close-btn{all:unset;position:absolute;top:0;right:0;width:32px;height:28px;cursor:pointer;font-size:18px;font-weight:500;color:#d2d2d2;z-index:1;text-align:center;transition:color;transition-duration:.2s}.driver-popover-close-btn:hover,.driver-popover-close-btn:focus{color:#2d2d2d}.driver-popover-title[style*=block]+.driver-popover-description{margin-top:5px}.driver-popover-description{margin-bottom:0;font:14px/normal sans-serif;line-height:1.5;font-weight:400;zoom:1}.driver-popover-footer{margin-top:15px;text-align:right;zoom:1;display:flex;align-items:center;justify-content:space-between}.driver-popover-progress-text{font-size:13px;font-weight:400;color:#727272;zoom:1}.driver-popover-footer button{all:unset;display:inline-block;box-sizing:border-box;padding:3px 7px;text-decoration:none;text-shadow:1px 1px 0 #fff;background-color:#fff;color:#2d2d2d;font:12px/normal sans-serif;cursor:pointer;outline:0;zoom:1;line-height:1.3;border:1px solid #ccc;border-radius:3px}.driver-popover-footer .driver-popover-btn-disabled{opacity:.5;pointer-events:none}:not(body):has(>.driver-active-element){overflow:hidden!important}.driver-no-interaction,.driver-no-interaction *{pointer-events:none!important}.driver-popover-footer button:hover,.driver-popover-footer button:focus{background-color:#f7f7f7}.driver-popover-navigation-btns{display:flex;flex-grow:1;justify-content:flex-end}.driver-popover-navigation-btns button+button{margin-left:4px}.driver-popover-arrow{content:"";position:absolute;border:5px solid #fff}.driver-popover-arrow-side-over{display:none}.driver-popover-arrow-side-left{left:100%;border-right-color:transparent;border-bottom-color:transparent;border-top-color:transparent}.driver-popover-arrow-side-right{right:100%;border-left-color:transparent;border-bottom-color:transparent;border-top-color:transparent}.driver-popover-arrow-side-top{top:100%;border-right-color:transparent;border-bottom-color:transparent;border-left-color:transparent}.driver-popover-arrow-side-bottom{bottom:100%;border-left-color:transparent;border-top-color:transparent;border-right-color:transparent}.driver-popover-arrow-side-center{display:none}.driver-popover-arrow-side-left.driver-popover-arrow-align-start,.driver-popover-arrow-side-right.driver-popover-arrow-align-start{top:15px}.driver-popover-arrow-side-top.driver-popover-arrow-align-start,.driver-popover-arrow-side-bottom.driver-popover-arrow-align-start{left:15px}.driver-popover-arrow-align-end.driver-popover-arrow-side-left,.driver-popover-arrow-align-end.driver-popover-arrow-side-right{bottom:15px}.driver-popover-arrow-side-top.driver-popover-arrow-align-end,.driver-popover-arrow-side-bottom.driver-popover-arrow-align-end{right:15px}.driver-popover-arrow-side-left.driver-popover-arrow-align-center,.driver-popover-arrow-side-right.driver-popover-arrow-align-center{top:50%;margin-top:-5px}.driver-popover-arrow-side-top.driver-popover-arrow-align-center,.driver-popover-arrow-side-bottom.driver-popover-arrow-align-center{left:50%;margin-left:-5px}.driver-popover-arrow-none{display:none}

/* ========== 01.variables.css ========== */
        :root {
            /* Thème épuré blanc */
            --bg-primary: #ffffff;
            --bg-primary-rgb: 255, 255, 255;
            --bg-secondary: #f8f9fa;
            --bg-secondary-rgb: 248, 249, 250;
            --bg-tertiary: #f0f1f3;
            --bg-tertiary-rgb: 240, 241, 243;
            --bg-accent: #2a2622;
            --bg-accent-rgb: 42, 38, 34;

            --text-primary: #1a1a1a;
            --text-primary-rgb: 26, 26, 26;
            --text-secondary: #666666;
            --text-muted: #999999;
            --border-color: #e0e0e0;

            /* Couleur principale (orange) */
            --primary-color: #ff8c42;
            --primary-color-rgb: 255, 140, 66;
            --primary-hover: #ff7629;

            /* Touches de couleur */
            --accent-red: #ff6b6b;
            --accent-red-rgb: 255, 107, 107;
            --accent-gold: #ffd93d;
            --accent-gold-rgb: 255, 217, 61;
            --accent-blue: #4a9eff;
            --accent-blue-rgb: 74, 158, 255;
            --accent-green: #51cf66;
            --accent-green-rgb: 81, 207, 102;
            --accent-purple: #a78bfa;
            --accent-purple-rgb: 167, 139, 250;
            --error-color: #dc2626;

            --shadow-color: 0, 0, 0;
            --shadow: rgba(var(--shadow-color), 0.08);

            /* Revision colors */
            --highlight-yellow: rgba(255, 235, 59, 0.4);
            --highlight-green: rgba(76, 175, 80, 0.3);
            --highlight-blue: rgba(33, 150, 243, 0.3);
            --highlight-red: rgba(244, 67, 54, 0.3);
            --highlight-purple: rgba(156, 39, 176, 0.3);

            /* Corkboard specific */
            --cork-bg-default: #fef9e7;
            --cork-bg-yellow: #ffd93d;
            --cork-bg-pink: #ff6b9d;
            --cork-bg-blue: #6bcfff;
            --cork-bg-green: #6bff9d;
            --cork-bg-purple: #c26bff;
            --cork-bg-orange: #ffb56b;
            --cork-bg-red: #ff6b6b;
            --cork-bg-teal: #6bffd9;
        }
/* ========== 02.base.css ========== */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

html {
    scroll-behavior: smooth;
}

body {
    font-family: 'Crimson Pro', serif;
    background: var(--bg-primary);
    color: var(--text-primary);
    overflow: hidden;
}

.app-container {
    display: flex;
    flex-direction: column;
    height: 100vh;
}

.app-header {
    flex-shrink: 0;
    height: 60px;
}

.app-content {
    display: flex;
    flex: 1;
    overflow: hidden;
}

.sidebar {
    flex-shrink: 0;
    width: 350px;
}

.sidebar-versions {
    flex-shrink: 0;
    width: 280px;
}

.sidebar-versions.hidden {
    display: none;
}

.editor-container {
    flex: 1;
    overflow: auto;
    min-height: 0;
}

textarea {
    resize: vertical;
}
/* ========== 03.header.css ========== */
/* Top Header */
        .app-header {
            background: var(--bg-primary);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            padding: 0 2rem;
            gap: 2rem;
            position: relative;
            z-index: 1000;
            box-shadow: 0 1px 3px var(--shadow);
            overflow: hidden;
        }
        
        .app-logo {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-size: 1.3rem;
            font-weight: 600;
            color: var(--accent-blue);
            font-family: 'Noto Serif JP', serif;
            white-space: nowrap;
            flex-shrink: 0;
        }
        
        .app-logo-icon {
            font-size: 1.5rem;
        }
        
        .header-nav {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex: 1;
            overflow-x: auto;
            overflow-y: hidden;
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE/Edge */
        }
        
        .header-nav::-webkit-scrollbar {
            display: none; /* Chrome/Safari */
        }
        
        .nav-group {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            padding-right: 1rem;
            border-right: 1px solid var(--border-color);
            flex-shrink: 0;
        }
        
        .nav-group:last-child {
            border-right: none;
        }
        
        .nav-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 0.25rem;
            padding: 0.5rem 0.5rem;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-family: 'Crimson Pro', serif;
            font-size: 0.7rem;
            border-radius: 8px;
            transition: all 0.2s ease;
            white-space: nowrap;
            flex-shrink: 0;
            min-width: 36px;
        }
        
        .nav-btn:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }
        
        .nav-btn.active {
            background: var(--primary-color);
            color: white;
            font-weight: 600;
        }
        
        .nav-btn-icon {
            font-size: 1.3rem;
            line-height: 1;
        }
        
        /* Lucide Icons Styling */
        .nav-btn-icon [data-lucide],
        .mobile-nav-item-icon [data-lucide],
        .header-action-btn [data-lucide],
        [data-lucide] {
            width: 18px;
            height: 18px;
            stroke-width: 1.75;
            vertical-align: middle;
        }
        
        .nav-btn-icon [data-lucide] {
            width: 20px;
            height: 20px;
        }
        
        .mobile-nav-item-icon [data-lucide] {
            width: 22px;
            height: 22px;
        }
        
        .header-action-btn [data-lucide] {
            width: 18px;
            height: 18px;
        }
        
        .app-logo-icon [data-lucide] {
            width: 24px;
            height: 24px;
            stroke: var(--primary-color);
        }
        
        .modal-title [data-lucide] {
            width: 22px;
            height: 22px;
            vertical-align: middle;
            margin-right: 8px;
        }
        
        .mobile-nav-section-title [data-lucide] {
            width: 16px;
            height: 16px;
            vertical-align: middle;
            margin-right: 6px;
        }
        
        .nav-btn-text {
            font-size: 0.7rem;
            line-height: 1;
        }
        
        .header-actions {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-left: auto;
            flex-shrink: 0;
        }
        
        .header-action-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 36px;
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            cursor: pointer;
            font-size: 1.1rem;
            border-radius: 4px;
            transition: all 0.2s ease;
        }
        
        .header-action-btn:hover:not(:disabled) {
            background: var(--accent-gold);
            color: white;
            border-color: var(--accent-gold);
        }
        
        .header-action-btn.active {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }
        
        .header-action-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

/* ========== 04.sidebar.css ========== */
/* Sidebar Navigation */
.sidebar {
    background: var(--bg-secondary);
    border-right: 2px solid var(--border-color);
    display: flex;
    flex-direction: column;
    position: relative;
    overflow: hidden;
}

/* Vertical Tools Sidebar */
.tools-sidebar {
    background: var(--bg-secondary);
    border-right: 2px solid var(--border-color);
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.5rem;
    padding: 1rem 0;
    width: 60px;
    flex-shrink: 0;
    overflow-y: auto;
}

.tool-btn {
    position: relative;
    width: 44px;
    height: 44px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: var(--bg-primary);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    color: var(--text-secondary);
    cursor: pointer;
    transition: all 0.2s ease;
    flex-shrink: 0;
}

.tool-btn:hover {
    background: var(--primary-color);
    color: white;
    border-color: var(--primary-color);
    transform: translateX(2px);
}

.tool-btn.active {
    background: var(--primary-color);
    color: white;
    border-color: var(--primary-color);
}

.tool-btn i {
    width: 20px;
    height: 20px;
}

.tool-badge {
    position: absolute;
    top: -4px;
    right: -4px;
    background: var(--accent-red);
    color: white;
    font-size: 0.65rem;
    font-weight: 700;
    padding: 0.15rem 0.35rem;
    border-radius: 10px;
    line-height: 1;
    min-width: 18px;
    text-align: center;
}

/* Hide old scene-tools */
.scene-tools {
    display: none !important;
}

/* Mobile: hide tools-sidebar on small screens */
@media (max-width: 900px) {
    .tools-sidebar {
        display: none !important;
    }
}

/* Sidebar Versions (pour les versions de scènes) */
.sidebar-versions {
    background: var(--bg-secondary);
    border-right: 2px solid var(--border-color);
    border-left: 1px solid var(--border-color);
    display: flex;
    flex-direction: column;
    overflow: hidden;
    min-width: 250px;
    width: 280px;
}

.sidebar-versions.hidden {
    display: none;
    min-width: 0;
    width: 0;
}

.sidebar-versions-header {
    padding: 1rem;
    border-bottom: 1px solid var(--border-color);
    background: var(--bg-secondary);
    flex-shrink: 0;
}

.sidebar-versions-title {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 0.5rem;
}

.sidebar-versions-title h3 {
    font-size: 0.9rem;
    font-weight: 600;
    color: var(--text-primary);
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.sidebar-versions-toggle {
    background: none;
    border: none;
    color: var(--text-muted);
    cursor: pointer;
    padding: 0.25rem;
    font-size: 1rem;
    transition: color 0.2s;
}

.sidebar-versions-toggle:hover {
    color: var(--text-primary);
}

.sidebar-versions-scene {
    font-size: 0.75rem;
    color: var(--text-muted);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.sidebar-versions-actions {
    padding: 0.75rem 1rem;
    border-bottom: 1px solid var(--border-color);
    background: var(--bg-primary);
    flex-shrink: 0;
}

.btn-new-version {
    width: 100%;
    padding: 0.6rem 1rem;
    background: var(--primary-color);
    color: white;
    border: none;
    border-radius: 6px;
    font-family: 'Crimson Pro', serif;
    font-size: 0.85rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
}

.btn-new-version:hover {
    background: var(--primary-hover);
    transform: translateY(-1px);
}

.sidebar-versions-list {
    flex: 1;
    overflow-y: auto;
    padding: 0.5rem;
}

.version-card {
    background: var(--bg-secondary);
    border: 2px solid var(--border-color);
    border-radius: 8px;
    padding: 0.75rem;
    margin-bottom: 0.5rem;
    cursor: pointer;
    transition: all 0.2s ease;
    position: relative;
}

.version-card:hover {
    border-color: var(--primary-color);
    background: rgba(var(--primary-color-rgb), 0.05);
}

.version-card.active {
    border-color: var(--primary-color);
    background: rgba(var(--primary-color-rgb), 0.1);
    box-shadow: 0 0 0 3px rgba(var(--primary-color-rgb), 0.15);
}

.version-card-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 0.5rem;
}

.version-card-number {
    font-size: 1.1rem;
    font-weight: 700;
    color: var(--primary-color);
}

.version-card-actions {
    display: flex;
    gap: 0.25rem;
    opacity: 1;
}

.version-card:hover .version-card-actions {
    opacity: 1;
}

.version-card-btn {
    background: var(--bg-tertiary);
    border: none;
    color: var(--text-muted);
    cursor: pointer;
    padding: 0.35rem;
    font-size: 0.8rem;
    border-radius: 4px;
    transition: all 0.2s;
}

.version-card-btn:hover {
    background: var(--bg-primary);
    color: var(--text-primary);
}

.version-card-btn.delete:hover {
    background: rgba(var(--accent-red-rgb), 0.1);
    color: var(--accent-red);
}

.version-card-date {
    font-size: 0.75rem;
    color: var(--text-muted);
}

.version-card-stats {
    font-size: 0.7rem;
    color: var(--text-secondary);
    margin-top: 0.25rem;
}

.version-card-label {
    font-size: 0.8rem;
    color: var(--text-secondary);
    margin-top: 0.5rem;
    font-style: italic;
}

/* Version finale */
.version-card.final {
    border-color: var(--accent-gold);
    background: rgba(var(--accent-gold-rgb), 0.1);
}

.version-card.final .version-card-number::after {
    content: ' ⭐';
}

.version-card-final-badge {
    display: inline-flex;
    align-items: center;
    gap: 0.25rem;
    background: var(--accent-gold);
    color: var(--bg-accent);
    font-size: 0.65rem;
    font-weight: 700;
    padding: 0.15rem 0.5rem;
    border-radius: 10px;
    margin-left: 0.5rem;
    text-transform: uppercase;
}

.version-card-btn.final {
    color: var(--text-muted);
}

.version-card-btn.final:hover {
    background: rgba(var(--accent-gold-rgb), 0.2);
    color: var(--accent-gold);
}

.version-card-btn.final.is-final {
    color: var(--accent-gold);
}

/* Sidebar Plot (Dabble Style) */
.sidebar-plot {
    background: var(--bg-secondary);
    border-left: 2px solid var(--border-color);
    display: flex;
    flex-direction: column;
    overflow: hidden;
    min-width: 250px;
    width: 280px;
    height: 100%;
    z-index: 10;
}

.sidebar-plot.hidden {
    display: none;
    min-width: 0;
    width: 0;
}

.sidebar-plot-header {
    padding: 1rem;
    border-bottom: 1px solid var(--border-color);
    background: var(--bg-secondary);
    flex-shrink: 0;
}

.sidebar-plot-title {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 0.5rem;
}

.sidebar-plot-title h3 {
    font-size: 0.9rem;
    font-weight: 600;
    color: var(--text-primary);
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin: 0;
}

.sidebar-plot-toggle {
    background: none;
    border: none;
    color: var(--text-muted);
    cursor: pointer;
    padding: 0.25rem;
    font-size: 1rem;
    transition: color 0.2s;
}

.sidebar-plot-toggle:hover {
    color: var(--text-primary);
}

.sidebar-plot-scene {
    font-size: 0.75rem;
    color: var(--text-muted);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.sidebar-plot-list {
    flex: 1;
    overflow-y: auto;
    padding: 1rem;
    display: flex;
    flex-direction: column;
    gap: 1rem;
}

.sidebar-plot-card {
    background: var(--bg-primary);
    border: 1px solid var(--border-color);
    border-radius: 4px;
    padding: 10px;
    cursor: pointer;
    transition: transform 0.2s, box-shadow 0.2s;
    position: relative;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
}

.sidebar-plot-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    border-color: var(--primary-color);
}

.sidebar-plot-card-line {
    font-size: 0.7rem;
    text-transform: uppercase;
    color: var(--text-muted);
    margin-bottom: 6px;
    letter-spacing: 0.5px;
    font-weight: 600;
}

.sidebar-plot-card-title {
    font-weight: 700;
    font-size: 0.9rem;
    margin-bottom: 4px;
    color: var(--text-primary);
}

.sidebar-plot-card-content {
    font-size: 0.8rem;
    color: var(--text-secondary);
    display: -webkit-box;
    -webkit-line-clamp: 3;
    line-clamp: 3;
    -webkit-box-orient: vertical;
    overflow: hidden;
    line-height: 1.4;
}

/* Links Panel (Sidebar) */
.links-panel-sidebar {
    background: var(--bg-secondary);
    border-left: 2px solid var(--border-color);
    border-right: 1px solid var(--border-color);
    display: flex;
    flex-direction: column;
    overflow: hidden;
    min-width: 250px;
    width: 280px;
    height: 100%;
    z-index: 10;
}

.links-panel-sidebar.hidden {
    display: none;
    min-width: 0;
    width: 0;
}

.links-panel-header {
    padding: 1rem;
    border-bottom: 1px solid var(--border-color);
    background: var(--bg-secondary);
    flex-shrink: 0;
    display: flex;
    align-items: center;
    justify-content: space-between;
}

.links-panel-header h3 {
    font-size: 0.9rem;
    font-weight: 600;
    color: var(--text-primary);
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin: 0;
}

.links-panel-close {
    background: none;
    border: none;
    color: var(--text-muted);
    cursor: pointer;
    padding: 0.25rem;
    font-size: 1rem;
    transition: color 0.2s;
}

.links-panel-close:hover {
    color: var(--text-primary);
}

.links-panel-content {
    flex: 1;
    overflow-y: auto;
    padding: 1rem;
}
/* ========== 05.modals.css ========== */
/* Diff Viewer Modal */
.diff-modal {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.6);
    z-index: 10000;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 2rem;
}

.diff-modal-content {
    background: var(--bg-primary);
    border-radius: 12px;
    width: 100%;
    max-width: 1200px;
    max-height: 90vh;
    display: flex;
    flex-direction: column;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
}

.diff-modal-header {
    padding: 1.25rem 1.5rem;
    border-bottom: 1px solid var(--border-color);
    display: flex;
    align-items: center;
    justify-content: space-between;
    flex-shrink: 0;
}

.diff-modal-title {
    font-size: 1.1rem;
    font-weight: 600;
    color: var(--text-primary);
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.diff-modal-close {
    background: none;
    border: none;
    font-size: 1.5rem;
    color: var(--text-muted);
    cursor: pointer;
    padding: 0.25rem;
    line-height: 1;
    transition: color 0.2s;
}

.diff-modal-close:hover {
    color: var(--text-primary);
}

.diff-toolbar {
    padding: 0.75rem 1.5rem;
    border-bottom: 1px solid var(--border-color);
    background: var(--bg-secondary);
    display: flex;
    align-items: center;
    justify-content: space-between;
    flex-wrap: wrap;
    gap: 1rem;
    flex-shrink: 0;
}

.diff-stats {
    display: flex;
    gap: 1rem;
    font-size: 0.85rem;
}

.diff-stat {
    display: flex;
    align-items: center;
    gap: 0.3rem;
}

.diff-stat.added {
    color: #2e7d32;
}

.diff-stat.removed {
    color: #c62828;
}

.diff-stat.changed {
    color: #f57c00;
}

.diff-view-toggle {
    display: flex;
    gap: 0.25rem;
}

.diff-view-btn {
    padding: 0.4rem 0.8rem;
    border: 1px solid var(--border-color);
    background: var(--bg-primary);
    color: var(--text-secondary);
    font-size: 0.8rem;
    cursor: pointer;
    transition: all 0.2s;
}

.diff-view-btn:first-child {
    border-radius: 4px 0 0 4px;
}

.diff-view-btn:last-child {
    border-radius: 0 4px 4px 0;
}

.diff-view-btn.active {
    background: var(--primary-color);
    color: white;
    border-color: var(--primary-color);
}

.diff-nav-buttons {
    display: flex;
    gap: 0.5rem;
}

.diff-nav-btn {
    padding: 0.4rem 0.8rem;
    border: 1px solid var(--border-color);
    background: var(--bg-primary);
    color: var(--text-secondary);
    font-size: 0.8rem;
    cursor: pointer;
    border-radius: 4px;
    transition: all 0.2s;
}

.diff-nav-btn:hover {
    background: var(--bg-tertiary);
    color: var(--text-primary);
}

.diff-content {
    flex: 1;
    overflow: auto;
    padding: 1rem;
}

/* Vue unifiée */
.diff-unified {
    font-family: 'Crimson Pro', serif;
    font-size: 1rem;
    line-height: 1.8;
    white-space: pre-wrap;
    word-wrap: break-word;
}

.diff-line {
    padding: 0.1rem 0.5rem;
    margin: 0 -0.5rem;
    border-radius: 3px;
}

.diff-line.added {
    background: rgba(46, 125, 50, 0.15);
}

.diff-line.removed {
    background: rgba(198, 40, 40, 0.15);
    text-decoration: line-through;
    opacity: 0.7;
}

.diff-word {
    padding: 0.1rem 0.2rem;
    border-radius: 2px;
}

.diff-word.added {
    background: rgba(46, 125, 50, 0.3);
    color: #1b5e20;
}

.diff-word.removed {
    background: rgba(198, 40, 40, 0.3);
    color: #b71c1c;
    text-decoration: line-through;
}

/* Vue côte à côte */
.diff-side-by-side {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 1rem;
    height: 100%;
}

.diff-side {
    border: 1px solid var(--border-color);
    border-radius: 8px;
    overflow: hidden;
    display: flex;
    flex-direction: column;
}

.diff-side-header {
    padding: 0.75rem 1rem;
    background: var(--bg-secondary);
    border-bottom: 1px solid var(--border-color);
    font-weight: 600;
    font-size: 0.85rem;
    display: flex;
    align-items: center;
    justify-content: space-between;
}

.diff-side-header.old {
    color: #c62828;
}

.diff-side-header.new {
    color: #2e7d32;
}

.diff-side-content {
    flex: 1;
    overflow: auto;
    padding: 1rem;
    font-family: 'Crimson Pro', serif;
    font-size: 1rem;
    line-height: 1.8;
    white-space: pre-wrap;
    word-wrap: break-word;
}

.diff-paragraph {
    margin-bottom: 1rem;
    padding: 0.5rem;
    border-radius: 4px;
    transition: background 0.2s;
}

.diff-paragraph.modified {
    background: rgba(255, 152, 0, 0.1);
    border-left: 3px solid #ff9800;
}

.diff-paragraph.added {
    background: rgba(46, 125, 50, 0.1);
    border-left: 3px solid #4caf50;
}

.diff-paragraph.removed {
    background: rgba(198, 40, 40, 0.1);
    border-left: 3px solid #f44336;
    text-decoration: line-through;
    opacity: 0.6;
}

.diff-highlight {
    cursor: pointer;
}

.diff-highlight:hover {
    filter: brightness(0.95);
}

.diff-empty-state {
    text-align: center;
    padding: 3rem;
    color: var(--text-muted);
}

.diff-empty-state-icon {
    font-size: 3rem;
    margin-bottom: 1rem;
}

/* Version selector dans le diff */
.diff-version-selector {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.85rem;
}

.diff-version-select {
    padding: 0.4rem 0.8rem;
    border: 1px solid var(--border-color);
    border-radius: 4px;
    background: var(--bg-primary);
    color: var(--text-primary);
    font-size: 0.85rem;
    cursor: pointer;
}

/* Bouton comparer dans version card */
.version-card-btn.compare {
    color: #1976d2;
}

.version-card-btn.compare:hover {
    background: rgba(25, 118, 210, 0.1);
    color: #1565c0;
}

.versions-empty {
    text-align: center;
    padding: 2rem 1rem;
    color: var(--text-muted);
}

.versions-empty-icon {
    font-size: 2.5rem;
    margin-bottom: 0.75rem;
    opacity: 0.5;
}

.versions-empty-text {
    font-size: 0.85rem;
    line-height: 1.5;
}

.versions-no-scene {
    text-align: center;
    padding: 3rem 1rem;
    color: var(--text-muted);
}

.versions-no-scene-icon {
    font-size: 3rem;
    margin-bottom: 1rem;
    opacity: 0.3;
}

.versions-no-scene-text {
    font-size: 0.9rem;
    line-height: 1.6;
}

/* Poignée de redimensionnement */
.sidebar-resize-handle {
    position: absolute;
    top: 0;
    right: 0;
    width: 8px;
    height: 100%;
    cursor: ew-resize;
    z-index: 3000;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background 0.2s;
}

.sidebar-resize-handle:hover {
    background: rgba(212, 175, 55, 0.1);
}

.sidebar-resize-handle:active {
    background: rgba(212, 175, 55, 0.2);
}

.resize-handle-line {
    width: 3px;
    height: 40px;
    background: var(--border-color);
    border-radius: 2px;
    transition: all 0.2s;
}

.sidebar-resize-handle:hover .resize-handle-line {
    background: var(--accent-gold);
    height: 60px;
}


.sidebar-header {
    padding: 1.5rem 1rem 1rem;
    border-bottom: 1px solid var(--border-color);
    position: relative;
    z-index: 2600;
    flex-shrink: 0;
}

.search-container {
    position: relative;
    margin-bottom: 1rem;
    z-index: 10;
}

.search-input {
    width: 100%;
    padding: 0.75rem 2.5rem 0.75rem 1rem;
    border: 1px solid var(--border-color);
    background: var(--bg-primary);
    font-family: 'Crimson Pro', serif;
    font-size: 0.9rem;
    color: var(--text-primary);
    border-radius: 2px;
    outline: none;
    transition: all 0.2s ease;
}

.search-input:focus {
    border-color: var(--accent-gold);
    box-shadow: 0 0 0 2px rgba(212, 175, 55, 0.1);
}

.search-icon {
    position: absolute;
    right: 0.75rem;
    top: 50%;
    transform: translateY(-50%);
    color: var(--text-muted);
    font-size: 1.2rem;
    pointer-events: none;
}

.search-results {
    position: absolute;
    top: 100%;
    left: 0;
    right: 0;
    background: var(--bg-primary);
    border: 2px solid var(--accent-gold);
    border-radius: 4px;
    max-height: 400px;
    overflow-y: auto;
    z-index: 20;
    box-shadow: 0 4px 16px var(--shadow);
    margin-top: 0.5rem;
    display: none;
}

.search-results.active {
    display: block;
}

.search-result-item {
    padding: 0.75rem 1rem;
    border-bottom: 1px solid var(--border-color);
    cursor: pointer;
    transition: all 0.2s ease;
}

.search-result-item:last-child {
    border-bottom: none;
}

.search-result-item:hover {
    background: rgba(212, 175, 55, 0.1);
}

.search-result-type {
    font-size: 0.7rem;
    padding: 0.2rem 0.5rem;
    background: var(--accent-gold);
    color: var(--bg-primary);
    border-radius: 2px;
    margin-bottom: 0.5rem;
    display: inline-block;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    font-weight: 600;
}

.search-result-title {
    font-size: 0.9rem;
    font-weight: 600;
    margin-bottom: 0.25rem;
    color: var(--text-primary);
}

.search-result-path {
    font-size: 0.75rem;
    color: var(--text-muted);
    margin-bottom: 0.5rem;
}

.search-result-preview {
    font-size: 0.8rem;
    color: var(--text-secondary);
    line-height: 1.4;
}

.search-highlight {
    background: rgba(212, 175, 55, 0.3);
    font-weight: 600;
    padding: 0 2px;
}

.search-no-results {
    padding: 2rem;
    text-align: center;
    color: var(--text-muted);
    font-style: italic;
}

.view-tabs {
    display: flex;
    gap: 0.5rem;
    margin-bottom: 1rem;
}

.view-tab {
    flex: 1;
    padding: 0.5rem;
    border: 1px solid var(--border-color);
    background: var(--bg-primary);
    color: var(--text-secondary);
    cursor: pointer;
    font-family: 'Crimson Pro', serif;
    font-size: 0.85rem;
    font-weight: 500;
    transition: all 0.2s ease;
    border-radius: 2px;
    text-align: center;
}

.view-tab:hover {
    background: var(--bg-secondary);
}

.view-tab.active {
    background: var(--accent-gold);
    color: var(--bg-primary);
    border-color: var(--accent-gold);
}

.project-title {
    font-family: 'Noto Serif JP', serif;
    font-size: 1.5rem;
    font-weight: 700;
    color: var(--text-primary);
    margin-bottom: 0.5rem;
    letter-spacing: 0.02em;
}

.project-stats {
    font-size: 0.85rem;
    color: var(--text-muted);
    font-weight: 300;
    display: flex;
    gap: 1rem;
}

.chapters-list {
    flex: 1;
    overflow-y: auto;
    padding: 1rem 0;
    position: relative;
    z-index: 1;
}

.database-list {
    flex: 1;
    overflow-y: auto;
    padding: 1rem;
    position: relative;
    z-index: 1;
}

/* Treeview compact style */
.treeview-group {
    margin-bottom: 0.25rem;
}

.treeview-header {
    display: flex;
    align-items: center;
    gap: 0.25rem;
    padding: 0.4rem 0.5rem;
    cursor: pointer;
    border-radius: 4px;
    transition: background 0.15s;
    user-select: none;
}

.treeview-header:hover {
    background: var(--bg-secondary);
}

.treeview-chevron {
    width: 14px;
    height: 14px;
    color: var(--text-muted);
    flex-shrink: 0;
}

.treeview-label {
    font-size: 0.8rem;
    font-weight: 600;
    color: var(--text-secondary);
    text-transform: uppercase;
    letter-spacing: 0.03em;
    flex: 1;
}

.treeview-count {
    font-size: 0.7rem;
    color: var(--text-muted);
    background: var(--bg-secondary);
    padding: 0.1rem 0.4rem;
    border-radius: 10px;
}

.treeview-add-btn {
    width: 20px;
    height: 20px;
    padding: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    background: transparent;
    border: none;
    border-radius: 4px;
    color: var(--text-secondary);
    cursor: pointer;
    transition: all 0.2s ease;
    opacity: 0;
}

.treeview-header:hover .treeview-add-btn {
    opacity: 1;
}

.treeview-add-btn:hover {
    background: var(--accent-gold);
    color: white;
}

.treeview-children {
    margin-left: 0.5rem;
    border-left: 1px solid var(--border-color);
    padding-left: 0.5rem;
    overflow: hidden;
    transition: max-height 0.2s ease, opacity 0.2s ease;
}

.treeview-children.collapsed {
    display: none;
}

.treeview-item {
    display: flex;
    align-items: center;
    gap: 0.4rem;
    padding: 0.35rem 0.5rem;
    cursor: grab;
    border-radius: 4px;
    transition: background 0.15s;
    position: relative;
}

.treeview-item:active {
    cursor: grabbing;
}

.treeview-item:hover {
    background: var(--bg-secondary);
}

.treeview-item.dragging {
    opacity: 0.5;
    cursor: grabbing;
}

.treeview-item:hover .treeview-item-delete {
    opacity: 1;
}

.treeview-item-icon {
    font-size: 0.85rem;
    flex-shrink: 0;
    width: 18px;
    text-align: center;
}

.treeview-item-label,
.treeview-item-name {
    font-size: 0.85rem;
    color: var(--text-primary);
    flex: 1;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.treeview-item-delete {
    opacity: 0;
    background: none;
    border: none;
    color: var(--text-muted);
    cursor: pointer;
    padding: 0 0.25rem;
    font-size: 1rem;
    line-height: 1;
    transition: opacity 0.15s, color 0.15s;
    display: flex;
    align-items: center;
    justify-content: center;
}

.treeview-item-delete i {
    width: 14px;
    height: 14px;
}

.treeview-item-delete:hover {
    color: var(--accent-red);
}

.database-card {
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 4px;
    padding: 1rem;
    margin-bottom: 0.75rem;
    cursor: pointer;
    transition: all 0.2s ease;
}

.database-card:hover {
    border-color: var(--accent-gold);
    background: rgba(212, 175, 55, 0.05);
    transform: translateX(2px);
}

/* Acts Hierarchy */
.act-group {
    margin-bottom: 0.25rem;
}

.act-header {
    padding: 0.3rem 0.5rem;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 0.3rem;
    transition: all 0.15s ease;
    position: relative;
    background: var(--bg-secondary);
    border-left: 3px solid var(--accent-red);
    border-radius: 0 4px 4px 0;
    font-weight: 600;
    font-size: 0.85rem;
}

.act-header:hover {
    background: var(--bg-tertiary);
}

.act-header.active {
    background: var(--accent-red);
    color: white;
}

.act-icon {
    font-size: 0.65rem;
    transition: transform 0.2s ease;
    color: var(--accent-red);
    width: 12px;
    text-align: center;
}

.act-header.active .act-icon {
    color: white;
}

/* .act-icon.expanded {
    transform: rotate(90deg);
} */

.act-title {
    flex: 1;
    font-size: 0.8rem;
    font-family: 'Noto Serif JP', serif;
    letter-spacing: 0.01em;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.act-count {
    font-size: 0.65rem;
    opacity: 0.7;
    font-family: 'Source Code Pro', monospace;
}

.act-chapters {
    display: none;
    padding-left: 0.25rem;
}

.act-chapters.visible {
    display: block;
}

.chapter-group {
    margin-bottom: 0.1rem;
}

.chapter-header {
    padding: 0.25rem 0.5rem;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 0.3rem;
    transition: all 0.15s ease;
    position: relative;
    border-radius: 4px;
    font-size: 0.8rem;
}

.chapter-header:hover {
    background: var(--bg-secondary);
}

.chapter-header.active {
    background: var(--primary-color);
    color: white;
}

.chapter-icon {
    font-size: 0.6rem;
    transition: transform 0.2s ease;
    color: var(--text-muted);
    width: 10px;
    text-align: center;
}

.chapter-header.active .chapter-icon {
    color: white;
}

/* .chapter-icon.expanded {
    transform: rotate(90deg);
} */

.chapter-title {
    flex: 1;
    font-size: 0.8rem;
    font-weight: 600;
    letter-spacing: 0.01em;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.chapter-count {
    font-size: 0.65rem;
    opacity: 0.7;
    font-family: 'Source Code Pro', monospace;
}

.scenes-list {
    display: none;
    padding-left: 0.75rem;
}

.scenes-list.visible {
    display: block;
}

.scene-item {
    padding: 0.2rem 0.5rem;
    cursor: pointer;
    font-size: 0.78rem;
    transition: all 0.15s ease;
    border-left: 2px solid transparent;
    color: var(--text-secondary);
    display: flex;
    align-items: center;
    gap: 0.25rem;
}

.scene-item:hover {
    background: var(--bg-secondary);
    border-left-color: var(--accent-red);
}

.scene-item.active {
    background: rgba(196, 69, 54, 0.1);
    border-left-color: var(--accent-red);
    color: var(--text-primary);
    font-weight: 500;
}

.scene-synopsis {
    display: none;
    font-size: 0.7rem;
    color: var(--text-muted);
    font-style: italic;
    line-height: 1.2;
    margin-top: 0.1rem;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    opacity: 0.8;
}

.scene-item:hover .scene-synopsis {
    display: block;
    opacity: 1;
}

/* Tree collapse toolbar */
.tree-collapse-toolbar {
    display: flex;
    gap: 0.25rem;
    padding: 0.35rem 0.5rem;
    background: var(--bg-secondary);
    border-bottom: 1px solid var(--border-color);
}

.tree-collapse-btn {
    display: flex;
    align-items: center;
    gap: 0.25rem;
    padding: 0.2rem 0.5rem;
    background: var(--bg-primary);
    border: 1px solid var(--border-color);
    border-radius: 3px;
    font-size: 0.7rem;
    color: var(--text-secondary);
    cursor: pointer;
    transition: all 0.15s ease;
}

.tree-collapse-btn:hover {
    background: var(--bg-tertiary);
    border-color: var(--primary-color);
    color: var(--primary-color);
}

.sidebar-actions {
    padding: 0.75rem 1rem;
    border-top: 1px solid var(--border-color);
    background: var(--bg-primary);
    display: flex;
    gap: 0.4rem;
    position: relative;
    z-index: 1;
    flex-shrink: 0;
}

.sidebar-actions .btn {
    flex: 1;
    padding: 0.5rem 0.25rem;
    font-size: 0.75rem;
    white-space: nowrap;
}

/* Scene Tools Bar */
.scene-tools {
    display: flex;
    gap: 0.5rem;
    padding: 0.75rem 1rem;
    background: var(--bg-secondary);
    border-bottom: 1px solid var(--border-color);
}

.scene-tool-btn {
    display: flex;
    align-items: center;
    gap: 0.4rem;
    padding: 0.5rem 0.75rem;
    background: var(--bg-primary);
    border: 1px solid var(--border-color);
    border-radius: 4px;
    color: var(--text-secondary);
    font-size: 0.8rem;
    font-family: 'Crimson Pro', serif;
    cursor: pointer;
    transition: all 0.2s ease;
    flex: 1;
    justify-content: center;
}

.scene-tool-btn:hover {
    background: var(--bg-tertiary);
    color: var(--text-primary);
}

.scene-tool-btn.active {
    background: var(--primary-color);
    border-color: var(--primary-color);
    color: white;
}

.scene-tool-btn [data-lucide] {
    width: 16px;
    height: 16px;
}

.scene-tool-badge {
    background: var(--accent-red);
    color: white;
    font-size: 0.65rem;
    padding: 0.1rem 0.4rem;
    border-radius: 10px;
    font-weight: 600;
    margin-left: 0.25rem;
}
/* ========== 06.editor.css ========== */
/* Main Editor */
.editor-container {
    display: block;
    /* Mieux pour le sticky que flex */
    background: var(--bg-primary);
    height: calc(100vh - 60px);
    overflow-y: auto;
    overflow-x: hidden;
}

#editorView {
    position: relative;
    min-height: 100%;
}

.editor-header {
    padding: 2rem 3rem 1rem;
    border-bottom: 1px solid var(--border-color);
    background: var(--bg-primary);
}

.editor-breadcrumb {
    font-size: 0.85rem;
    color: var(--text-muted);
    margin-bottom: 0.75rem;
    font-weight: 300;
}

.editor-title {
    font-family: 'Noto Serif JP', serif;
    font-size: 2rem;
    font-weight: 700;
    color: var(--text-primary);
    margin-bottom: 0.5rem;
    letter-spacing: 0.01em;
}

.editor-meta {
    display: flex;
    gap: 2rem;
    font-size: 0.85rem;
    color: var(--text-muted);
    font-family: 'Source Code Pro', monospace;
}

.editor-synopsis {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin-top: 0.75rem;
    padding-top: 0.75rem;
    border-top: 1px dashed var(--border-color);
}

.synopsis-label {
    display: flex;
    align-items: center;
    gap: 0.3rem;
    font-size: 0.8rem;
    color: var(--text-muted);
    white-space: nowrap;
}

.synopsis-input {
    flex: 1;
    min-width: 200px;
    padding: 0.4rem 0.6rem;
    font-size: 0.85rem;
    font-style: italic;
    color: var(--text-secondary);
    background: transparent;
    border: 1px solid transparent;
    border-radius: 4px;
    transition: all 0.2s;
}

.synopsis-input:hover {
    background: var(--bg-secondary);
    border-color: var(--border-color);
}

.synopsis-input:focus {
    outline: none;
    background: var(--bg-primary);
    border-color: var(--primary-color);
    font-style: normal;
}

.synopsis-input::placeholder {
    color: var(--text-muted);
    font-style: italic;
}

.editor-toolbar {
    display: flex;
    gap: 8px;
    padding: 8px 16px;
    border-bottom: 1px solid var(--border-color);
    background: var(--bg-primary);
    flex-wrap: wrap;
    align-items: center;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    overflow: visible;
    position: sticky;
    top: 0;
    z-index: 110;
}

.editor-toolbar::-webkit-scrollbar {
    display: none;
}

.links-panel-toggle {
    display: none;
    width: 100%;
    padding: 0.5rem;
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 6px;
    font-size: 0.9rem;
    color: var(--text-primary);
    cursor: pointer;
    text-align: center;
    font-weight: 600;
}

.links-panel-toggle:active {
    background: var(--accent-gold);
    color: white;
}

.links-panel-sticky {
    padding: 1rem 3rem;
    background: var(--bg-primary);
    border-bottom: 1px solid var(--border-color);
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
}

.links-panel-sticky.hidden {
    display: none;
}

.editor-content {
    max-width: none;
    margin: 0 auto;
    padding: 3rem;
}

.editor-textarea {
    width: 100%;
    min-height: 1200px;
    border: none;
    background: transparent;
    font-family: 'Crimson Pro', serif;
    font-size: 1.15rem;
    line-height: 1.8;
    color: var(--text-primary);
    outline: none;
    font-weight: 400;
}

.editor-textarea:focus {
    outline: none;
}

.editor-textarea::placeholder {
    color: var(--text-muted);
    font-style: italic;
}

/* Buttons */
.btn {
    padding: 0.6rem 1.2rem;
    border: 1px solid var(--border-color);
    background: var(--bg-primary);
    color: var(--text-primary);
    cursor: pointer;
    font-family: 'Crimson Pro', serif;
    font-size: 0.9rem;
    font-weight: 500;
    transition: all 0.2s ease;
    border-radius: 8px;
}

.btn:hover {
    background: var(--bg-secondary);
    border-color: var(--text-secondary);
}

.btn-primary {
    background: var(--primary-color);
    color: white;
    border-color: var(--primary-color);
    border-radius: 8px;
    padding: 0.75rem 1.5rem;
    font-weight: 600;
}

.btn-primary:hover {
    background: var(--primary-hover);
    border-color: var(--primary-hover);
}

.btn-secondary {
    background: var(--bg-secondary);
    color: var(--text-primary);
    border: 2px solid var(--border-color);
    border-radius: 8px;
    padding: 0.75rem 1.5rem;
    font-weight: 600;
    cursor: pointer;
    font-family: 'Crimson Pro', serif;
    font-size: 0.9rem;
    transition: all 0.2s ease;
}

.btn-secondary:hover {
    background: var(--bg-tertiary);
    border-color: var(--text-secondary);
}

.btn-small {
    padding: 0.4rem 0.8rem;
    font-size: 0.8rem;
}

.btn-icon {
    padding: 0.5rem;
    width: 32px;
    height: 32px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
}

/* Empty State */
.empty-state {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    text-align: center;
    padding: 3rem;
}

.empty-state-icon {
    font-size: 4rem;
    margin-bottom: 1.5rem;
    opacity: 0.3;
}

.empty-state-icon [data-lucide] {
    width: 64px;
    height: 64px;
    stroke-width: 1.5;
}

.empty-state-title {
    font-size: 1.5rem;
    font-weight: 600;
    margin-bottom: 0.5rem;
    color: var(--text-primary);
}

.empty-state-text {
    color: var(--text-muted);
    margin-bottom: 1.5rem;
    max-width: 400px;
}

/* Modal */
.modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(var(--bg-accent-rgb), 0.6);
    backdrop-filter: blur(4px);
    z-index: 1000;
    align-items: center;
    justify-content: center;
}

.modal.active {
    display: flex;
}

.modal-content {
    background: var(--bg-primary);
    padding: 2rem;
    border-radius: 4px;
    max-width: 500px;
    width: 90%;
    max-height: 90vh;
    display: flex;
    flex-direction: column;
    box-shadow: 0 8px 32px var(--shadow);
    border: 2px solid var(--border-color);
}

/* Modal overlay pour thèmes */
.modal-overlay {
    display: flex;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(var(--bg-accent-rgb), 0.85);
    backdrop-filter: blur(4px);
    align-items: center;
    justify-content: center;
    z-index: 10000;
}

.modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding-bottom: 1rem;
    margin-bottom: 1.5rem;
    border-bottom: 2px solid var(--accent-gold);
    flex-shrink: 0;
}

.modal-header h2 {
    margin: 0;
    font-family: 'Noto Serif JP', serif;
}

.modal-close {
    background: transparent;
    border: none;
    font-size: 2rem;
    cursor: pointer;
    color: var(--text-muted);
    padding: 0.5rem;
    line-height: 1;
    transition: all 0.2s;
    border-radius: 4px;
    min-width: 44px;
    min-height: 44px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.modal-close:hover {
    color: var(--accent-red);
    background: rgba(var(--accent-red-rgb), 0.1);
}

.modal-close:active {
    transform: scale(0.95);
}

.modal-title {
    font-size: 1.5rem;
    font-weight: 600;
    margin-bottom: 1.5rem;
    font-family: 'Noto Serif JP', serif;
}

.modal-body {
    margin-bottom: 1.5rem;
    overflow-y: auto;
    flex: 1;
    min-height: 0;
}

.modal-footer {
    display: flex;
    gap: 0.75rem;
    justify-content: flex-end;
    align-items: center;
    padding-top: 1.5rem;
    margin-top: 1.5rem;
    border-top: 1px solid var(--border-color);
    flex-shrink: 0;
}

.form-group {
    margin-bottom: 1.5rem;
}

.form-label {
    display: block;
    margin-bottom: 0.5rem;
    font-weight: 500;
    color: var(--text-secondary);
}

.form-input {
    width: 100%;
    padding: 0.75rem;
    border: 1px solid var(--border-color);
    background: var(--bg-secondary);
    font-family: 'Crimson Pro', serif;
    font-size: 1rem;
    color: var(--text-primary);
    border-radius: 2px;
    outline: none;
    transition: all 0.2s ease;
    resize: vertical;
}

.form-input:focus {
    border-color: var(--accent-gold);
    background: var(--bg-primary);
}


/*//////////////////////////////////////////////////////////
//  Focus mode panel
///////////////////////////////////////////////////////////*/

.focus-mode-panel {
    position: fixed;
    top: 0;
    right: 0;
    width: 350px;
    height: 100vh;
    background: var(--bg-primary);
    border-left: 2px solid var(--accent-gold);
    box-shadow: -8px 0 24px rgba(0, 0, 0, 0.3);
    transform: translateX(100%);
    transition: transform 0.3s ease;
    z-index: 2000;
    display: flex;
    flex-direction: column;
}

.focus-mode-panel.active {
    transform: translateX(0);
}

.app-container.focus-mode .focus-mode-panel {
    display: flex;
}

.focus-panel-header {
    padding: 1.5rem;
    border-bottom: 2px solid var(--border-color);
    background: var(--bg-accent);
    color: var(--bg-primary);
}

.focus-panel-title {
    font-size: 1.2rem;
    font-weight: 700;
    font-family: 'Noto Serif JP', serif;
}

.focus-panel-content {
    flex: 1;
    overflow-y: auto;
    padding: 1.5rem;
}

.focus-section {
    margin-bottom: 2rem;
}

.focus-section-title {
    font-size: 0.9rem;
    font-weight: 600;
    color: var(--text-primary);
    margin-bottom: 0.75rem;
    text-transform: uppercase;
    letter-spacing: 0.05em;
}

.pomodoro-timer {
    text-align: center;
    padding: 2rem;
    background: var(--bg-primary);
    border-radius: 4px;
    border: 2px solid var(--border-color);
}

.pomodoro-display {
    font-size: 3rem;
    font-weight: 700;
    font-family: 'Source Code Pro', monospace;
    color: var(--text-primary);
    margin-bottom: 1rem;
}

.pomodoro-controls {
    display: flex;
    gap: 0.5rem;
    justify-content: center;
}

.ambient-music {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
}

.focus-toggle-btn {
    position: fixed;
    bottom: 2rem;
    right: 2rem;
    z-index: 2001;
    background: var(--accent-gold);
    color: var(--bg-primary);
    border: none;
    padding: 0.75rem 1.25rem;
    border-radius: 4px;
    cursor: pointer;
    font-weight: 600;
    font-size: 0.9rem;
    transition: all 0.2s ease;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    display: none;
    font-family: 'Crimson Pro', serif;
}

.app-container.focus-mode .focus-toggle-btn {
    display: block !important;
}

.focus-toggle-btn:hover {
    background: var(--accent-red);
    transform: translateY(-2px);
    box-shadow: 0 4px 12px var(--shadow);
}

.focus-stats {
    display: flex;
    gap: 1rem;
    margin-top: 1rem;
}

.focus-stat-box {
    flex: 1;
    padding: 0.75rem;
    background: var(--bg-primary);
    border: 1px solid var(--border-color);
    border-radius: 2px;
    text-align: center;
}

.focus-stat-value {
    font-size: 1.5rem;
    font-weight: 700;
    color: var(--accent-gold);
    font-family: 'Source Code Pro', monospace;
}

.focus-stat-label {
    font-size: 0.75rem;
    color: var(--text-muted);
    margin-top: 0.25rem;
}

/* =========================================
   STYLES POUR LE PANNEAU DE LIENS (Auto-detect)
   ========================================= */

/* Conteneur de base pour un item (perso ou lieu) */
.link-item .quick-links {
    display: flex;
    justify-content: space-between;
    align-items: center;
    /*padding: 6px 8px;*/
    margin-bottom: 2px;
    border-radius: 6px;
    transition: all 0.2s ease;
    font-size: 0.9rem;
    border: 1px solid transparent;
}

/* --- ZONES D'ÉTAT --- */

/* 1. Présent (Validé) - Vert subtil */
.link-item.present {
    background-color: rgba(var(--accent-green-rgb), 0.1);
    /* Vert très clair */
    border-left: 3px solid var(--accent-green);
}

.link-item.present:hover {
    background-color: rgba(46, 204, 113, 0.2);
}

/* 2. Suggéré (En attente) - Orange/Accent */
.link-item.suggested {
    background-color: rgba(var(--accent-gold-rgb), 0.1);
    /* Orange très clair */
    border-left: 3px solid var(--accent-gold);
}

.link-item.suggested:hover {
    background-color: rgba(255, 165, 0, 0.2);
}

/* 3. Absent (Ignoré) - Grisé et discret */
.link-item.absent {
    background-color: rgba(255, 255, 255, 0.03);
    border: 1px solid var(--border-color, #ccc);
    opacity: 0.7;
    filter: grayscale(0.8);
}

.link-item.absent:hover {
    opacity: 1;
    filter: grayscale(0);
    background-color: rgba(255, 255, 255, 0.08);
}

.link-item.absent span {
    text-decoration: line-through;
    color: var(--text-muted, #888);
}

/* --- ÉLÉMENTS INTERNES --- */

/* Avatar et Nom */
.link-item>div:first-child {
    display: flex;
    align-items: center;
    gap: 8px;
    overflow: hidden;
    /* Pour les noms très longs */
}

.link-item span {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

/* --- BOUTONS D'ACTION (Icônes) --- */
.btn-icon {
    background: none;
    border: none;
    cursor: pointer;
    padding: 4px;
    border-radius: 4px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: transform 0.2s, background-color 0.2s, color 0.2s;
    color: var(--text-muted, #888);
}

.btn-icon:hover {
    background-color: rgba(0, 0, 0, 0.1);
    /* Ou blanc semi-transparent en thème sombre */
    transform: scale(1.1);
    color: var(--text-main, #000);
}

/* Couleurs spécifiques au survol des boutons */
.btn-icon[title*="Valider"]:hover {
    color: #2ecc71;
    /* Vert au survol */
    background-color: rgba(46, 204, 113, 0.15);
}

.btn-icon[title*="Retirer"]:hover,
.btn-icon[title*="Ignorer"]:hover {
    color: #e74c3c;
    /* Rouge au survol */
    background-color: rgba(231, 76, 60, 0.15);
}

.btn-icon[title*="Rétablir"]:hover {
    color: #3498db;
    /* Bleu au survol */
    background-color: rgba(52, 152, 219, 0.15);
}

/* AJOUT/MODIFICATION DANS VOTRE FICHIER CSS */

#linksPanel .quick-links h4 {
    /* Garantit que le texte est aligné à gauche */
    text-align: left;
    /* S'assure qu'ils prennent toute la largeur pour être bien distincts */
    width: 100%;
    /* S'assure qu'ils sont des blocs distincts, ce qui est le défaut de <h4> */
    display: block;
}

/* --- CHAPTER EDITOR (SEQUENTIAL SCENES) --- */

/* Séparateur de scène */
.scene-separator {
    margin: 3rem 0 2rem;
    padding: 1.5rem 2rem;
    background: var(--bg-secondary);
    border-left: 4px solid var(--primary-color);
    border-radius: 8px;
}

.scene-separator-title {
    font-family: 'Noto Serif JP', serif;
    font-size: 1.5rem;
    font-weight: 600;
    color: var(--text-primary);
    margin-bottom: 0.5rem;
}

.scene-separator-meta {
    display: flex;
    flex-wrap: wrap;
    align-items: flex-start;
    gap: 1.5rem;
    font-size: 0.85rem;
    color: var(--text-muted);
    font-family: 'Source Code Pro', monospace;
}

.scene-separator-synopsis {
    font-style: italic;
    color: var(--text-secondary);
    font-family: 'Source Code Pro', monospace;
    font-size: 0.85rem;
    background: transparent;
    border: 1px solid transparent;
    border-radius: 4px;
    padding: 0.3rem 0.5rem;
    resize: vertical;
    min-height: 1.5em;
    width: 100%;
    flex: 1;
    transition: all 0.2s ease;
}

.scene-separator-synopsis:hover {
    background: var(--bg-primary);
    border-color: var(--border-color);
}

.scene-separator-synopsis:focus {
    outline: none;
    background: var(--bg-primary);
    border-color: var(--primary-color);
    font-style: normal;
}

.scene-separator-synopsis::placeholder {
    color: var(--text-muted);
    font-style: italic;
    opacity: 0.6;
}

/* Bloc de scène dans le mode chapitre */
.chapter-scene-block {
    margin-bottom: 0;
}

.chapter-scene-block .editor-textarea {
    margin-bottom: 0;
}

/* Indicateur de progression vertical */
.chapter-progress-indicator {
    position: fixed;
    right: 20px;
    top: 50%;
    transform: translateY(-50%);
    width: 8px;
    height: 300px;
    background: var(--bg-secondary);
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    overflow: hidden;
    z-index: 200;
}

.progress-scene-segment {
    width: 100%;
    background: var(--border-color);
    border-bottom: 1px solid var(--bg-primary);
    cursor: pointer;
    transition: background 0.2s ease, transform 0.2s ease;
    position: relative;
}

.progress-scene-segment:hover {
    background: var(--text-muted);
    transform: scaleX(1.5);
    z-index: 10;
}

.progress-scene-segment.active {
    background: var(--primary-color);
}

.progress-current-indicator {
    position: absolute;
    left: -4px;
    width: 16px;
    height: 3px;
    background: var(--bg-accent);
    border-radius: 2px;
    box-shadow: 0 0 8px rgba(255, 193, 7, 0.8);
    transition: top 0.3s ease;
    pointer-events: none;
}

/* --- ACT EDITOR (SEQUENTIAL CHAPTERS & SCENES) --- */

/* Séparateur de chapitre */
.chapter-separator {
    margin: 4rem 0 2rem;
    padding: 2rem 2.5rem;
    background: linear-gradient(135deg, var(--primary-color) 0%, var(--primary-color-dark, #2c5aa0) 100%);
    border-radius: 12px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
}

.chapter-separator-title {
    font-family: 'Noto Serif JP', serif;
    font-size: 2rem;
    font-weight: 700;
    color: white;
    margin-bottom: 0.75rem;
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

.chapter-separator-meta {
    display: flex;
    gap: 2rem;
    font-size: 0.9rem;
    color: rgba(255, 255, 255, 0.9);
    font-family: 'Source Code Pro', monospace;
}

/* Bloc de chapitre dans le mode acte */
.act-chapter-block {
    margin-bottom: 2rem;
}

/* Bloc de scène dans le mode acte */
.act-scene-block {
    margin-bottom: 0;
}

.act-scene-block .editor-textarea {
    margin-bottom: 0;
}

/* --- SCENE NAVIGATION TOOLBAR --- */

.scene-nav-toolbar {
    position: fixed;
    z-index: 500;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.2s ease;
}

.scene-nav-toolbar.visible {
    opacity: 1;
    pointer-events: auto;
}

.scene-nav-buttons {
    position: fixed;
    display: flex;
    gap: 2px;
    pointer-events: auto;
}

.scene-nav-line {
    display: none;
}

.scene-nav-word-counts {
    position: fixed;
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    gap: 0;
    pointer-events: auto;
}

.scene-nav-words-before,
.scene-nav-words-after {
    font-family: 'Source Code Pro', monospace;
    font-size: 0.75rem;
    white-space: nowrap;
    line-height: 1.2;
}

.scene-nav-words-before {
    color: var(--accent-gold);
}

.scene-nav-words-after {
    color: var(--primary-color);
}

.scene-nav-btn {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 28px;
    height: 28px;
    border: none;
    border-radius: 50%;
    background: var(--bg-secondary);
    color: var(--text-secondary);
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    border: 1px solid var(--border-color);
}

.scene-nav-btn:hover {
    background: var(--primary-color);
    color: white;
    transform: scale(1.1);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}

.scene-nav-btn:active {
    transform: scale(0.95);
}

.scene-nav-btn svg {
    width: 14px;
    height: 14px;
}

.scene-nav-prev:hover {
    background: var(--accent-gold);
}

.scene-nav-next:hover {
    background: var(--primary-color);
}

/* Notification animation */
@keyframes slideUp {
    from {
        opacity: 0;
        transform: translateX(-50%) translateY(20px);
    }

    to {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
    }
}

@keyframes slideDown {
    from {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
    }

    to {
        opacity: 0;
        transform: translateX(-50%) translateY(20px);
    }
}

.scene-nav-notification {
    font-family: 'Crimson Pro', serif;
}
/* ========== 07.characters.css ========== */
/* Detail View Styles (Characters, World, etc.) */


/* En-tête de groupe dans la sidebar */
.character-group-header {
    padding: 8px 15px;
    background-color: var(--bg-secondary);
    /* ou une couleur légèrement plus foncée */
    color: var(--text-muted);
    font-size: 0.85rem;
    font-weight: bold;
    text-transform: uppercase;
    border-bottom: 1px solid var(--border-color);
    border-top: 1px solid var(--border-color);
    margin-top: 10px;
    display: flex;
    justify-content: space-between;
}

.character-group-header:first-child {
    margin-top: 0;
    border-top: none;
}

.character-group-header .count {
    background: rgba(0, 0, 0, 0.2);
    padding: 1px 6px;
    border-radius: 10px;
    font-size: 0.75rem;
}

.detail-view {
    padding: 2rem 3rem;
    max-width: 1400px;
    width: 100%;
    margin: 0 auto;
    height: 100vh;
    overflow-y: auto;
    box-sizing: border-box;
}

/* Character Sheet Styles */
.character-sheet {
    padding: 1.5rem;
    height: 100%;
    overflow-y: auto;
}

/* Grille des sections - 2 colonnes sur desktop */
.character-sections-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 1rem;
}

/* Section qui prend toute la largeur */
.character-section.full-width {
    grid-column: 1 / -1;
}

/* Responsive: 3 colonnes sur très grand écran */
@media (min-width: 1600px) {
    .character-sections-grid {
        grid-template-columns: repeat(3, 1fr);
    }
}

/* Responsive: 4 colonnes sur écran ultra-large */
@media (min-width: 2200px) {
    .character-sections-grid {
        grid-template-columns: repeat(4, 1fr);
    }
}

.character-sheet-header {
    display: flex;
    gap: 2rem;
    padding: 1.5rem;
    background: var(--bg-secondary);
    border-radius: 8px;
    margin-bottom: 1.5rem;
    border: 1px solid var(--border-color);
    position: relative;
}

.character-avatar {
    width: 100px;
    height: 100px;
    border-radius: 50%;
    background: linear-gradient(135deg, var(--primary-color) 0%, var(--accent-red) 100%);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 2.5rem;
    color: white;
    flex-shrink: 0;
    cursor: pointer;
    position: relative;
    overflow: hidden;
    border: 3px solid var(--bg-primary);
    box-shadow: 0 4px 12px var(--shadow);
}

.character-avatar img {
    width: 100%;
    height: 100%;
    object-fit: cover;
}

.character-avatar:hover::after {
    content: '📷';
    position: absolute;
    inset: 0;
    background: rgba(0, 0, 0, 0.5);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.5rem;
}

.character-header-info {
    flex: 1;
}

.character-header-info h2 {
    font-size: 1.6rem;
    font-weight: 600;
    margin-bottom: 0.5rem;
    color: var(--text-primary);
}

.character-header-info .character-meta {
    font-size: 0.9rem;
    color: var(--text-secondary);
    list-style: disc;
    margin-left: 1.2rem;
}

.character-header-actions {
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    gap: 0.75rem;
}

.character-role-stars {
    display: flex;
    gap: 0.25rem;
}

.character-role-stars .star {
    font-size: 1.3rem;
    cursor: pointer;
    color: #ddd;
    transition: color 0.2s;
}

.character-role-stars .star.filled {
    color: var(--primary-color);
}

.character-role-stars .star:hover {
    color: var(--primary-hover);
}

.btn-write-beside {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem 1rem;
    background: var(--bg-primary);
    border: 1px solid var(--border-color);
    border-radius: 20px;
    font-size: 0.85rem;
    cursor: pointer;
    transition: all 0.2s;
}

.btn-write-beside:hover {
    border-color: var(--primary-color);
    color: var(--primary-color);
}

.character-close-btn {
    position: absolute;
    top: 1rem;
    right: 1rem;
    background: none;
    border: none;
    font-size: 1.5rem;
    cursor: pointer;
    color: var(--text-muted);
    line-height: 1;
}

.character-close-btn:hover {
    color: var(--accent-red);
}

.character-section {
    background: var(--bg-primary);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    overflow: hidden;
}

.character-section-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.75rem 1rem;
    background: var(--bg-secondary);
    cursor: pointer;
    user-select: none;
}

.character-section-header:hover {
    background: var(--bg-tertiary);
}

.character-section-title {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.8rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: var(--accent-red);
}

.character-section-title::before {
    content: '';
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background: var(--primary-color);
}

.character-section-toggle {
    font-size: 0.9rem;
    color: var(--text-muted);
    transition: transform 0.2s;
}

.character-section.collapsed .character-section-toggle {
    transform: rotate(-90deg);
}

.character-section.collapsed .character-section-content {
    display: none;
}

.character-section-content {
    padding: 1rem;
}

.character-field-row {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
    gap: 0.75rem;
    margin-bottom: 0.75rem;
}

.character-field-row:last-child {
    margin-bottom: 0;
}

.character-field {
    display: flex;
    flex-direction: column;
    gap: 0.3rem;
}

.character-field-label {
    font-size: 0.75rem;
    font-weight: 500;
    color: var(--accent-red);
    text-transform: capitalize;
}

.character-field input,
.character-field textarea,
.character-field select {
    padding: 0.5rem 0.6rem;
    border: 1px solid var(--border-color);
    border-radius: 4px;
    font-size: 0.9rem;
    font-family: inherit;
    background: var(--bg-primary);
    color: var(--text-primary);
    transition: border-color 0.2s;
}

.character-field input:focus,
.character-field textarea:focus {
    outline: none;
    border-color: var(--primary-color);
}

.character-field textarea {
    resize: vertical;
    min-height: 60px;
}

.character-radio-group {
    display: flex;
    gap: 1rem;
    padding: 0.5rem 0;
}

/* Responsive: 1 colonne sur tablette/mobile */
@media (max-width: 900px) {
    .character-sections-grid {
        grid-template-columns: 1fr;
    }

    .character-section.full-width {
        grid-column: 1;
    }
}

.character-radio-group label {
    display: flex;
    align-items: center;
    gap: 0.4rem;
    cursor: pointer;
    font-size: 0.9rem;
}

.character-radio-group input[type="radio"] {
    accent-color: var(--primary-color);
}

/* Système de traits de caractère */
.selected-traits-container {
    display: flex;
    flex-wrap: wrap;
    gap: 0.4rem;
    padding: 0.75rem;
    border: 2px solid var(--primary-color);
    border-radius: 8px;
    background: rgba(212, 175, 55, 0.05);
    min-height: 50px;
    align-items: flex-start;
}

.selected-trait {
    display: inline-flex;
    align-items: center;
    gap: 0.3rem;
    padding: 0.3rem 0.6rem;
    background: var(--primary-color);
    color: white;
    border-radius: 15px;
    font-size: 0.8rem;
    font-weight: 500;
}

.trait-remove {
    cursor: pointer;
    opacity: 0.7;
    font-size: 0.9rem;
    line-height: 1;
    margin-left: 0.2rem;
}

.trait-remove:hover {
    opacity: 1;
}

.no-traits {
    color: var(--text-muted);
    font-style: italic;
    font-size: 0.85rem;
}

.traits-categories {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    margin-top: 1rem;
}

/* Sections principales de traits */
.trait-section {
    border: 2px solid var(--border-color);
    border-radius: 8px;
    overflow: hidden;
    background: var(--bg-primary);
}

.trait-section-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0.6rem 1rem;
    background: linear-gradient(135deg, var(--primary-color) 0%, var(--accent-gold) 100%);
    cursor: pointer;
    user-select: none;
    font-size: 0.9rem;
    font-weight: 700;
    color: white;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.trait-section-header:hover {
    filter: brightness(1.1);
}

.trait-section-icon {
    font-size: 1.1rem;
    margin-right: 0.5rem;
}

.trait-section-toggle {
    font-size: 0.8rem;
    transition: transform 0.2s;
}

.trait-section.collapsed .trait-section-toggle {
    transform: rotate(-90deg);
}

.trait-section.collapsed .trait-section-content {
    display: none;
}

.trait-section-content {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
    gap: 0.5rem;
    padding: 0.75rem;
    background: var(--bg-secondary);
}

.trait-category {
    border: 1px solid var(--border-color);
    border-radius: 6px;
    overflow: hidden;
    background: var(--bg-primary);
}

.trait-category-header {
    display: flex;
    align-items: center;
    padding: 0.4rem 0.6rem;
    background: var(--bg-tertiary);
    font-size: 0.75rem;
    font-weight: 600;
    color: var(--text-primary);
}

.trait-category-icon {
    font-size: 0.9rem;
    margin-right: 0.3rem;
}

.trait-category-content {
    padding: 0.4rem;
    display: flex;
    flex-wrap: wrap;
    gap: 0.25rem;
}

.trait-option {
    padding: 0.2rem 0.45rem;
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 10px;
    font-size: 0.7rem;
    cursor: pointer;
    transition: all 0.15s;
    color: var(--text-secondary);
}

.trait-option:hover {
    background: var(--bg-tertiary);
    border-color: var(--primary-color);
    color: var(--text-primary);
}

.trait-option.selected {
    background: var(--primary-color);
    border-color: var(--primary-color);
    color: white;
}

/* Tags input */
.character-tags-container {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    padding: 0.5rem;
    border: 1px solid var(--border-color);
    border-radius: 6px;
    background: var(--bg-primary);
    min-height: 42px;
    align-items: center;
}

.character-tag {
    display: flex;
    align-items: center;
    gap: 0.3rem;
    padding: 0.25rem 0.6rem;
    background: var(--bg-tertiary);
    border-radius: 12px;
    font-size: 0.85rem;
}

.character-tag-remove {
    cursor: pointer;
    color: var(--text-muted);
    font-size: 0.9rem;
    line-height: 1;
}

.character-tag-remove:hover {
    color: var(--accent-red);
}

.character-tags-input {
    border: none !important;
    padding: 0.25rem !important;
    flex: 1;
    min-width: 120px;
    font-size: 0.9rem !important;
}

.character-tags-input:focus {
    outline: none;
}

/* Radar Chart */
.character-radar-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 1rem;
}

.character-radar-canvas {
    max-width: 350px;
    max-height: 350px;
}

.character-radar-controls {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 0.75rem;
    width: 100%;
    max-width: 500px;
    margin-top: 1rem;
}

.radar-control {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.radar-control label {
    font-size: 0.85rem;
    min-width: 90px;
    color: var(--text-secondary);
}

.radar-control input[type="range"] {
    flex: 1;
    accent-color: var(--primary-color);
}

.radar-control .radar-value {
    font-size: 0.8rem;
    min-width: 24px;
    text-align: right;
    color: var(--text-muted);
}

/* Wealth slider */
.wealth-slider-container {
    display: flex;
    align-items: center;
    gap: 1rem;
}

.wealth-slider {
    flex: 1;
    height: 8px;
    -webkit-appearance: none;
    background: linear-gradient(to right, var(--bg-tertiary), var(--primary-color));
    border-radius: 4px;
    outline: none;
}

.wealth-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: var(--primary-color);
    cursor: pointer;
    border: 2px solid white;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
}

/* Timeline cards (Passé/Présent/Futur) */
.character-timeline {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 1rem;
}

.timeline-card {
    background: var(--bg-secondary);
    border-radius: 6px;
    padding: 1rem;
    border: 1px solid var(--border-color);
}

.timeline-card-title {
    font-size: 0.8rem;
    font-weight: 600;
    color: var(--accent-red);
    margin-bottom: 0.5rem;
}

.timeline-card textarea {
    width: 100%;
    border: none;
    background: transparent;
    resize: vertical;
    font-family: inherit;
    font-size: 0.9rem;
    color: var(--text-secondary);
    min-height: 100px;
}

.timeline-card textarea:focus {
    outline: none;
}

/* Inventory items */
.inventory-item {
    background: var(--bg-secondary);
    border-radius: 6px;
    padding: 1rem;
    margin-bottom: 0.75rem;
    border: 1px solid var(--border-color);
    position: relative;
}

.inventory-item-delete {
    position: absolute;
    top: 0.5rem;
    right: 0.5rem;
    background: none;
    border: none;
    cursor: pointer;
    color: var(--text-muted);
    font-size: 1rem;
}

.inventory-item-delete:hover {
    color: var(--accent-red);
}

.inventory-add-btn {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
    padding: 0.75rem;
    border: 1px dashed var(--border-color);
    border-radius: 20px;
    background: transparent;
    cursor: pointer;
    color: var(--text-muted);
    font-size: 0.9rem;
    transition: all 0.2s;
    margin-top: 1rem;
}

.inventory-add-btn:hover {
    border-color: var(--primary-color);
    color: var(--primary-color);
}

/* Side-by-side mode */
.editor-split-mode {
    display: flex;
    height: 100%;
}

.editor-split-mode .editor-main {
    flex: 1;
    overflow-y: auto;
    border-right: 1px solid var(--border-color);
}

.editor-split-mode .character-sheet-panel {
    width: 450px;
    overflow-y: auto;
    background: var(--bg-primary);
}

.character-sheet-panel .character-sheet {
    padding: 1rem;
}

.character-sheet-panel .character-sheet-header {
    flex-direction: column;
    align-items: center;
    text-align: center;
    gap: 1rem;
}

.character-sheet-panel .character-avatar {
    width: 80px;
    height: 80px;
    font-size: 2rem;
}

.character-sheet-panel .character-header-info h2 {
    font-size: 1.3rem;
}

/* ==========================================
           SPLIT VIEW SYSTEM
           ========================================== */

.split-view-container {
    display: flex;
    height: 100%;
    width: 100%;
    position: relative;
}

.split-view-container.vertical {
    flex-direction: column;
}

.split-panel {
    display: flex;
    flex-direction: column;
    overflow: hidden;
    min-width: 250px;
    min-height: 200px;
}

.split-panel-left {
    flex: 6;
}

.split-panel-right {
    flex: 4;
}

.split-panel-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.5rem 0.75rem;
    background: var(--bg-secondary);
    border-bottom: 1px solid var(--border-color);
    flex-shrink: 0;
    min-height: 40px;
}

.split-panel-title {
    font-size: 0.85rem;
    font-weight: 600;
    color: var(--text-primary);
    display: flex;
    align-items: center;
    gap: 0.5rem;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.split-panel-actions {
    display: flex;
    gap: 0.25rem;
    flex-shrink: 0;
}

.split-panel-btn {
    background: none;
    border: none;
    padding: 0.25rem 0.5rem;
    cursor: pointer;
    color: var(--text-muted);
    border-radius: 4px;
    font-size: 0.8rem;
    transition: all 0.2s;
}

.split-panel-btn:hover {
    background: var(--bg-tertiary);
    color: var(--text-primary);
}

.split-panel-content {
    flex: 1;
    overflow-y: auto;
    overflow-x: hidden;
}

/* Active panel indicator */
.split-panel.active {
    box-shadow: inset 0 0 0 2px var(--primary-color);
}

.split-panel.active .split-panel-header {
    background: var(--primary-color);
    color: white;
}

.split-panel.active .split-panel-header .split-panel-title {
    color: white;
}

.split-panel.active .split-panel-btn {
    color: rgba(255, 255, 255, 0.8);
}

.split-panel.active .split-panel-btn:hover {
    background: rgba(255, 255, 255, 0.2);
    color: white;
}

.split-panel-indicator {
    font-size: 8px;
    color: var(--text-muted);
    opacity: 0.3;
}

.split-panel-indicator.active {
    color: white;
    opacity: 1;
}

.split-panel-header {
    cursor: pointer;
    transition: background 0.2s;
}

.split-panel-header:hover {
    background: var(--bg-tertiary);
}

.split-panel.active .split-panel-header:hover {
    background: var(--primary-color-dark, var(--primary-color));
    filter: brightness(0.9);
}

/* View option in selector */
.split-view-option:hover {
    filter: brightness(1.1);
    transform: translateY(-1px);
}

/* Resizer */
.split-resizer {
    flex-shrink: 0;
    background: var(--border-color);
    transition: background 0.2s;
    position: relative;
}

.split-resizer:hover,
.split-resizer.dragging {
    background: var(--primary-color);
}

.split-resizer.horizontal {
    width: 5px;
    cursor: col-resize;
}

.split-resizer.vertical {
    height: 5px;
    cursor: row-resize;
}

.split-resizer::after {
    content: '';
    position: absolute;
    background: var(--text-muted);
    border-radius: 2px;
    opacity: 0.5;
}

.split-resizer.horizontal::after {
    width: 3px;
    height: 30px;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}

.split-resizer.vertical::after {
    width: 30px;
    height: 3px;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}

/* Split View Selector Dropdown */
.split-selector {
    position: relative;
}

.split-selector-btn {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.4rem 0.75rem;
    background: var(--bg-primary);
    border: 1px solid var(--border-color);
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.8rem;
    color: var(--text-secondary);
    transition: all 0.2s;
}

.split-selector-btn:hover {
    border-color: var(--primary-color);
    color: var(--text-primary);
}

.split-selector-dropdown {
    position: absolute;
    top: 100%;
    left: 0;
    right: 0;
    min-width: 200px;
    background: var(--bg-primary);
    border: 1px solid var(--border-color);
    border-radius: 6px;
    box-shadow: 0 4px 12px var(--shadow);
    z-index: 100;
    display: none;
    max-height: 300px;
    overflow-y: auto;
}

.split-selector-dropdown.open {
    display: block;
}

.split-selector-group {
    padding: 0.5rem 0;
    border-bottom: 1px solid var(--border-color);
}

.split-selector-group:last-child {
    border-bottom: none;
}

.split-selector-group-title {
    padding: 0.25rem 0.75rem;
    font-size: 0.7rem;
    font-weight: 600;
    text-transform: uppercase;
    color: var(--text-muted);
    letter-spacing: 0.5px;
}

.split-selector-item {
    padding: 0.5rem 0.75rem;
    cursor: pointer;
    font-size: 0.85rem;
    color: var(--text-secondary);
    display: flex;
    align-items: center;
    gap: 0.5rem;
    transition: background 0.15s;
}

.split-selector-item:hover {
    background: var(--bg-secondary);
    color: var(--text-primary);
}

.split-selector-item.active {
    background: var(--bg-tertiary);
    color: var(--primary-color);
    font-weight: 500;
}

/* Split Mode Toggle Button in Header */
.split-mode-toggle {
    display: flex;
    align-items: center;
    gap: 0.4rem;
    padding: 0.4rem 0.75rem;
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.8rem;
    color: var(--text-secondary);
    transition: all 0.2s;
}

.split-mode-toggle:hover {
    border-color: var(--primary-color);
    color: var(--primary-color);
}

.split-mode-toggle.active {
    background: var(--primary-color);
    border-color: var(--primary-color);
    color: white;
}

/* Responsive */
@media (max-width: 900px) {
    .split-view-container {
        flex-direction: column !important;
    }

    .split-resizer.horizontal {
        width: 100%;
        height: 5px;
        cursor: row-resize;
    }

    .split-resizer.horizontal::after {
        width: 30px;
        height: 3px;
    }

    .split-panel {
        min-width: unset;
        min-height: 150px;
    }

    .split-panel-left,
    .split-panel-right {
        flex: 1;
    }
}

/* Character sheet adjustments in split view */
.split-panel .character-sheet {
    padding: 1rem;
    height: auto;
}

.split-panel .character-sheet-header {
    padding: 1rem;
}

.split-panel .character-avatar {
    width: 80px;
    height: 80px;
    font-size: 2rem;
}

@media (max-width: 900px) {
    .character-sheet {
        padding: 1rem;
    }

    .character-sheet-header {
        flex-direction: column;
        align-items: center;
        text-align: center;
    }

    .character-header-actions {
        align-items: center;
    }

    .character-field-row {
        grid-template-columns: 1fr;
    }

    .character-timeline {
        grid-template-columns: 1fr;
    }

    .character-radar-controls {
        grid-template-columns: 1fr;
    }
}

.detail-header {
    padding: 1.5rem;
    background: var(--bg-secondary);
    border-radius: 4px;
    margin-bottom: 2rem;
    border-left: 4px solid var(--accent-red);
}

.detail-title {
    font-size: 1.8rem;
    font-weight: 600;
    margin-bottom: 1rem;
    color: var(--text-primary);
    font-family: 'Noto Serif JP', serif;
}

.detail-section {
    background: var(--bg-secondary);
    padding: 1.5rem;
    margin-bottom: 1.5rem;
    border-radius: 4px;
    border: 1px solid var(--border-color);
}

.detail-section-title {
    font-size: 1.1rem;
    font-weight: 600;
    margin-bottom: 1rem;
    color: var(--text-primary);
    padding-bottom: 0.75rem;
    border-bottom: 2px solid var(--border-color);
}

.detail-field {
    margin-bottom: 1.25rem;
}

.detail-field:last-child {
    margin-bottom: 0;
}

.detail-label {
    display: block;
    margin-bottom: 0.5rem;
    font-weight: 500;
    color: var(--text-secondary);
    font-size: 0.95rem;
}

.modal-actions {
    display: flex;
    gap: 0.75rem;
    justify-content: flex-end;
}

.modal-button-group {
    display: flex;
    gap: 0.75rem;
    flex-wrap: wrap;
}

.modal-button-group .btn {
    flex: 1;
    min-width: 180px;
}

/* Scrollbar */
::-webkit-scrollbar {
    width: 12px;
    height: 12px;
}

::-webkit-scrollbar-track {
    background: var(--bg-secondary);
}

::-webkit-scrollbar-thumb {
    background: var(--border-color);
    border-radius: 6px;
    border: 2px solid var(--bg-secondary);
}

::-webkit-scrollbar-thumb:hover {
    background: var(--text-muted);
}

/* Better scrollbar for editor workspace */
.editor-workspace::-webkit-scrollbar-thumb {
    background: var(--accent-gold);
    border: 2px solid var(--bg-primary);
}

.editor-workspace::-webkit-scrollbar-thumb:hover {
    background: var(--accent-red);
}

/* Animations */
@keyframes fadeIn {
    from {
        opacity: 0;
        transform: translateY(-10px);
    }

    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.chapter-group {
    animation: fadeIn 0.3s ease forwards;
}

/* ==========================================
           AMÉLIORATIONS VISUELLES - OPT 1
           ========================================== */

/* Badge de statut amélioré */
.status-badge {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 18px;
    height: 18px;
    border-radius: 50%;
    margin-left: 0.4rem;
    flex-shrink: 0;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
    font-size: 10px;
    cursor: pointer;
    position: relative;
}

.status-badge:hover {
    transform: scale(1.2);
    box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.1);
}

.status-draft {
    background: #ff6b6b;
}

.status-draft::after {
    content: "";
}

.status-progress {
    background: #ffd93d;
}

.status-progress::after {
    content: "";
}

.status-complete {
    background: #51cf66;
}

.status-complete::after {
    content: "✓";
    color: white;
    font-weight: bold;
}

.status-review {
    background: #4a9eff;
}

.status-review::after {
    content: "";
}

/* Menu contextuel de statut */
.status-menu {
    position: fixed;
    background: var(--bg-primary);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    z-index: 10000;
    min-width: 140px;
    padding: 0.5rem 0;
    display: none;
}

.status-menu.visible {
    display: block;
}

.status-menu-item {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem 1rem;
    cursor: pointer;
    font-size: 0.85rem;
    color: var(--text-primary);
    transition: background 0.2s;
}

.status-menu-item:hover {
    background: var(--bg-secondary);
}

.status-menu-item.active {
    background: var(--bg-tertiary);
    font-weight: 600;
}

.status-menu-dot {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    flex-shrink: 0;
}

.status-menu-dot.draft {
    background: #ff6b6b;
}

.status-menu-dot.progress {
    background: #ffd93d;
}

.status-menu-dot.complete {
    background: #51cf66;
}

.status-menu-dot.review {
    background: #4a9eff;
}

/* Barre de progression globale */
.project-progress-bar {
    padding: 0.75rem 1rem;
    background: var(--bg-primary);
    border-bottom: 1px solid var(--border-color);
}

.progress-stats {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 0.5rem;
    font-size: 0.75rem;
    color: var(--text-secondary);
}

.progress-track {
    height: 6px;
    background: var(--bg-tertiary);
    border-radius: 3px;
    overflow: hidden;
    display: flex;
}

.progress-segment {
    height: 100%;
    transition: width 0.3s ease;
}

.progress-segment.complete {
    background: #51cf66;
}

.progress-segment.review {
    background: #4a9eff;
}

.progress-segment.progress {
    background: #ffd93d;
}

.progress-segment.draft {
    background: #ff6b6b;
}

/* Filtres de statut */
.status-filters {
    display: flex;
    gap: 0.25rem;
    padding: 0.5rem 1rem;
    background: var(--bg-secondary);
    border-bottom: 1px solid var(--border-color);
    flex-wrap: wrap;
}

.status-filter-btn {
    display: flex;
    align-items: center;
    gap: 0.3rem;
    padding: 0.3rem 0.6rem;
    border: 1px solid var(--border-color);
    border-radius: 12px;
    background: var(--bg-primary);
    font-size: 0.7rem;
    cursor: pointer;
    transition: all 0.2s;
    color: var(--text-secondary);
}

.status-filter-btn:hover {
    border-color: var(--text-muted);
}

.status-filter-btn.active {
    border-color: currentColor;
    font-weight: 600;
}

.status-filter-btn.draft.active {
    background: rgba(255, 107, 107, 0.15);
    color: #e55a5a;
    border-color: #ff6b6b;
}

.status-filter-btn.progress.active {
    background: rgba(255, 217, 61, 0.15);
    color: #c9a82e;
    border-color: #ffd93d;
}

.status-filter-btn.complete.active {
    background: rgba(81, 207, 102, 0.15);
    color: #3db854;
    border-color: #51cf66;
}

.status-filter-btn.review.active {
    background: rgba(74, 158, 255, 0.15);
    color: #3a8ae6;
    border-color: #4a9eff;
}

.status-filter-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
}

.status-filter-dot.draft {
    background: #ff6b6b;
}

.status-filter-dot.progress {
    background: #ffd93d;
}

.status-filter-dot.complete {
    background: #51cf66;
}

.status-filter-dot.review {
    background: #4a9eff;
}

.status-filter-count {
    font-weight: 600;
}

/* Scènes filtrées (cachées) */
.scene-item.filtered-out {
    display: none !important;
}

.chapter-group.filtered-out {
    display: none !important;
}

.act-group.filtered-out {
    display: none !important;
}

/* Compteur de mots */
.word-count-badge {
    font-size: 0.6rem;
    color: var(--text-muted);
    font-family: 'Courier New', monospace;
    padding: 0.05rem 0.25rem;
    background: var(--bg-tertiary);
    border-radius: 2px;
    white-space: nowrap;
    font-weight: 600;
}

/* Numérotation automatique */
.auto-number {
    font-size: 0.65rem;
    color: var(--text-muted);
    font-family: 'Courier New', monospace;
    font-weight: 700;
    min-width: 28px;
    text-align: right;
    margin-right: 0.2rem;
    flex-shrink: 0;
}

.delete-btn {
    opacity: 0;
    margin-left: auto;
    transition: opacity 0.2s ease;
    padding: 0 0.2rem !important;
    min-width: auto !important;
    width: 18px !important;
    height: 18px !important;
    font-size: 0.8rem !important;
}

.act-header:hover .delete-btn,
.chapter-header:hover .delete-btn,
.scene-item:hover .delete-btn {
    opacity: 1;
}

.scene-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
}

/* Drag and Drop */
.draggable {
    cursor: move;
}

.draggable:active {
    cursor: grabbing;
}

.drag-over {
    background: rgba(212, 175, 55, 0.2);
    border-left: 3px solid var(--accent-gold);
}

.dragging {
    opacity: 0.5;
    background: var(--bg-accent);
    color: var(--bg-primary);
}

.drag-handle {
    cursor: grab;
    padding: 0 0.2rem;
    color: var(--text-muted);
    opacity: 0;
    transition: opacity 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
}

.chapter-header:hover .drag-handle,
.scene-item:hover .drag-handle,
.act-header:hover .drag-handle {
    opacity: 1;
}

.drag-handle:active {
    cursor: grabbing;
}

/* Inline Editing */
.editing-input {
    background: var(--bg-primary);
    border: 2px solid var(--accent-gold);
    padding: 0.15rem 0.3rem;
    font-family: 'Crimson Pro', serif;
    font-size: inherit;
    font-weight: inherit;
    color: var(--text-primary);
    border-radius: 2px;
    outline: none;
    width: 100%;
}

.chapter-title,
.scene-item>div>span:not(.drag-handle) {
    cursor: text;
}

.chapter-title:hover,
.scene-item>div>span:not(.drag-handle):hover {
    background: rgba(212, 175, 55, 0.1);
    padding: 0.15rem 0.3rem;
    margin: -0.15rem -0.3rem;
    border-radius: 2px;
}

.edit-hint {
    font-size: 0.6rem;
    color: var(--text-muted);
    opacity: 0;
    transition: opacity 0.2s ease;
    font-style: italic;
    margin-left: 0.25rem;
}

.chapter-header:hover .edit-hint,
.scene-item:hover .edit-hint {
    opacity: 1;
}

/* Rich Text Editor Toolbar - defined above in main structure */

.toolbar-group {
    display: flex;
    gap: 4px;
    padding-right: 12px;
    border-right: 1px solid var(--border-color);
    flex-shrink: 0;
}

.toolbar-group:last-child {
    border-right: none;
}

.toolbar-btn {
    padding: 0;
    min-width: 36px;
    height: 36px;
    border: none;
    background: transparent;
    color: var(--text-primary);
    cursor: pointer;
    font-family: 'Crimson Pro', serif;
    font-size: 16px;
    font-weight: 400;
    transition: all 0.15s ease;
    border-radius: 6px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.toolbar-btn:hover {
    background: var(--bg-secondary);
}

.toolbar-btn.active {
    background: var(--primary-color);
    color: white;
}

.toolbar-btn[data-format="bold"] {
    font-weight: 700;
}

.toolbar-btn[data-format="italic"] {
    font-style: italic;
}

.toolbar-btn[data-format="underline"] {
    text-decoration: underline;
}

/* Bouton annotations avec badge */
.annotations-toolbar-btn {
    position: relative;
}

.annotations-toolbar-btn.has-annotations::after {
    content: attr(data-count);
    position: absolute;
    top: 2px;
    right: 2px;
    background: var(--accent-red);
    color: white;
    font-size: 10px;
    font-weight: 600;
    min-width: 14px;
    height: 14px;
    border-radius: 7px;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0 3px;
}

.annotations-toolbar-btn.panel-open {
    background: var(--primary-color);
    color: white;
}

/* Select dans le toolbar */
select.toolbar-btn {
    min-width: 100px;
    padding: 0 32px 0 12px;
    font-size: 14px;
    appearance: none;
    background-image: url("data:image/svg+xml,%3Csvg width='10' height='6' viewBox='0 0 10 6' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 1L5 5L9 1' stroke='%23666' stroke-width='1.5' stroke-linecap='round'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 10px center;
    background-color: transparent;
}

select.toolbar-btn:hover {
    background-color: var(--bg-secondary);
    background-image: url("data:image/svg+xml,%3Csvg width='10' height='6' viewBox='0 0 10 6' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 1L5 5L9 1' stroke='%23666' stroke-width='1.5' stroke-linecap='round'/%3E%3C/svg%3E");
}

/* Color Picker Dropdown */
.color-picker-wrapper {
    position: relative;
    display: inline-block;
}

.color-picker-dropdown {
    position: fixed;
    background: var(--bg-primary);
    border: 2px solid var(--border-color);
    border-radius: 4px;
    padding: 0.75rem;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    z-index: 99999;
    display: none;
    min-width: 200px;
}

.color-picker-dropdown.active {
    display: block;
}

.color-grid {
    display: grid;
    grid-template-columns: repeat(8, 1fr);
    gap: 0.25rem;
    margin-bottom: 0.5rem;
}

.color-swatch {
    width: 24px;
    height: 24px;
    border: 2px solid var(--border-color);
    border-radius: 2px;
    cursor: pointer;
    transition: transform 0.2s ease;
}

.color-swatch:hover {
    transform: scale(1.1);
    border-color: var(--accent-gold);
}

.color-input-wrapper {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin-top: 0.5rem;
    padding-top: 0.5rem;
    border-top: 1px solid var(--border-color);
}

.color-input-wrapper input[type="color"] {
    width: 40px;
    height: 30px;
    border: 1px solid var(--border-color);
    border-radius: 2px;
    cursor: pointer;
}

.color-input-wrapper input[type="text"] {
    flex: 1;
    padding: 0.3rem 0.5rem;
    border: 1px solid var(--border-color);
    border-radius: 2px;
    font-family: 'Source Code Pro', monospace;
    font-size: 0.85rem;
}

/* Font Size Selector */
.font-size-selector {
    padding: 0.5rem;
    border: 1px solid var(--border-color);
    background: var(--bg-primary);
    color: var(--text-primary);
    cursor: pointer;
    font-family: 'Crimson Pro', serif;
    font-size: 0.9rem;
    border-radius: 2px;
    min-width: 70px;
}

.font-size-selector:hover {
    background: var(--accent-gold);
    color: var(--bg-primary);
    border-color: var(--accent-gold);
}

/* Font Family Selector */
.font-family-selector {
    padding: 0.5rem;
    border: 1px solid var(--border-color);
    background: var(--bg-primary);
    color: var(--text-primary);
    cursor: pointer;
    font-size: 0.9rem;
    border-radius: 2px;
    min-width: 150px;
}

.font-family-selector:hover {
    background: var(--accent-gold);
    color: var(--bg-primary);
    border-color: var(--accent-gold);
}

/* Toolbar separator */
.toolbar-separator {
    width: 1px;
    height: 30px;
    background: var(--border-color);
    margin: 0 0.25rem;
}

/* Rich Text Editor Content */
.editor-textarea[contenteditable="true"] {
    outline: none;
    white-space: pre-wrap;
    word-wrap: break-word;
}

.editor-textarea[contenteditable="true"]:empty:before {
    content: attr(data-placeholder);
    color: var(--text-muted);
    font-style: italic;
    pointer-events: none;
}

.editor-textarea strong,
.editor-textarea b {
    font-weight: 700;
}

.editor-textarea em,
.editor-textarea i {
    font-style: italic;
}

.editor-textarea u {
    text-decoration: underline;
}

.editor-textarea h1 {
    font-size: 2em;
    font-weight: 700;
    margin: 1em 0 0.5em;
    font-family: 'Noto Serif JP', serif;
}

.editor-textarea h2 {
    font-size: 1.5em;
    font-weight: 600;
    margin: 1em 0 0.5em;
    font-family: 'Noto Serif JP', serif;
}

.editor-textarea h3 {
    font-size: 1.25em;
    font-weight: 600;
    margin: 1em 0 0.5em;
}

.editor-textarea blockquote {
    border-left: 4px solid var(--accent-gold);
    padding-left: 1.5rem;
    margin: 1.5rem 0;
    font-style: italic;
    color: var(--text-secondary);
}

.editor-textarea ul,
.editor-textarea ol {
    margin: 1rem 0;
    padding-left: 2rem;
}

.editor-textarea li {
    margin: 0.5rem 0;
}

.editor-textarea hr {
    border: none;
    border-top: 2px solid var(--border-color);
    margin: 2rem 0;
}

/* Text alignment */
.editor-textarea [style*="text-align: left"] {
    text-align: left;
}

.editor-textarea [style*="text-align: center"] {
    text-align: center;
}

.editor-textarea [style*="text-align: right"] {
    text-align: right;
}

.editor-textarea [style*="text-align: justify"] {
    text-align: justify;
}

/* Strikethrough */
.editor-textarea s,
.editor-textarea strike {
    text-decoration: line-through;
}

/* Superscript and subscript */
.editor-textarea sup {
    vertical-align: super;
    font-size: 0.75em;
}

.editor-textarea sub {
    vertical-align: sub;
    font-size: 0.75em;
}

/* Timeline Styles */
.timeline-container {
    position: relative;
    padding: 1rem 0 1rem 2.5rem;
}

.timeline-line {
    position: absolute;
    left: 0.75rem;
    top: 0;
    bottom: 0;
    width: 2px;
    background: var(--border-color);
}

.timeline-event {
    position: relative;
    margin-bottom: 1.5rem;
    padding: 0.75rem;
    background: var(--bg-primary);
    border: 1px solid var(--border-color);
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.2s ease;
}

.timeline-event::before {
    content: '';
    position: absolute;
    left: -2rem;
    top: 1rem;
    width: 10px;
    height: 10px;
    background: var(--accent-red);
    border: 2px solid var(--bg-primary);
    border-radius: 50%;
    z-index: 2;
}

.timeline-event:hover {
    border-color: var(--accent-gold);
    box-shadow: 0 2px 8px var(--shadow);
}

.timeline-event.active {
    border-color: var(--accent-red);
    background: var(--bg-secondary);
}

.timeline-date {
    font-size: 0.75rem;
    color: var(--accent-gold);
    font-weight: 600;
    margin-bottom: 0.4rem;
    font-family: 'Source Code Pro', monospace;
}

.timeline-title {
    font-size: 0.95rem;
    font-weight: 600;
    color: var(--text-primary);
    margin-bottom: 0.4rem;
}

.timeline-meta {
    display: flex;
    gap: 0.75rem;
    font-size: 0.75rem;
    color: var(--text-muted);
    margin-bottom: 0.4rem;
    flex-wrap: wrap;
}

.timeline-meta-item {
    display: flex;
    align-items: center;
    gap: 0.25rem;
}

.timeline-description {
    font-size: 0.85rem;
    color: var(--text-secondary);
    line-height: 1.4;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
}

/* Notes Styles */
.note-card {
    background: var(--bg-primary);
    border: 1px solid var(--border-color);
    border-radius: 4px;
    padding: 1rem;
    margin-bottom: 1rem;
    cursor: pointer;
    transition: all 0.2s ease;
    position: relative;
}

.note-card:hover {
    border-color: var(--accent-gold);
    box-shadow: 0 2px 8px var(--shadow);
}

.note-card.active {
    border-color: var(--accent-red);
    background: var(--bg-secondary);
}

.note-category-badge {
    display: inline-block;
    font-size: 0.7rem;
    padding: 0.25rem 0.5rem;
    background: var(--accent-gold);
    color: var(--bg-primary);
    border-radius: 2px;
    margin-bottom: 0.5rem;
    font-family: 'Source Code Pro', monospace;
    text-transform: uppercase;
    letter-spacing: 0.05em;
}

.note-title {
    font-size: 1rem;
    font-weight: 600;
    color: var(--text-primary);
    margin-bottom: 0.5rem;
}

.note-preview {
    font-size: 0.85rem;
    color: var(--text-secondary);
    line-height: 1.4;
    display: -webkit-box;
    -webkit-line-clamp: 3;
    -webkit-box-orient: vertical;
    overflow: hidden;
    margin-bottom: 0.5rem;
}

.note-tags {
    display: flex;
    gap: 0.5rem;
    flex-wrap: wrap;
}

.note-tag {
    font-size: 0.7rem;
    padding: 0.2rem 0.5rem;
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 2px;
    color: var(--text-muted);
}

.note-date {
    font-size: 0.7rem;
    color: var(--text-muted);
    margin-top: 0.5rem;
    font-family: 'Source Code Pro', monospace;
}

/* Note Medias */
.note-medias-container {
    margin-top: 0.5rem;
}

.note-medias-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
    gap: 1rem;
}

.note-media-item {
    position: relative;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    overflow: hidden;
    background: var(--bg-secondary);
    transition: all 0.2s;
}

.note-media-item:hover {
    border-color: var(--primary-color);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.note-media-image {
    cursor: pointer;
}

.note-media-image img {
    width: 100%;
    height: 150px;
    object-fit: cover;
    display: block;
}

.note-media-overlay {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0.5rem;
    background: var(--bg-primary);
    border-top: 1px solid var(--border-color);
}

.note-media-title {
    font-size: 0.8rem;
    font-weight: 500;
    color: var(--text-primary);
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    flex: 1;
}

.note-media-delete {
    background: none;
    border: none;
    color: var(--text-muted);
    font-size: 1.2rem;
    cursor: pointer;
    padding: 0.2rem 0.5rem;
    border-radius: 4px;
    transition: all 0.2s;
}

.note-media-delete:hover {
    background: var(--accent-red);
    color: white;
}

.note-media-url {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    padding: 1rem;
    cursor: pointer;
}

.note-media-url-icon {
    font-size: 1.5rem;
    flex-shrink: 0;
}

.note-media-url-info {
    flex: 1;
    min-width: 0;
}

.note-media-domain {
    display: block;
    font-size: 0.7rem;
    color: var(--text-muted);
    margin-top: 0.2rem;
}

.note-media-audio {
    display: flex;
    align-items: flex-start;
    gap: 0.75rem;
    padding: 1rem;
}

.note-media-audio-icon {
    font-size: 1.5rem;
    flex-shrink: 0;
}

.note-media-audio-info {
    flex: 1;
    min-width: 0;
}

.note-media-youtube {
    cursor: pointer;
}

.note-media-youtube-thumb {
    position: relative;
    width: 100%;
    height: 120px;
    overflow: hidden;
}

.note-media-youtube-thumb img {
    width: 100%;
    height: 100%;
    object-fit: cover;
}

.note-media-youtube-play {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 50px;
    height: 50px;
    background: rgba(255, 0, 0, 0.9);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-size: 1.2rem;
    transition: transform 0.2s;
}

.note-media-youtube:hover .note-media-youtube-play {
    transform: translate(-50%, -50%) scale(1.1);
}

/* Treeview media icon */
.treeview-media-icon {
    font-size: 0.75rem;
    margin-left: 0.25rem;
}

/* Statistics Styles */
.stat-box {
    background: var(--bg-primary);
    border: 2px solid var(--border-color);
    border-radius: 4px;
    padding: 1.5rem;
    margin-bottom: 1.5rem;
}

.stat-title {
    font-size: 0.85rem;
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 0.05em;
    margin-bottom: 0.5rem;
    font-weight: 500;
}

.stat-value {
    font-size: 2rem;
    font-weight: 700;
    color: var(--text-primary);
    font-family: 'Noto Serif JP', serif;
}

.stat-label {
    font-size: 0.85rem;
    color: var(--text-secondary);
    margin-top: 0.25rem;
}

.progress-bar {
    width: 100%;
    height: 8px;
    background: var(--bg-secondary);
    border-radius: 4px;
    overflow: hidden;
    margin-top: 0.5rem;
}

.progress-fill {
    height: 100%;
    background: var(--accent-gold);
    transition: width 0.3s ease;
}

.goal-input {
    display: flex;
    gap: 0.5rem;
    margin-top: 1rem;
}

/* Codex Styles */
.codex-card {
    background: var(--bg-primary);
    border-left: 4px solid var(--accent-gold);
    border-right: 1px solid var(--border-color);
    border-top: 1px solid var(--border-color);
    border-bottom: 1px solid var(--border-color);
    border-radius: 0 4px 4px 0;
    padding: 1rem;
    margin-bottom: 1rem;
    cursor: pointer;
    transition: all 0.2s ease;
}

.codex-card:hover {
    border-left-color: var(--accent-red);
    box-shadow: 0 2px 8px var(--shadow);
}

/* Version Styles */
.version-card {
    background: var(--bg-primary);
    border: 1px solid var(--border-color);
    border-radius: 4px;
    padding: 1rem;
    margin-bottom: 1rem;
    cursor: pointer;
    transition: all 0.2s ease;
}

.version-card:hover {
    border-color: var(--accent-gold);
    box-shadow: 0 2px 8px var(--shadow);
}

.version-timestamp {
    font-size: 0.85rem;
    color: var(--accent-gold);
    font-weight: 600;
    margin-bottom: 0.5rem;
    font-family: 'Source Code Pro', monospace;
}

.version-label {
    font-size: 1rem;
    font-weight: 600;
    color: var(--text-primary);
    margin-bottom: 0.5rem;
}

.version-stats {
    font-size: 0.8rem;
    color: var(--text-muted);
}

/* References and Links Styles */
.references-section {
    margin-bottom: 1.5rem;
}

.references-title {
    font-size: 1rem;
    font-weight: 600;
    color: var(--text-primary);
    margin-bottom: 0.75rem;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.reference-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0.5rem 0.75rem;
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 2px;
    margin-bottom: 0.5rem;
    cursor: pointer;
    transition: all 0.2s ease;
}

.reference-item:hover {
    background: rgba(212, 175, 55, 0.1);
    border-color: var(--accent-gold);
}

.reference-link {
    display: inline-block;
    padding: 0.25rem 0.5rem;
    background: var(--accent-gold);
    color: var(--bg-primary);
    border-radius: 2px;
    font-size: 0.75rem;
    cursor: pointer;
    transition: all 0.2s ease;
    text-decoration: none;
    margin: 0.25rem;
}

.reference-link:hover {
    background: var(--accent-red);
}

.tag-selector {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    margin-top: 0.5rem;
}

.tag-option {
    padding: 0.4rem 0.8rem;
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 2px;
    cursor: pointer;
    font-size: 0.85rem;
    transition: all 0.2s ease;
}

.tag-option:hover {
    border-color: var(--accent-gold);
}

.tag-option.selected {
    background: var(--accent-gold);
    color: var(--bg-primary);
    border-color: var(--accent-gold);
}

.link-badge {
    display: inline-flex;
    align-items: center;
    gap: 0.25rem;
    padding: 0.25rem 0.5rem;
    background: rgba(212, 175, 55, 0.2);
    border: 1px solid var(--accent-gold);
    border-radius: 2px;
    font-size: 0.75rem;
    color: var(--text-primary);
    margin: 0.25rem 0.25rem 0.25rem 0;
    cursor: pointer;
}

.link-badge:hover {
    background: rgba(212, 175, 55, 0.3);
}

.link-badge-remove {
    cursor: pointer;
    color: var(--accent-red);
    font-weight: bold;
    margin-left: 0.25rem;
}

.link-badge-remove:hover {
    color: #8b2a1f;
}

.quick-links {
    display: flex;
    gap: 0.5rem;
    flex-wrap: wrap;
    margin-top: 0.5rem;
}

/* Projects Management Styles */
.project-card {
    background: var(--bg-primary);
    border: 2px solid var(--border-color);
    border-radius: 4px;
    padding: 1.5rem;
    margin-bottom: 1rem;
    cursor: pointer;
    transition: all 0.2s ease;
    position: relative;
}

.project-card:hover {
    border-color: var(--accent-gold);
    box-shadow: 0 2px 8px var(--shadow);
}

.project-card.active {
    border-color: var(--accent-red);
    background: var(--bg-secondary);
}

.project-card-header {
    display: flex;
    justify-content: space-between;
    align-items: start;
    margin-bottom: 0.75rem;
}

.project-card-title {
    font-size: 1.2rem;
    font-weight: 700;
    color: var(--text-primary);
    font-family: 'Noto Serif JP', serif;
}

.project-card-genre {
    font-size: 0.75rem;
    padding: 0.25rem 0.5rem;
    background: var(--accent-gold);
    color: var(--bg-primary);
    border-radius: 2px;
    font-weight: 600;
}

.project-card-desc {
    font-size: 0.9rem;
    color: var(--text-secondary);
    margin-bottom: 0.75rem;
    line-height: 1.4;
}

.project-card-stats {
    display: flex;
    gap: 1.5rem;
    font-size: 0.85rem;
    color: var(--text-muted);
    font-family: 'Source Code Pro', monospace;
}

.project-card-actions {
    display: flex;
    gap: 0.5rem;
    margin-top: 1rem;
}

/* Focus Mode Styles */
.app-container.focus-mode {
    display: flex !important;
    flex-direction: column !important;
}

.app-container.focus-mode .app-content {
    display: flex !important;
    flex: 1 !important;
    overflow: hidden !important;
}

.app-container.focus-mode .sidebar {
    display: none !important;
    width: 0 !important;
}



.app-container.focus-mode .app-header {
    display: none !important;
}



.app-container.focus-mode .editor-container {
    background: var(--bg-primary);
    height: 100vh !important;
    width: 100% !important;
    flex: 1 !important;
}

/* Header de l'éditeur toujours visible en mode focus */
.app-container.focus-mode .editor-header {
    opacity: 1;
}

/* Toolbar toujours visible en mode focus (garde son style normal) */
.app-container.focus-mode .editor-toolbar {
    opacity: 1;
}

/* Bouton Paramètres Focus - styles quand visible */
.focus-settings-btn {
    background: var(--accent-gold) !important;
    color: var(--bg-accent) !important;
    border-color: var(--accent-gold) !important;
}

.focus-settings-btn:hover {
    background: var(--accent-red) !important;
    border-color: var(--accent-red) !important;
    color: white !important;
}

/* Barre de progression d'écriture */
.writing-progress-bar {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    height: 28px;
    background: rgba(0, 0, 0, 0.85);
    z-index: 9999;
    display: none;
    flex-direction: column;
    /* Ne participe pas au grid */
}

.app-container.focus-mode .writing-progress-bar {
    display: flex;
}

.writing-progress-fill {
    height: 3px;
    background: linear-gradient(90deg, var(--accent-gold), var(--accent-red));
    transition: width 0.3s ease;
    width: 0%;
}

.writing-progress-text {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    color: rgba(255, 255, 255, 0.8);
    font-size: 0.7rem;
    font-family: 'Courier New', monospace;
    padding: 0.2rem;
}

/* Indicateur de position discret - DÉSACTIVÉ, intégré dans la barre */
.position-indicator {
    display: none !important;
}

.focus-mode-panel {
    position: fixed;
    top: 0;
    right: 0;
    width: 350px;
    height: 100vh;
    background: var(--bg-primary);
    border-left: 2px solid var(--accent-gold);
    box-shadow: -8px 0 24px rgba(0, 0, 0, 0.3);
    transform: translateX(100%);
    transition: transform 0.3s ease;
    z-index: 2000;
    display: flex;
    flex-direction: column;
}

.focus-mode-panel.active {
    transform: translateX(0);
}

.app-container.focus-mode .focus-mode-panel {
    display: flex;
}

.focus-panel-header {
    padding: 1.5rem;
    border-bottom: 2px solid var(--border-color);
    background: var(--bg-accent);
    color: var(--bg-primary);
}

.focus-panel-title {
    font-size: 1.2rem;
    font-weight: 700;
    font-family: 'Noto Serif JP', serif;
}

.focus-panel-content {
    flex: 1;
    overflow-y: auto;
    padding: 1.5rem;
}

.focus-section {
    margin-bottom: 2rem;
}

.focus-section-title {
    font-size: 0.9rem;
    font-weight: 600;
    color: var(--text-primary);
    margin-bottom: 0.75rem;
    text-transform: uppercase;
    letter-spacing: 0.05em;
}

.pomodoro-timer {
    text-align: center;
    padding: 2rem;
    background: var(--bg-primary);
    border-radius: 4px;
    border: 2px solid var(--border-color);
}

.pomodoro-display {
    font-size: 3rem;
    font-weight: 700;
    font-family: 'Source Code Pro', monospace;
    color: var(--text-primary);
    margin-bottom: 1rem;
}

.pomodoro-controls {
    display: flex;
    gap: 0.5rem;
    justify-content: center;
}

/* Pomodoro Popup dans le header */
.pomodoro-popup {
    position: fixed;
    top: 60px;
    right: 100px;
    background: var(--bg-primary);
    border: 2px solid var(--border-color);
    border-radius: 8px;
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
    z-index: 10000;
    display: none;
    min-width: 200px;
}

.pomodoro-popup.active {
    display: block;
}

.pomodoro-popup-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.75rem 1rem;
    background: var(--bg-secondary);
    border-bottom: 1px solid var(--border-color);
    font-weight: 600;
    border-radius: 6px 6px 0 0;
}

.pomodoro-popup-close {
    cursor: pointer;
    font-size: 1.2rem;
    color: var(--text-muted);
    transition: color 0.2s;
}

.pomodoro-popup-close:hover {
    color: var(--accent-red);
}

.pomodoro-popup-content {
    padding: 1.5rem;
    text-align: center;
}

.pomodoro-popup .pomodoro-display {
    font-size: 2.5rem;
    margin-bottom: 1rem;
}

.pomodoro-popup .pomodoro-controls {
    margin-bottom: 1rem;
}

.pomodoro-stats {
    display: flex;
    justify-content: center;
    gap: 1rem;
}

.pomodoro-stat {
    display: flex;
    flex-direction: column;
    align-items: center;
}

.pomodoro-stat-value {
    font-size: 1.5rem;
    font-weight: 700;
    color: var(--primary-color);
}

.pomodoro-stat-label {
    font-size: 0.75rem;
    color: var(--text-muted);
    text-transform: uppercase;
}

/* Indicateur visuel quand le timer tourne */
.header-action-btn.pomodoro-active {
    color: var(--accent-red);
    animation: pomodoro-pulse 1s ease-in-out infinite;
}

@keyframes pomodoro-pulse {

    0%,
    100% {
        opacity: 1;
    }

    50% {
        opacity: 0.5;
    }
}

.ambient-music {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
}

.focus-stats {
    display: flex;
    gap: 1rem;
    margin-top: 1rem;
}

.focus-stat-box {
    flex: 1;
    padding: 0.75rem;
    background: var(--bg-primary);
    border: 1px solid var(--border-color);
    border-radius: 2px;
    text-align: center;
}

.focus-stat-value {
    font-size: 1.5rem;
    font-weight: 700;
    color: var(--accent-gold);
    font-family: 'Source Code Pro', monospace;
}

.focus-stat-label {
    font-size: 0.75rem;
    color: var(--text-muted);
    margin-top: 0.25rem;
}

/* REVISION MODE STYLES */
.highlight-yellow {
    background: var(--highlight-yellow);
}

.highlight-green {
    background: var(--highlight-green);
}

.highlight-blue {
    background: var(--highlight-blue);
}

.highlight-red {
    background: var(--highlight-red);
}

.highlight-purple {
    background: var(--highlight-purple);
}

.revision-toolbar {
    display: flex;
    gap: 0.5rem;
    padding: 1rem 3rem;
    border-bottom: 2px solid var(--accent-red);
    background: var(--bg-secondary);
    flex-wrap: wrap;
    align-items: center;
}

.revision-badge {
    padding: 0.5rem 1rem;
    background: var(--accent-red);
    color: var(--bg-primary);
    border-radius: 4px;
    font-weight: 600;
    margin-right: 1rem;
}

.highlight-btn {
    padding: 0.5rem 0.75rem;
    border: 1px solid var(--border-color);
    background: var(--bg-primary);
    cursor: pointer;
    font-size: 0.85rem;
    border-radius: 2px;
    transition: all 0.2s;
}

.highlight-btn.active {
    border-width: 2px;
    font-weight: 600;
}

.highlight-btn.yellow {
    background: var(--highlight-yellow);
}

.highlight-btn.green {
    background: var(--highlight-green);
}

.highlight-btn.blue {
    background: var(--highlight-blue);
}

.highlight-btn.red {
    background: var(--highlight-red);
}

.highlight-btn.purple {
    background: var(--highlight-purple);
}

.annotations-panel {
    background: var(--bg-secondary);
    border-left: 2px solid var(--border-color);
    border-right: 1px solid var(--border-color);
    display: flex;
    flex-direction: column;
    overflow: hidden;
    min-width: 250px;
    width: 280px;
    height: 100%;
    z-index: 10;
}

.annotations-panel.hidden {
    display: none;
    min-width: 0;
    width: 0;
}

.annotations-panel.visible {
    display: flex;
}

.annotations-panel-spacer {
    display: none;
    /* Plus besoin du spacer */
}

.annotations-panel-content {
    flex: 1;
    overflow-y: auto;
    padding: 1rem;
}

.annotations-panel-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1rem;
    padding-bottom: 0.5rem;
    border-bottom: 2px solid var(--border-color);
}

.annotations-panel-close {
    cursor: pointer;
    font-size: 1.5rem;
    color: var(--text-muted);
    transition: color 0.2s;
    padding: 0.5rem;
    line-height: 1;
}

.annotations-panel-close:hover {
    color: var(--accent-red);
}

.annotation-card {
    background: var(--bg-primary);
    border-left: 4px solid var(--accent-gold);
    padding: 1rem;
    margin-bottom: 1rem;
    border-radius: 0 4px 4px 0;
    cursor: pointer;
}

.annotation-card:hover {
    transform: translateX(-4px);
}

.annotation-card.todo {
    border-left-color: var(--accent-red);
}

.annotation-card.note {
    border-left-color: #4CAF50;
}

.annotation-card.question {
    border-left-color: #2196F3;
}

.annotation-type {
    font-size: 0.7rem;
    padding: 0.25rem 0.5rem;
    border-radius: 2px;
    text-transform: uppercase;
    font-weight: 600;
    display: inline-block;
    margin-bottom: 0.5rem;
}

.annotation-type.comment {
    background: var(--accent-gold);
    color: white;
}

.annotation-type.todo {
    background: var(--accent-red);
    color: white;
}

.annotation-type.note {
    background: #4CAF50;
    color: white;
}

.annotation-type.question {
    background: #2196F3;
    color: white;
}

.annotation-content {
    font-size: 0.9rem;
    margin-bottom: 0.5rem;
}

.annotation-context {
    font-size: 0.75rem;
    color: var(--text-muted);
    font-style: italic;
    padding: 0.5rem;
    background: var(--bg-secondary);
    border-radius: 2px;
    margin-bottom: 0.5rem;
}

/* Marqueurs d'annotation dans le texte */
.annotation-marker {
    padding: 2px 0;
    border-radius: 2px;
    transition: background 0.3s ease, box-shadow 0.3s ease;
    position: relative;
}

.annotation-marker:hover {
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
}

.annotation-marker.comment {
    background: rgba(255, 235, 59, 0.3);
    border-bottom: 2px solid #FBC02D;
}

.annotation-marker.question {
    background: rgba(33, 150, 243, 0.3);
    border-bottom: 2px solid #1976D2;
}

.annotation-marker.todo {
    background: rgba(244, 67, 54, 0.3);
    border-bottom: 2px solid #D32F2F;
}

.annotation-marker.note {
    background: rgba(76, 175, 80, 0.3);
    border-bottom: 2px solid #4CAF50;
}

.annotation-popup {
    position: fixed;
    background: var(--bg-primary);
    border: 2px solid var(--accent-gold);
    border-radius: 4px;
    padding: 1.5rem;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    z-index: 10000;
    min-width: 350px;
    display: none;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
}

.annotation-popup.visible {
    display: block;
}

.annotation-type-selector {
    display: flex;
    gap: 0.5rem;
    margin-bottom: 1rem;
}

.annotation-type-btn {
    flex: 1;
    padding: 0.5rem;
    border: 1px solid var(--border-color);
    background: var(--bg-secondary);
    cursor: pointer;
    font-size: 0.75rem;
    border-radius: 2px;
}

.annotation-type-btn.active {
    border-width: 2px;
    font-weight: 600;
}

.annotation-type-btn.comment.active {
    border-color: var(--accent-gold);
}

.annotation-type-btn.todo.active {
    border-color: var(--accent-red);
}

.annotation-type-btn.note.active {
    border-color: #4CAF50;
}

.annotation-type-btn.question.active {
    border-color: #2196F3;
}

.annotation-popup textarea {
    width: 100%;
    min-height: 100px;
    padding: 0.75rem;
    border: 1px solid var(--border-color);
    border-radius: 2px;
    font-family: inherit;
    font-size: 0.95rem;
    margin-bottom: 1rem;
}

.todo-item {
    background: var(--bg-primary);
    border: 1px solid var(--border-color);
    padding: 0.75rem;
    margin-bottom: 0.75rem;
    border-radius: 4px;
    display: flex;
    gap: 0.75rem;
    cursor: pointer;
}

.todo-item:hover {
    border-color: var(--accent-gold);
}

.todo-checkbox {
    width: 18px;
    height: 18px;
    cursor: pointer;
}

.todo-text {
    flex: 1;
}

.todo-text.done {
    text-decoration: line-through;
    color: var(--text-muted);
}

.scene-badge {
    font-size: 0.7rem;
    padding: 0.2rem 0.4rem;
    background: var(--accent-red);
    color: white;
    border-radius: 2px;
    margin-left: 0.5rem;
}
/* ========== 08.visualizations.css ========== */
/* ============================================ */
/* CORK BOARD STYLES */
/* ============================================ */

.cork-board-container {
    padding: 2rem;
    background: var(--bg-tertiary);
    background-image:
        radial-gradient(circle at 20% 30%, rgba(var(--text-primary-rgb), 0.05) 1px, transparent 1px),
        radial-gradient(circle at 70% 60%, rgba(var(--text-primary-rgb), 0.05) 1px, transparent 1px),
        radial-gradient(circle at 40% 80%, rgba(var(--text-primary-rgb), 0.05) 1px, transparent 1px);
    background-size: 100px 100px, 150px 150px, 120px 120px;
    min-height: calc(100vh - 200px);
    overflow-y: auto;
}

.cork-board-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 2rem;
    padding: 1rem 2rem;
    background: var(--bg-primary);
    border-radius: 8px;
    box-shadow: 0 2px 8px var(--shadow);
}

.cork-board-title {
    font-size: 1.5rem;
    font-weight: 700;
    color: var(--text-primary);
}

.cork-board-filters {
    display: flex;
    gap: 1rem;
    align-items: center;
}

.cork-board-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
    gap: 2rem;
    padding: 1rem;
}

.cork-card {
    background: var(--bg-primary);
    padding: 1.5rem;
    border-radius: 4px;
    box-shadow:
        0 2px 4px var(--shadow),
        0 4px 8px var(--shadow);
    cursor: move;
    transition: all 0.3s ease;
    position: relative;
    min-height: 200px;
    border: 1px solid var(--border-color);
}

.cork-card::before {
    content: '📌';
    position: absolute;
    top: -10px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 1.5rem;
    filter: drop-shadow(0 2px 2px var(--shadow));
}

.cork-card:hover {
    transform: translateY(-5px) rotate(1deg);
    box-shadow:
        0 4px 8px var(--shadow),
        0 8px 16px var(--shadow);
}

.cork-card.dragging {
    opacity: 0.5;
    transform: rotate(5deg);
}

.cork-card-header {
    display: flex;
    justify-content: space-between;
    align-items: start;
    margin-bottom: 1rem;
    padding-bottom: 0.75rem;
    border-bottom: 2px dashed var(--border-color);
}

.cork-card-number {
    font-size: 0.8rem;
    font-weight: 600;
    color: var(--text-muted);
    font-family: 'Source Code Pro', monospace;
}

.cork-card-color-tag {
    width: 30px;
    height: 30px;
    border-radius: 50%;
    border: 2px solid rgba(0, 0, 0, 0.2);
    cursor: pointer;
    transition: transform 0.2s;
}

.cork-card-color-tag:hover {
    transform: scale(1.2);
}

.cork-card-title {
    font-size: 1.1rem;
    font-weight: 700;
    color: var(--text-primary);
    margin-bottom: 1rem;
    line-height: 1.3;
}

.cork-card-synopsis {
    font-size: 0.9rem;
    color: var(--text-secondary);
    line-height: 1.6;
    margin-bottom: 1rem;
    min-height: 60px;
}

.cork-card-meta {
    display: flex;
    gap: 1rem;
    font-size: 0.75rem;
    color: var(--text-muted);
    margin-top: auto;
}

.cork-card-actions {
    display: flex;
    gap: 0.5rem;
    margin-top: 1rem;
    padding-top: 0.75rem;
    border-top: 1px dashed var(--border-color);
}

.cork-color-palette {
    position: absolute;
    top: 100%;
    right: 0;
    background: white;
    border: 2px solid var(--border-color);
    border-radius: 4px;
    padding: 0.5rem;
    display: none;
    z-index: 1000;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
}

.cork-color-palette.visible {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 0.5rem;
}

.cork-color-option {
    width: 30px;
    height: 30px;
    border-radius: 50%;
    border: 2px solid rgba(0, 0, 0, 0.2);
    cursor: pointer;
    transition: transform 0.2s;
}

.cork-color-option:hover {
    transform: scale(1.2);
}

/* Couleurs prédéfinies pour POV/Intrigues */
.cork-color-yellow {
    background: var(--cork-bg-yellow);
}

.cork-color-pink {
    background: var(--cork-bg-pink);
}

.cork-color-blue {
    background: var(--cork-bg-blue);
}

.cork-color-green {
    background: var(--cork-bg-green);
}

.cork-color-purple {
    background: var(--cork-bg-purple);
}

.cork-color-orange {
    background: var(--cork-bg-orange);
}

.cork-color-red {
    background: var(--cork-bg-red);
}

.cork-color-teal {
    background: var(--cork-bg-teal);
}

.cork-color-default {
    background: var(--cork-bg-default);
}

.cork-board-empty {
    text-align: center;
    padding: 4rem;
    color: var(--text-muted);
}

.cork-board-empty-icon {
    font-size: 4rem;
    margin-bottom: 1rem;
    opacity: 0.5;
}

.cork-filter-btn {
    padding: 0.5rem 1rem;
    border: 2px solid var(--border-color);
    background: var(--bg-primary);
    color: var(--text-primary);
    cursor: pointer;
    font-size: 0.85rem;
    border-radius: 4px;
    transition: all 0.2s;
    font-weight: 500;
}

.cork-filter-btn:hover {
    background: var(--accent-gold);
    color: white;
    border-color: var(--accent-gold);
}

.cork-filter-btn.active {
    background: var(--accent-red);
    color: white;
    border-color: var(--accent-red);
}

/* ============================================
           STRUCTURED VIEW (Style plume_locale)
           ============================================ */

.structured-act-container {
    background: var(--bg-secondary);
    border-radius: 8px;
    padding: 1rem;
    border: 1px solid var(--border-color);
}

.structured-act-header {
    display: flex;
    align-items: center;
    gap: 1rem;
    margin-bottom: 1rem;
    padding-bottom: 1rem;
    border-bottom: 1px solid var(--border-color);
}

.structured-collapse-btn {
    background: transparent;
    border: none;
    color: var(--text-primary);
    cursor: pointer;
    font-size: 0.9rem;
    padding: 0.25rem;
}

.structured-collapse-btn:hover {
    color: var(--primary-color);
}

.structured-act-title {
    font-size: 1.1rem;
    font-weight: 600;
    color: var(--text-primary);
}

.structured-count {
    color: var(--text-secondary);
    font-size: 0.9rem;
    margin-left: auto;
}

.structured-chapters-grid {
    display: grid;
    /* On remplace 300px par la variable, avec une valeur par défaut de 300px */
    grid-template-columns: repeat(auto-fill, minmax(var(--chapter-card-width, 300px), 1fr));
    gap: 1rem;
    transition: all 0.3s ease;
    /* Ajoute une fluidité lors du redimensionnement */
}

.structured-chapter-container {
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 6px;
    padding: 1rem;
}

.structured-chapter-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 0.75rem;
    padding-bottom: 0.75rem;
    border-bottom: 1px solid var(--border-color);
}

.structured-chapter-icon {
    color: var(--text-muted);
    font-size: 1rem;
}

.structured-chapter-title {
    color: var(--text-primary);
    font-weight: 500;
    font-size: 0.95rem;
}

.structured-menu-btn {
    background: transparent;
    border: none;
    color: var(--text-muted);
    cursor: pointer;
    padding: 0.25rem 0.5rem;
    font-size: 1.2rem;
}

.structured-menu-btn:hover {
    color: var(--accent-gold);
}

.structured-scenes-list {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
}

.structured-scene-card {
    background: var(--bg-primary);
    border: 1px solid var(--border-color);
    border-radius: 4px;
    padding: 0.75rem;
    cursor: pointer;
    transition: all 0.2s ease;
}

.structured-scene-card:hover {
    border-color: var(--accent-gold);
    transform: translateX(2px);
}

.structured-scene-header {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin-bottom: 0.5rem;
}

.structured-scene-icon {
    color: var(--text-muted);
    font-size: 0.9rem;
}

.structured-scene-title {
    color: var(--text-primary);
    font-size: 0.9rem;
    font-weight: 500;
}

.structured-scene-menu {
    background: transparent;
    border: none;
    color: var(--text-muted);
    cursor: pointer;
    padding: 0.25rem;
    margin-left: auto;
}

.structured-scene-menu:hover {
    color: var(--accent-gold);
}

.structured-scene-synopsis {
    color: var(--text-secondary);
    font-size: 0.85rem;
    line-height: 1.4;
    margin-bottom: 0.5rem;
    min-height: 2.5rem;
}

.structured-scene-synopsis:empty:before {
    content: attr(data-placeholder);
    color: var(--text-muted);
}

.structured-scene-synopsis:focus {
    outline: none;
    color: var(--text-primary);
}

.structured-scene-label {
    display: flex;
    align-items: center;
    gap: 0.25rem;
    font-size: 0.8rem;
    color: var(--text-muted);
    cursor: pointer;
}

.structured-scene-label:hover {
    color: var(--accent-gold);
}

.label-icon {
    font-size: 0.9rem;
}

.structured-add-scene-btn {
    background: transparent;
    border: 1px dashed var(--border-color);
    border-radius: 4px;
    padding: 0.75rem;
    color: var(--text-muted);
    cursor: pointer;
    font-size: 0.85rem;
    width: 100%;
    transition: all 0.2s ease;
}

.structured-add-scene-btn:hover {
    border-color: var(--accent-gold);
    color: var(--accent-gold);
    background: rgba(212, 175, 55, 0.05);
}

.structured-bottom-actions {
    display: flex;
    gap: 0.75rem;
    margin-top: 2rem;
    padding-top: 2rem;
    border-top: 1px solid var(--border-color);
}

/* Bordures des scènes basées EXCLUSIVEMENT sur le statut */
.structured-scene-card.scene-status-draft,
.cork-card.scene-status-draft {
    border-left: 3px solid var(--accent-red) !important;
}

.structured-scene-card.scene-status-progress,
.cork-card.scene-status-progress {
    border-left: 3px solid var(--accent-gold) !important;
}

.structured-scene-card.scene-status-complete,
.cork-card.scene-status-complete {
    border-left: 3px solid var(--accent-green) !important;
}

.structured-scene-card.scene-status-review,
.cork-card.scene-status-review {
    border-left: 3px solid var(--accent-blue) !important;
}

/* KANBAN VIEW STYLES */
.kanban-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: 1.5rem;
    align-items: start;
    padding: 0.5rem;
}

.kanban-column {
    background: var(--bg-secondary);
    border-radius: 12px;
    border: 1px solid var(--border-color);
    display: flex;
    flex-direction: column;
    min-height: 600px;
    box-shadow: 0 4px 12px var(--shadow);
    transition: all 0.3s ease;
}

.kanban-column:hover {
    box-shadow: 0 8px 24px var(--shadow);
}

.kanban-column-header {
    padding: 1.25rem;
    border-top-left-radius: 12px;
    border-top-right-radius: 12px;
    background: var(--bg-primary);
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 1rem;
}

.kanban-scenes-list {
    padding: 1rem;
    display: flex;
    flex-direction: column;
    gap: 1rem;
    flex: 1;
}

.kanban-scenes-list .structured-scene-card {
    margin: 0;
    width: 100%;
    transform: none !important;
    transition: transform 0.2s, box-shadow 0.2s;
}

.kanban-scenes-list .structured-scene-card:hover {
    transform: translateY(-2px) !important;
    box-shadow: 0 4px 12px var(--shadow) !important;
}

@keyframes slideIn {
    from {
        transform: translateX(400px);
        opacity: 0;
    }

    to {
        transform: translateX(0);
        opacity: 1;
    }
}

@keyframes slideOut {
    from {
        transform: translateX(0);
        opacity: 1;
    }

    to {
        transform: translateX(400px);
        opacity: 0;
    }
}

/* ============================================
           STYLES POUR LES NOUVELLES VISUALISATIONS
           ============================================ */

/* Canvas pour les visualisations */
.visualization-canvas {
    width: 100%;
    height: 750px;
    background: var(--bg-primary);
    border: 2px solid var(--border-color);
    border-radius: 4px;
    position: relative;
    overflow: hidden;
}

/* Mindmap Styles */
/* Mindmap Styles */
.mindmap-wrapper {
    display: flex;
    height: 100%;
    width: 100%;
    overflow: hidden;
}

.mindmap-sidebar {
    width: 250px;
    background: var(--bg-secondary);
    border-right: 1px solid var(--border-color);
    display: flex;
    flex-direction: column;
    overflow-y: auto;
}

.mindmap-sidebar-header {
    padding: 1rem;
    border-bottom: 1px solid var(--border-color);
    background: var(--bg-primary);
}

.mindmap-list {
    flex: 1;
    overflow-y: auto;
}

.mindmap-item {
    padding: 0.75rem 1rem;
    cursor: pointer;
    border-bottom: 1px solid var(--border-color);
    transition: background 0.2s ease;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.mindmap-item:hover {
    background: rgba(212, 175, 55, 0.1);
}

.mindmap-item.active {
    background: rgba(212, 175, 55, 0.2);
    border-left: 3px solid var(--accent-gold);
}

.mindmap-main {
    flex: 1;
    display: flex;
    flex-direction: column;
    position: relative;
}

.mindmap-toolbar {
    padding: 0.75rem 1rem;
    background: var(--bg-primary);
    border-bottom: 1px solid var(--border-color);
    display: flex;
    gap: 0.5rem;
    align-items: center;
    flex-wrap: wrap;
}

.mindmap-canvas-wrapper {
    flex: 1;
    position: relative;
    overflow: hidden;
    background:
        linear-gradient(90deg, rgba(var(--accent-gold-rgb), 0.05) 1px, transparent 1px),
        linear-gradient(rgba(var(--accent-gold-rgb), 0.05) 1px, transparent 1px);
    background-size: 20px 20px;
}

.mindmap-canvas {
    width: 100%;
    height: 100%;
    position: relative;
    transform-origin: 0 0;
    cursor: grab;
}

.mindmap-canvas.panning {
    cursor: grabbing;
}

.mindmap-canvas.linking {
    cursor: crosshair;
}

.mindmap-node {
    position: absolute;
    padding: 1rem;
    background: var(--bg-primary);
    border: 2px solid var(--accent-gold);
    border-radius: 8px;
    cursor: move;
    box-shadow: 0 2px 8px var(--shadow);
    min-width: 120px;
    max-width: 200px;
    user-select: none;
    transition: box-shadow 0.2s ease;
}

.mindmap-node:hover {
    box-shadow: 0 4px 16px rgba(212, 175, 55, 0.3);
    z-index: 10;
}

.mindmap-node.selected {
    border-color: var(--accent-red);
    box-shadow: 0 0 0 3px rgba(196, 69, 54, 0.2);
}

.mindmap-node.dragging {
    opacity: 0.7;
    cursor: grabbing;
}

.mindmap-node-header {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin-bottom: 0.5rem;
    font-weight: 600;
}

.mindmap-node-icon {
    font-size: 1.2rem;
}

.mindmap-node-title {
    flex: 1;
    font-size: 0.9rem;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.mindmap-node-delete {
    opacity: 0;
    cursor: pointer;
    color: var(--accent-red);
    font-size: 1.2rem;
    line-height: 1;
    transition: opacity 0.2s ease;
}

.mindmap-node:hover .mindmap-node-delete {
    opacity: 1;
}

.mindmap-node-link-btn {
    opacity: 0;
    cursor: pointer;
    color: var(--accent-gold);
    font-size: 1rem;
    line-height: 1;
    transition: opacity 0.2s ease;
    margin-right: 0.25rem;
}

.mindmap-node:hover .mindmap-node-link-btn {
    opacity: 1;
}

.mindmap-node-link-btn:hover {
    transform: scale(1.2);
}

.mindmap-node.linking-source {
    border-color: var(--accent-red);
    box-shadow: 0 0 0 3px rgba(196, 69, 54, 0.3);
    animation: pulse 1s infinite;
}

@keyframes pulse {

    0%,
    100% {
        box-shadow: 0 0 0 3px rgba(196, 69, 54, 0.3);
    }

    50% {
        box-shadow: 0 0 0 6px rgba(196, 69, 54, 0.1);
    }
}

@keyframes pulse-text {

    0%,
    100% {
        opacity: 1;
    }

    50% {
        opacity: 0.6;
    }
}

.mindmap-canvas-wrapper.linking-mode {
    cursor: crosshair;
}

.mindmap-canvas-wrapper.linking-mode .mindmap-node:not(.linking-source) {
    cursor: pointer;
}

.mindmap-canvas-wrapper.linking-mode .mindmap-node:not(.linking-source):hover {
    box-shadow: 0 0 0 3px rgba(74, 158, 255, 0.5);
    border-color: var(--accent-blue);
}

.mindmap-node-content {
    font-size: 0.85rem;
    color: var(--text-secondary);
    line-height: 1.4;
}

.mindmap-node.type-character {
    border-color: var(--accent-red);
    background: rgba(var(--accent-red-rgb), 0.05);
}

.mindmap-node.type-element {
    border-color: var(--accent-green);
    background: rgba(var(--accent-green-rgb), 0.05);
}

.mindmap-node.type-scene {
    border-color: var(--accent-blue);
    background: rgba(var(--accent-blue-rgb), 0.05);
}

.mindmap-node.type-note {
    border-color: var(--accent-gold);
    background: var(--bg-primary);
}

.mindmap-node.type-codex {
    border-color: var(--accent-purple);
    background: rgba(var(--accent-purple-rgb), 0.05);
}

.mindmap-node.type-act {
    border-color: var(--primary-color);
    background: rgba(var(--primary-color-rgb), 0.08);
}

.mindmap-node.type-chapter {
    border-color: var(--accent-blue);
    background: rgba(var(--accent-blue-rgb), 0.05);
}

.mindmap-link-line {
    position: absolute;
    pointer-events: stroke;
    cursor: pointer;
}

.mindmap-link-label {
    position: absolute;
    padding: 0.25rem 0.5rem;
    background: var(--bg-primary);
    border: 1px solid var(--border-color);
    border-radius: 4px;
    font-size: 0.75rem;
    white-space: nowrap;
    pointer-events: none;
    transform: translate(-50%, -50%);
}

.mindmap-library {
    width: 250px;
    background: var(--bg-secondary);
    border-left: 1px solid var(--border-color);
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

.mindmap-library.collapsed {
    width: 40px;
}

.mindmap-library-toggle {
    padding: 0.75rem;
    text-align: center;
    cursor: pointer;
    border-bottom: 1px solid var(--border-color);
    background: var(--bg-primary);
    font-size: 1.2rem;
}

.mindmap-library-tabs {
    display: flex;
    border-bottom: 1px solid var(--border-color);
}

.mindmap-library.collapsed .mindmap-library-tabs {
    display: none;
}

.mindmap-library-tab {
    flex: 1;
    padding: 0.5rem;
    text-align: center;
    cursor: pointer;
    font-size: 0.85rem;
    border-right: 1px solid var(--border-color);
    transition: background 0.2s ease;
}

.mindmap-library-tab:last-child {
    border-right: none;
}

.mindmap-library-tab:hover {
    background: rgba(212, 175, 55, 0.1);
}

.mindmap-library-tab.active {
    background: var(--accent-gold);
    color: white;
    font-weight: 600;
}

.mindmap-library-content {
    flex: 1;
    overflow-y: auto;
    padding: 0.5rem;
}

.mindmap-library.collapsed .mindmap-library-content {
    display: none;
}

.mindmap-library-item {
    padding: 0.75rem;
    margin-bottom: 0.5rem;
    background: var(--bg-primary);
    border: 1px solid var(--border-color);
    border-radius: 4px;
    cursor: grab;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.mindmap-library-item:hover {
    border-color: var(--accent-gold);
    box-shadow: 0 2px 8px var(--shadow);
}

.mindmap-library-item:active {
    cursor: grabbing;
}

.mindmap-library-item-icon {
    font-size: 1.2rem;
}

.mindmap-library-item-text {
    flex: 1;
    font-size: 0.85rem;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.mindmap-empty {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100%;
    color: var(--text-muted);
    padding: 2rem;
    text-align: center;
}

.mindmap-empty-icon {
    font-size: 4rem;
    margin-bottom: 1rem;
    opacity: 0.3;
}


/* ============================================
           NARRATIVE ARCS STYLES
           ============================================ */

/* Arc Detail View Styles */
.arc-detail-view {
    padding: 2rem;
    max-width: none;
    margin: 0 auto;
}

.arc-detail-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: 2rem;
    padding-bottom: 1.5rem;
    border-bottom: 2px solid var(--border-color);
}

.arc-detail-title-group {
    display: flex;
    align-items: center;
    gap: 1rem;
}

.arc-detail-icon {
    font-size: 2.5rem;
}

.arc-detail-header h2 {
    margin: 0;
    font-size: 2rem;
    color: var(--text-primary);
}

.arc-detail-actions {
    display: flex;
    gap: 0.75rem;
}

.arc-detail-content {
    display: flex;
    flex-direction: column;
    gap: 2rem;
}

.arc-detail-section h3 {
    font-size: 1.2rem;
    color: var(--text-primary);
    margin-bottom: 1rem;
}

.arc-detail-meta {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: 1.5rem;
    margin-bottom: 1rem;
}

.arc-detail-meta-item {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
}

.arc-detail-meta-label {
    font-size: 0.85rem;
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.arc-detail-meta-value {
    font-size: 1.1rem;
    font-weight: 600;
    color: var(--text-primary);
}

.arc-progress-bar {
    height: 12px;
    background: var(--bg-secondary);
    border-radius: 6px;
    overflow: hidden;
    margin-bottom: 0.5rem;
}

.arc-progress-fill {
    height: 100%;
    transition: width 0.3s ease;
    border-radius: 6px;
}

.arc-progress-text {
    font-size: 0.9rem;
    color: var(--text-muted);
    margin: 0;
}

.arc-scenes-list {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
}

.arc-scene-item {
    background: var(--bg-secondary);
    border: 2px solid var(--border-color);
    border-radius: 8px;
    padding: 1rem;
    cursor: pointer;
    transition: all 0.2s;
}

.arc-scene-item:hover {
    border-color: var(--primary-color);
    background: var(--bg-tertiary);
}

.arc-scene-title {
    font-weight: 600;
    color: var(--text-primary);
    margin-bottom: 0.5rem;
}

.arc-scene-meta {
    display: flex;
    gap: 1rem;
    font-size: 0.85rem;
    color: var(--text-muted);
    margin-bottom: 0.5rem;
}

.arc-scene-intensity {
    color: var(--primary-color);
    font-weight: 600;
}

.arc-scene-notes {
    font-size: 0.9rem;
    color: var(--text-secondary);
    font-style: italic;
    margin-top: 0.5rem;
}

.btn-danger {
    padding: 0.75rem 1.5rem;
    background: var(--error-color);
    color: white;
    border: none;
    border-radius: 8px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    font-family: 'Crimson Pro', serif;
    font-size: 1rem;
}

.btn-danger:hover {
    background: #b91c1c;
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(220, 38, 38, 0.3);
}

.btn-danger:active {
    transform: translateY(0);
}

/* Arc Editor View Styles */
.arc-editor-view {
    padding: 2rem;
    max-width: none;
    margin: 0 auto;
}

.arc-editor-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 2rem;
    padding-bottom: 1.5rem;
    border-bottom: 2px solid var(--border-color);
}

.arc-editor-header h2 {
    margin: 0;
    font-size: 2rem;
    color: var(--text-primary);
}

.arc-editor-actions-header {
    display: flex;
    gap: 0.75rem;
}

.arc-editor-form {
    display: flex;
    flex-direction: column;
    gap: 2rem;
}

.arc-editor-section {
    background: var(--bg-secondary);
    padding: 1.5rem;
    border-radius: 12px;
    border: 2px solid var(--border-color);
}

.arc-editor-section h3 {
    margin: 0 0 1.5rem 0;
    font-size: 1.2rem;
    color: var(--text-primary);
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.arc-editor-section h3 [data-lucide] {
    width: 20px;
    height: 20px;
    color: var(--primary-color);
}

.arc-editor-header h2 {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.arc-editor-header h2 [data-lucide] {
    width: 24px;
    height: 24px;
    color: var(--primary-color);
}

.btn-primary [data-lucide],
.btn-secondary [data-lucide] {
    width: 16px;
    height: 16px;
    vertical-align: middle;
    margin-right: 4px;
}

.form-group {
    margin-bottom: 1.5rem;
}

.form-group:last-child {
    margin-bottom: 0;
}

.form-group label {
    display: block;
    margin-bottom: 0.5rem;
    font-weight: 600;
    color: var(--text-primary);
    font-size: 0.95rem;
}

.form-input {
    width: 100%;
    padding: 0.75rem;
    border: 2px solid var(--border-color);
    border-radius: 8px;
    font-size: 1rem;
    font-family: inherit;
    background: var(--bg-primary);
    color: var(--text-primary);
}

.form-input:focus {
    outline: none;
    border-color: var(--primary-color);
}

.form-textarea {
    width: 100%;
    min-height: 120px;
    padding: 0.75rem;
    border: 2px solid var(--border-color);
    border-radius: 8px;
    font-size: 1rem;
    font-family: inherit;
    resize: vertical;
    background: var(--bg-primary);
    color: var(--text-primary);
}

.form-textarea:focus {
    outline: none;
    border-color: var(--primary-color);
}

.form-select {
    width: 100%;
    padding: 0.75rem;
    border: 2px solid var(--border-color);
    border-radius: 8px;
    font-size: 1rem;
    font-family: inherit;
    background: var(--bg-primary);
    color: var(--text-primary);
}

.form-select:focus {
    outline: none;
    border-color: var(--primary-color);
}

.form-row {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 1rem;
}

.form-help {
    margin: 0.5rem 0 0 0;
    font-size: 0.85rem;
    color: var(--text-muted);
}

.color-picker-group {
    display: flex;
    gap: 1rem;
    align-items: center;
}

.color-picker-group input[type="color"] {
    width: 80px;
    height: 44px;
    border: 2px solid var(--border-color);
    border-radius: 8px;
    cursor: pointer;
    background: none;
}

.form-input-small {
    width: 120px;
    padding: 0.75rem;
    border: 2px solid var(--border-color);
    border-radius: 8px;
    font-family: monospace;
    background: var(--bg-primary);
    color: var(--text-primary);
}

.arc-types-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
    gap: 0.75rem;
}

/* Sidebar item styles for arcs */
.sidebar-item-icon {
    display: flex;
    align-items: center;
    justify-content: center;
}

.sidebar-item-icon [data-lucide] {
    width: 18px;
    height: 18px;
    stroke-width: 2;
}

.sidebar-empty-icon {
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 2rem;
    opacity: 0.4;
    margin-bottom: 0.5rem;
}

.sidebar-empty-icon [data-lucide] {
    width: 32px;
    height: 32px;
    stroke-width: 1.5;
}

.arc-panel-empty-icon {
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0.4;
    margin-bottom: 0.5rem;
}

.arc-panel-empty-icon [data-lucide] {
    width: 32px;
    height: 32px;
    stroke-width: 1.5;
}

.arc-in-scene-title [data-lucide] {
    width: 16px;
    height: 16px;
    vertical-align: middle;
    margin-right: 4px;
}

.arc-type-card {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.5rem;
    padding: 1rem;
    background: var(--bg-primary);
    border: 2px solid var(--border-color);
    border-radius: 10px;
    cursor: pointer;
    transition: all 0.2s;
}

.arc-type-card:hover {
    border-color: var(--primary-color);
    transform: translateY(-2px);
    box-shadow: 0 4px 12px var(--shadow);
}

.arc-type-card.selected {
    border-color: var(--primary-color);
    background: var(--primary-color);
    color: white;
}

.arc-type-icon {
    font-size: 2rem;
    display: flex;
    align-items: center;
    justify-content: center;
}

.arc-type-icon [data-lucide] {
    width: 32px;
    height: 32px;
    stroke-width: 1.5;
}

.arc-type-card.selected .arc-type-icon [data-lucide] {
    color: white;
}

.arc-type-label {
    font-size: 0.9rem;
    font-weight: 600;
    text-align: center;
}

.arc-type-card.selected .arc-type-label {
    color: white;
}

/* Arc Scene Panel Styles */
.arc-scene-panel {
    background: var(--bg-secondary);
    border-left: 2px solid var(--border-color);
    border-right: 1px solid var(--border-color);
    display: flex;
    flex-direction: column;
    overflow: hidden;
    min-width: 250px;
    width: 280px;
    height: 100%;
    z-index: 10;
}

.arc-scene-panel.hidden {
    display: none;
    min-width: 0;
    width: 0;
}

.arc-scene-panel-header {
    padding: 1.5rem;
    border-bottom: 2px solid var(--border-color);
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.arc-scene-panel-header h3 {
    margin: 0;
    font-size: 1.1rem;
    color: var(--text-primary);
}

.arc-panel-close {
    background: none;
    border: none;
    font-size: 1.5rem;
    cursor: pointer;
    color: var(--text-muted);
    padding: 0;
    line-height: 1;
}

.arc-panel-close:hover {
    color: var(--error-color);
}

.arc-scene-panel-content {
    flex: 1;
    overflow-y: auto;
    padding: 1rem;
}

.arc-scene-info {
    background: var(--bg-secondary);
    padding: 1rem;
    border-radius: 8px;
    margin-bottom: 1rem;
    font-size: 0.9rem;
}

.arc-scene-info-title {
    font-weight: 600;
    color: var(--text-primary);
    margin-bottom: 0.5rem;
}

.arc-in-scene {
    background: var(--bg-primary);
    border: 2px solid var(--border-color);
    border-radius: 8px;
    padding: 1rem;
    margin-bottom: 1rem;
}

.arc-in-scene-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: 1rem;
}

.arc-in-scene-title {
    font-weight: 600;
    color: var(--text-primary);
    flex: 1;
}

.arc-in-scene-remove {
    background: none;
    border: none;
    color: var(--text-muted);
    cursor: pointer;
    font-size: 1.2rem;
    padding: 0;
}

.arc-in-scene-remove:hover {
    color: var(--error-color);
}

.arc-in-scene-control {
    margin-bottom: 1rem;
}

.arc-in-scene-label {
    font-size: 0.85rem;
    color: var(--text-secondary);
    margin-bottom: 0.5rem;
    display: block;
}

.arc-intensity-slider {
    width: 100%;
    margin-bottom: 0.5rem;
}

.arc-intensity-value {
    text-align: center;
    font-weight: 600;
    color: var(--primary-color);
}

.arc-status-select {
    width: 100%;
    padding: 0.5rem;
    border: 2px solid var(--border-color);
    border-radius: 6px;
    background: var(--bg-primary);
    font-size: 0.9rem;
}

.arc-column-select {
    width: 100%;
    padding: 0.5rem;
    border: 2px solid var(--border-color);
    border-radius: 6px;
    background: var(--bg-primary);
    font-size: 0.9rem;
    color: var(--text-primary);
}

.arc-notes-textarea {
    width: 100%;
    min-height: 60px;
    padding: 0.5rem;
    border: 2px solid var(--border-color);
    border-radius: 6px;
    font-size: 0.85rem;
    font-family: inherit;
    resize: vertical;
}

.arc-panel-add-select {
    width: 100%;
    padding: 0.75rem;
    border: 2px solid var(--border-color);
    border-radius: 8px;
    margin-bottom: 0.5rem;
}

.arc-panel-add-btn {
    width: 100%;
    padding: 0.75rem;
    background: var(--primary-color);
    color: white;
    border: none;
    border-radius: 8px;
    font-weight: 600;
    cursor: pointer;
    margin-top: 0.5rem;
}

.arc-panel-add-btn:hover {
    opacity: 0.9;
}

.arc-panel-empty {
    text-align: center;
    padding: 2rem 1rem;
    color: var(--text-muted);
}

.arc-panel-empty-icon {
    font-size: 3rem;
    margin-bottom: 1rem;
    opacity: 0.3;
}

/* ============================================ 
   LIVE TENSION METER 
   ============================================ */

.tension-meter-container {
    position: fixed;
    bottom: 2rem;
    right: 6.5rem;
    /* Left of focus button */
    width: 60px;
    height: 60px;
    background: var(--bg-primary);
    border-radius: 50%;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
    z-index: 1000;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: help;
    transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    border: 2px solid var(--border-color);
}

.tension-meter-container:hover {
    transform: scale(1.1);
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
}

.tension-meter-svg {
    transform: rotate(-90deg);
    width: 50px;
    height: 50px;
}

.tension-meter-bg {
    fill: none;
    stroke: var(--bg-secondary);
    stroke-width: 4;
}

.tension-meter-fill {
    fill: none;
    stroke: var(--accent-blue);
    stroke-width: 4;
    stroke-linecap: round;
    transition: stroke-dashoffset 0.5s ease, stroke 0.5s ease;
}

.tension-value-display {
    position: absolute;
    font-family: 'Source Code Pro', monospace;
    font-size: 0.75rem;
    font-weight: 700;
    color: var(--text-primary);
}

/* Tooltip premium */
.tension-tooltip {
    position: absolute;
    bottom: 110%;
    right: 0;
    width: 220px;
    background: var(--bg-primary);
    border: 1px solid var(--border-color);
    border-radius: 12px;
    padding: 1rem;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
    opacity: 0;
    visibility: hidden;
    transition: all 0.2s ease;
    z-index: 1001;
    pointer-events: none;
}

.tension-meter-container:hover .tension-tooltip {
    opacity: 1;
    visibility: visible;
    transform: translateY(-5px);
}

.tension-tooltip-title {
    font-weight: 700;
    font-size: 0.9rem;
    margin-bottom: 0.75rem;
    border-bottom: 1px solid var(--border-color);
    padding-bottom: 0.5rem;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.tension-tooltip-item {
    display: flex;
    justify-content: space-between;
    font-size: 0.75rem;
    margin-bottom: 0.4rem;
    color: var(--text-secondary);
}

.tension-tags-container {
    margin-top: 0.75rem;
    display: flex;
    flex-wrap: wrap;
    gap: 4px;
}

.tension-tag {
    display: inline-block;
    padding: 2px 6px;
    border-radius: 4px;
    font-size: 0.65rem;
    font-weight: 600;
}

.tension-tag-high {
    background: rgba(196, 69, 54, 0.1);
    color: var(--accent-red);
    border: 1px solid rgba(196, 69, 54, 0.2);
}

.tension-tag-medium {
    background: rgba(184, 134, 11, 0.1);
    color: var(--accent-gold);
    border: 1px solid rgba(184, 134, 11, 0.2);
}

.tension-tag-low {
    background: rgba(58, 123, 200, 0.1);
    color: var(--accent-blue);
    border: 1px solid rgba(58, 123, 200, 0.2);
}

.tension-meter-container.focus-hide {
    opacity: 0.2;
}

.tension-meter-container.focus-hide:hover {
    opacity: 1;
}
/* ========== 09.utilities.css ========== */
/* Storage Quota Badge Styles */
        .storage-badge {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 12px 18px;
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: 25px;
            font-size: 13px;
            font-weight: 600;
            color: var(--text-primary);
            box-shadow: 0 4px 12px var(--shadow);
            z-index: 10001;
            transition: all 0.3s;
            cursor: pointer;
            display: none;
            align-items: center;
            gap: 8px;
            min-width: 120px;
            -webkit-tap-highlight-color: transparent;
        }
        
        /* Version header du badge de stockage */
        .storage-badge-header {
            padding: 6px 12px;
            background: var(--bg-secondary);
            border: 1.5px solid var(--border-color);
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-primary);
            transition: all 0.2s;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            -webkit-tap-highlight-color: transparent;
        }
        
        .storage-badge-header:hover {
            border-color: var(--accent-gold);
            background: var(--bg-tertiary);
        }
        
        .storage-badge-header .storage-icon {
            font-size: 14px;
            line-height: 1;
        }
        
        .storage-badge-header.status-ok {
            border-color: #4caf50;
        }

        .storage-badge-header.status-warning {
            border-color: #ffc107;
        }

        .storage-badge-header.status-danger {
            border-color: #f44336;
        }

        .storage-badge:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px var(--shadow);
            border-color: var(--accent-gold);
        }

        .storage-badge:active {
            transform: translateY(0);
        }

        .storage-icon {
            font-size: 18px;
            line-height: 1;
        }

        .storage-badge.status-ok {
            border-color: #4caf50;
        }

        .storage-badge.status-warning {
            border-color: #ffc107;
            animation: pulse-warning 2s infinite;
        }

        .storage-badge.status-danger {
            border-color: #f44336;
            animation: pulse-danger 1.5s infinite;
        }

        @keyframes pulse-warning {
            0%, 100% {
                box-shadow: 0 4px 12px var(--shadow);
            }
            50% {
                box-shadow: 0 4px 20px rgba(255, 193, 7, 0.4);
            }
        }

        @keyframes pulse-danger {
            0%, 100% {
                box-shadow: 0 4px 12px var(--shadow);
            }
            50% {
                box-shadow: 0 4px 20px rgba(244, 67, 54, 0.5);
            }
        }

        .storage-details-modal .modal-content {
            max-width: 500px;
        }

        .storage-info {
            margin: 20px 0;
        }

        .storage-bar {
            width: 100%;
            height: 30px;
            background: var(--bg-tertiary);
            border-radius: 15px;
            overflow: hidden;
            margin: 15px 0;
            position: relative;
        }

        .storage-bar-fill {
            height: 100%;
            transition: width 0.5s ease, background-color 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            color: white;
        }

        .storage-bar-fill.ok {
            background: linear-gradient(90deg, #4caf50, #20c997);
        }

        .storage-bar-fill.warning {
            background: linear-gradient(90deg, #ffc107, #ffb800);
        }

        .storage-bar-fill.danger {
            background: linear-gradient(90deg, #f44336, #c62828);
        }

        .storage-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 20px 0;
        }

        .storage-stat {
            background: var(--bg-tertiary);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .storage-stat-label {
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 5px;
        }

        .storage-stat-value {
            font-size: 20px;
            font-weight: bold;
            color: var(--accent-gold);
        }

        .storage-recommendations {
            background: var(--bg-tertiary);
            padding: 15px;
            border-radius: 8px;
            border-left: 3px solid var(--accent-gold);
            margin: 20px 0;
        }

        .storage-recommendations h4 {
            color: var(--accent-gold);
            margin-bottom: 10px;
        }

        .storage-recommendations ul {
            margin-left: 20px;
            color: var(--text-secondary);
            line-height: 1.8;
        }

/* Import Chapter from DOCX Styles */
.import-chapter-upload {
    padding: 1rem 0;
}

.import-chapter-dropzone {
    border: 2px dashed var(--border-color);
    border-radius: 12px;
    padding: 3rem 2rem;
    text-align: center;
    transition: all 0.3s ease;
    cursor: pointer;
    background: var(--bg-secondary);
}

.import-chapter-dropzone:hover,
.import-chapter-dropzone.dragover {
    border-color: var(--accent-gold);
    background: rgba(212, 175, 55, 0.05);
}

.import-chapter-dropzone.dragover {
    transform: scale(1.01);
    box-shadow: 0 0 20px rgba(212, 175, 55, 0.2);
}

.import-chapter-spinner {
    width: 48px;
    height: 48px;
    border: 4px solid var(--bg-tertiary);
    border-top-color: var(--accent-gold);
    border-radius: 50%;
    animation: import-spin 1s linear infinite;
    margin: 0 auto;
}

@keyframes import-spin {
    to {
        transform: rotate(360deg);
    }
}

.import-chapter-preview {
    padding: 0.5rem 0;
}

.import-chapter-list {
    background: var(--bg-secondary);
}

.import-chapter-item:last-child {
    border-bottom: none;
}

.import-chapter-item:hover {
    background: var(--bg-tertiary);
}

/* ========== 10.mobile.css ========== */
/* ============================================ */
/* FLOATING EDITOR MENU (MOBILE) */
/* ============================================ */

#floatingEditorToggle {
    display: none;
    position: fixed;
    bottom: 0;
    right: 0;
    width: 60px;
    height: 44px;
    border-radius: 0;
    background: white;
    border: none;
    border-left: 1px solid #e0e0e0;
    border-top: 1px solid #e0e0e0;
    color: #333;
    font-size: 24px;
    cursor: pointer;
    box-shadow: -2px -2px 8px rgba(0, 0, 0, 0.1);
    z-index: 10002;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
}

#floatingEditorToggle:active {
    transform: scale(0.95);
    background: #f5f5f5;
}

#floatingEditorMenu {
    display: none;
    position: fixed;
    bottom: 0;
    left: 0;
    right: 60px;
    background: white;
    border-top: 1px solid #e0e0e0;
    box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.05);
    z-index: 10001;
    overflow: visible;
    padding: 0;
    flex-direction: column-reverse;
}

#floatingEditorMenu.active {
    display: flex;
}

#floatingMenuHandle {
    display: none;
}

#floatingMenuContent {
    padding: 6px 12px;
    background: white;
    display: flex;
    gap: 8px;
    align-items: center;
    justify-content: flex-start;
    overflow-x: auto;
    overflow-y: hidden;
    -webkit-overflow-scrolling: touch;
    scrollbar-width: none;
    height: 44px;
}

#floatingMenuContent::-webkit-scrollbar {
    display: none;
}

/* Barre de sous-menu avancé */
#advancedMenuBar {
    padding: 6px 12px;
    background: white;
    display: none !important;
    gap: 8px;
    align-items: center;
    justify-content: flex-start;
    overflow-x: auto;
    overflow-y: hidden;
    -webkit-overflow-scrolling: touch;
    scrollbar-width: none;
    height: 44px;
    border-bottom: 1px solid #e0e0e0;
    box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
    width: 100%;
}

#advancedMenuBar::-webkit-scrollbar {
    display: none;
}

#floatingEditorMenu #advancedMenuBar.active {
    display: flex !important;
}

.floating-toolbar-row {
    display: flex;
    gap: 6px;
    align-items: center;
}

.floating-btn-mini {
    min-width: 36px;
    height: 36px;
    padding: 0;
    background: transparent;
    border: none;
    color: #333;
    cursor: pointer;
    transition: all 0.15s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 18px;
    font-weight: 400;
    position: relative;
    flex-shrink: 0;
}

.floating-btn-mini:active {
    background: #f0f0f0;
    border-radius: 6px;
}

.floating-select-mini {
    height: 36px;
    padding: 0 28px 0 10px;
    background: transparent;
    border: none;
    color: #333;
    font-size: 15px;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    cursor: pointer;
    appearance: none;
    background-image: url("data:image/svg+xml,%3Csvg width='10' height='6' viewBox='0 0 10 6' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 1L5 5L9 1' stroke='%23666' stroke-width='1.5' stroke-linecap='round'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 8px center;
    flex-shrink: 0;
}

.floating-select-mini:active {
    background-color: #f0f0f0;
    border-radius: 6px;
}

.floating-divider {
    width: 1px;
    height: 24px;
    background: #e0e0e0;
    flex-shrink: 0;
}

/* Storage icon mobile - déjà géré dans la media query principale */
/* Link Editor Modal */
.link-editor-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.5);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10000;
}

.link-editor-modal {
    background: var(--bg-primary);
    border: 2px solid var(--border-color);
    border-radius: 8px;
    padding: 1.5rem;
    min-width: 400px;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
}

.link-editor-header {
    font-size: 1.1rem;
    font-weight: 600;
    margin-bottom: 1rem;
    color: var(--text-primary);
}

.link-editor-field {
    margin-bottom: 1rem;
}

.link-editor-label {
    display: block;
    font-size: 0.85rem;
    font-weight: 600;
    margin-bottom: 0.5rem;
    color: var(--text-secondary);
}

.link-editor-input {
    width: 100%;
    padding: 0.5rem;
    border: 1px solid var(--border-color);
    border-radius: 4px;
    font-family: inherit;
    font-size: 0.9rem;
}

.link-editor-colors {
    display: flex;
    gap: 0.5rem;
    flex-wrap: wrap;
}

.link-color-option {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    cursor: pointer;
    border: 3px solid transparent;
    transition: all 0.2s ease;
}

.link-color-option:hover {
    transform: scale(1.1);
}

.link-color-option.selected {
    border-color: var(--text-primary);
    box-shadow: 0 0 0 2px var(--bg-primary), 0 0 0 4px var(--text-primary);
}

.link-editor-buttons {
    display: flex;
    gap: 0.5rem;
    margin-top: 1.5rem;
}

/* Relation Graph Styles */
.relation-graph {
    width: 100%;
    height: 100%;
    position: relative;
}

.relation-node {
    position: absolute;
    width: 80px;
    height: 80px;
    border-radius: 50%;
    background: var(--bg-primary);
    border: 3px solid var(--accent-gold);
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 4px 12px var(--shadow);
}

.relation-node:hover {
    transform: scale(1.2);
    z-index: 100;
}

.relation-node-avatar {
    font-size: 2rem;
}

.relation-node-label {
    position: absolute;
    bottom: -25px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 0.85rem;
    font-weight: 600;
    white-space: nowrap;
    background: white;
    padding: 0.25rem 0.5rem;
    border-radius: 4px;
    box-shadow: 0 2px 4px var(--shadow);
}

.relation-legend {
    position: absolute;
    top: 1rem;
    right: 1rem;
    background: white;
    border: 1px solid var(--border-color);
    border-radius: 4px;
    padding: 1rem;
    box-shadow: 0 4px 12px var(--shadow);
}

.relation-legend-item {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin-bottom: 0.5rem;
    font-size: 0.85rem;
}

.relation-legend-line {
    width: 30px;
    height: 3px;
}

/* Timeline Viz Styles */
.timeline-viz-container {
    width: 100%;
    padding: 2rem;
    overflow-x: auto;
}

.timeline-viz {
    display: flex;
    position: relative;
    min-width: 100%;
    padding: 2rem 0;
}

.timeline-viz-line {
    position: absolute;
    top: 50%;
    left: 0;
    right: 0;
    height: 4px;
    background: var(--accent-gold);
    transform: translateY(-50%);
}

.timeline-viz-item {
    position: relative;
    flex: 0 0 200px;
    padding: 0 1rem;
}

.timeline-viz-marker {
    width: 20px;
    height: 20px;
    background: var(--accent-gold);
    border: 4px solid white;
    border-radius: 50%;
    margin: 0 auto;
    position: relative;
    z-index: 2;
    cursor: pointer;
    transition: all 0.2s ease;
}

.timeline-viz-marker:hover {
    transform: scale(1.5);
    background: var(--accent-red);
}

.timeline-viz-content {
    background: white;
    border: 2px solid var(--border-color);
    border-radius: 4px;
    padding: 1rem;
    margin-top: 2rem;
    box-shadow: 0 4px 12px var(--shadow);
    transition: all 0.2s ease;
}

.timeline-viz-content:hover {
    border-color: var(--accent-gold);
    transform: translateY(-4px);
}

.timeline-viz-date {
    font-size: 0.8rem;
    color: var(--text-muted);
    margin-bottom: 0.5rem;
}

.timeline-viz-title {
    font-weight: 700;
    color: var(--text-primary);
    margin-bottom: 0.5rem;
}

.timeline-viz-description {
    font-size: 0.85rem;
    color: var(--text-secondary);
    line-height: 1.4;
}

/* Metro Timeline Styles */
.metro-timeline-container {
    width: 100%;
    min-height: 500px;
    overflow-x: auto;
    overflow-y: auto;
    background: var(--bg-primary);
    border-radius: 8px;
    position: relative;
}

.metro-timeline-wrapper {
    display: flex;
    min-width: max-content;
    padding: 2rem;
}

.metro-characters-column {
    flex: 0 0 180px;
    padding-right: 1rem;
    border-right: 2px solid var(--border-color);
    position: sticky;
    left: 0;
    background: var(--bg-primary);
    z-index: 10;
}

.metro-character-row {
    height: 60px;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem;
    border-radius: 4px;
    margin-bottom: 4px;
    cursor: pointer;
    transition: background 0.2s;
}

.metro-character-row:hover {
    background: var(--bg-secondary);
}

.metro-character-color {
    width: 24px;
    height: 24px;
    border-radius: 50%;
    border: 3px solid white;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    cursor: pointer;
    transition: transform 0.2s;
}

.metro-character-color:hover {
    transform: scale(1.2);
}

.metro-character-name {
    font-size: 0.85rem;
    font-weight: 600;
    color: var(--text-primary);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 120px;
}

.metro-events-area {
    flex: 1;
    position: relative;
    min-width: 600px;
}

.metro-svg-container {
    display: block;
    min-height: 400px;
}

.metro-timeline-container svg {
    display: block;
}

.metro-event-node {
    cursor: pointer;
    transition: all 0.2s;
}

.metro-event-node:hover circle {
    r: 14;
}

.metro-event-node:hover .metro-event-label {
    font-weight: 700;
}

.metro-event-label {
    font-size: 11px;
    fill: var(--text-primary);
    pointer-events: none;
}

.metro-line {
    fill: none;
    stroke-width: 4;
    stroke-linecap: round;
    stroke-linejoin: round;
}

.metro-toolbar {
    display: flex;
    gap: 0.5rem;
    flex-wrap: wrap;
    margin-bottom: 1rem;
    padding: 1rem;
    background: var(--bg-secondary);
    border-radius: 8px;
}

.metro-toolbar .btn {
    font-size: 0.85rem;
    padding: 0.5rem 1rem;
}

/* Metro Event Modal */
.metro-event-form {
    display: flex;
    flex-direction: column;
    gap: 1rem;
}

.metro-characters-selector {
    max-height: 200px;
    overflow-y: auto;
    border: 1px solid var(--border-color);
    border-radius: 4px;
    padding: 0.5rem;
}

.metro-char-option {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem;
    border-radius: 4px;
    cursor: pointer;
    transition: background 0.2s;
}

.metro-char-option:hover {
    background: var(--bg-secondary);
}

.metro-char-option.selected {
    background: var(--accent-blue-light, #e3f2fd);
    border: 1px solid var(--accent-blue);
}

.metro-char-option input[type="checkbox"] {
    margin: 0;
}

.metro-char-color-dot {
    width: 16px;
    height: 16px;
    border-radius: 50%;
    flex-shrink: 0;
}

.metro-linked-chars {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    margin-top: 0.5rem;
}

.metro-linked-char-tag {
    display: inline-flex;
    align-items: center;
    gap: 0.25rem;
    padding: 0.25rem 0.5rem;
    border-radius: 12px;
    font-size: 0.8rem;
    color: white;
}

.metro-linked-char-tag .remove-char {
    cursor: pointer;
    opacity: 0.8;
    margin-left: 0.25rem;
}

.metro-linked-char-tag .remove-char:hover {
    opacity: 1;
}

.metro-empty-state {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 400px;
    color: var(--text-muted);
    text-align: center;
    padding: 2rem;
}

.metro-empty-state i {
    font-size: 4rem;
    margin-bottom: 1rem;
    opacity: 0.3;
}

.metro-legend {
    display: flex;
    flex-wrap: wrap;
    gap: 1rem;
    padding: 1rem;
    background: var(--bg-secondary);
    border-radius: 8px;
    margin-top: 1rem;
}

.metro-legend-item {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.85rem;
}

.metro-legend-line {
    width: 30px;
    height: 4px;
    border-radius: 2px;
}

/* Metro Events Sortable List */
.metro-events-sortable {
    display: flex;
    flex-direction: column;
    gap: 4px;
}

.metro-event-item {
    display: flex;
    align-items: stretch;
    background: var(--bg-primary);
    border-radius: 4px;
    font-size: 0.85rem;
    cursor: grab;
    transition: all 0.2s;
    border: 2px solid transparent;
}

.metro-event-item:hover {
    border-color: var(--border-color);
}

.metro-event-item.dragging {
    opacity: 0.5;
    cursor: grabbing;
}

.metro-event-item.drag-over {
    border-color: var(--accent-blue);
    background: var(--accent-blue-light, #e3f2fd);
}

.metro-event-reorder-btns {
    display: flex;
    flex-direction: column;
    gap: 2px;
    padding: 0.25rem;
}

.metro-reorder-btn {
    width: 22px;
    height: 22px;
    border: none;
    background: var(--bg-secondary);
    color: var(--text-muted);
    border-radius: 3px;
    cursor: pointer;
    font-size: 10px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.15s;
}

.metro-reorder-btn:hover:not(:disabled) {
    background: var(--accent-blue);
    color: white;
}

.metro-reorder-btn:disabled {
    opacity: 0.3;
    cursor: not-allowed;
}

.metro-event-item-content {
    flex: 1;
    padding: 0.5rem;
    padding-left: 0;
    cursor: pointer;
}

.metro-event-item-content:hover {
    background: var(--bg-secondary);
    border-radius: 0 4px 4px 0;
}

.metro-drop-indicator {
    height: 3px;
    background: var(--accent-blue);
    border-radius: 2px;
    margin: 2px 0;
}

/* Plot Graph Styles */
.plot-graph {
    width: 100%;
    height: 100%;
    padding: 2rem;
}

.plot-legend {
    position: absolute;
    top: 2rem;
    right: 2rem;
    background: white;
    border: 1px solid var(--border-color);
    border-radius: 4px;
    padding: 1rem;
    box-shadow: 0 4px 12px var(--shadow);
}

/* Map Styles */
.world-map-container {
    width: 100%;
    height: 100%;
    position: relative;
    overflow: auto;
    background: #f0e6d2;
    background-image:
        repeating-linear-gradient(0deg, transparent, transparent 20px, rgba(0, 0, 0, 0.03) 20px, rgba(0, 0, 0, 0.03) 21px),
        repeating-linear-gradient(90deg, transparent, transparent 20px, rgba(0, 0, 0, 0.03) 20px, rgba(0, 0, 0, 0.03) 21px);
}

.world-map {
    min-width: 100%;
    min-height: 100%;
    position: relative;
    cursor: grab;
}

.world-map:active {
    cursor: grabbing;
}

.map-location {
    position: absolute;
    width: 40px;
    height: 40px;
    background: var(--accent-red);
    border: 3px solid white;
    border-radius: 50% 50% 50% 0;
    transform: rotate(-45deg);
    cursor: pointer;
    box-shadow: 0 4px 12px var(--shadow);
    transition: all 0.2s ease;
}

.map-location:hover {
    transform: rotate(-45deg) scale(1.2);
    z-index: 100;
}

.map-location::after {
    content: attr(data-label);
    position: absolute;
    top: 45px;
    left: 50%;
    transform: translateX(-50%) rotate(45deg);
    background: white;
    padding: 0.25rem 0.5rem;
    border-radius: 4px;
    font-size: 0.85rem;
    font-weight: 600;
    white-space: nowrap;
    box-shadow: 0 2px 8px var(--shadow);
    opacity: 0;
    transition: opacity 0.2s ease;
}

.map-location:hover::after {
    opacity: 1;
}

.map-upload-zone {
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    border: 3px dashed var(--border-color);
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.2s ease;
}

.map-upload-zone:hover {
    border-color: var(--accent-gold);
    background: rgba(212, 175, 55, 0.05);
}

.map-upload-icon {
    font-size: 4rem;
    margin-bottom: 1rem;
    opacity: 0.5;
}

.map-uploaded-image {
    max-width: 100%;
    max-height: 100%;
    object-fit: contain;
}

/* Toolbar pour les visualisations */
.visualization-toolbar {
    display: flex;
    gap: 0.5rem;
    margin-bottom: 1rem;
    flex-wrap: wrap;
    padding: 1rem;
    background: var(--bg-secondary);
    border-radius: 4px;
}

.viz-tool-btn {
    padding: 0.5rem 1rem;
    background: var(--primary-color);
    color: white;
    border: 1px solid var(--border-color);
    border-radius: 4px;
    cursor: pointer;
    font-family: 'Crimson Pro', serif;
    font-size: 0.9rem;
    transition: all 0.2s ease;
}

.viz-tool-btn:hover {
    background: var(--accent-gold);
    color: var(--bg-secondary);
    border-color: var(--accent-gold);
}

.viz-tool-btn.active {
    background: var(--accent-gold);
    color: var(--bg-secondary);
    border-color: var(--accent-gold);
}

/* ========================================
           RESPONSIVE DESIGN - MOBILE & TABLET
           ======================================== */

/* Mobile Menu Handle (poignée latérale) */
/* Mobile Menu Handle (poignée latérale) - Style blanc épuré */
.mobile-menu-handle {
    display: none;
    position: fixed;
    top: 50%;
    left: 0;
    transform: translateY(-50%);
    width: 24px;
    height: 100px;
    background: white;
    border-radius: 0 12px 12px 0;
    cursor: pointer;
    z-index: 10003;
    transition: all 0.3s ease;
    box-shadow: 2px 0 12px rgba(0, 0, 0, 0.15);
    border: 1px solid rgba(0, 0, 0, 0.1);
    border-left: none;
}

.mobile-menu-handle::before {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 2px;
    height: 50px;
    background: linear-gradient(to bottom,
            rgba(0, 0, 0, 0.1) 0%,
            rgba(0, 0, 0, 0.3) 50%,
            rgba(0, 0, 0, 0.1) 100%);
    border-radius: 1px;
}

.mobile-menu-handle::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 8px;
    height: 8px;
    background: rgba(0, 0, 0, 0.2);
    border-radius: 50%;
}

.mobile-menu-handle:active {
    transform: translateY(-50%) translateX(6px);
    box-shadow: 1px 0 8px rgba(0, 0, 0, 0.1);
}

.mobile-menu-handle.hidden {
    opacity: 0;
    pointer-events: none;
}

.mobile-menu-toggle:active {
    transform: scale(0.95);
}

/* Mobile Navigation Dropdown */
.mobile-nav-dropdown {
    display: none;
    position: fixed;
    top: 56px;
    left: 0;
    right: 0;
    background: var(--bg-secondary);
    border-bottom: 2px solid var(--accent-gold);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    z-index: 9999;
    max-height: 0;
    overflow: hidden;
    transition: max-height 0.3s ease;
}

.mobile-nav-dropdown.active {
    max-height: 80vh;
    overflow-y: auto;
}

.mobile-nav-section {
    padding: 0.75rem 1rem;
    border-bottom: 1px solid var(--border-color);
}

.mobile-nav-section-title {
    font-size: 0.75rem;
    font-weight: 600;
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 0.5rem;
}

.mobile-nav-item {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    padding: 0.75rem;
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.2s ease;
    font-size: 1rem;
    color: var(--text-primary);
    background: transparent;
    border: none;
    width: 100%;
    text-align: left;
}

.mobile-nav-item:active {
    background: var(--accent-gold);
    color: white;
}

.mobile-nav-item.active {
    background: var(--accent-gold);
    color: white;
    font-weight: 600;
}

.mobile-nav-item-icon {
    font-size: 1.3rem;
    width: 28px;
    text-align: center;
}

.mobile-nav-toggle-btn {
    display: none;
    position: absolute;
    right: 1rem;
    top: 50%;
    transform: translateY(-50%);
    background: var(--accent-gold);
    color: white;
    border: none;
    border-radius: 6px;
    width: 36px;
    height: 36px;
    font-size: 1.2rem;
    cursor: pointer;
    z-index: 1001;
}

.mobile-nav-toggle-btn:active {
    opacity: 0.7;
}

/* Collapsible Editor Toolbar on Mobile */
.toolbar-mobile-toggle {
    display: none;
    width: 100%;
    padding: 0.5rem;
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 6px;
    font-size: 0.9rem;
    color: var(--text-primary);
    cursor: pointer;
    margin-bottom: 0.5rem;
    text-align: center;
    font-weight: 600;
}

.toolbar-mobile-toggle:active {
    background: var(--accent-gold);
    color: white;
}

/* Mobile Sidebar Overlay */
.sidebar-overlay {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.5);
    z-index: 10001;
    opacity: 0;
    transition: opacity 0.3s ease;
}

.sidebar-overlay.active {
    opacity: 1;
}

/* Tablet styles (landscape phones and portrait tablets) */
@media (max-width: 1024px) {
    .app-header {
        padding: 0 1rem;
        gap: 1rem;
    }

    .app-logo {
        font-size: 1.1rem;
    }

    .header-nav {
        gap: 0.25rem;
    }

    .nav-btn {
        padding: 0.5rem 0.75rem;
        font-size: 0.85rem;
    }

    .header-actions {
        gap: 0.25rem;
    }

    .header-action-btn {
        width: 36px;
        height: 36px;
        font-size: 1.1rem;
    }

    .app-container {
        grid-template-columns: 240px 1fr;
    }

    .sidebar {
        width: 240px;
    }

    .modal-content {
        max-width: 90%;
        margin: 2rem auto;
    }

    /* Masquer le texte des boutons scene-tools sur tablette */
    .scene-tool-btn span:not(.scene-tool-badge) {
        display: none;
    }
}

/* Force mobile nav quand le header déborde */
body.force-mobile-nav .header-nav {
    display: none !important;
}

body.force-mobile-nav .mobile-nav-toggle-btn {
    display: block !important;
}

body.force-mobile-nav .mobile-nav-dropdown {
    display: block !important;
}

body.force-mobile-nav #headerStatsContainer {
    display: none !important;
}

body.force-mobile-nav .header-actions {
    gap: 0.35rem;
    margin-right: 3.5rem !important;
}

body.force-mobile-nav .split-mode-toggle span {
    display: none;
}

/* Mobile styles (phones) */
/* ============================================ */
/* RESPONSIVE - MOBILE FIRST */
/* ============================================ */

/* MOBILE (< 900px) */
@media (max-width: 900px) {

    /* Layout Mobile */
    .app-content {
        flex-direction: column;
    }

    /* Sidebar versions en overlay sur mobile */
    .sidebar-versions {
        position: fixed !important;
        top: 0 !important;
        right: 0 !important;
        bottom: 0 !important;
        left: 0 !important;
        width: 100% !important;
        height: 100% !important;
        z-index: 10000 !important;
        background: var(--bg-primary) !important;
        transform: translateX(100%);
        transition: transform 0.3s ease;
    }

    .sidebar-versions:not(.hidden) {
        transform: translateX(0);
    }

    .sidebar-versions.hidden {
        display: block !important;
        transform: translateX(100%);
    }

    .sidebar-versions {
        padding-bottom: calc(60px + env(safe-area-inset-bottom, 20px));
    }

    .sidebar-versions-header {
        padding: 1rem;
        border-bottom: 2px solid var(--primary-color);
    }

    .sidebar-versions-toggle {
        font-size: 1.5rem;
        padding: 0.5rem;
    }

    /* Header Mobile */
    .app-header {
        height: 56px;
        padding: 0 1rem;
        gap: 1rem;
    }

    .app-logo {
        font-size: 1.1rem;
    }

    .app-logo-icon {
        font-size: 1.3rem;
    }

    /* Cacher navigation desktop */
    .header-nav {
        display: none !important;
    }

    /* Afficher toggle navigation mobile */
    .mobile-nav-toggle-btn {
        display: block;
    }

    /* Afficher le bouton ✏️ flottant en mobile */
    #floatingEditorToggle {
        display: flex !important;
    }

    /* Afficher la poignée latérale sur mobile */
    .mobile-menu-handle {
        display: block;
    }

    .mobile-nav-dropdown {
        display: block;
    }

    /* Cacher stats et boutons secondaires sur mobile */
    #headerStatsContainer,
    #headerUndoBtn,
    #headerRedoBtn,
    #storage-badge,
    #pomodoroHeaderBtn {
        display: none !important;
    }

    /* Header actions mobile - compacts et alignés */
    .header-actions {
        gap: 0.35rem;
        margin-left: auto;
        margin-right: 3.5rem !important;
    }

    .header-action-btn {
        width: 32px;
        height: 32px;
        padding: 0;
        font-size: 0.9rem;
    }

    /* Split toggle plus compact sur mobile */
    .split-mode-toggle {
        padding: 0.35rem 0.6rem;
        font-size: 0.75rem;
        gap: 0.25rem;
    }

    .split-mode-toggle span {
        display: none;
    }

    /* Logo plus compact */
    .app-logo {
        font-size: 0.95rem;
        max-width: 140px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
    }

    .app-logo-icon {
        font-size: 1.1rem;
        flex-shrink: 0;
    }

    /* Sidebar Mobile - en overlay */
    .sidebar {
        position: fixed;
        top: 56px;
        left: -100%;
        width: 85%;
        max-width: 320px;
        height: calc(100vh - 56px);
        z-index: 10002;
        transition: left 0.3s ease;
        box-shadow: 2px 0 12px rgba(0, 0, 0, 0.2);
        background: var(--bg-secondary);
        overflow-y: auto;
        padding-bottom: calc(60px + env(safe-area-inset-bottom, 20px));
    }

    .sidebar.mobile-open {
        left: 0;
    }

    /* Padding pour les listes de la sidebar sur mobile */
    .chapters-list,
    .database-list {
        padding-bottom: calc(80px + env(safe-area-inset-bottom, 20px));
    }

    .sidebar-actions {
        padding-bottom: calc(1rem + env(safe-area-inset-bottom, 20px));
    }

    /* Sidebar Structure - Optimisation mobile */
    .status-filters {
        padding: 0.3rem 0.5rem;
        gap: 0.25rem;
        flex-wrap: wrap;
    }

    .status-filter-btn {
        padding: 0.2rem 0.4rem;
        font-size: 0.6rem;
        gap: 0.15rem;
    }

    .status-filter-btn span:not(.status-filter-dot):not(.status-filter-count) {
        display: none;
        /* Cacher le texte, garder seulement le point et le count */
    }

    .status-filter-dot {
        width: 6px;
        height: 6px;
    }

    .status-filter-count {
        font-size: 0.55rem;
        padding: 0 0.2rem;
    }

    .scene-tools {
        padding: 0.3rem 0.5rem;
        gap: 0.25rem;
        flex-wrap: wrap;
    }

    .scene-tool-btn {
        padding: 0.25rem 0.4rem;
        font-size: 0.65rem;
        gap: 0.2rem;
    }

    .scene-tool-btn span {
        display: none;
    }

    .scene-tool-btn i {
        width: 14px !important;
        height: 14px !important;
    }

    .tree-collapse-toolbar {
        padding: 0.2rem 0.5rem;
        gap: 0.15rem;
    }

    .tree-collapse-btn {
        padding: 0.15rem 0.35rem;
        font-size: 0.6rem;
        gap: 0.15rem;
    }

    /* Treeview ULTRA compact sur mobile */
    .act-group {
        margin-bottom: 0.1rem;
    }

    .act-header {
        padding: 0.15rem 0.3rem;
        font-size: 0.7rem;
        gap: 0.15rem;
        min-height: 24px;
    }

    .act-icon {
        width: 14px;
        height: 14px;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .act-title {
        font-size: 0.65rem;
    }

    .act-chapters {
        padding-left: 0.15rem;
    }

    .chapter-group {
        margin-bottom: 0;
    }

    .chapter-header {
        padding: 0.1rem 0.3rem;
        font-size: 0.65rem;
        gap: 0.15rem;
        min-height: 22px;
    }

    .chapter-icon {
        width: 12px;
        height: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .chapter-title {
        font-size: 0.65rem;
    }

    .scenes-list {
        padding-left: 0.4rem;
    }

    .scene-item {
        padding: 0.08rem 0.3rem;
        font-size: 0.65rem;
        gap: 0.15rem;
        min-height: 20px;
    }

    .auto-number {
        font-size: 0.5rem;
        min-width: 20px;
        margin-right: 0.1rem;
    }

    .word-count-badge {
        font-size: 0.45rem;
        padding: 0 0.15rem;
    }

    .status-badge {
        width: 6px;
        height: 6px;
    }

    .drag-handle {
        padding: 0 0.1rem;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .drag-handle i {
        width: 10px !important;
        height: 10px !important;
    }

    .delete-btn {
        width: 14px !important;
        height: 14px !important;
        font-size: 0.6rem !important;
        padding: 0 !important;
    }

    .edit-hint {
        display: none;
    }

    .chapter-count {
        font-size: 0.5rem;
    }

    /* Barre de progression mobile */
    .sidebar-progress-info {
        padding: 0.25rem 0.5rem;
        font-size: 0.6rem;
    }

    /* Search bar mobile */
    .search-container {
        padding: 0.3rem 0.5rem;
        margin-bottom: 0.5rem;
    }

    .search-container input {
        padding: 0.35rem 0.5rem;
        font-size: 0.75rem;
    }

    /* Stats overview compact */
    .stats-overview {
        padding: 0.5rem;
        margin-bottom: 0.5rem;
    }

    .stats-overview .stat-group {
        gap: 0.25rem;
    }

    .stats-overview .stat-badge {
        padding: 0.15rem 0.4rem;
        font-size: 0.7rem;
    }

    /* Toolbar collapse buttons compact */
    .tree-collapse-toolbar {
        padding: 0.25rem 0.5rem;
        margin-bottom: 0.25rem;
    }

    .tree-collapse-btn {
        padding: 0.25rem 0.5rem;
        font-size: 0.75rem;
        gap: 0.25rem;
    }

    /* Sidebar actions mobile compact */
    .sidebar-actions .btn {
        padding: 0.4rem 0.6rem;
        font-size: 0.7rem;
    }

    /* Editor full width */
    .editor-container {
        width: 100%;
    }

    /* Toolbar Desktop - masqué et remplacé par bouton toggle */
    .toolbar-mobile-toggle {
        display: block;
        width: 100%;
        padding: 12px;
        background: white;
        border: none;
        border-bottom: 1px solid var(--border-color);
        color: var(--text-primary);
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        text-align: center;
        transition: all 0.2s ease;
    }

    .toolbar-mobile-toggle:active {
        background: var(--bg-secondary);
    }

    .toolbar-mobile-toggle .toggle-icon {
        display: inline-block;
        transition: transform 0.3s ease;
        margin-left: 0.5rem;
    }

    .toolbar-mobile-toggle.expanded .toggle-icon {
        transform: rotate(180deg);
    }

    /* Toolbar collapsible */
    .editor-toolbar {
        max-height: 0 !important;
        overflow: hidden !important;
        transition: max-height 0.3s ease;
        padding: 0 !important;
        border-bottom: none !important;
    }

    .editor-toolbar.expanded {
        max-height: 500px !important;
        overflow-y: auto !important;
        overflow-x: hidden !important;
        padding: 12px !important;
        border-bottom: 1px solid var(--border-color) !important;
        flex-wrap: wrap !important;
    }

    /* Menu flottant mobile visible */
    #floatingEditorToggle {
        display: flex;
    }

    /* Editor content */
    .editor-content {
        padding: 1.5rem;
    }

    .editor-textarea {
        font-size: 1rem;
        line-height: 1.7;
    }

    /* Editor header mobile */
    .editor-header {
        padding: 1rem 1rem 0.75rem;
    }

    .editor-breadcrumb {
        font-size: 0.75rem;
        margin-bottom: 0.5rem;
    }

    .editor-title {
        font-size: 1.4rem;
    }

    .editor-meta {
        flex-wrap: wrap;
        gap: 0.5rem 1rem;
        font-size: 0.75rem;
    }

    /* Bouton Focus plus compact */
    .editor-header .btn-small,
    .editor-header .btn {
        padding: 0.4rem 0.6rem;
        font-size: 0.75rem;
    }

    /* Links panel toggle - comme toolbar */
    .links-panel-toggle {
        display: block;
        width: 100%;
        padding: 12px;
        background: white;
        border: none;
        border-bottom: 1px solid var(--border-color);
        color: var(--text-primary);
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        text-align: center;
        transition: all 0.2s ease;
    }

    .links-panel-toggle:active {
        background: var(--bg-secondary);
    }

    /* Links panel collapsible - comme toolbar */
    #linksPanel {
        max-height: 0;
        overflow: hidden;
        transition: max-height 0.3s ease;
        padding: 0 1rem;
        border-bottom: none;
    }

    #linksPanel.expanded {
        max-height: 500px;
        overflow-y: auto;
        padding: 0.75rem 1rem;
        border-bottom: 1px solid var(--border-color);
    }

    .links-panel-sticky>div {
        flex-direction: column;
        gap: 0.75rem !important;
    }

    .quick-links {
        flex-wrap: wrap;
        gap: 0.4rem;
    }

    .link-badge {
        font-size: 0.75rem;
        padding: 0.25rem 0.5rem;
    }

    /* Modals */
    .modal-content {
        width: 95%;
        max-width: 95%;
        margin: 1rem;
        max-height: 90vh;
    }

    /* Boutons */
    .btn {
        padding: 0.7rem 1rem;
        font-size: 15px;
        touch-action: manipulation;
    }

    /* Formulaires */
    .form-input,
    .form-textarea {
        font-size: 16px;
        /* Évite le zoom sur iOS */
    }

    /* Storage badge */
    .storage-badge {
        bottom: 60px;
        right: 15px;
        font-size: 11px;
        min-width: 80px;
        min-height: 40px;
        padding: 8px 12px;
    }
}

/* TABLETTE (901px - 1024px) */
@media (min-width: 901px) and (max-width: 1024px) {
    .app-content {
        display: flex;
        flex-direction: row;
    }

    .sidebar {
        position: static !important;
        left: auto !important;
        width: 240px !important;
        max-width: 240px !important;
        height: auto !important;
        z-index: auto !important;
        transition: none !important;
        display: flex !important;
        flex-shrink: 0;
    }

    .mobile-menu-handle,
    .sidebar-overlay {
        display: none !important;
    }

    .editor-content {
        padding: 2rem;
    }

    .app-header {
        padding: 0 1.5rem;
    }

    .editor-toolbar {
        padding: 8px 12px;
        flex-wrap: wrap;
    }
}

/* DESKTOP (> 1024px) */
@media (min-width: 1025px) {

    /* Masquer les éléments mobile */
    .mobile-nav-toggle-btn,
    .mobile-nav-dropdown,
    .toolbar-mobile-toggle,
    #floatingEditorToggle,
    #floatingEditorMenu,
    .mobile-menu-handle,
    .sidebar-overlay {
        display: none !important;
    }

    /* Afficher navigation desktop */
    .header-nav {
        display: flex !important;
    }

    /* Toolbar toujours visible */
    .editor-toolbar {
        /*display: flex !important;*/
        max-height: none !important;
        flex-wrap: wrap !important;
    }

    /* SIDEBAR DESKTOP - CRITIQUE */
    .sidebar {
        position: static !important;
        left: auto !important;
        width: 350px !important;
        max-width: 350px !important;
        height: auto !important;
        z-index: auto !important;
        transition: none !important;
        display: flex !important;
    }

    /* Grid layout desktop */
    .app-container {
        grid-template-columns: 350px 1fr !important;
        grid-template-areas:
            "header header"
            "sidebar main" !important;
    }
}

/* GRAND ÉCRAN (> 1440px) */
@media (min-width: 1441px) {
    .editor-content {
        max-width: 850px;
    }
}

/* Styles additionnels pour mobile (900px) - storage badge */
@media (max-width: 900px) {
    .storage-badge {
        bottom: 15px;
        right: 15px;
        padding: 10px 15px;
        font-size: 12px;
        min-width: 100px;
        min-height: 44px;
        z-index: 10001;
    }

    /* Scene metadata */
    .scene-metadata {
        flex-direction: column;
        gap: 0.75rem;
    }

    .metadata-item {
        width: 100%;
    }

    /* Character and element links */
    .scene-links {
        flex-direction: column;
    }

    .link-group {
        width: 100%;
    }

    /* Content editor */
    #sceneContent {
        font-size: 1rem;
        line-height: 1.6;
        padding: 1rem;
    }

    /* Sidebar actions */
    .sidebar-actions {
        flex-direction: row;
        gap: 0.25rem;
        padding: 0.5rem;
    }

    .sidebar-actions .btn {
        width: 33.333%;
        flex: 1;
        font-size: 0.8rem;
        padding: 0.5rem 0.25rem;
        white-space: nowrap;
    }

    /* Modals */
    .modal-content {
        width: 95%;
        max-width: 95%;
        margin: 1rem auto;
        max-height: 90vh;
        overflow-y: auto;
    }

    .modal-title {
        font-size: 1.3rem;
    }

    /* Boutons dans les modals - empiler verticalement sur mobile */
    .modal-button-group {
        flex-direction: column;
    }

    .modal-button-group .btn {
        width: 100%;
        min-width: unset;
        margin: 0;
    }

    .modal-button-group .btn+.btn {
        margin-top: 0.75rem;
    }

    .modal-content>div>.btn {
        display: block;
        width: 100%;
        margin: 0.5rem 0;
    }

    /* Forms */
    .form-input,
    .form-textarea {
        font-size: 16px;
        /* Prevents zoom on iOS */
    }

    /* Buttons */
    .btn {
        padding: 0.65rem 1rem;
        font-size: 0.95rem;
        touch-action: manipulation;
        -webkit-tap-highlight-color: transparent;
    }

    .btn-small {
        padding: 0.4rem 0.6rem;
        font-size: 0.85rem;
    }

    /* Stats cards */
    .stats-cards {
        grid-template-columns: 1fr;
        gap: 1rem;
    }

    /* Character/World cards */
    .character-card,
    .world-card {
        padding: 1rem;
    }

    /* Act/Chapter structure */
    .act-header,
    .chapter-header {
        padding: 0.5rem 0.75rem;
        min-height: unset;
    }

    .act-title,
    .chapter-title {
        font-size: 0.9rem;
        line-height: 1.3;
    }

    .scene-item {
        padding: 0.45rem 0.75rem;
        font-size: 0.85rem;
        min-height: unset;
        line-height: 1.3;
    }

    /* Reduce spacing in act/chapter groups */
    .act-group {
        margin-bottom: 0.5rem;
    }

    .chapter-group {
        margin-bottom: 0.25rem;
    }

    /* Compact word count badges */
    .word-count-badge {
        font-size: 0.7rem;
        padding: 0.15rem 0.4rem;
    }

    /* Compact status badges */
    .status-badge {
        width: 6px;
        height: 6px;
    }

    /* Compact chapter count */
    .chapter-count {
        font-size: 0.7rem;
        padding: 0.15rem 0.35rem;
    }

    /* Empty state */
    .empty-state {
        padding: 2rem 1rem;
    }

    .empty-state-icon {
        font-size: 3rem;
    }

    .empty-state-title {
        font-size: 1.3rem;
    }

    /* Timeline visualization */
    .timeline-item {
        padding: 1rem;
    }

    /* Cork board */
    .cork-card {
        min-width: 200px;
        font-size: 0.9rem;
    }

    /* Search */
    .search-input {
        font-size: 0.95rem;
        padding: 0.65rem 2.5rem 0.65rem 1rem;
    }

    /* Tabs */
    .tabs {
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
    }

    .tab-btn {
        flex-shrink: 0;
        padding: 0.6rem 1rem;
        font-size: 0.9rem;
    }
}

/* Small mobile phones */
@media (max-width: 480px) {
    .app-header {
        height: 52px;
        padding: 0 0.5rem;
    }

    .app-logo {
        font-size: 0.9rem;
    }

    .app-logo-icon {
        font-size: 1.1rem;
    }

    .nav-btn {
        padding: 0.35rem 0.5rem;
        font-size: 0.95rem;
    }

    .header-action-btn {
        width: 32px;
        height: 32px;
        font-size: 0.95rem;
    }

    .sidebar {
        width: 90%;
        max-width: 280px;
        top: 52px;
        height: calc(100vh - 52px);
    }

    .app-container {
        grid-template-rows: 52px 1fr;
    }

    .scene-editor {
        padding: 0.75rem;
    }

    .scene-title {
        font-size: 1.3rem;
    }

    #sceneContent {
        font-size: 0.95rem;
        padding: 0.75rem;
    }

    .mobile-menu-toggle {
        width: 52px;
        height: 52px;
        font-size: 1.3rem;
        bottom: 16px;
        right: 16px;
    }

    .modal-content {
        width: 98%;
        margin: 0.5rem auto;
        padding: 1rem;
    }

    .modal-title {
        font-size: 1.2rem;
    }

    .btn {
        padding: 0.6rem 0.85rem;
        font-size: 0.9rem;
    }
}

/* Landscape orientation on phones */
@media (max-width: 900px) and (orientation: landscape) {
    .app-header {
        height: 48px;
    }

    .sidebar {
        top: 48px;
        height: calc(100vh - 48px);
    }

    .app-container {
        grid-template-rows: 48px 1fr;
    }

    .modal-content {
        max-height: 85vh;
    }

    .mobile-menu-toggle {
        width: 48px;
        height: 48px;
        bottom: 12px;
        right: 12px;
    }
}

/* iOS specific fixes */
@supports (-webkit-touch-callout: none) {

    /* iOS safe area insets */
    .app-header {
        padding-top: max(env(safe-area-inset-top), 0px);
    }

    .sidebar {
        padding-bottom: max(env(safe-area-inset-bottom), 0px);
    }

    .mobile-menu-toggle {
        bottom: max(env(safe-area-inset-bottom, 20px) + 20px, 20px);
        right: max(env(safe-area-inset-right, 20px) + 20px, 20px);
    }

    /* Prevent elastic scrolling on body */
    body {
        position: fixed;
        width: 100%;
    }

    /* Fix textarea font size to prevent zoom */
    input,
    textarea,
    select {
        font-size: 16px !important;
    }
}

/* Android Chrome specific */
@media screen and (-webkit-min-device-pixel-ratio: 0) {

    select,
    textarea,
    input {
        font-size: 16px;
    }
}

/* High DPI screens */
@media (-webkit-min-device-pixel-ratio: 2),
(min-resolution: 192dpi) {
    .app-header {
        border-bottom-width: 1px;
    }
}

/* Dark mode support (if device prefers dark) */
@media (prefers-color-scheme: dark) {
    /* This is ready for future dark mode implementation */
}

/* Reduced motion for accessibility */
@media (prefers-reduced-motion: reduce) {

    *,
    *::before,
    *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
    }
}

/* Touch device optimizations */
@media (hover: none) and (pointer: coarse) {

    /* Larger touch targets */
    .btn,
    .nav-btn,
    .toolbar-btn,
    button {
        min-height: 44px;
        min-width: 44px;
    }

    /* Remove hover effects on touch devices */
    .btn:hover,
    .nav-btn:hover,
    .toolbar-btn:hover {
        transform: none;
    }

    /* Add active state feedback */
    .btn:active,
    .nav-btn:active,
    .toolbar-btn:active {
        opacity: 0.7;
    }
}
/* ========== 12.arc-board.css ========== */
/* ============================================
   ARC BOARD - Canvas Style (Milanote-inspired)
   ============================================ */

/* ============================================
   SIDEBAR TREEVIEW
   ============================================ */

.sidebar-tree-category {
    margin-bottom: 4px;
}

.sidebar-tree-header {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 12px;
    cursor: pointer;
    border-radius: 6px;
    transition: background 0.15s ease;
}

.sidebar-tree-header:hover {
    background: var(--bg-secondary);
}

.sidebar-tree-toggle {
    width: 16px;
    height: 16px;
    display: flex;
    align-items: center;
    justify-content: center;
    color: var(--text-muted);
}

.sidebar-tree-toggle svg {
    width: 14px;
    height: 14px;
}

.sidebar-tree-icon {
    width: 18px;
    height: 18px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.sidebar-tree-icon svg {
    width: 16px;
    height: 16px;
}

.sidebar-tree-label {
    flex: 1;
    font-family: 'Inter', sans-serif;
    font-size: 13px;
    font-weight: 500;
    color: var(--text-primary);
}

.sidebar-tree-count {
    font-family: 'Inter', sans-serif;
    font-size: 11px;
    color: var(--text-muted);
    background: var(--bg-tertiary);
    padding: 2px 6px;
    border-radius: 10px;
}

.sidebar-tree-children {
    margin-left: 24px;
    overflow: hidden;
    transition: max-height 0.3s ease;
}

.sidebar-tree-children.collapsed {
    max-height: 0;
    opacity: 0;
}

.sidebar-tree-item {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 6px 12px;
    cursor: pointer;
    border-radius: 6px;
    transition: background 0.15s ease;
    margin-bottom: 2px;
}

.sidebar-tree-item:hover {
    background: var(--bg-secondary);
}

.sidebar-tree-item.active {
    background: var(--primary-color);
}

.sidebar-tree-item.active .sidebar-tree-item-title {
    color: white;
}

.sidebar-tree-item.active .sidebar-tree-item-menu {
    color: rgba(255, 255, 255, 0.7);
}

.sidebar-tree-item-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    flex-shrink: 0;
}

.sidebar-tree-item-title {
    flex: 1;
    font-family: 'Inter', sans-serif;
    font-size: 13px;
    color: var(--text-primary);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.sidebar-tree-item-menu {
    width: 24px;
    height: 24px;
    border: none;
    background: transparent;
    border-radius: 4px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    color: var(--text-muted);
    opacity: 0;
    transition: opacity 0.15s ease;
}

.sidebar-tree-item:hover .sidebar-tree-item-menu {
    opacity: 1;
}

.sidebar-tree-item-menu:hover {
    background: var(--bg-tertiary);
    color: var(--text-primary);
}

.sidebar-tree-item-menu svg {
    width: 14px;
    height: 14px;
}

.sidebar-tree-add {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 10px 12px;
    cursor: pointer;
    color: var(--text-muted);
    font-family: 'Inter', sans-serif;
    font-size: 13px;
    border-radius: 6px;
    margin-top: 8px;
    border: 1px dashed var(--border-color);
    transition: all 0.15s ease;
}

.sidebar-tree-add:hover {
    background: var(--bg-secondary);
    border-color: var(--primary-color);
    color: var(--primary-color);
}

.sidebar-tree-add svg {
    width: 16px;
    height: 16px;
}

/* Card add button inside column */
.arc-card-add {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
    padding: 12px;
    color: var(--text-muted);
    font-family: 'Inter', sans-serif;
    font-size: 12px;
    cursor: pointer;
    border: 1px dashed var(--border-color);
    border-radius: 6px;
    transition: all 0.15s ease;
    margin-top: 4px;
}

.arc-card-add:hover {
    background: var(--bg-secondary);
    border-color: var(--primary-color);
    color: var(--primary-color);
}

.arc-card-add svg {
    width: 14px;
    height: 14px;
}

/* ============================================
   LAYOUT PRINCIPAL
   ============================================ */

.arc-board-container {
    display: flex;
    flex: 1;
    height: 100%;
    overflow: hidden;
    background: var(--bg-secondary);
}

.arc-board-main {
    display: flex;
    flex-direction: column;
    flex: 1;
    min-width: 0;
    overflow: hidden;
}

.arc-board-body {
    display: flex;
    flex: 1;
    min-height: 0;
    overflow: hidden;
}

/* ============================================
   TOOLBAR GAUCHE (Outils de création)
   ============================================ */

.arc-board-toolbar {
    width: 56px;
    background: var(--bg-primary);
    border-right: 1px solid var(--border-color);
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 12px 0;
    gap: 4px;
    flex-shrink: 0;
    z-index: 100;
}

.arc-toolbar-btn {
    width: 40px;
    height: 40px;
    border: none;
    background: transparent;
    border-radius: 8px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    color: var(--text-secondary);
    transition: all 0.2s ease;
    position: relative;
}

.arc-toolbar-btn:hover {
    background: var(--bg-secondary);
    color: var(--text-primary);
}

.arc-toolbar-btn.active {
    background: var(--primary-color);
    color: white;
}

.arc-toolbar-btn svg {
    width: 20px;
    height: 20px;
}

.arc-toolbar-btn[data-tooltip]::after {
    content: attr(data-tooltip);
    position: absolute;
    left: calc(100% + 8px);
    top: 50%;
    transform: translateY(-50%);
    background: var(--bg-accent);
    color: white;
    padding: 6px 10px;
    border-radius: 6px;
    font-size: 12px;
    font-family: 'Inter', sans-serif;
    white-space: nowrap;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.2s ease;
    z-index: 1000;
}

.arc-toolbar-btn:hover[data-tooltip]::after {
    opacity: 1;
}

.arc-toolbar-separator {
    width: 32px;
    height: 1px;
    background: var(--border-color);
    margin: 8px 0;
}

/* ============================================
   CANVAS PRINCIPAL
   ============================================ */

.arc-board-canvas-wrapper {
    flex: 1;
    position: relative;
    overflow: hidden;
    background: var(--bg-secondary);
}

.arc-board-canvas {
    position: absolute;
    width: 100%;
    height: 100%;
    overflow: auto;
    cursor: grab;
    /* Grille de fond style Milanote */
    background-image:
        radial-gradient(circle, var(--border-color) 1px, transparent 1px);
    background-size: 24px 24px;
    background-position: 0 0;
}

.arc-board-canvas.dragging {
    cursor: grabbing;
}

.arc-board-canvas.connecting {
    cursor: crosshair;
}

.arc-board-content {
    position: relative;
    min-width: 3000px;
    min-height: 2000px;
    padding: 40px;
    transform-origin: 0 0;
}

/* Layer SVG pour les connexions */
.arc-connections-layer {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 2000;
}

.arc-connections-layer svg {
    width: 100%;
    height: 100%;
}

.arc-connection-line {
    stroke: var(--text-muted);
    stroke-width: 2;
    fill: none;
    pointer-events: stroke;
    cursor: pointer;
}

.arc-connection-line:hover {
    stroke: var(--primary-color);
    stroke-width: 3;
}

.arc-connection-line.selected {
    stroke: var(--primary-color);
    stroke-width: 3;
}

.arc-connection-arrow {
    fill: var(--text-muted);
}

.arc-connection-temp {
    stroke: var(--primary-color);
    stroke-width: 2;
    stroke-dasharray: 8 4;
    fill: none;
}

/* ============================================
   COLONNES (Boards)
   ============================================ */

.arc-column {
    position: absolute;
    background: var(--bg-primary);
    border-radius: 12px;
    box-shadow: 0 2px 8px var(--shadow), 0 0 0 1px var(--border-color);
    min-width: 200px;
    max-width: 500px;
    display: flex;
    flex-direction: column;
    z-index: 10;
    transition: box-shadow 0.2s ease;
}

.arc-column:hover {
    box-shadow: 0 4px 16px var(--shadow), 0 0 0 1px var(--border-color);
}

.arc-column.selected {
    box-shadow: 0 4px 16px var(--shadow), 0 0 0 2px var(--primary-color);
}

.arc-column.dragging {
    opacity: 0.9;
    z-index: 1000;
    cursor: grabbing;
}

.arc-column-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 12px 16px;
    border-bottom: 1px solid var(--border-color);
    cursor: grab;
    background: var(--bg-primary);
    border-radius: 12px 12px 0 0;
}

.arc-column-header:active {
    cursor: grabbing;
}

.arc-column-title {
    font-family: 'Inter', sans-serif;
    font-size: 14px;
    font-weight: 600;
    color: var(--text-primary);
    flex: 1;
    border: none;
    background: transparent;
    outline: none;
    padding: 4px 0;
}

.arc-column-title:focus {
    background: var(--bg-secondary);
    padding: 4px 8px;
    margin: -4px -8px;
    border-radius: 4px;
}

.arc-column-meta {
    font-family: 'Inter', sans-serif;
    font-size: 11px;
    color: var(--text-muted);
    margin-left: 8px;
}

.arc-column-arrow {
    color: var(--text-muted);
    margin-left: 12px;
}

.arc-column-arrow svg {
    width: 16px;
    height: 16px;
}

.arc-column-body {
    flex: 1;
    padding: 8px;
    display: flex;
    flex-direction: column;
    gap: 8px;
    overflow-y: auto;
    max-height: 600px;
}

/* Resize handle */
.arc-column-resize {
    position: absolute;
    right: 0;
    top: 0;
    bottom: 0;
    width: 8px;
    cursor: ew-resize;
    background: transparent;
}

.arc-column-resize:hover {
    background: linear-gradient(to right, transparent, rgba(255, 140, 66, 0.2));
}

/* ============================================
   CARTES (Items dans les colonnes)
   ============================================ */

.arc-card {
    background: var(--bg-primary);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 12px 12px 12px 36px;
    /* Extra padding left for drag handle */
    cursor: pointer;
    transition: all 0.2s ease;
    position: relative;
}

.arc-card:hover {
    border-color: var(--primary-color);
    box-shadow: 0 2px 8px var(--shadow);
}

.arc-card.selected {
    border-color: var(--primary-color);
    box-shadow: 0 0 0 2px rgba(255, 140, 66, 0.2);
}

.arc-card.dragging {
    opacity: 0.7;
    transform: rotate(2deg);
}

/* Poignée de drag - visible au hover */
.arc-card-drag-handle {
    position: absolute;
    top: 0;
    left: 0;
    width: 28px;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: grab;
    opacity: 0;
    transition: opacity 0.2s ease, background 0.2s ease;
    background: transparent;
    border-radius: 8px 0 0 8px;
    z-index: 1;
}

.arc-card:hover .arc-card-drag-handle {
    opacity: 1;
    background: linear-gradient(to right, rgba(255, 140, 66, 0.08), transparent);
}

.arc-card-drag-handle:hover {
    background: linear-gradient(to right, rgba(255, 140, 66, 0.15), transparent);
}

.arc-card-drag-handle:active {
    cursor: grabbing;
}

.arc-card-drag-handle svg,
.arc-card-drag-handle i {
    width: 16px;
    height: 16px;
    color: var(--text-muted);
    pointer-events: none;
}

/* Poignée de drag pour les éléments flottants sur le canvas */
.arc-floating-drag-handle {
    position: absolute;
    top: 0;
    left: 0;
    display: flex;
    align-items: center;
    gap: 2px;
    opacity: 0;
    transition: opacity 0.2s ease;
    z-index: 2;
}

.arc-floating-item:hover .arc-floating-drag-handle {
    opacity: 1;
}

.arc-drag-move,
.arc-drag-to-column {
    width: 24px;
    height: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: grab;
    background: rgba(255, 140, 66, 0.12);
    border-radius: 6px;
    transition: background 0.2s ease;
}

.arc-drag-move:hover {
    background: rgba(255, 140, 66, 0.25);
}

.arc-drag-to-column:hover {
    background: rgba(100, 180, 255, 0.25);
}

.arc-drag-move:active,
.arc-drag-to-column:active {
    cursor: grabbing;
}

.arc-drag-move svg,
.arc-drag-move i,
.arc-drag-to-column svg,
.arc-drag-to-column i {
    width: 14px;
    height: 14px;
    color: var(--text-muted);
    pointer-events: none;
}

.arc-drag-to-column i {
    color: var(--accent-color, #64b4ff);
}

/* Bouton de suppression de carte */
.arc-card-delete {
    position: absolute;
    top: 4px;
    right: 4px;
    width: 22px;
    height: 22px;
    border: none;
    background: var(--bg-secondary);
    border-radius: 4px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    color: var(--text-muted);
    opacity: 0;
    transition: all 0.15s ease;
    z-index: 10;
}

.arc-card:hover .arc-card-delete {
    opacity: 1;
}

.arc-card-delete:hover {
    background: var(--error-color);
    color: white;
}

.arc-card-delete svg {
    width: 14px;
    height: 14px;
}

/* Card type: Note/Text */
.arc-card-note .arc-card-content {
    font-family: 'Crimson Pro', serif;
    font-size: 15px;
    line-height: 1.6;
    color: var(--text-primary);
    min-height: 40px;
}

.arc-card-note .arc-card-content:empty::before {
    content: 'Commencez à écrire...';
    color: var(--text-muted);
}

.arc-card-note .arc-card-content[contenteditable="true"]:focus {
    outline: none;
}

/* Card type: Image */
.arc-card-image {
    padding: 0;
    overflow: hidden;
}

.arc-card-image img {
    width: 100%;
    display: block;
    border-radius: 7px;
}

.arc-card-image .arc-card-upload {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 32px 16px;
    color: var(--text-muted);
    gap: 8px;
}

.arc-card-image .arc-card-upload svg {
    width: 32px;
    height: 32px;
    opacity: 0.5;
}

.arc-card-image .arc-card-caption {
    padding: 8px 12px;
    font-family: 'Inter', sans-serif;
    font-size: 12px;
    color: var(--text-secondary);
    border-top: 1px solid var(--border-color);
}

/* Card type: Link */
.arc-card-link {
    padding: 0;
}

.arc-card-link .arc-link-input {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 12px;
    color: var(--text-muted);
}

.arc-card-link .arc-link-input svg {
    width: 16px;
    height: 16px;
    flex-shrink: 0;
}

.arc-card-link .arc-link-input input {
    flex: 1;
    border: none;
    background: transparent;
    font-family: 'Inter', sans-serif;
    font-size: 13px;
    color: var(--text-primary);
    outline: none;
}

.arc-card-link .arc-link-input input::placeholder {
    color: var(--text-muted);
}

.arc-card-link .arc-link-preview {
    display: flex;
    flex-direction: column;
}

.arc-card-link .arc-link-preview-image {
    height: 120px;
    background: var(--bg-secondary);
    background-size: cover;
    background-position: center;
    border-radius: 7px 7px 0 0;
}

.arc-card-link .arc-link-preview-info {
    padding: 12px;
}

.arc-card-link .arc-link-preview-title {
    font-family: 'Inter', sans-serif;
    font-size: 13px;
    font-weight: 500;
    color: var(--text-primary);
    margin-bottom: 4px;
}

.arc-card-link .arc-link-preview-url {
    font-family: 'Inter', sans-serif;
    font-size: 11px;
    color: var(--text-muted);
}

/* Card type: To-do */
.arc-card-todo .arc-card-title {
    font-family: 'Inter', sans-serif;
    font-size: 14px;
    font-weight: 600;
    color: var(--text-primary);
    margin-bottom: 12px;
    border: none;
    background: transparent;
    width: 100%;
    outline: none;
}

.arc-card-todo .arc-todo-list {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.arc-card-todo .arc-todo-item {
    display: flex;
    align-items: flex-start;
    gap: 8px;
}

.arc-card-todo .arc-todo-checkbox {
    width: 18px;
    height: 18px;
    border: 2px solid var(--border-color);
    border-radius: 4px;
    cursor: pointer;
    flex-shrink: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-top: 2px;
    transition: all 0.2s ease;
}

.arc-card-todo .arc-todo-checkbox:hover {
    border-color: var(--primary-color);
}

.arc-card-todo .arc-todo-checkbox.checked {
    background: var(--accent-green);
    border-color: var(--accent-green);
}

.arc-card-todo .arc-todo-checkbox.checked svg {
    color: white;
    width: 12px;
    height: 12px;
}

.arc-card-todo .arc-todo-text {
    flex: 1;
    font-family: 'Inter', sans-serif;
    font-size: 13px;
    color: var(--text-primary);
    border: none;
    background: transparent;
    outline: none;
    line-height: 1.5;
}

.arc-card-todo .arc-todo-text.completed {
    text-decoration: line-through;
    color: var(--text-muted);
}

.arc-card-todo .arc-todo-add {
    display: flex;
    align-items: center;
    gap: 8px;
    color: var(--text-muted);
    font-family: 'Inter', sans-serif;
    font-size: 13px;
    cursor: pointer;
    padding: 4px 0;
    margin-top: 4px;
}

.arc-card-todo .arc-todo-add:hover {
    color: var(--primary-color);
}

.arc-card-todo .arc-todo-assign {
    font-family: 'Inter', sans-serif;
    font-size: 11px;
    color: var(--text-muted);
    border: 1px solid var(--border-color);
    border-radius: 4px;
    padding: 4px 8px;
    background: transparent;
    cursor: pointer;
    margin-top: 8px;
}

.arc-card-todo .arc-todo-assign:hover {
    border-color: var(--primary-color);
    color: var(--primary-color);
}

/* Card type: Comment */
.arc-card-comment {
    background: #fffde7;
    border-color: #fff59d;
}

.arc-card-comment .arc-card-content {
    font-family: 'Inter', sans-serif;
    font-size: 13px;
    line-height: 1.5;
    color: var(--text-primary);
}

/* Card type: Table */
.arc-card-table {
    padding: 0;
    overflow: hidden;
}

.arc-card-table table {
    width: 100%;
    border-collapse: collapse;
    font-family: 'Inter', sans-serif;
    font-size: 12px;
}

.arc-card-table th,
.arc-card-table td {
    padding: 8px 12px;
    border: 1px solid var(--border-color);
    text-align: left;
}

.arc-card-table th {
    background: var(--bg-secondary);
    font-weight: 600;
}

.arc-card-table td[contenteditable="true"]:focus {
    background: var(--bg-secondary);
    outline: none;
}

/* Card type: Audio embed */
.arc-card-audio {
    padding: 12px;
}

.arc-card-audio .arc-audio-placeholder {
    display: flex;
    align-items: center;
    gap: 12px;
    color: var(--text-muted);
    font-family: 'Inter', sans-serif;
    font-size: 13px;
}

.arc-card-audio .arc-audio-placeholder svg {
    width: 24px;
    height: 24px;
    color: #1DB954;
}

/* Card type: Separator/Divider */
.arc-card-divider {
    padding: 16px 12px;
    text-align: center;
}

.arc-card-divider hr {
    border: none;
    border-top: 2px solid var(--border-color);
}

/* Card type: Scene */
.arc-card-scene {
    background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
    border-left: 3px solid var(--primary-color);
}

.arc-card-scene:hover {
    border-left-color: var(--accent-color);
}

.arc-card-scene-header {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 12px;
    padding-bottom: 8px;
    border-bottom: 1px solid var(--border-color);
}

.arc-card-scene-header svg {
    width: 16px;
    height: 16px;
    color: var(--primary-color);
    flex-shrink: 0;
    align-self: flex-start;
    margin-top: 2px;
}

.arc-card-scene-title-wrapper {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 4px;
}

.arc-card-scene-breadcrumb {
    font-family: 'Inter', sans-serif;
    font-size: 10px;
    font-weight: 500;
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 0.3px;
    line-height: 1;
}

.arc-card-scene-title {
    font-family: 'Inter', sans-serif;
    font-size: 14px;
    font-weight: 600;
    color: var(--text-primary);
    line-height: 1.3;
}

.arc-card-scene-meta {
    display: flex;
    flex-direction: column;
    gap: 8px;
    margin-bottom: 12px;
}

.arc-card-scene-intensity,
.arc-card-scene-status {
    display: flex;
    align-items: center;
    gap: 8px;
}

.arc-card-scene-label {
    font-family: 'Inter', sans-serif;
    font-size: 11px;
    font-weight: 500;
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    min-width: 70px;
}

.arc-card-scene-value {
    font-family: 'Inter', sans-serif;
    font-size: 12px;
    color: var(--text-secondary);
}

.arc-card-scene-notes {
    margin-top: 4px;
    padding: 8px;
    background: var(--bg-tertiary);
    border-radius: 4px;
    font-family: 'Crimson Pro', serif;
    font-size: 13px;
    line-height: 1.5;
    color: var(--text-secondary);
    font-style: italic;
}

.arc-card-scene-open {
    width: 100%;
    padding: 8px 12px;
    border: 1px solid var(--border-color);
    background: var(--bg-primary);
    border-radius: 6px;
    font-family: 'Inter', sans-serif;
    font-size: 12px;
    font-weight: 500;
    color: var(--primary-color);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
    transition: all 0.2s ease;
}

.arc-card-scene-open:hover {
    background: var(--primary-color);
    color: white;
    border-color: var(--primary-color);
}

.arc-card-scene-open svg {
    width: 14px;
    height: 14px;
}

/* ============================================
   ITEMS FLOTTANTS (hors colonnes)
   ============================================ */

.arc-floating-item {
    position: absolute;
    z-index: 5;
    cursor: move;
}

.arc-floating-item.selected {
    z-index: 50;
}

.arc-floating-note {
    background: var(--bg-primary);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 16px;
    min-width: 200px;
    max-width: 400px;
    box-shadow: 0 2px 8px var(--shadow);
}

.arc-floating-note:hover,
.arc-floating-note.selected {
    border-color: var(--primary-color);
}

.arc-floating-image {
    background: var(--bg-primary);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 2px 8px var(--shadow);
}

.arc-floating-image img {
    display: block;
    max-width: 400px;
}

/* ============================================
   PANNEAU CONTEXTUEL (droite)
   ============================================ */

.arc-board-context-panel {
    width: 280px;
    background: var(--bg-primary);
    border-left: 1px solid var(--border-color);
    display: flex;
    flex-direction: column;
    flex-shrink: 0;
    transition: width 0.3s ease;
    overflow: hidden;
}

.arc-board-context-panel.collapsed {
    width: 0;
    border-left: none;
}

.arc-context-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 16px;
    border-bottom: 1px solid var(--border-color);
}

.arc-context-title {
    font-family: 'Inter', sans-serif;
    font-size: 13px;
    font-weight: 600;
    color: var(--text-primary);
    display: flex;
    align-items: center;
    gap: 8px;
}

.arc-context-title svg {
    width: 16px;
    height: 16px;
    color: var(--primary-color);
}

.arc-context-close {
    width: 28px;
    height: 28px;
    border: none;
    background: transparent;
    border-radius: 6px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    color: var(--text-muted);
}

.arc-context-close:hover {
    background: var(--bg-secondary);
    color: var(--text-primary);
}

.arc-context-body {
    flex: 1;
    overflow-y: auto;
    padding: 16px;
}

/* Context tools */
.arc-context-section {
    margin-bottom: 20px;
}

.arc-context-section-title {
    font-family: 'Inter', sans-serif;
    font-size: 11px;
    font-weight: 600;
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 12px;
}

.arc-context-tools {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
}

.arc-context-tool {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 4px;
    padding: 12px;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    background: var(--bg-primary);
    cursor: pointer;
    transition: all 0.2s ease;
    width: calc(50% - 4px);
}

.arc-context-tool:hover {
    border-color: var(--primary-color);
    background: var(--bg-secondary);
}

.arc-context-tool svg {
    width: 20px;
    height: 20px;
    color: var(--text-secondary);
}

.arc-context-tool span {
    font-family: 'Inter', sans-serif;
    font-size: 11px;
    color: var(--text-secondary);
}

/* Text formatting tools */
.arc-context-format-bar {
    display: flex;
    gap: 4px;
    flex-wrap: wrap;
}

.arc-format-btn {
    width: 32px;
    height: 32px;
    border: 1px solid var(--border-color);
    background: var(--bg-primary);
    border-radius: 6px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    color: var(--text-secondary);
    transition: all 0.2s ease;
}

.arc-format-btn:hover {
    border-color: var(--primary-color);
    color: var(--primary-color);
}

.arc-format-btn.active {
    background: var(--primary-color);
    border-color: var(--primary-color);
    color: white;
}

.arc-format-btn svg {
    width: 16px;
    height: 16px;
}

/* Color picker in context */
.arc-context-colors {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
}

.arc-color-swatch {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    cursor: pointer;
    border: 2px solid transparent;
    transition: all 0.2s ease;
}

.arc-color-swatch:hover {
    transform: scale(1.1);
}

.arc-color-swatch.selected {
    border-color: var(--text-primary);
}

/* Delete button */
.arc-context-delete {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    padding: 12px;
    border: 1px solid var(--error-color);
    border-radius: 8px;
    background: transparent;
    color: var(--error-color);
    cursor: pointer;
    font-family: 'Inter', sans-serif;
    font-size: 13px;
    width: 100%;
    transition: all 0.2s ease;
}

.arc-context-delete:hover {
    background: var(--error-color);
    color: white;
}

/* ============================================
   ZOOM CONTROLS
   ============================================ */

.arc-zoom-controls {
    position: absolute;
    bottom: 20px;
    right: 20px;
    display: flex;
    align-items: center;
    gap: 4px;
    background: var(--bg-primary);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 4px;
    box-shadow: 0 2px 8px var(--shadow);
    z-index: 100;
}

.arc-zoom-btn {
    width: 32px;
    height: 32px;
    border: none;
    background: transparent;
    border-radius: 6px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    color: var(--text-secondary);
}

.arc-zoom-btn:hover {
    background: var(--bg-secondary);
    color: var(--text-primary);
}

.arc-zoom-btn svg {
    width: 18px;
    height: 18px;
}

.arc-zoom-level {
    font-family: 'Inter', sans-serif;
    font-size: 12px;
    color: var(--text-secondary);
    padding: 0 8px;
    min-width: 50px;
    text-align: center;
}

/* ============================================
   MINIMAP
   ============================================ */

.arc-minimap {
    position: absolute;
    bottom: 70px;
    right: 20px;
    width: 150px;
    height: 100px;
    background: var(--bg-primary);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 2px 8px var(--shadow);
    z-index: 100;
}

.arc-minimap-content {
    width: 100%;
    height: 100%;
    position: relative;
}

.arc-minimap-item {
    position: absolute;
    background: var(--primary-color);
    border-radius: 2px;
    opacity: 0.6;
}

.arc-minimap-viewport {
    position: absolute;
    border: 2px solid var(--primary-color);
    background: rgba(255, 140, 66, 0.1);
    border-radius: 2px;
}

/* ============================================
   EMPTY STATE
   ============================================ */

.arc-board-empty {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    text-align: center;
    color: var(--text-muted);
    pointer-events: none;
}

.arc-board-empty-icon {
    width: 64px;
    height: 64px;
    margin: 0 auto 16px;
    opacity: 0.3;
}

.arc-board-empty-icon svg {
    width: 100%;
    height: 100%;
}

.arc-board-empty-title {
    font-family: 'Inter', sans-serif;
    font-size: 16px;
    font-weight: 600;
    margin-bottom: 8px;
    color: var(--text-secondary);
}

.arc-board-empty-text {
    font-family: 'Inter', sans-serif;
    font-size: 13px;
    line-height: 1.5;
}

/* ============================================
   SELECTION BOX (multi-select)
   ============================================ */

.arc-selection-box {
    position: absolute;
    border: 2px dashed var(--primary-color);
    background: rgba(255, 140, 66, 0.1);
    pointer-events: none;
    z-index: 1000;
}

/* ============================================
   DRAG & DROP BIDIRECTIONNEL
   ============================================ */

/* Zone de drop sur les colonnes */
.arc-column-body.drop-target {
    background: rgba(255, 140, 66, 0.05);
    border: 2px dashed var(--primary-color);
    border-radius: 8px;
    min-height: 100px;
}

.arc-column-body.drop-hover {
    background: rgba(255, 140, 66, 0.15);
    border-color: var(--primary-color);
    box-shadow: inset 0 0 20px rgba(255, 140, 66, 0.1);
}

/* Zone de drop sur le canvas (pour sortir les cartes) */
.arc-board-canvas.drop-hover {
    background:
        radial-gradient(circle at center, rgba(255, 140, 66, 0.1) 0%, transparent 70%),
        radial-gradient(circle, var(--border-color) 1px, transparent 1px);
    background-size: 100% 100%, 24px 24px;
}

/* Éléments flottants en cours de drag */
.arc-floating-item.dragging {
    opacity: 0.6;
    transform: rotate(2deg);
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
    z-index: 1000;
}

/* Cartes en cours de drag */
.arc-card.dragging {
    opacity: 0.6;
    transform: rotate(2deg);
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
}

/* Indication visuelle sur les éléments draggables */
.arc-floating-item[draggable="true"],
.arc-card[draggable="true"] {
    cursor: grab;
}

.arc-floating-item[draggable="true"]:active,
.arc-card[draggable="true"]:active {
    cursor: grabbing;
}

/* ============================================
   CONNECTION MODE
   ============================================ */

.arc-board-canvas.connection-mode {
    cursor: crosshair;
}

.arc-connection-mode-hint {
    position: absolute;
    top: 16px;
    left: 50%;
    transform: translateX(-50%);
    background: var(--bg-accent);
    color: white;
    padding: 10px 20px;
    border-radius: 8px;
    display: flex;
    align-items: center;
    gap: 12px;
    font-family: 'Inter', sans-serif;
    font-size: 13px;
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
    z-index: 200;
}

.arc-connection-mode-hint svg {
    width: 18px;
    height: 18px;
    color: var(--primary-color);
}

.arc-connection-mode-hint button {
    display: flex;
    align-items: center;
    gap: 4px;
    padding: 4px 10px;
    background: rgba(255, 255, 255, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 4px;
    color: white;
    font-size: 12px;
    cursor: pointer;
    transition: all 0.15s ease;
}

.arc-connection-mode-hint button:hover {
    background: rgba(255, 255, 255, 0.2);
}

.arc-connection-mode-hint button svg {
    width: 14px;
    height: 14px;
    color: white;
}

/* Éléments connectables */
.arc-column.connectable,
.arc-floating-item.connectable {
    cursor: crosshair;
    box-shadow: 0 0 0 2px var(--primary-color), 0 4px 16px var(--shadow);
}

.arc-column.connection-source,
.arc-floating-item.connection-source {
    box-shadow: 0 0 0 3px var(--accent-green), 0 4px 16px var(--shadow);
}

.arc-column.connection-target,
.arc-floating-item.connection-target {
    cursor: crosshair;
}

.arc-column.connection-target:hover,
.arc-floating-item.connection-target:hover {
    box-shadow: 0 0 0 3px var(--primary-color), 0 4px 16px rgba(255, 140, 66, 0.3);
}

/* ============================================
   CONNECTION POINTS (removed - using click system now)
   ============================================ */

/* ============================================
   CONTEXT MENU
   ============================================ */

.arc-context-menu {
    position: fixed;
    background: var(--bg-primary);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    box-shadow: 0 4px 16px var(--shadow);
    padding: 8px 0;
    min-width: 180px;
    z-index: 10000;
}

.arc-context-menu-item {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 8px 16px;
    font-family: 'Inter', sans-serif;
    font-size: 13px;
    color: var(--text-primary);
    cursor: pointer;
    transition: background 0.15s ease;
}

.arc-context-menu-item:hover {
    background: var(--bg-secondary);
}

.arc-context-menu-item svg {
    width: 16px;
    height: 16px;
    color: var(--text-secondary);
}

.arc-context-menu-item.danger {
    color: var(--error-color);
}

.arc-context-menu-item.danger svg {
    color: var(--error-color);
}

.arc-context-menu-separator {
    height: 1px;
    background: var(--border-color);
    margin: 8px 0;
}

/* ============================================
   DRAG GHOST
   ============================================ */

.arc-drag-ghost {
    position: fixed;
    pointer-events: none;
    z-index: 10000;
    opacity: 0.8;
    transform: rotate(3deg);
}

/* ============================================
   MENU DE SÉLECTION DE TYPE DE CARTE
   ============================================ */

.arc-card-type-menu {
    position: fixed;
    background: var(--bg-primary);
    border: 1px solid var(--border-color);
    border-radius: 12px;
    box-shadow: 0 8px 32px var(--shadow), 0 0 0 1px rgba(0, 0, 0, 0.05);
    padding: 8px;
    z-index: 10000;
    min-width: 200px;
    animation: arcMenuAppear 0.15s ease-out;
}

@keyframes arcMenuAppear {
    from {
        opacity: 0;
        transform: translateY(-8px) scale(0.96);
    }
    to {
        opacity: 1;
        transform: translateY(0) scale(1);
    }
}

.arc-card-type-menu-header {
    padding: 8px 12px 12px;
    font-family: 'Inter', sans-serif;
    font-size: 11px;
    font-weight: 600;
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    border-bottom: 1px solid var(--border-color);
    margin-bottom: 8px;
}

.arc-card-type-menu-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 4px;
}

.arc-card-type-option {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 6px;
    padding: 12px 8px;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.15s ease;
    background: transparent;
    border: 1px solid transparent;
}

.arc-card-type-option:hover {
    background: var(--bg-secondary);
    border-color: var(--primary-color);
}

.arc-card-type-option svg,
.arc-card-type-option i {
    width: 20px;
    height: 20px;
    color: var(--text-secondary);
    transition: color 0.15s ease;
}

.arc-card-type-option:hover svg,
.arc-card-type-option:hover i {
    color: var(--primary-color);
}

.arc-card-type-option span {
    font-family: 'Inter', sans-serif;
    font-size: 11px;
    color: var(--text-secondary);
    transition: color 0.15s ease;
}

.arc-card-type-option:hover span {
    color: var(--text-primary);
}

/* ============================================
   TOOLBAR DRAG & DROP
   ============================================ */

.arc-toolbar-btn.arc-toolbar-draggable {
    cursor: grab;
}

.arc-toolbar-btn.arc-toolbar-draggable:active {
    cursor: grabbing;
}

.arc-toolbar-btn.arc-toolbar-draggable.dragging {
    opacity: 0.4;
    cursor: grabbing;
}

/* Ghost de drag depuis la toolbar */
.arc-toolbar-drag-ghost {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 10px 14px;
    background: var(--bg-primary);
    border: 2px solid var(--primary-color);
    border-radius: 8px;
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
    font-family: 'Inter', sans-serif;
    font-size: 12px;
    font-weight: 500;
    color: var(--text-primary);
    pointer-events: none;
    white-space: nowrap;
}

.arc-toolbar-drag-ghost svg,
.arc-toolbar-drag-ghost i {
    width: 16px;
    height: 16px;
    color: var(--primary-color);
}

/* Indication visuelle lors du drag depuis la toolbar */
.arc-board-canvas.drop-zone-active {
    outline: 2px dashed var(--primary-color);
    outline-offset: -10px;
}



/* ============================================
   FORMULAIRES INLINE SIDEBAR
   Ajouter à la fin de arc-board.css
   ============================================ */

.sidebar-inline-form {
    background: var(--bg-primary);
    border: 1px solid var(--primary-color);
    border-radius: 8px;
    margin-bottom: 12px;
    overflow: hidden;
    animation: slideDown 0.2s ease-out;
}

@keyframes slideDown {
    from {
        opacity: 0;
        transform: translateY(-10px);
    }

    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.sidebar-inline-form-header {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 10px 12px;
    background: var(--bg-secondary);
    border-bottom: 1px solid var(--border-color);
    font-family: 'Inter', sans-serif;
    font-size: 13px;
    font-weight: 600;
    color: var(--text-primary);
}

.sidebar-inline-form-header>i,
.sidebar-inline-form-header>svg {
    width: 16px;
    height: 16px;
    color: var(--primary-color);
}

.sidebar-inline-form-header span {
    flex: 1;
}

.sidebar-inline-form-close {
    width: 24px;
    height: 24px;
    border: none;
    background: transparent;
    border-radius: 4px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    color: var(--text-muted);
    transition: all 0.15s ease;
}

.sidebar-inline-form-close:hover {
    background: var(--bg-tertiary);
    color: var(--text-primary);
}

.sidebar-inline-form-close svg {
    width: 14px;
    height: 14px;
}

.sidebar-inline-form-body {
    padding: 12px;
}

.sidebar-inline-form-group {
    margin-bottom: 12px;
}

.sidebar-inline-form-group:last-of-type {
    margin-bottom: 0;
}

.sidebar-inline-form-group label {
    display: block;
    font-family: 'Inter', sans-serif;
    font-size: 11px;
    font-weight: 500;
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 6px;
}

.sidebar-inline-input {
    width: 100%;
    padding: 8px 10px;
    font-family: 'Inter', sans-serif;
    font-size: 13px;
    color: var(--text-primary);
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 6px;
    transition: all 0.15s ease;
}

.sidebar-inline-input:focus {
    outline: none;
    border-color: var(--primary-color);
    box-shadow: 0 0 0 3px rgba(255, 140, 66, 0.1);
}

.sidebar-inline-input.error {
    border-color: var(--error-color);
    box-shadow: 0 0 0 3px rgba(231, 76, 60, 0.1);
    animation: shake 0.3s ease;
}

@keyframes shake {

    0%,
    100% {
        transform: translateX(0);
    }

    25% {
        transform: translateX(-4px);
    }

    75% {
        transform: translateX(4px);
    }
}

.sidebar-inline-input::placeholder {
    color: var(--text-muted);
}

.sidebar-inline-select {
    width: 100%;
    padding: 8px 10px;
    font-family: 'Inter', sans-serif;
    font-size: 13px;
    color: var(--text-primary);
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.15s ease;
}

.sidebar-inline-select:focus {
    outline: none;
    border-color: var(--primary-color);
    box-shadow: 0 0 0 3px rgba(255, 140, 66, 0.1);
}

.sidebar-inline-color-row {
    display: flex;
    align-items: center;
    gap: 10px;
}

.sidebar-inline-color {
    width: 36px;
    height: 36px;
    padding: 2px;
    border: 1px solid var(--border-color);
    border-radius: 6px;
    cursor: pointer;
    background: var(--bg-secondary);
}

.sidebar-inline-color::-webkit-color-swatch-wrapper {
    padding: 2px;
}

.sidebar-inline-color::-webkit-color-swatch {
    border-radius: 4px;
    border: none;
}

.sidebar-inline-color-hex {
    font-family: 'JetBrains Mono', monospace;
    font-size: 12px;
    color: var(--text-secondary);
}

.sidebar-inline-form-actions {
    display: flex;
    justify-content: flex-end;
    gap: 8px;
    margin-top: 16px;
    padding-top: 12px;
    border-top: 1px solid var(--border-color);
}

/* Boutons compacts pour la sidebar */
.btn-sm {
    padding: 6px 12px;
    font-size: 12px;
    border-radius: 6px;
}

.btn-sm svg,
.btn-sm i {
    width: 14px;
    height: 14px;
}

.btn-secondary.btn-sm {
    background: var(--bg-secondary);
    color: var(--text-secondary);
    border: 1px solid var(--border-color);
}

.btn-secondary.btn-sm:hover {
    background: var(--bg-tertiary);
    color: var(--text-primary);
}

.btn-primary.btn-sm {
    background: var(--primary-color);
    color: white;
    border: none;
    display: flex;
    align-items: center;
    gap: 4px;
}

.btn-primary.btn-sm:hover {
    background: var(--primary-hover);
}



/* ============================================
   RESPONSIVE
   ============================================ */

@media (max-width: 768px) {
    .arc-board-toolbar {
        width: 48px;
        padding: 8px 0;
    }

    .arc-toolbar-btn {
        width: 36px;
        height: 36px;
    }

    .arc-board-context-panel {
        position: absolute;
        right: 0;
        top: 0;
        bottom: 0;
        z-index: 200;
        box-shadow: -4px 0 16px var(--shadow);
    }

    .arc-zoom-controls {
        bottom: 10px;
        right: 10px;
    }

    .arc-minimap {
        display: none;
    }
}

/* ============================================
   ZONE NON ATTRIBUÉ (Unassigned Sidebar)
   ============================================ */

.arc-unassigned-zone {
    width: 280px;
    background: var(--bg-primary);
    border-right: 1px solid var(--border-color);
    display: flex;
    flex-direction: column;
    flex-shrink: 0;
    height: 100%;
    overflow: hidden;
}

.arc-unassigned-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 14px 16px;
    border-bottom: 1px solid var(--border-color);
    background: var(--bg-primary);
    flex-shrink: 0;
}

.arc-unassigned-title {
    display: flex;
    align-items: center;
    gap: 8px;
    font-family: 'Inter', sans-serif;
    font-size: 14px;
    font-weight: 600;
    color: var(--text-primary);
}

.arc-unassigned-title i,
.arc-unassigned-title svg {
    width: 16px;
    height: 16px;
    color: var(--text-muted);
}

.arc-unassigned-count {
    font-family: 'Inter', sans-serif;
    font-size: 11px;
    color: var(--text-muted);
    background: var(--bg-secondary);
    padding: 3px 8px;
    border-radius: 10px;
    font-weight: 500;
}

.arc-unassigned-body {
    flex: 1;
    padding: 8px;
    display: flex;
    flex-direction: column;
    gap: 8px;
    overflow-y: auto;
    overflow-x: hidden;
}

.arc-unassigned-body.drag-over {
    background: rgba(255, 140, 66, 0.05);
}

.arc-unassigned-empty {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 8px;
    padding: 32px 16px;
    color: var(--text-muted);
    text-align: center;
    font-family: 'Inter', sans-serif;
    font-size: 12px;
    line-height: 1.5;
}

/* Cards dans la zone non attribué */
.arc-unassigned-body .arc-card {
    margin: 0;
    cursor: pointer;
}

.arc-unassigned-body .arc-card-scene {
    padding: 10px 10px 10px 32px;
}

/* ============================================
   ANIMATIONS
   ============================================ */

@keyframes arcItemAppear {
    from {
        opacity: 0;
        transform: scale(0.95);
    }

    to {
        opacity: 1;
        transform: scale(1);
    }
}

.arc-column,
.arc-floating-item {
    animation: arcItemAppear 0.2s ease;
}

/* ============================================
   PRINT STYLES
   ============================================ */

@media print {

    .arc-board-toolbar,
    .arc-board-context-panel,
    .arc-zoom-controls,
    .arc-minimap {
        display: none !important;
    }

    .arc-board-canvas {
        background: white !important;
    }
}

/* ============================================
   MULTI-ARCS - Barre compacte sur une ligne
   ============================================ */

.arc-multi-bar {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 4px 12px;
    background: var(--bg-primary);
    border-bottom: 1px solid var(--border-light);
    flex-shrink: 0;
    min-height: 32px;
}

.arc-multi-left {
    display: flex;
    align-items: center;
    gap: 8px;
}

.arc-multi-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    flex-shrink: 0;
}

.arc-multi-select {
    padding: 4px 8px;
    border: 1px solid var(--border-light);
    border-radius: 4px;
    background: var(--bg-primary);
    font-size: 12px;
    color: var(--text-primary);
    cursor: pointer;
}

/* Mode buttons */
.arc-multi-modes {
    display: flex;
    background: var(--bg-tertiary);
    border-radius: 4px;
    padding: 2px;
}

.arc-multi-modes button {
    padding: 4px 10px;
    border: none;
    background: none;
    border-radius: 3px;
    font-size: 11px;
    color: var(--text-secondary);
    cursor: pointer;
    transition: all 0.15s;
}

.arc-multi-modes button:hover {
    color: var(--text-primary);
}

.arc-multi-modes button.active {
    background: var(--bg-primary);
    color: var(--text-primary);
    box-shadow: 0 1px 2px rgba(0,0,0,0.1);
}

/* Ghost arcs section */
.arc-multi-ghosts {
    display: flex;
    align-items: center;
    gap: 6px;
    flex: 1;
}

/* Ghost arc tags */
.arc-multi-tag {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    padding: 2px 4px 2px 8px;
    background: var(--bg-primary);
    border: 1px solid var(--tag-color, var(--border-light));
    border-radius: 12px;
    font-size: 11px;
    color: var(--text-primary);
}

.arc-multi-tag button {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 14px;
    height: 14px;
    padding: 0;
    background: none;
    border: none;
    border-radius: 50%;
    color: var(--text-muted);
    cursor: pointer;
}

.arc-multi-tag button:hover {
    background: var(--bg-danger-light);
    color: var(--text-danger);
}

.arc-multi-tag button i {
    width: 10px;
    height: 10px;
}

.arc-multi-add {
    padding: 2px 6px;
    border: 1px solid var(--border-light);
    border-radius: 4px;
    background: var(--bg-primary);
    font-size: 11px;
    color: var(--text-secondary);
    cursor: pointer;
}

.arc-multi-opacity {
    width: 60px;
    height: 3px;
    -webkit-appearance: none;
    background: var(--border-medium);
    border-radius: 2px;
    cursor: pointer;
}

.arc-multi-opacity::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 10px;
    height: 10px;
    background: var(--accent-color);
    border-radius: 50%;
    cursor: pointer;
}

.arc-multi-btn-exit {
    display: flex;
    align-items: center;
    gap: 4px;
    padding: 4px 8px;
    background: none;
    border: 1px solid var(--border-light);
    border-radius: 4px;
    font-size: 11px;
    color: var(--text-secondary);
    cursor: pointer;
}

.arc-multi-btn-exit:hover {
    background: var(--bg-danger-light);
    color: var(--text-danger);
    border-color: var(--border-danger);
}

.arc-multi-btn-exit i {
    width: 12px;
    height: 12px;
}

/* ============================================
   MULTI-ARCS - Ghost Layers (Mode Compare)
   ============================================ */

.arc-ghost-layer {
    position: absolute;
    top: 0;
    left: 0;
    pointer-events: none;
    z-index: 2;
}

/* Ghost columns */
.arc-ghost-column {
    position: absolute;
    background: var(--bg-secondary);
    border: 2px dashed var(--ghost-color, var(--border-medium));
    border-radius: 12px;
    pointer-events: auto;
    cursor: pointer;
}

.arc-ghost-column-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 14px;
    border-bottom: 1px dashed var(--border-light);
    font-size: 13px;
    font-weight: 500;
    color: var(--text-secondary);
}

.arc-ghost-card-count {
    font-size: 11px;
    padding: 2px 6px;
    background: var(--bg-tertiary);
    border-radius: 10px;
    color: var(--text-muted);
}

.arc-ghost-column-body {
    padding: 8px;
    display: flex;
    flex-direction: column;
    gap: 4px;
}

.arc-ghost-card {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 6px 10px;
    background: var(--bg-primary);
    border-radius: 6px;
    font-size: 11px;
    color: var(--text-muted);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.arc-ghost-card i {
    width: 12px;
    height: 12px;
    opacity: 0.6;
    flex-shrink: 0;
}

.arc-ghost-more {
    font-size: 11px;
    color: var(--text-muted);
    text-align: center;
    padding: 4px;
}

/* Ghost floating items */
.arc-ghost-item {
    position: absolute;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 48px;
    height: 48px;
    background: var(--bg-secondary);
    border: 2px dashed var(--ghost-color, var(--border-medium));
    border-radius: 8px;
    color: var(--text-muted);
    pointer-events: auto;
    cursor: pointer;
}

.arc-ghost-item i {
    width: 20px;
    height: 20px;
}

/* Ghost connections */
.arc-ghost-connections {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    overflow: visible;
}

.arc-ghost-connection-line {
    fill: none;
    stroke: var(--ghost-color, var(--border-medium));
    stroke-width: 2;
    stroke-dasharray: 8 4;
    opacity: 0.6;
}

/* ============================================
   MULTI-ARCS - Split Mode
   ============================================ */

.arc-split-container {
    display: flex;
    flex-direction: column;
    height: 100%;
    overflow: hidden;
}

.arc-split-bar {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 8px;
    padding: 4px 8px;
    background: var(--bg-secondary);
    border-bottom: 1px solid var(--border-light);
    flex-shrink: 0;
}

.arc-split-bar-left {
    display: flex;
    align-items: center;
    gap: 8px;
}

.arc-split-add-select {
    padding: 4px 8px;
    font-size: 12px;
    border: 1px solid var(--border-light);
    border-radius: 4px;
    background: var(--bg-primary);
    color: var(--text-secondary);
    cursor: pointer;
}

.arc-split-exit {
    display: flex;
    align-items: center;
    gap: 4px;
    padding: 4px 10px;
    font-size: 12px;
    background: var(--bg-tertiary);
    border: 1px solid var(--border-light);
    border-radius: 4px;
    color: var(--text-secondary);
    cursor: pointer;
    transition: all 0.15s;
}

.arc-split-exit:hover {
    background: var(--bg-danger-light);
    color: var(--text-danger);
    border-color: var(--bg-danger-light);
}

.arc-split-exit i {
    width: 14px;
    height: 14px;
}

.arc-split-layout-toggle {
    display: flex;
    background: var(--bg-tertiary);
    border-radius: 4px;
    padding: 2px;
}

.arc-split-layout-toggle button {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 24px;
    height: 22px;
    padding: 0;
    background: none;
    border: none;
    border-radius: 3px;
    color: var(--text-muted);
    cursor: pointer;
}

.arc-split-layout-toggle button:hover {
    color: var(--text-primary);
}

.arc-split-layout-toggle button.active {
    background: var(--bg-primary);
    color: var(--text-primary);
}

.arc-split-layout-toggle button i {
    width: 14px;
    height: 14px;
}

/* Split Panels Container */
.arc-split-panels {
    flex: 1;
    display: flex;
    gap: 1px;
    background: var(--border-light);
    min-height: 0;
}

.arc-split-vertical {
    flex-direction: row;
}

.arc-split-horizontal {
    flex-direction: column;
}

/* Individual Split Panel */
.arc-split-panel {
    flex: 1;
    display: flex;
    flex-direction: column;
    background: var(--bg-primary);
    min-width: 0;
    min-height: 0;
    overflow: hidden;
}

.arc-split-panel-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 4px 8px;
    background: var(--bg-secondary);
    border-bottom: 1px solid var(--border-light);
    flex-shrink: 0;
}

.arc-split-panel-title {
    display: flex;
    align-items: center;
    gap: 8px;
}

.arc-split-select {
    padding: 4px 8px;
    border: 1px solid var(--border-light);
    border-radius: 6px;
    background: var(--bg-primary);
    font-size: 13px;
    font-weight: 500;
    color: var(--text-primary);
    cursor: pointer;
}

.arc-split-close {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 24px;
    height: 24px;
    padding: 0;
    background: none;
    border: none;
    border-radius: 4px;
    color: var(--text-muted);
    cursor: pointer;
    transition: all 0.15s ease;
}

.arc-split-close:hover {
    background: var(--bg-danger-light);
    color: var(--text-danger);
}

.arc-split-close i {
    width: 16px;
    height: 16px;
}

/* Split Canvas */
.arc-split-canvas {
    flex: 1;
    position: relative;
    overflow: hidden;
    background-color: var(--bg-tertiary);
    background-image:
        linear-gradient(var(--border-light) 1px, transparent 1px),
        linear-gradient(90deg, var(--border-light) 1px, transparent 1px);
    background-size: 24px 24px;
}

.arc-split-content {
    position: relative;
    min-width: 2000px;
    min-height: 1500px;
    transform-origin: 0 0;
}

.arc-split-column {
    pointer-events: none;
}

.arc-split-connections {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    overflow: visible;
}

.arc-split-zoom {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
    padding: 3px 8px;
    background: var(--bg-secondary);
    border-top: 1px solid var(--border-light);
    font-size: 11px;
    color: var(--text-muted);
    flex-shrink: 0;
}

.arc-split-zoom button {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 20px;
    height: 20px;
    padding: 0;
    background: var(--bg-tertiary);
    border: 1px solid var(--border-light);
    border-radius: 3px;
    color: var(--text-secondary);
    cursor: pointer;
    transition: all 0.15s ease;
}

.arc-split-zoom button:hover {
    background: var(--bg-hover);
    color: var(--text-primary);
}

.arc-split-zoom button i {
    width: 12px;
    height: 12px;
}

/* ============================================
   MULTI-ARCS - Inter-Arc Connections Panel
   ============================================ */

.arc-interarc-panel {
    display: flex;
    flex-direction: column;
    background: var(--bg-secondary);
    border-top: 1px solid var(--border-light);
    max-height: 200px;
}

.arc-interarc-header {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 10px 16px;
    border-bottom: 1px solid var(--border-light);
    font-size: 13px;
    font-weight: 500;
    color: var(--text-primary);
}

.arc-interarc-header i {
    width: 16px;
    height: 16px;
    color: var(--accent-color);
}

.arc-interarc-count {
    font-size: 11px;
    padding: 2px 8px;
    background: var(--bg-tertiary);
    border-radius: 10px;
    color: var(--text-muted);
    font-weight: normal;
}

.arc-interarc-body {
    flex: 1;
    overflow-y: auto;
    padding: 8px;
}

.arc-interarc-empty {
    text-align: center;
    padding: 20px;
    font-size: 13px;
    color: var(--text-muted);
}

.arc-interarc-empty small {
    display: block;
    margin-top: 4px;
    font-size: 11px;
    opacity: 0.8;
}

.arc-interarc-connection {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 8px 12px;
    background: var(--bg-primary);
    border: 1px solid var(--border-light);
    border-radius: 8px;
    margin-bottom: 6px;
}

.arc-interarc-from,
.arc-interarc-to {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 12px;
    color: var(--text-secondary);
}

.arc-interarc-from i,
.arc-interarc-to i {
    width: 12px;
    height: 12px;
    opacity: 0.5;
}

.arc-interarc-type {
    flex-shrink: 0;
}

.arc-interarc-type select {
    padding: 4px 8px;
    border: 1px solid var(--accent-color);
    border-radius: 12px;
    background: var(--bg-accent-light);
    font-size: 11px;
    color: var(--accent-color);
    cursor: pointer;
}

.arc-interarc-delete {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 24px;
    height: 24px;
    padding: 0;
    background: none;
    border: none;
    border-radius: 4px;
    color: var(--text-muted);
    cursor: pointer;
    margin-left: auto;
    transition: all 0.15s ease;
}

.arc-interarc-delete:hover {
    background: var(--bg-danger-light);
    color: var(--text-danger);
}

.arc-interarc-delete i {
    width: 14px;
    height: 14px;
}

.arc-interarc-footer {
    padding: 8px 12px;
    border-top: 1px solid var(--border-light);
}

.arc-interarc-add {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
    width: 100%;
    padding: 8px;
    background: var(--bg-tertiary);
    border: 1px dashed var(--border-medium);
    border-radius: 6px;
    font-size: 12px;
    color: var(--text-secondary);
    cursor: pointer;
    transition: all 0.15s ease;
}

.arc-interarc-add:hover {
    background: var(--bg-hover);
    border-color: var(--accent-color);
    color: var(--accent-color);
}

.arc-interarc-add i {
    width: 14px;
    height: 14px;
}

/* Connection source highlight */
.connection-source {
    outline: 3px solid var(--accent-color) !important;
    outline-offset: 2px;
}

/* ============================================
   MODE COMPARE - Canvas unique avec arcs empilés
   ============================================ */

/* Contrôles du mode Compare dans la barre multi-arcs */
.arc-compare-controls {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-left: 12px;
}

/* Tags des arcs en comparaison */
.arc-compare-tag {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 4px 8px;
    background: color-mix(in srgb, var(--tag-color, var(--primary-color)) 15%, var(--bg-primary));
    border: 1px solid color-mix(in srgb, var(--tag-color, var(--primary-color)) 30%, var(--border-color));
    border-radius: 14px;
    font-size: 11px;
    color: var(--text-primary);
}

.arc-compare-tag.main {
    font-weight: 600;
}

.arc-compare-tag-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    flex-shrink: 0;
}

.arc-compare-tag button {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 14px;
    height: 14px;
    padding: 0;
    background: none;
    border: none;
    border-radius: 50%;
    color: var(--text-muted);
    cursor: pointer;
    transition: all 0.15s ease;
}

.arc-compare-tag button:hover {
    background: var(--error-color);
    color: white;
}

.arc-compare-tag button i {
    width: 10px;
    height: 10px;
}

/* Dropdown pour ajouter un arc */
.arc-compare-add {
    padding: 4px 8px;
    font-size: 11px;
    border: 1px dashed var(--border-color);
    border-radius: 14px;
    background: transparent;
    color: var(--text-muted);
    cursor: pointer;
    transition: all 0.15s ease;
}

.arc-compare-add:hover {
    border-color: var(--primary-color);
    color: var(--primary-color);
}

/* Bouton lien inter-arcs */
.arc-compare-link-btn {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 28px;
    height: 28px;
    padding: 0;
    background: var(--primary-color);
    border: none;
    border-radius: 6px;
    color: white;
    cursor: pointer;
    transition: all 0.15s ease;
}

.arc-compare-link-btn:hover {
    background: var(--primary-hover);
}

.arc-compare-link-btn i {
    width: 14px;
    height: 14px;
}

/* Tags des connexions inter-arcs */
.arc-interarc-tags {
    display: flex;
    align-items: center;
    gap: 6px;
    margin-left: 8px;
    padding-left: 8px;
    border-left: 1px solid var(--border-color);
}

.arc-interarc-tag {
    display: flex;
    align-items: center;
    gap: 4px;
    padding: 3px 8px;
    background: var(--bg-primary);
    border: 1px solid var(--border-color);
    border-radius: 10px;
    font-size: 11px;
    font-weight: 500;
    box-shadow: 0 1px 3px var(--shadow);
    z-index: 100;
    position: relative;
}

.arc-interarc-tag-dot {
    width: 6px;
    height: 6px;
    border-radius: 50%;
    flex-shrink: 0;
}

.arc-interarc-tag-name {
    color: var(--text-secondary);
    max-width: 80px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.arc-interarc-tag i {
    width: 10px;
    height: 10px;
    color: var(--text-muted);
}

.arc-interarc-tag button {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 12px;
    height: 12px;
    padding: 0;
    background: none;
    border: none;
    border-radius: 50%;
    color: var(--text-muted);
    cursor: pointer;
}

.arc-interarc-tag button:hover {
    background: var(--error-color);
    color: white;
}

.arc-interarc-tag button i {
    width: 8px;
    height: 8px;
}

.arc-compare-header-dot {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    flex-shrink: 0;
}

.arc-compare-header-title {
    font-family: 'Inter', sans-serif;
    font-size: 14px;
    font-weight: 600;
    color: var(--text-primary);
}

.arc-compare-header-count {
    font-size: 11px;
    color: var(--text-muted);
    margin-left: auto;
}

/* Colonnes en mode Compare (avec accent coloré) */
.arc-column.arc-column-compare {
    border-top: 3px solid var(--column-accent, var(--primary-color));
}

.arc-column.arc-column-compare .arc-column-header {
    cursor: pointer;
}

.arc-column.arc-column-compare:hover {
    box-shadow: 0 4px 16px var(--shadow), 0 0 0 2px var(--column-accent, var(--primary-color));
}

/* Connexions internes en mode Compare */
.arc-connection-line[data-arc-id] {
    stroke-width: 2;
    opacity: 0.6;
}

/* Connexions inter-arcs (tiretées) */
.arc-interarc-connection {
    stroke: var(--primary-color) !important;
    stroke-width: 2.5 !important;
    stroke-dasharray: 8 4;
    opacity: 0.9;
}

.arc-interarc-connection:hover {
    stroke-width: 4 !important;
    opacity: 1;
}

/* ============================================
   MODE COMPARE - Poignée de redimensionnement vertical
   ============================================ */

/* Conteneur d'un arc en mode Compare */
.arc-compare-section {
    position: absolute;
    left: 0;
    right: 0;
    overflow: visible;
    border-bottom: 1px solid var(--border-color);
    background: var(--bg-secondary);
}

/* Zone de contenu des items d'un arc */
.arc-compare-content {
    position: relative;
    overflow: visible;
}

/* Poignée de redimensionnement en bas de chaque arc */
.arc-compare-resize-handle {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    height: 8px;
    cursor: ns-resize;
    background: transparent;
    z-index: 20;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background 0.15s ease;
}

.arc-compare-resize-handle:hover {
    background: linear-gradient(to bottom, transparent, rgba(255, 140, 66, 0.15));
}

.arc-compare-resize-handle:active {
    background: linear-gradient(to bottom, transparent, rgba(255, 140, 66, 0.25));
}

/* Indicateur visuel de la poignée */
.arc-compare-resize-handle::before {
    content: '';
    width: 40px;
    height: 4px;
    background: var(--border-color);
    border-radius: 2px;
    opacity: 0;
    transition: opacity 0.15s ease;
}

.arc-compare-resize-handle:hover::before {
    opacity: 1;
    background: var(--primary-color);
}

/* Style de l'en-tête avec poignée de drag vertical */
.arc-compare-header {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 40px;
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 0 20px;
    background: linear-gradient(to right, color-mix(in srgb, var(--arc-color, var(--primary-color)) 20%, var(--bg-primary)), var(--bg-primary));
    border-bottom: 3px solid var(--arc-color, var(--primary-color));
    z-index: 10;
}

/* Indicateur de hauteur minimale/maximale */
.arc-compare-section.min-height .arc-compare-resize-handle::after {
    content: 'Hauteur minimale';
    position: absolute;
    bottom: 12px;
    font-size: 10px;
    color: var(--text-muted);
    background: var(--bg-primary);
    padding: 2px 8px;
    border-radius: 4px;
    opacity: 0;
    transition: opacity 0.2s ease;
}

.arc-compare-section.min-height .arc-compare-resize-handle:hover::after {
    opacity: 1;
}

/* ============================================
   MODE COMPARE - Contrôle d'opacité
   ============================================ */

/* Conteneur du contrôle d'opacité dans le header */
.arc-compare-opacity-control {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-left: 12px;
    padding-left: 12px;
    border-left: 1px solid color-mix(in srgb, var(--arc-color, var(--primary-color)) 30%, transparent);
}

.arc-compare-opacity-icon {
    width: 14px;
    height: 14px;
    color: var(--text-muted);
    flex-shrink: 0;
}

/* Slider de transparence */
.arc-compare-opacity-slider {
    -webkit-appearance: none;
    appearance: none;
    width: 80px;
    height: 4px;
    border-radius: 2px;
    background: linear-gradient(to right,
        rgba(255, 255, 255, 0.3),
        var(--arc-color, var(--primary-color)));
    cursor: pointer;
    outline: none;
}

.arc-compare-opacity-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background: var(--bg-primary);
    border: 2px solid var(--arc-color, var(--primary-color));
    cursor: pointer;
    transition: transform 0.15s ease, box-shadow 0.15s ease;
}

.arc-compare-opacity-slider::-webkit-slider-thumb:hover {
    transform: scale(1.2);
    box-shadow: 0 0 8px color-mix(in srgb, var(--arc-color, var(--primary-color)) 50%, transparent);
}

.arc-compare-opacity-slider::-moz-range-thumb {
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background: var(--bg-primary);
    border: 2px solid var(--arc-color, var(--primary-color));
    cursor: pointer;
    transition: transform 0.15s ease, box-shadow 0.15s ease;
}

.arc-compare-opacity-slider::-moz-range-thumb:hover {
    transform: scale(1.2);
}

/* Affichage de la valeur */
.arc-compare-opacity-value {
    font-size: 11px;
    font-weight: 500;
    color: var(--text-secondary);
    min-width: 36px;
    text-align: right;
}

/* Section d'arc en mode Compare - fond transparent pour voir les arcs en dessous */
.arc-compare-section {
    background: transparent;
}

/* Contenu avec transparence via color-mix (évite de créer un stacking context) */
/* L'opacité n'affecte que le fond, pas les colonnes/cartes/liens */
.arc-compare-content {
    background: color-mix(in srgb, var(--bg-secondary) calc(var(--arc-opacity, 1) * 100%), transparent);
}

/* Colonnes en mode Compare - z-index élevé pour passer au-dessus des headers des arcs suivants */
.arc-compare-content .arc-column {
    z-index: 1000;
}
/* ========== 14.word-repetition.css ========== */
/* ============================================================
 * 14.word-repetition.css - Styles pour l'analyseur de répétitions
 * ============================================================ */

/* ============================================================
 * SIDEBAR DROITE - Panneau principal
 * ============================================================ */

.word-rep-sidebar {
    position: fixed;
    top: 60px;
    right: 0;
    width: 380px;
    height: calc(100vh - 60px);
    background: var(--bg-primary);
    border-left: 1px solid var(--border-color);
    display: flex;
    flex-direction: column;
    z-index: 100;
    box-shadow: -4px 0 20px rgba(0, 0, 0, 0.1);
    transition: transform 0.3s ease;
}

.word-rep-sidebar.hidden {
    transform: translateX(100%);
    pointer-events: none;
}

/* Poignée de redimensionnement */
.word-rep-sidebar-resize {
    position: absolute;
    left: -4px;
    top: 0;
    width: 8px;
    height: 100%;
    cursor: ew-resize;
    background: transparent;
    z-index: 10;
}

.word-rep-sidebar-resize:hover,
.word-rep-sidebar-resize.active {
    background: var(--primary-color);
    opacity: 0.5;
}

/* Header de la sidebar */
.word-rep-sidebar-header {
    padding: 1rem;
    border-bottom: 1px solid var(--border-color);
    background: var(--bg-secondary);
    flex-shrink: 0;
}

.word-rep-sidebar-title {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 0.75rem;
}

.word-rep-sidebar-title h3 {
    margin: 0;
    font-size: 1rem;
    font-weight: 600;
    color: var(--text-primary);
    display: flex;
    align-items: center;
}

.word-rep-sidebar-close {
    background: none;
    border: none;
    cursor: pointer;
    padding: 0.25rem;
    border-radius: 4px;
    color: var(--text-muted);
    transition: all 0.15s;
}

.word-rep-sidebar-close:hover {
    background: var(--bg-tertiary);
    color: var(--text-primary);
}

.word-rep-sidebar-controls {
    display: flex;
    gap: 0.5rem;
}

/* Zone de contenu scrollable */
.word-rep-sidebar-content {
    flex: 1;
    overflow-y: auto;
    overflow-x: hidden;
    padding: 1rem;
}

/* Container principal */
.word-repetition-panel {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
    font-size: 0.875rem;
}

/* Header */
.word-rep-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding-bottom: 0.5rem;
    border-bottom: 1px solid var(--border-color);
}

.word-rep-title {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-weight: 600;
    color: var(--text-primary);
}

.word-rep-actions {
    display: flex;
    gap: 0.25rem;
}

/* Scope selector */
.word-rep-scope-selector {
    display: flex;
    gap: 0.25rem;
    background: var(--bg-tertiary);
    padding: 0.25rem;
    border-radius: 6px;
}

.scope-btn {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.25rem;
    padding: 0.375rem 0.5rem;
    border: none;
    background: transparent;
    color: var(--text-secondary);
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.75rem;
    transition: all 0.15s ease;
}

.scope-btn:hover {
    background: var(--bg-primary);
    color: var(--text-primary);
}

.scope-btn.active {
    background: var(--primary-color);
    color: white;
}

.scope-btn span {
    display: none;
}

@media (min-width: 400px) {
    .scope-btn span {
        display: inline;
    }
}

/* Settings panel */
.word-rep-settings {
    padding: 0.75rem;
    background: var(--bg-tertiary);
    border-radius: 6px;
    animation: slideDown 0.2s ease;
}

@keyframes slideDown {
    from {
        opacity: 0;
        transform: translateY(-10px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.settings-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.5rem 0;
    border-bottom: 1px solid var(--border-color);
}

.settings-row:last-child {
    border-bottom: none;
}

.settings-row label {
    font-size: 0.8rem;
    color: var(--text-secondary);
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.settings-row input[type="number"] {
    width: 60px;
    padding: 0.25rem 0.5rem;
    border: 1px solid var(--border-color);
    border-radius: 4px;
    font-size: 0.8rem;
    background: var(--bg-primary);
}

.settings-row input[type="checkbox"] {
    width: 16px;
    height: 16px;
    accent-color: var(--primary-color);
}

/* Ignored words */
.ignored-words-section {
    margin-top: 0.75rem;
    padding-top: 0.75rem;
    border-top: 1px solid var(--border-color);
}

.ignored-words-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 0.5rem;
    font-size: 0.8rem;
    color: var(--text-secondary);
}

.ignored-words-list {
    display: flex;
    flex-wrap: wrap;
    gap: 0.25rem;
}

.ignored-word-tag {
    display: inline-flex;
    align-items: center;
    gap: 0.25rem;
    padding: 0.2rem 0.5rem;
    background: var(--bg-primary);
    border: 1px solid var(--border-color);
    border-radius: 12px;
    font-size: 0.7rem;
    color: var(--text-secondary);
}

.ignored-word-tag i {
    opacity: 0.5;
    transition: opacity 0.15s;
}

.ignored-word-tag:hover i {
    opacity: 1;
    color: var(--accent-red);
}

/* Loading */
.word-rep-loading {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 2rem;
    color: var(--text-muted);
    gap: 0.75rem;
}

.loading-spinner {
    width: 24px;
    height: 24px;
    border: 2px solid var(--border-color);
    border-top-color: var(--primary-color);
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
}

@keyframes spin {
    to {
        transform: rotate(360deg);
    }
}

/* Empty state */
.word-rep-empty {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 2rem 1rem;
    text-align: center;
    color: var(--text-muted);
}

.word-rep-empty p {
    margin-top: 0.5rem;
    font-size: 0.8rem;
}

/* Success state */
.word-rep-success {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 1.5rem;
    text-align: center;
}

.word-rep-success p {
    margin-top: 0.5rem;
    color: var(--accent-green);
    font-weight: 500;
}

/* Stats */
.word-rep-stats {
    display: flex;
    align-items: center;
    gap: 1rem;
    padding: 0.5rem;
    background: var(--bg-tertiary);
    border-radius: 6px;
}

.stat-item {
    display: flex;
    flex-direction: column;
    align-items: center;
}

.stat-value {
    font-size: 1.1rem;
    font-weight: 600;
    color: var(--text-primary);
}

.stat-label {
    font-size: 0.65rem;
    color: var(--text-muted);
    text-transform: uppercase;
}

.stat-badges {
    display: flex;
    gap: 0.25rem;
    margin-left: auto;
}

.severity-badge {
    padding: 0.15rem 0.4rem;
    border-radius: 10px;
    font-size: 0.65rem;
    font-weight: 600;
    color: white;
}

.severity-badge.critical {
    background: var(--accent-red);
}

.severity-badge.high {
    background: var(--accent-gold);
    color: var(--text-primary);
}

.severity-badge.medium {
    background: var(--accent-blue);
}

/* List */
.word-rep-list {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    max-height: 400px;
    overflow-y: auto;
}

/* Repetition item */
.word-rep-item {
    display: flex;
    flex-direction: column;
    gap: 0.35rem;
    padding: 0.6rem;
    background: var(--bg-primary);
    border-radius: 6px;
    border-left: 3px solid var(--text-muted);
    cursor: pointer;
    transition: all 0.15s ease;
}

.word-rep-item:hover {
    background: var(--bg-tertiary);
    transform: translateX(2px);
}

.word-rep-item.critical {
    border-left-color: var(--accent-red);
}

.word-rep-item.high {
    border-left-color: var(--accent-gold);
}

.word-rep-item.medium {
    border-left-color: var(--accent-blue);
}

.word-rep-item.low {
    border-left-color: var(--text-muted);
}

.rep-item-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.rep-word {
    font-weight: 600;
    color: var(--text-primary);
}

.rep-count {
    font-weight: 700;
    font-size: 0.9rem;
}

.rep-item-meta {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.7rem;
}

.rep-density {
    color: var(--text-muted);
}

.rep-severity {
    padding: 0.1rem 0.35rem;
    border-radius: 8px;
    font-size: 0.6rem;
    font-weight: 500;
    color: white;
}

.rep-proximity {
    display: flex;
    align-items: center;
    gap: 0.2rem;
    color: var(--accent-gold);
}

.rep-item-actions {
    display: flex;
    justify-content: flex-end;
    gap: 0.25rem;
    margin-top: 0.25rem;
    opacity: 0;
    transition: opacity 0.15s;
}

.word-rep-item:hover .rep-item-actions {
    opacity: 1;
}

.btn-tiny {
    padding: 0.2rem 0.35rem !important;
}

/* Detail panel */
.word-rep-detail {
    animation: slideIn 0.2s ease;
}

@keyframes slideIn {
    from {
        opacity: 0;
        transform: translateX(10px);
    }
    to {
        opacity: 1;
        transform: translateX(0);
    }
}

.detail-header {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    padding-bottom: 0.75rem;
    border-bottom: 1px solid var(--border-color);
    margin-bottom: 0.75rem;
}

.detail-word {
    font-size: 1.1rem;
    font-weight: 600;
    color: var(--text-primary);
}

.detail-count {
    font-size: 0.8rem;
    color: var(--text-muted);
    margin-left: auto;
}

/* Suggestions */
.detail-suggestions {
    padding: 0.75rem;
    background: var(--bg-tertiary);
    border-radius: 6px;
    margin-bottom: 0.75rem;
}

.detail-suggestions h4 {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin: 0 0 0.5rem 0;
    font-size: 0.85rem;
    color: var(--text-secondary);
}

.suggestions-list {
    display: flex;
    flex-wrap: wrap;
    gap: 0.35rem;
}

.suggestion-tag {
    padding: 0.3rem 0.6rem;
    background: var(--accent-green);
    color: white;
    border-radius: 12px;
    font-size: 0.75rem;
    cursor: pointer;
    transition: all 0.15s;
}

.suggestion-tag:hover {
    background: var(--primary-color);
    transform: scale(1.05);
}

/* Occurrences */
.detail-occurrences {
    flex: 1;
    display: flex;
    flex-direction: column;
    min-height: 0;
}

.detail-occurrences h4 {
    margin: 0 0 0.75rem 0;
    font-size: 0.85rem;
    color: var(--text-secondary);
    display: flex;
    align-items: center;
    justify-content: space-between;
    flex-shrink: 0;
}

.detail-occurrences h4 .occ-count {
    font-weight: normal;
    color: var(--text-muted);
    font-size: 0.75rem;
}

.occurrences-list {
    flex: 1;
    overflow-y: auto;
    overflow-x: hidden;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    padding-right: 0.25rem;
}

.occurrence-item {
    padding: 0.75rem;
    background: var(--bg-secondary);
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.15s;
    border-left: 3px solid transparent;
    flex-shrink: 0;
}

.occurrence-item:hover {
    background: var(--bg-tertiary);
    border-left-color: var(--primary-color);
    transform: translateX(2px);
}

.occurrence-item.active {
    background: rgba(var(--primary-color-rgb), 0.1);
    border-left-color: var(--primary-color);
}

.occurrence-location {
    display: flex;
    align-items: center;
    gap: 0.35rem;
    font-size: 0.7rem;
    color: var(--accent-blue);
    margin-bottom: 0.5rem;
    font-weight: 500;
}

.occurrence-location i {
    flex-shrink: 0;
}

.occurrence-context {
    font-size: 0.8rem;
    color: var(--text-secondary);
    line-height: 1.5;
    word-break: break-word;
}

.occurrence-context mark {
    background: linear-gradient(135deg, rgba(255, 140, 66, 0.4) 0%, rgba(255, 107, 107, 0.4) 100%);
    padding: 0.15rem 0.3rem;
    border-radius: 3px;
    font-weight: 600;
    color: var(--text-primary);
}

/* Scrollbar styling */
.word-rep-list::-webkit-scrollbar,
.occurrences-list::-webkit-scrollbar,
.word-rep-sidebar-content::-webkit-scrollbar {
    width: 6px;
}

.word-rep-list::-webkit-scrollbar-track,
.occurrences-list::-webkit-scrollbar-track,
.word-rep-sidebar-content::-webkit-scrollbar-track {
    background: var(--bg-tertiary);
    border-radius: 3px;
}

.word-rep-list::-webkit-scrollbar-thumb,
.occurrences-list::-webkit-scrollbar-thumb,
.word-rep-sidebar-content::-webkit-scrollbar-thumb {
    background: var(--border-color);
    border-radius: 3px;
}

.word-rep-list::-webkit-scrollbar-thumb:hover,
.occurrences-list::-webkit-scrollbar-thumb:hover,
.word-rep-sidebar-content::-webkit-scrollbar-thumb:hover {
    background: var(--text-muted);
}

/* Responsive */
@media (max-width: 768px) {
    .word-rep-sidebar {
        width: 100%;
        left: 0;
    }

    .word-repetition-panel {
        padding: 0.5rem;
    }

    .word-rep-stats {
        flex-wrap: wrap;
        justify-content: center;
    }

    .stat-badges {
        width: 100%;
        justify-content: center;
        margin-top: 0.5rem;
        margin-left: 0;
    }
}

/* Dark theme support */
@media (prefers-color-scheme: dark) {
    .word-rep-item {
        background: var(--bg-tertiary);
    }

    .word-rep-item:hover {
        background: var(--bg-accent);
    }

    .word-rep-sidebar {
        background: var(--bg-accent);
    }
}

/* Toggle button for sidebar */
.word-rep-toggle-btn {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
    width: 100%;
    padding: 0.5rem;
    margin-top: 0.5rem;
    border: 1px dashed var(--border-color);
    border-radius: 6px;
    background: transparent;
    color: var(--text-muted);
    cursor: pointer;
    font-size: 0.8rem;
    transition: all 0.15s;
}

.word-rep-toggle-btn:hover {
    border-color: var(--primary-color);
    color: var(--primary-color);
    background: rgba(var(--primary-color-rgb), 0.05);
}

/* Integration with Structure view */
.structure-sidebar .word-repetition-panel {
    margin-top: 1rem;
    border-top: 1px solid var(--border-color);
    padding-top: 1rem;
}

/* ============================================================
 * Surlignage des répétitions dans l'éditeur
 * ============================================================ */

/* Style du surlignage dans l'éditeur */
.word-rep-highlight {
    background: linear-gradient(135deg, rgba(255, 140, 66, 0.4) 0%, rgba(255, 107, 107, 0.4) 100%);
    border-radius: 2px;
    padding: 0 2px;
    margin: 0 -2px;
    box-shadow: 0 0 0 1px rgba(255, 140, 66, 0.3);
    animation: highlightPulse 2s ease-in-out infinite;
}

@keyframes highlightPulse {
    0%, 100% {
        background: linear-gradient(135deg, rgba(255, 140, 66, 0.4) 0%, rgba(255, 107, 107, 0.4) 100%);
    }
    50% {
        background: linear-gradient(135deg, rgba(255, 140, 66, 0.6) 0%, rgba(255, 107, 107, 0.6) 100%);
    }
}

/* Item sélectionné dans la liste */
.word-rep-item.selected {
    background: rgba(var(--primary-color-rgb), 0.15);
    border-left-color: var(--primary-color);
    box-shadow: 0 2px 8px rgba(var(--primary-color-rgb), 0.2);
}

.word-rep-item.selected .rep-word {
    color: var(--primary-color);
}

/* Badge de compteur sur le highlight */
.word-rep-highlight[data-count]::after {
    content: attr(data-count);
    position: absolute;
    top: -8px;
    right: -8px;
    background: var(--primary-color);
    color: white;
    font-size: 0.6rem;
    padding: 1px 4px;
    border-radius: 8px;
    font-weight: 600;
}

/* Animation de focus pour navigation vers occurrence */
.word-rep-highlight-focus {
    animation: highlightFocus 0.5s ease-out;
    box-shadow: 0 0 0 3px var(--primary-color), 0 0 20px rgba(255, 140, 66, 0.6);
}

@keyframes highlightFocus {
    0% {
        transform: scale(1.3);
        box-shadow: 0 0 0 6px var(--primary-color), 0 0 30px rgba(255, 140, 66, 0.8);
    }
    100% {
        transform: scale(1);
        box-shadow: 0 0 0 3px var(--primary-color), 0 0 20px rgba(255, 140, 66, 0.6);
    }
}

/* Mode sombre */
@media (prefers-color-scheme: dark) {
    .word-rep-highlight {
        background: linear-gradient(135deg, rgba(255, 140, 66, 0.3) 0%, rgba(255, 107, 107, 0.3) 100%);
        box-shadow: 0 0 0 1px rgba(255, 140, 66, 0.4);
    }
}

/* ========== 14.product-tour.css ========== */
/* ============================================
   PRODUCT TOUR STYLES
   ============================================ */

/* Custom Driver.js theme for Plume */
.driver-popover {
    background: var(--bg-primary);
    color: var(--text-primary);
    border: 1px solid var(--border-color);
    border-radius: 12px;
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
    max-width: 400px;
}

.driver-popover-title {
    font-size: 1.25rem;
    font-weight: 600;
    color: var(--text-primary);
    margin-bottom: 0.75rem;
    padding-bottom: 0.75rem;
    border-bottom: 1px solid var(--border-color);
}

.driver-popover-description {
    font-size: 0.95rem;
    line-height: 1.6;
    color: var(--text-secondary);
}

.driver-popover-description p {
    margin-bottom: 0.75rem;
}

.driver-popover-description ul {
    margin: 0.5rem 0;
    padding-left: 1.5rem;
}

.driver-popover-description li {
    margin-bottom: 0.5rem;
}

.driver-popover-description strong {
    color: var(--text-primary);
    font-weight: 600;
}

/* Progress indicator */
.driver-popover-progress-text {
    font-size: 0.85rem;
    color: var(--text-muted);
    margin-bottom: 1rem;
    text-align: center;
}

/* Navigation buttons */
.driver-popover-footer {
    display: flex;
    gap: 0.5rem;
    margin-top: 1rem;
    padding-top: 1rem;
    border-top: 1px solid var(--border-color);
}

.driver-popover-btn {
    padding: 0.5rem 1rem;
    border-radius: 6px;
    font-size: 0.9rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
    border: none;
}

.driver-popover-next-btn {
    background: var(--primary-color);
    color: white;
    flex: 1;
}

.driver-popover-next-btn:hover {
    background: var(--primary-hover);
    transform: translateY(-1px);
}

.driver-popover-prev-btn {
    background: var(--bg-secondary);
    color: var(--text-primary);
    border: 1px solid var(--border-color);
}

.driver-popover-prev-btn:hover {
    background: var(--bg-tertiary);
}

.driver-popover-close-btn {
    position: absolute;
    top: 1rem;
    right: 1rem;
    background: transparent;
    border: none;
    color: var(--text-muted);
    cursor: pointer;
    font-size: 1.5rem;
    line-height: 1;
    padding: 0;
    width: 24px;
    height: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.driver-popover-close-btn:hover {
    color: var(--text-primary);
}

/* Highlighted element styling */
.driver-active-element {
    outline: 3px solid var(--primary-color) !important;
    outline-offset: 4px;
    border-radius: 8px;
}

/* Overlay */
.driver-overlay {
    background: rgba(0, 0, 0, 0.15);
    animation: fadeIn 0.3s ease;
}

@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

/* Arrow styling */
.driver-popover-arrow {
    border-color: var(--bg-primary);
}

.driver-popover-arrow-side-top {
    border-top-color: var(--bg-primary);
}

.driver-popover-arrow-side-bottom {
    border-bottom-color: var(--bg-primary);
}

.driver-popover-arrow-side-left {
    border-left-color: var(--bg-primary);
}

.driver-popover-arrow-side-right {
    border-right-color: var(--bg-primary);
}

/* Welcome modal */
.tour-welcome-modal {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: var(--bg-primary);
    border: 1px solid var(--border-color);
    border-radius: 16px;
    padding: 2rem;
    max-width: 500px;
    width: 90%;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    z-index: 10000;
    animation: slideIn 0.3s ease;
}

@keyframes slideIn {
    from {
        opacity: 0;
        transform: translate(-50%, -45%);
    }
    to {
        opacity: 1;
        transform: translate(-50%, -50%);
    }
}

.tour-welcome-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.15);
    z-index: 9999;
    animation: fadeIn 0.3s ease;
}

.tour-welcome-header {
    text-align: center;
    margin-bottom: 1.5rem;
}

.tour-welcome-icon {
    font-size: 3rem;
    margin-bottom: 1rem;
}

.tour-welcome-title {
    font-size: 1.75rem;
    font-weight: 600;
    color: var(--text-primary);
    margin-bottom: 0.5rem;
}

.tour-welcome-subtitle {
    font-size: 1rem;
    color: var(--text-secondary);
}

.tour-welcome-content {
    margin-bottom: 2rem;
    line-height: 1.6;
    color: var(--text-secondary);
}

.tour-welcome-actions {
    display: flex;
    gap: 1rem;
}

.tour-welcome-btn {
    flex: 1;
    padding: 0.75rem 1.5rem;
    border-radius: 8px;
    font-size: 1rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
    border: none;
}

.tour-welcome-btn-primary {
    background: var(--primary-color);
    color: white;
}

.tour-welcome-btn-primary:hover {
    background: var(--primary-hover);
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}

.tour-welcome-btn-secondary {
    background: var(--bg-secondary);
    color: var(--text-primary);
    border: 1px solid var(--border-color);
}

.tour-welcome-btn-secondary:hover {
    background: var(--bg-tertiary);
}

.tour-welcome-checkbox {
    margin-top: 1rem;
    text-align: center;
}

.tour-welcome-checkbox label {
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.9rem;
    color: var(--text-muted);
    cursor: pointer;
}

.tour-welcome-checkbox input[type="checkbox"] {
    cursor: pointer;
}

/* Tour button in header */
.tour-trigger-btn {
    background: transparent;
    border: 1px solid var(--border-color);
    color: var(--text-secondary);
    padding: 0.5rem;
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
}

.tour-trigger-btn:hover {
    background: var(--bg-secondary);
    color: var(--primary-color);
    border-color: var(--primary-color);
}

.tour-trigger-btn i {
    width: 18px;
    height: 18px;
}

/* Mobile responsive styles */
@media (max-width: 768px) {
    .driver-popover {
        max-width: 90vw;
        margin: 1rem;
    }
    
    .tour-welcome-modal {
        padding: 1.5rem;
        max-width: 90%;
    }
    
    .tour-welcome-actions {
        flex-direction: column;
    }
    
    .driver-popover-footer {
        flex-direction: column;
    }
    
    .driver-popover-next-btn,
    .driver-popover-prev-btn {
        width: 100%;
    }
}

/* Dark theme adjustments */
@media (prefers-color-scheme: dark) {
    .driver-overlay {
        background: rgba(0, 0, 0, 0.15);
    }
}

/* Print styles - hide tour elements */
@media print {
    .driver-popover,
    .driver-overlay,
    .tour-welcome-modal,
    .tour-welcome-overlay,
    .tour-trigger-btn {
        display: none !important;
    }
}

/* Accessibility - high contrast mode */
@media (prefers-contrast: high) {
    .driver-active-element {
        outline-width: 4px;
    }
    
    .driver-popover {
        border-width: 2px;
    }
}

/* Reduced motion */
@media (prefers-reduced-motion: reduce) {
    .driver-popover,
    .tour-welcome-modal,
    .driver-overlay,
    .tour-welcome-overlay {
        animation: none;
    }
}

/* ========== js-refactor/synonyms/synonyms.css ========== */
/* ============================================================
   synonyms.css - Styles pour le dictionnaire de synonymes
   ============================================================ */

/* Modal overlay - Matches app modal style */
.synonyms-modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(var(--bg-accent-rgb), 0.6);
    backdrop-filter: blur(4px);
    z-index: 10000;
    justify-content: center;
    align-items: center;
    opacity: 0;
    transition: opacity 0.2s ease;
}

.synonyms-modal.synonyms-modal-open {
    display: flex;
    opacity: 1;
}

/* Modal content */
.synonyms-modal-content {
    background: var(--bg-primary);
    border-radius: 12px;
    width: 90%;
    max-width: 600px;
    max-height: 80vh;
    display: flex;
    flex-direction: column;
    box-shadow: 0 8px 32px var(--shadow);
    border: 2px solid var(--border-color);
    animation: synonyms-slide-in 0.2s ease;
}

@keyframes synonyms-slide-in {
    from {
        transform: translateY(-20px);
        opacity: 0;
    }
    to {
        transform: translateY(0);
        opacity: 1;
    }
}

/* Header */
.synonyms-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 16px 24px;
    border-bottom: 2px solid var(--accent-blue);
}

.synonyms-header h3 {
    margin: 0;
    font-size: 1.2rem;
    font-weight: 600;
    font-family: 'Noto Serif JP', serif;
    color: var(--text-primary);
}

.synonyms-close-btn {
    background: none;
    border: none;
    cursor: pointer;
    padding: 6px;
    color: var(--text-muted);
    border-radius: 6px;
    transition: all 0.15s ease;
    display: flex;
    align-items: center;
    justify-content: center;
}

.synonyms-close-btn:hover {
    color: var(--accent-red);
    background: rgba(var(--accent-red-rgb), 0.1);
}

/* Search box */
.synonyms-search-box {
    position: relative;
    padding: 16px 24px;
}

.synonyms-search-box input {
    width: 100%;
    padding: 12px 16px 12px 44px;
    font-size: 1rem;
    font-family: 'Crimson Pro', serif;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    background: var(--bg-secondary);
    color: var(--text-primary);
    outline: none;
    transition: border-color 0.15s ease, box-shadow 0.15s ease;
    box-sizing: border-box;
}

.synonyms-search-box input::placeholder {
    color: var(--text-muted);
    font-style: italic;
}

.synonyms-search-box input:focus {
    border-color: var(--accent-blue);
    background: var(--bg-primary);
    box-shadow: 0 0 0 3px rgba(var(--accent-blue-rgb), 0.15);
}

.synonyms-search-icon {
    position: absolute;
    left: 38px;
    top: 50%;
    transform: translateY(-50%);
    color: var(--text-muted);
    pointer-events: none;
}

/* Tabs */
.synonyms-tabs {
    display: flex;
    gap: 8px;
    padding: 0 24px 12px;
    border-bottom: 1px solid var(--border-color);
}

.synonyms-tab {
    flex: 1;
    padding: 8px 12px;
    font-size: 0.9rem;
    font-weight: 500;
    border: none;
    background: transparent;
    color: var(--text-muted);
    cursor: pointer;
    border-radius: 6px;
    transition: all 0.15s ease;
    font-family: 'Crimson Pro', serif;
}

.synonyms-tab:hover {
    background: var(--bg-secondary);
    color: var(--text-primary);
}

.synonyms-tab.active {
    background: var(--accent-blue);
    color: white; /* Always white on accent color usually */
}

/* Status */
.synonyms-status {
    display: none;
    padding: 12px 24px;
    font-size: 0.9rem;
    text-align: center;
    color: var(--text-muted);
    font-style: italic;
}

.synonyms-status-loading {
    color: var(--accent-blue);
    font-style: normal;
}

.synonyms-status-loading::after {
    content: '';
    animation: synonyms-dots 1.5s infinite;
}

@keyframes synonyms-dots {
    0%, 20% { content: '.'; }
    40% { content: '..'; }
    60%, 100% { content: '...'; }
}

.synonyms-status-error {
    color: var(--error-color);
}

.synonyms-status-empty {
    color: var(--text-muted);
}

/* Results */
.synonyms-results {
    flex: 1;
    overflow-y: auto;
    padding: 16px 24px;
    min-height: 150px;
    max-height: 400px;
}

.synonyms-category {
    margin-bottom: 20px;
}

.synonyms-category:last-child {
    margin-bottom: 0;
}

.synonyms-category-label {
    font-size: 0.8rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: var(--text-muted);
    margin-bottom: 8px;
    padding-left: 2px;
}

.synonyms-words {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
}

.synonyms-word-item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    padding: 6px 12px;
    background: var(--bg-secondary);
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.15s ease;
    border: 1px solid var(--border-color);
}

.synonyms-word-item:hover {
    background: var(--bg-tertiary);
    border-color: var(--accent-blue);
    transform: translateY(-1px);
}

.synonyms-word {
    font-size: 0.95rem;
    color: var(--text-primary);
    font-family: 'Crimson Pro', serif;
}

.synonyms-score {
    font-size: 0.75rem;
    color: var(--text-muted);
    background: var(--bg-primary); /* Was score-bg */
    padding: 2px 6px;
    border-radius: 4px;
    border: 1px solid var(--border-color);
}

.synonyms-word-actions {
    display: none;
    gap: 4px;
    margin-left: 6px;
    padding-left: 6px;
    border-left: 1px solid var(--border-color);
}

.synonyms-word-item:hover .synonyms-word-actions {
    display: flex;
    animation: fade-in 0.2s ease;
}

@keyframes fade-in {
    from { opacity: 0; }
    to { opacity: 1; }
}

.synonyms-action-btn {
    background: none;
    border: none;
    padding: 2px;
    cursor: pointer;
    color: var(--text-muted);
    border-radius: 4px;
    transition: all 0.15s ease;
    display: flex;
    align-items: center;
    justify-content: center;
}

.synonyms-action-btn:hover {
    color: var(--primary-color);
    background: rgba(var(--primary-color-rgb), 0.1);
}

/* Recent searches */
.synonyms-recent {
    padding: 12px 24px;
    border-top: 1px solid var(--border-color);
    display: flex;
    align-items: center;
    gap: 12px;
    flex-wrap: wrap;
    background: var(--bg-secondary);
    border-radius: 0 0 12px 12px;
}

.synonyms-recent-label {
    font-size: 0.85rem;
    color: var(--text-muted);
    flex-shrink: 0;
    font-weight: 500;
}

.synonyms-recent-list {
    display: flex;
    gap: 6px;
    flex-wrap: wrap;
    flex: 1;
}

.synonyms-recent-item {
    font-size: 0.85rem;
    padding: 4px 10px;
    background: var(--bg-primary);
    border: 1px solid var(--border-color);
    border-radius: 12px;
    color: var(--text-secondary);
    cursor: pointer;
    transition: all 0.15s ease;
    font-family: 'Crimson Pro', serif;
}

.synonyms-recent-item:hover {
    background: var(--bg-primary);
    border-color: var(--accent-blue);
    color: var(--text-primary);
}

.synonyms-recent-empty {
    font-size: 0.85rem;
    color: var(--text-muted);
    font-style: italic;
}

/* Toast notification */
.synonyms-toast {
    position: fixed;
    bottom: 30px;
    left: 50%;
    transform: translateX(-50%);
    padding: 12px 24px;
    background: var(--bg-accent);
    color: var(--bg-primary); /* Inverted text */
    border-radius: 8px;
    font-size: 0.9rem;
    z-index: 10001;
    box-shadow: 0 4px 12px var(--shadow);
    animation: synonyms-toast-in 0.2s ease;
    font-weight: 500;
}

@keyframes synonyms-toast-in {
    from {
        transform: translateX(-50%) translateY(10px);
        opacity: 0;
    }
    to {
        transform: translateX(-50%) translateY(0);
        opacity: 1;
    }
}

.synonyms-toast-fade {
    opacity: 0;
    transition: opacity 0.3s ease;
}

/* Scrollbar styling */
.synonyms-results::-webkit-scrollbar {
    width: 6px;
}

.synonyms-results::-webkit-scrollbar-track {
    background: transparent;
}

.synonyms-results::-webkit-scrollbar-thumb {
    background: var(--border-color);
    border-radius: 3px;
}

.synonyms-results::-webkit-scrollbar-thumb:hover {
    background: var(--text-muted);
}

/* Responsive */
@media (max-width: 600px) {
    .synonyms-modal-content {
        width: 95%;
        max-height: 90vh;
        margin: 20px;
    }

    .synonyms-tabs {
        flex-wrap: wrap;
    }

    .synonyms-tab {
        flex: 1 1 45%;
    }
}

    </style>
</head>
<body> <!-- Mobile Menu Handle (poignée latérale) -->
    <div class="mobile-menu-handle" onclick="toggleMobileSidebar()"></div> <!-- Mobile Sidebar Overlay -->
    <div class="sidebar-overlay" onclick="toggleMobileSidebar()"></div>
    <!-- Mobile Navigation Dropdown (déplacé hors du grid) -->
    <div class="mobile-nav-dropdown" id="mobileNavDropdown">
        <div class="mobile-nav-section">
            <div class="mobile-nav-section-title"><i data-lucide="pen-tool"></i> écriture</div> <button
                class="mobile-nav-item active" onclick="switchViewMobile('editor')" data-view="editor"> <span
                    class="mobile-nav-item-icon"><i data-lucide="pen-line"></i></span> <span>Structure</span> </button>
            <button class="mobile-nav-item" onclick="switchViewMobile('corkboard')" data-view="corkboard"> <span
                    class="mobile-nav-item-icon"><i data-lucide="layout-grid"></i></span> <span>Tableau</span> </button>
            <button class="mobile-nav-item" onclick="switchViewMobile('plot')" data-view="plot"> <span
                    class="mobile-nav-item-icon"><i data-lucide="trending-up"></i></span> <span>Intrigue</span>
            </button> <button class="mobile-nav-item" onclick="switchViewMobile('arcs')" data-view="arcs"> <span
                    class="mobile-nav-item-icon"><i data-lucide="git-commit-horizontal"></i></span> <span>Arcs
                    Narratifs</span> </button> <button class="mobile-nav-item" onclick="switchViewMobile('thriller')"
                data-view="thriller"> <span class="mobile-nav-item-icon"><i data-lucide="hat-glasses"></i></span>
                <span>Thriller</span> </button> <button class="mobile-nav-item" onclick="switchViewMobile('storygrid')"
                data-view="storygrid"> <span class="mobile-nav-item-icon"><i data-lucide="grid-3x3"></i></span>
                <span>Storygrid</span> </button>
        </div>
        <div class="mobile-nav-section">
            <div class="mobile-nav-section-title"><i data-lucide="database"></i> Base de données</div> <button
                class="mobile-nav-item" onclick="switchViewMobile('characters')" data-view="characters"> <span
                    class="mobile-nav-item-icon"><i data-lucide="users"></i></span> <span>Personnages</span> </button>
            <button class="mobile-nav-item" onclick="switchViewMobile('world')" data-view="world"> <span
                    class="mobile-nav-item-icon"><i data-lucide="globe"></i></span> <span>Univers</span> </button>
            <button class="mobile-nav-item" onclick="switchViewMobile('codex')" data-view="codex"> <span
                    class="mobile-nav-item-icon"><i data-lucide="book-open"></i></span> <span>Codex</span> </button>
            <button class="mobile-nav-item" onclick="switchViewMobile('notes')" data-view="notes"> <span
                    class="mobile-nav-item-icon"><i data-lucide="sticky-note"></i></span> <span>Notes</span> </button>
        </div>
        <div class="mobile-nav-section">
            <div class="mobile-nav-section-title"><i data-lucide="eye"></i> Visualisation</div> <button
                class="mobile-nav-item" onclick="switchViewMobile('mindmap')" data-view="mindmap"> <span
                    class="mobile-nav-item-icon"><i data-lucide="git-branch"></i></span> <span>Mindmap</span> </button>
            <button class="mobile-nav-item" onclick="switchViewMobile('relations')" data-view="relations"> <span
                    class="mobile-nav-item-icon"><i data-lucide="link"></i></span> <span>Relations</span> </button>
            <button class="mobile-nav-item" onclick="switchViewMobile('map')" data-view="map"> <span
                    class="mobile-nav-item-icon"><i data-lucide="map"></i></span> <span>Carte</span> </button> <button
                class="mobile-nav-item" onclick="switchViewMobile('timelineviz')" data-view="timelineviz"> <span
                    class="mobile-nav-item-icon"><i data-lucide="clock"></i></span> <span>Timeline</span> </button>
        </div>
        <div class="mobile-nav-section">
            <div class="mobile-nav-section-title"><i data-lucide="wrench"></i> Outils</div> <button
                class="mobile-nav-item" onclick="switchViewMobile('stats')" data-view="stats"> <span
                    class="mobile-nav-item-icon"><i data-lucide="bar-chart-3"></i></span> <span>Stats</span> </button>
            <button class="mobile-nav-item" onclick="switchViewMobile('analysis')" data-view="analysis"> <span
                    class="mobile-nav-item-icon"><i data-lucide="scan-search"></i></span> <span>Analyse</span> </button>
        </div>
        <div class="mobile-nav-section">
            <div class="mobile-nav-section-title"><i data-lucide="history"></i> Historique</div> <button
                class="mobile-nav-item" onclick="switchViewMobile('versions')" data-view="versions"> <span
                    class="mobile-nav-item-icon"><i data-lucide="history"></i></span> <span>Snapshots</span> </button>
        </div>
        <div class="mobile-nav-section">
            <div class="mobile-nav-section-title"><i data-lucide="settings"></i> Actions</div> <button
                class="mobile-nav-item" onclick="openProjectsModal(); toggleMobileNav();"> <span
                    class="mobile-nav-item-icon"><i data-lucide="folder-open"></i></span> <span>Mes Projets</span>
            </button> <button class="mobile-nav-item" onclick="openThemeManager(); toggleMobileNav();"> <span
                    class="mobile-nav-item-icon"><i data-lucide="palette"></i></span> <span>Thèmes</span> </button>
            <button class="mobile-nav-item" onclick="undo(); toggleMobileNav();" id="mobileUndoBtn"> <span
                    class="mobile-nav-item-icon"><i data-lucide="undo-2"></i></span> <span>Annuler</span> </button>
            <button class="mobile-nav-item" onclick="redo(); toggleMobileNav();" id="mobileRedoBtn"> <span
                    class="mobile-nav-item-icon"><i data-lucide="redo-2"></i></span> <span>Rétablir</span> </button>
            <button class="mobile-nav-item" onclick="showBackupMenu(); toggleMobileNav();"> <span
                    class="mobile-nav-item-icon"><i data-lucide="download"></i></span> <span>Sauvegarde/Export</span>
            </button>
        </div>
    </div> <!-- Barre de progression d'écriture (mode focus) - hors du grid -->
    <div class="writing-progress-bar">
        <div class="writing-progress-fill" id="writingProgressFill"></div>
        <div class="writing-progress-text" id="positionIndicator"> Mot 0 / 0 </div>
    </div>
    <div class="app-container"> <!-- Top Header -->
        <div class="app-header">
            <div class="app-logo" onclick="renameProject()" style="cursor: pointer;"
                title="Cliquer pour renommer le projet"> <span class="app-logo-icon"><i
                        data-lucide="feather"></i></span> <span id="headerProjectTitle">Plume</span> <i
                    data-lucide="pencil" style="width: 12px; height: 12px; opacity: 0.5; margin-left: 4px;"></i> </div>
            <!-- Mobile Navigation Toggle --> <button class="mobile-nav-toggle-btn" onclick="toggleMobileNav()"
                id="mobileNavToggleBtn"> <i data-lucide="menu"></i> </button>
            <nav class="header-nav"> <!-- Section 1 : Structure, Tableau, Intrigue -->
                <div class="nav-group"> <button class="nav-btn active" onclick="switchView('editor')"
                        id="header-tab-editor"> <span class="nav-btn-icon"><i data-lucide="pen-line"></i></span> <span
                            class="nav-btn-text">Structure</span> </button> <button class="nav-btn"
                        onclick="switchView('corkboard')" id="header-tab-corkboard"> <span class="nav-btn-icon"><i
                                data-lucide="layout-grid"></i></span> <span class="nav-btn-text">Tableau</span>
                    </button> <button class="nav-btn" onclick="switchView('plot')" id="header-tab-plot"> <span
                            class="nav-btn-icon"><i data-lucide="trending-up"></i></span> <span
                            class="nav-btn-text">Intrigue</span> </button> <button class="nav-btn"
                        onclick="switchView('arcs')" id="header-tab-arcs"> <span class="nav-btn-icon"><i
                                data-lucide="git-commit-horizontal"></i></span> <span class="nav-btn-text">Arcs</span>
                    </button> <button class="nav-btn" onclick="switchView('thriller')" id="header-tab-thriller"> <span
                            class="nav-btn-icon"><i data-lucide="hat-glasses"></i></span> <span
                            class="nav-btn-text">Thriller</span> </button> <button class="nav-btn"
                        onclick="switchView('storygrid')" id="header-tab-storygrid"> <span class="nav-btn-icon"><i
                                data-lucide="grid-3x3"></i></span> <span class="nav-btn-text">StoryGrid</span> </button>
                </div> <!-- Section 2 : Personnages, Univers, Codex, Notes -->
                <div class="nav-group"> <button class="nav-btn" onclick="switchView('characters')"
                        id="header-tab-characters"> <span class="nav-btn-icon"><i data-lucide="users"></i></span> <span
                            class="nav-btn-text">Personnages</span> </button> <button class="nav-btn"
                        onclick="switchView('world')" id="header-tab-world"> <span class="nav-btn-icon"><i
                                data-lucide="globe"></i></span> <span class="nav-btn-text">Univers</span> </button>
                    <button class="nav-btn" onclick="switchView('codex')" id="header-tab-codex"> <span
                            class="nav-btn-icon"><i data-lucide="book-open"></i></span> <span
                            class="nav-btn-text">Codex</span> </button> <button class="nav-btn"
                        onclick="switchView('notes')" id="header-tab-notes"> <span class="nav-btn-icon"><i
                                data-lucide="sticky-note"></i></span> <span class="nav-btn-text">Notes</span> </button>
                </div> <!-- Section 3 : Mindmap, Relations, Carte, Timeline -->
                <div class="nav-group"> <button class="nav-btn" onclick="switchView('mindmap')" id="header-tab-mindmap">
                        <span class="nav-btn-icon"><i data-lucide="git-branch"></i></span> <span
                            class="nav-btn-text">Mindmap</span> </button> <button class="nav-btn"
                        onclick="switchView('relations')" id="header-tab-relations"> <span class="nav-btn-icon"><i
                                data-lucide="link"></i></span> <span class="nav-btn-text">Relations</span> </button>
                    <button class="nav-btn" onclick="switchView('map')" id="header-tab-map"> <span
                            class="nav-btn-icon"><i data-lucide="map"></i></span> <span
                            class="nav-btn-text">Carte</span> </button> <button class="nav-btn"
                        onclick="switchView('timelineviz')" id="header-tab-timeline-viz"> <span class="nav-btn-icon"><i
                                data-lucide="clock"></i></span> <span class="nav-btn-text">Timeline</span> </button>
                </div> <!-- Section 4 : Stats, Analyse -->
                <div class="nav-group"> <button class="nav-btn" onclick="switchView('stats')" id="header-tab-stats">
                        <span class="nav-btn-icon"><i data-lucide="bar-chart-3"></i></span> <span
                            class="nav-btn-text">Stats</span> </button> <button class="nav-btn"
                        onclick="switchView('analysis')" id="header-tab-analysis"> <span class="nav-btn-icon"><i
                                data-lucide="scan-search"></i></span> <span class="nav-btn-text">Analyse</span>
                    </button> </div> <!-- Section 5 : Snapshots -->
                <div class="nav-group"> <button class="nav-btn" onclick="switchView('versions')"
                        id="header-tab-versions"> <span class="nav-btn-icon"><i data-lucide="history"></i></span> <span
                            class="nav-btn-text">Snapshots</span> </button> </div>
            </nav> <!-- Actions à droite -->
            <div class="header-actions">
                <div id="headerStatsContainer"
                    style="font-size: 0.85rem; color: var(--text-muted); margin-right: 0.5rem;"> <span
                        id="headerTotalWords">0 mots</span> <span id="headerStatsSeparator"> / </span> <span
                        id="headerTotalChapters">0 chapitres</span> </div> <!-- Split View Toggle --> <button
                    class="split-mode-toggle" onclick="toggleSplitView()" id="splitModeToggle"
                    title="Activer/désactiver le mode split (vue côte à côte)"> <i data-lucide="columns-2"
                        style="width:14px;height:14px;"></i> <span>Split</span> </button>
                <!-- Storage badge intégré dans le header -->
                <div class="storage-badge-header status-ok" id="storage-badge" onclick="showStorageDetails()"
                    title="Espace de stockage"> <span class="storage-icon"><i data-lucide="hard-drive"></i></span> <span
                        id="storage-percentage">...</span> </div>
                <button class="header-action-btn" onclick="undo()" id="headerUndoBtn" title="Annuler (Ctrl+Z)"
                    disabled><i data-lucide="undo-2"></i></button>
                <button class="header-action-btn" onclick="redo()" id="headerRedoBtn" title="Rétablir (Ctrl+Y)"
                    disabled><i data-lucide="redo-2"></i></button>
                <button class="header-action-btn" onclick="togglePomodoroPopup()" id="pomodoroHeaderBtn"
                    title="Timer Pomodoro"><i data-lucide="timer"></i></button>
                <button class="header-action-btn" onclick="openImportChapterModal()" title="Importer un texte (.docx, .txt, .md, .epub)"><i
                        data-lucide="file-up"></i></button>
                <button class="header-action-btn" onclick="showBackupMenu()" title="Sauvegardes et exports"><i
                        data-lucide="download"></i></button>
                <button class="header-action-btn" onclick="openThemeManager()" title="Gérer les thèmes"><i
                        data-lucide="palette"></i></button>
                <button class="header-action-btn" onclick="openProjectsModal()" title="Gérer les projets"><i
                        data-lucide="folder-open"></i></button>
            </div>
        </div>
        <!-- Pomodoro Popup -->
        <div class="pomodoro-popup" id="pomodoroPopup">
            <div class="pomodoro-popup-header">
                <span>Pomodoro</span>
                <span class="pomodoro-popup-close" onclick="togglePomodoroPopup()"><i data-lucide="x"
                        style="width:14px;height:14px;"></i></span>
            </div>
            <div class="pomodoro-popup-content">
                <div class="pomodoro-display" id="pomodoroDisplay">25:00</div>
                <div class="pomodoro-controls">
                    <button class="btn btn-small" onclick="startPomodoro()"><i data-lucide="play"
                            style="width:14px;height:14px;"></i></button>
                    <button class="btn btn-small" onclick="pausePomodoro()"><i data-lucide="pause"
                            style="width:14px;height:14px;"></i></button>
                    <button class="btn btn-small" onclick="resetPomodoro()"><i data-lucide="rotate-ccw"
                            style="width:14px;height:14px;"></i></button>
                </div>
                <div class="pomodoro-stats">
                    <div class="pomodoro-stat">
                        <span class="pomodoro-stat-value" id="pomodorosCompleted">0</span>
                        <span class="pomodoro-stat-label">sessions</span>
                    </div>
                </div>
            </div>
        </div>
        <!-- Conteneur principal (sidebar + versions + éditeur) -->
        <div class="app-content">
            <!-- Sidebar Navigation -->
            <div class="sidebar">
                <!-- Poignée de redimensionnement -->
                <div class="sidebar-resize-handle" id="sidebarResizeHandle">
                    <div class="resize-handle-line"></div>
                </div>
                <div class="sidebar-header">
                    <div class="search-container">
                        <input type="text" class="search-input" id="globalSearch"
                            placeholder="Rechercher dans tout le projet..." oninput="performGlobalSearch(this.value)"
                            onfocus="this.select()">
                        <i data-lucide="search" class="search-icon"></i>
                        <div class="search-results" id="searchResults"></div>
                    </div>
                </div>
                <!-- Barre de progression globale -->
                <div class="project-progress-bar" id="projectProgressBar">
                    <div class="progress-stats">
                        <span id="progressStatsText">0 scènes</span>
                        <span id="progressPercent">0%</span>
                    </div>
                    <div class="progress-track">
                        <div class="progress-segment complete" id="progressComplete" style="width: 0%"></div>
                        <div class="progress-segment review" id="progressReview" style="width: 0%"></div>
                        <div class="progress-segment progress" id="progressProgress" style="width: 0%"></div>
                        <div class="progress-segment draft" id="progressDraft" style="width: 0%"></div>
                    </div>
                </div>
                <!-- Filtres de statut -->
                <div class="status-filters" id="statusFilters">
                    <button class="status-filter-btn draft active" onclick="toggleStatusFilter('draft')"
                        data-status="draft">
                        <span class="status-filter-dot draft"></span>
                        <span>Brouillon</span>
                        <span class="status-filter-count" id="countDraft">0</span>
                    </button>
                    <button class="status-filter-btn progress active" onclick="toggleStatusFilter('progress')"
                        data-status="progress">
                        <span class="status-filter-dot progress"></span>
                        <span>En cours</span>
                        <span class="status-filter-count" id="countProgress">0</span>
                    </button>
                    <button class="status-filter-btn complete active" onclick="toggleStatusFilter('complete')"
                        data-status="complete">
                        <span class="status-filter-dot complete"></span>
                        <span>Terminé</span>
                        <span class="status-filter-count" id="countComplete">0</span>
                    </button>
                    <button class="status-filter-btn review active" onclick="toggleStatusFilter('review')"
                        data-status="review">
                        <span class="status-filter-dot review"></span>
                        <span>À réviser</span>
                        <span class="status-filter-count" id="countReview">0</span>
                    </button>
                </div>
                <!-- Outils de scène -->
                <div class="scene-tools" id="sceneTools">
                    <button class="scene-tool-btn" onclick="toggleVersionsSidebar()" id="headerVersionsToggle"
                        title="Afficher/masquer les versions de scène">
                        <i data-lucide="git-branch"></i>
                        <span>Versions</span>
                    </button>
                    <button class="scene-tool-btn" onclick="toggleAnnotationsPanel()" id="sidebarAnnotationsBtn"
                        title="Afficher/masquer les annotations">
                        <i data-lucide="message-square"></i>
                        <span>Annotations</span>
                        <span class="scene-tool-badge" id="annotationsBadge" style="display: none;">0</span>
                    </button>
                    <button class="scene-tool-btn" onclick="toggleTodosPanel()" id="sidebarTodosBtn"
                        title="Afficher/masquer les TODOs">
                        <i data-lucide="check-square"></i>
                        <span>TODOs</span>
                        <span class="scene-tool-badge" id="todosBadge" style="display: none;">0</span>
                    </button>
                    <button class="scene-tool-btn" onclick="toggleArcScenePanel()" id="sidebarArcsBtn"
                        title="Afficher/masquer les Arcs Narratifs">
                        <i data-lucide="git-commit-horizontal"></i>
                        <span>Arcs</span>
                    </button>
                    <button class="scene-tool-btn" onclick="PlotGridUI.toggleSidebar()" id="sidebarPlotBtn"
                        title="Afficher/masquer l'Intrigue">
                        <i data-lucide="trending-up"></i>
                        <span>Intrigue</span>
                    </button>
                </div>
                <!-- Boutons déplier/replier tout -->
                <div class="tree-collapse-toolbar" id="treeCollapseToolbar">
                    <button class="tree-collapse-btn" onclick="expandAllTree()" title="Tout déplier">
                        <i data-lucide="unfold-vertical" style="width:12px;height:12px;"></i>
                        <span>Déplier</span>
                    </button>
                    <button class="tree-collapse-btn" onclick="collapseAllTree()" title="Tout replier">
                        <i data-lucide="fold-vertical" style="width:12px;height:12px;"></i>
                        <span>Replier</span>
                    </button>
                    <button class="tree-collapse-btn" onclick="openStructureOrganizer()" title="Réorganiser la structure (vue globale)">
                        <i data-lucide="layout-list" style="width:12px;height:12px;"></i>
                        <span>Organiser</span>
                    </button>
                </div>
                <div class="chapters-list" id="chaptersList">
                    <!-- Structure will be dynamically inserted here -->
                </div>
                <div class="database-list" id="charactersList" style="display: none;">
                    <!-- Characters will be dynamically inserted here -->
                </div>
                <div class="database-list" id="worldList" style="display: none;">
                    <!-- World elements will be dynamically inserted here -->
                </div>
                <div class="database-list" id="timelineList" style="display: none;">
                    <!-- Timeline events will be dynamically inserted here -->
                </div>
                <div class="database-list" id="notesList" style="display: none;">
                    <!-- Notes will be dynamically inserted here -->
                </div>
                <div class="database-list" id="codexList" style="display: none;">
                    <!-- Codex entries will be dynamically inserted here -->
                </div>
                <div class="database-list" id="arcsList" style="display: none;">
                    <!-- Narrative arcs will be dynamically inserted here -->
                </div>
                <div class="database-list" id="statsList" style="display: none;">
                    <!-- Statistics will be dynamically inserted here -->
                </div>
                <div class="database-list" id="versionsList" style="display: none;">
                    <!-- Versions will be dynamically inserted here -->
                </div>
                <div class="database-list" id="analysisList" style="display: none;">
                    <!-- Analysis will be dynamically inserted here -->
                </div>
                <div class="database-list" id="corkboardList" style="display: none;">
                    <!-- Cork Board info will be here -->
                </div>
                <div class="database-list" id="mindmapList" style="display: none;">
                    <!-- Mindmap will be here -->
                </div>
                <div class="database-list" id="plotList" style="display: none;">
                    <!-- Plot graph will be here -->
                </div>
                <div class="database-list" id="relationsList" style="display: none;">
                    <!-- Relations graph will be here -->
                </div>
                <div class="database-list" id="mapList" style="display: none;">
                    <!-- World map will be here -->
                </div>
                <div class="database-list" id="timelineVizList" style="display: none;">
                    <!-- Visual timeline will be here -->
                </div>
                <div class="database-list" id="todosList" style="display: none;">
                    <!-- TODOs list will be here -->
                </div>
                <div class="database-list" id="thrillerList" style="display: none;">
                    <!-- Thriller elements will be here -->
                </div>
                <div class="database-list" id="noSidebarMessage" style="display: none;">
                    <!-- Message for views without sidebar -->
                </div>
                <div class="sidebar-actions" id="sidebarActions">
                    <button class="btn btn-primary" onclick="openAddActModal()">+ Acte</button>
                    <button class="btn btn-primary" onclick="openAddChapterModal()">+ Chapitre</button>
                    <button class="btn btn-primary" onclick="openAddSceneModalQuick()">+ Scène</button>
                </div>
            </div>
            <!-- Vertical Tools Sidebar -->
            <div class="tools-sidebar" id="toolsSidebar">
                <button class="tool-btn" onclick="toggleVersionsSidebar()" id="toolVersionsBtn"
                    title="Versions de scène">
                    <i data-lucide="git-branch"></i>
                </button>
                <button class="tool-btn" onclick="toggleAnnotationsPanel()" id="toolAnnotationsBtn" title="Annotations">
                    <i data-lucide="message-square"></i>
                    <span class="tool-badge" id="toolAnnotationsBadge" style="display: none;">0</span>
                </button>
                <button class="tool-btn" onclick="toggleTodosPanel()" id="toolTodosBtn" title="TODOs">
                    <i data-lucide="check-square"></i>
                    <span class="tool-badge" id="toolTodosBadge" style="display: none;">0</span>
                </button>
                <button class="tool-btn" onclick="toggleArcScenePanel()" id="toolArcsBtn" title="Arcs Narratifs">
                    <i data-lucide="git-commit-horizontal"></i>
                </button>
                <button class="tool-btn" onclick="PlotGridUI.toggleSidebar()" id="toolPlotBtn" title="Plot Grid">
                    <i data-lucide="layout-grid"></i>
                </button>
                <div style="width: 100%; height: 1px; background: var(--border-color); margin: 0.5rem 0;"></div>
                <button class="tool-btn" onclick="toggleLinksPanelVisibility()" id="toolLinksPanelBtn"
                    title="Afficher/Masquer les liens (Personnages, Univers, Timeline)">
                    <i data-lucide="link-2"></i>
                </button>
                <button class="tool-btn" onclick="toggleWordRepetitionPanel()" id="toolRepetitionBtn"
                    title="Analyseur de répétitions de mots">
                    <i data-lucide="repeat"></i>
                </button>
            </div>
            <!-- Sidebar Versions (pour les versions de scènes) -->
            <div class="sidebar-versions hidden" id="sidebarVersions">
                <div class="sidebar-versions-header">
                    <div class="sidebar-versions-title">
                        <h3><i data-lucide="git-branch"
                                style="width:16px;height:16px;vertical-align:middle;margin-right:6px;"></i>Versions</h3>
                        <button class="sidebar-versions-toggle" onclick="toggleVersionsSidebar()" title="Masquer"><i
                                data-lucide="x" style="width:14px;height:14px;"></i></button>
                    </div>
                    <div class="sidebar-versions-scene" id="versionsSceneName">Aucune scène sélectionnée</div>
                </div>
                <div class="sidebar-versions-actions" id="versionsActionsArea">
                    <button class="btn-new-version" onclick="createSceneVersion()" id="btnNewVersion" disabled>
                        + Nouvelle version
                    </button>
                </div>
                <div class="sidebar-versions-list" id="sceneVersionsList">
                    <div class="versions-no-scene">
                        <div class="versions-no-scene-icon"><i data-lucide="file-text"></i></div>
                        <div class="versions-no-scene-text">
                            Sélectionnez une scène<br>dans la structure<br>pour voir ses versions
                        </div>
                    </div>
                </div>
            </div>
            <!-- Sidebar Plot (Dabble Style) -->
            <div class="sidebar-plot hidden" id="sidebarPlot">
                <div class="sidebar-plot-header">
                    <div class="sidebar-plot-title">
                        <h3><i data-lucide="layout-grid"
                                style="width:16px;height:16px;vertical-align:middle;margin-right:6px;"></i>Plot Grid
                        </h3>
                        <button class="sidebar-plot-toggle" onclick="PlotGridUI.toggleSidebar()" title="Masquer"><i
                                data-lucide="x" style="width:14px;height:14px;"></i></button>
                    </div>
                    <div class="sidebar-plot-scene" id="plotSidebarSceneName">Aucune scène sélectionnée</div>
                </div>
                <div class="sidebar-plot-list" id="plotSidebarList">
                    <!-- Plot cards will be inserted here -->
                </div>
            </div>
            <!-- Annotations Panel -->
            <div class="annotations-panel hidden" id="annotationsPanel">
                <div class="annotations-panel-spacer"></div>
                <div class="annotations-panel-content" id="annotationsPanelContent"></div>
            </div>
            <!-- TODOs Panel -->
            <div class="annotations-panel hidden" id="todosPanel">
                <div class="annotations-panel-spacer"></div>
                <div class="annotations-panel-content" id="todosPanelContent"></div>
            </div>
            <!-- Arc Scene Panel -->
            <div id="arcScenePanel" class="arc-scene-panel hidden">
                <div class="arc-scene-panel-header">
                    <h3>Arcs dans cette scène</h3>
                    <button class="arc-panel-close" onclick="toggleArcScenePanel()"><i data-lucide="x"
                            style="width:14px;height:14px;"></i></button>
                </div>
                <div id="arcScenePanelContent" class="arc-scene-panel-content">
                    <!-- Contenu dynamique -->
                </div>
            </div>
            <!-- Links Panel (Sidebar) -->
            <div id="linksPanel" class="links-panel-sidebar hidden">
                <div class="links-panel-header">
                    <h3><i data-lucide="link-2"
                            style="width:16px;height:16px;vertical-align:middle;margin-right:6px;"></i>Liens</h3>
                    <button class="links-panel-close" onclick="toggleLinksPanelVisibility()"><i data-lucide="x"
                            style="width:14px;height:14px;"></i></button>
                </div>
                <div id="linksPanelContent" class="links-panel-content">
                    <!-- Contenu dynamique -->
                </div>
            </div>
            <!-- Word Repetition Sidebar (Right Panel) -->
            <div id="wordRepetitionSidebar" class="word-rep-sidebar hidden">
                <div class="word-rep-sidebar-resize" id="wordRepSidebarResize"></div>
                <div class="word-rep-sidebar-header">
                    <div class="word-rep-sidebar-title">
                        <h3><i data-lucide="repeat" style="width:16px;height:16px;vertical-align:middle;margin-right:6px;"></i>Répétitions</h3>
                        <button class="word-rep-sidebar-close" onclick="toggleWordRepetitionPanel()" title="Fermer">
                            <i data-lucide="x" style="width:14px;height:14px;"></i>
                        </button>
                    </div>
                    <div class="word-rep-sidebar-controls">
                        <button class="btn btn-small" onclick="WordRepetitionHandlers.onRefresh()" title="Analyser">
                            <i data-lucide="refresh-cw" style="width:12px;height:12px;"></i> Analyser
                        </button>
                        <button class="btn btn-icon btn-small" onclick="WordRepetitionHandlers.onToggleSettings()" title="Paramètres">
                            <i data-lucide="settings" style="width:14px;height:14px;"></i>
                        </button>
                    </div>
                </div>
                <div class="word-rep-sidebar-content" id="wordRepetitionContainer">
                    <!-- Word repetition panel will be dynamically inserted here -->
                </div>
            </div>
            <!-- Main Editor -->
            <div class="editor-container" id="editorView">
                <div class="empty-state">
                    <div class="empty-state-icon"><i data-lucide="pen-tool"></i></div>
                    <div class="empty-state-title">Commencez votre histoire</div>
                    <div class="empty-state-text">
                        Créez votre premier chapitre pour commencer à écrire.
                    </div>
                    <button class="btn btn-primary" onclick="openAddChapterModal()">+ Créer un chapitre</button>
                </div>
            </div>
        </div><!-- Fin app-content -->
        <!-- Focus Mode Toggle Button -->
        <button class="focus-toggle-btn" onclick="toggleFocusPanel()"><i data-lucide="settings"></i> Paramètres
            Focus</button>
        <!-- Focus Mode Panel (inside app-container for fullscreen) -->
        <div class="focus-mode-panel" id="focusPanel">
            <div class="focus-panel-header">
                <div class="focus-panel-title"><i data-lucide="brain"></i> Mode Focus</div>
            </div>
            <div class="focus-panel-content">
                <!-- Pomodoro Timer -->
                <div class="focus-section">
                    <div class="focus-section-title"><i data-lucide="timer"></i> Timer Pomodoro</div>
                    <div class="pomodoro-timer">
                        <div class="pomodoro-display" id="pomodoroDisplay">25:00</div>
                        <div class="pomodoro-controls">
                            <button class="btn btn-small" onclick="startPomodoro()"><i data-lucide="play"></i>
                                Démarrer</button>
                            <button class="btn btn-small" onclick="pausePomodoro()"><i data-lucide="pause"></i>
                                Pause</button>
                            <button class="btn btn-small" onclick="resetPomodoro()"><i data-lucide="rotate-ccw"></i>
                                Reset</button>
                        </div>
                        <div class="focus-stats">
                            <div class="focus-stat-box">
                                <div class="focus-stat-value" id="pomodorosCompleted">0</div>
                                <div class="focus-stat-label">Pomodoros</div>
                            </div>
                            <div class="focus-stat-box">
                                <div class="focus-stat-value" id="focusWordCount">0</div>
                                <div class="focus-stat-label">Mots</div>
                            </div>
                        </div>
                    </div>
                </div>
                <!-- Focus Settings -->
                <div class="focus-section">
                    <div class="focus-section-title">Paramètres</div>
                    <div style="display: flex; flex-direction: column; gap: 0.75rem;">
                        <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                            <input type="checkbox" id="hideToolbar" onchange="toggleToolbar()">
                            <span>Masquer la barre d'outils</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                            <input type="checkbox" id="hideLinksPanel" onchange="toggleLinksPanelVisibility()">
                            <span>Masquer le panneau de liens</span>
                        </label>
                    </div>
                </div>
                <!-- Exit Focus Mode -->
                <div class="focus-section">
                    <button class="btn btn-primary" style="width: 100%;" onclick="toggleFocusMode()">
                        <i data-lucide="arrow-left"></i> Quitter le mode Focus
                    </button>
                </div>
            </div>
        </div>
    </div><!-- Fin app-container -->
    <!-- Diff Modal -->
    <div class="diff-modal" id="diffModal" style="display: none;">
        <div class="diff-modal-content">
            <div class="diff-modal-header">
                <div class="diff-modal-title">
                    <span><i data-lucide="repeat"></i></span>
                    <span>Comparaison des versions</span>
                </div>
                <button class="diff-modal-close" onclick="closeDiffModal()"><i data-lucide="x"
                        style="width:18px;height:18px;"></i></button>
            </div>
            <div class="diff-toolbar">
                <div class="diff-version-selector">
                    <span>Comparer</span>
                    <select class="diff-version-select" id="diffVersionOld" onchange="updateDiff()">
                    </select>
                    <span>avec</span>
                    <select class="diff-version-select" id="diffVersionNew" onchange="updateDiff()">
                    </select>
                </div>
                <div class="diff-stats" id="diffStats">
                    <span class="diff-stat added">+0 ajoutés</span>
                    <span class="diff-stat removed">−0 supprimés</span>
                </div>
                <div class="diff-view-toggle">
                    <button class="diff-view-btn active" onclick="setDiffView('unified')"
                        id="btnDiffUnified">Unifié</button>
                    <button class="diff-view-btn" onclick="setDiffView('side')" id="btnDiffSide">Côte à côte</button>
                </div>
            </div>
            <div class="diff-content" id="diffContent">
                <!-- Diff content will be inserted here -->
            </div>
        </div>
    </div>
    <!-- Add Act Modal -->
    <!-- Storage Details Modal -->
    <div class="modal storage-details-modal" id="storage-modal">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header">
                <h2><i data-lucide="save"></i> Espace de stockage</h2>
                <button class="modal-close" onclick="closeModal('storage-modal')"><i data-lucide="x"
                        style="width:18px;height:18px;"></i></button>
            </div>
            <div class="storage-info">
                <div class="storage-bar">
                    <div class="storage-bar-fill ok" id="storage-bar-fill" style="width: 0%">
                        <span id="storage-bar-text">0%</span>
                    </div>
                </div>
                <div class="storage-stats">
                    <div class="storage-stat">
                        <div class="storage-stat-label">Utilisé</div>
                        <div class="storage-stat-value" id="storage-used">0 MB</div>
                    </div>
                    <div class="storage-stat">
                        <div class="storage-stat-label">Disponible</div>
                        <div class="storage-stat-value" id="storage-available">5 MB</div>
                    </div>
                </div>
                <!-- Section repliable pour les recommandations -->
                <details id="storage-recommendations-details" style="margin-top: 1rem;">
                    <summary style="cursor: pointer; font-weight: 600; color: var(--accent-green); font-size: 0.9rem;">
                        <i data-lucide="check-circle"
                            style="width:14px;height:14px;vertical-align:middle;margin-right:6px;"></i> Espace suffisant
                    </summary>
                    <div id="storage-recommendations-container" style="margin-top: 0.5rem;"></div>
                </details>
            </div>
            <hr style="border: none; border-top: 1px solid var(--border-color); margin: 1.25rem 0;">
            <!-- Importer des données -->
            <div style="margin-bottom: 1rem;">
                <div style="font-size: 0.9rem; font-weight: 600; margin-bottom: 0.5rem; color: var(--text-primary);">
                    Importer</div>
                <button class="btn" onclick="importProject()" style="width: 100%; font-size: 0.85rem;">
                    <i data-lucide="upload"
                        style="width:14px;height:14px;vertical-align:middle;margin-right:6px;"></i>Importer depuis un
                    fichier JSON
                </button>
            </div>
            <!-- Exporter les données -->
            <div style="margin-bottom: 1rem;">
                <div style="font-size: 0.9rem; font-weight: 600; margin-bottom: 0.5rem; color: var(--text-primary);">
                    Exporter</div>
                <div style="display: flex; flex-direction: column; gap: 0.5rem;">
                    <button class="btn btn-primary" onclick="closeModal('storage-modal'); openExportNovelModal();"
                        style="font-weight: 600; font-size: 0.85rem;">
                        <i data-lucide="book-open"
                            style="width:14px;height:14px;vertical-align:middle;margin-right:6px;"></i>Exporter le roman
                        (MD, TXT, HTML ...)
                    </button>
                    <div style="display: flex; gap: 0.5rem;">
                        <button class="btn" onclick="exportToJSON()" style="flex: 1; font-size: 0.8rem;">
                            <i data-lucide="hard-drive"
                                style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>JSON
                        </button>
                        <button class="btn" onclick="exportProject()" style="flex: 1; font-size: 0.8rem;">
                            <i data-lucide="file-text"
                                style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>TXT
                        </button>
                    </div>
                </div>
            </div>
            <!-- Cloud manuel - repliable -->
            <details style="margin-bottom: 1rem;">
                <summary style="cursor: pointer; font-weight: 600; color: var(--text-primary); font-size: 0.9rem;">
                    <i data-lucide="cloud"></i> Cloud (manuel)
                </summary>
                <div
                    style="padding: 0.75rem; background: var(--bg-secondary); border-radius: 4px; margin-top: 0.5rem; border: 1px solid var(--border-color);">
                    <ol
                        style="font-size: 0.75rem; color: var(--text-secondary); line-height: 1.6; padding-left: 1.25rem; margin: 0;">
                        <li>Télécharge en JSON</li>
                        <li>Uploade sur Google Drive / Dropbox</li>
                        <li>Pour restaurer : "Importer depuis un fichier"</li>
                    </ol>
                </div>
            </details>
            <!-- Avertissement très petit -->
            <p style="font-size: 0.7rem; color: var(--text-muted); text-align: center; margin: 0;">
                <i data-lucide="alert-triangle"
                    style="width:12px;height:12px;vertical-align:middle;margin-right:4px;"></i> Pense à exporter
                régulièrement — les données navigateur peuvent être effacées
            </p>
            <div class="modal-actions" style="margin-top: 1rem;">
                <button class="btn" onclick="closeModal('storage-modal')">Fermer</button>
            </div>
        </div>
    </div>
    <!-- Modals -->
    <div class="modal" id="addActModal">
        <div class="modal-content">
            <div class="modal-title">Nouvel Acte</div>
            <div class="form-group">
                <label class="form-label">Titre de l'acte</label>
                <input type="text" class="form-input" id="actTitleInput" placeholder="Acte I : L'éveil">
            </div>
            <div class="modal-actions">
                <button class="btn" onclick="closeModal('addActModal')">Annuler</button>
                <button class="btn btn-primary" onclick="addAct()">Créer</button>
            </div>
        </div>
    </div>
    <!-- Add Chapter Modal -->
    <div class="modal" id="addChapterModal">
        <div class="modal-content">
            <div class="modal-title">Nouveau Chapitre</div>
            <div class="form-group">
                <label class="form-label">Titre du chapitre</label>
                <input type="text" class="form-input" id="chapterTitleInput" placeholder="Chapitre 1 : Le Début">
            </div>
            <div class="modal-actions">
                <button class="btn" onclick="closeModal('addChapterModal')">Annuler</button>
                <button class="btn btn-primary" onclick="addChapter()">Créer</button>
            </div>
        </div>
    </div>
    <!-- Add Scene Modal -->
    <div class="modal" id="addSceneModal">
        <div class="modal-content">
            <div class="modal-title">Nouvelle Scène</div>
            <div class="form-group">
                <label class="form-label">Titre de la scène</label>
                <input type="text" class="form-input" id="sceneTitleInput" placeholder="Scène 1 : Rencontre">
            </div>
            <div class="modal-actions">
                <button class="btn" onclick="closeModal('addSceneModal')">Annuler</button>
                <button class="btn btn-primary" onclick="addScene()">Créer</button>
            </div>
        </div>
    </div>
    <!-- Split View Selector Modal -->
    <div class="modal" id="splitSelectorModal">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-title"><i data-lucide="layout"
                    style="width:20px;height:20px;vertical-align:middle;margin-right:8px;"></i>Choisir la vue</div>
            <div id="splitSelectorContent" style="max-height: 600px; overflow-y: auto;">
                <!-- Content will be populated by JavaScript -->
            </div>
            <div class="modal-actions">
                <button class="btn" onclick="closeModal('splitSelectorModal')">Annuler</button>
            </div>
        </div>
    </div>
    <!-- Add Character Modal -->
    <div class="modal" id="addCharacterModal">
        <div class="modal-content">
            <div class="modal-title">Nouveau Personnage</div>
            <div class="form-group">
                <label class="form-label">Nom du personnage</label>
                <input type="text" class="form-input" id="characterNameInput" placeholder="Akiko">
            </div>
            <div class="form-group">
                <label class="form-label">Rôle</label>
                <input type="text" class="form-input" id="characterRoleInput"
                    placeholder="Protagoniste, Antagoniste, Allié...">
            </div>
            <div class="form-group">
                <label class="form-label">Description rapide</label>
                <textarea class="form-input" id="characterDescInput" placeholder="Description du personnage..."
                    rows="3"></textarea>
            </div>
            <div class="modal-actions">
                <button class="btn" onclick="closeModal('addCharacterModal')">Annuler</button>
                <button class="btn btn-primary" onclick="addCharacter()">Créer</button>
            </div>
        </div>
    </div>
    <!-- Add World Element Modal -->
    <div class="modal" id="addWorldModal">
        <div class="modal-content">
            <div class="modal-title">Nouvel élément d'Univers</div>
            <div class="form-group">
                <label class="form-label">Nom</label>
                <input type="text" class="form-input" id="worldNameInput" placeholder="Cité de Voile">
            </div>
            <div class="form-group">
                <label class="form-label">Type</label>
                <select class="form-input" id="worldTypeInput">
                    <option value="Lieu">Lieu</option>
                    <option value="Objet">Objet</option>
                    <option value="Concept">Concept</option>
                    <option value="Organisation">Organisation</option>
                    <option value="événement">événement</option>
                </select>
            </div>
            <div class="form-group">
                <label class="form-label">Description rapide</label>
                <textarea class="form-input" id="worldDescInput" placeholder="Description de l'élément..."
                    rows="3"></textarea>
            </div>
            <div class="modal-actions">
                <button class="btn" onclick="closeModal('addWorldModal')">Annuler</button>
                <button class="btn btn-primary" onclick="addWorldElement()">Créer</button>
            </div>
        </div>
    </div>
    <!-- Add Timeline Event Modal -->
    <div class="modal" id="addTimelineModal">
        <div class="modal-content">
            <div class="modal-title">Nouvel événement</div>
            <div class="form-group">
                <label class="form-label">Titre de l'événement</label>
                <input type="text" class="form-input" id="timelineTitleInput" placeholder="La grande bataille">
            </div>
            <div class="form-group">
                <label class="form-label">Date / Moment</label>
                <input type="text" class="form-input" id="timelineDateInput"
                    placeholder="An 2157, Printemps / Chapitre 5 / Jour 3...">
            </div>
            <div class="form-group">
                <label class="form-label">Localisation</label>
                <input type="text" class="form-input" id="timelineLocationInput" placeholder="Cité de Voile">
            </div>
            <div class="form-group">
                <label class="form-label">Personnages impliqués</label>
                <input type="text" class="form-input" id="timelineCharactersInput" placeholder="Akiko, Sora, Kumi...">
            </div>
            <div class="form-group">
                <label class="form-label">Description</label>
                <textarea class="form-input" id="timelineDescInput" placeholder="Description de l'événement..."
                    rows="4"></textarea>
            </div>
            <div class="modal-actions">
                <button class="btn" onclick="closeModal('addTimelineModal')">Annuler</button>
                <button class="btn btn-primary" onclick="addTimelineEvent()">Créer</button>
            </div>
        </div>
    </div>
    <!-- Metro Timeline Event Modal -->
    <div class="modal" id="metroEventModal">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-title" id="metroEventModalTitle">Nouvel événement</div>
            <input type="hidden" id="metroEventId">
            <div class="metro-event-form">
                <div class="form-group">
                    <label class="form-label">Titre de l'événement *</label>
                    <input type="text" class="form-input" id="metroEventTitle" placeholder="La grande bataille">
                </div>
                <div class="form-group">
                    <label class="form-label">Date / Moment</label>
                    <input type="text" class="form-input" id="metroEventDate" placeholder="An 2157, Printemps...">
                </div>
                <div class="form-group">
                    <label class="form-label">Position sur la timeline</label>
                    <select class="form-input" id="metroEventPosition">
                        <!-- Populated dynamically -->
                    </select>
                    <input type="hidden" id="metroEventOrder">
                    <small style="color: var(--text-muted);">Choisissez où placer cet événement dans la
                        chronologie</small>
                </div>
                <div class="form-group">
                    <label class="form-label">Description</label>
                    <textarea class="form-input" id="metroEventDesc" placeholder="Ce qui se passe..."
                        rows="3"></textarea>
                </div>
                <div class="form-group">
                    <label class="form-label">Scène liée</label>
                    <select class="form-input" id="metroEventScene">
                        <option value="">Aucune scène</option>
                        <!-- Populated dynamically -->
                    </select>
                    <small style="color: var(--text-muted);">Associez cet événement à une scène de votre roman</small>
                </div>
                <div class="form-group">
                    <label class="form-label">Personnages impliqués</label>
                    <div id="metroCharactersSelector" class="metro-characters-selector">
                        <!-- Populated dynamically -->
                    </div>
                    <div id="metroLinkedChars" class="metro-linked-chars">
                        <!-- Tags des personnages liés -->
                    </div>
                </div>
            </div>
            <div class="modal-actions">
                <button class="btn" onclick="closeModal('metroEventModal')">Annuler</button>
                <button class="btn" style="background: var(--accent-red); color: white;" onclick="deleteMetroEvent()"
                    id="metroDeleteBtn" style="display: none;">Supprimer</button>
                <button class="btn btn-primary" onclick="saveMetroEvent()">Enregistrer</button>
            </div>
        </div>
    </div>
    <!-- Metro Event View Choice Modal -->
    <div class="modal" id="metroViewChoiceModal">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-title">Ouvrir l'événement Timeline</div>
            <input type="hidden" id="metroViewChoiceEventId">
            <div style="padding: 1rem 0;">
                <p style="color: var(--text-secondary); margin-bottom: 1.5rem;">
                    Comment souhaitez-vous visualiser cet événement ?
                </p>
                <div style="display: flex; flex-direction: column; gap: 1rem;">
                    <button class="btn" onclick="openMetroEventFullView()"
                        style="padding: 1rem; text-align: left; display: flex; align-items: start; gap: 1rem; border: 2px solid var(--border-color);">
                        <i data-lucide="maximize-2"
                            style="width: 24px; height: 24px; flex-shrink: 0; color: var(--accent-blue);"></i>
                        <div>
                            <div style="font-weight: 600; margin-bottom: 0.25rem;">Vue complète</div>
                            <div style="font-size: 0.85rem; color: var(--text-muted);">Basculer vers la vue Timeline
                                Métro (quitte la vue actuelle)</div>
                        </div>
                    </button>
                    <button class="btn" onclick="openMetroEventSplitView()"
                        style="padding: 1rem; text-align: left; display: flex; align-items: start; gap: 1rem; border: 2px solid var(--border-color);">
                        <i data-lucide="columns-2"
                            style="width: 24px; height: 24px; flex-shrink: 0; color: var(--accent-green);"></i>
                        <div>
                            <div style="font-weight: 600; margin-bottom: 0.25rem;">Split-view</div>
                            <div style="font-size: 0.85rem; color: var(--text-muted);">Ouvrir la Timeline en vue séparée
                                (conserve l'éditeur)</div>
                        </div>
                    </button>
                </div>
            </div>
            <div class="modal-actions">
                <button class="btn" onclick="closeModal('metroViewChoiceModal')">Annuler</button>
            </div>
        </div>
    </div>
    <!-- Metro Character Color Picker Modal -->
    <div class="modal" id="metroColorModal">
        <div class="modal-content" style="max-width: 350px;">
            <div class="modal-title">Couleur de la ligne</div>
            <input type="hidden" id="metroColorCharId">
            <div class="form-group">
                <label class="form-label" id="metroColorCharName">Personnage</label>
                <div style="display: flex; flex-wrap: wrap; gap: 0.5rem; margin-top: 0.5rem;">
                    <div class="metro-color-option" data-color="#E53935" style="background: #E53935;"
                        onclick="selectMetroColor('#E53935')"></div>
                    <div class="metro-color-option" data-color="#D81B60" style="background: #D81B60;"
                        onclick="selectMetroColor('#D81B60')"></div>
                    <div class="metro-color-option" data-color="#8E24AA" style="background: #8E24AA;"
                        onclick="selectMetroColor('#8E24AA')"></div>
                    <div class="metro-color-option" data-color="#5E35B1" style="background: #5E35B1;"
                        onclick="selectMetroColor('#5E35B1')"></div>
                    <div class="metro-color-option" data-color="#3949AB" style="background: #3949AB;"
                        onclick="selectMetroColor('#3949AB')"></div>
                    <div class="metro-color-option" data-color="#1E88E5" style="background: #1E88E5;"
                        onclick="selectMetroColor('#1E88E5')"></div>
                    <div class="metro-color-option" data-color="#039BE5" style="background: #039BE5;"
                        onclick="selectMetroColor('#039BE5')"></div>
                    <div class="metro-color-option" data-color="#00ACC1" style="background: #00ACC1;"
                        onclick="selectMetroColor('#00ACC1')"></div>
                    <div class="metro-color-option" data-color="#00897B" style="background: #00897B;"
                        onclick="selectMetroColor('#00897B')"></div>
                    <div class="metro-color-option" data-color="#43A047" style="background: #43A047;"
                        onclick="selectMetroColor('#43A047')"></div>
                    <div class="metro-color-option" data-color="#7CB342" style="background: #7CB342;"
                        onclick="selectMetroColor('#7CB342')"></div>
                    <div class="metro-color-option" data-color="#C0CA33" style="background: #C0CA33;"
                        onclick="selectMetroColor('#C0CA33')"></div>
                    <div class="metro-color-option" data-color="#FDD835" style="background: #FDD835;"
                        onclick="selectMetroColor('#FDD835')"></div>
                    <div class="metro-color-option" data-color="#FFB300" style="background: #FFB300;"
                        onclick="selectMetroColor('#FFB300')"></div>
                    <div class="metro-color-option" data-color="#FB8C00" style="background: #FB8C00;"
                        onclick="selectMetroColor('#FB8C00')"></div>
                    <div class="metro-color-option" data-color="#F4511E" style="background: #F4511E;"
                        onclick="selectMetroColor('#F4511E')"></div>
                    <div class="metro-color-option" data-color="#6D4C41" style="background: #6D4C41;"
                        onclick="selectMetroColor('#6D4C41')"></div>
                    <div class="metro-color-option" data-color="#757575" style="background: #757575;"
                        onclick="selectMetroColor('#757575')"></div>
                    <div class="metro-color-option" data-color="#546E7A" style="background: #546E7A;"
                        onclick="selectMetroColor('#546E7A')"></div>
                    <div class="metro-color-option" data-color="#263238" style="background: #263238;"
                        onclick="selectMetroColor('#263238')"></div>
                </div>
                <div style="margin-top: 1rem;">
                    <label class="form-label">Couleur personnalisée</label>
                    <input type="color" id="metroCustomColor" class="form-input"
                        style="width: 100%; height: 40px; padding: 0; cursor: pointer;">
                </div>
            </div>
            <div class="modal-actions">
                <button class="btn" onclick="closeModal('metroColorModal')">Annuler</button>
                <button class="btn btn-primary" onclick="applyMetroColor()">Appliquer</button>
            </div>
        </div>
    </div>
    <style>
        .metro-color-option {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.2s;
        }

        .metro-color-option:hover {
            transform: scale(1.15);
            border-color: white;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .metro-color-option.selected {
            border-color: var(--text-primary);
            box-shadow: 0 0 0 2px var(--accent-blue);
        }
    </style>
    <!-- Add Note Modal -->
    <div class="modal" id="addNoteModal">
        <div class="modal-content">
            <div class="modal-title">Nouvelle Note</div>
            <div class="form-group">
                <label class="form-label">Titre de la note</label>
                <input type="text" class="form-input" id="noteTitleInput"
                    placeholder="Recherche sur les sanctuaires Shinto">
            </div>
            <div class="form-group">
                <label class="form-label">Catégorie</label>
                <select class="form-input" id="noteCategoryInput">
                    <option value="Recherche">Recherche</option>
                    <option value="Idée">Idée</option>
                    <option value="Référence">Référence</option>
                    <option value="A faire">A faire</option>
                    <option value="Question">Question</option>
                    <option value="Autre">Autre</option>
                </select>
            </div>
            <div class="form-group">
                <label class="form-label">Tags (séparés par des virgules)</label>
                <input type="text" class="form-input" id="noteTagsInput" placeholder="shinto, religion, japon">
            </div>
            <div class="form-group">
                <label class="form-label">Contenu</label>
                <textarea class="form-input" id="noteContentInput" placeholder="Contenu de la note..."
                    rows="6"></textarea>
            </div>
            <div class="modal-actions">
                <button class="btn" onclick="closeModal('addNoteModal')">Annuler</button>
                <button class="btn btn-primary" onclick="addNote()">Créer</button>
            </div>
        </div>
    </div>
    <!-- Add Codex Entry Modal -->
    <div class="modal" id="addCodexModal">
        <div class="modal-content">
            <div class="modal-title">Nouvelle Entrée Codex</div>
            <div class="form-group">
                <label class="form-label">Titre</label>
                <input type="text" class="form-input" id="codexTitleInput" placeholder="Les Sanctuaires Shinto">
            </div>
            <div class="form-group">
                <label class="form-label">Catégorie</label>
                <select class="form-input" id="codexCategoryInput">
                    <option value="Culture">Culture</option>
                    <option value="Histoire">Histoire</option>
                    <option value="Technologie">Technologie</option>
                    <option value="Géographie">Géographie</option>
                    <option value="Politique">Politique</option>
                    <option value="Magie/Pouvoir">Magie/Pouvoir</option>
                    <option value="Religion">Religion</option>
                    <option value="Société">Société</option>
                    <option value="Autre">Autre</option>
                </select>
            </div>
            <div class="form-group">
                <label class="form-label">Résumé rapide</label>
                <textarea class="form-input" id="codexSummaryInput" placeholder="Description courte..."
                    rows="3"></textarea>
            </div>
            <div class="modal-actions">
                <button class="btn" onclick="closeModal('addCodexModal')">Annuler</button>
                <button class="btn btn-primary" onclick="addCodexEntry()">Créer</button>
            </div>
        </div>
    </div>
    <!-- Projects Management Modal -->
    <div class="modal" id="projectsModal">
        <div class="modal-content" style="max-width: 800px;">
            <div class="modal-title"><i data-lucide="folder-open"></i> Mes Projets</div>
            <div class="modal-button-group" style="margin-bottom: 2rem;">
                <button class="btn btn-primary" onclick="openNewProjectModal()">+ Nouveau Projet</button>
                <button class="btn" onclick="importProject()">Importer un projet</button>
            </div>
            <div id="projectsList" style="max-height: 400px; overflow-y: auto;">
                <!-- Projects will be listed here -->
            </div>
            <div class="modal-actions">
                <button class="btn" onclick="closeModal('projectsModal')">Fermer</button>
            </div>
        </div>
    </div>
    <!-- New Project Modal -->
    <div class="modal" id="newProjectModal">
        <div class="modal-content">
            <div class="modal-title">Nouveau Projet</div>
            <div class="form-group">
                <label class="form-label">Titre du projet</label>
                <input type="text" class="form-input" id="newProjectTitle" placeholder="Mon Roman">
            </div>
            <div class="form-group">
                <label class="form-label">Description (optionnel)</label>
                <textarea class="form-input" id="newProjectDesc" placeholder="Un roman de fantasy épique..."
                    rows="3"></textarea>
            </div>
            <div class="form-group">
                <label class="form-label">Genre</label>
                <select class="form-input" id="newProjectGenre">
                    <option value="">Aucun</option>
                    <option value="Fantasy">Fantasy</option>
                    <option value="Science-Fiction">Science-Fiction</option>
                    <option value="Thriller">Thriller</option>
                    <option value="Romance">Romance</option>
                    <option value="Policier">Policier</option>
                    <option value="Horreur">Horreur</option>
                    <option value="Historique">Historique</option>
                    <option value="Aventure">Aventure</option>
                    <option value="Drame">Drame</option>
                    <option value="Autre">Autre</option>
                </select>
            </div>
            <div class="form-group">
                <label class="form-label">Utiliser un template ?</label>
                <select class="form-input" id="newProjectTemplate">
                    <option value="">Projet vide</option>
                    <option value="fantasy">Fantasy (3 actes + personnages types)</option>
                    <option value="thriller">Thriller (Structure suspense)</option>
                    <option value="scifi">Science-Fiction (Worldbuilding avancé)</option>
                </select>
            </div>
            <div class="modal-actions">
                <button class="btn" onclick="closeModal('newProjectModal')">Annuler</button>
                <button class="btn btn-primary" onclick="createNewProject()">Créer</button>
            </div>
        </div>
    </div>
    <input type="file" id="importProjectInput" accept=".json" style="display: none;"
        onchange="handleProjectImport(event)">
    <!-- Backup Menu Modal -->
    <div class="modal" id="backupModal">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-title"><i data-lucide="hard-drive"></i> Sauvegardes et Exports</div>
            <div style="margin-bottom: 2rem;">
                <div style="font-size: 1rem; font-weight: 600; margin-bottom: 1rem; color: var(--text-primary);"><i
                        data-lucide="download"
                        style="width:16px;height:16px;vertical-align:middle;margin-right:6px;"></i>Importer des données
                </div>
                <div style="display: flex; flex-direction: column; gap: 0.75rem;">
                    <button class="btn btn-primary" onclick="openImportChapterModal(); closeModal('backupModal');" style="font-weight: 600;">
                        <i data-lucide="file-text"
                            style="width:16px;height:16px;vertical-align:middle;margin-right:6px;"></i>Importer un texte
                        (.docx, .txt, .md, .epub)
                    </button>
                    <button class="btn" onclick="importFromFile()">
                        <i data-lucide="folder-open"
                            style="width:16px;height:16px;vertical-align:middle;margin-right:6px;"></i>Importer depuis
                        un fichier JSON
                    </button>
                    <input type="file" id="importFileInput" accept=".json" style="display: none;"
                        onchange="handleFileImport(event)">
                </div>
            </div>
            <div style="margin-bottom: 2rem;">
                <div style="font-size: 1rem; font-weight: 600; margin-bottom: 1rem; color: var(--text-primary);"><i
                        data-lucide="upload"
                        style="width:16px;height:16px;vertical-align:middle;margin-right:6px;"></i>Exporter les données
                </div>
                <div style="display: flex; flex-direction: column; gap: 0.75rem;">
                    <button class="btn btn-primary" onclick="openExportNovelModal()" style="font-weight: 600;">
                        <i data-lucide="book-open"
                            style="width:16px;height:16px;vertical-align:middle;margin-right:6px;"></i>Exporter le roman
                        (MD, TXT, HTML ...)
                    </button>
                    <button class="btn" onclick="exportToJSON()">
                        <i data-lucide="hard-drive"
                            style="width:16px;height:16px;vertical-align:middle;margin-right:6px;"></i>Télécharger en
                        JSON (sauvegarde complète)
                    </button>
                    <button class="btn" onclick="exportProject()">
                        <i data-lucide="file-text"
                            style="width:16px;height:16px;vertical-align:middle;margin-right:6px;"></i>Exporter en TXT
                        (texte seulement)
                    </button>
                </div>
            </div>
            <div style="margin-bottom: 2rem;">
                <div style="font-size: 1rem; font-weight: 600; margin-bottom: 1rem; color: var(--text-primary);"><i
                        data-lucide="cloud"
                        style="width:16px;height:16px;vertical-align:middle;margin-right:6px;"></i>Cloud (manuel)</div>
                <div
                    style="padding: 1rem; background: var(--bg-secondary); border-radius: 4px; border: 1px solid var(--border-color);">
                    <p style="font-size: 0.9rem; color: var(--text-secondary); margin-bottom: 1rem; line-height: 1.6;">
                        Pour sauvegarder sur Google Drive, Dropbox, ou tout autre service cloud :
                    </p>
                    <ol
                        style="font-size: 0.85rem; color: var(--text-secondary); line-height: 1.8; padding-left: 1.5rem;">
                        <li>Clique sur "Télécharger en JSON"</li>
                        <li>Le fichier contient TOUTES tes données</li>
                        <li>Uploade-le manuellement sur ton service cloud préféré</li>
                        <li>Pour restaurer : télécharge le fichier et utilise "Importer depuis un fichier"</li>
                    </ol>
                </div>
            </div>
            <div
                style="padding: 1rem; background: rgba(196, 69, 54, 0.1); border-radius: 4px; border: 1px solid var(--accent-red);">
                <div style="font-size: 0.85rem; font-weight: 600; color: var(--accent-red); margin-bottom: 0.5rem;">
                    Important : Sauvegarde régulière
                </div>
                <p style="font-size: 0.8rem; color: var(--text-secondary); line-height: 1.6;">
                    Le localStorage peut être effacé par le navigateur. Pense à exporter régulièrement ton projet en
                    JSON et à le sauvegarder dans un endroit sûr (Google Drive, Dropbox, disque dur, etc.).
                </p>
            </div>
            <div class="modal-actions" style="margin-top: 1.5rem;">
                <button class="btn" onclick="closeModal('backupModal')">Fermer</button>
            </div>
        </div>
    </div>
    <!-- Import Chapter Modal (multi-format) -->
    <div class="modal" id="importChapterModal">
        <div class="modal-content" style="max-width: 650px; max-height: 85vh; overflow-y: auto;">
            <div class="modal-title">
                <i data-lucide="file-plus"></i> Importer un texte
            </div>
            <p style="font-size: 0.9rem; color: var(--text-secondary); margin-bottom: 1.5rem; line-height: 1.5;">
                Importez votre texte et Plume detectera automatiquement vos chapitres pour creer la structure.
            </p>
            <div id="importChapterContent">
                <!-- Content will be populated by JavaScript -->
            </div>
            <div class="modal-actions" style="margin-top: 1.5rem; border-top: 1px solid var(--border-color); padding-top: 1rem;">
                <button class="btn" onclick="closeImportChapterModal()">Annuler</button>
            </div>
        </div>
    </div>
    <!-- Export Novel Modal -->
    <div class="modal" id="exportNovelModal">
        <div class="modal-content" style="max-width: 700px; max-height: 90vh; overflow-y: auto;">
            <div class="modal-title"><i data-lucide="book-open"></i> Exporter votre roman</div>
            <p style="font-size: 0.95rem; color: var(--text-secondary); margin-bottom: 1.5rem; line-height: 1.6;">
                Vous pouvez exporter votre roman dans plusieurs formats. Vous pouvez ensuite importer les données dans
                d'autres logiciels d'écriture.
            </p>
            <!-- Toggle All Button -->
            <div style="margin-bottom: 1.5rem;">
                <button class="btn btn-small" onclick="toggleAllScenes()" style="width: 100%;">
                    Tout sélectionner / Tout désélectionner
                </button>
            </div>
            <!-- Acts/Chapters/Scenes Selection Tree -->
            <div style="margin-bottom: 1.5rem; max-height: 300px; overflow-y: auto; border: 1px solid var(--border-color); border-radius: 6px; padding: 1rem; background: var(--bg-secondary);"
                id="exportTreeContainer">
                <!-- Will be populated by JavaScript -->
            </div>
            <!-- Format Selection -->
            <div style="margin-bottom: 1.5rem;">
                <label style="display: block; font-weight: 600; margin-bottom: 0.75rem; color: var(--text-primary);">
                    Format du fichier
                </label>
                <select id="exportFormatSelect" onchange="updateExportFormatInfo()"
                    style="width: 100%; padding: 0.75rem; background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); font-size: 0.95rem; font-family: 'Crimson Pro', serif;">
                    <option value="markdown">Markdown (.md)</option>
                    <option value="txt">Texte brut (.txt)</option>
                    <option value="html">HTML (.html)</option>
                    <option value="epub">EPUB (.epub)</option>
                </select>
                <div id="formatInfoBox"
                    style="margin-top: 0.75rem; padding: 0.75rem; background: rgba(212, 175, 55, 0.1); border-radius: 4px; border: 1px solid var(--accent-gold); font-size: 0.85rem; color: var(--text-secondary); line-height: 1.5;">
                    <strong style="color: var(--text-primary);">Note :</strong>
                    Toutes les fonctionnalités ne sont pas supportées en format DOCX. Le texte exporté pourrait ne pas
                    ressembler exactement à l'éditeur. Pour une compatibilité complète, utilisez un autre format.
                </div>
            </div>
            <!-- General Options -->
            <div style="margin-bottom: 1.5rem;">
                <label style="display: block; font-weight: 600; margin-bottom: 0.75rem; color: var(--text-primary);">
                    Options générales
                </label>
                <div style="display: flex; flex-direction: column; gap: 0.5rem;">
                    <label
                        style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-size: 0.95rem;">
                        <input type="checkbox" id="exportSummariesCheck" style="cursor: pointer;">
                        <span>Exporter les résumés</span>
                    </label>
                    <label
                        style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-size: 0.95rem;">
                        <input type="checkbox" id="exportProseCheck" checked style="cursor: pointer;">
                        <span>Exporter le texte</span>
                    </label>
                    <label
                        style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-size: 0.95rem;">
                        <input type="checkbox" id="includeActTitlesCheck" checked style="cursor: pointer;">
                        <span>Inclure les titres d'actes <span
                                style="color: var(--text-muted); font-size: 0.85rem;">(désactiver pour ex. Vellum,
                                Atticus)</span></span>
                    </label>
                    <label
                        style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-size: 0.95rem;">
                        <input type="checkbox" id="includeSceneSubtitlesCheck" checked style="cursor: pointer;">
                        <span>Inclure les sous-titres de scènes</span>
                    </label>
                </div>
            </div>
            <!-- Scene Dividers -->
            <div style="margin-bottom: 1.5rem;">
                <label style="display: block; font-weight: 600; margin-bottom: 0.75rem; color: var(--text-primary);">
                    Séparateurs de scènes
                </label>
                <select id="sceneDividerSelect"
                    style="width: 100%; padding: 0.75rem; background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); font-size: 0.95rem; font-family: 'Crimson Pro', serif;">
                    <option value="asterisks">Astérisques ( * * * )</option>
                    <option value="hash">Dièse ( ### )</option>
                    <option value="line">Ligne horizontale (---)</option>
                    <option value="space">Espace vide</option>
                    <option value="none">Aucun séparateur</option>
                </select>
            </div>
            <!-- Project Export (ZIP with all data) -->
            <div
                style="margin-bottom: 1.5rem; padding: 1rem; background: var(--bg-secondary); border-radius: 6px; border: 1px solid var(--border-color);">
                <label style="display: block; font-weight: 600; margin-bottom: 0.75rem; color: var(--text-primary);">
                    Export du projet complet
                </label>
                <p style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 1rem; line-height: 1.5;">
                    En exportant le projet complet, le fichier résultant sera une archive ZIP contenant tout le contenu
                    sélectionné.
                </p>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
                    <label
                        style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-size: 0.95rem;">
                        <input type="checkbox" id="includeCharactersCheck" style="cursor: pointer;">
                        <span>Personnages</span>
                    </label>
                    <label
                        style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-size: 0.95rem;">
                        <input type="checkbox" id="includeWorldCheck" style="cursor: pointer;">
                        <span>Univers</span>
                    </label>
                    <label
                        style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-size: 0.95rem;">
                        <input type="checkbox" id="includeTimelineCheck" style="cursor: pointer;">
                        <span>Timeline</span>
                    </label>
                    <label
                        style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-size: 0.95rem;">
                        <input type="checkbox" id="includeRelationsCheck" style="cursor: pointer;">
                        <span>Relations</span>
                    </label>
                    <label
                        style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-size: 0.95rem;">
                        <input type="checkbox" id="includeCodexCheck" style="cursor: pointer;">
                        <span>Codex</span>
                    </label>
                    <label
                        style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-size: 0.95rem;">
                        <input type="checkbox" id="includeNotesCheck" style="cursor: pointer;">
                        <span>Notes</span>
                    </label>
                </div>
                <div style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px dashed var(--border-color);">
                    <button onclick="toggleAllExportOptions(true)" class="btn btn-small"
                        style="margin-right: 0.5rem; font-size: 0.8rem; padding: 0.3rem 0.6rem;">
                        Tout sélectionner
                    </button>
                    <button onclick="toggleAllExportOptions(false)" class="btn btn-small"
                        style="font-size: 0.8rem; padding: 0.3rem 0.6rem;">
                        Tout désélectionner
                    </button>
                </div>
            </div>
            <!-- Export Button -->
            <div style="text-align: center; padding-top: 1rem; border-top: 1px solid var(--border-color);">
                <button class="btn btn-primary" onclick="executeNovelExport()"
                    style="padding: 0.75rem 2rem; font-size: 1rem; font-weight: 600;">
                    Exporter
                </button>
            </div>
            <div class="modal-actions" style="margin-top: 1rem;">
                <button class="btn" onclick="closeModal('exportNovelModal')">Annuler</button>
            </div>
        </div>
    </div>
    <!-- Tension Words Editor Modal -->
    <div class="modal" id="tensionWordsModal">
        <div class="modal-content" style="max-width: 900px;">
            <div class="modal-title"><i data-lucide="pencil"></i> Personnaliser les mots de tension</div>
            <div
                style="margin-bottom: 1.5rem; padding: 1rem; background: var(--bg-secondary); border-radius: 6px; border: 1px solid var(--border-color);">
                <p style="font-size: 0.9rem; color: var(--text-secondary); line-height: 1.6; margin: 0;">
                    Ces mots sont utilisés pour calculer automatiquement la tension narrative de vos scènes.
                    Personnalisez-les selon votre style d'écriture et le genre de votre roman.
                </p>
            </div>
            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 1.5rem; margin-bottom: 1.5rem;">
                <!-- High Tension Words -->
                <div
                    style="background: var(--bg-secondary); border-radius: 8px; padding: 1.25rem; border: 2px solid rgba(196, 69, 54, 0.3);">
                    <h3
                        style="margin: 0 0 0.75rem 0; font-size: 1rem; color: var(--accent-red); display: flex; align-items: center; gap: 0.5rem;">
                        Haute tension
                        <span style="font-size: 0.75rem; color: var(--text-muted); font-weight: normal;">(+3 pts
                            chacun)</span>
                    </h3>
                    <div style="margin-bottom: 0.75rem;">
                        <input type="text" id="highTensionInput" placeholder="Ajouter un mot..."
                            style="width: 100%; padding: 0.5rem; background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); font-size: 0.85rem;"
                            onkeypress="if(event.key==='Enter') addTensionWord('high')">
                        <button onclick="addTensionWord('high')"
                            style="width: 100%; margin-top: 0.5rem; padding: 0.5rem; background: var(--accent-red); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85rem; font-weight: 500;">
                            + Ajouter
                        </button>
                        <button onclick="openBulkImport('high')"
                            style="width: 100%; margin-top: 0.5rem; padding: 0.5rem; background: rgba(196, 69, 54, 0.2); color: var(--accent-red); border: 1px solid var(--accent-red); border-radius: 4px; cursor: pointer; font-size: 0.85rem; font-weight: 500;">
                            Import en masse
                        </button>
                    </div>
                    <div id="highTensionList"
                        style="max-height: 300px; overflow-y: auto; display: flex; flex-direction: column; gap: 0.4rem;">
                        <!-- Words will be added here -->
                    </div>
                </div>
                <!-- Medium Tension Words -->
                <div
                    style="background: var(--bg-secondary); border-radius: 8px; padding: 1.25rem; border: 2px solid rgba(230, 162, 60, 0.3);">
                    <h3
                        style="margin: 0 0 0.75rem 0; font-size: 1rem; color: #e6a23c; display: flex; align-items: center; gap: 0.5rem;">
                        Tension moyenne
                        <span style="font-size: 0.75rem; color: var(--text-muted); font-weight: normal;">(+1.5 pts
                            chacun)</span>
                    </h3>
                    <div style="margin-bottom: 0.75rem;">
                        <input type="text" id="mediumTensionInput" placeholder="Ajouter un mot..."
                            style="width: 100%; padding: 0.5rem; background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); font-size: 0.85rem;"
                            onkeypress="if(event.key==='Enter') addTensionWord('medium')">
                        <button onclick="addTensionWord('medium')"
                            style="width: 100%; margin-top: 0.5rem; padding: 0.5rem; background: #e6a23c; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85rem; font-weight: 500;">
                            + Ajouter
                        </button>
                        <button onclick="openBulkImport('medium')"
                            style="width: 100%; margin-top: 0.5rem; padding: 0.5rem; background: rgba(230, 162, 60, 0.2); color: #e6a23c; border: 1px solid #e6a23c; border-radius: 4px; cursor: pointer; font-size: 0.85rem; font-weight: 500;">
                            Import en masse
                        </button>
                    </div>
                    <div id="mediumTensionList"
                        style="max-height: 300px; overflow-y: auto; display: flex; flex-direction: column; gap: 0.4rem;">
                        <!-- Words will be added here -->
                    </div>
                </div>
                <!-- Low Tension Words -->
                <div
                    style="background: var(--bg-secondary); border-radius: 8px; padding: 1.25rem; border: 2px solid rgba(74, 144, 226, 0.3);">
                    <h3
                        style="margin: 0 0 0.75rem 0; font-size: 1rem; color: var(--accent-blue); display: flex; align-items: center; gap: 0.5rem;">
                        Faible tension
                        <span style="font-size: 0.75rem; color: var(--text-muted); font-weight: normal;">(-2 pts
                            chacun)</span>
                    </h3>
                    <div style="margin-bottom: 0.75rem;">
                        <input type="text" id="lowTensionInput" placeholder="Ajouter un mot..."
                            style="width: 100%; padding: 0.5rem; background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); font-size: 0.85rem;"
                            onkeypress="if(event.key==='Enter') addTensionWord('low')">
                        <button onclick="addTensionWord('low')"
                            style="width: 100%; margin-top: 0.5rem; padding: 0.5rem; background: #2d6bb3; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85rem; font-weight: 500;">
                            + Ajouter
                        </button>
                        <button onclick="openBulkImport('low')"
                            style="width: 100%; margin-top: 0.5rem; padding: 0.5rem; background: rgba(45, 107, 179, 0.15); color: #2d6bb3; border: 1px solid #2d6bb3; border-radius: 4px; cursor: pointer; font-size: 0.85rem; font-weight: 500;">
                            Import en masse
                        </button>
                    </div>
                    <div id="lowTensionList"
                        style="max-height: 300px; overflow-y: auto; display: flex; flex-direction: column; gap: 0.4rem;">
                        <!-- Words will be added here -->
                    </div>
                </div>
            </div>
            <div class="modal-actions" style="display: flex; justify-content: space-between; align-items: center;">
                <div style="display: flex; gap: 0.75rem;">
                    <button class="btn" onclick="exportTensionWords()"
                        style="background: #2d6bb3; color: white; border: 1px solid #2d6bb3;">
                        Exporter les dictionnaires
                    </button>
                    <button class="btn" onclick="resetTensionWordsToDefault()"
                        style="background: var(--accent-red); color: white;">
                        Réinitialiser aux valeurs par défaut
                    </button>
                </div>
                <div style="display: flex; gap: 0.75rem;">
                    <button class="btn" onclick="closeModal('tensionWordsModal')">Annuler</button>
                    <button class="btn btn-primary" onclick="saveTensionWords()"><i data-lucide="save"></i>
                        Enregistrer</button>
                </div>
            </div>
        </div>
    </div>
    <!-- Bulk Import Modal -->
    <div class="modal" id="bulkImportModal">
        <div class="modal-content" style="max-width: 700px;">
            <div class="modal-title" id="bulkImportTitle">Import en masse</div>
            <div style="margin-bottom: 1.5rem;">
                <p style="font-size: 0.9rem; color: var(--text-secondary); line-height: 1.6; margin-bottom: 1rem;">
                    Importez une liste de mots en masse. Vous pouvez :
                </p>
                <ul style="font-size: 0.85rem; color: var(--text-secondary); line-height: 1.8; padding-left: 1.5rem;">
                    <li><strong>Coller du texte</strong> : Un mot par ligne ou séparés par des virgules</li>
                    <li><strong>Importer un fichier</strong> : Fichier .txt avec un mot par ligne</li>
                </ul>
            </div>
            <div style="margin-bottom: 1.5rem;">
                <label class="form-label">Collez vos mots ici :</label>
                <textarea id="bulkImportText"
                    placeholder="Ex: combat, bataille, mort&#10;tuer, danger, peur&#10;terreur, cri, hurler"
                    style="width: 100%; min-height: 200px; padding: 0.75rem; background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); font-size: 0.85rem; font-family: monospace; resize: vertical;">
                </textarea>
                <div style="font-size: 0.75rem; color: var(--text-muted); margin-top: 0.5rem;">
                    Formats acceptés : un mot par ligne, ou plusieurs mots séparés par des virgules
                </div>
            </div>
            <div style="margin-bottom: 1.5rem;">
                <label class="form-label">Ou importez un fichier .txt :</label>
                <input type="file" id="bulkImportFile" accept=".txt"
                    style="width: 100%; padding: 0.5rem; background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); font-size: 0.85rem;">
            </div>
            <div
                style="padding: 1rem; background: rgba(74, 144, 226, 0.1); border-radius: 4px; border: 1px solid var(--accent-blue); margin-bottom: 1.5rem;">
                <div style="font-size: 0.85rem; font-weight: 600; color: var(--accent-blue); margin-bottom: 0.5rem;">
                    Mode de fusion
                </div>
                <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; margin-bottom: 0.5rem;">
                    <input type="radio" name="importMode" value="add" checked>
                    <span style="font-size: 0.85rem; color: var(--text-primary);">Ajouter aux mots existants
                        (recommandé)</span>
                </label>
                <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                    <input type="radio" name="importMode" value="replace">
                    <span style="font-size: 0.85rem; color: var(--text-primary);">Remplacer tous les mots
                        existants</span>
                </label>
            </div>
            <div class="modal-actions">
                <button class="btn" onclick="closeModal('bulkImportModal')">Annuler</button>
                <button class="btn btn-primary" onclick="processBulkImport()"><i data-lucide="download"></i> Importer
                    les mots</button>
            </div>
        </div>
    </div>
    <!-- References Panel Modal -->
    <div class="modal" id="referencesModal">
        <div class="modal-content" style="max-width: 700px;">
            <div class="modal-title" id="referencesModalTitle">Références et Liens</div>
            <div id="referencesModalContent"></div>
            <div class="modal-actions">
                <button class="btn" onclick="closeModal('referencesModal')">Fermer</button>
            </div>
        </div>
    </div>
    </div>
    <!-- Annotation Popup -->
    <div class="annotation-popup" id="annotationPopup">
        <h3 style="margin-bottom: 1rem;">Ajouter une annotation</h3>
        <div class="annotation-type-selector">
            <div class="annotation-type-btn comment active" onclick="selectAnnotationType('comment')"><i
                    data-lucide="message-circle"
                    style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Commentaire</div>
            <div class="annotation-type-btn todo" onclick="selectAnnotationType('todo')"><i data-lucide="check-square"
                    style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>TODO</div>
            <div class="annotation-type-btn note" onclick="selectAnnotationType('note')"><i data-lucide="sticky-note"
                    style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Note</div>
            <div class="annotation-type-btn question" onclick="selectAnnotationType('question')"><i
                    data-lucide="help-circle"
                    style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Question</div>
        </div>
        <textarea id="annotationText" placeholder="Votre annotation..."></textarea>
        <div style="display: flex; gap: 0.75rem; justify-content: flex-end;">
            <button class="btn" onclick="closeAnnotationPopup()">Annuler</button>
            <button class="btn btn-primary" onclick="saveAnnotation()">Enregistrer</button>
        </div>
    </div>
    <!-- Floating Editor Menu Toggle Button (Mobile) -->
    <button id="floatingEditorToggle" onclick="toggleFloatingEditorMenu()"><i data-lucide="pen-line"></i></button>
    <!-- Floating Editor Menu (Mobile) -->
    <div id="floatingEditorMenu">
        <div id="floatingMenuHandle" title="Faire glisser pour déplacer"></div>
        <div id="floatingMenuContent">
            <!-- Annuler/Rétablir -->
            <button class="floating-btn-mini" onclick="undo()" title="Annuler"><i data-lucide="undo-2"></i></button>
            <button class="floating-btn-mini" onclick="redo()" title="Rétablir"><i data-lucide="redo-2"></i></button>
            <div class="floating-divider"></div>
            <!-- Formatage de base -->
            <button class="floating-btn-mini" onclick="formatText('bold')" title="Gras"><i
                    data-lucide="bold"></i></button>
            <button class="floating-btn-mini" onclick="formatText('italic')" title="Italique"><i
                    data-lucide="italic"></i></button>
            <button class="floating-btn-mini" onclick="formatText('underline')" title="Souligné"><i
                    data-lucide="underline"></i></button>
            <button class="floating-btn-mini" onclick="formatText('strikeThrough')" title="Barré"><i
                    data-lucide="strikethrough"></i></button>
            <div class="floating-divider"></div>
            <!-- Alignement -->
            <button class="floating-btn-mini" onclick="formatText('justifyLeft')" title="Aligner à gauche"><i
                    data-lucide="align-left"></i></button>
            <button class="floating-btn-mini" onclick="formatText('justifyCenter')" title="Centrer"><i
                    data-lucide="align-center"></i></button>
            <button class="floating-btn-mini" onclick="formatText('justifyRight')" title="Aligner à droite"><i
                    data-lucide="align-right"></i></button>
            <button class="floating-btn-mini" onclick="formatText('justifyFull')" title="Justifier"><i
                    data-lucide="align-justify"></i></button>
            <div class="floating-divider"></div>
            <!-- Listes -->
            <button class="floating-btn-mini" onclick="formatText('insertUnorderedList')" title="Liste à puces"><i
                    data-lucide="list"></i></button>
            <button class="floating-btn-mini" onclick="formatText('insertOrderedList')" title="Liste numérotée"><i
                    data-lucide="list-ordered"></i></button>
            <div class="floating-divider"></div>
            <!-- Plus d'options - Toggle sous-menu -->
            <button class="floating-btn-mini" onclick="toggleAdvancedMenu()" id="advancedMenuBtn"
                title="Plus d'options"><i data-lucide="more-horizontal"></i></button>
        </div>
        <!-- Barre de sous-menu avancé (apparaît au-dessus grâce à column-reverse) -->
        <div id="advancedMenuBar" style="display: none;">
            <button class="floating-btn-mini" onclick="formatText('removeFormat')" title="Supprimer le formatage"><i
                    data-lucide="eraser"></i></button>
            <button class="floating-btn-mini" onclick="insertLink()" title="Insérer un lien"><i data-lucide="link"
                    style="width:16px;height:16px;"></i></button>
            <button class="floating-btn-mini" onclick="formatText('formatBlock', 'h1')" title="Titre 1">H1</button>
            <button class="floating-btn-mini" onclick="formatText('formatBlock', 'h2')" title="Titre 2">H2</button>
            <button class="floating-btn-mini" onclick="formatText('formatBlock', 'h3')" title="Titre 3">H3</button>
            <button class="floating-btn-mini" onclick="formatText('formatBlock', 'blockquote')"
                title="Citation">Citation</button>
            <button class="floating-btn-mini" onclick="formatText('insertHorizontalRule')"
                title="Ligne horizontale">Ligne</button>
        </div>
    </div>
</body>    <script>
// ========== vendor/driver.js.iife.js ==========
this.driver=this.driver||{};this.driver.js=function(D){"use strict";let F={};function z(e={}){F={animate:!0,allowClose:!0,overlayOpacity:.7,smoothScroll:!1,disableActiveInteraction:!1,showProgress:!1,stagePadding:10,stageRadius:5,popoverOffset:10,showButtons:["next","previous","close"],disableButtons:[],overlayColor:"#000",...e}}function a(e){return e?F[e]:F}function W(e,o,t,i){return(e/=i/2)<1?t/2*e*e+o:-t/2*(--e*(e-2)-1)+o}function q(e){const o='a[href]:not([disabled]), button:not([disabled]), textarea:not([disabled]), input[type="text"]:not([disabled]), input[type="radio"]:not([disabled]), input[type="checkbox"]:not([disabled]), select:not([disabled])';return e.flatMap(t=>{const i=t.matches(o),p=Array.from(t.querySelectorAll(o));return[...i?[t]:[],...p]}).filter(t=>getComputedStyle(t).pointerEvents!=="none"&&ae(t))}function V(e){if(!e||se(e))return;const o=a("smoothScroll");e.scrollIntoView({behavior:!o||re(e)?"auto":"smooth",inline:"center",block:"center"})}function re(e){if(!e||!e.parentElement)return;const o=e.parentElement;return o.scrollHeight>o.clientHeight}function se(e){const o=e.getBoundingClientRect();return o.top>=0&&o.left>=0&&o.bottom<=(window.innerHeight||document.documentElement.clientHeight)&&o.right<=(window.innerWidth||document.documentElement.clientWidth)}function ae(e){return!!(e.offsetWidth||e.offsetHeight||e.getClientRects().length)}let N={};function b(e,o){N[e]=o}function l(e){return e?N[e]:N}function K(){N={}}let E={};function O(e,o){E[e]=o}function _(e){var o;(o=E[e])==null||o.call(E)}function ce(){E={}}function le(e,o,t,i){let p=l("__activeStagePosition");const n=p||t.getBoundingClientRect(),f=i.getBoundingClientRect(),w=W(e,n.x,f.x-n.x,o),r=W(e,n.y,f.y-n.y,o),v=W(e,n.width,f.width-n.width,o),s=W(e,n.height,f.height-n.height,o);p={x:w,y:r,width:v,height:s},Y(p),b("__activeStagePosition",p)}function X(e){if(!e)return;const o=e.getBoundingClientRect(),t={x:o.x,y:o.y,width:o.width,height:o.height};b("__activeStagePosition",t),Y(t)}function de(){const e=l("__activeStagePosition"),o=l("__overlaySvg");if(!e)return;if(!o){console.warn("No stage svg found.");return}const t=window.innerWidth,i=window.innerHeight;o.setAttribute("viewBox",`0 0 ${t} ${i}`)}function pe(e){const o=ue(e);document.body.appendChild(o),G(o,t=>{t.target.tagName==="path"&&_("overlayClick")}),b("__overlaySvg",o)}function Y(e){const o=l("__overlaySvg");if(!o){pe(e);return}const t=o.firstElementChild;if((t==null?void 0:t.tagName)!=="path")throw new Error("no path element found in stage svg");t.setAttribute("d",j(e))}function ue(e){const o=window.innerWidth,t=window.innerHeight,i=document.createElementNS("http://www.w3.org/2000/svg","svg");i.classList.add("driver-overlay","driver-overlay-animated"),i.setAttribute("viewBox",`0 0 ${o} ${t}`),i.setAttribute("xmlSpace","preserve"),i.setAttribute("xmlnsXlink","http://www.w3.org/1999/xlink"),i.setAttribute("version","1.1"),i.setAttribute("preserveAspectRatio","xMinYMin slice"),i.style.fillRule="evenodd",i.style.clipRule="evenodd",i.style.strokeLinejoin="round",i.style.strokeMiterlimit="2",i.style.zIndex="10000",i.style.position="fixed",i.style.top="0",i.style.left="0",i.style.width="100%",i.style.height="100%";const p=document.createElementNS("http://www.w3.org/2000/svg","path");return p.setAttribute("d",j(e)),p.style.fill=a("overlayColor")||"rgb(0,0,0)",p.style.opacity=`${a("overlayOpacity")}`,p.style.pointerEvents="auto",p.style.cursor="auto",i.appendChild(p),i}function j(e){const o=window.innerWidth,t=window.innerHeight,i=a("stagePadding")||0,p=a("stageRadius")||0,n=e.width+i*2,f=e.height+i*2,w=Math.min(p,n/2,f/2),r=Math.floor(Math.max(w,0)),v=e.x-i+r,s=e.y-i,c=n-r*2,d=f-r*2;return`M${o},0L0,0L0,${t}L${o},${t}L${o},0Z
    M${v},${s} h${c} a${r},${r} 0 0 1 ${r},${r} v${d} a${r},${r} 0 0 1 -${r},${r} h-${c} a${r},${r} 0 0 1 -${r},-${r} v-${d} a${r},${r} 0 0 1 ${r},-${r} z`}function ve(){const e=l("__overlaySvg");e&&e.remove()}function fe(){const e=document.getElementById("driver-dummy-element");if(e)return e;let o=document.createElement("div");return o.id="driver-dummy-element",o.style.width="0",o.style.height="0",o.style.pointerEvents="none",o.style.opacity="0",o.style.position="fixed",o.style.top="50%",o.style.left="50%",document.body.appendChild(o),o}function Q(e){const{element:o}=e;let t=typeof o=="string"?document.querySelector(o):o;t||(t=fe()),ge(t,e)}function he(){const e=l("__activeElement"),o=l("__activeStep");e&&(X(e),de(),oe(e,o))}function ge(e,o){const i=Date.now(),p=l("__activeStep"),n=l("__activeElement")||e,f=!n||n===e,w=e.id==="driver-dummy-element",r=n.id==="driver-dummy-element",v=a("animate"),s=o.onHighlightStarted||a("onHighlightStarted"),c=(o==null?void 0:o.onHighlighted)||a("onHighlighted"),d=(p==null?void 0:p.onDeselected)||a("onDeselected"),m=a(),g=l();!f&&d&&d(r?void 0:n,p,{config:m,state:g}),s&&s(w?void 0:e,o,{config:m,state:g});const u=!f&&v;let h=!1;xe(),b("previousStep",p),b("previousElement",n),b("activeStep",o),b("activeElement",e);const P=()=>{if(l("__transitionCallback")!==P)return;const x=Date.now()-i,y=400-x<=400/2;o.popover&&y&&!h&&u&&(J(e,o),h=!0),a("animate")&&x<400?le(x,400,n,e):(X(e),c&&c(w?void 0:e,o,{config:a(),state:l()}),b("__transitionCallback",void 0),b("__previousStep",p),b("__previousElement",n),b("__activeStep",o),b("__activeElement",e)),window.requestAnimationFrame(P)};b("__transitionCallback",P),window.requestAnimationFrame(P),V(e),!u&&o.popover&&J(e,o),n.classList.remove("driver-active-element","driver-no-interaction"),n.removeAttribute("aria-haspopup"),n.removeAttribute("aria-expanded"),n.removeAttribute("aria-controls"),a("disableActiveInteraction")&&e.classList.add("driver-no-interaction"),e.classList.add("driver-active-element"),e.setAttribute("aria-haspopup","dialog"),e.setAttribute("aria-expanded","true"),e.setAttribute("aria-controls","driver-popover-content")}function we(){var e;(e=document.getElementById("driver-dummy-element"))==null||e.remove(),document.querySelectorAll(".driver-active-element").forEach(o=>{o.classList.remove("driver-active-element","driver-no-interaction"),o.removeAttribute("aria-haspopup"),o.removeAttribute("aria-expanded"),o.removeAttribute("aria-controls")})}function A(){const e=l("__resizeTimeout");e&&window.cancelAnimationFrame(e),b("__resizeTimeout",window.requestAnimationFrame(he))}function me(e){var r;if(!l("isInitialized")||!(e.key==="Tab"||e.keyCode===9))return;const i=l("__activeElement"),p=(r=l("popover"))==null?void 0:r.wrapper,n=q([...p?[p]:[],...i?[i]:[]]),f=n[0],w=n[n.length-1];if(e.preventDefault(),e.shiftKey){const v=n[n.indexOf(document.activeElement)-1]||w;v==null||v.focus()}else{const v=n[n.indexOf(document.activeElement)+1]||f;v==null||v.focus()}}function Z(e){var t;((t=a("allowKeyboardControl"))==null||t)&&(e.key==="Escape"?_("escapePress"):e.key==="ArrowRight"?_("arrowRightPress"):e.key==="ArrowLeft"&&_("arrowLeftPress"))}function G(e,o,t){const i=(n,f)=>{const w=n.target;e.contains(w)&&((!t||t(w))&&(n.preventDefault(),n.stopPropagation(),n.stopImmediatePropagation()),f==null||f(n))};document.addEventListener("pointerdown",i,!0),document.addEventListener("mousedown",i,!0),document.addEventListener("pointerup",i,!0),document.addEventListener("mouseup",i,!0),document.addEventListener("click",n=>{i(n,o)},!0)}function ye(){window.addEventListener("keyup",Z,!1),window.addEventListener("keydown",me,!1),window.addEventListener("resize",A),window.addEventListener("scroll",A)}function be(){window.removeEventListener("keyup",Z),window.removeEventListener("resize",A),window.removeEventListener("scroll",A)}function xe(){const e=l("popover");e&&(e.wrapper.style.display="none")}function J(e,o){var C,y;let t=l("popover");t&&document.body.removeChild(t.wrapper),t=Pe(),document.body.appendChild(t.wrapper);const{title:i,description:p,showButtons:n,disableButtons:f,showProgress:w,nextBtnText:r=a("nextBtnText")||"Next &rarr;",prevBtnText:v=a("prevBtnText")||"&larr; Previous",progressText:s=a("progressText")||"{current} of {total}"}=o.popover||{};t.nextButton.innerHTML=r,t.previousButton.innerHTML=v,t.progress.innerHTML=s,i?(t.title.innerHTML=i,t.title.style.display="block"):t.title.style.display="none",p?(t.description.innerHTML=p,t.description.style.display="block"):t.description.style.display="none";const c=n||a("showButtons"),d=w||a("showProgress")||!1,m=(c==null?void 0:c.includes("next"))||(c==null?void 0:c.includes("previous"))||d;t.closeButton.style.display=c.includes("close")?"block":"none",m?(t.footer.style.display="flex",t.progress.style.display=d?"block":"none",t.nextButton.style.display=c.includes("next")?"block":"none",t.previousButton.style.display=c.includes("previous")?"block":"none"):t.footer.style.display="none";const g=f||a("disableButtons")||[];g!=null&&g.includes("next")&&(t.nextButton.disabled=!0,t.nextButton.classList.add("driver-popover-btn-disabled")),g!=null&&g.includes("previous")&&(t.previousButton.disabled=!0,t.previousButton.classList.add("driver-popover-btn-disabled")),g!=null&&g.includes("close")&&(t.closeButton.disabled=!0,t.closeButton.classList.add("driver-popover-btn-disabled"));const u=t.wrapper;u.style.display="block",u.style.left="",u.style.top="",u.style.bottom="",u.style.right="",u.id="driver-popover-content",u.setAttribute("role","dialog"),u.setAttribute("aria-labelledby","driver-popover-title"),u.setAttribute("aria-describedby","driver-popover-description");const h=t.arrow;h.className="driver-popover-arrow";const P=((C=o.popover)==null?void 0:C.popoverClass)||a("popoverClass")||"";u.className=`driver-popover ${P}`.trim(),G(t.wrapper,k=>{var M,R,I;const T=k.target,H=((M=o.popover)==null?void 0:M.onNextClick)||a("onNextClick"),$=((R=o.popover)==null?void 0:R.onPrevClick)||a("onPrevClick"),B=((I=o.popover)==null?void 0:I.onCloseClick)||a("onCloseClick");if(T.classList.contains("driver-popover-next-btn"))return H?H(e,o,{config:a(),state:l()}):_("nextClick");if(T.classList.contains("driver-popover-prev-btn"))return $?$(e,o,{config:a(),state:l()}):_("prevClick");if(T.classList.contains("driver-popover-close-btn"))return B?B(e,o,{config:a(),state:l()}):_("closeClick")},k=>!(t!=null&&t.description.contains(k))&&!(t!=null&&t.title.contains(k))&&typeof k.className=="string"&&k.className.includes("driver-popover")),b("popover",t);const S=((y=o.popover)==null?void 0:y.onPopoverRender)||a("onPopoverRender");S&&S(t,{config:a(),state:l()}),oe(e,o),V(u);const L=e.classList.contains("driver-dummy-element"),x=q([u,...L?[]:[e]]);x.length>0&&x[0].focus()}function U(){const e=l("popover");if(!(e!=null&&e.wrapper))return;const o=e.wrapper.getBoundingClientRect(),t=a("stagePadding")||0,i=a("popoverOffset")||0;return{width:o.width+t+i,height:o.height+t+i,realWidth:o.width,realHeight:o.height}}function ee(e,o){const{elementDimensions:t,popoverDimensions:i,popoverPadding:p,popoverArrowDimensions:n}=o;return e==="start"?Math.max(Math.min(t.top-p,window.innerHeight-i.realHeight-n.width),n.width):e==="end"?Math.max(Math.min(t.top-(i==null?void 0:i.realHeight)+t.height+p,window.innerHeight-(i==null?void 0:i.realHeight)-n.width),n.width):e==="center"?Math.max(Math.min(t.top+t.height/2-(i==null?void 0:i.realHeight)/2,window.innerHeight-(i==null?void 0:i.realHeight)-n.width),n.width):0}function te(e,o){const{elementDimensions:t,popoverDimensions:i,popoverPadding:p,popoverArrowDimensions:n}=o;return e==="start"?Math.max(Math.min(t.left-p,window.innerWidth-i.realWidth-n.width),n.width):e==="end"?Math.max(Math.min(t.left-(i==null?void 0:i.realWidth)+t.width+p,window.innerWidth-(i==null?void 0:i.realWidth)-n.width),n.width):e==="center"?Math.max(Math.min(t.left+t.width/2-(i==null?void 0:i.realWidth)/2,window.innerWidth-(i==null?void 0:i.realWidth)-n.width),n.width):0}function oe(e,o){const t=l("popover");if(!t)return;const{align:i="start",side:p="left"}=(o==null?void 0:o.popover)||{},n=i,f=e.id==="driver-dummy-element"?"over":p,w=a("stagePadding")||0,r=U(),v=t.arrow.getBoundingClientRect(),s=e.getBoundingClientRect(),c=s.top-r.height;let d=c>=0;const m=window.innerHeight-(s.bottom+r.height);let g=m>=0;const u=s.left-r.width;let h=u>=0;const P=window.innerWidth-(s.right+r.width);let S=P>=0;const L=!d&&!g&&!h&&!S;let x=f;if(f==="top"&&d?S=h=g=!1:f==="bottom"&&g?S=h=d=!1:f==="left"&&h?S=d=g=!1:f==="right"&&S&&(h=d=g=!1),f==="over"){const C=window.innerWidth/2-r.realWidth/2,y=window.innerHeight/2-r.realHeight/2;t.wrapper.style.left=`${C}px`,t.wrapper.style.right="auto",t.wrapper.style.top=`${y}px`,t.wrapper.style.bottom="auto"}else if(L){const C=window.innerWidth/2-(r==null?void 0:r.realWidth)/2,y=10;t.wrapper.style.left=`${C}px`,t.wrapper.style.right="auto",t.wrapper.style.bottom=`${y}px`,t.wrapper.style.top="auto"}else if(h){const C=Math.min(u,window.innerWidth-(r==null?void 0:r.realWidth)-v.width),y=ee(n,{elementDimensions:s,popoverDimensions:r,popoverPadding:w,popoverArrowDimensions:v});t.wrapper.style.left=`${C}px`,t.wrapper.style.top=`${y}px`,t.wrapper.style.bottom="auto",t.wrapper.style.right="auto",x="left"}else if(S){const C=Math.min(P,window.innerWidth-(r==null?void 0:r.realWidth)-v.width),y=ee(n,{elementDimensions:s,popoverDimensions:r,popoverPadding:w,popoverArrowDimensions:v});t.wrapper.style.right=`${C}px`,t.wrapper.style.top=`${y}px`,t.wrapper.style.bottom="auto",t.wrapper.style.left="auto",x="right"}else if(d){const C=Math.min(c,window.innerHeight-r.realHeight-v.width);let y=te(n,{elementDimensions:s,popoverDimensions:r,popoverPadding:w,popoverArrowDimensions:v});t.wrapper.style.top=`${C}px`,t.wrapper.style.left=`${y}px`,t.wrapper.style.bottom="auto",t.wrapper.style.right="auto",x="top"}else if(g){const C=Math.min(m,window.innerHeight-(r==null?void 0:r.realHeight)-v.width);let y=te(n,{elementDimensions:s,popoverDimensions:r,popoverPadding:w,popoverArrowDimensions:v});t.wrapper.style.left=`${y}px`,t.wrapper.style.bottom=`${C}px`,t.wrapper.style.top="auto",t.wrapper.style.right="auto",x="bottom"}L?t.arrow.classList.add("driver-popover-arrow-none"):Ce(n,x,e)}function Ce(e,o,t){const i=l("popover");if(!i)return;const p=t.getBoundingClientRect(),n=U(),f=i.arrow,w=n.width,r=window.innerWidth,v=p.width,s=p.left,c=n.height,d=window.innerHeight,m=p.top,g=p.height;f.className="driver-popover-arrow";let u=o,h=e;o==="top"?(s+v<=0?(u="right",h="end"):s+v-w<=0&&(u="top",h="start"),s>=r?(u="left",h="end"):s+w>=r&&(u="top",h="end")):o==="bottom"?(s+v<=0?(u="right",h="start"):s+v-w<=0&&(u="bottom",h="start"),s>=r?(u="left",h="start"):s+w>=r&&(u="bottom",h="end")):o==="left"?(m+g<=0?(u="bottom",h="end"):m+g-c<=0&&(u="left",h="start"),m>=d?(u="top",h="end"):m+c>=d&&(u="left",h="end")):o==="right"&&(m+g<=0?(u="bottom",h="start"):m+g-c<=0&&(u="right",h="start"),m>=d?(u="top",h="start"):m+c>=d&&(u="right",h="end")),u?(f.classList.add(`driver-popover-arrow-side-${u}`),f.classList.add(`driver-popover-arrow-align-${h}`)):f.classList.add("driver-popover-arrow-none")}function Pe(){const e=document.createElement("div");e.classList.add("driver-popover");const o=document.createElement("div");o.classList.add("driver-popover-arrow");const t=document.createElement("header");t.id="driver-popover-title",t.classList.add("driver-popover-title"),t.style.display="none",t.innerText="Popover Title";const i=document.createElement("div");i.id="driver-popover-description",i.classList.add("driver-popover-description"),i.style.display="none",i.innerText="Popover description is here";const p=document.createElement("button");p.type="button",p.classList.add("driver-popover-close-btn"),p.setAttribute("aria-label","Close"),p.innerHTML="&times;";const n=document.createElement("footer");n.classList.add("driver-popover-footer");const f=document.createElement("span");f.classList.add("driver-popover-progress-text"),f.innerText="";const w=document.createElement("span");w.classList.add("driver-popover-navigation-btns");const r=document.createElement("button");r.type="button",r.classList.add("driver-popover-prev-btn"),r.innerHTML="&larr; Previous";const v=document.createElement("button");return v.type="button",v.classList.add("driver-popover-next-btn"),v.innerHTML="Next &rarr;",w.appendChild(r),w.appendChild(v),n.appendChild(f),n.appendChild(w),e.appendChild(p),e.appendChild(o),e.appendChild(t),e.appendChild(i),e.appendChild(n),{wrapper:e,arrow:o,title:t,description:i,footer:n,previousButton:r,nextButton:v,closeButton:p,footerButtons:w,progress:f}}function Se(){var o;const e=l("popover");e&&((o=e.wrapper.parentElement)==null||o.removeChild(e.wrapper))}const Le="";function ke(e={}){z(e);function o(){a("allowClose")&&v()}function t(){const s=l("activeIndex"),c=a("steps")||[];if(typeof s=="undefined")return;const d=s+1;c[d]?r(d):v()}function i(){const s=l("activeIndex"),c=a("steps")||[];if(typeof s=="undefined")return;const d=s-1;c[d]?r(d):v()}function p(s){(a("steps")||[])[s]?r(s):v()}function n(){var h;if(l("__transitionCallback"))return;const c=l("activeIndex"),d=l("__activeStep"),m=l("__activeElement");if(typeof c=="undefined"||typeof d=="undefined"||typeof l("activeIndex")=="undefined")return;const u=((h=d.popover)==null?void 0:h.onPrevClick)||a("onPrevClick");if(u)return u(m,d,{config:a(),state:l()});i()}function f(){var u;if(l("__transitionCallback"))return;const c=l("activeIndex"),d=l("__activeStep"),m=l("__activeElement");if(typeof c=="undefined"||typeof d=="undefined")return;const g=((u=d.popover)==null?void 0:u.onNextClick)||a("onNextClick");if(g)return g(m,d,{config:a(),state:l()});t()}function w(){l("isInitialized")||(b("isInitialized",!0),document.body.classList.add("driver-active",a("animate")?"driver-fade":"driver-simple"),ye(),O("overlayClick",o),O("escapePress",o),O("arrowLeftPress",n),O("arrowRightPress",f))}function r(s=0){var H,$,B,M,R,I,ie,ne;const c=a("steps");if(!c){console.error("No steps to drive through"),v();return}if(!c[s]){v();return}b("__activeOnDestroyed",document.activeElement),b("activeIndex",s);const d=c[s],m=c[s+1],g=c[s-1],u=((H=d.popover)==null?void 0:H.doneBtnText)||a("doneBtnText")||"Done",h=a("allowClose"),P=typeof(($=d.popover)==null?void 0:$.showProgress)!="undefined"?(B=d.popover)==null?void 0:B.showProgress:a("showProgress"),L=(((M=d.popover)==null?void 0:M.progressText)||a("progressText")||"{{current}} of {{total}}").replace("{{current}}",`${s+1}`).replace("{{total}}",`${c.length}`),x=((R=d.popover)==null?void 0:R.showButtons)||a("showButtons"),C=["next","previous",...h?["close"]:[]].filter(_e=>!(x!=null&&x.length)||x.includes(_e)),y=((I=d.popover)==null?void 0:I.onNextClick)||a("onNextClick"),k=((ie=d.popover)==null?void 0:ie.onPrevClick)||a("onPrevClick"),T=((ne=d.popover)==null?void 0:ne.onCloseClick)||a("onCloseClick");Q({...d,popover:{showButtons:C,nextBtnText:m?void 0:u,disableButtons:[...g?[]:["previous"]],showProgress:P,progressText:L,onNextClick:y||(()=>{m?r(s+1):v()}),onPrevClick:k||(()=>{r(s-1)}),onCloseClick:T||(()=>{v()}),...(d==null?void 0:d.popover)||{}}})}function v(s=!0){const c=l("__activeElement"),d=l("__activeStep"),m=l("__activeOnDestroyed"),g=a("onDestroyStarted");if(s&&g){const P=!c||(c==null?void 0:c.id)==="driver-dummy-element";g(P?void 0:c,d,{config:a(),state:l()});return}const u=(d==null?void 0:d.onDeselected)||a("onDeselected"),h=a("onDestroyed");if(document.body.classList.remove("driver-active","driver-fade","driver-simple"),be(),Se(),we(),ve(),ce(),K(),c&&d){const P=c.id==="driver-dummy-element";u&&u(P?void 0:c,d,{config:a(),state:l()}),h&&h(P?void 0:c,d,{config:a(),state:l()})}m&&m.focus()}return{isActive:()=>l("isInitialized")||!1,refresh:A,drive:(s=0)=>{w(),r(s)},setConfig:z,setSteps:s=>{K(),z({...a(),steps:s})},getConfig:a,getState:l,getActiveIndex:()=>l("activeIndex"),isFirstStep:()=>l("activeIndex")===0,isLastStep:()=>{const s=a("steps")||[],c=l("activeIndex");return c!==void 0&&c===s.length-1},getActiveStep:()=>l("activeStep"),getActiveElement:()=>l("activeElement"),getPreviousElement:()=>l("previousElement"),getPreviousStep:()=>l("previousStep"),moveNext:t,movePrevious:i,moveTo:p,hasNextStep:()=>{const s=a("steps")||[],c=l("activeIndex");return c!==void 0&&s[c+1]},hasPreviousStep:()=>{const s=a("steps")||[],c=l("activeIndex");return c!==void 0&&s[c-1]},highlight:s=>{w(),Q({...s,popover:s.popover?{showButtons:[],showProgress:!1,progressText:"",...s.popover}:void 0})},destroy:()=>{v(!1)}}}return D.driver=ke,Object.defineProperty(D,Symbol.toStringTag,{value:"Module"}),D}({});

// ========== js-refactor/01.app.refactor.js ==========
// [MVVM : Model]
// Stockage de la liste de tous les projets
let projects = []; // Array of all projects

// [MVVM : ViewModel]
// État de la sélection actuelle
let currentProjectId = null;

// [MVVM : Model]
// Données métier du projet actif (Le Roman)
let project = {
    id: null,
    title: "Mon Roman",
    description: "",
    genre: "",
    createdAt: null,
    updatedAt: null,
    acts: [], // Acts contain chapters, chapters contain scenes
    characters: [], // Character database
    world: [], // World elements (locations, objects, concepts)
    timeline: [], // Timeline events
    notes: [], // Standalone notes and research
    codex: [], // Wiki/Codex entries for worldbuilding
    stats: {
        dailyGoal: 500,
        totalGoal: 80000,
        writingSessions: [] // Track writing sessions with word count and date
    },
    versions: [], // Version history snapshots
    relationships: [], // Cross-references between elements
    relations: [], // Character relations with types and colors
    characterPositions: {}, // Custom positions for relations graph
    mapLocations: [], // Geographic map markers
    mapImage: null, // Map image data URL
    visualTimeline: [], // Timeline visualization events
    metroTimeline: [], // Metro-style timeline with character links
    characterColors: {}, // Colors for metro timeline lines
    mindmaps: [], // Custom mindmaps with nodes and links
    thrillerElements: [], // Thriller mystery elements (alibis, clues, secrets, etc.)
    thrillerElements: [], // Thriller mystery elements (alibis, clues, secrets, etc.)
    thrillerConnections: [] // Connections between thriller elements
};

// [MVVM : ViewModel]
// État de la navigation (Pointeurs vers les données affichées)
let currentActId = null;
let currentChapterId = null;
let currentSceneId = null;
let activeActId = null;
let activeChapterId = null;

// [MVVM : ViewModel]
// État de la vue active
let currentView = 'editor'; // 'editor', 'characters', 'world', 'timeline', 'notes', 'stats', 'codex', 'versions'
let currentMindmapId = null; // ID du mindmap actuellement affiché

// [MVVM : ViewModel]
// État du système de Split View
// SPLIT VIEW SYSTEM - New Architecture
let splitViewActive = false;
let splitActivePanel = 'left'; // 'left' or 'right' - which panel is currently active
let splitViewState = {
    left: {
        view: 'editor',
        sceneId: null,
        actId: null,
        chapterId: null,
        characterId: null,
        worldId: null,
        noteId: null,
        codexId: null
    },
    right: {
        view: null, // null = empty
        sceneId: null,
        actId: null,
        chapterId: null,
        characterId: null,
        worldId: null,
        noteId: null,
        codexId: null
    },
    ratio: 60,
    persistOnReload: true
};

// [MVVM : ViewModel]
// État de l'interface (Expansions de l'arborescence)
// TREE STATE - pour mémoriser l'état d'expansion
let expandedActs = new Set(); // IDs des actes dépliés
let expandedChapters = new Set(); // IDs des chapitres dépliés

// [MVVM : ViewModel]
// État des outils d'édition (Mode Révision)
// REVISION MODE VARIABLES
let revisionMode = false;
let selectedHighlightColor = 'yellow';
let selectedAnnotationType = 'comment';
let currentSelection = null; // 'editor', 'characters', 'world', 'timeline', 'notes', 'stats', 'codex', 'versions'

// [MVVM : ViewModel]
// Infrastructure de gestion d'état (Undo/Redo)
// UNDO/REDO SYSTEM
let historyStack = []; // Stack pour les états précédents
let redoStack = []; // Stack pour redo
let maxHistorySize = 50; // Garder max 50 états
let isUndoRedoAction = false; // Flag pour éviter de sauvegarder pendant undo/redo
let historyDebounceTimer = null; // Timer pour debounce
let historyDebounceDelay = 2000; // 2 secondes de délai

// GLOBAL DATA STATE (Moved for early initialization)
let corkBoardFilter = {
    mode: 'structured', // 'structured', 'kanban'
    type: 'all', // 'all', 'act', 'chapter'
    actId: null,
    chapterId: null
};
let plotPoints = [];

// ========== js/38.tension.js ==========
// ============================================
// Module: features/analysis
// Généré automatiquement - Plume Writer
// ============================================
// Initialize
// === TENSION WORDS MANAGEMENT ===

// Valeurs par défaut des mots de tension
const DEFAULT_TENSION_WORDS = {
    high: [
        'combat', 'bataille', 'mort', 'tuer', 'danger', 'peur', 'terreur', 'cri', 'hurler',
        'sang', 'blessure', 'fuir', 'course', 'poursuite', 'menace', 'attaque', 'explosion',
        'feu', 'incendie', 'catastrophe', 'urgence', 'panique', 'désespoir', 'tragédie',
        'révélation', 'secret', 'trahison', 'conflit', 'confrontation', 'affrontement',
        'climax', 'crucial', 'décisif', 'critique', 'vital', 'dramatique'
    ],
    medium: [
        'mystère', 'suspense', 'intrigue', 'complot', 'enquête', 'découverte', 'surprise',
        'tension', 'stress', 'angoisse', 'inquiétude', 'doute', 'hésitation', 'dilemme',
        'choix', 'décision', 'tournant', 'changement', 'transformation'
    ],
    low: [
        'calme', 'paix', 'repos', 'détente', 'tranquille', 'paisible', 'serein',
        'conversation', 'discussion', 'réflexion', 'souvenir', 'rêve', 'pensée'
    ]
};

// Récupérer les mots de tension (personnalisés ou par défaut)
// [MVVM : Model]
// Récupère les mots de tension (personnalisés ou par défaut) depuis le localStorage.
function getTensionWords() {
    const stored = localStorage.getItem('tensionWords');
    if (stored) {
        try {
            return JSON.parse(stored);
        } catch (e) {
            console.error('Erreur lors du chargement des mots de tension:', e);
            return DEFAULT_TENSION_WORDS;
        }
    }
    return DEFAULT_TENSION_WORDS;
}

// Sauvegarder les mots de tension
// [MVVM : Model]
// Sauvegarde les mots de tension dans le localStorage.
function saveTensionWordsToStorage(words) {
    localStorage.setItem('tensionWords', JSON.stringify(words));
}

// Ouvrir l'éditeur de mots de tension
// [MVVM : View]
// Ouvre le modal de l'éditeur de mots de tension et déclenche le chargement des données.
function openTensionWordsEditor() {
    document.getElementById('tensionWordsModal').classList.add('active');
    loadTensionWordsInEditor();
}

// Charger les mots dans l'éditeur
// [MVVM : ViewModel]
// Récupère les données et met à jour l'affichage de l'éditeur pour les trois catégories de tension.
function loadTensionWordsInEditor() {
    const words = getTensionWords();

    // Charger les mots de haute tension
    const highList = document.getElementById('highTensionList');
    if (highList) {
        highList.innerHTML = '';
        words.high.forEach((word, index) => {
            highList.innerHTML += createWordElement(word, 'high', index);
        });
    }

    // Charger les mots de tension moyenne
    const mediumList = document.getElementById('mediumTensionList');
    if (mediumList) {
        mediumList.innerHTML = '';
        words.medium.forEach((word, index) => {
            mediumList.innerHTML += createWordElement(word, 'medium', index);
        });
    }

    // Charger les mots de faible tension
    const lowList = document.getElementById('lowTensionList');
    if (lowList) {
        lowList.innerHTML = '';
        words.low.forEach((word, index) => {
            lowList.innerHTML += createWordElement(word, 'low', index);
        });
    }
}

// Créer un élément de mot avec bouton de suppression
// [MVVM : View]
// Génère le fragment HTML représentant un mot avec son bouton de suppression.
function createWordElement(word, type, index) {
    const colors = {
        high: 'var(--accent-red)',
        medium: '#e6a23c',
        low: 'var(--accent-blue)'
    };

    return `
                <div style="display: flex; align-items: center; justify-content: space-between; padding: 0.5rem 0.75rem; background: var(--bg-primary); border-radius: 4px; border: 1px solid var(--border-color);">
                    <span style="font-size: 0.85rem; color: var(--text-primary);">${word}</span>
                    <button onclick="removeTensionWord('${type}', ${index})" 
                            style="background: none; border: none; color: ${colors[type]}; cursor: pointer; font-size: 1rem; padding: 0 0.25rem; opacity: 0.7; transition: opacity 0.2s;"
                            onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0.7'"
                            title="Supprimer ce mot">
                        ×
                    </button>
                </div>
            `;
}

// Ajouter un mot de tension
// [MVVM : ViewModel]
// Valide et ajoute un nouveau mot à une catégorie spécifique, puis met à jour le modèle et la vue.
function addTensionWord(type) {
    const input = document.getElementById(`${type}TensionInput`);
    const word = input.value.trim().toLowerCase();

    if (!word) {
        showNotification('⚠️ Veuillez entrer un mot', 'warning');
        return;
    }

    const words = getTensionWords();

    // Vérifier si le mot existe déjà
    if (words[type].includes(word)) {
        showNotification('⚠️ Ce mot existe déjà dans cette catégorie', 'warning');
        return;
    }

    // Vérifier si le mot existe dans une autre catégorie
    for (const category in words) {
        if (category !== type && words[category].includes(word)) {
            showNotification(`⚠️ Ce mot existe déjà dans la catégorie "${category === 'high' ? 'haute' : category === 'medium' ? 'moyenne' : 'faible'} tension"`, 'warning');
            return;
        }
    }

    // Ajouter le mot
    words[type].push(word);
    saveTensionWordsToStorage(words);

    // Recharger la liste
    loadTensionWordsInEditor();

    // Vider l'input
    input.value = '';

    showNotification(`✓ Mot "${word}" ajouté`, 'success');
}

// Supprimer un mot de tension
// [MVVM : ViewModel]
// Supprime un mot par son index dans une catégorie, puis met à jour le modèle et la vue.
function removeTensionWord(type, index) {
    const words = getTensionWords();
    const removedWord = words[type][index];

    words[type].splice(index, 1);
    saveTensionWordsToStorage(words);

    // Recharger la liste
    loadTensionWordsInEditor();

    showNotification(`✓ Mot "${removedWord}" supprimé`, 'success');
}

// Enregistrer les modifications
// [MVVM : View]
// Ferme le modal et informe l'utilisateur que les modifications ont été enregistrées.
function saveTensionWords() {
    closeModal('tensionWordsModal');
    showNotification('✓ Mots de tension enregistrés. Le graphique sera recalculé lors de la prochaine visualisation.', 'success');
}

// Réinitialiser aux valeurs par défaut
// [MVVM : ViewModel]
// Restaure le dictionnaire par défaut après confirmation, puis met à jour le modèle et la vue.
function resetTensionWordsToDefault() {
    if (confirm('Êtes-vous sûr de vouloir réinitialiser tous les mots de tension aux valeurs par défaut ? Cette action est irréversible.')) {
        saveTensionWordsToStorage(DEFAULT_TENSION_WORDS);
        loadTensionWordsInEditor();
        showNotification('✓ Mots de tension réinitialisés aux valeurs par défaut', 'success');
    }
}

// Exporter les dictionnaires de mots de tension
// [MVVM : ViewModel]
// Formate les dictionnaires actuels et déclenche le téléchargement d'un fichier texte.
function exportTensionWords() {
    const words = getTensionWords();

    // Créer trois fichiers texte, un par catégorie
    const highWords = words.high.join('\n');
    const mediumWords = words.medium.join('\n');
    const lowWords = words.low.join('\n');

    // Créer un fichier ZIP virtuel avec les trois fichiers
    const content = `=== DICTIONNAIRES DE MOTS DE TENSION ===
Exporté le ${new Date().toLocaleString('fr-FR')}

=== HAUTE TENSION (${words.high.length} mots) ===
${highWords}

=== TENSION MOYENNE (${words.medium.length} mots) ===
${mediumWords}

=== FAIBLE TENSION (${words.low.length} mots) ===
${lowWords}
`;

    // Créer et télécharger le fichier
    const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `dictionnaires-tension-${new Date().toISOString().slice(0, 10)}.txt`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    showNotification('✓ Dictionnaires exportés avec succès', 'success');
}

// === BULK IMPORT FOR TENSION WORDS ===

let currentBulkImportType = null;

// Ouvrir le modal d'import en masse
// [MVVM : View]
// Configure et affiche le modal d'importation en masse pour une catégorie donnée.
function openBulkImport(type) {
    currentBulkImportType = type;

    const titles = {
        high: '📥 Import en masse - Haute tension',
        medium: '📥 Import en masse - Tension moyenne',
        low: '📥 Import en masse - Faible tension'
    };

    document.getElementById('bulkImportTitle').textContent = titles[type];
    document.getElementById('bulkImportText').value = '';
    document.getElementById('bulkImportFile').value = '';
    document.querySelector('input[name="importMode"][value="add"]').checked = true;

    document.getElementById('bulkImportModal').classList.add('active');
}

// Traiter l'import en masse
// [MVVM : ViewModel]
// Récupère la source d'importation (texte ou fichier) et orchestre le processus de lecture.
function processBulkImport() {
    if (!currentBulkImportType) return;

    const textarea = document.getElementById('bulkImportText');
    const fileInput = document.getElementById('bulkImportFile');
    const mode = document.querySelector('input[name="importMode"]:checked').value;

    // Vérifier si un fichier est sélectionné
    if (fileInput.files && fileInput.files[0]) {
        const file = fileInput.files[0];
        const reader = new FileReader();

        reader.onload = function (e) {
            const content = e.target.result;
            importWordsFromText(content, currentBulkImportType, mode);
        };

        reader.onerror = function () {
            showNotification('❌ Erreur lors de la lecture du fichier', 'error');
        };

        reader.readAsText(file);
    } else if (textarea.value.trim()) {
        // Utiliser le texte collé
        importWordsFromText(textarea.value, currentBulkImportType, mode);
    } else {
        showNotification('⚠️ Veuillez coller du texte ou sélectionner un fichier', 'warning');
    }
}

// Importer les mots depuis du texte
// [MVVM : ViewModel]
// Analyse le texte brut, filtre les doublons et les mots vides, puis intègre les résultats au modèle.
function importWordsFromText(text, type, mode) {
    // Nettoyer et parser le texte
    let words = [];

    // Séparer par retours à la ligne ET par virgules
    const lines = text.split(/\r?\n/);
    lines.forEach(line => {
        // Pour chaque ligne, séparer aussi par virgules
        const wordsInLine = line.split(',');
        wordsInLine.forEach(word => {
            const cleaned = word.trim().toLowerCase();
            if (cleaned && cleaned.length > 0) {
                words.push(cleaned);
            }
        });
    });

    // Supprimer les doublons
    words = [...new Set(words)];

    if (words.length === 0) {
        showNotification('⚠️ Aucun mot valide trouvé', 'warning');
        return;
    }

    // Récupérer les mots existants
    const tensionWords = getTensionWords();

    if (mode === 'replace') {
        // Remplacer tous les mots
        tensionWords[type] = words;
        showNotification(`✓ ${words.length} mots importés (remplacement)`, 'success');
    } else {
        // Ajouter aux mots existants (sans doublons)
        const existingWords = new Set(tensionWords[type]);
        let addedCount = 0;

        words.forEach(word => {
            if (!existingWords.has(word)) {
                tensionWords[type].push(word);
                addedCount++;
            }
        });

        const skippedCount = words.length - addedCount;
        if (addedCount > 0) {
            showNotification(`✓ ${addedCount} mot(s) ajouté(s)${skippedCount > 0 ? ` (${skippedCount} doublon(s) ignoré(s))` : ''}`, 'success');
        } else {
            showNotification(`⚠️ Tous les mots existent déjà (${skippedCount} doublon(s))`, 'warning');
        }
    }

    // Sauvegarder et recharger
    saveTensionWordsToStorage(tensionWords);
    loadTensionWordsInEditor();

    // Fermer le modal
    closeModal('bulkImportModal');
}

// Gestionnaire pour le changement de fichier
// [MVVM : View]
// Initialise les écouteurs d'événements pour la gestion interactive du modal d'importation en masse.
document.addEventListener('DOMContentLoaded', function () {
    const fileInput = document.getElementById('bulkImportFile');
    if (fileInput) {
        fileInput.addEventListener('change', function () {
            if (this.files && this.files[0]) {
                // Vider le textarea si un fichier est sélectionné
                document.getElementById('bulkImportText').value = '';
            }
        });
    }

    const textarea = document.getElementById('bulkImportText');
    if (textarea) {
        textarea.addEventListener('input', function () {
            if (this.value.trim()) {
                // Vider le file input si du texte est saisi
                document.getElementById('bulkImportFile').value = '';
            }
        });
    }
});

/**
 * [MVVM : Model]
 * Calcule la tension en temps réel pour un bloc de texte donné.
 * @param {string} text - Le contenu HTML ou brut à analyser.
 * @param {Object} [context] - Contexte narratif optionnel {actId, chapterId, sceneId}
 * @returns {Object} Un objet contenant le score (0-100) et le détail des mots trouvés.
 */
function calculateLiveTension(text, context = null) {
    if (!text || text.trim() === '' || text === '<p><br></p>') {
        return { score: 0, details: { high: 0, medium: 0, low: 0 }, foundWords: { high: [], medium: [], low: [] } };
    }

    // Nettoyer le HTML de manière consistante
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = text;
    // Remplacer les blocks par des espaces pour éviter les mots collés lors du stripping
    const blocks = tempDiv.querySelectorAll('p, div, br, h1, h2, h3');
    blocks.forEach(b => {
        if (b.tagName === 'BR') b.after(' ');
        else b.after(' ');
    });

    const cleanText = tempDiv.textContent.toLowerCase();
    const tensionWords = getTensionWords();
    const foundWords = { high: [], medium: [], low: [] };
    let lexicalScore = 0;

    // 1. ANALYSE LEXICALE
    tensionWords.high.forEach(word => {
        if (!word) return;
        const regex = new RegExp(`\\b${word}\\b`, 'gi');
        const matches = cleanText.match(regex);
        if (matches) {
            lexicalScore += matches.length * 8;
            foundWords.high.push(word);
        }
    });

    tensionWords.medium.forEach(word => {
        if (!word) return;
        const regex = new RegExp(`\\b${word}\\b`, 'gi');
        const matches = cleanText.match(regex);
        if (matches) {
            lexicalScore += matches.length * 4;
            foundWords.medium.push(word);
        }
    });

    tensionWords.low.forEach(word => {
        if (!word) return;
        const regex = new RegExp(`\\b${word}\\b`, 'gi');
        const matches = cleanText.match(regex);
        if (matches) {
            lexicalScore -= matches.length * 5;
            foundWords.low.push(word);
        }
    });

    // 2. ANALYSE PONCTUATION
    const exclamations = (cleanText.match(/!/g) || []).length;
    const questions = (cleanText.match(/\?/g) || []).length;
    const suspensions = (cleanText.match(/\.\.\./g) || []).length;
    lexicalScore += (exclamations * 1.5 + questions * 0.5 + suspensions * 2);

    // 3. FACTEUR DE DENSITÉ
    const wordCount = typeof getWordCount === 'function' ? getWordCount(text) : (cleanText.split(/\s+/).filter(w => w.length > 0).length || 1);

    // Formule de base pour l'intensité textuelle (0-60 points environ)
    let textIntensity = (lexicalScore / Math.sqrt(Math.max(50, wordCount))) * 5.2;

    // 4. BASELINE NARRATIVE
    let narrativeBaseline = 25; // Défaut si pas de contexte
    let structureBonus = 0;

    if (context && typeof project !== 'undefined') {
        const structuralData = getNarrativeContextData(context);
        if (structuralData) {
            narrativeBaseline = structuralData.baseline;
            if (structuralData.isCliffhanger) structureBonus = 5;
        }
    }

    // Calcul final : Baseline + Intensité textuelle + Bonus
    let finalScore = narrativeBaseline + textIntensity + structureBonus;

    // Normalisation 5-95
    finalScore = Math.max(5, Math.min(95, finalScore));

    return {
        score: Math.round(finalScore),
        details: {
            high: foundWords.high.length,
            medium: foundWords.medium.length,
            low: foundWords.low.length
        },
        foundWords: foundWords
    };
}

/**
 * [MVVM : Model]
 * Calcule la baseline narrative basée sur la position dans le récit.
 * Réutilise la même logique que le graphique d'intrigue.
 */
function getNarrativeContextData(context) {
    const { actId, chapterId, sceneId } = context;
    if (!project || !project.acts) return null;

    const actIndex = project.acts.findIndex(a => a.id === actId);
    if (actIndex === -1) return null;
    const act = project.acts[actIndex];
    const totalActs = project.acts.length;

    const chapterIndex = act.chapters.findIndex(c => c.id === chapterId);
    if (chapterIndex === -1) return null;
    const chapter = act.chapters[chapterIndex];
    const totalChapters = act.chapters.length;

    const sceneIndex = chapter.scenes.findIndex(s => s.id === sceneId);
    if (sceneIndex === -1) return null;
    const totalScenes = chapter.scenes.length;

    const chapterProgress = chapterIndex / Math.max(totalChapters - 1, 1);
    const sceneProgress = sceneIndex / Math.max(totalScenes - 1, 1);
    const actProgress = actIndex / Math.max(totalActs - 1, 1);

    let baseline = 0;

    // Structure classique en 3 actes (reprise de 33.plot.refactor.js)
    if (totalActs >= 3) {
        if (actIndex === 0) {
            baseline = 10 + (chapterProgress * 15);
        } else if (actIndex === totalActs - 1) {
            if (sceneProgress < 0.7) {
                baseline = 35 + (sceneProgress * 5);
            } else {
                baseline = 40 - ((sceneProgress - 0.7) * 50);
            }
        } else {
            baseline = 20 + (actProgress * 15);
        }
    } else if (totalActs === 2) {
        if (actIndex === 0) {
            baseline = 15 + (chapterProgress * 15);
        } else {
            baseline = 30 + (sceneProgress * 10);
        }
    } else {
        baseline = 20 + (sceneProgress * 20);
    }

    return {
        baseline: baseline,
        isCliffhanger: sceneIndex === totalScenes - 1
    };
}

/**
 * [MVVM : View]
 * Met à jour le "Tension Meter" dans l'UI.
 * @param {string} text - Contenu de la scène.
 * @param {Object} [context] - Contexte {actId, chapterId, sceneId}.
 */
function updateLiveTensionMeter(text, context = null) {
    const meter = document.getElementById('liveTensionMeter');
    if (!meter) {
        injectTensionMeter();
        // On ne retourne pas, injectTensionMeter crée l'élément
    }

    const result = calculateLiveTension(text, context);
    const score = result.score;

    const circle = document.getElementById('tensionMeterFill');
    if (circle) {
        const radius = 22;
        const circumference = 2 * Math.PI * radius;
        const offset = circumference - (score / 100) * circumference;
        circle.style.strokeDasharray = `${circumference} ${circumference}`;
        circle.style.strokeDashoffset = offset;

        if (score > 65) circle.style.stroke = 'var(--accent-red)';
        else if (score > 40) circle.style.stroke = 'var(--accent-gold)';
        else circle.style.stroke = 'var(--accent-blue)';
    }

    const valueDisplay = document.getElementById('tensionValueDisplay');
    if (valueDisplay) valueDisplay.textContent = `${score}%`;

    updateTensionTooltip(result);
}

/**
 * [MVVM : View]
 * Met à jour le contenu du tooltip de tension.
 */
function updateTensionTooltip(result) {
    const tooltip = document.getElementById('tensionTooltip');
    if (!tooltip) return;

    const highTags = result.foundWords.high.slice(0, 5).map(w => `<span class="tension-tag tension-tag-high">${w}</span>`).join('');
    const mediumTags = result.foundWords.medium.slice(0, 5).map(w => `<span class="tension-tag tension-tag-medium">${w}</span>`).join('');

    tooltip.innerHTML = `
        <div class="tension-tooltip-title">
            <i data-lucide="zap" style="width:14px;height:14px;"></i> Tension Directe
        </div>
        <div class="tension-tooltip-item">
            <span>Indice d'intensité</span>
            <strong>${result.score}%</strong>
        </div>
        <div class="tension-tooltip-item">
            <span>Mots-clés forts</span>
            <span style="color: var(--accent-red)">${result.details.high}</span>
        </div>
        <div class="tension-tooltip-item">
            <span>Mots-clés modérés</span>
            <span style="color: var(--accent-gold)">${result.details.medium}</span>
        </div>
        <div class="tension-tags-container">
            ${highTags}
            ${mediumTags}
        </div>
        <div style="margin-top: 0.75rem; font-size: 0.65rem; color: var(--text-muted); font-style: italic;">
            Analyse la scène active (sous le curseur ou visible à l'écran).
        </div>
    `;

    if (typeof lucide !== 'undefined') lucide.createIcons();
}

/**
 * [MVVM : View]
 * Injecte le composant Tension Meter dans le DOM s'il n'existe pas.
 */
function injectTensionMeter() {
    if (document.getElementById('liveTensionMeter')) return;

    const div = document.createElement('div');
    div.id = 'liveTensionMeter';
    div.className = 'tension-meter-container';
    div.setAttribute('title', 'Tension dramatique en temps réel');

    div.innerHTML = `
        <svg class="tension-meter-svg" viewBox="0 0 50 50">
            <circle class="tension-meter-bg" cx="25" cy="25" r="22"></circle>
            <circle class="tension-meter-fill" id="tensionMeterFill" cx="25" cy="25" r="22" stroke-dasharray="138.2" stroke-dashoffset="138.2"></circle>
        </svg>
        <div class="tension-value-display" id="tensionValueDisplay">--</div>
        <div class="tension-tooltip" id="tensionTooltip"></div>
    `;

    document.body.appendChild(div);

    if (typeof focusModeActive !== 'undefined' && focusModeActive) {
        div.classList.add('focus-hide');
    }
}

// ========== js/02.storage.js ==========
// ============================================
// INDEXEDDB FUNCTIONS
// ============================================

let db = null; // Instance de la base de données
let useLocalStorage = false; // Fallback si IndexedDB échoue

// Initialiser IndexedDB
// [MVVM : Model]
// Initialisation de la couche de données (Data Access Layer).
async function initDB() {
    try {
        console.log('🔧 Initialisation IndexedDB...');

        // Vérifier si IndexedDB est disponible
        if (!window.indexedDB) {
            console.warn('⚠️ IndexedDB non disponible, utilisation de localStorage');
            useLocalStorage = true;
            return true;
        }

        // Vérifier si idb est chargé
        if (typeof idb === 'undefined') {
            console.warn('⚠️ Bibliothèque idb non chargée, utilisation de localStorage');
            useLocalStorage = true;
            return true;
        }

        // Ouvrir (ou créer) la base de données
        db = await idb.openDB('PlumeDB', 1, {
            upgrade(db) {
                // Créer les object stores si ils n'existent pas
                if (!db.objectStoreNames.contains('projects')) {
                    db.createObjectStore('projects', { keyPath: 'id' });
                    console.log('✅ Object store "projects" créé');
                }
                if (!db.objectStoreNames.contains('settings')) {
                    db.createObjectStore('settings');
                    console.log('✅ Object store "settings" créé');
                }
            }
        });

        console.log('✅ IndexedDB initialisé avec succès');

        // Migrer depuis localStorage si nécessaire
        await migrateFromLocalStorage();

        return true;
    } catch (error) {
        console.error('❌ Erreur initialisation IndexedDB:', error);
        console.warn('⚠️ Fallback vers localStorage');
        useLocalStorage = true;
        return true; // Retourne true pour continuer avec localStorage
    }
}

// [MVVM : Model]
// Logique de migration de données.
async function migrateFromLocalStorage() {
    try {
        // Vérifier si migration déjà effectuée
        const migrated = await db.get('settings', 'migrated_from_localStorage');
        if (migrated) {
            console.log('✅ Migration déjà effectuée précédemment');
            return;
        }

        console.log('🔄 Vérification des données localStorage...');

        // Récupérer les anciennes données
        const oldData = localStorage.getItem('novelcraft_project');
        const oldProjects = localStorage.getItem('novelcraft_projects');
        const oldCurrentId = localStorage.getItem('novelcraft_currentProjectId');
        const oldTreeState = localStorage.getItem('treeState');

        if (!oldData && !oldProjects) {
            console.log('ℹ️ Aucune donnée à migrer');
            await db.put('settings', true, 'migrated_from_localStorage');
            return;
        }

        console.log('📦 Migration des données...');

        // Migrer le projet actuel
        if (oldData) {
            try {
                const projectData = JSON.parse(oldData);

                // S'assurer qu'il a un ID
                if (!projectData.id) {
                    projectData.id = 'project_' + Date.now();
                }

                // S'assurer qu'il a des timestamps
                if (!projectData.createdAt) {
                    projectData.createdAt = Date.now();
                }
                if (!projectData.updatedAt) {
                    projectData.updatedAt = Date.now();
                }

                await db.put('projects', projectData);
                console.log('✅ Projet principal migré:', projectData.title);
            } catch (e) {
                console.error('❌ Erreur migration projet:', e);
            }
        }

        // Migrer la liste des projets
        if (oldProjects) {
            try {
                const projectsList = JSON.parse(oldProjects);
                for (const proj of projectsList) {
                    // Éviter les doublons
                    const existing = await db.get('projects', proj.id);
                    if (!existing) {
                        await db.put('projects', proj);
                        console.log('✅ Projet migré:', proj.title);
                    }
                }
            } catch (e) {
                console.error('❌ Erreur migration liste projets:', e);
            }
        }

        // Migrer les settings
        if (oldCurrentId) {
            await db.put('settings', oldCurrentId, 'currentProjectId');
        }
        if (oldTreeState) {
            await db.put('settings', oldTreeState, 'treeState');
        }

        // Marquer la migration comme effectuée
        await db.put('settings', true, 'migrated_from_localStorage');

        console.log('✅ Migration terminée avec succès !');
        console.log('ℹ️ Les anciennes données localStorage sont conservées par sécurité');

        // NE PAS supprimer localStorage pour l'instant (sécurité)
        // L'utilisateur pourra le faire manuellement plus tard

    } catch (error) {
        console.error('❌ Erreur lors de la migration:', error);
    }
}

// Sauvegarder un projet dans IndexedDB
// [MVVM : Model]
// Persistance des données (Create/Update).
async function saveProjectToDB(projectData) {
    try {
        if (!db) {
            console.error('❌ Base de données non initialisée');
            return false;
        }

        // S'assurer que le projet a un ID
        if (!projectData.id) {
            projectData.id = 'project_' + Date.now();
        }

        // Mettre à jour le timestamp
        projectData.updatedAt = Date.now();

        // Sauvegarder dans IndexedDB
        await db.put('projects', projectData);

        console.log('💾 Projet sauvegardé dans IndexedDB:', projectData.title);
        return true;
    } catch (error) {
        console.error('❌ Erreur sauvegarde IndexedDB:', error);
        alert('Erreur lors de la sauvegarde. Veuillez exporter votre projet par sécurité.');
        return false;
    }
}

// Charger un projet depuis IndexedDB
// [MVVM : Model]
// Récupération de données (Read).
async function loadProjectFromDB(projectId) {
    try {
        if (!db) {
            console.error('❌ Base de données non initialisée');
            return null;
        }

        const projectData = await db.get('projects', projectId);

        if (projectData) {
            console.log('📖 Projet chargé depuis IndexedDB:', projectData.title);
            return projectData;
        } else {
            console.log('ℹ️ Projet non trouvé:', projectId);
            return null;
        }
    } catch (error) {
        console.error('❌ Erreur chargement IndexedDB:', error);
        return null;
    }
}

// Charger tous les projets
// [MVVM : Model]
// Récupération de collection (Read All).
async function loadAllProjectsFromDB() {
    try {
        if (!db) {
            console.error('❌ Base de données non initialisée');
            return [];
        }

        const allProjects = await db.getAll('projects');
        console.log(`📚 ${allProjects.length} projet(s) chargé(s)`);
        return allProjects;
    } catch (error) {
        console.error('❌ Erreur chargement projets:', error);
        return [];
    }
}

// Supprimer un projet
// [MVVM : Model]
// Suppression de données (Delete).
async function deleteProjectFromDB(projectId) {
    try {
        if (!db) {
            console.error('❌ Base de données non initialisée');
            return false;
        }

        await db.delete('projects', projectId);
        console.log('🗑️ Projet supprimé:', projectId);
        return true;
    } catch (error) {
        console.error('❌ Erreur suppression projet:', error);
        return false;
    }
}

// Obtenir la taille totale utilisée par IndexedDB
// [MVVM : Model]
// Métadonnées sur les données.
async function getIndexedDBSize() {
    try {
        if (!db) return 0;

        const allProjects = await db.getAll('projects');
        const allSettings = await db.getAll('settings');

        // Calculer la taille approximative
        const projectsSize = JSON.stringify(allProjects).length * 2; // UTF-16
        const settingsSize = JSON.stringify(allSettings).length * 2;

        return projectsSize + settingsSize;
    } catch (error) {
        console.error('❌ Erreur calcul taille IndexedDB:', error);
        return 0;
    }
}

// Sauvegarder un setting
// [MVVM : Model]
// Persistance de configuration.
async function saveSetting(key, value) {
    try {
        if (!db) return false;
        await db.put('settings', value, key);
        return true;
    } catch (error) {
        console.error('❌ Erreur sauvegarde setting:', error);
        return false;
    }
}

// Charger un setting
// [MVVM : Model]
// Récupération de configuration.
async function loadSetting(key) {
    try {
        if (!db) return null;
        return await db.get('settings', key);
    } catch (error) {
        console.error('❌ Erreur chargement setting:', error);
        return null;
    }
}

// ============================================
// END INDEXEDDB FUNCTIONS
// ============================================

// ========== js-refactor/03.projects.refactor.js ==========
/**
 * [MVVM : Projects Module]
 * Refactorisé pour séparer le modèle, le viewmodel et la vue.
 */

// --- MODEL & PERSISTENCE ---

/**
 * Charge tous les projets depuis IndexedDB.
 */
async function loadAllProjects() {
    try {
        const loadedProjects = await loadAllProjectsFromDB();

        if (loadedProjects && loadedProjects.length > 0) {
            projects = loadedProjects;
            const savedId = await loadSetting('currentProjectId');

            if (savedId) {
                currentProjectId = savedId;
                project = projects.find(p => p.id === savedId);
            }

            if (!project && projects.length > 0) {
                project = projects[0];
                currentProjectId = project.id;
            }
        } else {
            createDefaultProject();
            await saveProjectToDB(project);
        }

        ensureProjectStructure();

        if (project?.title) {
            const headerTitle = document.getElementById('headerProjectTitle');
            if (headerTitle) headerTitle.textContent = project.title;
        }

        console.log('✅ Projets chargés:', projects.length);
    } catch (error) {
        console.error('❌ Erreur chargement projets:', error);
        createDefaultProject();
    }
}

/**
 * Sauvegarde tous les projets dans IndexedDB.
 */
async function saveAllProjects() {
    try {
        if (currentProjectId) {
            const index = projects.findIndex(p => p.id === currentProjectId);
            if (index >= 0) {
                projects[index] = { ...project, updatedAt: new Date().toISOString() };
            }
        }

        for (const proj of projects) {
            await saveProjectToDB(proj);
        }

        await saveSetting('currentProjectId', currentProjectId);
        console.log('💾 Tous les projets sauvegardés');
    } catch (error) {
        console.error('❌ Erreur sauvegarde projets:', error);
    }
}

/**
 * Crée un projet par défaut si aucun n'existe.
 */
function createDefaultProject() {
    project = {
        id: Date.now(),
        title: "Mon Roman",
        description: "",
        genre: "",
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        acts: [],
        characters: [],
        world: [],
        timeline: [],
        notes: [],
        codex: [],
        stats: { dailyGoal: 500, totalGoal: 80000, writingSessions: [] },
        versions: [],
        relationships: []
    };
    projects = [project];
    currentProjectId = project.id;
}

/**
 * S'assure que la structure du projet est complète.
 */
function ensureProjectStructure() {
    if (!project) return;
    project.characters = project.characters || [];
    project.world = project.world || [];
    project.timeline = project.timeline || [];
    project.notes = project.notes || [];
    project.codex = project.codex || [];
    project.stats = project.stats || { dailyGoal: 500, totalGoal: 80000, writingSessions: [] };
    project.versions = project.versions || [];
    project.relationships = project.relationships || [];
}

// Override du saveProject global
saveProject = function () {
    saveAllProjects();
};

// --- VIEWMODEL (LOGIQUE MÉTIER) ---

/**
 * Crée un nouveau projet.
 */
function createNewProject() {
    const title = document.getElementById('newProjectTitle').value.trim();
    const description = document.getElementById('newProjectDesc').value.trim();
    const genre = document.getElementById('newProjectGenre').value;
    const template = document.getElementById('newProjectTemplate').value;

    if (!title) {
        alert('Veuillez entrer un titre pour le projet');
        return;
    }

    const newProject = {
        id: Date.now(),
        title: title,
        description: description,
        genre: genre,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        acts: [],
        characters: [],
        world: [],
        timeline: [],
        notes: [],
        codex: [],
        stats: { dailyGoal: 500, totalGoal: 80000, writingSessions: [] },
        versions: [],
        relationships: []
    };

    // Templates
    if (template === 'fantasy') {
        newProject.acts = [
            { id: Date.now(), title: "Acte I - Le Monde Ordinaire", chapters: [] },
            { id: Date.now() + 1, title: "Acte II - L'Aventure", chapters: [] },
            { id: Date.now() + 2, title: "Acte III - Le Retour", chapters: [] }
        ];
    } else if (template === 'thriller') {
        newProject.acts = [
            { id: Date.now(), title: "Acte I - L'Incident", chapters: [] },
            { id: Date.now() + 1, title: "Acte II - La Tension", chapters: [] },
            { id: Date.now() + 2, title: "Acte III - Le Dénouement", chapters: [] }
        ];
    }

    projects.push(newProject);
    saveAllProjects();

    // Reset UI
    document.getElementById('newProjectTitle').value = '';
    document.getElementById('newProjectDesc').value = '';

    closeModal('newProjectModal');
    switchToProject(newProject.id);
    closeModal('projectsModal');
}

/**
 * Change le projet actif.
 */
function switchToProject(projectId) {
    currentProjectId = projectId;
    project = projects.find(p => p.id === projectId);

    if (!project) return;

    const headerTitle = document.getElementById('headerProjectTitle');
    if (headerTitle) headerTitle.textContent = project.title;

    currentActId = null;
    currentChapterId = null;
    currentSceneId = null;

    if (typeof switchView === 'function') switchView('editor');
    if (typeof renderActsList === 'function') renderActsList();
    if (typeof refreshAllViews === 'function') refreshAllViews();

    localStorage.setItem('plume_locale_current_project', projectId);
}

/**
 * Supprime un projet.
 */
function deleteProject(projectId) {
    const proj = projects.find(p => p.id === projectId);
    if (!proj) return;

    if (!confirm(`Supprimer "${proj.title}" ?\n\nIrréversible !`)) return;

    projects = projects.filter(p => p.id !== projectId);
    saveAllProjects();

    if (currentProjectId === projectId) {
        if (projects.length > 0) {
            switchToProject(projects[0].id);
        } else {
            createDefaultProject();
        }
    }

    renderProjectsList();
}

/**
 * Exporte un projet.
 */
function exportProjectIndividual(projectId) {
    const proj = projects.find(p => p.id === projectId);
    if (!proj) return;

    const dataStr = JSON.stringify(proj, null, 2);
    const blob = new Blob([dataStr], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${proj.title.replace(/\s+/g, '_')}_${new Date().toISOString().split('T')[0]}.json`;
    a.click();
    URL.revokeObjectURL(url);
}

/**
 * Gère l'import d'un projet.
 */
function handleProjectImport(event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = function (e) {
        try {
            const imported = JSON.parse(e.target.result);
            if (!imported.title) throw new Error('Format invalide');

            imported.id = Date.now();
            imported.title += " (Importé)";
            imported.createdAt = new Date().toISOString();
            imported.updatedAt = new Date().toISOString();

            projects.push(imported);
            saveAllProjects();
            renderProjectsList();
            alert(`✅ "${imported.title}" importé !`);
        } catch (error) {
            alert('❌ Erreur: ' + error.message);
        }
        event.target.value = '';
    };
    reader.readAsText(file);
}

// --- VIEW (RENDU DOM) ---

/**
 * Ouvre la modale de création.
 */
function openNewProjectModal() {
    const modal = document.getElementById('newProjectModal');
    if (modal) {
        modal.classList.add('active');
        setTimeout(() => document.getElementById('newProjectTitle')?.focus(), 100);
    }
}

/**
 * Déclenche l'import.
 */
function importProject() {
    document.getElementById('importProjectInput')?.click();
}

/**
 * Affiche la liste des projets.
 */
function renderProjectsList() {
    const container = document.getElementById('projectsList');
    if (!container) return;

    if (projects.length === 0) {
        container.innerHTML = '<div style="padding: 2rem; text-align: center; color: var(--text-muted);">Aucun projet</div>';
        return;
    }

    container.innerHTML = projects.map(proj => {
        const isActive = proj.id === currentProjectId;

        // Calcul des statistiques
        const actCount = proj.acts ? proj.acts.length : 0;
        let chapterCount = 0;
        let sceneCount = 0;
        let wordCount = 0;

        if (proj.acts) {
            proj.acts.forEach(act => {
                if (act.chapters) {
                    chapterCount += act.chapters.length;
                    act.chapters.forEach(chap => {
                        if (chap.scenes) {
                            sceneCount += chap.scenes.length;
                            chap.scenes.forEach(scene => {
                                const text = scene.content ? stripHTML(scene.content) : '';
                                if (text.trim().length > 0) {
                                    const words = text.trim().match(/[\w\u00C0-\u00FF]+(?:[''’][\w\u00C0-\u00FF]+)*/g);
                                    if (words) wordCount += words.length;
                                }
                            });
                        }
                    });
                }
            });
        }

        const charCount = proj.characters ? proj.characters.length : 0;
        const worldCount = proj.world ? proj.world.length : 0;
        const codexCount = proj.codex ? proj.codex.length : 0;

        return `
            <div class="project-card ${isActive ? 'active' : ''}" onclick="switchToProject(${proj.id}); closeModal('projectsModal');">
                <div class="project-card-header">
                    <div>
                        <div class="project-card-title">${proj.title}</div>
                        ${proj.genre ? `<span class="project-card-genre">${proj.genre}</span>` : ''}
                    </div>
                    ${isActive ? '<span style="color: var(--accent-red); font-weight: 600;">● Actif</span>' : ''}
                </div>
                ${proj.description ? `<div class="project-card-desc">${proj.description}</div>` : ''}
                
                <!-- Statistiques rapides -->
                <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(110px, 1fr)); gap: 0.5rem; margin-top: 1rem; padding-top: 0.75rem; border-top: 1px solid var(--border-color); font-size: 0.8rem; color: var(--text-muted);">
                    <div style="display: flex; align-items: center; gap: 6px;" title="Nombre de mots total">
                        <i data-lucide="align-left" style="width: 14px; height: 14px; color: var(--accent-gold);"></i> 
                        <span style="font-weight: 600;">${wordCount.toLocaleString('fr-FR')}</span> mots
                    </div>
                    <div style="display: flex; align-items: center; gap: 6px;" title="Nombre d'actes">
                        <i data-lucide="book" style="width: 14px; height: 14px;"></i> 
                        <span>${actCount} actes</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 6px;" title="Nombre de chapitres">
                        <i data-lucide="bookmark" style="width: 14px; height: 14px;"></i> 
                        <span>${chapterCount} chapitres</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 6px;" title="Nombre de scènes">
                        <i data-lucide="file-text" style="width: 14px; height: 14px;"></i> 
                        <span>${sceneCount} scènes</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 6px;" title="Personnages">
                        <i data-lucide="users" style="width: 14px; height: 14px;"></i> 
                        <span>${charCount} pers.</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 6px;" title="Entrées Univers">
                        <i data-lucide="globe" style="width: 14px; height: 14px;"></i> 
                        <span>${worldCount} univ.</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 6px;" title="Entrées Codex">
                        <i data-lucide="book-open" style="width: 14px; height: 14px;"></i> 
                        <span>${codexCount} codex</span>
                    </div>
                </div>

                <div class="project-card-actions">
                    <button class="btn btn-small" onclick="event.stopPropagation(); showBackupMenu()"><i data-lucide="upload" style="width:12px;height:12px;margin-right:4px;vertical-align:middle;"></i> Exporter</button>
                    <button class="btn btn-small" onclick="event.stopPropagation(); deleteProject(${proj.id})"><i data-lucide="trash-2" style="width:12px;height:12px;margin-right:4px;vertical-align:middle;"></i> Supprimer</button>
                </div>
            </div>`;
    }).join('');

    // Re-trigger icons
    if (typeof lucide !== 'undefined') {
        lucide.createIcons();
    }
}

/**
 * Rendu pour Split View ou conteneur spécifique.
 */
function renderSceneInContainer(actId, chapterId, sceneId, containerId) {
    const container = document.getElementById(containerId);
    if (!container) return;

    const act = project.acts.find(a => a.id === actId);
    const chapter = act?.chapters.find(c => c.id === chapterId);
    const scene = chapter?.scenes.find(s => s.id === sceneId);

    if (!scene) return;

    const wordCount = typeof getWordCount === 'function' ? getWordCount(scene.content || '') : 0;

    container.innerHTML = `
        <div class="split-scene-view" style="height: 100%; display: flex; flex-direction: column;">
            <div style="padding: 0.75rem 1rem; background: var(--bg-secondary); border-bottom: 1px solid var(--border-color);">
                <div style="font-size: 0.8rem; color: var(--text-muted);">${act.title} > ${chapter.title}</div>
                <div style="font-size: 1.1rem; font-weight: 600;">${scene.title || 'Sans titre'}</div>
                <div style="font-size: 0.75rem; color: var(--text-muted);">${wordCount} mots</div>
            </div>
            <div class="editor-textarea" 
                 contenteditable="true" 
                 data-container="${containerId}"
                 data-scene-id="${scene.id}"
                 data-chapter-id="${chapter.id}"
                 data-act-id="${act.id}"
                 oninput="updateSplitSceneContent(this)"
                 style="flex: 1; padding: 1.5rem; overflow-y: auto; outline: none; line-height: 1.8; font-size: 1.1rem;"
            >${scene.content || ''}</div>
        </div>`;
}

// --- ANALYSE DE TEXTE ---

/**
 * Rendu de la vue analyse.
 */
function renderAnalysis() {
    const editorView = document.getElementById('editorView');
    if (!editorView) return;

    editorView.innerHTML = `
        <div style="height: 100%; overflow-y: auto; padding: 2rem 3rem;">
            <h2 style="margin-bottom: 2rem; color: var(--accent-gold);">
                <i data-lucide="scan-search" style="width:24px;height:24px;vertical-align:middle;margin-right:8px;"></i>Analyse du texte
            </h2>
            <div style="background: var(--bg-secondary); padding: 2rem; border-radius: 8px; margin-bottom: 2rem;">
                <label style="display: block; font-weight: 600; margin-bottom: 1rem; font-size: 1rem;">Portée de l'analyse :</label>
                <select id="analysisScope" class="form-input" style="width: 100%; max-width: 400px; font-size: 1rem;">
                    <option value="current">Scène actuelle</option>
                    <option value="chapter">Chapitre actuel</option>
                    <option value="act">Acte actuel</option>
                    <option value="all">Tout le projet</option>
                </select>
            </div>
            <div id="analysisResults"></div>
        </div>`;

    setTimeout(() => {
        document.getElementById('analysisScope')?.addEventListener('change', runTextAnalysis);
        runTextAnalysis();
    }, 0);
}

/**
 * Lance l'analyse.
 */
function runTextAnalysis() {
    const scope = document.getElementById('analysisScope')?.value || 'current';
    const text = typeof getTextForAnalysis === 'function' ? getTextForAnalysis(scope) : '';

    if (!text || text.trim().length === 0) {
        document.getElementById('analysisResults').innerHTML = '<div style="padding: 2rem; text-align: center; color: var(--text-muted);">Aucun texte à analyser</div>';
        return;
    }

    const analysis = {
        wordCount: typeof getWordCount === 'function' ? getWordCount(text) : 0,
        repetitions: typeof detectRepetitions === 'function' ? detectRepetitions(text) : [],
        readability: typeof calculateReadability === 'function' ? calculateReadability(text) : { score: 0, level: 'N/A' },
        wordFrequency: typeof calculateWordFrequency === 'function' ? calculateWordFrequency(text) : [],
        sentenceLength: typeof calculateSentenceLength === 'function' ? calculateSentenceLength(text) : { avg: 0, min: 0, max: 0, distribution: [] },
        narrativeDistribution: typeof analyzeNarrativeDistribution === 'function' ? analyzeNarrativeDistribution(text) : { dialogue: 0, narrative: 0, dialogCount: 0 }
    };

    if (typeof displayAnalysisResults === 'function') displayAnalysisResults(analysis);
}

// [MVVM : ViewModel]
// Helper : extrait les données brutes nécessaires depuis le modèle selon le contexte de vue
function getTextForAnalysis(scope) {
    console.log('getTextForAnalysis called with scope:', scope);
    console.log('currentActId:', currentActId, 'currentChapterId:', currentChapterId, 'currentSceneId:', currentSceneId);

    if (scope === 'current' && currentSceneId) {
        const act = project.acts.find(a => a.id === currentActId);
        if (!act) return '';
        const chapter = act.chapters.find(c => c.id === currentChapterId);
        if (!chapter) return '';
        const scene = chapter.scenes.find(s => s.id === currentSceneId);
        if (!scene) return '';
        return stripHTML(scene.content);
    } else if (scope === 'chapter') {
        if (!currentChapterId) {
            // Try to use first chapter of first act
            if (project.acts.length > 0 && project.acts[0].chapters.length > 0) {
                const chapter = project.acts[0].chapters[0];
                const text = chapter.scenes.map(s => stripHTML(s.content)).join('\n\n');
                return text;
            }
            return '';
        }
        const act = project.acts.find(a => a.id === currentActId);
        if (!act) return '';
        const chapter = act.chapters.find(c => c.id === currentChapterId);
        if (!chapter) return '';
        const text = chapter.scenes.map(s => stripHTML(s.content)).join('\n\n');
        return text;
    } else if (scope === 'act') {
        if (!currentActId) {
            // Try to use first act
            if (project.acts.length > 0) {
                const act = project.acts[0];
                const text = act.chapters.flatMap(ch => ch.scenes.map(s => stripHTML(s.content))).join('\n\n');
                return text;
            }
            return '';
        }
        const act = project.acts.find(a => a.id === currentActId);
        if (!act) return '';
        const text = act.chapters.flatMap(ch => ch.scenes.map(s => stripHTML(s.content))).join('\n\n');
        return text;
    } else if (scope === 'all') {
        const text = project.acts.flatMap(a => a.chapters.flatMap(ch => ch.scenes.map(s => stripHTML(s.content)))).join('\n\n');
        return text;
    }
    return '';
}

// [MVVM : Other]
// [HELPER] Utilitaire de traitement de chaîne (agnostique)
function stripHTML(html) {
    const div = document.createElement('div');
    div.innerHTML = html;
    return div.textContent || div.innerText || '';
}

// [MVVM : Model]
// Algorithme pur : logique de détection des répétitions
function detectRepetitions(text) {
    // Correction pour inclure les caractères accentués français et autres Unicode
    const words = text.toLowerCase().match(/[\p{L}]{4,}/gu) || [];
    const frequency = {};
    words.forEach(word => frequency[word] = (frequency[word] || 0) + 1);

    const repeated = Object.entries(frequency)
        .filter(([word, count]) => count >= 5)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 10);

    return repeated;
}

// [MVVM : Model]
// Algorithme pur : calcul de score de lisibilité
function calculateReadability(text) {
    const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
    // Correction pour inclure les caractères accentués français et autres Unicode
    const words = text.match(/[\p{L}]+/gu) || [];
    const syllables = words.reduce((sum, word) => sum + countSyllables(word), 0);

    if (sentences.length === 0 || words.length === 0) return { score: 0, level: 'N/A' };

    // Flesch Reading Ease (adapted for French)
    const avgWordsPerSentence = words.length / sentences.length;
    const avgSyllablesPerWord = syllables / words.length;
    const score = 206.835 - (1.015 * avgWordsPerSentence) - (84.6 * avgSyllablesPerWord);

    let level = '';
    if (score >= 90) level = 'Très facile';
    else if (score >= 80) level = 'Facile';
    else if (score >= 70) level = 'Assez facile';
    else if (score >= 60) level = 'Standard';
    else if (score >= 50) level = 'Assez difficile';
    else if (score >= 30) level = 'Difficile';
    else level = 'Très difficile';

    return { score: Math.max(0, Math.min(100, score)).toFixed(1), level };
}

// [MVVM : Model]
// Helper algorithmique : comptage de syllabes
function countSyllables(word) {
    word = word.toLowerCase();
    const vowels = /[aeiouyàâäéèêëïîôùûü]/g;
    const matches = word.match(vowels);
    if (!matches) return 1;

    let count = matches.length;
    // Adjustments for French
    if (word.endsWith('e')) count--;
    if (word.match(/[aeiouy]{2,}/)) count--;
    return Math.max(1, count);
}

// [MVVM : Model]
// Algorithme pur : analyse de fréquence des mots
function calculateWordFrequency(text) {
    // Correction pour inclure les caractères accentués français et autres Unicode
    const words = text.toLowerCase().match(/[\p{L}]{3,}/gu) || [];
    const stopWords = new Set(['le', 'la', 'les', 'un', 'une', 'des', 'de', 'du', 'et', 'ou', 'où', 'qui', 'que', 'quoi', 'dont', 'ce', 'cette', 'ces', 'son', 'sa', 'ses', 'mon', 'ma', 'mes', 'ton', 'ta', 'tes', 'notre', 'nos', 'votre', 'vos', 'leur', 'leurs', 'je', 'tu', 'il', 'elle', 'nous', 'vous', 'ils', 'elles', 'on', 'ne', 'pas', 'plus', 'dans', 'sur', 'pour', 'par', 'avec', 'sans', 'est', 'était', 'être', 'avoir', 'fait', 'faire', 'dit', 'dire', 'peut', 'bien', 'tout', 'tous', 'comme', 'très', 'aussi', 'encore', 'mais', 'donc', 'ainsi']);

    const frequency = {};
    words.forEach(word => {
        if (!stopWords.has(word)) {
            frequency[word] = (frequency[word] || 0) + 1;
        }
    });

    return Object.entries(frequency)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 15);
}

// [MVVM : Model]
// Algorithme pur : statistiques de longueur de phrases
function calculateSentenceLength(text) {
    const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
    const lengths = sentences.map(s => s.trim().split(/\s+/).length);

    if (lengths.length === 0) return { avg: 0, min: 0, max: 0, distribution: [] };

    const avg = lengths.reduce((a, b) => a + b, 0) / lengths.length;
    const min = Math.min(...lengths);
    const max = Math.max(...lengths);

    // Distribution
    const ranges = [
        { label: '1-5 mots', count: lengths.filter(l => l >= 1 && l <= 5).length },
        { label: '6-10 mots', count: lengths.filter(l => l >= 6 && l <= 10).length },
        { label: '11-15 mots', count: lengths.filter(l => l >= 11 && l <= 15).length },
        { label: '16-20 mots', count: lengths.filter(l => l >= 16 && l <= 20).length },
        { label: '20+ mots', count: lengths.filter(l => l > 20).length }
    ];

    return { avg: avg.toFixed(1), min, max, distribution: ranges };
}

// [MVVM : Model]
// Algorithme pur : analyse de distribution narrative/dialogue
function analyzeNarrativeDistribution(text) {
    const dialogRegex = /[«"—–]\s*[^»"—–]{10,}?\s*[»"—–]/g;
    const dialogs = text.match(dialogRegex) || [];
    const dialogLength = dialogs.join('').length;
    const totalLength = text.length;

    const dialogPercent = totalLength > 0 ? (dialogLength / totalLength * 100).toFixed(1) : 0;
    const narrativePercent = totalLength > 0 ? (100 - dialogPercent).toFixed(1) : 0;

    return {
        dialogue: dialogPercent,
        narrative: narrativePercent,
        dialogCount: dialogs.length
    };
}

// [MVVM : View]
// Rendu des résultats d'analyse (Génération HTML)
function displayAnalysisResults(analysis) {
    const container = document.getElementById('analysisResults');

    container.innerHTML = `
                <div style="margin-top: 1rem;">
                    <!-- General Stats -->
                    <div style="background: var(--bg-primary); padding: 1rem; border-radius: 4px; border: 1px solid var(--border-color); margin-bottom: 1rem;">
                        <div style="font-weight: 700; font-size: 1rem; margin-bottom: 0.75rem; color: var(--accent-gold);"><i data-lucide="bar-chart-3" style="width:16px;height:16px;vertical-align:middle;margin-right:6px;"></i>Statistiques générales</div>
                        <div style="font-size: 1.2rem; font-weight: 600;">${analysis.wordCount.toLocaleString('fr-FR')} mots</div>
                    </div>

                    <!-- Readability -->
                    <div style="background: var(--bg-primary); padding: 1rem; border-radius: 4px; border: 1px solid var(--border-color); margin-bottom: 1rem;">
                        <div style="font-weight: 700; font-size: 1rem; margin-bottom: 0.75rem; color: var(--accent-gold);"><i data-lucide="book-open" style="width:16px;height:16px;vertical-align:middle;margin-right:6px;"></i>Lisibilité (Flesch)</div>
                        <div style="font-size: 1.1rem; margin-bottom: 0.25rem;">Score: <strong>${analysis.readability.score}</strong> / 100</div>
                        <div style="color: var(--text-muted);">Niveau: ${analysis.readability.level}</div>
                        <div style="margin-top: 0.5rem; font-size: 0.75rem; color: var(--text-muted); line-height: 1.4;">
                            Plus le score est élevé, plus le texte est facile à lire. 60-70 = Standard, 70-80 = Facile.
                        </div>
                    </div>

                    <!-- Sentence Length -->
                    <div style="background: var(--bg-primary); padding: 1rem; border-radius: 4px; border: 1px solid var(--border-color); margin-bottom: 1rem;">
                        <div style="font-weight: 700; font-size: 1rem; margin-bottom: 0.75rem; color: var(--accent-gold);"><i data-lucide="ruler" style="width:16px;height:16px;vertical-align:middle;margin-right:6px;"></i>Longueur des phrases</div>
                        <div style="display: flex; gap: 1rem; margin-bottom: 0.75rem;">
                            <div><strong>Moyenne:</strong> ${analysis.sentenceLength.avg} mots</div>
                            <div><strong>Min:</strong> ${analysis.sentenceLength.min}</div>
                            <div><strong>Max:</strong> ${analysis.sentenceLength.max}</div>
                        </div>
                        <div style="font-size: 0.8rem; font-weight: 600; margin-bottom: 0.5rem;">Distribution:</div>
                        ${analysis.sentenceLength.distribution.map(r => `
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.25rem;">
                                <span style="font-size: 0.75rem;">${r.label}</span>
                                <div style="flex: 1; margin: 0 0.5rem; height: 8px; background: var(--bg-secondary); border-radius: 4px; overflow: hidden;">
                                    <div style="height: 100%; width: ${r.count * 100 / analysis.sentenceLength.distribution.reduce((s, d) => s + d.count, 0)}%; background: var(--accent-gold);"></div>
                                </div>
                                <span style="font-size: 0.75rem; font-weight: 600; min-width: 30px; text-align: right;">${r.count}</span>
                            </div>
                        `).join('')}
                    </div>

                    <!-- Narrative Distribution -->
                    <div style="background: var(--bg-primary); padding: 1rem; border-radius: 4px; border: 1px solid var(--border-color); margin-bottom: 1rem;">
                        <div style="font-weight: 700; font-size: 1rem; margin-bottom: 0.75rem; color: var(--accent-gold);"><i data-lucide="message-circle" style="width:16px;height:16px;vertical-align:middle;margin-right:6px;"></i>Distribution narrative</div>
                        <div style="display: flex; gap: 1rem; margin-bottom: 0.75rem;">
                            <div><strong>Dialogues:</strong> ${analysis.narrativeDistribution.dialogue}%</div>
                            <div><strong>Narration:</strong> ${analysis.narrativeDistribution.narrative}%</div>
                        </div>
                        <div style="height: 20px; background: var(--bg-secondary); border-radius: 4px; overflow: hidden; display: flex;">
                            <div style="height: 100%; width: ${analysis.narrativeDistribution.dialogue}%; background: #4CAF50;" title="Dialogues"></div>
                            <div style="height: 100%; width: ${analysis.narrativeDistribution.narrative}%; background: var(--accent-gold);" title="Narration"></div>
                        </div>
                        <div style="margin-top: 0.5rem; font-size: 0.75rem; color: var(--text-muted);">
                            ${analysis.narrativeDistribution.dialogCount} segments de dialogue détectés
                        </div>
                    </div>

                    <!-- Word Frequency -->
                    <div style="background: var(--bg-primary); padding: 1rem; border-radius: 4px; border: 1px solid var(--border-color); margin-bottom: 1rem;">
                        <div style="font-weight: 700; font-size: 1rem; margin-bottom: 0.75rem; color: var(--accent-gold);"><i data-lucide="type" style="width:16px;height:16px;vertical-align:middle;margin-right:6px;"></i>Mots les plus fréquents</div>
                        <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 0.5rem;">
                            ${analysis.wordFrequency.map(([word, count]) => `
                                <div style="padding: 0.4rem 0.6rem; background: var(--bg-secondary); border-radius: 2px; font-size: 0.75rem;">
                                    <strong>${word}</strong>: ${count}×
                                </div>
                            `).join('')}
                        </div>
                    </div>

                    <!-- Repetitions -->
                    <div style="background: var(--bg-primary); padding: 1rem; border-radius: 4px; border: 1px solid var(--border-color);">
                        <div style="font-weight: 700; font-size: 1rem; margin-bottom: 0.75rem; color: var(--accent-red);"><i data-lucide="alert-triangle" style="width:16px;height:16px;vertical-align:middle;margin-right:6px;"></i>Répétitions à surveiller (5+ occurrences)</div>
                        ${analysis.repetitions.length > 0 ? `
                            <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 0.5rem;">
                                ${analysis.repetitions.map(([word, count]) => `
                                    <div style="padding: 0.4rem 0.6rem; background: rgba(196, 69, 54, 0.1); border: 1px solid var(--accent-red); border-radius: 2px; font-size: 0.75rem;">
                                        <strong>${word}</strong>: ${count}×
                                    </div>
                                `).join('')}
                            </div>
                        ` : '<div style="color: var(--text-muted); font-size: 0.85rem;">Aucune répétition excessive détectée</div>'}
                    </div>
                </div>
            `;
}


// ========== js/04.init.js ==========
// Initialize
// [MVVM : Other]
// Mixte (Controller/Initialization)
async function init() {
    // Initialiser IndexedDB en premier
    const dbReady = await initDB();
    if (!dbReady) {
        console.error('❌ Impossible d\'initialiser la base de données');
        alert('Erreur critique : impossible d\'initialiser le stockage. Rechargez la page.');
        return;
    }

    // Charger les projets depuis IndexedDB
    await loadAllProjects();
    await loadTreeState(); // Charger l'état d'expansion

    // Forcer la vue Structure au démarrage
    currentView = 'editor';

    // S'assurer que les autres vues sont cachées
    setTimeout(() => {
        // Masquer toutes les vues
        const viewsToHide = ['charactersList', 'worldList', 'notesList', 'codexList', 'statsList',
            'versionsList', 'analysisList', 'todosList', 'corkboardList'];
        viewsToHide.forEach(viewId => {
            const el = document.getElementById(viewId);
            if (el) el.style.display = 'none';
        });

        // Afficher la structure
        const chaptersList = document.getElementById('chaptersList');
        if (chaptersList) chaptersList.style.display = 'block';

        // Activer l'onglet Structure
        document.querySelectorAll('[id^="tab-"]').forEach(tab => {
            tab.classList.remove('btn-primary');
        });
        const editorTab = document.getElementById('tab-editor');
        if (editorTab) editorTab.classList.add('btn-primary');
    }, 100);

    switchView('editor');
    renderActsList();

    // Initialiser l'historique avec l'état initial
    saveToHistory();

    // Initialize color pickers
    initializeColorPickers();

    // Initialize sidebar resize
    initSidebarResize();

    // Initialize floating editor menu (mobile)
    initFloatingEditorMenu();

    // Initialize touch gestures for editor
    initEditorGestures();

    // Initialize storage monitoring
    initStorageMonitoring();

    // Initialize scene versions sidebar
    renderSceneVersionsList();

    // Initialize progress bar
    updateProgressBar();

    // Auto-save every 30 seconds
    setInterval(saveProject, 30000);

    // Update storage badge every 10 seconds
    setInterval(updateStorageBadge, 10000);

    // Initialize product tour
    if (typeof initProductTourVM === 'function') {
        await initProductTourVM();
    }
}

// Fonction utilitaire pour convertir un nombre en chiffres romains
// [MVVM : Other]
// Fonction utilitaire pour convertir un nombre en chiffres romains (Utility)
function toRoman(num) {
    const romanNumerals = [
        { value: 10, numeral: 'X' },
        { value: 9, numeral: 'IX' },
        { value: 5, numeral: 'V' },
        { value: 4, numeral: 'IV' },
        { value: 1, numeral: 'I' }
    ];

    let result = '';
    for (const { value, numeral } of romanNumerals) {
        while (num >= value) {
            result += numeral;
            num -= value;
        }
    }
    return result;
}

// Save/Load from localStorage
// [MVVM : ViewModel]
// Gère la sauvegarde du projet avec debounce pour l'historique
async function saveProject() {
    try {
        // Sauvegarder dans IndexedDB
        const success = await saveProjectToDB(project);

        if (!success) {
            throw new Error('Échec de la sauvegarde IndexedDB');
        }

        // Mettre à jour le badge de stockage après chaque sauvegarde
        updateStorageBadge();

        console.log('💾 saveProject appelé - isUndoRedoAction:', isUndoRedoAction);

        // Si c'est une action undo/redo, ne pas sauvegarder dans l'historique
        if (isUndoRedoAction) {
            console.log('⏭️ Action undo/redo, pas de sauvegarde historique');
            return;
        }

        // Si c'est le premier changement (pas de timer actif)
        if (!historyDebounceTimer) {
            console.log('🆕 Premier changement - sauvegarde immédiate');
            // Sauvegarder l'état ACTUEL comme point de départ
            saveToHistory();
            lastSavedState = JSON.stringify(project);
        } else {
            console.log('⏱️ Timer existant, réinitialisation');
        }

        // Annuler le timer précédent
        if (historyDebounceTimer) {
            clearTimeout(historyDebounceTimer);
        }

        // Créer un nouveau timer
        historyDebounceTimer = setTimeout(() => {
            console.log('⏰ Timer expiré - vérification changements');
            // Sauvegarder l'état final après la pause
            const finalState = JSON.stringify(project);

            // Ne sauvegarder que si l'état a changé
            if (finalState !== lastSavedState) {
                console.log('✏️ État modifié - sauvegarde finale');
                saveToHistory();
                lastSavedState = finalState;
            } else {
                console.log('⏭️ Aucun changement détecté');
            }

            historyDebounceTimer = null; // Réinitialiser
        }, historyDebounceDelay);
    } catch (error) {
        console.error('❌ Erreur de sauvegarde:', error);
        alert('Erreur lors de la sauvegarde. Veuillez exporter votre projet par sécurité.');
    }
}

// [MVVM : ViewModel]
// Gère le renommage du projet (Input et mise à jour Modèle/Vue)
function renameProject() {
    const newName = prompt('Nouveau nom du projet :', project.title || 'Mon Roman');
    if (newName === null) return; // Annulé

    const trimmedName = newName.trim();
    if (trimmedName === '') {
        showNotification('Le nom ne peut pas être vide');
        return;
    }

    project.title = trimmedName;

    // Mettre à jour le titre dans le header
    const headerTitle = document.getElementById('headerProjectTitle');
    if (headerTitle) {
        headerTitle.textContent = trimmedName;
    }

    // Mettre à jour le titre de la page
    document.title = trimmedName + ' - Plume';

    saveProject();
    showNotification('✓ Projet renommé');
}


// ========== js-refactor/05.undo-redo.refactor.js ==========
/**
 * [MVVM : ViewModel]
 * Systeme d'Undo/Redo complet pour Plume
 *
 * Architecture basee sur les snapshots avec debouncing intelligent.
 * Gere TOUTES les fonctionnalites de l'application.
 */

// ============================================
// CONFIGURATION
// ============================================

const UndoRedoConfig = {
    maxHistorySize: 50,           // Nombre maximum d'etats dans l'historique
    debounceDelay: 1000,          // Delai de debounce en ms (1 seconde)
    excludeKeys: [                // Cles a exclure des snapshots (etat UI temporaire)
        'updatedAt'               // Les timestamps ne declenchent pas de changements
    ],
    // Actions qui necessitent une sauvegarde immediate (pas de debounce)
    immediateActions: [
        'add', 'remove', 'delete', 'create', 'reorder', 'move', 'toggle'
    ],
    // Traduction des types d'actions en libellés lisibles
    actionLabels: {
        'Act.add': 'Ajout d\'un acte',
        'Act.delete': 'Suppression d\'un acte',
        'Act.reorder': 'Réordonnancement des actes',
        'Chapter.add': 'Ajout d\'un chapitre',
        'Chapter.delete': 'Suppression d\'un chapitre',
        'Chapter.reorder': 'Réordonnancement des chapitres',
        'Scene.add': 'Ajout d\'une scène',
        'Scene.delete': 'Suppression d\'une scène',
        'Scene.reorder': 'Réordonnancement des scènes',
        'Scene.move': 'Déplacement d\'une scène',
        'Character.add': 'Nouveau personnage',
        'Character.delete': 'Suppression d\'un personnage',
        'World.add': 'Nouvel élément de monde',
        'World.delete': 'Suppression d\'un élément',
        'Codex.add': 'Ajout au codex',
        'Codex.delete': 'Suppression du codex',
        'Codex.update': 'Modification du codex',
        'text-edit': 'Modification de texte',
        'text-edit-start': 'Début d\'édition',
        'text-edit-end': 'Fin d\'édition',
        'Arc.create': 'Nouvel arc narratif',
        'Arc.delete': 'Suppression d\'un arc',
        'BoardItem.create': 'Nouvel élément sur le tableau',
        'BoardItem.delete': 'Suppression d\'un élément',
        'Card.create': 'Nouvelle carte',
        'Card.delete': 'Suppression d\'une carte',
        'Card.move': 'Déplacement d\'une carte',
        'Connection.create': 'Nouvelle connexion',
        'Connection.delete': 'Suppression de connexion',
        'toggleTodo': 'Changement d\'état TODO',
        'Scene.update': 'Modification de scène',
        'Chapter.update': 'Modification de chapitre',
        'Act.update': 'Modification d\'acte'
    }
};

// ============================================
// ETAT GLOBAL DU SYSTEME
// ============================================

// Ces variables sont definies dans 01.app.refactor.js mais on les redeclare ici pour reference
// historyStack, redoStack, isUndoRedoAction sont deja definis globalement

let _undoRedoInitialized = false;
let _debounceTimer = null;
let _lastSnapshot = null;
let _pendingActionType = null;

// ============================================
// UTILITAIRES
// ============================================

/**
 * Deep clone d'un objet (gere les objets complexes, Set, Map, etc.)
 * @param {*} obj - L'objet a cloner
 * @returns {*} - Le clone profond
 */
function deepClone(obj) {
    if (obj === null || typeof obj !== 'object') {
        return obj;
    }

    if (obj instanceof Date) {
        return new Date(obj.getTime());
    }

    if (obj instanceof Set) {
        return new Set([...obj].map(item => deepClone(item)));
    }

    if (obj instanceof Map) {
        const clonedMap = new Map();
        obj.forEach((value, key) => {
            clonedMap.set(deepClone(key), deepClone(value));
        });
        return clonedMap;
    }

    if (Array.isArray(obj)) {
        return obj.map(item => deepClone(item));
    }

    const cloned = {};
    for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            cloned[key] = deepClone(obj[key]);
        }
    }
    return cloned;
}

/**
 * Compare deux objets pour detecter des changements significatifs
 * @param {Object} obj1 - Premier objet
 * @param {Object} obj2 - Deuxieme objet
 * @returns {boolean} - True si les objets sont differents
 */
function hasSignificantChanges(obj1, obj2) {
    if (obj1 === obj2) return false;
    if (obj1 === null || obj2 === null) return true;
    if (typeof obj1 !== typeof obj2) return true;

    if (typeof obj1 !== 'object') {
        return obj1 !== obj2;
    }

    if (Array.isArray(obj1) !== Array.isArray(obj2)) return true;

    if (Array.isArray(obj1)) {
        if (obj1.length !== obj2.length) return true;
        for (let i = 0; i < obj1.length; i++) {
            if (hasSignificantChanges(obj1[i], obj2[i])) return true;
        }
        return false;
    }

    const keys1 = Object.keys(obj1).filter(k => !UndoRedoConfig.excludeKeys.includes(k));
    const keys2 = Object.keys(obj2).filter(k => !UndoRedoConfig.excludeKeys.includes(k));

    if (keys1.length !== keys2.length) return true;

    for (const key of keys1) {
        if (!keys2.includes(key)) return true;
        if (hasSignificantChanges(obj1[key], obj2[key])) return true;
    }

    return false;
}

// ============================================
// GESTION DES SNAPSHOTS
// ============================================

/**
 * Cree un snapshot complet de l'etat du projet
 * @param {string} actionLabel - Libellé de l'action
 * @returns {Object} - Le snapshot de l'etat
 */
function createSnapshot(actionLabel = 'Action') {
    if (typeof project === 'undefined') {
        console.warn('[UndoRedo] project non defini');
        return null;
    }

    const snapshot = {
        timestamp: Date.now(),
        label: actionLabel,
        project: deepClone(project),
        // Etat de navigation (optionnel, pour restauration complete)
        navigation: {
            currentActId: typeof currentActId !== 'undefined' ? currentActId : null,
            currentChapterId: typeof currentChapterId !== 'undefined' ? currentChapterId : null,
            currentSceneId: typeof currentSceneId !== 'undefined' ? currentSceneId : null
        }
    };

    // Ajouter l'etat du thriller board si present
    if (typeof thrillerBoardState !== 'undefined') {
        snapshot.thrillerBoardState = deepClone(thrillerBoardState);
    }

    return snapshot;
}

/**
 * Restaure un snapshot
 * @param {Object} snapshot - Le snapshot a restaurer
 * @param {boolean} restoreNavigation - Si on doit restaurer la navigation
 */
function restoreSnapshot(snapshot, restoreNavigation = false) {
    if (!snapshot || !snapshot.project) {
        console.warn('[UndoRedo] Snapshot invalide');
        return;
    }

    // Marquer qu'on est en train de faire un undo/redo
    isUndoRedoAction = true;

    try {
        // Restaurer le projet
        const restoredProject = deepClone(snapshot.project);

        // Copier toutes les proprietes
        Object.keys(project).forEach(key => {
            if (restoredProject.hasOwnProperty(key)) {
                project[key] = restoredProject[key];
            }
        });

        // S'assurer que toutes les nouvelles proprietes sont aussi copiees
        Object.keys(restoredProject).forEach(key => {
            project[key] = restoredProject[key];
        });

        // Restaurer l'etat du thriller board si present
        if (snapshot.thrillerBoardState && typeof thrillerBoardState !== 'undefined') {
            const restoredThrillerState = deepClone(snapshot.thrillerBoardState);
            Object.keys(restoredThrillerState).forEach(key => {
                thrillerBoardState[key] = restoredThrillerState[key];
            });
        }

        // Restaurer la navigation si demande
        if (restoreNavigation && snapshot.navigation) {
            if (typeof currentActId !== 'undefined') {
                currentActId = snapshot.navigation.currentActId;
            }
            if (typeof currentChapterId !== 'undefined') {
                currentChapterId = snapshot.navigation.currentChapterId;
            }
            if (typeof currentSceneId !== 'undefined') {
                currentSceneId = snapshot.navigation.currentSceneId;
            }
        }

        // Notifier les composants de la mise a jour
        _notifyStateRestored();

    } finally {
        isUndoRedoAction = false;
    }
}

/**
 * Notifie tous les composants que l'etat a ete restaure
 */
function _notifyStateRestored() {
    // Sauvegarder le projet
    if (typeof saveProjectToDB === 'function') {
        saveProjectToDB(project);
    } else if (typeof saveProject === 'function') {
        saveProject();
    }

    // 0. Rafraîchir tout le système de vue si possible (Recommandé)
    if (typeof refreshAllViews === 'function') {
        try { refreshAllViews(); } catch (e) {
            console.error('[UndoRedo] Erreur dans refreshAllViews:', e);
        }
    } else {
        // Rafraichir la vue structure
        if (typeof renderActsList === 'function') {
            try { renderActsList(); } catch (e) { }
        } else if (typeof renderStructureTree === 'function') {
            try { renderStructureTree(); } catch (e) { }
        }

        // Rafraichir la vue caracteres
        if (typeof renderCharactersList === 'function') {
            try { renderCharactersList(); } catch (e) { }
        }

        // Rafraichir la vue monde
        if (typeof renderWorldList === 'function') {
            try { renderWorldList(); } catch (e) { }
        }

        // Rafraichir la vue codex
        if (typeof renderCodexList === 'function') {
            try { renderCodexList(); } catch (e) { }
        }
    }

    // Rafraichir la scene courante
    if (typeof openScene === 'function' && currentSceneId && currentActId && currentChapterId) {
        try { openScene(currentActId, currentChapterId, currentSceneId); } catch (e) { }
    } else if (typeof renderCurrentView === 'function') {
        try { renderCurrentView(); } catch (e) { }
    }

    // Forcer la mise à jour de l'éditeur si présent
    const editor = document.querySelector('.editor-textarea');
    if (editor && currentSceneId && currentActId && currentChapterId) {
        const act = project.acts.find(a => a.id === currentActId);
        const chapter = act?.chapters.find(c => c.id === currentChapterId);
        const scene = chapter?.scenes.find(s => s.id === currentSceneId);
        if (scene) {
            editor.innerHTML = scene.content || '';
            console.log('[UndoRedo] Editeur mis a jour avec le contenu restaure');
        }
    }

    // Rafraichir le plot grid
    if (typeof PlotGridView !== 'undefined' && typeof PlotGridView.render === 'function') {
        try { PlotGridView.render(); } catch (e) { }
    }

    // Rafraichir le thriller board
    if (typeof ThrillerBoardView !== 'undefined' && typeof ThrillerBoardView.render === 'function') {
        try { ThrillerBoardView.render(); } catch (e) { }
    }

    // Rafraichir le corkboard
    if (typeof renderCorkboard === 'function') {
        try { renderCorkboard(); } catch (e) { }
    }

    // Rafraichir les todos
    if (typeof renderTodos === 'function') {
        try { renderTodos(); } catch (e) { }
    }

    // Rafraichir la timeline
    if (typeof renderTimeline === 'function') {
        try { renderTimeline(); } catch (e) { }
    }

    // Rafraichir les stats
    if (typeof updateStats === 'function') {
        try { updateStats(); } catch (e) { }
    }

    // Rafraichir les arcs
    if (typeof renderArcs === 'function') {
        try { renderArcs(); } catch (e) { }
    }

    // Mettre a jour les boutons undo/redo
    updateUndoRedoButtons();

    console.log('[UndoRedo] Etat restaure avec succes');
}

// ============================================
// API PRINCIPALE
// ============================================

/**
 * Sauvegarde l'etat courant dans l'historique (avec debounce)
 * @param {string} actionType - Type d'action (pour info)
 */
function saveToHistory(actionType = 'edit') {
    // Ne pas sauvegarder pendant un undo/redo
    if (isUndoRedoAction) {
        return;
    }

    _pendingActionType = actionType;

    // Verifier si c'est une action immediate
    const isImmediate = UndoRedoConfig.immediateActions.some(
        action => actionType.toLowerCase().includes(action)
    );

    if (isImmediate) {
        saveToHistoryImmediate(actionType);
        return;
    }

    // Debounce pour les edits continus
    if (_debounceTimer) {
        clearTimeout(_debounceTimer);
    }

    _debounceTimer = setTimeout(() => {
        _saveToHistoryInternal(actionType);
        _debounceTimer = null;
    }, UndoRedoConfig.debounceDelay);
}

/**
 * Sauvegarde immediatement l'etat courant dans l'historique (sans debounce)
 * @param {string} actionType - Type d'action (pour info)
 */
function saveToHistoryImmediate(actionType = 'immediate') {
    // Ne pas sauvegarder pendant un undo/redo
    if (isUndoRedoAction) {
        return;
    }

    // Annuler tout debounce en cours
    if (_debounceTimer) {
        clearTimeout(_debounceTimer);
        _debounceTimer = null;
    }

    _saveToHistoryInternal(actionType);
}

/**
 * Implementation interne de la sauvegarde
 * @param {string} actionType - Type d'action
 */
function _saveToHistoryInternal(actionType) {
    // Obtenir le libellé lisible
    const actionLabel = UndoRedoConfig.actionLabels[actionType] || actionType;

    const currentSnapshot = createSnapshot(actionLabel);
    if (!currentSnapshot) return;

    // S'il n'y a pas de snapshot précédent, on initialise et on s'arrête
    if (!_lastSnapshot) {
        _lastSnapshot = currentSnapshot;
        return;
    }

    // Verifier s'il y a des changements significatifs entre l'ancien état et le nouveau
    if (!hasSignificantChanges(_lastSnapshot.project, currentSnapshot.project)) {
        // Pas de changements significatifs, on ne fait rien
        return;
    }

    // ÉTAT CHANGÉ : On pousse l'ANCIEN état (_lastSnapshot) dans l'historique
    // Mais on lui donne le label de l'action qui vient d'être faite
    _lastSnapshot.label = actionLabel;
    historyStack.push(_lastSnapshot);

    // Limiter la taille de l'historique
    while (historyStack.length > UndoRedoConfig.maxHistorySize) {
        historyStack.shift();
    }

    // Vider le redo stack car on a fait une nouvelle action
    redoStack = [];

    // Mettre a jour le "dernier snapshot connu" avec l'état actuel
    _lastSnapshot = currentSnapshot;

    // Mettre a jour les boutons
    updateUndoRedoButtons();

    console.log(`[UndoRedo] Changement détecté: ${actionLabel}, historique: ${historyStack.length}`);
}

/**
 * Annule la derniere action (Undo)
 */
function undo() {
    if (historyStack.length === 0) {
        console.log('[UndoRedo] Rien a annuler');
        return;
    }

    // Annuler tout debounce en cours
    if (_debounceTimer) {
        clearTimeout(_debounceTimer);
        _debounceTimer = null;
    }

    // Sauvegarder l'etat actuel dans redo avant de restaurer
    const currentSnapshot = createSnapshot();
    if (currentSnapshot) {
        currentSnapshot.actionType = 'before-undo';
        redoStack.push(currentSnapshot);
    }

    // Recuperer le dernier etat
    const previousSnapshot = historyStack.pop();

    // Restaurer
    restoreSnapshot(previousSnapshot, false);

    // Mettre a jour le dernier snapshot
    _lastSnapshot = previousSnapshot;

    console.log(`[UndoRedo] Undo effectue, historique: ${historyStack.length}, redo: ${redoStack.length}`);
}

/**
 * Retablit la derniere action annulee (Redo)
 */
function redo() {
    if (redoStack.length === 0) {
        console.log('[UndoRedo] Rien a retablir');
        return;
    }

    // Annuler tout debounce en cours
    if (_debounceTimer) {
        clearTimeout(_debounceTimer);
        _debounceTimer = null;
    }

    // Sauvegarder l'etat actuel dans history avant de restaurer
    const currentSnapshot = createSnapshot();
    if (currentSnapshot) {
        currentSnapshot.actionType = 'before-redo';
        historyStack.push(currentSnapshot);
    }

    // Recuperer l'etat a retablir
    const nextSnapshot = redoStack.pop();

    // Restaurer
    restoreSnapshot(nextSnapshot, false);

    // Mettre a jour le dernier snapshot
    _lastSnapshot = nextSnapshot;

    console.log(`[UndoRedo] Redo effectue, historique: ${historyStack.length}, redo: ${redoStack.length}`);
}

/**
 * Met a jour l'etat des boutons undo/redo
 */
function updateUndoRedoButtons() {
    // Header buttons (desktop)
    const headerUndoBtn = document.getElementById('headerUndoBtn');
    const headerRedoBtn = document.getElementById('headerRedoBtn');

    // Mobile buttons
    const mobileUndoBtn = document.getElementById('mobileUndoBtn');
    const mobileRedoBtn = document.getElementById('mobileRedoBtn');

    // Update header buttons
    if (headerUndoBtn) {
        headerUndoBtn.disabled = historyStack.length === 0;
        headerUndoBtn.classList.toggle('disabled', historyStack.length === 0);

        // Attacher les events de survol une seule fois
        if (!headerUndoBtn.dataset.popupInitialized) {
            headerUndoBtn.addEventListener('mouseenter', () => showUndoRedoPopup('undo', headerUndoBtn));
            headerUndoBtn.addEventListener('mouseleave', (e) => {
                if (!e.relatedTarget?.closest('.undo-redo-popup')) {
                    hideUndoRedoPopup();
                }
            });
            headerUndoBtn.dataset.popupInitialized = 'true';
        }
    }

    if (headerRedoBtn) {
        headerRedoBtn.disabled = redoStack.length === 0;
        headerRedoBtn.classList.toggle('disabled', redoStack.length === 0);

        // Attacher les events de survol
        if (!headerRedoBtn.dataset.popupInitialized) {
            headerRedoBtn.addEventListener('mouseenter', () => showUndoRedoPopup('redo', headerRedoBtn));
            headerRedoBtn.addEventListener('mouseleave', (e) => {
                if (!e.relatedTarget?.closest('.undo-redo-popup')) {
                    hideUndoRedoPopup();
                }
            });
            headerRedoBtn.dataset.popupInitialized = 'true';
        }
    }

    // Update mobile buttons
    if (mobileUndoBtn) {
        mobileUndoBtn.disabled = historyStack.length === 0;
        mobileUndoBtn.classList.toggle('disabled', historyStack.length === 0);
    }

    if (mobileRedoBtn) {
        mobileRedoBtn.disabled = redoStack.length === 0;
        mobileRedoBtn.classList.toggle('disabled', redoStack.length === 0);
    }
}

/**
 * Affiche la popup d'historique
 */
function showUndoRedoPopup(type, buttonElement) {
    let popup = document.getElementById('undoRedoPopup');
    if (!popup) {
        popup = document.createElement('div');
        popup.id = 'undoRedoPopup';
        popup.className = 'undo-redo-popup';
        popup.addEventListener('mouseleave', () => hideUndoRedoPopup());
        document.body.appendChild(popup);
    }

    const stack = type === 'undo' ? historyStack : redoStack;
    const title = type === 'undo' ? 'Historique d\'annulation' : 'Historique de rétablissement';

    if (stack.length === 0) {
        popup.innerHTML = `
            <div class="undo-redo-header"><span>${title}</span></div>
            <div class="undo-redo-empty">Aucune action disponible</div>
        `;
    } else {
        // Inverser pour avoir les plus récents en haut
        const displayStack = [...stack].reverse().slice(0, 15);

        popup.innerHTML = `
            <div class="undo-redo-header">
                <span>${title}</span>
                <span>${stack.length} action${stack.length > 1 ? 's' : ''}</span>
            </div>
            <ul class="undo-redo-list">
                ${displayStack.map((snap, idx) => `
                    <li class="undo-redo-item" onclick="jumpToHistoryState('${type}', ${stack.length - 1 - idx})">
                        <span class="undo-redo-item-label">${snap.label || 'Action sans nom'}</span>
                        <span class="undo-redo-item-time">${formatTimestamp(snap.timestamp)}</span>
                    </li>
                `).join('')}
            </ul>
        `;
    }

    // Positionner la popup
    const rect = buttonElement.getBoundingClientRect();
    popup.style.top = (rect.bottom + window.scrollY) + 'px';
    popup.style.left = (rect.left + rect.width / 2 + window.scrollX) + 'px';
    popup.classList.add('active');
}

/**
 * Cache la popup
 */
function hideUndoRedoPopup() {
    const popup = document.getElementById('undoRedoPopup');
    if (popup) {
        popup.classList.remove('active');
    }
}

/**
 * Formate un timestamp
 */
function formatTimestamp(timestamp) {
    const date = new Date(timestamp);
    return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
}

/**
 * Annule ou rétablit plusieurs actions d'un coup
 */
function jumpToHistoryState(type, targetIndex) {
    if (type === 'undo') {
        const count = historyStack.length - targetIndex;
        for (let i = 0; i < count; i++) {
            undo();
        }
    } else {
        const count = redoStack.length - targetIndex;
        for (let i = 0; i < count; i++) {
            redo();
        }
    }
    hideUndoRedoPopup();
}

/**
 * Reinitialise completement l'historique
 */
function clearHistory() {
    historyStack = [];
    redoStack = [];
    _lastSnapshot = null;
    _pendingActionType = null;

    if (_debounceTimer) {
        clearTimeout(_debounceTimer);
        _debounceTimer = null;
    }

    updateUndoRedoButtons();
    console.log('[UndoRedo] Historique reinitialise');
}

/**
 * Initialise le systeme d'undo/redo
 */
function initUndoRedo() {
    if (_undoRedoInitialized) return;

    // S'assurer que les stacks existent
    if (typeof historyStack === 'undefined') {
        window.historyStack = [];
    }
    if (typeof redoStack === 'undefined') {
        window.redoStack = [];
    }
    if (typeof isUndoRedoAction === 'undefined') {
        window.isUndoRedoAction = false;
    }

    // Exposer les fonctions globalement
    window.saveToHistory = saveToHistory;
    window.saveToHistoryImmediate = saveToHistoryImmediate;
    window.undo = undo;
    window.redo = redo;
    window.updateUndoRedoButtons = updateUndoRedoButtons;
    window.clearHistory = clearHistory;

    // Initialiser le snapshot de référence dès que le projet est là
    setTimeout(() => {
        if (typeof project !== 'undefined' && project.id) {
            _lastSnapshot = createSnapshot();
            updateUndoRedoButtons();
            console.log('[UndoRedo] État initial capturé');
        }
    }, 200);

    _undoRedoInitialized = true;
    console.log('[UndoRedo] Systeme initialise');
}

// ============================================
// DECORATEURS POUR REPOSITORIES
// ============================================

/**
 * Wrapper pour les methodes de repository qui sauvegardent automatiquement
 * @param {Function} fn - La fonction a wrapper
 * @param {string} actionType - Le type d'action
 * @returns {Function} - La fonction wrappee
 */
function withHistory(fn, actionType) {
    return function (...args) {
        const result = fn.apply(this, args);
        saveToHistory(actionType);
        return result;
    };
}

/**
 * Wrapper pour les methodes de repository avec sauvegarde immediate
 * @param {Function} fn - La fonction a wrapper
 * @param {string} actionType - Le type d'action
 * @returns {Function} - La fonction wrappee
 */
function withHistoryImmediate(fn, actionType) {
    return function (...args) {
        const result = fn.apply(this, args);
        saveToHistoryImmediate(actionType);
        return result;
    };
}

// ============================================
// INTEGRATION AUTOMATIQUE AVEC LES REPOSITORIES
// ============================================

/**
 * Integre automatiquement l'undo/redo dans un repository
 * @param {Object} repository - Le repository a integrer
 * @param {string} name - Le nom du repository (pour les logs)
 */
function integrateWithRepository(repository, name) {
    const methodsToWrap = {
        // Methodes avec sauvegarde immediate (avant l'action)
        immediate: ['add', 'remove', 'delete', 'create', 'reorder', 'move', 'moveToCell', 'update'],
        // Methodes avec debounce (apres l'action)
        debounced: ['set', 'save']
    };

    // Wrapper les methodes immediates
    methodsToWrap.immediate.forEach(method => {
        if (typeof repository[method] === 'function') {
            const original = repository[method].bind(repository);
            repository[method] = function (...args) {
                const result = original(...args);
                saveToHistoryImmediate(`${name}.${method}`);
                return result;
            };
        }
    });

    // Wrapper les methodes debounced
    methodsToWrap.debounced.forEach(method => {
        if (typeof repository[method] === 'function') {
            const original = repository[method].bind(repository);
            repository[method] = function (...args) {
                const result = original(...args);
                saveToHistory(`${name}.${method}`);
                return result;
            };
        }
    });
}

/**
 * Integre l'undo/redo dans tous les repositories connus
 */
function integrateWithAllRepositories() {
    const integrate = (repo, name) => {
        try {
            if (typeof repo !== 'undefined') {
                integrateWithRepository(repo, name);
            }
        } catch (e) {
            console.error(`[UndoRedo] Erreur d'integration pour ${name}:`, e);
        }
    };

    // Structure
    integrate(ActRepository, 'Act');
    integrate(ChapterRepository, 'Chapter');
    integrate(SceneRepository, 'Scene');

    // Characters
    integrate(CharacterRepository, 'Character');

    // World
    integrate(WorldRepository, 'World');

    // Codex
    integrate(CodexRepository, 'Codex');

    // PlotGrid
    integrate(PlotGridRepository, 'PlotGrid');

    // Thriller Board
    //integrate(ThrillerElementRepository, 'ThrillerElement');
    //integrate(ThrillerCardRepository, 'ThrillerCard');
    //integrate(ThrillerRowRepository, 'ThrillerRow');
    //integrate(ThrillerColumnRepository, 'ThrillerColumn');
    //integrate(ThrillerConnectionRepository, 'ThrillerConnection');
    //integrate(ThrillerTypeRepository, 'ThrillerType');

    // Arc Board
    integrate(ArcRepository, 'Arc');
    integrate(BoardItemRepository, 'BoardItem');
    integrate(CardRepository, 'Card');
    integrate(ConnectionRepository, 'Connection');

    console.log('[UndoRedo] Integration avec tous les repositories effectuee');
}



// ============================================
// HOOKS AUTOMATIQUES POUR LES CHAMPS DE TEXTE
// ============================================

/**
 * Timer de debounce pour les modifications de texte
 */
let _textEditDebounceTimer = null;
const _textEditDebounceDelay = 500; // 0.5 secondes - réduit pour une meilleure réactivité

/**
 * Installe les hooks automatiques sur les editeurs de texte
 */
function installTextEditHooks() {
    // Hook sur les evenements de focus pour sauvegarder l'etat avant edition
    document.addEventListener('focusin', (e) => {
        const target = e.target;

        // Verifier si c'est un element editable important
        if (
            target.classList.contains('editor-textarea') ||
            target.classList.contains('synopsis-input') ||
            target.id === 'sceneContent' ||
            target.id === 'sceneTitle' ||
            target.getAttribute('contenteditable') === 'true'
        ) {
            // Sauvegarder l'etat avant de commencer l'edition
            if (!isUndoRedoAction) {
                saveToHistoryImmediate('text-edit-start');
            }
        }
    }, true);

    // Hook sur les evenements de modification de texte avec debounce
    document.addEventListener('input', (e) => {
        const target = e.target;

        // Verifier si c'est un element editable important
        if (
            target.classList.contains('editor-textarea') ||
            target.classList.contains('synopsis-input') ||
            target.classList.contains('scene-separator-synopsis') ||
            target.id === 'sceneContent' ||
            target.id === 'sceneTitle' ||
            target.getAttribute('contenteditable') === 'true' ||
            target.tagName === 'TEXTAREA' ||
            (target.tagName === 'INPUT' && target.type === 'text')
        ) {
            // Debounce pour eviter trop de sauvegardes
            if (_textEditDebounceTimer) {
                clearTimeout(_textEditDebounceTimer);
            }

            _textEditDebounceTimer = setTimeout(() => {
                if (!isUndoRedoAction) {
                    saveToHistory('text-edit');
                }
                _textEditDebounceTimer = null;
            }, _textEditDebounceDelay);
        }
    }, true);

    // Hook sur les evenements de blur pour sauvegarder immediatement
    document.addEventListener('focusout', (e) => {
        const target = e.target;

        // Verifier si c'est un element editable important
        if (
            target.classList.contains('editor-textarea') ||
            target.classList.contains('synopsis-input') ||
            target.classList.contains('scene-separator-synopsis') ||
            target.id === 'sceneContent' ||
            target.getAttribute('contenteditable') === 'true'
        ) {
            // Annuler le debounce en cours
            if (_textEditDebounceTimer) {
                clearTimeout(_textEditDebounceTimer);
                _textEditDebounceTimer = null;
            }

            // Sauvegarder immediatement
            if (!isUndoRedoAction) {
                saveToHistory('text-edit-end');
            }
        }
    }, true);

    console.log('[UndoRedo] Hooks de texte installes');
}

// ============================================
// OBSERVATEUR DE MUTATIONS DU PROJET
// ============================================

/**
 * Installe un proxy pour surveiller les modifications du projet
 * Note: Cette approche est optionnelle et peut etre couteuse en performance
 */
function installProjectProxy() {
    // Pas utilise par defaut car les hooks manuels sont suffisants
    // et les proxies peuvent causer des problemes de compatibilite
}

// ============================================
// INITIALISATION AU CHARGEMENT
// ============================================

// Initialiser quand le DOM est pret
if (typeof document !== 'undefined') {
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
            initUndoRedo();
            // Integrer apres un court delai pour que les repos soient charges
            setTimeout(() => {
                integrateWithAllRepositories();
                installTextEditHooks();
            }, 100);
        });
    } else {
        initUndoRedo();
        setTimeout(() => {
            integrateWithAllRepositories();
            installTextEditHooks();
        }, 100);
    }
}

// Exposer les fonctions utilitaires
window.UndoRedo = {
    init: initUndoRedo,
    save: saveToHistory,
    saveImmediate: saveToHistoryImmediate,
    undo: undo,
    redo: redo,
    clear: clearHistory,
    updateButtons: updateUndoRedoButtons,
    integrate: integrateWithAllRepositories,
    integrateRepository: integrateWithRepository,
    // Utilitaires
    deepClone: deepClone,
    hasChanges: hasSignificantChanges,
    createSnapshot: createSnapshot,
    // Config
    config: UndoRedoConfig
};

// ========== js-refactor/structure/structure.model.js ==========
// [MVVM : Model]
// Charge le projet depuis le localStorage et gère la migration de structure
function loadProject() {
    const saved = localStorage.getItem('plume_locale_project');
    if (saved) {
        const loadedProject = JSON.parse(saved);

        // Migration: Convert old structure (chapters array) to new structure (acts array)
        if (loadedProject.chapters && !loadedProject.acts) {
            console.log('Migrating old project structure to acts-based structure...');
            project = {
                title: loadedProject.title || "Mon Roman",
                acts: [
                    {
                        id: Date.now(),
                        title: "Acte I",
                        chapters: loadedProject.chapters || []
                    }
                ],
                characters: loadedProject.characters || [],
                world: loadedProject.world || []
            };
            // Save migrated structure
            saveProject();
            console.log('Migration complete!');
        } else {
            // Ensure all data structures exist
            project = {
                ...loadedProject,
                characters: loadedProject.characters || [],
                world: loadedProject.world || [],
                timeline: loadedProject.timeline || [],
                notes: loadedProject.notes || [],
                codex: loadedProject.codex || [],
                stats: loadedProject.stats || {
                    dailyGoal: 500,
                    totalGoal: 80000,
                    writingSessions: []
                },
                versions: loadedProject.versions || [],
                relationships: loadedProject.relationships || [],
                metroTimeline: loadedProject.metroTimeline || [],
                characterColors: loadedProject.characterColors || {}
            };

            // Ensure all scenes have linked arrays
            project.acts.forEach(act => {
                act.chapters.forEach(chapter => {
                    chapter.scenes.forEach(scene => {
                        if (!scene.linkedCharacters) scene.linkedCharacters = [];
                        if (!scene.linkedElements) scene.linkedElements = [];
                    });
                });
            });

            // Ensure all characters have linked arrays
            project.characters.forEach(char => {
                if (!char.linkedScenes) char.linkedScenes = [];
                if (!char.linkedElements) char.linkedElements = [];
            });

            // Ensure all world elements have linked arrays
            project.world.forEach(elem => {
                if (!elem.linkedScenes) elem.linkedScenes = [];
                if (!elem.linkedElements) elem.linkedElements = [];
            });
        }
    }
}

// [MVVM : Model]
// Charge l'état d'expansion de l'arborescence depuis IndexedDB
async function loadTreeState() {
    // Charger l'état d'expansion depuis IndexedDB
    try {
        const savedActs = await loadSetting('expanded_acts');
        const savedChapters = await loadSetting('expanded_chapters');

        if (savedActs) {
            expandedActs = new Set(savedActs);
        }
        if (savedChapters) {
            expandedChapters = new Set(savedChapters);
        }
    } catch (e) {
        console.error('Erreur chargement état arborescence:', e);
    }
}

// [MVVM : Model]
// Factory Functions - Création des entités du modèle
// Ces fonctions centralisent la création des structures de données

// Générateurs d'ID pour éviter les collisions
let actIdCounter = Date.now();
let chapterIdCounter = Date.now() + 1000000;
let sceneIdCounter = Date.now() + 2000000;

function generateActId() {
    return actIdCounter++;
}

function generateChapterId() {
    return chapterIdCounter++;
}

function generateSceneId() {
    return sceneIdCounter++;
}

// Crée une nouvelle instance d'Acte
function createAct(title, options = {}) {
    if (!title || typeof title !== 'string') {
        throw new Error('Act title is required and must be a string');
    }

    const now = new Date().toISOString();

    return {
        id: options.id || generateActId(),
        title: title,
        chapters: options.chapters || [],
        createdAt: options.createdAt || now,
        updatedAt: options.updatedAt || now,
        metadata: {
            color: options.color || null,
            description: options.description || ''
        }
    };
}

// Crée une nouvelle instance de Chapitre
function createChapter(title, options = {}) {
    if (!title || typeof title !== 'string') {
        throw new Error('Chapter title is required and must be a string');
    }

    const now = new Date().toISOString();

    return {
        id: options.id || generateChapterId(),
        title: title,
        scenes: options.scenes || [],
        createdAt: options.createdAt || now,
        updatedAt: options.updatedAt || now,
        metadata: {
            description: options.description || ''
        }
    };
}

// Crée une nouvelle instance de Scène
function createScene(title, options = {}) {
    if (!title || typeof title !== 'string') {
        throw new Error('Scene title is required and must be a string');
    }

    const now = new Date().toISOString();

    return {
        id: options.id || generateSceneId(),
        title: title,
        content: options.content || '',
        linkedCharacters: options.linkedCharacters || [],
        linkedElements: options.linkedElements || [],
        wordCount: options.wordCount || 0,
        status: options.status || 'draft',
        createdAt: options.createdAt || now,
        updatedAt: options.updatedAt || now
    };
}

// ========== js-refactor/structure/structure.repository.js ==========
// [MVVM : Repository]
// Gestionnaire d'accès aux données pour la structure du projet

/**
 * ActRepository
 * Encapsule toutes les opérations sur les Actes
 */
const ActRepository = {
    getAll: () => {
        return project.acts || [];
    },

    getById: (id) => {
        return (project.acts || []).find(a => a.id === id) || null;
    },

    add: (act) => {
        if (!project.acts) project.acts = [];
        project.acts.push(act);
        return act;
    },

    update: (id, updates) => {
        const actIndex = project.acts.findIndex(a => a.id === id);
        if (actIndex === -1) return null;

        const act = project.acts[actIndex];
        const updatedAct = { ...act, ...updates, updatedAt: new Date().toISOString() };
        project.acts[actIndex] = updatedAct;
        return updatedAct;
    },

    remove: (id) => {
        const actIndex = project.acts.findIndex(a => a.id === id);
        if (actIndex === -1) return null;

        const removed = project.acts[actIndex];
        project.acts = project.acts.filter(a => a.id !== id);
        return removed;
    },

    reorder: (ids) => {
        if (!project.acts) return false;
        const newActs = ids.map(id => project.acts.find(a => a.id === id)).filter(Boolean);
        project.acts = newActs;
        return true;
    },

    // UI State Persistence
    saveTreeState: async () => {
        if (typeof saveSetting !== 'function') return;
        try {
            await saveSetting('expanded_acts', typeof expandedActs !== 'undefined' ? [...expandedActs] : []);
            await saveSetting('expanded_chapters', typeof expandedChapters !== 'undefined' ? [...expandedChapters] : []);
        } catch (error) {
            console.error('❌ Erreur sauvegarde TreeState:', error);
        }
    },

    loadTreeState: async () => {
        if (typeof loadSetting !== 'function') return;
        try {
            const savedActs = await loadSetting('expanded_acts');
            const savedChapters = await loadSetting('expanded_chapters');
            if (savedActs && typeof expandedActs !== 'undefined') expandedActs = new Set(savedActs);
            if (savedChapters && typeof expandedChapters !== 'undefined') expandedChapters = new Set(savedChapters);
        } catch (e) {
            console.error('Erreur chargement état arborescence:', e);
        }
    }
};

/**
 * ChapterRepository
 * Encapsule toutes les opérations sur les Chapitres
 */
const ChapterRepository = {
    getAll: (actId) => {
        const act = ActRepository.getById(actId);
        return act ? (act.chapters || []) : [];
    },

    getById: (actId, chapterId) => {
        const act = ActRepository.getById(actId);
        if (!act || !act.chapters) return null;
        return act.chapters.find(c => c.id === chapterId) || null;
    },

    add: (actId, chapter) => {
        const act = ActRepository.getById(actId);
        if (!act) return null;
        if (!act.chapters) act.chapters = [];
        act.chapters.push(chapter);
        act.updatedAt = new Date().toISOString();
        return chapter;
    },

    update: (actId, chapterId, updates) => {
        const act = ActRepository.getById(actId);
        if (!act || !act.chapters) return null;

        const chapterIndex = act.chapters.findIndex(c => c.id === chapterId);
        if (chapterIndex === -1) return null;

        const chapter = act.chapters[chapterIndex];
        const updatedChapter = { ...chapter, ...updates, updatedAt: new Date().toISOString() };
        act.chapters[chapterIndex] = updatedChapter;
        act.updatedAt = new Date().toISOString();
        return updatedChapter;
    },

    remove: (actId, chapterId) => {
        const act = ActRepository.getById(actId);
        if (!act || !act.chapters) return null;

        const chapterIndex = act.chapters.findIndex(c => c.id === chapterId);
        if (chapterIndex === -1) return null;

        const removed = act.chapters[chapterIndex];
        act.chapters = act.chapters.filter(c => c.id !== chapterId);
        act.updatedAt = new Date().toISOString();
        return removed;
    },

    reorder: (actId, ids) => {
        const act = ActRepository.getById(actId);
        if (!act || !act.chapters) return false;
        const newChapters = ids.map(id => act.chapters.find(c => c.id === id)).filter(Boolean);
        act.chapters = newChapters;
        act.updatedAt = new Date().toISOString();
        return true;
    }
};

/**
 * SceneRepository
 * Encapsule toutes les opérations sur les Scènes
 */
const SceneRepository = {
    getAll: (actId, chapterId) => {
        const chapter = ChapterRepository.getById(actId, chapterId);
        return chapter ? (chapter.scenes || []) : [];
    },

    getById: (actId, chapterId, sceneId) => {
        const chapter = ChapterRepository.getById(actId, chapterId);
        if (!chapter || !chapter.scenes) return null;
        return chapter.scenes.find(s => s.id === sceneId) || null;
    },

    add: (actId, chapterId, scene) => {
        const chapter = ChapterRepository.getById(actId, chapterId);
        if (!chapter) return null;
        if (!chapter.scenes) chapter.scenes = [];
        chapter.scenes.push(scene);
        chapter.updatedAt = new Date().toISOString();

        const act = ActRepository.getById(actId);
        if (act) act.updatedAt = new Date().toISOString();

        return scene;
    },

    update: (actId, chapterId, sceneId, updates) => {
        const chapter = ChapterRepository.getById(actId, chapterId);
        if (!chapter || !chapter.scenes) return null;

        const sceneIndex = chapter.scenes.findIndex(s => s.id === sceneId);
        if (sceneIndex === -1) return null;

        const scene = chapter.scenes[sceneIndex];
        const updatedScene = { ...scene, ...updates, updatedAt: new Date().toISOString() };
        chapter.scenes[sceneIndex] = updatedScene;
        chapter.updatedAt = new Date().toISOString();

        const act = ActRepository.getById(actId);
        if (act) act.updatedAt = new Date().toISOString();

        return updatedScene;
    },

    remove: (actId, chapterId, sceneId) => {
        const chapter = ChapterRepository.getById(actId, chapterId);
        if (!chapter || !chapter.scenes) return null;

        const sceneIndex = chapter.scenes.findIndex(s => s.id === sceneId);
        if (sceneIndex === -1) return null;

        const removed = chapter.scenes[sceneIndex];
        chapter.scenes = chapter.scenes.filter(s => s.id !== sceneId);
        chapter.updatedAt = new Date().toISOString();

        const act = ActRepository.getById(actId);
        if (act) act.updatedAt = new Date().toISOString();

        return removed;
    },

    reorder: (actId, chapterId, ids) => {
        const chapter = ChapterRepository.getById(actId, chapterId);
        if (!chapter || !chapter.scenes) return false;
        const newScenes = ids.map(id => chapter.scenes.find(s => s.id === id)).filter(Boolean);
        chapter.scenes = newScenes;
        chapter.updatedAt = new Date().toISOString();

        const act = ActRepository.getById(actId);
        if (act) act.updatedAt = new Date().toISOString();

        return true;
    }
};

// ========== js-refactor/structure/structure.viewmodel.js ==========
/**
 * [MVVM : Structure ViewModel]
 * Logique métier pour la navigation et l'organisation du projet (Actes/Chapitres/Scènes).
 */

/**
 * Prépare toutes les données de structure pour l'affichage de l'arborescence.
 * Centralise le Read pour éviter que la View ne boucle directement sur project.acts.
 */
function getStructureViewModel() {
    return {
        success: true,
        acts: ActRepository.getAll().map(act => ({
            ...act,
            chaptersCount: (act.chapters || []).length,
            chapters: (act.chapters || []).map(chapter => ({
                ...chapter,
                scenesCount: (chapter.scenes || []).length
            }))
        })),
        characters: typeof CharacterRepository !== 'undefined' ? CharacterRepository.getAll() : (project.characters || []),
        world: project.world || [],
        metroTimeline: project.metroTimeline || []
    };
}

/**
 * Coordination pour ajouter un acte.
 */
function addActViewModel(title) {
    const validation = ValidationHelper.validateTitle(title);
    if (!validation.isValid) return { success: false, message: validation.message, error: validation.error };

    const trimmedTitle = validation.value;
    const duplicateCheck = ValidationHelper.checkDuplicate(trimmedTitle, ActRepository.getAll());
    if (duplicateCheck.isDuplicate) return { success: false, message: duplicateCheck.message, error: duplicateCheck.error };

    try {
        const act = createAct(trimmedTitle);
        return {
            success: true,
            data: act,
            message: `Acte "${trimmedTitle}" créé`,
            sideEffects: {
                repository: { action: 'ADD', collection: 'acts', data: act },
                shouldExpand: act.id,
                shouldSave: true
            }
        };
    } catch (error) {
        return { success: false, error: 'CREATION_FAILED', message: error.message };
    }
}

/**
 * Coordination pour supprimer un acte.
 */
function deleteActViewModel(actId, currentActId) {
    const act = ActRepository.getById(actId);
    if (!act) return { success: false, message: 'Acte introuvable' };

    const isCurrent = actId === currentActId;

    return {
        success: true,
        message: `Acte "${act.title}" supprimé`,
        sideEffects: {
            repository: { action: 'REMOVE', collection: 'acts', id: actId },
            shouldSave: true,
            shouldResetState: isCurrent
        }
    };
}

/**
 * Coordination pour mettre à jour un acte.
 */
function updateActViewModel(actId, updates) {
    if (updates.title) {
        const validation = ValidationHelper.validateTitle(updates.title);
        if (!validation.isValid) return { success: false, message: validation.message };
        updates.title = validation.value;
    }

    return {
        success: true,
        sideEffects: {
            repository: { action: 'UPDATE', collection: 'acts', id: actId, updates },
            shouldSave: true
        }
    };
}

/**
 * Coordination pour ajouter un chapitre.
 */
function addChapterViewModel(title, targetActId) {
    const validation = ValidationHelper.validateTitle(title);
    if (!validation.isValid) return { success: false, message: validation.message };

    const trimmedTitle = validation.value;
    let actId = targetActId;
    let autoCreatedAct = null;

    // Fallback si pas d'acte cible
    if (!actId) {
        const acts = ActRepository.getAll();
        if (acts.length === 0) {
            autoCreatedAct = createAct('Roman');
            actId = autoCreatedAct.id;
        } else {
            actId = acts[0].id;
        }
    }

    const duplicateCheck = ValidationHelper.checkDuplicate(trimmedTitle, ChapterRepository.getAll(actId));
    if (duplicateCheck.isDuplicate) return { success: false, message: 'Ce titre existe déjà dans cet acte' };

    try {
        const chapter = createChapter(trimmedTitle);
        const repoActions = [];
        if (autoCreatedAct) repoActions.push({ action: 'ADD', collection: 'acts', data: autoCreatedAct });
        repoActions.push({ action: 'ADD', collection: 'chapters', actId: actId, data: chapter });

        return {
            success: true,
            data: { actId, chapter },
            message: `Chapitre "${trimmedTitle}" créé`,
            sideEffects: {
                repository: repoActions,
                shouldExpandAct: actId,
                shouldExpandChapter: chapter.id,
                shouldSave: true
            }
        };
    } catch (error) {
        return { success: false, error: 'CREATION_FAILED', message: error.message };
    }
}

/**
 * Coordination pour supprimer un chapitre.
 */
function deleteChapterViewModel(actId, chapterId, currentChapterId) {
    const chapter = ChapterRepository.getById(actId, chapterId);
    if (!chapter) return { success: false, message: 'Chapitre introuvable' };

    return {
        success: true,
        message: `Chapitre "${chapter.title}" supprimé`,
        sideEffects: {
            repository: { action: 'REMOVE', collection: 'chapters', actId, id: chapterId },
            shouldSave: true,
            shouldResetState: chapterId === currentChapterId
        }
    };
}

/**
 * Coordination pour mettre à jour un chapitre.
 */
function updateChapterViewModel(actId, chapterId, updates) {
    if (updates.title) {
        const validation = ValidationHelper.validateTitle(updates.title);
        if (!validation.isValid) return { success: false, message: validation.message };
        updates.title = validation.value;
    }

    return {
        success: true,
        sideEffects: {
            repository: { action: 'UPDATE', collection: 'chapters', actId, id: chapterId, updates },
            shouldSave: true
        }
    };
}

/**
 * Coordination pour ajouter une scène.
 */
function addSceneViewModel(title, actId, chapterId) {
    const validation = ValidationHelper.validateTitle(title);
    if (!validation.isValid) return { success: false, message: validation.message };

    if (!actId || !chapterId) return { success: false, message: 'Sélectionnez d\'abord un chapitre' };

    const duplicateCheck = ValidationHelper.checkDuplicate(validation.value, SceneRepository.getAll(actId, chapterId));
    if (duplicateCheck.isDuplicate) return { success: false, message: 'Ce titre existe déjà dans ce chapitre' };

    try {
        const scene = createScene(validation.value);
        return {
            success: true,
            data: scene,
            message: `Scène "${scene.title}" créée`,
            sideEffects: {
                repository: { action: 'ADD', collection: 'scenes', actId, chapterId, data: scene },
                shouldExpandAct: actId,
                shouldExpandChapter: chapterId,
                shouldSave: true,
                shouldOpenScene: { actId, chapterId, sceneId: scene.id }
            }
        };
    } catch (error) {
        return { success: false, error: 'CREATION_FAILED', message: error.message };
    }
}

/**
 * Coordination pour supprimer une scène.
 */
function deleteSceneViewModel(actId, chapterId, sceneId, currentSceneId) {
    const scene = SceneRepository.getById(actId, chapterId, sceneId);
    if (!scene) return { success: false, message: 'Scène introuvable' };

    return {
        success: true,
        message: `Scène "${scene.title}" supprimée`,
        sideEffects: {
            repository: { action: 'REMOVE', collection: 'scenes', actId, chapterId, id: sceneId },
            shouldSave: true,
            shouldResetState: sceneId === currentSceneId
        }
    };
}

/**
 * Coordination pour mettre à jour une scène.
 */
function updateSceneViewModel(actId, chapterId, sceneId, updates) {
    if (updates.title) {
        const validation = ValidationHelper.validateTitle(updates.title);
        if (!validation.isValid) return { success: false, message: validation.message };
        updates.title = validation.value;
    }

    return {
        success: true,
        sideEffects: {
            repository: { action: 'UPDATE', collection: 'scenes', actId, chapterId, id: sceneId, updates },
            shouldSave: true
        }
    };
}

/**
 * Coordination pour mettre à jour le statut d'une scène.
 */
function setSceneStatusViewModel(actId, chapterId, sceneId, status) {
    const validStatuses = ['draft', 'progress', 'complete', 'review'];
    if (!validStatuses.includes(status)) return { success: false, message: 'Statut invalide' };

    return updateSceneViewModel(actId, chapterId, sceneId, { status });
}

/**
 * Coordination pour réorganiser les éléments (drag & drop).
 */
function reorderStructureViewModel(type, ids, actId, chapterId) {
    let result = false;
    let collection = '';

    if (type === 'acts') {
        result = ActRepository.reorder(ids);
        collection = 'acts';
    } else if (type === 'chapters') {
        result = ChapterRepository.reorder(actId, ids);
        collection = 'chapters';
    } else if (type === 'scenes') {
        result = SceneRepository.reorder(actId, chapterId, ids);
        collection = 'scenes';
    }

    return {
        success: result,
        sideEffects: {
            shouldSave: true,
            shouldRefresh: true
        }
    };
}


// ========== js-refactor/00.app.view.js ==========
/**
 * [MVVM : App View Orchestrator]
 * Ce fichier coordonne les différentes vues de l'application et gère les side-effects globaux.
 */

// --- ÉTAT UI GLOBAL ---
let activeStatusFilters = ['draft', 'progress', 'complete', 'review'];
let currentStatusMenu = null;
let chapterScrollTrackingHandler = null;

// --- DISPATCHER DE REPOSITORY ---

/**
 * Exécute les actions du repository retournées par un ViewModel.
 * Centralise toutes les mutations de données de l'application.
 */
function executeRepositorySideEffect(repoSideEffect) {
    if (!repoSideEffect) return;

    // Si on a un tableau d'actions
    if (Array.isArray(repoSideEffect)) {
        repoSideEffect.forEach(executeRepositorySideEffect);
        return;
    }

    const { action, collection, data, id, updates, actId, chapterId } = repoSideEffect;

    if (collection === 'acts') {
        if (action === 'ADD') ActRepository.add(data);
        else if (action === 'REMOVE') ActRepository.remove(id);
        else if (action === 'UPDATE') ActRepository.update(id, updates);
    }
    else if (collection === 'chapters') {
        if (action === 'ADD') ChapterRepository.add(actId, data);
        else if (action === 'REMOVE') ChapterRepository.remove(actId, id);
        else if (action === 'UPDATE') ChapterRepository.update(actId, id, updates);
    }
    else if (collection === 'scenes') {
        if (action === 'ADD') SceneRepository.add(actId, chapterId, data);
        else if (action === 'REMOVE') SceneRepository.remove(actId, chapterId, id);
        else if (action === 'UPDATE') SceneRepository.update(actId, chapterId, id, updates);
    }
}

// --- NAVIGATION & ROUTING ---

/**
 * Ferme tous les panneaux du toolsSidebar (versions, annotations, todos, arcs, plot).
 */
function closeAllToolsSidebarPanels() {
    // Fermer le panneau des versions
    const sidebarVersions = document.getElementById('sidebarVersions');
    const toolVersionsBtn = document.getElementById('toolVersionsBtn');
    const headerVersionsToggle = document.getElementById('headerVersionsToggle');
    if (sidebarVersions && !sidebarVersions.classList.contains('hidden')) {
        sidebarVersions.classList.add('hidden');
        if (toolVersionsBtn) toolVersionsBtn.classList.remove('active');
        if (headerVersionsToggle) headerVersionsToggle.classList.remove('active');
        if (typeof sceneVersionsSidebarVisible !== 'undefined') {
            sceneVersionsSidebarVisible = false;
        }
    }

    // Fermer le panneau des annotations
    if (typeof closeAnnotationsPanel === 'function') {
        closeAnnotationsPanel();
    }

    // Fermer le panneau des TODOs
    if (typeof closeTodosPanel === 'function') {
        closeTodosPanel();
    }

    // Fermer le panneau des arcs narratifs
    const arcScenePanel = document.getElementById('arcScenePanel');
    const toolArcsBtn = document.getElementById('toolArcsBtn');
    const sidebarArcsBtn = document.getElementById('sidebarArcsBtn');
    if (arcScenePanel && !arcScenePanel.classList.contains('hidden')) {
        arcScenePanel.classList.add('hidden');
        if (toolArcsBtn) toolArcsBtn.classList.remove('active');
        if (sidebarArcsBtn) sidebarArcsBtn.classList.remove('active');
    }

    // Fermer le panneau de l'intrigue (PlotGrid)
    const sidebarPlot = document.getElementById('sidebarPlot');
    const toolPlotBtn = document.getElementById('toolPlotBtn');
    const sidebarPlotBtn = document.getElementById('sidebarPlotBtn');
    if (sidebarPlot && !sidebarPlot.classList.contains('hidden')) {
        sidebarPlot.classList.add('hidden');
        if (toolPlotBtn) toolPlotBtn.classList.remove('active');
        if (sidebarPlotBtn) sidebarPlotBtn.classList.remove('active');
    }
}

/**
 * Change la vue principale de l'application.
 */
function switchView(view) {
    // Si split view actif, changer la vue du panneau actif
    if (splitViewActive) {
        if (typeof switchSplitPanelView === 'function') {
            switchSplitPanelView(splitActivePanel, view);
        }
        return;
    }

    // Fermer tous les panneaux du toolsSidebar quand on quitte la vue structure
    if (currentView === 'editor' && view !== 'editor') {
        closeAllToolsSidebarPanels();
    }

    currentView = view;

    // Update header nav buttons
    document.querySelectorAll('[id^="header-tab-"]').forEach(btn => {
        btn.classList.remove('active');
    });
    const headerBtn = document.getElementById(`header-tab-${view}`);
    if (headerBtn) {
        headerBtn.classList.add('active');
    }

    // Éléments spécifiques à la vue Structure (Editor)
    const structureOnlyElements = [
        'projectProgressBar',
        'statusFilters',
        'sceneTools',
        'toolsSidebar'
    ];

    structureOnlyElements.forEach(id => {
        const el = document.getElementById(id);
        if (el) {
            el.style.display = (view === 'editor') ? '' : 'none';
        }
    });

    // Toolbar de l'arborescence
    const treeCollapseToolbar = document.getElementById('treeCollapseToolbar');
    const viewsWithGroups = ['editor', 'world', 'notes', 'codex', 'thriller'];
    if (treeCollapseToolbar) {
        treeCollapseToolbar.style.display = viewsWithGroups.includes(view) ? '' : 'none';
    }

    // Sidebar des versions (à droite)
    const sidebarVersions = document.getElementById('sidebarVersions');
    if (sidebarVersions) {
        if (view !== 'editor') {
            sidebarVersions.classList.add('hidden');
        }
    }

    // Cacher toutes les listes de la sidebar gauche
    const sidebarLists = [
        'chaptersList', 'charactersList', 'worldList', 'timelineList',
        'notesList', 'codexList', 'arcsList', 'statsList', 'versionsList', 'analysisList',
        'todosList', 'corkboardList', 'mindmapList', 'plotList',
        'relationsList', 'mapList', 'timelineVizList', 'storyGridList', 'thrillerList', 'noSidebarMessage'
    ];

    sidebarLists.forEach(listId => {
        const el = document.getElementById(listId);
        if (el) el.style.display = 'none';
    });

    // Mapping des vues vs listes sidebar
    const sidebarViews = {
        'editor': 'chaptersList',
        'characters': 'charactersList',
        'world': 'worldList',
        'notes': 'notesList',
        'codex': 'codexList',
        'arcs': 'arcsList',
        'mindmap': 'mindmapList',
        'timelineviz': 'timelineVizList',
        'thriller': 'thrillerList'
    };

    const editorViewVues = ['stats', 'analysis', 'versions', 'todos', 'timeline', 'corkboard', 'plot', 'plotgrid', 'relations', 'map'];

    const viewLabelsNoSidebar = {
        'stats': 'Statistiques', 'analysis': 'Analyse', 'versions': 'Versions',
        'todos': 'TODOs', 'timeline': 'Timeline', 'corkboard': 'Tableau',
        'plot': 'Intrigue', 'plotgrid': 'Plot grid', 'relations': 'Relations', 'map': 'Carte',
        'thriller': 'Thriller', 'storygrid': 'Story Grid'
    };

    if (sidebarViews[view]) {
        const listEl = document.getElementById(sidebarViews[view]);
        if (listEl) listEl.style.display = 'block';
    } else if (editorViewVues.includes(view)) {
        const noSidebarEl = document.getElementById('noSidebarMessage');
        if (noSidebarEl) {
            const viewLabel = viewLabelsNoSidebar[view] || 'Cette vue';
            noSidebarEl.innerHTML = `
                <div style="padding: 2rem 1rem; text-align: center; color: var(--text-muted);">
                    <i data-lucide="layout-dashboard" style="width: 48px; height: 48px; opacity: 0.3; margin-bottom: 1rem;"></i>
                    <div style="font-size: 0.9rem; line-height: 1.6;">
                        <strong>${viewLabel}</strong> utilise tout l'espace disponible.
                    </div>
                </div>`;
            noSidebarEl.style.display = 'block';
        }
    }

    // Sur mobile, gérer la sidebar
    const isMobile = window.innerWidth <= 900;
    if (isMobile && sidebarViews[view] && typeof renderMobileSidebarView === 'function') {
        renderMobileSidebarView(view);
    }

    // Update sidebar actions
    const actionsHTML = {
        editor: '<button class="btn btn-primary" onclick="openAddActModal()">+ Acte</button><button class="btn btn-primary" onclick="openAddChapterModal()">+ Chapitre</button><button class="btn btn-primary" onclick="openAddSceneModalQuick()">+ Scène</button>',
        characters: '<button class="btn btn-primary" onclick="openAddCharacterModal()">+ Personnage</button>',
        world: '<button class="btn btn-primary" onclick="openAddWorldModal()">+ Élément</button>',
        notes: '<button class="btn btn-primary" onclick="openAddNoteModal()">+ Note</button>',
        codex: '<button class="btn btn-primary" onclick="openAddCodexModal()">+ Entrée</button>',
        arcs: '<button class="btn btn-primary" onclick="createNewArc()">+ Arc narratif</button>',

    };
    const sidebarActions = document.getElementById('sidebarActions');
    if (sidebarActions) {
        sidebarActions.innerHTML = actionsHTML[view] || '';
    }

    // Hide plot sidebar when leaving editor
    if (view !== 'editor' && !splitViewActive) {
        document.getElementById('sidebarPlot')?.classList.add('hidden');
    }

    // Rendu du contenu
    renderViewContent(view, 'editorView');

    // Live Tension Meter Visibility
    const tensionMeter = document.getElementById('liveTensionMeter');
    if (tensionMeter) {
        tensionMeter.style.display = (view === 'editor') ? 'flex' : 'none';
    }

    // Refresh icons
    setTimeout(() => {
        if (typeof lucide !== 'undefined') lucide.createIcons();
    }, 50);
}

/**
 * Rend le contenu spécifique d'une vue dans un conteneur.
 */
function renderViewContent(view, containerId) {
    const container = document.getElementById(containerId);
    if (!container) return;

    switch (view) {
        case 'editor':
            if (currentActId && currentChapterId && currentSceneId) {
                if (containerId === 'editorView' && !splitViewActive) {
                    const act = project.acts.find(a => a.id === currentActId);
                    if (act) {
                        const chapter = act.chapters.find(c => c.id === currentChapterId);
                        if (chapter) {
                            const scene = chapter.scenes.find(s => s.id === currentSceneId);
                            if (scene) {
                                if (typeof renderEditor === 'function') {
                                    renderEditor(act, chapter, scene);
                                    // Force refresh of links panel
                                    if (typeof autoDetectLinks === 'function') autoDetectLinks();
                                    if (typeof refreshLinksPanel === 'function') refreshLinksPanel();
                                    return;
                                }
                            }
                        }
                    }
                } else if (typeof renderSceneInContainer === 'function') {
                    renderSceneInContainer(currentActId, currentChapterId, currentSceneId, containerId);
                    return;
                }
            }

            // État vide par défaut pour l'éditeur
            if (project.acts.length === 0 || (project.acts.length === 1 && project.acts[0].chapters.length === 0)) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon"><i data-lucide="pencil" style="width:48px;height:48px;stroke-width:1;"></i></div>
                        <div class="empty-state-title">Commencez votre histoire</div>
                        <div class="empty-state-text">Créez votre premier chapitre pour commencer à écrire.</div>
                        <button class="btn btn-primary" onclick="openAddChapterModal()">+ Créer un chapitre</button>
                    </div>`;
            } else {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon"><i data-lucide="pencil" style="width:48px;height:48px;stroke-width:1;"></i></div>
                        <div class="empty-state-title">Sélectionnez une scène</div>
                        <div class="empty-state-text">Choisissez une scène dans la barre latérale pour commencer à écrire.</div>
                    </div>`;
            }
            break;

        case 'characters':
            if (typeof renderCharactersList === 'function') renderCharactersList();
            if (typeof renderCharacterWelcome === 'function') renderCharacterWelcome();
            break;
        case 'world':
            if (typeof renderWorldList === 'function') renderWorldList();
            if (typeof renderWorldWelcome === 'function') renderWorldWelcome();
            break;
        case 'notes':
            if (typeof renderNotesList === 'function') renderNotesList();
            if (typeof renderNotesWelcome === 'function') renderNotesWelcome();
            break;
        case 'codex':
            if (typeof renderCodexList === 'function') renderCodexList();
            if (typeof renderCodexWelcome === 'function') renderCodexWelcome();
            break;
        case 'stats': if (typeof renderStats === 'function') renderStats(); break;
        case 'analysis': if (typeof renderAnalysis === 'function') renderAnalysis(); break;
        case 'versions': if (typeof renderVersionsList === 'function') renderVersionsList(); break;
        case 'todos': if (typeof renderTodosList === 'function') renderTodosList(); break;
        case 'corkboard': if (typeof openCorkBoardView === 'function') openCorkBoardView(); break;
        case 'mindmap': if (typeof renderMindmapView === 'function') renderMindmapView(); break;
        case 'plot': if (typeof renderPlotView === 'function') renderPlotView(); break;
        case 'relations': if (typeof renderRelationsView === 'function') renderRelationsView(); break;
        case 'map': if (typeof renderMapView === 'function') renderMapView(); break;
        case 'timelineviz': if (typeof renderTimelineVizView === 'function') renderTimelineVizView(); break;
        case 'arcs':
            if (typeof renderArcsList === 'function') renderArcsList();
            if (typeof renderArcsWelcome === 'function') renderArcsWelcome();
            break;
        case 'timeline': if (typeof renderTimelineList === 'function') renderTimelineList(); break;
        case 'storygrid': if (typeof renderStoryGrid === 'function') renderStoryGrid(); break;
        case 'thriller': if (typeof renderThrillerBoard === 'function') renderThrillerBoard(); break;
        default:
            container.innerHTML = `
                <div class="empty-state">
                    <div class="empty-state-icon"><i data-lucide="layout" style="width:48px;height:48px;stroke-width:1;"></i></div>
                    <div class="empty-state-title">Panneau vide</div>
                    <div class="empty-state-text">Cliquez sur l'en-tête pour choisir une vue</div>
                </div>`;
            break;
    }
}

/**
 * Rafraîchit toutes les vues de l'application (utile après undo/redo ou import).
 */
function refreshAllViews() {
    // 1. Rafraîchir la structure (sidebar editor)
    if (typeof renderActsList === 'function') renderActsList();

    // 2. Restaurer l'état de l'arborescence
    setTimeout(() => {
        if (typeof restoreTreeState === 'function') restoreTreeState();
    }, 100);

    // 3. Rafraîchir les stats
    if (typeof updateStats === 'function') updateStats();

    // 4. Rafraîchir la vue actuelle
    switch (currentView) {
        case 'editor': if (typeof renderActsList === 'function') renderActsList(); break;
        case 'characters': if (typeof renderCharactersList === 'function') renderCharactersList(); break;
        case 'world': if (typeof renderWorldList === 'function') renderWorldList(); break;
        case 'timeline': if (typeof renderTimelineList === 'function') renderTimelineList(); break;
        case 'notes': if (typeof renderNotesList === 'function') renderNotesList(); break;
        case 'codex': if (typeof renderCodexList === 'function') renderCodexList(); break;
        case 'stats': if (typeof renderStats === 'function') renderStats(); break;
        case 'analysis': if (typeof renderAnalysis === 'function') renderAnalysis(); break;
        case 'versions': if (typeof renderVersionsList === 'function') renderVersionsList(); break;
        case 'todos': if (typeof renderTodosList === 'function') renderTodosList(); break;
        case 'corkboard': if (typeof renderCorkBoard === 'function') renderCorkBoard(); break;
        case 'mindmap': if (typeof renderMindmapView === 'function') renderMindmapView(); break;
        case 'plot': if (typeof renderPlotView === 'function') renderPlotView(); break;
        case 'relations': if (typeof renderRelationsView === 'function') renderRelationsView(); break;
        case 'map': if (typeof renderMapView === 'function') renderMapView(); break;
        case 'timelineviz': if (typeof renderTimelineVizView === 'function') renderTimelineVizView(); break;
        case 'arcs': if (typeof renderArcsList === 'function') renderArcsList(); break;
    }

    // 5. Rafraîchir l'éditeur si une scène est ouverte
    if (currentSceneId) {
        const scene = typeof findScene === 'function' ? findScene(currentActId, currentChapterId, currentSceneId) : null;
        if (scene) {
            const titleEl = document.getElementById('sceneTitle');
            const contentEl = document.getElementById('sceneContent');
            if (titleEl) titleEl.value = scene.title;
            if (contentEl) contentEl.value = scene.content || '';
            if (typeof updateWordCount === 'function') updateWordCount();
        }
    }
}

// --- GOOGLE FONTS SUPPORT ---

const POPULAR_GOOGLE_FONTS = [
    "Merriweather", "Roboto", "Open Sans", "Lato", "Montserrat", "Oswald", "Raleway", "Noto Sans", "Poppins", "Nunito",
    "Playfair Display", "Rubik", "Mukta", "Lora", "Work Sans", "Nunito Sans", "Fira Sans", "Quicksand", "Inter", "Barlow",
    "PT Serif", "PT Sans", "Inconsolata", "Kanit", "Exo 2", "Titillium Web", "Crimson Pro", "Libre Baskerville", "Arvo",
    "Josefin Sans", "Anton", "Bitter", "Dosis", "Teko", "Oxygen", "Cabin", "Hind", "Patua One", "Muli", "Abel", "Varela Round",
    "Pacifico", "Dancing Script", "Shadows Into Light", "Indie Flower", "Amatic SC", "Caveat", "Satisfy", "Great Vibes", "Sacramento",
    "Space Mono", "Source Code Pro", "IBM Plex Mono", "Ubuntu Mono", "Courier New", "Georgia", "Times New Roman", "Verdana", "Arial"
].sort();

function loadGoogleFont(fontName) {
    if (!fontName) return;
    const linkId = `font-${fontName.replace(/\s+/g, '-').toLowerCase()}`;
    if (!document.getElementById(linkId)) {
        const link = document.createElement('link');
        link.id = linkId;
        link.rel = 'stylesheet';
        link.href = `https://fonts.googleapis.com/css2?family=${fontName.replace(/\s+/g, '+')}:ital,wght@0,300;0,400;0,500;0,600;0,700;1,400;1,700&display=swap`;
        document.head.appendChild(link);
    }
}

function applyFont(fontName, panel = null) {
    if (fontName === 'custom') {
        const customFont = prompt("Entrez le nom de la police Google Font exact (ex: 'Roboto Slab') :");
        if (customFont && customFont.trim()) {
            const cleanFontName = customFont.trim();
            loadGoogleFont(cleanFontName);
            // Add option to select if not exists
            const selects = document.querySelectorAll('.font-family-selector');
            selects.forEach(select => {
                // Check duplicate
                let exists = false;
                for (let i = 0; i < select.options.length; i++) {
                    if (select.options[i].value === cleanFontName) exists = true;
                }
                if (!exists) {
                    const opt = document.createElement('option');
                    opt.value = cleanFontName;
                    opt.text = cleanFontName;
                    // Insert before the last option "Autre..."
                    if (select.options.length > 0) {
                        select.add(opt, select.options[select.options.length - 1]);
                    } else {
                        select.add(opt);
                    }
                    select.value = cleanFontName;
                } else {
                    select.value = cleanFontName;
                }
            });

            if (panel) {
                if (typeof formatTextInPanel === 'function') formatTextInPanel(panel, 'fontName', cleanFontName);
            } else {
                if (typeof formatText === 'function') formatText('fontName', cleanFontName);
            }
        } else {
            // Reset select to default or previous? For now do nothing
        }
    } else {
        // Standard fonts usually don't need loading, but we load everything in our list just in case it's a google font version
        // Except standard websafe fonts
        const standardFonts = ["Arial", "Georgia", "Times New Roman", "Courier New", "Verdana", "Garamond", "Palatino"];
        if (!standardFonts.includes(fontName)) {
            loadGoogleFont(fontName);
        }

        if (panel) {
            if (typeof formatTextInPanel === 'function') formatTextInPanel(panel, 'fontName', fontName);
        } else {
            if (typeof formatText === 'function') formatText('fontName', fontName);
        }
    }
}


/**
 * Ouvre un acte complet et affiche tous ses chapitres et scènes de manière séquentielle.
 */
function openAct(actId) {
    if (window.innerWidth <= 900 && typeof closeMobileSidebar === 'function') {
        closeMobileSidebar();
    }

    if (typeof saveToHistoryImmediate === 'function') saveToHistoryImmediate();

    currentActId = actId;
    currentChapterId = null; // Mode acte, pas de chapitre unique
    currentSceneId = null; // Mode acte, pas de scène unique

    const act = project.acts.find(a => a.id === actId);

    if (!act || !act.chapters || act.chapters.length === 0) return;

    // Vérifier s'il y a au moins une scène dans l'acte
    const hasScenes = act.chapters.some(ch => ch.scenes && ch.scenes.length > 0);
    if (!hasScenes) return;

    // Mise à jour visuelle sidebar
    document.querySelectorAll('.act-header, .chapter-header, .scene-item').forEach(el => el.classList.remove('active'));
    const actElement = document.getElementById(`act-${actId}`);
    if (actElement) {
        actElement.querySelector('.act-header')?.classList.add('active');

        // Auto-expand l'acte
        actElement.querySelector('.act-icon')?.classList.add('expanded');
        actElement.querySelector('.act-chapters')?.classList.add('visible');

        // Mettre à jour l'état mémorisé (indispensable pour que ça reste ouvert au prochain rendu)
        if (typeof expandedActs !== 'undefined') expandedActs.add(actId);
    }

    // Rendu de l'éditeur d'acte
    if (typeof renderActEditor === 'function') {
        renderActEditor(act);
    }
}

/**
 * Ouvre un chapitre complet et affiche toutes ses scènes de manière séquentielle.
 */
function openChapter(actId, chapterId) {
    if (window.innerWidth <= 900 && typeof closeMobileSidebar === 'function') {
        closeMobileSidebar();
    }

    if (typeof saveToHistoryImmediate === 'function') saveToHistoryImmediate();

    currentActId = actId;
    currentChapterId = chapterId;
    currentSceneId = null; // Mode chapitre, pas de scène unique

    const act = project.acts.find(a => a.id === actId);
    const chapter = act ? act.chapters.find(c => c.id === chapterId) : null;

    if (!chapter || !chapter.scenes || chapter.scenes.length === 0) return;

    // Mise à jour visuelle sidebar
    document.querySelectorAll('.act-header, .chapter-header, .scene-item').forEach(el => el.classList.remove('active'));
    const chapterElement = document.getElementById(`chapter-${chapterId}`);
    if (chapterElement) {
        chapterElement.querySelector('.chapter-header')?.classList.add('active');

        // Auto-expand parents
        chapterElement.querySelector('.chapter-icon')?.classList.add('expanded');
        chapterElement.querySelector('.scenes-list')?.classList.add('visible');

        const actElement = document.getElementById(`act-${actId}`);
        if (actElement) {
            actElement.querySelector('.act-icon')?.classList.add('expanded');
            actElement.querySelector('.act-chapters')?.classList.add('visible');
            if (typeof expandedActs !== 'undefined') expandedActs.add(actId);
        }
        if (typeof expandedChapters !== 'undefined') expandedChapters.add(chapterId);
    }

    // Rendu de l'éditeur de chapitre
    if (typeof renderChapterEditor === 'function') {
        renderChapterEditor(act, chapter);
    }
}

/**
 * Ouvre une scène spécifique et gère toute l'orchestration associée.
 */
function openScene(actId, chapterId, sceneId) {
    // Nettoyer le tracking de scroll du mode chapitre
    if (typeof cleanupChapterScrollTracking === 'function') cleanupChapterScrollTracking();

    if (window.innerWidth <= 900 && typeof closeMobileSidebar === 'function') {
        closeMobileSidebar();
    }

    if (typeof saveToHistoryImmediate === 'function') saveToHistoryImmediate();

    currentActId = actId;
    currentChapterId = chapterId;
    currentSceneId = sceneId;

    const act = project.acts.find(a => a.id === actId);
    const chapter = act ? act.chapters.find(c => c.id === chapterId) : null;
    const scene = chapter ? chapter.scenes.find(s => s.id === sceneId) : null;

    if (!scene) return;

    // Mise à jour visuelle sidebar
    document.querySelectorAll('.act-header, .chapter-header, .scene-item').forEach(el => el.classList.remove('active'));
    const sceneElement = document.querySelector(`[data-scene-id="${sceneId}"]`);
    if (sceneElement) {
        sceneElement.classList.add('active');

        // Auto-expand parents
        const chapterElement = document.getElementById(`chapter-${chapterId}`);
        if (chapterElement) {
            chapterElement.querySelector('.chapter-icon')?.classList.add('expanded');
            chapterElement.querySelector('.scenes-list')?.classList.add('visible');
        }
        const actElement = document.getElementById(`act-${actId}`);
        if (actElement) {
            actElement.querySelector('.act-icon')?.classList.add('expanded');
            actElement.querySelector('.act-chapters')?.classList.add('visible');
            if (typeof expandedActs !== 'undefined') expandedActs.add(actId);
        }
        if (typeof expandedChapters !== 'undefined') expandedChapters.add(chapterId);
    }

    // Gestion Split View vs Normal
    if (splitViewActive && typeof renderSplitPanelViewContent === 'function') {
        let editorPanel = splitViewState.left.view === 'editor' ? 'left' : (splitViewState.right.view === 'editor' ? 'right' : null);
        const panel = editorPanel || splitActivePanel;
        const state = panel === 'left' ? splitViewState.left : splitViewState.right;
        state.view = 'editor';
        state.sceneId = sceneId; state.actId = actId; state.chapterId = chapterId;
        renderSplitPanelViewContent(panel);
        splitActivePanel = panel;
        if (typeof saveSplitViewState === 'function') saveSplitViewState();
    } else if (typeof renderEditor === 'function') {
        renderEditor(act, chapter, scene);
    }

    // Post-open orchestrations
    if (typeof autoDetectLinks === 'function') autoDetectLinks();
    if (typeof refreshLinksPanel === 'function') refreshLinksPanel();
    if (typeof renderSceneVersionsList === 'function') renderSceneVersionsList();

    // Update arc scene panel if it's visible
    const arcPanel = document.getElementById('arcScenePanel');
    if (arcPanel && !arcPanel.classList.contains('hidden') && typeof renderArcScenePanel === 'function') {
        renderArcScenePanel();
    }

    // Refresh plot sidebar if open
    if (typeof PlotGridUI !== 'undefined' && !document.getElementById('sidebarPlot').classList.contains('hidden')) {
        PlotGridUI.renderSidebar(sceneId);
    }

    // Annotations automatic opening
    const annotations = typeof getVersionAnnotations === 'function' ? getVersionAnnotations(scene) : [];
    if (annotations && annotations.length > 0 && window.innerWidth > 900) {
        if (typeof renderAnnotationsPanel === 'function') renderAnnotationsPanel();
        if (typeof updateAnnotationsButton === 'function') updateAnnotationsButton(true);
    } else {
        document.getElementById('annotationsPanel')?.classList.add('hidden');
        if (typeof updateAnnotationsButton === 'function') updateAnnotationsButton(false);
    }
}

// --- UTILITAIRES DE L'ARBORESCENCE (TREEVIEW) ---

function expandAllTree() {
    document.querySelectorAll('.act-group, .chapter-group').forEach(group => {
        group.querySelector('.act-icon, .chapter-icon')?.classList.add('expanded');
        group.querySelector('.act-chapters, .scenes-list')?.classList.add('visible');
    });

    document.querySelectorAll('.act-group').forEach(el => expandedActs.add(parseInt(el.dataset.actId)));
    document.querySelectorAll('.chapter-group').forEach(el => expandedChapters.add(parseInt(el.dataset.chapterId)));

    // Treeview groups (Univers, Codex, etc.)
    document.querySelectorAll('.treeview-group').forEach(group => {
        group.querySelector('.treeview-children')?.classList.remove('collapsed');
        group.querySelector('.treeview-chevron')?.setAttribute('data-lucide', 'chevron-down');
    });

    if (typeof renderNotesList === 'function') {
        expandedNoteCategories = new Set(['Idée', 'Recherche', 'Référence', 'A faire', 'Question', 'Autre']);
        renderNotesList();
    }

    if (typeof ActRepository?.saveTreeState === 'function') ActRepository.saveTreeState();
    if (typeof lucide !== 'undefined') lucide.createIcons();
}

function collapseAllTree() {
    document.querySelectorAll('.act-icon, .chapter-icon').forEach(el => el.classList.remove('expanded'));
    document.querySelectorAll('.act-chapters, .scenes-list').forEach(el => el.classList.remove('visible'));

    expandedActs.clear();
    expandedChapters.clear();

    document.querySelectorAll('.treeview-children').forEach(el => el.classList.add('collapsed'));
    document.querySelectorAll('.treeview-chevron').forEach(el => el.setAttribute('data-lucide', 'chevron-right'));

    if (typeof renderNotesList === 'function') {
        expandedNoteCategories.clear();
        renderNotesList();
    }

    if (typeof ActRepository?.saveTreeState === 'function') ActRepository.saveTreeState();
    if (typeof lucide !== 'undefined') lucide.createIcons();
}

function restoreTreeState() {
    expandedActs.forEach(id => {
        const el = document.getElementById(`act-${id}`);
        if (el) {
            el.querySelector('.act-icon')?.classList.add('expanded');
            el.querySelector('.act-chapters')?.classList.add('visible');
        }
    });
    expandedChapters.forEach(id => {
        const el = document.getElementById(`chapter-${id}`);
        if (el) {
            el.querySelector('.chapter-icon')?.classList.add('expanded');
            el.querySelector('.scenes-list')?.classList.add('visible');
        }
    });
}

// --- UTILITAIRES UI GLOBAUX ---

function closeModal(modalId) {
    document.getElementById(modalId)?.classList.remove('active');
}

function openProjectsModal() {
    if (typeof renderProjectsList === 'function') renderProjectsList();
    document.getElementById('projectsModal')?.classList.add('active');
}


function toggleStatusFilter(status) {
    const index = activeStatusFilters.indexOf(status);
    const btn = document.querySelector(`.status-filter-btn[data-status="${status}"]`);

    if (index > -1) {
        activeStatusFilters.splice(index, 1);
        btn?.classList.remove('active');
    } else {
        activeStatusFilters.push(status);
        btn?.classList.add('active');
    }

    if (typeof applyStatusFilters === 'function') applyStatusFilters();
}

/**
 * [MVVM : View]
 * Définit la scène active pour les outils de la barre latérale.
 * Utile pour les vues séquentielles (Acte/Chapitre) où plusieurs scènes sont affichées.
 */
function setActiveScene(actId, chapterId, sceneId) {
    if (currentSceneId === sceneId) return;

    currentActId = actId;
    currentChapterId = chapterId;
    currentSceneId = sceneId;

    // Mettre à jour les titres et breadcrumbs si on est en vue Acte ou Chapitre
    const act = project.acts.find(a => a.id === actId);
    const chapter = act?.chapters.find(c => c.id === chapterId);
    const scene = chapter?.scenes.find(s => s.id === sceneId);

    if (scene) {
        // En vue chapitre
        const chapterTitleEl = document.getElementById('chapterEditorTitle');
        if (chapterTitleEl) chapterTitleEl.textContent = scene.title;

        // En vue acte
        const actTitleEl = document.getElementById('actEditorTitle');
        if (actTitleEl) actTitleEl.textContent = scene.title;

        const breadcrumbEl = document.querySelector('.act-editor-header .editor-breadcrumb');
        if (breadcrumbEl && act && chapter) {
            breadcrumbEl.textContent = `${act.title} › ${chapter.title}`;
        }

        // Mettre à jour les indicateurs de navigation (points sur le côté ou segments)
        const dots = document.querySelectorAll('.scene-nav-dot');
        dots.forEach(dot => {
            dot.classList.remove('active');
            if (dot.getAttribute('onclick')?.includes(scene.id)) {
                dot.classList.add('active');
            }
        });

        const segments = document.querySelectorAll('.progress-scene-segment');
        segments.forEach(seg => {
            seg.classList.remove('active');
            if (seg.dataset.sceneId == scene.id) {
                seg.classList.add('active');
            }
        });
    }

    // Mettre à jour les indicateurs visuels des sidebars si ouverts

    // 1. Versions
    if (typeof renderSceneVersionsList === 'function' && !document.getElementById('sidebarVersions').classList.contains('hidden')) {
        renderSceneVersionsList();
    }

    // 2. Annotations
    if (typeof renderAnnotationsPanel === 'function' && !document.getElementById('annotationsPanel').classList.contains('hidden')) {
        renderAnnotationsPanel();
    }

    // 3. Arcs
    if (typeof renderArcScenePanel === 'function' && !document.getElementById('arcScenePanel').classList.contains('hidden')) {
        renderArcScenePanel();
    }

    // 4. Plot Grid Sidebar
    if (typeof PlotGridUI !== 'undefined' && typeof PlotGridUI.renderSidebar === 'function' && !document.getElementById('sidebarPlot').classList.contains('hidden')) {
        PlotGridUI.renderSidebar(sceneId);
    }

    // 5. Liens (Characters, World, etc.)
    if (typeof refreshLinksPanel === 'function') {
        refreshLinksPanel();
    }

    // Mettre à jour le badge d'annotations dans la sidebar
    if (typeof updateAnnotationsButton === 'function') {
        updateAnnotationsButton(false);
    }

    // Mettre à jour l'indicateur de tension si disponible
    const editor = document.querySelector(`.editor-textarea[data-scene-id="${sceneId}"]`);
    if (editor && typeof updateLiveTensionMeter === 'function') {
        updateLiveTensionMeter(editor.innerHTML, { actId, chapterId, sceneId });
    }
}

// --- EDITOR RENDERING ---

/**
 * [MVVM : View]
 * Retourne le HTML complet de la barre d'outils de l'éditeur.
 * @param {string} [panel] - Si présent, utilise formatTextInPanel au lieu de formatText
 */
function getEditorToolbarHTML(panel = null) {
    const fnName = panel ? 'formatTextInPanel' : 'formatText';
    const fnPrefix = panel ? `'${panel}', ` : '';
    const idSuffix = panel ? `-${panel}` : '';

    return `
        <!-- Basic formatting -->
        <div class="toolbar-group">
            <button class="toolbar-btn" data-format="bold" onclick="${fnName}(${fnPrefix}'bold')" title="Gras (Ctrl+B)">
                <i data-lucide="bold" style="width:14px;height:14px;"></i>
            </button>
            <button class="toolbar-btn" data-format="italic" onclick="${fnName}(${fnPrefix}'italic')" title="Italique (Ctrl+I)">
                <i data-lucide="italic" style="width:14px;height:14px;"></i>
            </button>
            <button class="toolbar-btn" data-format="underline" onclick="${fnName}(${fnPrefix}'underline')" title="Souligné (Ctrl+U)">
                <i data-lucide="underline" style="width:14px;height:14px;"></i>
            </button>
            <button class="toolbar-btn" data-format="strikethrough" onclick="${fnName}(${fnPrefix}'strikeThrough')" title="Barré">
                <i data-lucide="strikethrough" style="width:14px;height:14px;"></i>
            </button>
        </div>
        
        <!-- Font family and size -->
        <div class="toolbar-group">
            <select class="font-family-selector" onchange="applyFont(this.value, ${panel ? `'${panel}'` : 'null'})" title="Police de caractères" style="max-width: 150px;">
                ${POPULAR_GOOGLE_FONTS.map(font => `<option value="${font}" style="font-family: '${font}', sans-serif;">${font}</option>`).join('')}
                <option value="" disabled>──────────</option>
                <option value="custom" style="font-weight: bold; color: var(--accent-color);">+ Autre Google Font...</option>
            </select>
            <select class="font-size-selector" onchange="${fnName}(${fnPrefix}'fontSize', this.value)" title="Taille de police">
                <option value="1">Très petit</option>
                <option value="2">Petit</option>
                <option value="3" selected>Normal</option>
                <option value="4">Grand</option>
                <option value="5">Très grand</option>
                <option value="6">Énorme</option>
                <option value="7">Gigantesque</option>
            </select>
        </div>
        
        <!-- Text color -->
        <div class="toolbar-group">
            <div class="color-picker-wrapper">
                <button class="toolbar-btn" onclick="toggleColorPicker('text', event, ${panel ? `'${panel}'` : 'null'})" title="Couleur du texte">
                    <i data-lucide="baseline" style="width:14px;height:14px; border-bottom: 2px solid currentColor;"></i>
                </button>
                <div class="color-picker-dropdown" id="textColorPicker${idSuffix}">
                    <div class="color-grid" id="textColorGrid${idSuffix}"></div>
                    <div class="color-input-wrapper">
                        <input type="color" id="textColorInput${idSuffix}" onchange="applyTextColor(this.value, ${panel ? `'${panel}'` : 'null'})">
                        <input type="text" id="textColorHex${idSuffix}" placeholder="#000000" maxlength="7" onchange="applyTextColor(this.value, ${panel ? `'${panel}'` : 'null'})">
                    </div>
                </div>
            </div>
            <div class="color-picker-wrapper">
                <button class="toolbar-btn" onclick="toggleColorPicker('background', event, ${panel ? `'${panel}'` : 'null'})" title="Couleur de fond">
                    <i data-lucide="highlighter" style="width:14px;height:14px; border-bottom: 2px solid yellow;"></i>
                </button>
                <div class="color-picker-dropdown" id="backgroundColorPicker${idSuffix}">
                    <div class="color-grid" id="backgroundColorGrid${idSuffix}"></div>
                    <div class="color-input-wrapper">
                        <input type="color" id="bgColorInput${idSuffix}" onchange="applyBackgroundColor(this.value, ${panel ? `'${panel}'` : 'null'})">
                        <input type="text" id="bgColorHex${idSuffix}" placeholder="#FFFF00" maxlength="7" onchange="applyBackgroundColor(this.value, ${panel ? `'${panel}'` : 'null'})">
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Alignment -->
        <div class="toolbar-group">
            <button class="toolbar-btn" onclick="${fnName}(${fnPrefix}'justifyLeft')" title="Aligner à gauche">
                <i data-lucide="align-left" style="width:14px;height:14px;"></i>
            </button>
            <button class="toolbar-btn" onclick="${fnName}(${fnPrefix}'justifyCenter')" title="Centrer">
                <i data-lucide="align-center" style="width:14px;height:14px;"></i>
            </button>
            <button class="toolbar-btn" onclick="${fnName}(${fnPrefix}'justifyRight')" title="Aligner à droite">
                <i data-lucide="align-right" style="width:14px;height:14px;"></i>
            </button>
            <button class="toolbar-btn" onclick="${fnName}(${fnPrefix}'justifyFull')" title="Justifier">
                <i data-lucide="align-justify" style="width:14px;height:14px;"></i>
            </button>
        </div>
        
        <!-- Headings -->
        <div class="toolbar-group">
            <button class="toolbar-btn" onclick="${fnName}(${fnPrefix}'formatBlock', 'h1')" title="Titre 1"><i data-lucide="heading-1" style="width:14px;height:14px;"></i></button>
            <button class="toolbar-btn" onclick="${fnName}(${fnPrefix}'formatBlock', 'h2')" title="Titre 2"><i data-lucide="heading-2" style="width:14px;height:14px;"></i></button>
            <button class="toolbar-btn" onclick="${fnName}(${fnPrefix}'formatBlock', 'h3')" title="Titre 3"><i data-lucide="heading-3" style="width:14px;height:14px;"></i></button>
            <button class="toolbar-btn" onclick="${fnName}(${fnPrefix}'formatBlock', 'p')" title="Paragraphe"><i data-lucide="pilcrow" style="width:14px;height:14px;"></i></button>
        </div>
        
        <!-- Lists and quotes -->
        <div class="toolbar-group">
            <button class="toolbar-btn" onclick="${fnName}(${fnPrefix}'insertUnorderedList')" title="Liste à puces"><i data-lucide="list" style="width:14px;height:14px;"></i></button>
            <button class="toolbar-btn" onclick="${fnName}(${fnPrefix}'insertOrderedList')" title="Liste numérotée"><i data-lucide="list-ordered" style="width:14px;height:14px;"></i></button>
            <button class="toolbar-btn" onclick="${fnName}(${fnPrefix}'formatBlock', 'blockquote')" title="Citation"><i data-lucide="quote" style="width:14px;height:14px;"></i></button>
        </div>
        
        <!-- Indentation -->
        <div class="toolbar-group">
            <button class="toolbar-btn" onclick="${fnName}(${fnPrefix}'indent')" title="Augmenter l'indentation"><i data-lucide="indent" style="width:14px;height:14px;"></i></button>
            <button class="toolbar-btn" onclick="${fnName}(${fnPrefix}'outdent')" title="Diminuer l'indentation"><i data-lucide="outdent" style="width:14px;height:14px;"></i></button>
        </div>
        
        <!-- Superscript, subscript -->
        <div class="toolbar-group">
            <button class="toolbar-btn" onclick="${fnName}(${fnPrefix}'superscript')" title="Exposant"><i data-lucide="superscript" style="width:14px;height:14px;"></i></button>
            <button class="toolbar-btn" onclick="${fnName}(${fnPrefix}'subscript')" title="Indice"><i data-lucide="subscript" style="width:14px;height:14px;"></i></button>
        </div>
        
        <!-- Synonyms -->
        <div class="toolbar-group">
            <button class="toolbar-btn" onclick="if(typeof SynonymsView !== 'undefined') SynonymsView.toggle()" title="Dictionnaire des synonymes (Ctrl+Shift+S)">
                <i data-lucide="book-a" style="width:14px;height:14px;"></i>
            </button>
        </div>

        <!-- Other -->
        <div class="toolbar-group">
            <button class="toolbar-btn" onclick="${fnName}(${fnPrefix}'insertHorizontalRule')" title="Ligne horizontale"><i data-lucide="minus" style="width:14px;height:14px;"></i></button>
            <button class="toolbar-btn" onclick="${fnName}(${fnPrefix}'removeFormat')" title="Supprimer le formatage"><i data-lucide="eraser" style="width:14px;height:14px;"></i></button>
        </div>

        
        <!-- Revision mode button -->
        <div class="toolbar-group">
            <button class="toolbar-btn" onclick="toggleRevisionMode()" title="Mode Révision (Ctrl+R)" style="color: var(--accent-gold); font-weight: 600;"><i data-lucide="pencil" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i> RÉVISION</button>
        </div>
    `;
}

/**
 * [MVVM : View]
 * Génère et affiche l'éditeur de texte complet.
 */
function renderEditor(act, chapter, scene) {
    const editorView = document.getElementById('editorView');
    if (!editorView) return;

    const wordCount = typeof getWordCount === 'function' ? getWordCount(scene.content) : 0;

    // Vérifier si une version finale existe
    const hasFinalVersion = scene.versions && scene.versions.some(v => v.isFinal === true);
    const finalVersion = hasFinalVersion ? scene.versions.find(v => v.isFinal === true) : null;
    const finalVersionBadge = hasFinalVersion
        ? `<span style="display: inline-flex; align-items: center; gap: 0.25rem; background: var(--accent-gold); color: var(--bg-accent); font-size: 0.7rem; font-weight: 600; padding: 0.2rem 0.5rem; border-radius: 10px; margin-left: 0.5rem;" title="Version finale : ${finalVersion.number}"><i data-lucide="star" style="width:10px;height:10px;fill:currentColor;"></i> ${finalVersion.number}</span>`
        : '';

    editorView.innerHTML = `
        <div class="editor-header">
            <div class="editor-breadcrumb">${act.title} > ${chapter.title}</div>
            <div style="display: flex; align-items: center; gap: 1rem;">
                <div class="editor-title" style="flex: 1;">${scene.title}${finalVersionBadge}</div>
                <button class="btn btn-small" onclick="toggleFocusMode()" title="Mode Focus (F11)" style="white-space: nowrap;">
                    <i data-lucide="maximize" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Focus
                </button>
            </div>
            <div class="editor-meta">
                <span id="sceneWordCount">${wordCount} mots</span>
                <span>Dernière modification : ${new Date(scene.updatedAt || Date.now()).toLocaleDateString('fr-FR')}</span>
            </div>
            <div class="editor-synopsis">
                <span class="synopsis-label"><i data-lucide="file-text" style="width:12px;height:12px;"></i> Résumé :</span>
                <input type="text" 
                       class="synopsis-input" 
                       value="${(scene.synopsis || '').replace(/"/g, '&quot;')}" 
                       placeholder="Ajouter un résumé de la scène..."
                       onchange="updateSceneSynopsis(${act.id}, ${chapter.id}, ${scene.id}, this.value)"
                       oninput="this.style.width = Math.max(200, this.scrollWidth) + 'px'">
            </div>
        </div>

        <button class="toolbar-mobile-toggle" onclick="toggleEditorToolbar()">
            <span id="toolbarToggleText"><i data-lucide="pen-line" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Afficher les outils</span>
        </button>
        
        <div class="editor-toolbar" id="editorToolbar">
            ${getEditorToolbarHTML()}
        </div>

        <div class="editor-content">
            <div class="editor-textarea" contenteditable="true" spellcheck="true" oninput="updateSceneContent()">${scene.content || ''}</div>
        </div>`;

    if (typeof lucide !== 'undefined') lucide.createIcons();
    if (typeof initializeColorPickers === 'function') initializeColorPickers();

    // Focus if empty
    setTimeout(() => {
        const editor = document.querySelector('.editor-textarea');
        if (editor && editor.textContent.trim() === '') editor.focus();

    }, 100);

    // Initialize scene navigation toolbar
    setTimeout(() => {
        if (typeof initSceneNavigation === 'function') initSceneNavigation();
        if (typeof updateLiveTensionMeter === 'function') updateLiveTensionMeter(scene.content || '', { actId: act.id, chapterId: chapter.id, sceneId: scene.id });
    }, 200);
}

/**
 * [MVVM : View]
 * Génère et affiche l'éditeur d'acte avec tous les chapitres et scènes séquentiellement.
 */
function renderActEditor(act) {
    const editorView = document.getElementById('editorView');
    if (!editorView) return;

    // Calculer les statistiques de l'acte
    let totalWords = 0;
    const chapterData = [];

    act.chapters.forEach((chapter, chapterIndex) => {
        let chapterWords = 0;
        const sceneWordCounts = [];

        chapter.scenes.forEach(scene => {
            const wc = typeof getWordCount === 'function' ? getWordCount(scene.content) : (scene.wordCount || 0);
            sceneWordCounts.push(wc);
            chapterWords += wc;
        });

        chapterData.push({
            chapter,
            chapterWords,
            sceneWordCounts,
            chapterIndex
        });

        totalWords += chapterWords;
    });

    // Générer le HTML pour tous les chapitres et scènes
    let contentHTML = '';
    let allScenes = [];

    chapterData.forEach(({ chapter, chapterWords, sceneWordCounts, chapterIndex }) => {
        if (chapter.scenes.length === 0) return;

        contentHTML += `
            <div class="act-chapter-block" data-chapter-id="${chapter.id}" data-chapter-index="${chapterIndex}">
                <div class="chapter-separator">
                    <div class="chapter-separator-title">${chapter.title}</div>
                    <div class="chapter-separator-meta">
                        <span>${chapterWords} mots</span>
                        <span>${chapter.scenes.length} scène${chapter.scenes.length > 1 ? 's' : ''}</span>
                    </div>
                </div>`;

        chapter.scenes.forEach((scene, sceneIndex) => {
            const wordCount = sceneWordCounts[sceneIndex];
            const hasFinalVersion = scene.versions && scene.versions.some(v => v.isFinal === true);
            const finalVersion = hasFinalVersion ? scene.versions.find(v => v.isFinal === true) : null;
            const finalVersionBadge = hasFinalVersion
                ? `<span style="display: inline-flex; align-items: center; gap: 0.25rem; background: var(--accent-gold); color: var(--bg-accent); font-size: 0.7rem; font-weight: 600; padding: 0.2rem 0.5rem; border-radius: 10px; margin-left: 0.5rem;" title="Version finale : ${finalVersion.number}"><i data-lucide="star" style="width:10px;height:10px;fill:currentColor;"></i> ${finalVersion.number}</span>`
                : '';

            allScenes.push({
                scene,
                wordCount,
                chapterId: chapter.id,
                chapterTitle: chapter.title
            });

            contentHTML += `
                <div class="act-scene-block" data-scene-id="${scene.id}" data-chapter-id="${chapter.id}" data-scene-index="${allScenes.length - 1}">
                    <div class="scene-separator">
                        <div class="scene-separator-title">${scene.title}${finalVersionBadge}</div>
                        <div class="scene-separator-meta">
                            <span>${wordCount} mots</span>
                            <textarea class="scene-separator-synopsis" placeholder="Ajouter un résumé..." onblur="saveSceneSynopsis(${act.id}, ${chapter.id}, ${scene.id}, this)" onkeydown="handleSynopsisKeydown(event, this)" rows="1" oninput="autoResizeSynopsis(this)">${scene.synopsis || ''}</textarea>
                        </div>
                    </div>
                    <div class="editor-textarea" contenteditable="true" spellcheck="true"
                         data-scene-id="${scene.id}"
                         data-chapter-id="${chapter.id}"
                         data-act-id="${act.id}"
                         onfocus="setActiveScene(${act.id}, ${chapter.id}, ${scene.id})"
                         oninput="updateActSceneContent(${act.id}, ${chapter.id}, ${scene.id})">${scene.content || ''}</div>
                </div>`;
        });

        contentHTML += `</div>`;
    });

    editorView.innerHTML = `
        <div class="editor-header">
            <div class="editor-breadcrumb">${act.title}</div>
            <div style="display: flex; align-items: center; gap: 1rem;">
                <div class="editor-title" id="actEditorTitle" style="flex: 1;">${act.title} - Tous les chapitres</div>
                <button class="btn btn-small" onclick="toggleFocusMode()" title="Mode Focus (F11)" style="white-space: nowrap;">
                    <i data-lucide="maximize" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Focus
                </button>
            </div>
            <div class="editor-meta">
                <span>${totalWords} mots au total</span>
                <span>${act.chapters.length} chapitre${act.chapters.length > 1 ? 's' : ''}</span>
                <span>${allScenes.length} scène${allScenes.length > 1 ? 's' : ''}</span>
                <span>Dernière modification : ${new Date(act.updatedAt || Date.now()).toLocaleDateString('fr-FR')}</span>
            </div>
        </div>

        <button class="toolbar-mobile-toggle" onclick="toggleEditorToolbar()">
            <span id="toolbarToggleText"><i data-lucide="pen-line" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Afficher les outils</span>
        </button>
        
        <div class="editor-toolbar" id="editorToolbar">
            ${getEditorToolbarHTML()}
        </div>

        <!-- Indicateur de position vertical -->
        <div class="chapter-progress-indicator" id="actProgressIndicator">
            ${allScenes.map((sceneData, index) => {
        const heightPercent = totalWords > 0 ? (sceneData.wordCount / totalWords) * 100 : (100 / allScenes.length);
        return `<div class="progress-scene-segment"
                            data-scene-id="${sceneData.scene.id}"
                            data-scene-index="${index}"
                            style="height: ${heightPercent}%"
                            title="${sceneData.chapterTitle} - ${sceneData.scene.title} (${sceneData.wordCount} mots)"
                            onclick="scrollToActScene(${index})"></div>`;
    }).join('')}
            <div class="progress-current-indicator" id="progressCurrentIndicator"></div>
        </div>

        <div class="editor-content" id="actEditorContent">
            ${contentHTML}
        </div>`;

    if (typeof lucide !== 'undefined') lucide.createIcons();
    if (typeof initializeColorPickers === 'function') initializeColorPickers();

    // Initialiser le tracking de scroll
    setTimeout(() => {
        initActScrollTracking(act.id, allScenes);
        // Auto-resize des synopsis existants
        document.querySelectorAll('.scene-separator-synopsis').forEach(autoResizeSynopsis);
    }, 100);

    // Initialize scene navigation toolbar
    setTimeout(() => {
        if (typeof initSceneNavigation === 'function') initSceneNavigation();
        if (typeof updateLiveTensionMeter === 'function' && allScenes.length > 0) {
            updateLiveTensionMeter(allScenes[0].scene.content || '', { actId: act.id, chapterId: allScenes[0].chapterId, sceneId: allScenes[0].scene.id });
        }
    }, 200);
}

/**
 * [MVVM : View]
 * Génère et affiche l'éditeur de chapitre avec toutes les scènes séquentiellement.
 */
function renderChapterEditor(act, chapter) {
    const editorView = document.getElementById('editorView');
    if (!editorView) return;

    // Calculer les statistiques du chapitre
    let totalWords = 0;
    const sceneWordCounts = [];
    chapter.scenes.forEach(scene => {
        const wc = typeof getWordCount === 'function' ? getWordCount(scene.content) : (scene.wordCount || 0);
        sceneWordCounts.push(wc);
        totalWords += wc;
    });

    // Générer le HTML pour toutes les scènes
    let scenesHTML = '';
    chapter.scenes.forEach((scene, index) => {
        const wordCount = sceneWordCounts[index];
        const hasFinalVersion = scene.versions && scene.versions.some(v => v.isFinal === true);
        const finalVersion = hasFinalVersion ? scene.versions.find(v => v.isFinal === true) : null;
        const finalVersionBadge = hasFinalVersion
            ? `<span style="display: inline-flex; align-items: center; gap: 0.25rem; background: var(--accent-gold); color: var(--bg-accent); font-size: 0.7rem; font-weight: 600; padding: 0.2rem 0.5rem; border-radius: 10px; margin-left: 0.5rem;" title="Version finale : ${finalVersion.number}"><i data-lucide="star" style="width:12px;height:12px;vertical-align:middle;"></i> ${finalVersion.number}</span>`
            : '';

        scenesHTML += `
            <div class="chapter-scene-block" data-scene-id="${scene.id}" data-scene-index="${index}">
                <div class="scene-separator">
                    <div class="scene-separator-title">${scene.title}${finalVersionBadge}</div>
                    <div class="scene-separator-meta">
                        <span>${wordCount} mots</span>
                        <textarea class="scene-separator-synopsis" placeholder="Ajouter un résumé..." onblur="saveSceneSynopsis(${act.id}, ${chapter.id}, ${scene.id}, this)" onkeydown="handleSynopsisKeydown(event, this)" rows="1" oninput="autoResizeSynopsis(this)">${scene.synopsis || ''}</textarea>
                    </div>
                </div>
                <div class="editor-textarea" contenteditable="true" spellcheck="true"
                     data-scene-id="${scene.id}"
                     data-chapter-id="${chapter.id}"
                     data-act-id="${act.id}"
                     onfocus="setActiveScene(${act.id}, ${chapter.id}, ${scene.id})"
                     oninput="updateChapterSceneContent(${act.id}, ${chapter.id}, ${scene.id})">${scene.content || ''}</div>
            </div>`;
    });

    editorView.innerHTML = `
        <div class="editor-header">
            <div class="editor-breadcrumb">${act.title} > ${chapter.title}</div>
            <div style="display: flex; align-items: center; gap: 1rem;">
                <div class="editor-title" id="chapterEditorTitle" style="flex: 1;">${chapter.title} - Toutes les scènes</div>
                <button class="btn btn-small" onclick="toggleFocusMode()" title="Mode Focus (F11)" style="white-space: nowrap;">
                    <i data-lucide="maximize" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Focus
                </button>
            </div>
            <div class="editor-meta">
                <span>${totalWords} mots au total</span>
                <span>${chapter.scenes.length} scène${chapter.scenes.length > 1 ? 's' : ''}</span>
                <span>Dernière modification : ${new Date(chapter.updatedAt || Date.now()).toLocaleDateString('fr-FR')}</span>
            </div>
        </div>

        <button class="toolbar-mobile-toggle" onclick="toggleEditorToolbar()">
            <span id="toolbarToggleText"><i data-lucide="pen-line" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Afficher les outils</span>
        </button>
        
        <div class="editor-toolbar" id="editorToolbar">
            ${getEditorToolbarHTML()}
        </div>

        <!-- Indicateur de position vertical -->
        <div class="chapter-progress-indicator" id="chapterProgressIndicator">
            ${chapter.scenes.map((scene, index) => {
        const wordCount = sceneWordCounts[index];
        const heightPercent = totalWords > 0 ? (wordCount / totalWords) * 100 : (100 / chapter.scenes.length);
        return `<div class="progress-scene-segment"
                            data-scene-id="${scene.id}"
                            data-scene-index="${index}"
                            style="height: ${heightPercent}%"
                            title="${scene.title} (${wordCount} mots)"
                            onclick="scrollToChapterScene(${index})"></div>`;
    }).join('')}
            <div class="progress-current-indicator" id="progressCurrentIndicator"></div>
        </div>

        <div class="editor-content" id="chapterEditorContent">
            ${scenesHTML}
        </div>`;

    if (typeof lucide !== 'undefined') lucide.createIcons();
    if (typeof initializeColorPickers === 'function') initializeColorPickers();

    // Initialiser le tracking de scroll
    setTimeout(() => {
        initChapterScrollTracking(act.id, chapter.id);
        // Auto-resize des synopsis existants
        document.querySelectorAll('.scene-separator-synopsis').forEach(autoResizeSynopsis);
    }, 100);

    // Initialize scene navigation toolbar
    setTimeout(() => {
        if (typeof initSceneNavigation === 'function') initSceneNavigation();
        if (typeof updateLiveTensionMeter === 'function' && chapter.scenes.length > 0) {
            updateLiveTensionMeter(chapter.scenes[0].content || '', { actId: act.id, chapterId: chapter.id, sceneId: chapter.scenes[0].id });
        }
    }, 200);
}

/**
 * [MVVM : View]
 * Synchronise la Vue vers le Modèle et rafraîchit les indicateurs.
 */
function updateSceneContent() {
    const editor = document.querySelector('.editor-textarea');
    if (!editor) return;

    const act = project.acts.find(a => a.id === currentActId);
    const chapter = act?.chapters.find(c => c.id === currentChapterId);
    const scene = chapter?.scenes.find(s => s.id === currentSceneId);
    if (!scene) return;

    scene.content = editor.innerHTML;
    const wordCount = typeof getWordCount === 'function' ? getWordCount(editor.innerHTML) : 0;
    scene.wordCount = wordCount;

    // Mise à jour de la version active (si applicable)
    if (typeof updateSceneContentWithVersion === 'function') updateSceneContentWithVersion(editor.innerHTML);

    const countEl = document.getElementById('sceneWordCount');
    if (countEl) countEl.textContent = `${wordCount} mots`;

    if (typeof saveProject === 'function') saveProject();
    if (typeof updateStats === 'function') updateStats();
    if (typeof renderActsList === 'function') renderActsList();
    if (typeof trackWritingSession === 'function') trackWritingSession();

    if (typeof focusModeActive !== 'undefined' && focusModeActive && typeof updateWritingProgress === 'function') {
        updateWritingProgress();
    }

    if (typeof autoDetectLinksDebounced === 'function') autoDetectLinksDebounced();
    if (typeof updateLiveTensionMeter === 'function') updateLiveTensionMeter(editor.innerHTML, { actId: currentActId, chapterId: currentChapterId, sceneId: currentSceneId });
}

/**
 * [MVVM : View]
 * Met à jour le contenu d'une scène dans le mode chapitre.
 */
function updateChapterSceneContent(actId, chapterId, sceneId) {
    const editor = document.querySelector(`.editor-textarea[data-scene-id="${sceneId}"]`);
    if (!editor) return;

    const act = project.acts.find(a => a.id === actId);
    const chapter = act?.chapters.find(c => c.id === chapterId);
    const scene = chapter?.scenes.find(s => s.id === sceneId);
    if (!scene) return;

    scene.content = editor.innerHTML;
    const wordCount = typeof getWordCount === 'function' ? getWordCount(editor.innerHTML) : 0;
    scene.wordCount = wordCount;

    // Mise à jour du compteur de mots de la scène
    const sceneBlock = document.querySelector(`.chapter-scene-block[data-scene-id="${sceneId}"]`);
    if (sceneBlock) {
        const metaSpan = sceneBlock.querySelector('.scene-separator-meta span');
        if (metaSpan) metaSpan.textContent = `${wordCount} mots`;
    }

    if (typeof saveProject === 'function') saveProject();
    if (typeof updateStats === 'function') updateStats();
    if (typeof renderActsList === 'function') renderActsList();
    if (typeof trackWritingSession === 'function') trackWritingSession();

    // Recalculer les proportions de l'indicateur
    updateChapterProgressIndicator(chapter);

    if (typeof updateLiveTensionMeter === 'function') {
        updateLiveTensionMeter(editor.innerHTML, { actId, chapterId, sceneId });
    }

    if (typeof autoDetectLinksDebounced === 'function') autoDetectLinksDebounced();
}

/**
 * [MVVM : View]
 * Met à jour les proportions de l'indicateur de progression du chapitre.
 */
function updateChapterProgressIndicator(chapter) {
    let totalWords = 0;
    const wordCounts = [];

    chapter.scenes.forEach(scene => {
        const wc = typeof getWordCount === 'function' ? getWordCount(scene.content) : (scene.wordCount || 0);
        wordCounts.push(wc);
        totalWords += wc;
    });

    chapter.scenes.forEach((scene, index) => {
        const segment = document.querySelector(`.progress-scene-segment[data-scene-index="${index}"]`);
        if (segment) {
            const heightPercent = totalWords > 0 ? (wordCounts[index] / totalWords) * 100 : (100 / chapter.scenes.length);
            segment.style.height = `${heightPercent}%`;
            segment.title = `${scene.title} (${wordCounts[index]} mots)`;
        }
    });
}

/**
 * [MVVM : View]
 * Initialise le tracking de scroll pour l'éditeur de chapitre.
 */
function initChapterScrollTracking(actId, chapterId) {
    // Nettoyer le handler précédent s'il existe
    cleanupChapterScrollTracking();

    const editorContent = document.getElementById('chapterEditorContent');
    const indicator = document.getElementById('progressCurrentIndicator');
    const title = document.getElementById('chapterEditorTitle');

    if (!editorContent || !indicator) return;

    const act = project.acts.find(a => a.id === actId);
    const chapter = act?.chapters.find(c => c.id === chapterId);
    if (!chapter) return;

    let currentSceneIndex = 0;

    function updateScrollPosition() {
        const sceneBlocks = Array.from(document.querySelectorAll('.chapter-scene-block'));
        if (sceneBlocks.length === 0) return;

        // Trouver quelle scène est actuellement visible
        const viewportMiddle = window.innerHeight / 2;
        let closestScene = 0;
        let closestDistance = Infinity;

        sceneBlocks.forEach((block, index) => {
            const rect = block.getBoundingClientRect();
            const blockMiddle = rect.top + rect.height / 2;
            const distance = Math.abs(blockMiddle - viewportMiddle);

            if (distance < closestDistance) {
                closestDistance = distance;
                closestScene = index;
            }
        });

        // Mettre à jour le titre si la scène a changé
        if (closestScene !== currentSceneIndex) {
            currentSceneIndex = closestScene;
            const scene = chapter.scenes[closestScene];
            if (scene) {
                if (title) title.textContent = scene.title;
                // Mettre à jour la scène active dans tout l'application (Sidebar, Links, etc.)
                setActiveScene(actId, chapterId, scene.id);
            }

            // Update tension meter with current visible scene text from DOM
            if (typeof updateLiveTensionMeter === 'function' && scene) {
                const sceneEditor = document.querySelector(`.editor-textarea[data-scene-id="${scene.id}"]`);
                const textToAnalyze = sceneEditor ? sceneEditor.innerHTML : (scene.content || '');
                updateLiveTensionMeter(textToAnalyze, { actId, chapterId, sceneId: scene.id });
            }
        }

        // Calculer la position de l'indicateur
        const progressIndicator = document.getElementById('chapterProgressIndicator');
        if (!progressIndicator) return;

        const segments = Array.from(progressIndicator.querySelectorAll('.progress-scene-segment'));
        let topOffset = 0;

        // Calculer l'offset jusqu'à la scène actuelle
        for (let i = 0; i < currentSceneIndex; i++) {
            const seg = segments[i];
            if (seg) topOffset += seg.offsetHeight;
        }

        // Ajouter un pourcentage dans la scène actuelle basé sur le scroll
        const currentBlock = sceneBlocks[currentSceneIndex];
        if (currentBlock) {
            const blockRect = currentBlock.getBoundingClientRect();
            const viewportTop = 0;
            const relativeScroll = Math.max(0, Math.min(1, (viewportTop - blockRect.top) / blockRect.height));

            const currentSegment = segments[currentSceneIndex];
            if (currentSegment) {
                topOffset += currentSegment.offsetHeight * relativeScroll;
            }
        }

        indicator.style.top = `${topOffset}px`;

        // Mettre en surbrillance le segment actif
        segments.forEach((seg, i) => {
            if (i === currentSceneIndex) {
                seg.classList.add('active');
            } else {
                seg.classList.remove('active');
            }
        });
    }

    // Stocker le handler pour pouvoir le nettoyer plus tard
    chapterScrollTrackingHandler = updateScrollPosition;

    // Forcer un premier appel immédiat pour synchroniser la scène 1 (index 0)
    currentSceneIndex = -1;
    updateScrollPosition();

    // Écouter le scroll sur le conteneur principal
    const container = document.querySelector('.editor-container');
    if (container) {
        container.addEventListener('scroll', chapterScrollTrackingHandler);
    } else {
        // Fallback
        window.addEventListener('scroll', chapterScrollTrackingHandler);
    }
}

/**
 * [MVVM : View]
 * Nettoie le tracking de scroll pour éviter les fuites mémoire.
 */
function cleanupChapterScrollTracking() {
    if (chapterScrollTrackingHandler) {
        const container = document.querySelector('.editor-container');
        if (container) {
            container.removeEventListener('scroll', chapterScrollTrackingHandler);
        }
        window.removeEventListener('scroll', chapterScrollTrackingHandler);
        chapterScrollTrackingHandler = null;
    }
}

/**
 * [MVVM : View]
 * Place le curseur au début d'un élément contenteditable.
 */
function setCursorAtBeginning(element) {
    if (!element) return;
    element.focus();

    // Pour contenteditable, on utilise Selection et Range
    if (typeof window.getSelection !== "undefined" && typeof document.createRange !== "undefined") {
        const range = document.createRange();
        range.selectNodeContents(element);
        range.collapse(true); // true pour le début
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
    }
}

/**
 * [MVVM : View]
 * Fait défiler jusqu'à une scène spécifique dans le mode chapitre.
 */
function scrollToChapterScene(sceneIndex) {
    const sceneBlock = document.querySelector(`.chapter-scene-block[data-scene-index="${sceneIndex}"]`);
    if (sceneBlock) {
        sceneBlock.scrollIntoView({ behavior: 'smooth', block: 'start' });

        // Placer le curseur au début de l'éditeur de cette scène
        const editor = sceneBlock.querySelector('.editor-textarea');
        if (editor) {
            // Un petit délai pour laisser l'animation de scroll commencer/finir si nécessaire
            // mais l'appel à focus() peut être immédiat
            setCursorAtBeginning(editor);
        }
    }
}

/**
 * [MVVM : View]
 * Met à jour le contenu d'une scène dans le mode acte.
 */
function updateActSceneContent(actId, chapterId, sceneId) {
    const editor = document.querySelector(`.editor-textarea[data-scene-id="${sceneId}"][data-chapter-id="${chapterId}"]`);
    if (!editor) return;

    const act = project.acts.find(a => a.id === actId);
    const chapter = act?.chapters.find(c => c.id === chapterId);
    const scene = chapter?.scenes.find(s => s.id === sceneId);
    if (!scene) return;

    scene.content = editor.innerHTML;
    const wordCount = typeof getWordCount === 'function' ? getWordCount(editor.innerHTML) : 0;
    scene.wordCount = wordCount;

    // Mise à jour du compteur de mots de la scène
    const sceneBlock = document.querySelector(`.act-scene-block[data-scene-id="${sceneId}"][data-chapter-id="${chapterId}"]`);
    if (sceneBlock) {
        const metaSpan = sceneBlock.querySelector('.scene-separator-meta span');
        if (metaSpan) metaSpan.textContent = `${wordCount} mots`;
    }

    if (typeof saveProject === 'function') saveProject();
    if (typeof updateStats === 'function') updateStats();
    if (typeof renderActsList === 'function') renderActsList();
    if (typeof trackWritingSession === 'function') trackWritingSession();

    // Recalculer les proportions de l'indicateur
    updateActProgressIndicator(act);

    if (typeof updateLiveTensionMeter === 'function') {
        updateLiveTensionMeter(editor.innerHTML);
    }

    if (typeof autoDetectLinksDebounced === 'function') autoDetectLinksDebounced();
}

/**
 * [MVVM : View]
 * Met à jour les proportions de l'indicateur de progression de l'acte.
 */
function updateActProgressIndicator(act) {
    let totalWords = 0;
    const allScenes = [];

    act.chapters.forEach(chapter => {
        chapter.scenes.forEach(scene => {
            const wc = typeof getWordCount === 'function' ? getWordCount(scene.content) : (scene.wordCount || 0);
            allScenes.push({ scene, wordCount: wc, chapterTitle: chapter.title });
            totalWords += wc;
        });
    });

    allScenes.forEach((sceneData, index) => {
        const segment = document.querySelector(`.progress-scene-segment[data-scene-index="${index}"]`);
        if (segment) {
            const heightPercent = totalWords > 0 ? (sceneData.wordCount / totalWords) * 100 : (100 / allScenes.length);
            segment.style.height = `${heightPercent}%`;
            segment.title = `${sceneData.chapterTitle} - ${sceneData.scene.title} (${sceneData.wordCount} mots)`;
        }
    });
}

/**
 * [MVVM : View]
 * Initialise le tracking de scroll pour l'éditeur d'acte.
 */
function initActScrollTracking(actId, allScenes) {
    // Nettoyer le handler précédent s'il existe
    cleanupChapterScrollTracking();

    const editorContent = document.getElementById('actEditorContent');
    const indicator = document.getElementById('progressCurrentIndicator');
    const title = document.getElementById('actEditorTitle');

    if (!editorContent || !indicator) return;

    const act = project.acts.find(a => a.id === actId);
    if (!act) return;

    let currentSceneIndex = 0;

    function updateScrollPosition() {
        const sceneBlocks = Array.from(document.querySelectorAll('.act-scene-block'));
        if (sceneBlocks.length === 0) return;

        // Trouver quelle scène est actuellement visible
        const viewportMiddle = window.innerHeight / 2;
        let closestScene = 0;
        let closestDistance = Infinity;

        sceneBlocks.forEach((block, index) => {
            const rect = block.getBoundingClientRect();
            const blockMiddle = rect.top + rect.height / 2;
            const distance = Math.abs(blockMiddle - viewportMiddle);

            if (distance < closestDistance) {
                closestDistance = distance;
                closestScene = index;
            }
        });

        // Mettre à jour le titre si la scène a changé
        if (closestScene !== currentSceneIndex) {
            currentSceneIndex = closestScene;
            const sceneData = allScenes[closestScene];
            if (sceneData) {
                if (title) title.textContent = `${sceneData.chapterTitle} - ${sceneData.scene.title}`;
                // Mettre à jour la scène active dans tout l'application (Sidebar, Links, etc.)
                setActiveScene(actId, sceneData.chapterId, sceneData.scene.id);
            }

            // Update tension meter with current visible scene text from DOM for maximum accuracy
            if (typeof updateLiveTensionMeter === 'function' && sceneData) {
                const sceneEditor = document.querySelector(`.editor-textarea[data-scene-id="${sceneData.scene.id}"]`);
                const textToAnalyze = sceneEditor ? sceneEditor.innerHTML : (sceneData.scene.content || '');
                updateLiveTensionMeter(textToAnalyze);
            }
        }

        // Calculer la position de l'indicateur
        const progressIndicator = document.getElementById('actProgressIndicator');
        if (!progressIndicator) return;

        const segments = Array.from(progressIndicator.querySelectorAll('.progress-scene-segment'));
        let topOffset = 0;

        // Calculer l'offset jusqu'à la scène actuelle
        for (let i = 0; i < currentSceneIndex; i++) {
            const seg = segments[i];
            if (seg) topOffset += seg.offsetHeight;
        }

        // Ajouter un pourcentage dans la scène actuelle basé sur le scroll
        const currentBlock = sceneBlocks[currentSceneIndex];
        if (currentBlock) {
            const blockRect = currentBlock.getBoundingClientRect();
            const viewportTop = 0;
            const relativeScroll = Math.max(0, Math.min(1, (viewportTop - blockRect.top) / blockRect.height));

            const currentSegment = segments[currentSceneIndex];
            if (currentSegment) {
                topOffset += currentSegment.offsetHeight * relativeScroll;
            }
        }

        indicator.style.top = `${topOffset}px`;

        // Mettre en surbrillance le segment actif
        segments.forEach((seg, i) => {
            if (i === currentSceneIndex) {
                seg.classList.add('active');
            } else {
                seg.classList.remove('active');
            }
        });
    }

    // Stocker le handler pour pouvoir le nettoyer plus tard
    chapterScrollTrackingHandler = updateScrollPosition;

    // Forcer un premier appel immédiat pour synchroniser la scène 1 (index 0)
    currentSceneIndex = -1;
    updateScrollPosition();

    // Écouter le scroll sur le conteneur principal
    const container = document.querySelector('.editor-container');
    if (container) {
        container.addEventListener('scroll', chapterScrollTrackingHandler);
    } else {
        // Fallback
        window.addEventListener('scroll', chapterScrollTrackingHandler);
    }
}

/**
 * [MVVM : View]
 * Sauvegarde le synopsis d'une scène depuis un textarea.
 */
function saveSceneSynopsis(actId, chapterId, sceneId, textarea) {
    const act = project.acts.find(a => a.id === actId);
    const chapter = act?.chapters.find(c => c.id === chapterId);
    const scene = chapter?.scenes.find(s => s.id === sceneId);
    if (!scene) return;

    const newSynopsis = textarea.value.trim();
    scene.synopsis = newSynopsis;

    // Sauvegarder le projet
    if (typeof saveProject === 'function') saveProject();
    if (typeof renderActsList === 'function') renderActsList();
}

/**
 * [MVVM : View]
 * Gère les raccourcis clavier dans le textarea de synopsis.
 */
function handleSynopsisKeydown(event, textarea) {
    if (event.key === 'Escape') {
        textarea.blur();
    }
}

/**
 * [MVVM : View]
 * Auto-redimensionne le textarea de synopsis selon son contenu.
 */
function autoResizeSynopsis(textarea) {
    textarea.style.height = 'auto';
    textarea.style.height = textarea.scrollHeight + 'px';
}

/**
 * [MVVM : View]
 * Fait défiler jusqu'à une scène spécifique dans le mode acte.
 */
function scrollToActScene(sceneIndex) {
    const sceneBlock = document.querySelector(`.act-scene-block[data-scene-index="${sceneIndex}"]`);
    if (sceneBlock) {
        sceneBlock.scrollIntoView({ behavior: 'smooth', block: 'start' });

        // Placer le curseur au début de l'éditeur de cette scène
        const editor = sceneBlock.querySelector('.editor-textarea');
        if (editor) {
            setCursorAtBeginning(editor);
        }
    }
}

// --- WELCOME SCREENS ---

function renderWelcomeEditor() {
    const container = document.getElementById('editorView');
    if (!container) return;
    container.innerHTML = `
        <div class="empty-state">
            <div class="empty-state-icon"><i data-lucide="pencil-line" style="width:48px;height:48px;stroke-width:1.5;"></i></div>
            <div class="empty-state-title">Sélectionnez une scène</div>
            <div class="empty-state-text">Choisissez une scène dans la barre latérale pour commencer à écrire.</div>
        </div>`;
}

function renderCharacterWelcome() {
    const container = document.getElementById('editorView');
    if (!container) return;
    container.innerHTML = `
        <div class="empty-state">
            <div class="empty-state-icon"><i data-lucide="users" style="width:48px;height:48px;stroke-width:1.5;"></i></div>
            <div class="empty-state-title">Personnages</div>
            <div class="empty-state-text">Sélectionnez un personnage pour voir sa fiche, ou créez-en un nouveau.</div>
        </div>`;
    if (typeof lucide !== 'undefined') lucide.createIcons();
}

function renderWorldWelcome() {
    const container = document.getElementById('editorView');
    if (!container) return;
    container.innerHTML = `
        <div class="empty-state">
            <div class="empty-state-icon"><i data-lucide="globe" style="width:48px;height:48px;stroke-width:1.5;"></i></div>
            <div class="empty-state-title">Univers</div>
            <div class="empty-state-text">Sélectionnez un lieu ou un élément dans la liste pour voir ses détails.</div>
        </div>`;
    if (typeof lucide !== 'undefined') lucide.createIcons();
}

function renderNotesWelcome() {
    const container = document.getElementById('editorView');
    if (!container) return;
    container.innerHTML = `
        <div class="empty-state">
            <div class="empty-state-icon"><i data-lucide="sticky-note" style="width:48px;height:48px;stroke-width:1.5;"></i></div>
            <div class="empty-state-title">Notes</div>
            <div class="empty-state-text">Sélectionnez une note dans la liste pour la consulter.</div>
        </div>`;
    if (typeof lucide !== 'undefined') lucide.createIcons();
}

function renderCodexWelcome() {
    const container = document.getElementById('editorView');
    if (!container) return;
    container.innerHTML = `
        <div class="empty-state">
            <div class="empty-state-icon"><i data-lucide="book-open" style="width:48px;height:48px;stroke-width:1.5;"></i></div>
            <div class="empty-state-title">Codex</div>
            <div class="empty-state-text">Sélectionnez une entrée dans la liste pour la consulter.</div>
        </div>`;
    if (typeof lucide !== 'undefined') lucide.createIcons();
}

// ========== js-refactor/structure/structure.view.js ==========
/**
 * [MVVM : Structure View]
 * Gestionnaire d'affichage de l'arborescence (Actes/Chapitres/Scènes).
 */

// --- ACTIONS UI ---

function addAct() {
    const titleInput = document.getElementById('actTitleInput');
    const result = addActViewModel((titleInput.value || '').trim());

    if (result.success) {
        processStructureSideEffects(result.sideEffects);
        titleInput.value = '';
        closeModal('addActModal');
        renderActsList();
        if (result.message) showNotification(result.message, 'success');
    } else {
        showNotification(result.message || 'Erreur lors de l\'ajout', 'error');
    }
}

function deleteAct(actId) {
    if (!confirm('Êtes-vous sûr de vouloir supprimer cet acte et tout son contenu ?')) return;

    const result = deleteActViewModel(actId, typeof currentActId !== 'undefined' ? currentActId : null);

    if (result.success) {
        processStructureSideEffects(result.sideEffects);
        renderActsList();
        if (result.message) showNotification(result.message, 'success');
    } else {
        showNotification(result.message || 'Erreur lors de la suppression', 'error');
    }
}

function addChapter() {
    const titleInput = document.getElementById('chapterTitleInput');
    const result = addChapterViewModel((titleInput.value || '').trim(), typeof activeActId !== 'undefined' ? activeActId : null);

    if (result.success) {
        processStructureSideEffects(result.sideEffects);
        titleInput.value = '';
        closeModal('addChapterModal');
        renderActsList();
        if (result.message) showNotification(result.message, 'success');
    } else {
        showNotification(result.message || 'Erreur lors de l\'ajout', 'error');
    }
}

function deleteChapter(actId, chapterId) {
    if (!confirm('Êtes-vous sûr de vouloir supprimer ce chapitre et ses scènes ?')) return;

    const result = deleteChapterViewModel(actId, chapterId, typeof currentChapterId !== 'undefined' ? currentChapterId : null);

    if (result.success) {
        processStructureSideEffects(result.sideEffects);
        renderActsList();
        if (result.message) showNotification(result.message, 'success');
    } else {
        showNotification(result.message || 'Erreur lors de la suppression', 'error');
    }
}

function addScene() {
    const titleInput = document.getElementById('sceneTitleInput');
    const result = addSceneViewModel(
        (titleInput.value || '').trim(),
        typeof activeActId !== 'undefined' ? activeActId : null,
        typeof activeChapterId !== 'undefined' ? activeChapterId : null
    );

    if (result.success) {
        processStructureSideEffects(result.sideEffects);
        titleInput.value = '';
        closeModal('addSceneModal');
        renderActsList();
        if (result.message) showNotification(result.message, 'success');
    } else {
        showNotification(result.message || 'Erreur lors de l\'ajout', 'error');
    }
}

function deleteScene(actId, chapterId, sceneId) {
    if (!confirm('Êtes-vous sûr de vouloir supprimer cette scène ?')) return;

    const result = deleteSceneViewModel(actId, chapterId, sceneId, typeof currentSceneId !== 'undefined' ? currentSceneId : null);

    if (result.success) {
        processStructureSideEffects(result.sideEffects);
        renderActsList();
        if (result.message) showNotification(result.message, 'success');
    } else {
        showNotification(result.message || 'Erreur lors de la suppression', 'error');
    }
}

function setSceneStatus(actId, chapterId, sceneId, status) {
    const result = setSceneStatusViewModel(actId, chapterId, sceneId, status);

    if (result.success) {
        processStructureSideEffects(result.sideEffects);
        closeStatusMenu();
        renderActsList();
        updateProgressBar();
    }
}

// --- ÉDITION DIRECTE (RENOMMAGE) ---

function startEditingAct(actId, element) {
    const originalText = element.textContent.trim();
    const input = document.createElement('input');
    input.type = 'text';
    input.className = 'editing-input';
    input.value = originalText;

    element.textContent = '';
    element.appendChild(input);
    input.focus();
    input.select();

    const finish = () => {
        const newTitle = input.value.trim();
        if (newTitle && newTitle !== originalText) {
            const result = updateActViewModel(actId, { title: newTitle });
            if (result.success) processStructureSideEffects(result.sideEffects);
        }
        renderActsList();
    };

    input.onblur = finish;
    input.onkeydown = (e) => { e.key === 'Enter' && finish(); e.key === 'Escape' && renderActsList(); };
}

function startEditingChapter(actId, chapterId, element) {
    const originalText = element.textContent.trim();
    const input = document.createElement('input');
    input.type = 'text';
    input.className = 'editing-input';
    input.value = originalText;

    element.textContent = '';
    element.appendChild(input);
    input.focus();
    input.select();

    const finish = () => {
        const newTitle = input.value.trim();
        if (newTitle && newTitle !== originalText) {
            const result = updateChapterViewModel(actId, chapterId, { title: newTitle });
            if (result.success) {
                processStructureSideEffects(result.sideEffects);
                // Update editor if this chapter is currently open
                if (typeof currentChapterId !== 'undefined' && currentChapterId === chapterId) {
                    const breadcrumb = document.querySelector('.editor-breadcrumb');
                    if (breadcrumb) breadcrumb.textContent = `${result.updatedActTitle} > ${newTitle}`;
                }
            }
        }
        renderActsList();
    };

    input.onblur = finish;
    input.onkeydown = (e) => { e.key === 'Enter' && finish(); e.key === 'Escape' && renderActsList(); };
}

function startEditingScene(actId, chapterId, sceneId, element) {
    const originalText = element.textContent.trim();
    const input = document.createElement('input');
    input.type = 'text';
    input.className = 'editing-input';
    input.value = originalText;

    element.textContent = '';
    element.appendChild(input);
    input.focus();
    input.select();

    const finish = () => {
        const newTitle = input.value.trim();
        if (newTitle && newTitle !== originalText) {
            const result = updateSceneViewModel(actId, chapterId, sceneId, { title: newTitle });
            if (result.success) {
                processStructureSideEffects(result.sideEffects);
                // Update editor title if open
                if (typeof currentSceneId !== 'undefined' && currentSceneId === sceneId) {
                    const editorTitle = document.querySelector('.editor-title');
                    if (editorTitle) editorTitle.textContent = newTitle;
                }
            }
        }
        renderActsList();
    };

    input.onblur = finish;
    input.onkeydown = (e) => { e.key === 'Enter' && finish(); e.key === 'Escape' && renderActsList(); };
}

// --- RENDU (ARBORESCENCE) ---

function renderActsList() {
    const container = document.getElementById('chaptersList');
    if (!container) return;

    // Sauvegarder la position du scroll avant le rendu
    const scrollTop = container.scrollTop;

    const vm = getStructureViewModel();
    if (!vm.acts || vm.acts.length === 0) {
        container.innerHTML = `
            <div style="padding: 2rem; text-align: center; color: var(--text-muted);">
                <div style="margin-bottom: 1rem;">Aucun chapitre</div>
                <button class="btn btn-primary" onclick="openAddChapterModal()">+ Créer un chapitre</button>
            </div>`;
        if (typeof updateStats === 'function') updateStats();
        return;
    }

    let html = '<div style="padding: 0 0.5rem;">';

    vm.acts.forEach((act, actIndex) => {
        const actStats = typeof getActStats === 'function' ? getActStats(act) : { totalWords: 0 };
        const actExpanded = typeof expandedActs !== 'undefined' && expandedActs.has(act.id);

        html += `<div class="act-group" id="act-${act.id}" data-act-id="${act.id}">
            <div class="act-header ${typeof currentActId !== 'undefined' && currentActId === act.id ? 'active' : ''}" data-act-id="${act.id}">
                <span class="drag-handle" draggable="true" onclick="event.stopPropagation()"><i data-lucide="grip-vertical" style="width:12px;height:12px;vertical-align:middle;"></i></span>
                <span class="act-icon ${actExpanded ? 'expanded' : ''}" onclick="toggleAct(${act.id}); event.stopPropagation();" style="cursor: pointer;"><i data-lucide="${actExpanded ? 'chevron-down' : 'chevron-right'}" style="width:14px;height:14px;vertical-align:middle;"></i></span>
                <span class="auto-number">${actIndex + 1}.</span>
                <span class="act-title" ondblclick="event.stopPropagation(); startEditingAct(${act.id}, this)" onclick="${act.chapters.length > 0 ? `openAct(${act.id})` : ''}">${act.title}</span>
                <span class="edit-hint"><i data-lucide="pencil" style="width:10px;height:10px;"></i></span>
                <span class="word-count-badge" title="${actStats.totalWords.toLocaleString()} mots">${typeof formatWordCount === 'function' ? formatWordCount(actStats.totalWords) : actStats.totalWords}</span>
                <button class="btn btn-icon btn-small delete-btn" onclick="event.stopPropagation(); deleteAct(${act.id})"><i data-lucide="x" style="width:12px;height:12px;"></i></button>
            </div>
            <div class="act-chapters ${actExpanded ? 'visible' : ''}">`;

        act.chapters.forEach((chapter, chapterIndex) => {
            const chStats = typeof getChapterStats === 'function' ? getChapterStats(chapter) : { totalWords: 0, progressPercent: 0 };
            const chStatus = chStats.progressPercent === 100 ? 'complete' : chStats.progressPercent > 0 ? 'progress' : 'draft';
            const chExpanded = typeof expandedChapters !== 'undefined' && expandedChapters.has(chapter.id);
            const chNumber = `${actIndex + 1}.${chapterIndex + 1}`;

            html += `<div class="chapter-group" id="chapter-${chapter.id}" data-chapter-id="${chapter.id}" data-act-id="${act.id}">
                <div class="chapter-header ${typeof currentChapterId !== 'undefined' && currentChapterId === chapter.id ? 'active' : ''}" data-chapter-id="${chapter.id}" data-act-id="${act.id}">
                    <span class="drag-handle" draggable="true" onclick="event.stopPropagation()"><i data-lucide="grip-vertical" style="width:12px;height:12px;vertical-align:middle;"></i></span>
                    <span class="chapter-icon ${chExpanded ? 'expanded' : ''}" onclick="toggleChapter(${act.id}, ${chapter.id}); event.stopPropagation();" style="cursor: pointer;"><i data-lucide="${chExpanded ? 'chevron-down' : 'chevron-right'}" style="width:14px;height:14px;vertical-align:middle;"></i></span>
                    <span class="auto-number">${chNumber}</span>
                    <span class="chapter-title" ondblclick="event.stopPropagation(); startEditingChapter(${act.id}, ${chapter.id}, this)" onclick="${chapter.scenes.length > 0 ? `openChapter(${act.id}, ${chapter.id})` : ''}">${chapter.title}</span>
                    <span class="edit-hint"><i data-lucide="pencil" style="width:10px;height:10px;"></i></span>
                    <span class="word-count-badge" title="${chStats.totalWords.toLocaleString()} mots">${typeof formatWordCount === 'function' ? formatWordCount(chStats.totalWords) : chStats.totalWords}</span>
                    <span class="status-badge status-${chStatus}" title="${chStats.progressPercent}%"></span>
                    <span class="chapter-count" title="Nombre de scènes" style="cursor: default;">${chapter.scenes.length}</span>
                    <button class="btn btn-icon btn-small delete-btn" onclick="event.stopPropagation(); deleteChapter(${act.id}, ${chapter.id})"><i data-lucide="x" style="width:12px;height:12px;"></i></button>
                </div>
                <div class="scenes-list ${chExpanded ? 'visible' : ''}">`;

            chapter.scenes.forEach((scene, sceneIndex) => {
                const sStatus = scene.status || 'draft';
                const sWords = scene.wordCount || 0;
                const synopsis = scene.synopsis ? (scene.synopsis.substring(0, 100) + (scene.synopsis.length > 100 ? '...' : '')) : '';
                const tooltip = scene.synopsis ? scene.synopsis.replace(/"/g, '&quot;').replace(/'/g, '&#39;') : '';
                const sNumber = `${actIndex + 1}.${chapterIndex + 1}.${sceneIndex + 1}`;
                const isActive = typeof currentSceneId !== 'undefined' && currentSceneId === scene.id;

                html += `<div class="scene-item draggable ${isActive ? 'active' : ''}" draggable="true" data-scene-id="${scene.id}" data-chapter-id="${chapter.id}" data-act-id="${act.id}" onclick="openScene(${act.id}, ${chapter.id}, ${scene.id})" ${tooltip ? `title="${tooltip}"` : ''}>
                    <div style="display: flex; align-items: center; gap: 0.4rem; flex: 1; min-width: 0;">
                        <span class="drag-handle"><i data-lucide="grip-vertical" style="width:12px;height:12px;vertical-align:middle;"></i></span>
                        <span class="auto-number">${sNumber}</span>
                        <div style="flex: 1; min-width: 0; overflow: hidden;">
                            <span ondblclick="event.stopPropagation(); startEditingScene(${act.id}, ${chapter.id}, ${scene.id}, this)" style="display: block;">${scene.title}</span>
                            ${synopsis ? `<span class="scene-synopsis">${synopsis}</span>` : ''}
                        </div>
                        <span class="edit-hint"><i data-lucide="pencil" style="width:10px;height:10px;"></i></span>
                    </div>
                    <span class="word-count-badge" title="${sWords.toLocaleString()} mots">${typeof formatWordCount === 'function' ? formatWordCount(sWords) : sWords}</span>
                    <span class="status-badge status-${sStatus}" onclick="event.stopPropagation(); toggleSceneStatus(${act.id}, ${chapter.id}, ${scene.id}, event)" style="cursor: pointer;" title="Cliquez pour changer le statut"></span>
                    <button class="btn btn-icon btn-small delete-btn" onclick="event.stopPropagation(); deleteScene(${act.id}, ${chapter.id}, ${scene.id})"><i data-lucide="x" style="width:12px;height:12px;"></i></button>
                </div>`;
            });

            html += `<div class="scene-item" onclick="openAddSceneModal(${act.id}, ${chapter.id})" style="opacity: 0.6; font-style: italic;">+ Ajouter une scène</div>
                </div></div>`;
        });

        html += `<div class="scene-item" onclick="openAddChapterModal(${act.id})" style="opacity: 0.6; font-style: italic; margin-left: 1rem;">+ Ajouter un chapitre</div>
            </div></div>`;
    });

    html += '</div>';
    container.innerHTML = html;

    // Post-rendu
    if (typeof setupActDragAndDrop === 'function') setupActDragAndDrop();
    if (typeof setupChapterDragAndDrop === 'function') setupChapterDragAndDrop();
    if (typeof setupSceneDragAndDrop === 'function') setupSceneDragAndDrop();
    if (typeof updateStats === 'function') updateStats();
    if (typeof updateProgressBar === 'function') updateProgressBar();
    if (typeof applyStatusFilters === 'function') applyStatusFilters();
    if (typeof restoreTreeState === 'function') restoreTreeState();

    if (typeof lucide !== 'undefined') lucide.createIcons();

    // Restaurer la position du scroll
    container.scrollTop = scrollTop;
}

// --- ORCHESTRATION ---

function processStructureSideEffects(sideEffects) {
    if (!sideEffects) return;

    // 1. Repository
    if (sideEffects.repository) {
        const actions = Array.isArray(sideEffects.repository) ? sideEffects.repository : [sideEffects.repository];
        actions.forEach(action => executeRepositorySideEffect(action));
    }

    // 2. Expansion
    if (sideEffects.shouldExpand && typeof expandedActs !== 'undefined') expandedActs.add(sideEffects.shouldExpand);
    if (sideEffects.shouldExpandAct && typeof expandedActs !== 'undefined') expandedActs.add(sideEffects.shouldExpandAct);
    if (sideEffects.shouldExpandChapter && typeof expandedChapters !== 'undefined') expandedChapters.add(sideEffects.shouldExpandChapter);

    // 3. Navigation State
    if (sideEffects.shouldResetState) {
        if (typeof currentActId !== 'undefined') currentActId = null;
        if (typeof currentChapterId !== 'undefined') currentChapterId = null;
        if (typeof currentSceneId !== 'undefined') currentSceneId = null;
        if (typeof showEmptyState === 'function') showEmptyState();
    }

    // 4. Persistence
    if (sideEffects.shouldSave && typeof saveProject === 'function') saveProject();
    if (sideEffects.shouldOpenScene) {
        const { actId, chapterId, sceneId } = sideEffects.shouldOpenScene;
        if (typeof openScene === 'function') openScene(actId, chapterId, sceneId);
    }
}

function executeRepositorySideEffect(effect) {
    if (!effect) return;
    const { action, collection, id, data, updates, actId, chapterId } = effect;

    let repo;
    if (collection === 'acts') repo = ActRepository;
    else if (collection === 'chapters') repo = ChapterRepository;
    else if (collection === 'scenes') repo = SceneRepository;

    if (!repo) return;

    switch (action) {
        case 'ADD':
            if (collection === 'acts') repo.add(data);
            else if (collection === 'chapters') repo.add(actId, data);
            else if (collection === 'scenes') repo.add(actId, chapterId, data);
            break;
        case 'UPDATE':
            if (collection === 'acts') repo.update(id, updates);
            else if (collection === 'chapters') repo.update(actId, id, updates);
            else if (collection === 'scenes') repo.update(actId, chapterId, id, updates);
            break;
        case 'REMOVE':
            if (collection === 'acts') repo.remove(id);
            else if (collection === 'chapters') repo.remove(actId, id);
            else if (collection === 'scenes') repo.remove(actId, chapterId, id);
            break;
    }
}

// --- UTILITAIRES DE VUE ---

function toggleAct(actId) {
    if (typeof expandedActs === 'undefined') return;
    if (expandedActs.has(actId)) expandedActs.delete(actId);
    else expandedActs.add(actId);

    if (typeof saveTreeState === 'function') saveTreeState();
    renderActsList();
}

function toggleChapter(actId, chapterId) {
    if (typeof expandedChapters === 'undefined') return;
    if (expandedChapters.has(chapterId)) expandedChapters.delete(chapterId);
    else expandedChapters.add(chapterId);

    if (typeof saveTreeState === 'function') saveTreeState();
    renderActsList();
}

function expandAll() {
    const vm = getStructureViewModel();
    vm.acts.forEach(act => {
        if (typeof expandedActs !== 'undefined') expandedActs.add(act.id);
        act.chapters.forEach(ch => {
            if (typeof expandedChapters !== 'undefined') expandedChapters.add(ch.id);
        });
    });
    if (typeof saveTreeState === 'function') saveTreeState();
    renderActsList();
}

function collapseAll() {
    if (typeof expandedActs !== 'undefined') expandedActs.clear();
    if (typeof expandedChapters !== 'undefined') expandedChapters.clear();
    if (typeof saveTreeState === 'function') saveTreeState();
    renderActsList();
}

function openAddActModal() {
    const modal = document.getElementById('addActModal');
    if (modal) {
        modal.classList.add('active');
        const input = document.getElementById('actTitleInput');
        if (input) setTimeout(() => input.focus(), 100);
    }
}

function openAddChapterModal(actId) {
    if (actId) activeActId = actId;
    else {
        const vm = getStructureViewModel();
        if (vm.acts.length > 0) {
            activeActId = vm.acts[0].id;
        } else {
            activeActId = null; // Will be created in addChapter
        }
    }
    const modal = document.getElementById('addChapterModal');
    if (modal) {
        modal.classList.add('active');
        const input = document.getElementById('chapterTitleInput');
        if (input) setTimeout(() => input.focus(), 100);
    }
}

function openAddSceneModal(actId, chapterId) {
    if (actId) activeActId = actId;
    if (chapterId) activeChapterId = chapterId;
    const modal = document.getElementById('addSceneModal');
    if (modal) {
        modal.classList.add('active');
        const input = document.getElementById('sceneTitleInput');
        if (input) setTimeout(() => input.focus(), 100);
    }
}

function openAddSceneModalQuick() {
    if (typeof currentActId !== 'undefined' && typeof currentChapterId !== 'undefined' && currentActId && currentChapterId) {
        openAddSceneModal(currentActId, currentChapterId);
    } else {
        const vm = getStructureViewModel();
        if (vm.acts.length > 0 && vm.acts[0].chapters.length > 0) {
            openAddSceneModal(vm.acts[0].id, vm.acts[0].chapters[0].id);
        } else {
            showNotification('Créez d\'abord un chapitre', 'info');
        }
    }
}

// [MVVM : View]
// Applique visuellement les filtres de statut dans l'arborescence
function applyStatusFilters() {
    // Appliquer les filtres à toutes les scènes
    document.querySelectorAll('.scene-item[data-scene-id]').forEach(sceneEl => {
        const sceneId = parseInt(sceneEl.dataset.sceneId);
        const actId = parseInt(sceneEl.dataset.actId);
        const chapterId = parseInt(sceneEl.dataset.chapterId);

        const vm = getStructureViewModel();
        const act = vm.acts.find(a => a.id === actId);
        if (!act) return;
        const chapter = act.chapters.find(c => c.id === chapterId);
        if (!chapter) return;
        const scene = chapter.scenes.find(s => s.id === sceneId);
        if (!scene) return;

        const status = scene.status || 'draft';

        if (activeStatusFilters.includes(status)) {
            sceneEl.classList.remove('filtered-out');
        } else {
            sceneEl.classList.add('filtered-out');
        }
    });

    // Cacher les chapitres dont toutes les scènes sont filtrées (mais pas les chapitres vides)
    document.querySelectorAll('.chapter-group').forEach(chapterEl => {
        const allScenes = chapterEl.querySelectorAll('.scene-item[data-scene-id]');
        const visibleScenes = chapterEl.querySelectorAll('.scene-item[data-scene-id]:not(.filtered-out)');

        // Si le chapitre a des scènes mais aucune visible, le cacher
        // Si le chapitre n'a pas de scènes (vide), le garder visible
        if (allScenes.length > 0 && visibleScenes.length === 0) {
            chapterEl.classList.add('filtered-out');
        } else {
            chapterEl.classList.remove('filtered-out');
        }
    });

    // Cacher les actes dont tous les chapitres sont filtrés (mais pas les actes avec chapitres vides)
    document.querySelectorAll('.act-group').forEach(actEl => {
        const allChapters = actEl.querySelectorAll('.chapter-group');
        const visibleChapters = actEl.querySelectorAll('.chapter-group:not(.filtered-out)');

        // Si l'acte a des chapitres mais aucun visible, le cacher
        // Si l'acte n'a pas de chapitres (vide), le garder visible
        if (allChapters.length > 0 && visibleChapters.length === 0) {
            actEl.classList.add('filtered-out');
        } else {
            actEl.classList.remove('filtered-out');
        }
    });
}

/* [MVVM] View */
function updateProgressBar() {
    let counts = { draft: 0, progress: 0, complete: 0, review: 0 };
    let total = 0;

    const vm = getStructureViewModel();
    vm.acts.forEach(act => {
        act.chapters.forEach(chapter => {
            chapter.scenes.forEach(scene => {
                const status = scene.status || 'draft';
                counts[status] = (counts[status] || 0) + 1;
                total++;
            });
        });
    });

    // Mettre à jour les compteurs
    document.getElementById('countDraft').textContent = counts.draft;
    document.getElementById('countProgress').textContent = counts.progress;
    document.getElementById('countComplete').textContent = counts.complete;
    document.getElementById('countReview').textContent = counts.review;

    // Mettre à jour le texte de progression
    const completedPercent = total > 0 ? Math.round((counts.complete / total) * 100) : 0;
    document.getElementById('progressStatsText').textContent = `${total} scène${total > 1 ? 's' : ''}`;
    document.getElementById('progressPercent').textContent = `${completedPercent}% terminé`;

    // Mettre à jour les segments de la barre
    if (total > 0) {
        document.getElementById('progressComplete').style.width = `${(counts.complete / total) * 100}%`;
        document.getElementById('progressReview').style.width = `${(counts.review / total) * 100}%`;
        document.getElementById('progressProgress').style.width = `${(counts.progress / total) * 100}%`;
        document.getElementById('progressDraft').style.width = `${(counts.draft / total) * 100}%`;
    } else {
        document.getElementById('progressComplete').style.width = '0%';
        document.getElementById('progressReview').style.width = '0%';
        document.getElementById('progressProgress').style.width = '0%';
        document.getElementById('progressDraft').style.width = '0%';
    }
}

// [MVVM : View]
// Ouvre le menu contextuel de statut d'une scène
function toggleSceneStatus(actId, chapterId, sceneId, event) {
    event = event || window.event;
    event.stopPropagation();

    // Fermer tout menu existant
    closeStatusMenu();

    const vm = getStructureViewModel();
    const act = vm.acts.find(a => a.id === actId);
    if (!act) return;

    const chapter = act.chapters.find(c => c.id === chapterId);
    if (!chapter) return;

    const scene = chapter.scenes.find(s => s.id === sceneId);
    if (!scene) return;

    const currentStatus = scene.status || 'draft';

    // Créer le menu contextuel
    const menu = document.createElement('div');
    menu.className = 'status-menu visible';
    menu.id = 'statusMenu';
    menu.innerHTML = `
                <div class="status-menu-item ${currentStatus === 'draft' ? 'active' : ''}" onclick="setSceneStatus(${actId}, ${chapterId}, ${sceneId}, 'draft')">
                    <span class="status-menu-dot draft"></span>
                    <span>Brouillon</span>
                </div>
                <div class="status-menu-item ${currentStatus === 'progress' ? 'active' : ''}" onclick="setSceneStatus(${actId}, ${chapterId}, ${sceneId}, 'progress')">
                    <span class="status-menu-dot progress"></span>
                    <span>En cours</span>
                </div>
                <div class="status-menu-item ${currentStatus === 'complete' ? 'active' : ''}" onclick="setSceneStatus(${actId}, ${chapterId}, ${sceneId}, 'complete')">
                    <span class="status-menu-dot complete"></span>
                    <span>Terminé</span>
                </div>
                <div class="status-menu-item ${currentStatus === 'review' ? 'active' : ''}" onclick="setSceneStatus(${actId}, ${chapterId}, ${sceneId}, 'review')">
                    <span class="status-menu-dot review"></span>
                    <span>À réviser</span>
                </div>
            `;

    // Positionner le menu en position fixe près du clic
    const badge = event.target.closest('.status-badge');
    if (badge) {
        const rect = badge.getBoundingClientRect();
        menu.style.top = (rect.bottom + 5) + 'px';
        menu.style.left = (rect.left - 100) + 'px'; // Décaler vers la gauche

        // S'assurer que le menu ne sort pas de l'écran
        document.body.appendChild(menu);

        const menuRect = menu.getBoundingClientRect();
        if (menuRect.right > window.innerWidth) {
            menu.style.left = (window.innerWidth - menuRect.width - 10) + 'px';
        }
        if (menuRect.left < 0) {
            menu.style.left = '10px';
        }
        if (menuRect.bottom > window.innerHeight) {
            menu.style.top = (rect.top - menuRect.height - 5) + 'px';
        }

        currentStatusMenu = menu;
    }

    // Fermer le menu si on clique ailleurs
    setTimeout(() => {
        document.addEventListener('click', closeStatusMenuOnClickOutside);
    }, 10);
}

// [MVVM : View]
// Ferme le menu de statut
function closeStatusMenu() {
    const menu = document.getElementById('statusMenu');
    if (menu) {
        menu.remove();
    }
    currentStatusMenu = null;
    document.removeEventListener('click', closeStatusMenuOnClickOutside);
}

// [MVVM : View]
// Gère la fermeture du menu au clic extérieur
function closeStatusMenuOnClickOutside(event) {
    if (currentStatusMenu && !currentStatusMenu.contains(event.target)) {
        closeStatusMenu();
    }
}

/**
 * [MVVM : View]
 * Génère le HTML pour les liens personnages d'une scène.
 */
function renderSceneCharacters(actId, chapterId, scene) {
    if (!scene.linkedCharacters || scene.linkedCharacters.length === 0) {
        return '<span style="font-size: 0.8rem; color: var(--text-muted); font-style: italic;">Aucun personnage lié</span>';
    }

    const vm = getStructureViewModel();
    return scene.linkedCharacters.map(charId => {
        const character = vm.characters.find(c => c.id === charId);
        if (!character) return '';
        return `
            <span class="link-badge" onclick="event.stopPropagation(); switchView('characters'); openCharacterDetail(${charId});">
                ${character.name}
                <span class="link-badge-remove" onclick="event.stopPropagation(); toggleCharacterInScene(${actId}, ${chapterId}, ${scene.id}, ${charId}); openScene(${actId}, ${chapterId}, ${scene.id});"><i data-lucide="x" style="width:10px;height:10px;"></i></span>
            </span>`;
    }).join('');
}

/**
 * [MVVM : View]
 * Génère le HTML pour les liens éléments/lieux d'une scène.
 */
function renderSceneElements(actId, chapterId, scene) {
    if (!scene.linkedElements || scene.linkedElements.length === 0) {
        return '<span style="font-size: 0.8rem; color: var(--text-muted); font-style: italic;">Aucun élément lié</span>';
    }

    const vm = getStructureViewModel();
    return scene.linkedElements.map(elemId => {
        const element = vm.world.find(e => e.id === elemId);
        if (!element) return '';
        return `
            <span class="link-badge" onclick="event.stopPropagation(); switchView('world'); openWorldDetail(${elemId});">
                ${element.name}
                <span class="link-badge-remove" onclick="event.stopPropagation(); toggleElementInScene(${actId}, ${chapterId}, ${scene.id}, ${elemId}); openScene(${actId}, ${chapterId}, ${scene.id});"><i data-lucide="x" style="width:10px;height:10px;"></i></span>
           </span>`;
    }).join('');
}

/**
 * [MVVM : View]
 * Génère le HTML pour les événements temporels liés à une scène.
 */
function renderSceneMetroEvents(sceneId) {
    const vm = getStructureViewModel();
    if (!vm.metroTimeline || vm.metroTimeline.length === 0) {
        return '<span style="font-size: 0.8rem; color: var(--text-muted); font-style: italic;">Aucun événement</span>';
    }

    const linkedEvents = vm.metroTimeline.filter(event => event.sceneId == sceneId);
    if (linkedEvents.length === 0) {
        return '<span style="font-size: 0.8rem; color: var(--text-muted); font-style: italic;">Aucun événement lié</span>';
    }

    return linkedEvents.map(event => `
        <span class="link-badge" style="background: var(--accent-blue); color: white;" onclick="event.stopPropagation(); openMetroEventFromScene(${event.id});" title="${event.date || 'Sans date'}">
            <i data-lucide="train-track" style="width:12px;height:12px;vertical-align:middle;margin-right:2px;"></i>
            ${event.title}
        </span>`).join('');
}

/**
 * [MVVM : View]
 * Ouvre la modale pour lier des personnages.
 */
function openCharacterLinker(actId, chapterId, sceneId) {
    const vm = getStructureViewModel();
    const act = vm.acts.find(a => a.id === actId);
    const chapter = act?.chapters.find(c => c.id === chapterId);
    const scene = chapter?.scenes.find(s => s.id === sceneId);
    if (!scene) return;

    const titleEl = document.getElementById('referencesModalTitle');
    const contentEl = document.getElementById('referencesModalContent');
    if (titleEl) titleEl.textContent = 'Lier des personnages à cette scène';

    if (contentEl) {
        contentEl.innerHTML = `
            <div class="tag-selector">
                ${project.characters.map(char => {
            const isLinked = scene.confirmedPresentCharacters && scene.confirmedPresentCharacters.includes(char.id);
            return `
                        <div class="tag-option ${isLinked ? 'selected' : ''}" 
                             onclick="toggleCharacterLinkerAction(${char.id}); this.classList.toggle('selected');">
                            ${char.name}
                        </div>`;
        }).join('')}
            </div>
            ${project.characters.length === 0 ? '<p style="color: var(--text-muted); margin-top: 1rem;">Aucun personnage créé. Créez des personnages dans l\'onglet Personnages.</p>' : ''}`;
    }

    const modal = document.getElementById('referencesModal');
    if (modal) modal.classList.add('active');
}

/**
 * [MVVM : View]
 * Ouvre la modale pour lier des éléments.
 */
function openElementLinker(actId, chapterId, sceneId) {
    const act = project.acts.find(a => a.id === actId);
    const chapter = act?.chapters.find(c => c.id === chapterId);
    const scene = chapter?.scenes.find(s => s.id === sceneId);
    if (!scene) return;

    const titleEl = document.getElementById('referencesModalTitle');
    const contentEl = document.getElementById('referencesModalContent');
    if (titleEl) titleEl.textContent = 'Lier des lieux/éléments à cette scène';

    if (contentEl) {
        contentEl.innerHTML = `
            <div class="tag-selector">
                ${project.world.map(elem => {
            const isLinked = scene.linkedElements && scene.linkedElements.includes(elem.id);
            return `
                        <div class="tag-option ${isLinked ? 'selected' : ''}" 
                             onclick="toggleElementInScene(${actId}, ${chapterId}, ${sceneId}, ${elem.id}); this.classList.toggle('selected');">
                            ${elem.name} <small>(${elem.type})</small>
                        </div>`;
        }).join('')}
            </div>
            ${project.world.length === 0 ? '<p style="color: var(--text-muted); margin-top: 1rem;">Aucun élément créé. Créez des lieux dans l\'onglet Univers.</p>' : ''}`;
    }

    const modal = document.getElementById('referencesModal');
    if (modal) modal.classList.add('active');
}

// ========== js-refactor/structure/structure-organizer.view.js ==========
/**
 * [MVVM : Structure Organizer View]
 * Vue dédiée à la réorganisation massive de la structure (Actes > Chapitres > Scènes)
 * Style "Gestion de menu WordPress" (Blocs imbriqués et Drag & Drop)
 */

// --- STATE ---
let organizerDragItems = []; // Array of { type, id, parentId, actId }
let organizerSelectedItems = []; // Array of { type, id }
let organizerDragSource = null;
const organizerCollapsedState = { acts: new Set(), chapters: new Set() };

// --- CONFIG ---
const ORGANIZER_STYLES = `
    .organizer-modal {
        position: fixed;
        top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.85);
        backdrop-filter: blur(5px);
        z-index: 2000;
        display: none;
        align-items: center;
        justify-content: center;
    }
    .organizer-modal.active {
        display: flex;
        animation: orgFadeIn 0.25s ease-out;
    }
    @keyframes orgFadeIn { from{opacity:0; transform:scale(0.98);} to{opacity:1; transform:scale(1);} }
    
    .organizer-content {
        width: 98%; height: 95%;
        max-width: 1900px;
        background: var(--bg-canvas, #121212);
        border-radius: 12px;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        box-shadow: 0 20px 50px rgba(0,0,0,0.6);
        border: 1px solid var(--border-color, #333);
    }
    
    .organizer-header {
        padding: 0.75rem 1.5rem;
        border-bottom: 1px solid var(--border-color, #333);
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: var(--bg-secondary, #1e1e1e);
    }
    .organizer-header h2 { font-size: 1.1rem; margin: 0; display:flex; gap:10px; align-items:center; }
    
    .organizer-body {
        flex: 1;
        overflow-x: auto;
        overflow-y: hidden; /* Acts scroll internally */
        padding: 1rem;
        background: var(--bg-canvas, #0e0e0e);
    }

    /* KANBAN LAYOUT */
    .org-container {
        display: flex;
        flex-direction: row;
        gap: 12px;
        height: 100%;
        align-items: stretch;
        padding-bottom: 8px;
    }
    
    /* ACT COLUMN */
    .org-act {
        flex: 0 0 320px;
        display: flex;
        flex-direction: column;
        background: var(--bg-secondary, #1e1e1e);
        border-radius: 8px;
        max-height: 100%;
        border: 1px solid var(--border-color, #333);
        transition: transform 0.2s, box-shadow 0.2s;
    }
    .org-act.dragging { opacity: 0.5; transform: scale(0.95); }
    .org-act.selected-block { border: 1px solid var(--accent-color, #007acc); box-shadow: 0 0 0 1px var(--accent-color, #007acc); }

    .org-act > .org-header {
        padding: 10px 12px;
        background: var(--bg-tertiary, #252526);
        border-bottom: 1px solid var(--border-color, #333);
        border-radius: 8px 8px 0 0;
        font-weight: 700;
        cursor: grab;
        position: sticky; top: 0;
        z-index: 10;
        display: flex; align-items: center; gap: 8px;
    }
    
    /* Default hidden content for collapse logic */
    .org-content { display: none; }

    .org-act.expanded > .org-content {
        flex: 1;
        overflow-y: auto;
        padding: 8px;
        display: flex;
        flex-direction: column;
        gap: 8px;
        min-height: 50px;
    }

    /* CHAPTER CARD */
    .org-chapter {
        background: var(--bg-primary, #2d2d2d);
        border: 1px solid var(--border-color, #444);
        border-radius: 6px;
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        display: flex; flex-direction: column;
        margin-bottom: 2px;
    }
    .org-chapter.selected-block { border-color: var(--accent-color, #007acc); background: rgba(0, 122, 204, 0.1); }
    
    .org-chapter > .org-header {
        padding: 8px 10px;
        font-weight: 600;
        font-size: 0.95rem;
        cursor: pointer;
        border-radius: 6px;
        display: flex; align-items: center; gap: 6px;
    }
    .org-chapter > .org-header:hover { background: rgba(255,255,255,0.05); }

    .org-chapter.expanded > .org-content {
        display: block;
        padding: 0 4px 4px 4px; /* Space for scenes */
    }
    
    /* BUTTONS */
    .org-icon-btn { padding: 4px; border-radius: 4px; cursor: pointer; display: flex; align-items: center; justify-content: center; }
    .org-icon-btn:hover { background: rgba(255,255,255,0.15); }
    .toggle-icon { transition: transform 0.2s; transform: rotate(-90deg); }
    .org-block.expanded .toggle-icon { transform: rotate(0deg); }

    /* SCENE ITEM */
    .org-scene {
        background: transparent;
        border-top: 1px solid var(--border-color, #3a3a3a);
        padding: 4px 0 0 0;
        margin-top: 4px;
    }
    .org-scene:first-child { border-top: none; margin-top: 0; }
    
    .org-scene .org-header {
        padding: 4px 8px;
        font-size: 0.85rem;
        color: var(--text-secondary, #ccc);
        border-radius: 4px;
        display: flex; align-items: center; gap: 6px;
        cursor: pointer;
    }
    .org-scene .org-header:hover { background: rgba(255,255,255,0.05); color: #fff; }
    .org-scene.selected-block .org-header { background: rgba(0, 122, 204, 0.2); color: #fff; }

    /* DROP ZONES - IMPROVED HIT TARGETS */
    .org-drop-zone { transition: all 0.1s; opacity: 0; box-sizing: border-box; }
    
    /* Vertical separator for Acts */
    .org-drop-zone[data-type="act-drop"] {
        width: 60px; margin: 0 -30px; cursor: col-resize; z-index: 50;
    }
    .org-drop-zone[data-type="act-drop"].drag-over {
        width: 8px; margin: 0 -4px; background: var(--accent-color); opacity: 1; border-radius: 4px;
    }

    /* Horizontal separator for Chapters/Scenes */
    .org-drop-zone[data-type="chapter-drop"], .org-drop-zone[data-type="scene-drop"] {
        height: 16px; margin: -8px 0; z-index: 50; position: relative;
    }
    .org-drop-zone[data-type="chapter-drop"].drag-over, .org-drop-zone[data-type="scene-drop"].drag-over {
        height: 36px; margin: 4px 0; background: rgba(0, 122, 204, 0.15); border: 2px dashed var(--accent-color); opacity: 1; border-radius: 6px; z-index: 49;
    }
    
    .org-header.drag-over-folder {
        background: rgba(0, 122, 204, 0.3);
        outline: 2px solid var(--accent-color, #007acc);
    }
    /* EMPTY STATES */
    .empty-placeholder { opacity: 1 !important; margin: 10px 0 !important; height: 50px !important; border-radius: 6px; background: rgba(255,255,255,0.02); }

    /* UTILS */
    .org-stats { font-size: 0.75rem; color: #666; margin-left: auto; }
    .org-count { font-size: 0.7rem; background: rgba(255,255,255,0.1); padding: 1px 4px; border-radius: 4px; }
    
    /* ICONS in headers */
    .drag-handle { opacity: 0.3; width: 14px; height: 14px; }
    .org-header:hover .drag-handle { opacity: 1; }
`;
// --- UI HELPERS ---

function ensureOrganizerStyles() {
    let style = document.getElementById('organizer-styles');
    if (!style) {
        style = document.createElement('style');
        style.id = 'organizer-styles';
        document.head.appendChild(style);
    }
    style.textContent = ORGANIZER_STYLES;

    if (!document.getElementById('organizerModal')) {
        const modal = document.createElement('div');
        modal.id = 'organizerModal';
        modal.className = 'organizer-modal';
        modal.innerHTML = `
            <div class="organizer-content">
                <div class="organizer-header">
                    <h2><i data-lucide="layout-list"></i> Réorganisation de la Structure</h2>
                    <div style="display:flex; gap:10px;">
                        <button class="btn btn-secondary" onclick="expandAllOrganizer()">Tout déplier</button>
                        <button class="btn btn-secondary" onclick="collapseAllOrganizer()">Tout replier</button>
                        <button class="btn btn-primary" onclick="closeOrganizer()">Terminer</button>
                    </div>
                </div>
                <div id="organizerBody" class="organizer-body">
                    <!-- CONTENT HERE -->
                </div>
            </div>
    `;
        document.body.appendChild(modal);
        if (typeof lucide !== 'undefined') lucide.createIcons();
    }
}

// --- MAIN FUNCTIONS ---

function openStructureOrganizer() {
    ensureOrganizerStyles();
    renderOrganizer();
    document.getElementById('organizerModal').classList.add('active');
}

function closeOrganizer() {
    document.getElementById('organizerModal').classList.remove('active');
    // Refresh main tree view to reflect changes
    if (typeof renderActsList === 'function') renderActsList();
}

function renderOrganizer() {
    const container = document.getElementById('organizerBody');
    if (!container) return;

    if (!project.acts || project.acts.length === 0) {
        container.innerHTML = '<div style="padding:2rem; text-align:center;">Aucune structure.</div>';
        return;
    }

    let html = '<div class="org-container">';

    project.acts.forEach((act, actIndex) => {
        html += renderOrganizerAct(act, actIndex);
    });

    html += '</div>';
    container.innerHTML = html;

    if (typeof lucide !== 'undefined') lucide.createIcons();
    setupOrganizerEvents();
}

function renderOrganizerAct(act, index) {
    const scenesCount = act.chapters.reduce((sum, ch) => sum + ch.scenes.length, 0);
    const wordCount = act.chapters.reduce((sum, ch) => sum + ch.scenes.reduce((s, scene) => s + (scene.wordCount || 0), 0), 0);

    // Drop zone before act
    let html = `<div class="org-drop-zone" data-type="act-drop" data-index="${index}"></div>`;

    const isSelected = organizerSelectedItems.some(i => i.type === 'act' && i.id === act.id);
    const isCollapsed = organizerCollapsedState.acts.has(act.id);

    html += `
        <div class="org-block org-act ${!isCollapsed ? 'expanded' : ''} ${isSelected ? 'selected-block' : ''}" id="org-act-${act.id}" draggable="true" data-type="act" data-id="${act.id}">
            <div class="org-header ${isSelected ? 'selected' : ''}" onclick="handleOrganizerClick(event, 'act', ${act.id})">
                <i data-lucide="grip-vertical" class="drag-handle" style="cursor: grab;"></i>
                <div class="org-icon-btn" onclick="toggleOrganizerBlock(this, event)">
                    <i data-lucide="chevron-down" class="toggle-icon"></i>
                </div>
                <span style="font-weight:bold;">${act.title}</span>
                <span class="org-count">${act.chapters.length} chapitres</span>
                <span class="org-stats">${wordCount} mots</span>
            </div>
            <div class="org-content" data-parent-type="act" data-parent-id="${act.id}">
    `;

    if (act.chapters.length === 0) {
        html += `<div class="org-drop-zone empty-placeholder" data-type="chapter-drop" data-parent-id="${act.id}" data-index="0" style="height:30px; border:1px dashed #555; display:flex; align-items:center; justify-content:center; color:#777;">Déposer un chapitre ici</div>`;
    } else {
        act.chapters.forEach((chapter, chIndex) => {
            html += renderOrganizerChapter(chapter, chIndex, act.id);
        });
        // Drop zone at end of chapters
        html += `<div class="org-drop-zone" data-type="chapter-drop" data-parent-id="${act.id}" data-index="${act.chapters.length}"></div>`;
    }

    html += `</div></div>`;
    return html;
}

function renderOrganizerChapter(chapter, index, actId) {
    const wordCount = chapter.scenes.reduce((sum, scene) => sum + (scene.wordCount || 0), 0);

    // Drop zone before chapter
    let html = `<div class="org-drop-zone" data-type="chapter-drop" data-parent-id="${actId}" data-index="${index}"></div>`;

    const isSelected = organizerSelectedItems.some(i => i.type === 'chapter' && i.id === chapter.id);
    const isCollapsed = organizerCollapsedState.chapters.has(chapter.id);

    html += `
        <div class="org-block org-chapter ${!isCollapsed ? 'expanded' : ''} ${isSelected ? 'selected-block' : ''}" id="org-chapter-${chapter.id}" draggable="true" data-type="chapter" data-id="${chapter.id}" data-parent-id="${actId}">
            <div class="org-header ${isSelected ? 'selected' : ''}" onclick="handleOrganizerClick(event, 'chapter', ${chapter.id})">
                <i data-lucide="grip-vertical" class="drag-handle" style="cursor: grab;"></i>
                <div class="org-icon-btn" onclick="toggleOrganizerBlock(this, event)">
                    <i data-lucide="chevron-down" class="toggle-icon"></i>
                </div>
                <span>${chapter.title}</span>
                <span class="org-count">${chapter.scenes.length} scènes</span>
                <span class="org-stats">${wordCount} mots</span>
            </div>
            <div class="org-content" data-parent-type="chapter" data-parent-id="${chapter.id}">
    `;

    if (chapter.scenes.length === 0) {
        html += `<div class="org-drop-zone empty-placeholder" data-type="scene-drop" data-parent-id="${chapter.id}" data-index="0" style="height:30px; border:1px dashed #555; display:flex; align-items:center; justify-content:center; color:#777;">Déposer une scène ici</div>`;
    } else {
        chapter.scenes.forEach((scene, scIndex) => {
            html += renderOrganizerScene(scene, scIndex, actId, chapter.id);
        });
        // Drop zone at end of scenes
        html += `<div class="org-drop-zone" data-type="scene-drop" data-parent-id="${chapter.id}" data-index="${chapter.scenes.length}"></div>`;
    }

    html += `</div></div>`;
    return html;
}

function renderOrganizerScene(scene, index, actId, chapterId) {
    // Drop zone before scene
    let html = `<div class="org-drop-zone" data-type="scene-drop" data-parent-id="${chapterId}" data-index="${index}"></div>`;

    const isSelected = organizerSelectedItems.some(i => i.type === 'scene' && i.id === scene.id);

    html += `
        <div class="org-block org-scene ${isSelected ? 'selected-block' : ''}" id="org-scene-${scene.id}" draggable="true" data-type="scene" data-id="${scene.id}" data-parent-id="${chapterId}" data-act-id="${actId}">
            <div class="org-header ${isSelected ? 'selected' : ''}" onclick="handleOrganizerClick(event, 'scene', ${scene.id})">
                <i data-lucide="grip-vertical" class="drag-handle" style="cursor: grab;"></i>
                <span>${scene.title}</span>
                <span class="org-stats">${scene.wordCount || 0} mots</span>
            </div>
        </div>
    `;
    return html;
}

// --- INTERACTION --- //

function handleOrganizerClick(event, type, id) {
    // If clicking chevron or drag handle, don't trigger selection via this handler (handled separately or bubbling stopped)
    // Actually simpler: pass event and check target?
    // But I put onclick on the header div, and separate onclick on chevron.
    // Ensure separate handling.

    // Check key modifiers for multi-select
    const isMulti = event.ctrlKey || event.metaKey;
    // const isRange = event.shiftKey; // Simplification: Treat shift as multi for now or implement range later

    selectOrganizerItem(type, id, isMulti);
}

function selectOrganizerItem(type, id, isMulti) {
    const existingIndex = organizerSelectedItems.findIndex(i => i.id === id && i.type === type);

    if (isMulti) {
        // Enforce same type constraint
        if (organizerSelectedItems.length > 0 && organizerSelectedItems[0].type !== type) {
            // Different type clicked? Reset and select new.
            organizerSelectedItems = [{ type, id }];
        } else {
            // Toggle
            if (existingIndex >= 0) {
                organizerSelectedItems.splice(existingIndex, 1);
            } else {
                organizerSelectedItems.push({ type, id });
            }
        }
    } else {
        // Single select
        // If already selected and only one, do nothing (or re-select)
        if (existingIndex >= 0 && organizerSelectedItems.length === 1) {
            // Already the only selected item
        } else {
            organizerSelectedItems = [{ type, id }];
        }
    }

    renderOrganizer(); // Re-render to update classes
}

function toggleOrganizerBlock(element, event) {
    if (event) event.stopPropagation();

    const block = element.closest('.org-block');
    block.classList.toggle('expanded');

    // Update State
    const type = block.dataset.type;
    const id = parseInt(block.dataset.id);
    const isExpanded = block.classList.contains('expanded');

    if (type === 'act') {
        if (isExpanded) organizerCollapsedState.acts.delete(id);
        else organizerCollapsedState.acts.add(id);
    } else if (type === 'chapter') {
        if (isExpanded) organizerCollapsedState.chapters.delete(id);
        else organizerCollapsedState.chapters.add(id);
    }
}

function expandAllOrganizer() {
    organizerCollapsedState.acts.clear();
    organizerCollapsedState.chapters.clear();
    document.querySelectorAll('.org-block').forEach(b => b.classList.add('expanded'));
}

function collapseAllOrganizer() {
    // Only collapse chapters, keep Acts expanded (Kanban columns)
    if (typeof project !== 'undefined' && project.acts) {
        project.acts.forEach(act => {
            if (act.chapters) act.chapters.forEach(ch => organizerCollapsedState.chapters.add(ch.id));
        });
    }
    document.querySelectorAll('.org-chapter').forEach(b => b.classList.remove('expanded'));
}

// --- DRAG AND DROP LOGIC ---

function setupOrganizerEvents() {
    const container = document.getElementById('organizerBody');
    let currentDragTarget = null; // Performance optimization

    // DRAG START
    container.addEventListener('dragstart', (e) => {
        const target = e.target.closest('.org-block');
        if (!target) return;

        e.stopPropagation();
        target.classList.add('dragging');

        const type = target.dataset.type;
        const id = parseInt(target.dataset.id);

        const isSelected = organizerSelectedItems.some(i => i.id === id && i.type === type);

        if (!isSelected) {
            organizerSelectedItems = [{ type, id }];
            container.querySelectorAll('.org-header.selected').forEach(el => el.classList.remove('selected'));
            container.querySelectorAll('.org-block.selected-block').forEach(el => el.classList.remove('selected-block'));
            target.querySelector('.org-header').classList.add('selected');
            target.classList.add('selected-block');
        }

        organizerDragItems = organizerSelectedItems.map(item => {
            const el = document.getElementById(`org-${item.type}-${item.id}`);
            return {
                type: item.type,
                id: item.id,
                parentId: parseInt(el?.dataset.parentId || 0),
                actId: parseInt(el?.dataset.actId || 0)
            };
        });

        if (organizerDragItems.length === 0) {
            organizerDragItems = [{
                type, id,
                parentId: parseInt(target.dataset.parentId || 0),
                actId: parseInt(target.dataset.actId || 0)
            }];
        }

        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/plain', JSON.stringify(organizerDragItems));
    });

    // DRAG END
    container.addEventListener('dragend', (e) => {
        document.querySelectorAll('.dragging').forEach(el => el.classList.remove('dragging'));
        if (currentDragTarget) {
            currentDragTarget.classList.remove('drag-over', 'drag-over-folder');
            currentDragTarget = null;
        }
        // Cleanup fallback
        document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
        document.querySelectorAll('.drag-over-folder').forEach(el => el.classList.remove('drag-over-folder'));

        organizerDragItems = [];
    });

    // DRAG OVER (Optimized)
    container.addEventListener('dragover', (e) => {
        e.preventDefault();

        if (!organizerDragItems || organizerDragItems.length === 0) return;

        // Optimization: Don't re-query if target hasn't changed conceptually
        const targetElement = e.target.closest('.org-drop-zone, .org-header');

        if (currentDragTarget === targetElement) {
            e.dataTransfer.dropEffect = 'move';
            return;
        }

        // Clean previous
        if (currentDragTarget) {
            currentDragTarget.classList.remove('drag-over', 'drag-over-folder');
        }

        if (!targetElement) {
            currentDragTarget = null;
            return;
        }

        // Validate new target
        const targetInfo = getDropTarget(targetElement);
        if (!targetInfo) {
            currentDragTarget = null;
            return;
        }

        const sampleItem = organizerDragItems[0];
        if (!isCompatibleDrop(sampleItem.type, targetInfo.type)) {
            currentDragTarget = null;
            return;
        }

        // APPLY HIGHLIGHT
        currentDragTarget = targetElement;

        if (targetElement.classList.contains('org-drop-zone')) {
            targetElement.classList.add('drag-over');
        } else {
            targetElement.classList.add('drag-over-folder');
        }

        e.dataTransfer.dropEffect = 'move';
    });

    // DROP
    container.addEventListener('drop', async (e) => {
        e.preventDefault();
        e.stopPropagation();

        if (!organizerDragItems || organizerDragItems.length === 0) return;

        const targetInfo = getDropTarget(e.target);
        if (!targetInfo) return;

        const sampleItem = organizerDragItems[0];

        // [MVVM : View] Validation du drop - vérifier la compatibilité
        if (!isCompatibleDrop(sampleItem.type, targetInfo.type)) {
            // Cas spécial : scène droppée sur un acte (zone chapter-drop)
            // -> Créer automatiquement un chapitre pour accueillir la scène
            if (sampleItem.type === 'scene' && targetInfo.type === 'chapter-drop') {
                const targetAct = project.acts.find(a => a.id === targetInfo.parentId);
                if (targetAct) {
                    // Créer un nouveau chapitre
                    const newChapter = createAutoChapterForScene(targetAct);
                    if (newChapter) {
                        // Modifier targetInfo pour pointer vers ce nouveau chapitre
                        targetInfo.type = 'scene-drop';
                        targetInfo.parentId = newChapter.id;
                        targetInfo.index = 0;
                    } else {
                        return; // Échec de création du chapitre
                    }
                } else {
                    return; // Acte non trouvé
                }
            } else {
                // Drop incompatible non géré
                return;
            }
        }

        // EXECUTE MOVE
        await executeOrganizerMoveMulti(organizerDragItems, targetInfo);

        renderOrganizer(); // Re-render to show changes
    });
}

function getDropTarget(element) {
    // 1. Check if Drop Zone (INSERT)
    const dropZone = element.closest('.org-drop-zone');
    if (dropZone) {
        return {
            type: dropZone.dataset.type, // act-drop, chapter-drop, scene-drop
            parentId: parseInt(dropZone.dataset.parentId || 0),
            index: parseInt(dropZone.dataset.index),
            element: dropZone,
            action: 'insert'
        };
    }

    // 2. Check if Header (APPEND TO CHILDREN)
    const header = element.closest('.org-header');
    if (header) {
        const block = header.closest('.org-block');
        const blockType = block.dataset.type; // act, chapter

        // Define drop types based on block type
        let dropType = '';
        if (blockType === 'act') dropType = 'chapter-drop'; // Dropping into an Act means adding a chapter
        if (blockType === 'chapter') dropType = 'scene-drop'; // Dropping into a Chapter means adding a scene

        return {
            type: dropType,
            parentId: parseInt(block.dataset.id),
            index: 9999, // Append to end
            element: header,
            action: 'append'
        };
    }

    return null;
}

function isCompatibleDrop(sourceType, targetDropType) {
    if (sourceType === 'act' && targetDropType === 'act-drop') return true;
    if (sourceType === 'chapter' && targetDropType === 'chapter-drop') return true;
    if (sourceType === 'scene' && targetDropType === 'scene-drop') return true;
    return false;
}

// [MVVM : View Helper] Crée automatiquement un chapitre quand une scène est droppée sur un acte sans chapitre
function createAutoChapterForScene(targetAct) {
    if (!targetAct) return null;

    // Générer un titre automatique pour le chapitre
    const chapterNumber = (targetAct.chapters?.length || 0) + 1;
    const newChapter = {
        id: Date.now(),
        title: `Chapitre ${chapterNumber}`,
        scenes: []
    };

    // Ajouter le chapitre à l'acte
    if (!targetAct.chapters) targetAct.chapters = [];
    targetAct.chapters.push(newChapter);

    return newChapter;
}

async function executeOrganizerMoveMulti(items, target) {
    // This function manipulates the PROJECT global object directly
    // Then we should probably save and sync.

    /* 
       Items: [{ type, id, parentId, actId }, ...]
       Target: { type, parentId, index, element, action }
    */

    if (!items || items.length === 0) return;
    const type = items[0].type; // All items in `items` should be of the same type due to selection logic

    const objectsToMove = [];
    const itemIds = new Set(items.map(i => i.id));

    if (type === 'act') {
        // 1. Gather objects and calculate adjusted target index
        let targetIndex = target.index;
        let removedBeforeCount = 0;

        // Get original indices of all acts
        const currentMetadata = project.acts.map((a, idx) => ({ id: a.id, index: idx }));

        items.forEach(item => {
            const obj = project.acts.find(a => a.id === item.id);
            if (obj) objectsToMove.push(obj);

            const meta = currentMetadata.find(m => m.id === item.id);
            if (meta && meta.index < targetIndex) {
                removedBeforeCount++;
            }
        });

        let finalIndex = targetIndex - removedBeforeCount;
        if (finalIndex < 0) finalIndex = 0;

        // 2. Remove all selected acts
        project.acts = project.acts.filter(a => !itemIds.has(a.id));

        // 3. Insert at final index
        if (finalIndex > project.acts.length) finalIndex = project.acts.length;
        project.acts.splice(finalIndex, 0, ...objectsToMove);

    } else if (type === 'chapter') {
        // 1. Pre-calculate Anchor ID (the chapter that was at target.index before any removals)
        const preTargetAct = project.acts.find(a => a.id === target.parentId);
        let anchorId = null;
        if (preTargetAct && target.action === 'insert' && target.index < preTargetAct.chapters.length) {
            anchorId = preTargetAct.chapters[target.index].id;
        }

        // 2. Remove all selected chapters from their current acts
        items.forEach(item => {
            const parentAct = project.acts.find(a => a.chapters.some(c => c.id === item.id));
            if (parentAct) {
                const ch = parentAct.chapters.find(c => c.id === item.id);
                if (ch) objectsToMove.push(ch);
                parentAct.chapters = parentAct.chapters.filter(c => c.id !== item.id);
            }
        });

        // 3. Find the target act (it might have been modified by removals)
        const targetAct = project.acts.find(a => a.id === target.parentId);
        if (targetAct) {
            let insertIndex = targetAct.chapters.length; // Default to append

            if (anchorId) {
                // Find where the anchor chapter ended up after removals
                const newAnchorIndex = targetAct.chapters.findIndex(c => c.id === anchorId);
                if (newAnchorIndex !== -1) {
                    insertIndex = newAnchorIndex;
                } else {
                    // Anchor was removed (e.g., it was one of the selected items)
                    // Fallback to target.index, clamped
                    if (target.action === 'insert' && target.index < targetAct.chapters.length) {
                        insertIndex = target.index;
                    }
                }
            } else if (target.action === 'insert' && target.index === 0) {
                // Explicitly insert at the beginning
                insertIndex = 0;
            } else if (target.action === 'insert' && target.index < targetAct.chapters.length) {
                // If no anchor, but a specific index was targeted, use it (clamped)
                insertIndex = target.index;
            }

            targetAct.chapters.splice(insertIndex, 0, ...objectsToMove);
        }

    } else if (type === 'scene') {
        // 1. Pre-calculate Anchor ID (the scene that was at target.index before any removals)
        let preTargetChapter = null;
        for (const act of project.acts) {
            const ch = act.chapters.find(c => c.id === target.parentId);
            if (ch) { preTargetChapter = ch; break; }
        }

        let anchorId = null;
        if (preTargetChapter && target.action === 'insert' && target.index < preTargetChapter.scenes.length) {
            anchorId = preTargetChapter.scenes[target.index].id;
        }

        // 2. Remove all selected scenes from their current chapters
        items.forEach(item => {
            for (const act of project.acts) {
                const ch = act.chapters.find(c => c.scenes.some(s => s.id === item.id));
                if (ch) {
                    const sc = ch.scenes.find(s => s.id === item.id);
                    if (sc) objectsToMove.push(sc);
                    ch.scenes = ch.scenes.filter(s => s.id !== item.id);
                }
            }
        });

        // 3. Find the target chapter (it might have been modified by removals)
        let targetChapter = null;
        for (const act of project.acts) {
            const ch = act.chapters.find(c => c.id === target.parentId);
            if (ch) { targetChapter = ch; break; }
        }

        if (targetChapter) {
            let insertIndex = targetChapter.scenes.length; // Default to append

            if (anchorId) {
                // Find where the anchor scene ended up after removals
                const newAnchorIndex = targetChapter.scenes.findIndex(s => s.id === anchorId);
                if (newAnchorIndex !== -1) {
                    insertIndex = newAnchorIndex;
                } else {
                    // Anchor was removed (e.g., it was one of the selected items)
                    // Fallback to target.index, clamped
                    if (target.action === 'insert' && target.index < targetChapter.scenes.length) {
                        insertIndex = target.index;
                    }
                }
            } else if (target.action === 'insert' && target.index === 0) {
                // Explicitly insert at the beginning
                insertIndex = 0;
            } else if (target.action === 'insert' && target.index < targetChapter.scenes.length) {
                // If no anchor, but a specific index was targeted, use it (clamped)
                insertIndex = target.index;
            }

            targetChapter.scenes.splice(insertIndex, 0, ...objectsToMove);
        }
    }

    // Side Effects
    // Save project
    if (typeof saveProject === 'function') saveProject();

    // Refresh stats if needed
    if (typeof updateStats === 'function') updateStats();
}

// ========== js-refactor/structure/structure.helpers.js ==========
// Raccourcis clavier pour undo/redo
document.addEventListener('keydown', function (e) {
    // Ctrl+Z ou Cmd+Z pour undo
    if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
        e.preventDefault();
        if (typeof EventBus !== 'undefined') EventBus.emit('history:undo');
        else if (typeof undo === 'function') undo();
    }
    // Ctrl+Y ou Cmd+Shift+Z pour redo
    else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
        e.preventDefault();
        if (typeof EventBus !== 'undefined') EventBus.emit('history:redo');
        else if (typeof redo === 'function') redo();
    }
});

// [MVVM : Helper]
// Validation utilities
const ValidationHelper = {
    validateTitle(title, options = {}) {
        const maxLength = options.maxLength || 100;
        const minLength = options.minLength || 1;

        if (!title || typeof title !== 'string') {
            return {
                isValid: false,
                error: 'INVALID_TYPE',
                message: 'Le titre doit être une chaîne de caractères'
            };
        }

        const trimmed = title.trim();

        if (trimmed.length < minLength) {
            return {
                isValid: false,
                error: 'TOO_SHORT',
                message: `Le titre doit contenir au moins ${minLength} caractère(s)`
            };
        }

        if (trimmed.length > maxLength) {
            return {
                isValid: false,
                error: 'TOO_LONG',
                message: `Le titre ne peut pas dépasser ${maxLength} caractères`
            };
        }

        return { isValid: true, value: trimmed };
    },

    checkDuplicate(title, collection, property = 'title') {
        const exists = collection.some(item => item[property] === title);
        if (exists) {
            return {
                isDuplicate: true,
                error: 'DUPLICATE',
                message: `Un élément avec ce ${property} existe déjà`
            };
        }
        return { isDuplicate: false };
    }
};

// [MVVM : Helper]
// Notification system
function showNotification(message, type = 'info') {
    // Si la fonction showNotification existe déjà dans l'app, l'utiliser
    if (typeof window.showNotification === 'function') {
        window.showNotification(message, type);
        return;
    }

    // Sinon, fallback simple
    console.log(`[${type.toUpperCase()}] ${message}`);
}

// ========== js-refactor/07.stats.refactor.js ==========
/**
 * [MVVM : Stats Module]
 * Ce fichier contient uniquement la logique pure de calcul et de formatage des statistiques.
 */

/**
 * [MVVM : Model]
 * Utilitaire pur pour compter les mots (Logique métier)
 */
function getWordCount(html) {
    if (!html) return 0;
    // Create temporary div to strip HTML tags
    const temp = document.createElement('div');
    temp.innerHTML = html;
    const text = temp.textContent || temp.innerText || '';
    return text.split(/\s+/).filter(w => w.length > 0).length;
}

/**
 * [MVVM : ViewModel]
 * Formate un nombre pour l'affichage (ex: 1.2k)
 */
function formatWordCount(count) {
    if (count >= 1000) {
        return (count / 1000).toFixed(1).replace('.0', '') + 'k';
    }
    return count.toString();
}

/**
 * [MVVM : ViewModel]
 * Calcule les statistiques d'un chapitre pour la vue
 */
function getChapterStats(chapter) {
    if (!chapter || !chapter.scenes) return { totalScenes: 0, totalWords: 0, completedScenes: 0, progressPercent: 0 };

    const totalScenes = chapter.scenes.length;
    const totalWords = chapter.scenes.reduce((sum, s) => sum + (s.wordCount || 0), 0);
    const completedScenes = chapter.scenes.filter(s => (s.status || 'draft') === 'complete').length;
    const progressPercent = totalScenes > 0 ? Math.round((completedScenes / totalScenes) * 100) : 0;
    return { totalScenes, totalWords, completedScenes, progressPercent };
}

/**
 * [MVVM : ViewModel]
 * Calcule les statistiques d'un acte pour la vue
 */
function getActStats(act) {
    if (!act || !act.chapters) return { totalChapters: 0, totalScenes: 0, totalWords: 0 };

    const totalChapters = act.chapters.length;
    const totalScenes = act.chapters.reduce((sum, ch) => sum + ch.scenes.length, 0);
    const totalWords = act.chapters.reduce((sum, ch) =>
        sum + ch.scenes.reduce((s, scene) => s + (scene.wordCount || 0), 0), 0);
    return { totalChapters, totalScenes, totalWords };
}

/**
 * [MVVM : View]
 * Met à jour les statistiques globales affichées dans l'interface.
 * Note: Cette fonction dépend de variables globales comme 'project'.
 */
/**
 * [MVVM : View]
 * Met à jour les statistiques globales affichées dans l'interface (Header).
 */
function updateStats() {
    if (typeof project === 'undefined' || !project.acts) return;

    const totalChapters = project.acts.reduce((sum, act) => sum + (act.chapters ? act.chapters.length : 0), 0);

    const totalWords = project.acts.reduce((sum, act) => {
        return sum + (act.chapters ? act.chapters.reduce((chSum, chapter) => {
            return chSum + (chapter.scenes ? chapter.scenes.reduce((sceneSum, scene) => {
                // Prioritize pre-calculated wordCount if available
                return sceneSum + (scene.wordCount || (typeof getWordCount === 'function' ? getWordCount(scene.content) : 0));
            }, 0) : 0);
        }, 0) : 0);
    }, 0);

    // Mettre à jour les stats dans le header
    const headerWords = document.getElementById('headerTotalWords');
    const headerChapters = document.getElementById('headerTotalChapters');
    if (headerWords) headerWords.textContent = `${totalWords.toLocaleString('fr-FR')} mots`;
    if (headerChapters) headerChapters.textContent = `${totalChapters} chapitres`;

    // Mettre à jour le titre du projet dans le header
    const headerTitle = document.getElementById('headerProjectTitle');
    if (headerTitle && project.title) {
        headerTitle.textContent = project.title;
    }

    // Compatibilité avec l'ancien ID si nécessaire (pour d'autres vues refactorisées)
    const totalWordsEl = document.getElementById('totalWordCount');
    if (totalWordsEl) {
        totalWordsEl.textContent = totalWords.toLocaleString('fr-FR');
    }
}

// ========== js-refactor/08.auto-detect.refactor.js ==========
// ============================================
// AUTO-DÉTECTION DES PERSONNAGES ET LIEUX
// ============================================

let autoDetectTimeout = null;

// [MVVM : ViewModel]
// Lance la détection automatique avec un délai (Debounce)
// pour éviter de surcharger pendant la frappe.
function autoDetectLinksDebounced() {
    clearTimeout(autoDetectTimeout);
    autoDetectTimeout = setTimeout(() => {
        autoDetectLinks();
    }, 800); // Délai de 800ms après arrêt de la frappe
}

// [MVVM : ViewModel]
// Accès aux données contextuelles.
// Récupère l'objet "scène" courant depuis le modèle global (project).
function getCurrentScene() {
    if (!currentActId || !currentChapterId || !currentSceneId) return null;

    // On suppose que 'project' est global
    const act = project.acts.find(a => a.id === currentActId);
    if (!act) return null;
    const chapter = act.chapters.find(c => c.id === currentChapterId);
    if (!chapter) return null;

    return chapter.scenes.find(s => s.id === currentSceneId);
}

// [MVVM : Model]
// Utilitaire pur de manipulation de données.
// Modifie un tableau en place (mutation de données).
function removeIdfromArray(arr, id) {
    const index = arr.indexOf(id);
    if (index > -1) {
        arr.splice(index, 1);
        return true;
    }
    return false;
}

// [MVVM : ViewModel]
// Cœur de la logique de détection (Business Logic).
// Analyse le texte et met à jour les listes (Suggérés, Présents, Absents)
function autoDetectLinks() {
    const scene = getCurrentScene();
    if (!scene) return;

    // Obtenir le texte brut de la scène depuis l'éditeur
    let editor = null;
    if (typeof currentSceneId !== 'undefined' && currentSceneId) {
        editor = document.querySelector(`.editor-textarea[data-scene-id="${currentSceneId}"]`);
    }
    // Fallback si pas de sélecteur spécifique ou pas trouvé (ex: vue simple)
    if (!editor) {
        editor = document.querySelector('.editor-textarea');
    }

    if (!editor) return;

    const temp = document.createElement('div');
    temp.innerHTML = editor.innerHTML;
    const sceneText = temp.textContent || temp.innerText || '';

    // Normaliser le texte pour la recherche (sans accents, minuscule)
    const normalizedText = normalizeForSearch(sceneText);

    // Initialiser les tableaux si nécessaire (Migration de données ou création)
    if (!scene.confirmedPresentCharacters) scene.confirmedPresentCharacters = [];
    if (!scene.suggestedCharacters) scene.suggestedCharacters = [];
    if (!scene.confirmedAbsentCharacters) scene.confirmedAbsentCharacters = [];

    // Rétro-compatibilité : si linkedCharacters existe mais pas confirmedPresentCharacters
    if (scene.linkedCharacters && scene.linkedCharacters.length > 0 && scene.confirmedPresentCharacters.length === 0) {
        scene.confirmedPresentCharacters = [...scene.linkedCharacters];
        scene.linkedCharacters = []; // On vide l'ancien tableau
    }

    if (!scene.linkedElements) scene.linkedElements = [];

    let hasChanges = false;

    // ===============================================
    // LOGIQUE PERSONNAGES (3 ÉTATS)
    // ===============================================

    // 1. Identifier les noms de famille ambigus (partagés par plusieurs persos)
    const lastNameCounts = {};
    project.characters.forEach(char => {
        const normalizedLastName = normalizeForSearch(char.lastName || '');
        if (normalizedLastName) {
            lastNameCounts[normalizedLastName] = (lastNameCounts[normalizedLastName] || 0) + 1;
        }
    });

    const ambiguousLastNames = new Set(
        Object.keys(lastNameCounts).filter(name => lastNameCounts[name] > 1)
    );

    // 2. Boucle sur chaque personnage
    project.characters.forEach(char => {

        // --- Construction des patterns de recherche ---
        const namesToDetect = [];

        // A. Nom complet (Priorité haute)
        if (char.name && char.name.trim()) namesToDetect.push(char.name.trim());

        // B. Prénom (Priorité haute)
        if (char.firstName && char.firstName.trim()) namesToDetect.push(char.firstName.trim());

        // C. Surnom (Priorité haute)
        if (char.nickname && char.nickname.trim()) namesToDetect.push(char.nickname.trim());

        // D. Nom de famille (Conditionnel : Seulement si unique)
        if (char.lastName && char.lastName.trim()) {
            const normalizedLastName = normalizeForSearch(char.lastName);
            if (!ambiguousLastNames.has(normalizedLastName)) {
                namesToDetect.push(char.lastName.trim());
            }
        }

        // Nettoyage et normalisation des noms à chercher
        const uniqueNamesNormalized = [...new Set(namesToDetect)]
            .filter(n => n && n.trim())
            .map(name => normalizeForSearch(name));

        // --- Vérification de présence ---
        let isInText = false;
        for (const name of uniqueNamesNormalized) {
            // Regex : \b pour mot entier, 'i' pour insensible à la casse
            const regex = new RegExp('\\b' + escapeRegex(name) + '\\b', 'i');
            if (regex.test(normalizedText)) {
                isInText = true;
                break; // Trouvé ! Pas besoin de chercher les autres variantes
            }
        }

        // --- Gestion des États ---
        const isConfirmedPresent = scene.confirmedPresentCharacters.includes(char.id);
        const isSuggested = scene.suggestedCharacters.includes(char.id);
        const isConfirmedAbsent = scene.confirmedAbsentCharacters.includes(char.id);

        if (isInText) {
            // CAS : Le personnage est DÉTECTÉ dans le texte

            if (!isConfirmedPresent && !isConfirmedAbsent && !isSuggested) {
                // S'il n'est nulle part, on le met en SUGGESTION
                scene.suggestedCharacters.push(char.id);
                hasChanges = true;
            }
            // S'il est déjà confirmé présent ou absent, on ne touche à rien (décision humaine prioritaire)

        } else {
            // CAS : Le personnage n'est PAS DÉTECTÉ

            // S'il était suggéré, on retire la suggestion (c'était un faux positif ou le texte a changé)
            if (isSuggested) {
                removeIdfromArray(scene.suggestedCharacters, char.id);
                hasChanges = true;
            }

            // S'il était confirmé absent (parce que détecté précédemment), on retire cette confirmation
            // pour qu'il puisse être re-suggéré si le nom réapparaît plus tard.
            //if (isConfirmedAbsent) {
            //    removeIdfromArray(scene.confirmedAbsentCharacters, char.id);
            //    hasChanges = true;
            //}

            // Note: S'il est confirmé PRÉSENT, on le laisse. 
            // L'utilisateur peut vouloir lier un perso qui n'est pas explicitement nommé (sous-entendu).
        }
    });

    // ===============================================
    // LOGIQUE LIEUX/ÉLÉMENTS (Classique)
    // ===============================================
    project.world.forEach(elem => {
        const elemNameNormalized = normalizeForSearch(elem.name);
        const regex = new RegExp('\\b' + escapeRegex(elemNameNormalized) + '\\b', 'i');
        const isInText = regex.test(normalizedText);
        const isLinked = scene.linkedElements.includes(elem.id);

        if (isInText && !isLinked) {
            scene.linkedElements.push(elem.id);
            hasChanges = true;
        } else if (!isInText && isLinked) {
            const index = scene.linkedElements.indexOf(elem.id);
            if (index > -1) {
                scene.linkedElements.splice(index, 1);
                hasChanges = true;
            }
        }
    });

    // Mettre à jour si changements détectés
    if (hasChanges) {
        saveProject(); // Important pour IndexedDB
        refreshLinksPanel();
    }
}

// ============================================
// GESTION MANUELLE DES ÉTATS (ACTIONS UTILISATEUR)
// ============================================

// [MVVM : ViewModel]
// Action utilisateur (Command) : L'utilisateur valide la présence (Check)
// Déplace de Suggéré/Absent vers Présent
function confirmCharacterPresence(charId) {
    const scene = getCurrentScene();
    if (!scene) return;

    // 1. Nettoyer les autres listes
    removeIdfromArray(scene.suggestedCharacters, charId);
    removeIdfromArray(scene.confirmedAbsentCharacters, charId);

    // 2. Ajouter aux présents si pas déjà là
    if (!scene.confirmedPresentCharacters.includes(charId)) {
        scene.confirmedPresentCharacters.push(charId);
    }

    saveProject();
    refreshLinksPanel();
}

// [MVVM : ViewModel]
// Action utilisateur (Command) : L'utilisateur refuse la présence (Croix)
// Déplace de Suggéré/Présent vers Absent
function confirmCharacterAbsence(charId) {
    const scene = getCurrentScene();
    if (!scene) return;

    // 1. Nettoyer les autres listes
    removeIdfromArray(scene.suggestedCharacters, charId);
    removeIdfromArray(scene.confirmedPresentCharacters, charId);

    // 2. Ajouter aux absents (liste noire pour cette scène)
    if (!scene.confirmedAbsentCharacters.includes(charId)) {
        scene.confirmedAbsentCharacters.push(charId);
    }

    saveProject();
    refreshLinksPanel();
}

// ============================================
// RENDU VISUEL DU PANNEAU
// ============================================

// Fichier 08.auto-detect.js - REMPLACEMENT TOTAL DE function refreshLinksPanel()

// [MVVM : View]
// Fonction de rendu pur. Construit le DOM du panneau latéral basé sur l'état du Modèle.
function refreshLinksPanel() {
    const linksPanel = document.getElementById('linksPanel');
    if (!linksPanel) return;

    // Si c'est la nouvelle sidebar, utiliser renderLinksPanelSidebar
    if (linksPanel.classList.contains('links-panel-sidebar')) {
        if (typeof renderLinksPanelSidebar === 'function') {
            renderLinksPanelSidebar();
        }
        return;
    }

    const scene = getCurrentScene();
    if (!scene) return;

    const flexDivs = linksPanel.querySelectorAll('[style*="flex: 1"]');

    // --- 1. Rafraîchir les Personnages ---
    if (flexDivs.length >= 1) {
        const charDiv = flexDivs[0];
        const quickLinks = charDiv.querySelector('.quick-links');

        if (quickLinks) {

            // Obtenir les listes de personnages pour le rendu
            const allCharacters = project.characters || [];
            const confirmedIds = scene.confirmedPresentCharacters || [];
            const suggestedIds = scene.suggestedCharacters || [];
            const absentIds = scene.confirmedAbsentCharacters || [];

            // Filtrer les objets personnages complets
            const presentList = allCharacters.filter(c => confirmedIds.includes(c.id));
            const suggestedList = allCharacters.filter(c => suggestedIds.includes(c.id));
            const absentList = allCharacters.filter(c => absentIds.includes(c.id));

            let html = '';

            // ZONE 1 : PRÉSENTS (Validés)
            // L'en-tête est affiché, même si la liste est vide.
            html += '<h4 style="margin: 0 0 8px 0; font-size: 0.8rem; opacity: 0.8; text-align: left;"><i data-lucide="check-circle" style="width: 14px; height: 14px; vertical-align: -2px; margin-right: 4px;"></i> Confirmés Présents</h4>';
            if (presentList.length > 0) {
                html += presentList.map(char => `
                    <div class="link-item present" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            ${getAvatarHTML(char)}
                            <span>${char.name}</span>
                        </div>
                        <button onclick="confirmCharacterAbsence(${char.id})" title="Retirer (Marquer absent)" class="btn-icon">
                            <i data-lucide="x" style="width: 16px; height: 16px;"></i>
                        </button>
                    </div>
                `).join('');
            } else {
                html += '<p class="text-muted small" style="font-size: 0.75rem; margin-bottom: 12px; opacity: 0.7;">Aucun personnage confirmé présent.</p>';
            }


            // ZONE 2 : SUGGÉRÉS (En attente)
            // L'en-tête est affiché, même si la liste est vide.
            html += '<h4 style="margin: 12px 0 8px 0; font-size: 0.8rem; opacity: 0.8; color: var(--accent-color); text-align: left;"><i data-lucide="help-circle" style="width: 14px; height: 14px; vertical-align: -2px; margin-right: 4px;"></i> Suggestions</h4>';
            if (suggestedList.length > 0) {
                html += suggestedList.map(char => `
                    <div class="link-item suggested" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            ${getAvatarHTML(char)}
                            <span>${char.name}</span>
                        </div>
                        <div style="display: flex; gap: 4px;">
                            <button onclick="confirmCharacterAbsence(${char.id})" title="Ignorer" class="btn-icon">
                                <i data-lucide="x" style="width: 16px; height: 16px;"></i>
                            </button>
                            <button onclick="confirmCharacterPresence(${char.id})" title="Valider" class="btn-icon">
                                <i data-lucide="check" style="width: 16px; height: 16px;"></i>
                            </button>
                        </div>
                    </div>
                `).join('');
            } else {
                html += '<p class="text-muted small" style="font-size: 0.75rem; margin-bottom: 12px; opacity: 0.7;">Aucune suggestion.</p>';
            }


            // ZONE 3 : ABSENTS (Ignorés manuellement)
            // L'en-tête est affiché, même si la liste est vide.
            html += '<h4 style="margin: 12px 0 8px 0; font-size: 0.8rem; opacity: 0.8; text-align: left;"><i data-lucide="x-circle" style="width: 14px; height: 14px; vertical-align: -2px; margin-right: 4px;"></i> Confirmés Absents</h4>';
            if (absentList.length > 0) {
                html += absentList.map(char => `
                    <div class="link-item absent" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            ${getAvatarHTML(char)}
                            <span style="text-decoration: line-through;">${char.name}</span>
                        </div>
                        <button onclick="confirmCharacterPresence(${char.id})" title="Rétablir" class="btn-icon">
                            <i data-lucide="rotate-ccw" style="width: 16px; height: 16px;"></i>
                        </button>
                    </div>
                `).join('');
            } else {
                html += '<p class="text-muted small" style="font-size: 0.75rem; margin-bottom: 12px; opacity: 0.7;">Aucun personnage ignoré manuellement.</p>';
            }

            // Bouton d'ajout manuel
            html += `
                <div style="margin-top: 10px; text-align: center;">
                    <button class="btn btn-small" onclick="openCharacterLinker(${currentActId}, ${currentChapterId}, ${currentSceneId})" style="font-size: 0.75rem; padding: 4px 8px; width: 100%;">
                        <i data-lucide="plus" style="width: 12px; height: 12px; vertical-align: middle; margin-right: 4px;"></i> Lier manuellement
                    </button>
                </div>
            `;

            quickLinks.innerHTML = html;
        }
    }

    // --- 2. Rafraîchir les Lieux/Éléments (Nouveau Design) ---
    if (flexDivs.length >= 2) {
        const locationDiv = flexDivs[1];
        const quickLinks = locationDiv.querySelector('.quick-links');

        if (quickLinks) {

            // Les éléments n'ont qu'un seul état (lié ou non)
            const linkedIds = scene.linkedElements || [];
            const linkedElements = (project.world || []).filter(e => linkedIds.includes(e.id));

            let html = '';

            // En-tête + Bouton de liaison
            html += `
                <h4 style="margin: 0 0 8px 0; font-size: 0.8rem; opacity: 0.8; text-align: left;"><i data-lucide="globe" style="width:14px;height:14px;vertical-align:-2px;margin-right:4px;"></i> Éléments Liés</h4>
            `;

            if (linkedElements.length > 0) {
                html += linkedElements.map(elem => {
                    const iconName = getElementIcon(elem.type);
                    return `
                        <div class="link-item present" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                            <div style="display: flex; align-items: center; gap: 8px; flex: 1; min-width: 0;">
                                <i data-lucide="${iconName}" style="width: 20px; height: 20px;"></i>
                                <span style="white-space: nowrap; overflow: hidden; text-overflow: ellipsis;" title="${elem.name} (${elem.type})">${elem.name}</span>
                            </div>
                            <button onclick="toggleElementInScene(${currentActId}, ${currentChapterId}, ${currentSceneId}, ${elem.id}); openScene(${currentActId}, ${currentChapterId}, ${currentSceneId});" title="Délier" class="btn-icon">
                                <i data-lucide="x" style="width: 16px; height: 16px;"></i>
                            </button>
                        </div>
                    `;
                }).join('');
            } else {
                html += '<p class="text-muted small" style="font-size: 0.75rem; margin-bottom: 12px; opacity: 0.7;">Aucun lieu ou élément lié.</p>';
            }

            // Bouton d'ajout manuel
            html += `
                <div style="margin-top: 10px; text-align: center;">
                    <button class="btn btn-small" onclick="openElementLinker(${currentActId}, ${currentChapterId}, ${currentSceneId})" style="font-size: 0.75rem; padding: 4px 8px; width: 100%;">
                        <i data-lucide="plus" style="width: 12px; height: 12px; vertical-align: middle; margin-right: 4px;"></i> Lier manuellement
                    </button>
                </div>
            `;

            quickLinks.innerHTML = html;
        }
    }

    // Réinitialiser les icônes Lucide après injection HTML
    if (typeof lucide !== 'undefined') lucide.createIcons();
}

// [MVVM : View]
// Helper de rendu UI. Détermine l'icône Lucide à utiliser pour un type d'élément.
function getElementIcon(type) {
    switch (type.toLowerCase()) {
        case 'lieu':
        case 'place':
            return 'map-pin';
        case 'objet':
        case 'artifact':
            return 'box';
        case 'organisation':
        case 'group':
        case 'organization': // Ajout sécurité
            return 'landmark';
        case 'concept':
        case 'idée':
            return 'lightbulb';
        default:
            return 'globe'; // Icône par défaut
    }
}

// [MVVM : ViewModel]
// Action utilisateur (Command) : Gère la déliaison d'un personnage (Bascule l'état).
function toggleCharacterLinkerAction(charId) {
    const scene = getCurrentScene();
    if (!scene) return;

    const isConfirmedPresent = scene.confirmedPresentCharacters.includes(charId);

    if (isConfirmedPresent) {
        // Délien: Le retirer de la liste des présents confirmés
        removeIdfromArray(scene.confirmedPresentCharacters, charId);
    } else {
        // Lien: L'ajouter aux présents confirmés
        scene.confirmedPresentCharacters.push(charId);

        // S'assurer qu'il n'est ni suggéré ni absent (la liaison manuelle est prioritaire)
        removeIdfromArray(scene.suggestedCharacters, charId);
        removeIdfromArray(scene.confirmedAbsentCharacters, charId);
    }

    saveProject();

    // Appel au NOUVEAU moteur de rendu pour mettre à jour le panneau des liens principal.
    refreshLinksPanel();
}

// ============================================
// FONCTIONS UTILITAIRES
// ============================================

// Helper pour générer le petit avatar HTML (Image ou Icône)
// [MVVM : View]
// Helper de rendu UI pour les avatars.
function getAvatarHTML(char) {
    if (char.avatarImage) {
        return `<img src="${char.avatarImage}" style="width: 20px; height: 20px; border-radius: 50%; object-fit: cover;">`;
    } else {
        return `<i data-lucide="user" style="width: 16px; height: 16px;"></i>`;
    }
}

// Normaliser le texte pour la recherche (retirer accents, minuscule)
// [MVVM : Model]
// Utilitaire pur de manipulation de string (Normalisation pour recherche)
function normalizeForSearch(text) {
    return text
        .toLowerCase()
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, ''); // Retire les accents
}

// Échapper les caractères spéciaux regex
// [MVVM : Model]
// Utilitaire pur : Échappe les caractères spéciaux regex.
function escapeRegex(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

// Rich Text Formatting (inchangé)
// [MVVM : View]
// Manipulation directe du DOM/API du navigateur pour le formatage.
function formatText(command, value = null) {
    // Cibler l'éditeur spécifique de la scène courante pour éviter le scroll jump
    let selector = '.editor-textarea';
    if (typeof currentSceneId !== 'undefined' && currentSceneId) {
        selector = `.editor-textarea[data-scene-id="${currentSceneId}"]`;
    }

    const editor = document.querySelector(selector);
    if (editor) editor.focus();

    document.execCommand(command, false, value);
}
// [MVVM : View]
// Fonction de rendu pour le panneau des liens en mode sidebar
function renderLinksPanelSidebar() {
    const linksPanelContent = document.getElementById('linksPanelContent');
    if (!linksPanelContent) return;

    const scene = getCurrentScene();
    if (!scene) {
        linksPanelContent.innerHTML = '<p style="text-align: center; color: var(--text-muted); padding: 2rem;">Sélectionnez une scène</p>';
        return;
    }

    // Construire le HTML pour les trois sections
    let html = '';

    // SECTION 1 : PERSONNAGES
    html += '<div style="margin-bottom: 1.5rem;">';
    html += '<div class="quick-links-title" style="font-size: 0.85rem; font-weight: 600; margin-bottom: 0.75rem; color: var(--text-muted);"><i data-lucide="users" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i> Personnages</div>';

    const allCharacters = project.characters || [];
    const confirmedIds = scene.confirmedPresentCharacters || [];
    const suggestedIds = scene.suggestedCharacters || [];
    const absentIds = scene.confirmedAbsentCharacters || [];

    const presentList = allCharacters.filter(c => confirmedIds.includes(c.id));
    const suggestedList = allCharacters.filter(c => suggestedIds.includes(c.id));
    const absentList = allCharacters.filter(c => absentIds.includes(c.id));

    // Présents confirmés
    html += '<h4 style="margin: 0 0 8px 0; font-size: 0.8rem; opacity: 0.8;"><i data-lucide="check-circle" style="width: 14px; height: 14px; vertical-align: -2px; margin-right: 4px;"></i> Confirmés Présents</h4>';
    if (presentList.length > 0) {
        html += presentList.map(char => `
            <div class="link-item present" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                <div style="display: flex; align-items: center; gap: 8px;">
                    ${getAvatarHTML(char)}
                    <span>${char.name}</span>
                </div>
                <button onclick="confirmCharacterAbsence(${char.id})" title="Retirer" class="btn-icon">
                    <i data-lucide="x" style="width: 16px; height: 16px;"></i>
                </button>
            </div>
        `).join('');
    } else {
        html += '<p class="text-muted small" style="font-size: 0.75rem; margin-bottom: 12px; opacity: 0.7;">Aucun personnage confirmé présent.</p>';
    }

    // Suggestions
    html += '<h4 style="margin: 12px 0 8px 0; font-size: 0.8rem; opacity: 0.8; color: var(--accent-color);"><i data-lucide="help-circle" style="width: 14px; height: 14px; vertical-align: -2px; margin-right: 4px;"></i> Suggestions</h4>';
    if (suggestedList.length > 0) {
        html += suggestedList.map(char => `
            <div class="link-item suggested" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                <div style="display: flex; align-items: center; gap: 8px;">
                    ${getAvatarHTML(char)}
                    <span>${char.name}</span>
                </div>
                <div style="display: flex; gap: 4px;">
                    <button onclick="confirmCharacterAbsence(${char.id})" title="Ignorer" class="btn-icon">
                        <i data-lucide="x" style="width: 16px; height: 16px;"></i>
                    </button>
                    <button onclick="confirmCharacterPresence(${char.id})" title="Valider" class="btn-icon">
                        <i data-lucide="check" style="width: 16px; height: 16px;"></i>
                    </button>
                </div>
            </div>
        `).join('');
    } else {
        html += '<p class="text-muted small" style="font-size: 0.75rem; margin-bottom: 12px; opacity: 0.7;">Aucune suggestion.</p>';
    }

    // Absents
    html += '<h4 style="margin: 12px 0 8px 0; font-size: 0.8rem; opacity: 0.8;"><i data-lucide="x-circle" style="width: 14px; height: 14px; vertical-align: -2px; margin-right: 4px;"></i> Confirmés Absents</h4>';
    if (absentList.length > 0) {
        html += absentList.map(char => `
            <div class="link-item absent" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                <div style="display: flex; align-items: center; gap: 8px;">
                    ${getAvatarHTML(char)}
                    <span style="text-decoration: line-through;">${char.name}</span>
                </div>
                <button onclick="confirmCharacterPresence(${char.id})" title="Rétablir" class="btn-icon">
                    <i data-lucide="rotate-ccw" style="width: 16px; height: 16px;"></i>
                </button>
            </div>
        `).join('');
    } else {
        html += '<p class="text-muted small" style="font-size: 0.75rem; margin-bottom: 12px; opacity: 0.7;">Aucun personnage ignoré.</p>';
    }

    html += '</div>';

    // SECTION 2 : UNIVERS
    html += '<div style="margin-bottom: 1.5rem;">';
    html += '<div class="quick-links-title" style="font-size: 0.85rem; font-weight: 600; margin-bottom: 0.75rem; color: var(--text-muted);"><i data-lucide="globe" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i> Univers</div>';
    const locations = (scene.locations || []).map(loc => {
        const locData = project.locations ? project.locations.find(l => l.id === loc.id) : null;
        return locData ? `<div class="link-item" style="margin-bottom: 4px;"><i data-lucide="map-pin" style="width:12px;height:12px;vertical-align:middle;margin-right:4px;"></i>${locData.name}</div>` : '';
    }).join('');
    html += locations || '<p class="text-muted small" style="font-size: 0.75rem; opacity: 0.7;">Aucun lieu.</p>';
    html += '</div>';

    // SECTION 3 : TIMELINE
    html += '<div>';
    html += '<div class="quick-links-title" style="font-size: 0.85rem; font-weight: 600; margin-bottom: 0.75rem; color: var(--text-muted);"><i data-lucide="train-track" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i> Timeline</div>';
    const events = (scene.events || []).map(ev => {
        const evData = project.events ? project.events.find(e => e.id === ev.id) : null;
        return evData ? `<div class="link-item" style="margin-bottom: 4px;"><i data-lucide="calendar" style="width:12px;height:12px;vertical-align:middle;margin-right:4px;"></i>${evData.title}</div>` : '';
    }).join('');
    html += events || '<p class="text-muted small" style="font-size: 0.75rem; opacity: 0.7;">Aucun événement.</p>';
    html += '</div>';

    linksPanelContent.innerHTML = html;

    // Rafraîchir les icônes Lucide
    setTimeout(() => {
        if (typeof lucide !== 'undefined') lucide.createIcons();
    }, 10);
}

// ========== js/09.floating-editor.js ==========
// ============================================
// FLOATING EDITOR MENU (MOBILE)
// ============================================
// GESTES TACTILES POUR L'ÉDITEUR
// ============================================

// [MVVM : View]
// Gère les interactions tactiles sur l'éditeur (zoom, undo/redo gestuels)
function initEditorGestures() {
    const editor = document.querySelector('.editor-textarea');
    if (!editor) return;

    let lastTap = 0;
    let initialPinchDistance = 0;
    let initialFontSize = 16;

    // Double-tap pour mode focus
    editor.addEventListener('touchend', (e) => {
        const currentTime = new Date().getTime();
        const tapLength = currentTime - lastTap;

        if (tapLength < 300 && tapLength > 0) {
            // Double-tap détecté
            e.preventDefault();
            toggleFocusMode();
        }
        lastTap = currentTime;
    });

    // Swipe à 2 doigts pour annuler/refaire
    let touchStartY = 0;
    editor.addEventListener('touchstart', (e) => {
        if (e.touches.length === 2) {
            touchStartY = (e.touches[0].clientY + e.touches[1].clientY) / 2;

            // Calculer distance initiale pour pinch
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            initialPinchDistance = Math.sqrt(dx * dx + dy * dy);

            const computedStyle = window.getComputedStyle(editor);
            initialFontSize = parseFloat(computedStyle.fontSize);
        }
    });

    editor.addEventListener('touchmove', (e) => {
        if (e.touches.length === 2) {
            // Pinch to zoom font size
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            const currentDistance = Math.sqrt(dx * dx + dy * dy);

            const scale = currentDistance / initialPinchDistance;
            const newFontSize = Math.max(12, Math.min(24, initialFontSize * scale));

            editor.style.fontSize = newFontSize + 'px';
        }
    });

    editor.addEventListener('touchend', (e) => {
        if (e.changedTouches.length === 2) {
            const touchEndY = touchStartY;
            const deltaY = touchEndY - touchStartY;

            // Swipe vers le haut = annuler
            if (deltaY < -50) {
                e.preventDefault();
                if (typeof EventBus !== 'undefined') EventBus.emit('history:undo');
                else if (typeof undo === 'function') undo();
            }
            // Swipe vers le bas = refaire
            else if (deltaY > 50) {
                e.preventDefault();
                if (typeof EventBus !== 'undefined') EventBus.emit('history:redo');
                else if (typeof redo === 'function') redo();
            }
        }
    });
}

// ============================================
// FLOATING EDITOR MENU (MOBILE)
// ============================================

let floatingMenuPosition = null;
let isDraggingFloatingMenu = false;
let dragOffset = { x: 0, y: 0 };

// [MVVM : View]
// Initialise le menu flottant, ses références DOM et les événements locaux
function initFloatingEditorMenu() {
    const menu = document.getElementById('floatingEditorMenu');
    const handle = document.getElementById('floatingMenuHandle');
    const toggleBtn = document.getElementById('floatingEditorToggle');

    if (!menu || !handle) {
        console.error('❌ Menu flottant ou handle non trouvé');
        return;
    }

    if (!toggleBtn) {
        console.error('❌ Bouton toggle non trouvé');
        return;
    }

    // Ajouter le listener au bouton toggle
    toggleBtn.addEventListener('click', function (e) {
        e.preventDefault();
        e.stopPropagation();
        toggleFloatingEditorMenu();
    });

    console.log('✅ Menu flottant initialisé');

    // Load saved position or set default
    const savedPos = localStorage.getItem('floatingMenuPosition');
    if (savedPos) {
        try {
            floatingMenuPosition = JSON.parse(savedPos);
            console.log('📍 Position chargée:', floatingMenuPosition);
        } catch (e) {
            console.error('Erreur chargement position:', e);
            floatingMenuPosition = null;
        }
    }

    if (!floatingMenuPosition) {
        // Default position: center of screen
        floatingMenuPosition = {
            x: Math.max(10, (window.innerWidth / 2) - 150),
            y: Math.max(10, (window.innerHeight / 2) - 200)
        };
        console.log('📍 Position par défaut:', floatingMenuPosition);
    }

    // Setup drag - TOUCH
    handle.addEventListener('touchstart', function (e) {
        console.log('👆 TOUCH START - isDragging avant:', isDraggingFloatingMenu);
        isDraggingFloatingMenu = true;
        console.log('👆 TOUCH START - isDragging après:', isDraggingFloatingMenu);

        const touch = e.touches[0];
        const rect = menu.getBoundingClientRect();

        dragOffset.x = touch.clientX - rect.left;
        dragOffset.y = touch.clientY - rect.top;

        handle.style.background = 'var(--accent-red)';
        console.log('🎯 Touch:', touch.clientX, touch.clientY);
        console.log('🎯 Rect:', rect.left, rect.top, rect.width, rect.height);
        console.log('🎯 Drag offset:', dragOffset);

        e.preventDefault();
        e.stopPropagation();
    }, { passive: false });

    // Setup drag - MOUSE (pour test desktop)
    handle.addEventListener('mousedown', function (e) {
        console.log('🖱️ MOUSE DOWN');
        isDraggingFloatingMenu = true;
        const rect = menu.getBoundingClientRect();

        dragOffset.x = e.clientX - rect.left;
        dragOffset.y = e.clientY - rect.top;

        handle.style.background = 'var(--accent-red)';

        e.preventDefault();
        e.stopPropagation();
    });

    console.log('✅ Drag handlers installés sur handle');
}

// TOUCH MOVE - au niveau global
// [MVVM : View]
// Event Handler global : Gère le déplacement visuel du menu via touch
document.addEventListener('touchmove', function (e) {
    console.log('👆 TOUCH MOVE event - isDragging:', isDraggingFloatingMenu);

    if (!isDraggingFloatingMenu) return;

    console.log('👆 TOUCH MOVE - vraiment en train de bouger!');
    const menu = document.getElementById('floatingEditorMenu');
    const handle = document.getElementById('floatingMenuHandle');
    const touch = e.touches[0];

    const newX = touch.clientX - dragOffset.x;
    const newY = touch.clientY - dragOffset.y;

    console.log('📍 Nouvelle position calculée:', newX, newY);

    floatingMenuPosition.x = Math.max(10, Math.min(newX, window.innerWidth - menu.offsetWidth - 10));
    floatingMenuPosition.y = Math.max(10, Math.min(newY, window.innerHeight - menu.offsetHeight - 10));

    console.log('📍 Position finale:', floatingMenuPosition);

    menu.style.transform = 'none';
    menu.style.left = floatingMenuPosition.x + 'px';
    menu.style.top = floatingMenuPosition.y + 'px';

    e.preventDefault();
    e.stopPropagation();
}, { passive: false });

// TOUCH END - au niveau global
// [MVVM : ViewModel]
// Event Handler global : Finalise le déplacement et sauvegarde l'état de position via Persistence
document.addEventListener('touchend', function (e) {
    console.log('👆 TOUCH END - isDragging:', isDraggingFloatingMenu);

    if (!isDraggingFloatingMenu) return;

    console.log('👆 TOUCH END - Position finale:', floatingMenuPosition);
    isDraggingFloatingMenu = false;

    const handle = document.getElementById('floatingMenuHandle');
    if (handle) handle.style.background = 'var(--accent-gold)';

    localStorage.setItem('floatingMenuPosition', JSON.stringify(floatingMenuPosition));
    console.log('💾 Position sauvegardée');
});

// MOUSE MOVE - au niveau global
// [MVVM : View]
// Event Handler global : Gère le déplacement visuel du menu via souris
document.addEventListener('mousemove', function (e) {
    if (!isDraggingFloatingMenu) return;

    console.log('🖱️ MOUSE MOVE');
    const menu = document.getElementById('floatingEditorMenu');

    const newX = e.clientX - dragOffset.x;
    const newY = e.clientY - dragOffset.y;

    floatingMenuPosition.x = Math.max(10, Math.min(newX, window.innerWidth - menu.offsetWidth - 10));
    floatingMenuPosition.y = Math.max(10, Math.min(newY, window.innerHeight - menu.offsetHeight - 10));

    menu.style.transform = 'none';
    menu.style.left = floatingMenuPosition.x + 'px';
    menu.style.top = floatingMenuPosition.y + 'px';

    e.preventDefault();
});

// MOUSE UP - au niveau global
// [MVVM : ViewModel]
// Event Handler global : Finalise le déplacement souris et sauvegarde l'état
document.addEventListener('mouseup', function (e) {
    if (!isDraggingFloatingMenu) return;

    console.log('🖱️ MOUSE UP - Position finale:', floatingMenuPosition);
    isDraggingFloatingMenu = false;

    const handle = document.getElementById('floatingMenuHandle');
    if (handle) handle.style.background = 'var(--accent-gold)';

    localStorage.setItem('floatingMenuPosition', JSON.stringify(floatingMenuPosition));
});

// [MVVM : View]
// Met à jour le DOM du menu selon l'état de position stocké
function updateFloatingMenuPosition() {
    const menu = document.getElementById('floatingEditorMenu');
    if (menu && floatingMenuPosition) {
        menu.style.transform = 'none'; // Annuler le centrage par défaut
        menu.style.left = floatingMenuPosition.x + 'px';
        menu.style.top = floatingMenuPosition.y + 'px';
        console.log('Position mise à jour:', floatingMenuPosition);
    }
}

// [MVVM : View]
// Logique d'affichage : Bascule la visibilité du menu et met à jour l'icône
function toggleFloatingEditorMenu() {
    console.log('toggleFloatingEditorMenu appelée');
    const menu = document.getElementById('floatingEditorMenu');
    const toggle = document.getElementById('floatingEditorToggle');

    console.log('Menu:', menu);
    console.log('Toggle:', toggle);

    if (!menu || !toggle) {
        console.error('Menu ou toggle non trouvé!');
        return;
    }

    if (menu.classList.contains('active')) {
        console.log('Fermeture du menu');
        menu.classList.remove('active');
        toggle.innerHTML = '<i data-lucide="pencil" style="width:16px;height:16px;"></i>';
    } else {
        console.log('Ouverture du menu');
        menu.classList.add('active');
        updateFloatingMenuPosition();
        toggle.innerHTML = '<i data-lucide="x" style="width:16px;height:16px;"></i>';
    }
    if (typeof lucide !== 'undefined') lucide.createIcons();
}

// [MVVM : ViewModel]
// Action : Applique le formatage de bloc sur le contenu
function applyFloatingFormat() {
    const format = document.getElementById('floatingFormatBlock').value;
    document.execCommand('formatBlock', false, format);
    const editor = document.querySelector('.editor-textarea');
    if (editor) editor.focus();
}

// [MVVM : ViewModel]
// Action : Modifie la couleur du texte
function changeFloatingTextColor() {
    const color = document.getElementById('floatingTextColor').value;
    document.execCommand('foreColor', false, color);
    const editor = document.querySelector('.editor-textarea');
    if (editor) editor.focus();
}

// [MVVM : ViewModel]
// Action : Modifie la couleur de fond
function changeFloatingBackgroundColor() {
    const color = document.getElementById('floatingBgColor').value;
    document.execCommand('hiliteColor', false, color);
    const editor = document.querySelector('.editor-textarea');
    if (editor) editor.focus();
}

// [MVVM : ViewModel]
// Action : Logique d'insertion de lien avec interaction utilisateur
function insertLink() {
    const url = prompt('URL du lien :');
    if (url) {
        const selection = window.getSelection();
        if (selection.toString()) {
            document.execCommand('createLink', false, url);
        } else {
            const text = prompt('Texte du lien :');
            if (text) {
                document.execCommand('insertHTML', false, `<a href="${url}" target="_blank">${text}</a>`);
            }
        }
        const editor = document.querySelector('.editor-textarea');
        if (editor) editor.focus();
    }
}

// [MVVM : ViewModel]
// Action : Logique d'insertion d'image
function insertImage() {
    const url = prompt('URL de l\'image :');
    if (url) {
        document.execCommand('insertImage', false, url);
        const editor = document.querySelector('.editor-textarea');
        if (editor) editor.focus();
    }
}

// ============================================
// END FLOATING EDITOR MENU
// ============================================

// ========== js-refactor/10.colorpalette.refactor.js ==========

// Color palette for quick selection - REFACTORED
// [MVVM : Model]
// Source de données pour la palette de couleurs
const colorPalette = [
    '#000000', '#434343', '#666666', '#999999', '#b7b7b7', '#cccccc', '#d9d9d9', '#efefef',
    '#f3f3f3', '#ffffff', '#980000', '#ff0000', '#ff9900', '#ffff00', '#00ff00', '#00ffff',
    '#4a86e8', '#0000ff', '#9900ff', '#ff00ff', '#e6b8af', '#f4cccc', '#fce5cd', '#fff2cc',
    '#d9ead3', '#d0e0e3', '#c9daf8', '#cfe2f3', '#d9d2e9', '#ead1dc', '#dd7e6b', '#ea9999',
    '#f9cb9c', '#ffe599', '#b6d7a8', '#a2c4c9', '#a4c2f4', '#9fc5e8', '#b4a7d6', '#d5a6bd',
    '#cc4125', '#e06666', '#f6b26b', '#ffd966', '#93c47d', '#76a5af', '#6d9eeb', '#6fa8dc',
    '#8e7cc3', '#c27ba0', '#a61c00', '#cc0000', '#e69138', '#f1c232', '#6aa84f', '#45818e',
    '#3c78d8', '#3d85c6', '#674ea7', '#a64d79', '#85200c', '#990000', '#b45f06', '#bf9000',
    '#38761d', '#134f5c', '#1155cc', '#0b5394', '#351c75', '#741b47', '#5b0f00', '#660000'
];

// Initialize color pickers
// ============================================
// SIDEBAR RESIZE
// ============================================

// [MVVM : View]
// Gère la logique UI et les événements du redimensionnement de la sidebar
function initSidebarResize() {
    const sidebar = document.querySelector('.sidebar');
    const resizeHandle = document.getElementById('sidebarResizeHandle');
    const appContainer = document.querySelector('.app-container');

    if (!sidebar || !resizeHandle) return;

    let isResizing = false;
    let startX = 0;
    let startWidth = 0;

    resizeHandle.addEventListener('mousedown', (e) => {
        isResizing = true;
        startX = e.clientX;
        startWidth = sidebar.offsetWidth;

        document.body.style.cursor = 'ew-resize';
        document.body.style.userSelect = 'none';

        e.preventDefault();
    });

    document.addEventListener('mousemove', (e) => {
        if (!isResizing) return;

        const diff = e.clientX - startX;
        const newWidth = startWidth + diff;

        // Respecter min et max width
        if (newWidth >= 200 && newWidth <= 600) {
            sidebar.style.width = newWidth + 'px';
            appContainer.style.gridTemplateColumns = `${newWidth}px 1fr`;
        }
    });

    document.addEventListener('mouseup', () => {
        if (isResizing) {
            isResizing = false;
            document.body.style.cursor = '';
            document.body.style.userSelect = '';

            // Sauvegarder la largeur dans localStorage
            localStorage.setItem('sidebarWidth', sidebar.offsetWidth);
        }
    });

    // Charger la largeur sauvegardée
    const savedWidth = localStorage.getItem('sidebarWidth');
    if (savedWidth) {
        const width = parseInt(savedWidth);
        if (width >= 200 && width <= 600) {
            sidebar.style.width = width + 'px';
            appContainer.style.gridTemplateColumns = `${width}px 1fr`;
        }
    }
}

// [MVVM : View]
// Génère les éléments UI pour les sélecteurs de couleurs
function initializeColorPickers(panel = null) {
    const idSuffix = panel ? `-${panel}` : '';
    const textColorGrid = document.getElementById(`textColorGrid${idSuffix}`);
    const bgColorGrid = document.getElementById(`backgroundColorGrid${idSuffix}`);

    // Vérifier que les éléments existent
    if (!textColorGrid || !bgColorGrid) {
        console.log(`Color pickers ${idSuffix} not found in DOM, skipping initialization`);
        return;
    }

    // Clear existing content if any
    textColorGrid.innerHTML = '';
    bgColorGrid.innerHTML = '';

    colorPalette.forEach(color => {
        // Text color swatch
        const textSwatch = document.createElement('div');
        textSwatch.className = 'color-swatch';
        textSwatch.style.backgroundColor = color;
        textSwatch.title = color;
        textSwatch.onmousedown = (e) => {
            e.preventDefault(); // Prevent focus loss from editor
            applyTextColor(color, panel);
        };
        textColorGrid.appendChild(textSwatch);

        // Background color swatch
        const bgSwatch = document.createElement('div');
        bgSwatch.className = 'color-swatch';
        bgSwatch.style.backgroundColor = color;
        bgSwatch.title = color;
        bgSwatch.onmousedown = (e) => {
            e.preventDefault(); // Prevent focus loss from editor
            applyBackgroundColor(color, panel);
        };
        bgColorGrid.appendChild(bgSwatch);
    });
}

// Toggle color picker dropdown
// [MVVM : View]
// Contrôle la visibilité et le positionnement de l'UI du sélecteur de couleur
function toggleColorPicker(type, event, panel = null) {
    const idSuffix = panel ? `-${panel}` : '';
    const textPicker = document.getElementById(`textColorPicker${idSuffix}`);
    const bgPicker = document.getElementById(`backgroundColorPicker${idSuffix}`);

    if (!textPicker || !bgPicker) return;

    // Obtenir le bouton cliqué pour positionner la popup
    const button = event ? event.currentTarget : null;

    if (type === 'text') {
        const wasActive = textPicker.classList.contains('active');
        bgPicker.classList.remove('active');

        if (!wasActive && button) {
            const rect = button.getBoundingClientRect();
            textPicker.style.top = (rect.bottom + 5) + 'px';
            textPicker.style.left = rect.left + 'px';
        }
        textPicker.classList.toggle('active');
    } else {
        const wasActive = bgPicker.classList.contains('active');
        textPicker.classList.remove('active');

        if (!wasActive && button) {
            const rect = button.getBoundingClientRect();
            bgPicker.style.top = (rect.bottom + 5) + 'px';
            bgPicker.style.left = rect.left + 'px';
        }
        bgPicker.classList.toggle('active');
    }
}

// Apply text color
// [MVVM : View]
// Met à jour la couleur du texte dans l'éditeur et synchronise les inputs UI
function applyTextColor(color, panel = null) {
    const idSuffix = panel ? `-${panel}` : '';
    const textareaId = panel ? `editor-${panel}` : null;
    let textarea = textareaId ? document.getElementById(textareaId) : null;

    if (!textarea && !panel && typeof currentSceneId !== 'undefined' && currentSceneId) {
        textarea = document.querySelector(`.editor-textarea[data-scene-id="${currentSceneId}"]`);
    }

    if (!textarea) textarea = document.querySelector('.editor-textarea');

    // Focus BEFORE applying command to ensure selection is active
    if (textarea) textarea.focus();

    if (panel) {
        // Use the specialized function for panels if it exists
        if (typeof formatTextInPanel === 'function') {
            formatTextInPanel(panel, 'foreColor', color);
        } else {
            document.execCommand('foreColor', false, color);
        }
    } else {
        document.execCommand('foreColor', false, color);
    }

    const input = document.getElementById(`textColorInput${idSuffix}`);
    const hex = document.getElementById(`textColorHex${idSuffix}`);
    if (input) input.value = color;
    if (hex) hex.value = color.toUpperCase();
}

// Apply background color
// [MVVM : View]
// Met à jour la couleur de fond dans l'éditeur et synchronise les inputs UI
function applyBackgroundColor(color, panel = null) {
    const idSuffix = panel ? `-${panel}` : '';
    const textareaId = panel ? `editor-${panel}` : null;
    let textarea = textareaId ? document.getElementById(textareaId) : null;

    if (!textarea && !panel && typeof currentSceneId !== 'undefined' && currentSceneId) {
        textarea = document.querySelector(`.editor-textarea[data-scene-id="${currentSceneId}"]`);
    }

    if (!textarea) textarea = document.querySelector('.editor-textarea');

    // Focus BEFORE applying command to ensure selection is active
    if (textarea) textarea.focus();

    if (panel) {
        if (typeof formatTextInPanel === 'function') {
            formatTextInPanel(panel, 'hiliteColor', color);
        } else {
            document.execCommand('hiliteColor', false, color);
        }
    } else {
        document.execCommand('hiliteColor', false, color);
    }

    const input = document.getElementById(`bgColorInput${idSuffix}`);
    const hex = document.getElementById(`bgColorHex${idSuffix}`);
    if (input) input.value = color;
    if (hex) hex.value = color.toUpperCase();
}

// Close color pickers when clicking outside
document.addEventListener('click', function (event) {
    if (!event.target.closest('.color-picker-wrapper')) {
        document.querySelectorAll('.color-picker-dropdown').forEach(picker => {
            picker.classList.remove('active');
        });
    }
});

// [MVVM : View]
// Gère les raccourcis clavier au sein de l'éditeur
function handleEditorKeydown(event) {
    // Handle keyboard shortcuts
    if (event.ctrlKey || event.metaKey) {
        switch (event.key.toLowerCase()) {
            case 'b':
                event.preventDefault();
                formatText('bold');
                break;
            case 'i':
                event.preventDefault();
                formatText('italic');
                break;
            case 'u':
                event.preventDefault();
                formatText('underline');
                break;
        }
    }
}

// ========== js/11.updateStats.js ==========

(function () {
    if (typeof window === 'undefined') return;
    if (typeof window.updateStats === 'function') return; // migrated implementation present

    // [MVVM : Other]
    // Calcul des statistiques globales (Logique métier) et mise à jour directe de l'interface (View).
    window.updateStats = function () {
        const totalActs = project.acts.length;
        const totalChapters = project.acts.reduce((sum, act) => sum + act.chapters.length, 0);
        const totalWords = project.acts.reduce((sum, act) => {
            return sum + act.chapters.reduce((chSum, chapter) => {
                return chSum + chapter.scenes.reduce((sceneSum, scene) => {
                    return sceneSum + getWordCount(scene.content);
                }, 0);
            }, 0);
        }, 0);

        // Mettre à jour les stats dans le header
        const headerWords = document.getElementById('headerTotalWords');
        const headerChapters = document.getElementById('headerTotalChapters');
        if (headerWords) headerWords.textContent = `${totalWords} mots`;
        if (headerChapters) headerChapters.textContent = `${totalChapters} chapitres`;

        // Mettre à jour le titre du projet dans le header
        const headerTitle = document.getElementById('headerProjectTitle');
        if (headerTitle) headerTitle.textContent = project.title;
    };
})();
// ========== js/12.import-export.js ==========

// Backup and Import Management
// [MVVM : View]
// Gère l'affichage du modal de sauvegarde
function showBackupMenu() {
    document.getElementById('backupModal').classList.add('active');
}

// [MVVM : Other]
// Convertit le Model en JSON et gère le téléchargement (View) - Mixte
function exportToJSON() {
    const dataStr = JSON.stringify(project, null, 2);
    const blob = new Blob([dataStr], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    const filename = `${project.title.replace(/\s+/g, '_')}_${new Date().toISOString().split('T')[0]}.json`;
    a.download = filename;
    a.click();
    URL.revokeObjectURL(url);

    alert(`? Fichier JSON téléchargé !\n\nNom : ${filename}\n\nTu peux maintenant l'uploader sur Google Drive, Dropbox, ou tout autre service cloud.`);
}

// [MVVM : View]
// Interaction simple pour ouvrir le sélecteur de fichier
function importFromFile() {
    document.getElementById('importFileInput').click();
}

// [MVVM : Other]
// Lit le fichier (View), valide et met à jour le Model, puis rafraîchit l'UI (View) - Mixte
function handleFileImport(event) {
    const file = event.target.files[0];
    if (!file) return;

    if (!file.name.endsWith('.json')) {
        alert('? Erreur : Le fichier doit être au format JSON');
        return;
    }

    if (!confirm('?? ATTENTION : L\'import va remplacer toutes vos données actuelles.\n\nVoulez-vous créer une sauvegarde avant de continuer ?')) {
        event.target.value = ''; // Reset input
        return;
    }

    // Create backup before import
    exportToJSON();

    const reader = new FileReader();
    reader.onload = function (e) {
        try {
            const importedData = JSON.parse(e.target.result);

            // Validate imported data
            if (!importedData.acts || !Array.isArray(importedData.acts)) {
                throw new Error('Format de fichier invalide');
            }

            // Merge with current structure to ensure all fields exist
            project = {
                title: importedData.title || "Mon Roman",
                acts: importedData.acts || [],
                characters: importedData.characters || [],
                world: importedData.world || [],
                timeline: importedData.timeline || [],
                notes: importedData.notes || [],
                codex: importedData.codex || [],
                stats: importedData.stats || {
                    dailyGoal: 500,
                    totalGoal: 80000,
                    writingSessions: []
                },
                versions: importedData.versions || []
            };

            saveProject();
            switchView('editor');
            renderActsList();
            closeModal('backupModal');

            alert('? Import réussi !\n\nToutes vos données ont été restaurées.');
        } catch (error) {
            alert('? Erreur lors de l\'import : ' + error.message);
        }

        event.target.value = ''; // Reset input
    };

    reader.onerror = function () {
        alert('? Erreur lors de la lecture du fichier');
        event.target.value = ''; // Reset input
    };

    reader.readAsText(file);
}

// Export
// [MVVM : Other]
// Formatte les données du Model pour l'export texte et déclenche le téléchargement (View) - Mixte
function exportProject() {
    let text = `${project.title}\n${'='.repeat(project.title.length)}\n\n`;

    project.acts.forEach(act => {
        text += `\n\n${act.title}\n${'='.repeat(act.title.length)}\n\n`;

        act.chapters.forEach(chapter => {
            text += `\n${chapter.title}\n${'-'.repeat(chapter.title.length)}\n\n`;
            chapter.scenes.forEach(scene => {
                // Convert HTML to plain text for export
                const temp = document.createElement('div');
                temp.innerHTML = scene.content;
                const plainText = temp.textContent || temp.innerText || '';

                text += `\n${scene.title}\n\n${plainText}\n\n`;
            });
        });
    });

    const blob = new Blob([text], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${project.title.replace(/\s+/g, '_')}.txt`;
    a.click();
    URL.revokeObjectURL(url);
}

// Modal Management
// [MVVM : View]
// Affiche le modal d'ajout d'acte (DOM)
function openAddActModal() {
    document.getElementById('addActModal').classList.add('active');
    setTimeout(() => document.getElementById('actTitleInput').focus(), 100);
}

// [MVVM : Other]
// Logique de sélection d'acte (ViewModel) et manipulation DOM (View) - Mixte
function openAddChapterModal(actId) {
    // Si pas d'actId fourni, utiliser le premier acte ou on en créera un
    if (actId) {
        activeActId = actId;
    } else if (project.acts.length > 0) {
        activeActId = project.acts[0].id;
    } else {
        activeActId = null; // Sera créé dans addChapter
    }
    document.getElementById('addChapterModal').classList.add('active');
    setTimeout(() => document.getElementById('chapterTitleInput').focus(), 100);
}

// [MVVM : View]
// Manipulation DOM pour fermer les modales
function closeModal(modalId) {
    document.getElementById(modalId).classList.remove('active');
}

// ========== js/13.mobile-menu.js ==========


// ========================================
// MOBILE MENU FUNCTIONS
// ========================================

// [MVVM : View]
// Manipulation directe du DOM pour la sidebar mobile (classList, style).
function toggleMobileSidebar() {
    const sidebar = document.querySelector('.sidebar');
    const overlay = document.querySelector('.sidebar-overlay');
    const handle = document.querySelector('.mobile-menu-handle');

    console.log('?? toggleMobileSidebar appelé');
    console.log('Sidebar:', sidebar);
    console.log('Overlay:', overlay);
    console.log('Handle:', handle);

    // Toggle sidebar
    sidebar.classList.toggle('mobile-open');

    console.log('Sidebar classes:', sidebar.className);
    console.log('Sidebar mobile-open?', sidebar.classList.contains('mobile-open'));

    // Toggle overlay and handle
    if (sidebar.classList.contains('mobile-open')) {
        overlay.style.display = 'block';
        setTimeout(() => overlay.classList.add('active'), 10);
        if (handle) handle.classList.add('hidden');
        // Prevent body scroll when menu is open
        document.body.style.overflow = 'hidden';
        console.log('?  Sidebar ouverte');
    } else {
        overlay.classList.remove('active');
        setTimeout(() => overlay.style.display = 'none', 300);
        if (handle) handle.classList.remove('hidden');
        // Restore body scroll
        document.body.style.overflow = '';
        console.log('? Sidebar fermée');
    }
}

// [MVVM : View]
// Manipulation directe du DOM pour fermer la sidebar.
function closeMobileSidebar() {
    const sidebar = document.querySelector('.sidebar');
    const overlay = document.querySelector('.sidebar-overlay');
    const handle = document.querySelector('.mobile-menu-handle');

    if (sidebar.classList.contains('mobile-open')) {
        sidebar.classList.remove('mobile-open');
        overlay.classList.remove('active');
        setTimeout(() => overlay.style.display = 'none', 300);
        if (handle) handle.classList.remove('hidden');
        document.body.style.overflow = '';
    }
}

// ========================================
// MOBILE NAVIGATION FUNCTIONS
// ========================================

// [MVVM : View]
// Gestion de l'affichage du menu de navigation mobile (DOM + SVG).
function toggleMobileNav() {
    const dropdown = document.getElementById('mobileNavDropdown');
    const toggleBtn = document.getElementById('mobileNavToggleBtn');
    const sidebar = document.querySelector('.sidebar');

    // Icône Lucid 'Menu' (pour ouvrir)
    const menuIcon = `
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-menu">
                    <line x1="4" x2="20" y1="12" y2="12"/>
                    <line x1="4" x2="20" y1="6" y2="6"/>
                    <line x1="4" x2="20" y1="18" y2="18"/>
                </svg>
            `;

    // Icône Lucid 'X' (pour fermer)
    const closeIcon = `
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-x">
                    <path d="M18 6 6 18"/>
                    <path d="m6 6 12 12"/>
                </svg>
            `;

    // Déterminez si le menu est actif (ouvert)
    if (dropdown.classList.contains('active')) {
        // Fermer le menu
        dropdown.classList.remove('active');
        toggleBtn.innerHTML = menuIcon; // Remplacer par l'icône 'Menu'
        if (sidebar) sidebar.style.visibility = '';
    } else {
        // Ouvrir le menu
        dropdown.classList.add('active');
        toggleBtn.innerHTML = closeIcon; // Remplacer par l'icône 'X'
        if (sidebar) sidebar.style.visibility = 'hidden';
    }
}

// [MVVM : View]
// Fermeture du menu de navigation mobile (DOM).
function closeMobileNav() {
    const dropdown = document.getElementById('mobileNavDropdown');
    const toggleBtn = document.getElementById('mobileNavToggleBtn');
    const sidebar = document.querySelector('.sidebar');

    if (dropdown && dropdown.classList.contains('active')) {
        dropdown.classList.remove('active');
        // Icône Lucid 'Menu' (pour ouvrir)
        toggleBtn.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-menu">
                    <line x1="4" x2="20" y1="12" y2="12"/>
                    <line x1="4" x2="20" y1="6" y2="6"/>
                    <line x1="4" x2="20" y1="18" y2="18"/>
                </svg>
            `;
        if (sidebar) sidebar.style.visibility = '';
    }
}

// [MVVM : View]
// Mise à jour de l'état UI actif et appel d'une fonction de changement de vue.
function switchViewMobile(view) {
    // Update active state in mobile menu
    document.querySelectorAll('.mobile-nav-item').forEach(item => {
        item.classList.remove('active');
    });
    const activeItem = document.querySelector(`[data-view="${view}"]`);
    if (activeItem) {
        activeItem.classList.add('active');
    }

    // Close mobile nav
    closeMobileNav();

    // Switch to the view
    switchView(view);
}

// ========================================
// MOBILE EDITOR TOOLBAR FUNCTIONS
// ========================================

// [MVVM : View]
// Affichage/Masquage de la barre d'outils (DOM).
function toggleEditorToolbar() {
    const toolbar = document.getElementById('editorToolbar');
    const toggleText = document.getElementById('toolbarToggleText');
    const toggleBtn = document.querySelector('.toolbar-mobile-toggle');

    if (toolbar.classList.contains('expanded')) {
        toolbar.classList.remove('expanded');
        toggleText.innerHTML = '<i data-lucide="pen-line" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Afficher les outils de formatage';
        if (toggleBtn) toggleBtn.classList.remove('expanded');
        if (typeof lucide !== 'undefined') lucide.createIcons();
    } else {
        toolbar.classList.add('expanded');
        toggleText.innerHTML = '<i data-lucide="x" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Masquer les outils de formatage';
        if (toggleBtn) toggleBtn.classList.add('expanded');
        if (typeof lucide !== 'undefined') lucide.createIcons();
    }
}

// [MVVM : View]
// Affichage/Masquage du panneau de liens (DOM).
function toggleLinksPanel() {
    const panel = document.getElementById('linksPanel');
    const toggleText = document.getElementById('linksPanelToggleText');
    const toggleBtn = document.querySelector('.links-panel-toggle');

    if (panel.classList.contains('expanded')) {
        panel.classList.remove('expanded');
        if (toggleText) toggleText.innerHTML = '<i data-lucide="chevron-right" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Afficher personnages & lieux liés';
        if (toggleBtn) toggleBtn.classList.remove('expanded');
        if (typeof lucide !== 'undefined') lucide.createIcons();
    } else {
        panel.classList.add('expanded');
        if (toggleText) toggleText.innerHTML = '<i data-lucide="chevron-down" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Masquer personnages & lieux liés';
        if (toggleBtn) toggleBtn.classList.add('expanded');
        if (typeof lucide !== 'undefined') lucide.createIcons();
    }
}

// [MVVM : View]
// Interaction complexe entre deux éléments d'interface (menu flottant et toolbar).
function toggleToolbarFromFloating() {
    // Fermer le menu flottant
    const floatingMenu = document.getElementById('floatingEditorMenu');
    const floatingToggle = document.getElementById('floatingEditorToggle');

    if (floatingMenu && floatingMenu.classList.contains('active')) {
        floatingMenu.classList.remove('active');
        if (floatingToggle) floatingToggle.innerHTML = '<i data-lucide="pencil" style="width:16px;height:16px;"></i>';
    }

    // Ouvrir le toolbar complet
    const toolbar = document.getElementById('editorToolbar');
    const toggleText = document.getElementById('toolbarToggleText');
    const toggleBtn = document.querySelector('.toolbar-mobile-toggle');

    if (toolbar && !toolbar.classList.contains('expanded')) {
        toolbar.classList.add('expanded');
        if (toggleText) toggleText.textContent = 'Masquer les outils de formatage';
        if (toggleBtn) toggleBtn.classList.add('expanded');
    }

    // Scroll vers le toolbar pour le rendre visible
    setTimeout(() => {
        if (toolbar) {
            toolbar.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
    }, 100);
}

// [MVVM : View]
// Gestion de l'affichage du menu avancé (DOM + Style).
function toggleAdvancedMenu() {
    const advancedBar = document.getElementById('advancedMenuBar');
    const advancedBtn = document.getElementById('advancedMenuBtn');

    console.log('Toggle advanced menu clicked');
    console.log('Advanced bar found:', !!advancedBar);
    console.log('Current display:', advancedBar ? window.getComputedStyle(advancedBar).display : 'not found');

    if (advancedBar.classList.contains('active')) {
        console.log('Hiding advanced menu');
        advancedBar.classList.remove('active');
        advancedBtn.style.background = '';
    } else {
        console.log('Showing advanced menu');
        advancedBar.classList.add('active');
        advancedBtn.style.background = 'rgba(255,215,0,0.3)';

        // Force display after a tick
        setTimeout(() => {
            console.log('After timeout display:', window.getComputedStyle(advancedBar).display);
        }, 10);
    }
}

// [MVVM : Other]
// Interaction utilisateur (Prompt) -> Appel logique métier (formatText). (Mixte)
function insertLink() {
    const url = prompt('Entrez l\'URL du lien:');
    if (url) {
        formatText('createLink', url);
    }
}

// [MVVM : View]
// Surcharge d'une fonction existante pour ajouter un comportement purement visuel (fermer sidebar).
// Override switchView to close mobile sidebar
const originalSwitchView = switchView;
switchView = function (view) {
    if (window.innerWidth <= 900) {
        closeMobileSidebar();
    }
    originalSwitchView(view);
};

// Détection dynamique du débordement du header
// [MVVM : View]
// Calcul de dimensions et ajustement de classes CSS en fonction de l'espace disponible.
function checkHeaderOverflow() {
    const header = document.querySelector('.app-header');
    const headerNav = document.querySelector('.header-nav');
    const body = document.body;

    if (!header || !headerNav) return;

    // Temporairement forcer le mode desktop pour mesurer
    body.classList.remove('force-mobile-nav');

    // Attendre le reflow
    requestAnimationFrame(() => {
        const headerWidth = header.offsetWidth;
        const logoWidth = document.querySelector('.app-logo')?.offsetWidth || 0;
        const actionsWidth = document.querySelector('.header-actions')?.offsetWidth || 0;
        const navWidth = headerNav.scrollWidth;
        const availableSpace = headerWidth - logoWidth - actionsWidth - 60; // 60px de marge

        if (navWidth > availableSpace) {
            body.classList.add('force-mobile-nav');
        } else {
            body.classList.remove('force-mobile-nav');
        }
    });
}

// Handle window resize
let resizeTimeout;
window.addEventListener('resize', function () {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(function () {
        // Vérifier le débordement du header
        checkHeaderOverflow();

        // If resizing to desktop, ensure sidebar is visible and overlay hidden
        if (window.innerWidth > 900 && !document.body.classList.contains('force-mobile-nav')) {
            const sidebar = document.querySelector('.sidebar');
            const overlay = document.querySelector('.sidebar-overlay');
            const menuBtn = document.querySelector('.mobile-menu-toggle');

            if (sidebar) sidebar.classList.remove('mobile-open');
            if (overlay) {
                overlay.classList.remove('active');
                overlay.style.display = 'none';
            }
            if (menuBtn) {
                menuBtn.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-menu">
                        <line x1="4" x2="20" y1="12" y2="12"/>
                        <line x1="4" x2="20" y1="6" y2="6"/>
                        <line x1="4" x2="20" y1="18" y2="18"/>
                    </svg>
                `;
            }
            document.body.style.overflow = '';
        }
    }, 100);
});

// Vérifier au chargement
window.addEventListener('load', function () {
    setTimeout(checkHeaderOverflow, 100);
});

// ========== js/14.dragndrop-acts.js ==========

// Drag and Drop for Acts
let draggedAct = null;

/**
 * @MVVM : View
 * Configure le glisser-déposer pour les actes
 */
function setupActDragAndDrop() {
    const actHeaders = document.querySelectorAll('.act-header');

    actHeaders.forEach(header => {
        const dragHandle = header.querySelector('.drag-handle');
        if (!dragHandle) return;

        dragHandle.addEventListener('dragstart', (e) => {
            draggedAct = parseInt(header.dataset.actId);
            header.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('type', 'act');
            e.stopPropagation(); // Empêcher le clic de se propager
        });

        dragHandle.addEventListener('dragend', (e) => {
            header.classList.remove('dragging');
            draggedAct = null;
        });

        header.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';

            const targetActId = parseInt(e.currentTarget.dataset.actId);
            if (draggedAct && draggedAct !== targetActId) {
                e.currentTarget.classList.add('drag-over');
            }
        });

        header.addEventListener('dragleave', (e) => {
            e.currentTarget.classList.remove('drag-over');
        });

        header.addEventListener('drop', (e) => {
            e.preventDefault();
            e.currentTarget.classList.remove('drag-over');

            const targetActId = parseInt(e.currentTarget.dataset.actId);

            if (draggedAct && draggedAct !== targetActId) {
                reorderActs(draggedAct, targetActId);
            }
        });
    });
}

/**
 * @MVVM : ViewModel
 * Réorganise les actes après un glisser-déposer
 */
function reorderActs(draggedId, targetId) {
    const draggedIndex = project.acts.findIndex(a => a.id === draggedId);
    const targetIndex = project.acts.findIndex(a => a.id === targetId);

    if (draggedIndex === -1 || targetIndex === -1) return;

    const [removed] = project.acts.splice(draggedIndex, 1);
    project.acts.splice(targetIndex, 0, removed);

    saveProject();
    renderActsList();
}

// Drag and Drop for Chapters
let draggedChapter = { chapterId: null, actId: null };

/**
 * @MVVM : View
 * Configure le glisser-déposer pour les chapitres
 */
function setupChapterDragAndDrop() {
    const chapterHeaders = document.querySelectorAll('.chapter-header');

    chapterHeaders.forEach(header => {
        const dragHandle = header.querySelector('.drag-handle');
        if (!dragHandle) return;

        dragHandle.addEventListener('dragstart', (e) => {
            draggedChapter.chapterId = parseInt(header.dataset.chapterId);
            draggedChapter.actId = parseInt(header.dataset.actId);
            header.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('type', 'chapter');
            e.stopPropagation(); // Empêcher le clic de se propager
        });

        dragHandle.addEventListener('dragend', (e) => {
            header.classList.remove('dragging');
            draggedChapter = { chapterId: null, actId: null };
        });

        header.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';

            const targetChapterId = parseInt(e.currentTarget.dataset.chapterId);
            const targetActId = parseInt(e.currentTarget.dataset.actId);

            if (draggedChapter.chapterId && draggedChapter.chapterId !== targetChapterId) {
                e.currentTarget.classList.add('drag-over');
            } else if (draggedScene.sceneId && draggedScene.chapterId !== targetChapterId) {
                e.currentTarget.classList.add('drag-over');
            }
        });

        header.addEventListener('dragleave', (e) => {
            e.currentTarget.classList.remove('drag-over');
        });

        header.addEventListener('drop', (e) => {
            e.preventDefault();
            e.currentTarget.classList.remove('drag-over');

            const targetChapterId = parseInt(e.currentTarget.dataset.chapterId);
            const targetActId = parseInt(e.currentTarget.dataset.actId);

            if (draggedChapter.chapterId && draggedChapter.chapterId !== targetChapterId) {
                reorderChapters(draggedChapter.chapterId, draggedChapter.actId, targetChapterId, targetActId);
            } else if (draggedScene.sceneId && draggedScene.chapterId !== targetChapterId) {
                moveSceneToChapter(draggedScene.sceneId, draggedScene.actId, draggedScene.chapterId, targetActId, targetChapterId);
            }
        });
    });
}

/**
 * @MVVM : ViewModel
 * Réorganise les chapitres après un glisser-déposer
 */
function reorderChapters(draggedChapterId, draggedActId, targetChapterId, targetActId) {
    const sourceAct = project.acts.find(a => a.id === draggedActId);
    const targetAct = project.acts.find(a => a.id === targetActId);

    if (!sourceAct || !targetAct) return;

    const draggedIndex = sourceAct.chapters.findIndex(c => c.id === draggedChapterId);
    const targetIndex = targetAct.chapters.findIndex(c => c.id === targetChapterId);

    if (draggedIndex === -1 || targetIndex === -1) return;

    const [removed] = sourceAct.chapters.splice(draggedIndex, 1);

    if (draggedActId === targetActId) {
        targetAct.chapters.splice(targetIndex, 0, removed);
    } else {
        targetAct.chapters.splice(targetIndex, 0, removed);
    }

    saveProject();
    renderActsList();
}

// Drag and Drop for Scenes
let draggedScene = { sceneId: null, chapterId: null, actId: null };

/**
 * @MVVM : View
 * Configure le glisser-déposer pour les scènes
 */
function setupSceneDragAndDrop() {
    const sceneItems = document.querySelectorAll('.scene-item.draggable');

    sceneItems.forEach(item => {
        item.addEventListener('dragstart', (e) => {
            draggedScene.sceneId = parseInt(e.target.dataset.sceneId);
            draggedScene.chapterId = parseInt(e.target.dataset.chapterId);
            draggedScene.actId = parseInt(e.target.dataset.actId);
            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
        });

        item.addEventListener('dragend', (e) => {
            e.target.classList.remove('dragging');
            draggedScene = { sceneId: null, chapterId: null, actId: null };
        });

        item.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';

            const targetSceneId = parseInt(e.currentTarget.dataset.sceneId);
            const targetChapterId = parseInt(e.currentTarget.dataset.chapterId);

            if (draggedScene.sceneId && draggedScene.sceneId !== targetSceneId) {
                e.currentTarget.classList.add('drag-over');
            }
        });

        item.addEventListener('dragleave', (e) => {
            e.currentTarget.classList.remove('drag-over');
        });

        item.addEventListener('drop', (e) => {
            e.preventDefault();
            e.currentTarget.classList.remove('drag-over');

            const targetSceneId = parseInt(e.currentTarget.dataset.sceneId);
            const targetChapterId = parseInt(e.currentTarget.dataset.chapterId);
            const targetActId = parseInt(e.currentTarget.dataset.actId);

            if (draggedScene.sceneId && draggedScene.sceneId !== targetSceneId) {
                reorderScenes(
                    draggedScene.sceneId,
                    draggedScene.actId,
                    draggedScene.chapterId,
                    targetSceneId,
                    targetActId,
                    targetChapterId
                );
            }
        });
    });
}

/**
 * @MVVM : ViewModel
 * Réorganise les scènes après un glisser-déposer
 */
function reorderScenes(draggedSceneId, draggedActId, draggedChapterId, targetSceneId, targetActId, targetChapterId) {
    const sourceAct = project.acts.find(a => a.id === draggedActId);
    const targetAct = project.acts.find(a => a.id === targetActId);

    if (!sourceAct || !targetAct) return;

    const sourceChapter = sourceAct.chapters.find(c => c.id === draggedChapterId);
    const targetChapter = targetAct.chapters.find(c => c.id === targetChapterId);

    if (!sourceChapter || !targetChapter) return;

    const draggedIndex = sourceChapter.scenes.findIndex(s => s.id === draggedSceneId);
    const targetIndex = targetChapter.scenes.findIndex(s => s.id === targetSceneId);

    if (draggedIndex === -1 || targetIndex === -1) return;

    const [removed] = sourceChapter.scenes.splice(draggedIndex, 1);

    if (draggedChapterId === targetChapterId) {
        targetChapter.scenes.splice(targetIndex, 0, removed);
    } else {
        targetChapter.scenes.splice(targetIndex, 0, removed);
    }

    saveProject();
    renderActsList();
}

/**
 * @MVVM : Other
 * Group: Use Case | Naming: MoveSceneToChapterUseCase
 * Déplace une scène vers un autre chapitre (Mixte Model/View)
 */
function moveSceneToChapter(sceneId, sourceActId, sourceChapterId, targetActId, targetChapterId) {
    const sourceAct = project.acts.find(a => a.id === sourceActId);
    const targetAct = project.acts.find(a => a.id === targetActId);

    if (!sourceAct || !targetAct) return;

    const sourceChapter = sourceAct.chapters.find(c => c.id === sourceChapterId);
    const targetChapter = targetAct.chapters.find(c => c.id === targetChapterId);

    if (!sourceChapter || !targetChapter) return;

    const sceneIndex = sourceChapter.scenes.findIndex(s => s.id === sceneId);
    if (sceneIndex === -1) return;

    const [removed] = sourceChapter.scenes.splice(sceneIndex, 1);
    targetChapter.scenes.push(removed);

    saveProject();
    renderActsList();

    // Auto-expand target chapter
    setTimeout(() => {
        const targetChapterElement = document.getElementById(`chapter-${targetChapterId}`);
        if (targetChapterElement) {
            const icon = targetChapterElement.querySelector('.chapter-icon');
            const scenesList = targetChapterElement.querySelector('.scenes-list');
            if (!scenesList.classList.contains('visible')) {
                icon.classList.add('expanded');
                scenesList.classList.add('visible');
            }
        }
    }, 100);
}

// ========== js-refactor/characters/characters.model.js ==========
/**
 * [MVVM : Characters Model]
 * Définition de la structure de données et usines pour les personnages.
 */

const CharacterModel = {
    /**
     * Crée un nouvel objet personnage avec les valeurs par défaut.
     */
    create(data = {}) {
        const id = data.id || Date.now();
        const name = data.name || '';

        return {
            id: id,
            // État civil
            firstName: data.firstName || name.split(' ')[0] || '',
            lastName: data.lastName || name.split(' ').slice(1).join(' ') || '',
            nickname: data.nickname || '',
            pronouns: data.pronouns || '',
            sex: data.sex || '',
            race: data.race || 'Humain',
            group: data.group || '',
            age: data.age || '',
            birthDate: data.birthDate || '',
            deathDate: data.deathDate || '',
            birthPlace: data.birthPlace || '',
            deathPlace: data.deathPlace || '',
            residence: data.residence || '',
            occupation: data.occupation || '',
            // Header
            name: name || `${data.firstName || ''} ${data.lastName || ''}`.trim(),
            role: data.role || '',
            roleImportance: data.roleImportance || 3, // 1-5 stars
            avatarEmoji: data.avatarEmoji || '👤',
            avatarImage: data.avatarImage || '',
            // Physique
            height: data.height || '',
            weight: data.weight || '',
            bodyType: data.bodyType || '',
            hairColor: data.hairColor || '',
            eyeColor: data.eyeColor || '',
            voice: data.voice || '',
            clothing: data.clothing || '',
            accessories: data.accessories || '',
            physicalDescription: data.physicalDescription || data.appearance || '',
            // Caractère
            traits: data.traits || [],
            tastes: data.tastes || '',
            habits: data.habits || '',
            fears: data.fears || '',
            // Personnalité radar (0-20)
            personality: data.personality || {
                intelligence: 10,
                force: 10,
                robustesse: 10,
                empathie: 10,
                perception: 10,
                agilite: 10,
                sociabilite: 10
            },
            // Profil
            education: data.education || '',
            wealth: data.wealth !== undefined ? data.wealth : 50, // 0-100 slider
            secrets: data.secrets || '',
            beliefs: data.beliefs || '',
            importantPlaces: data.importantPlaces || '',
            catchphrases: data.catchphrases || '',
            // Évolution
            goals: data.goals || '',
            past: data.past || data.background || '',
            present: data.present || '',
            future: data.future || '',
            // Inventaire & Possessions
            inventory: data.inventory || [],
            possessions: data.possessions || [],
            // Autres
            notes: data.notes || '',
            // Legacy / metadata
            updatedAt: data.updatedAt || Date.now(),
            createdAt: data.createdAt || id
        };
    },

    /**
     * Migre un ancien objet personnage vers la nouvelle structure.
     */
    migrate(char) {
        if (!char) return null;

        // Si déjà migré (présence de firstName par exemple), on vérifie juste les champs manquants
        const migrated = this.create(char);

        // Cas particuliers de migration
        if (!char.personality || typeof char.personality === 'string') {
            const oldPersonality = char.personality || '';
            migrated.personality = {
                intelligence: 10,
                force: 10,
                robustesse: 10,
                empathie: 10,
                perception: 10,
                agilite: 10,
                sociabilite: 10
            };
            if (oldPersonality) migrated.notes = (migrated.notes || '') + '\n\nPersonnalité (ancien):\n' + oldPersonality;
        }

        return migrated;
    }
};

/**
 * Configuration des sections de traits de caractère
 */
const TRAIT_SECTIONS = {
    'emotional': {
        icon: 'brain-circuit',
        label: 'Aspect Émotionnel',
        categories: {
            'adversity': { icon: 'shield-half', label: 'Réaction face à l\'adversité', traits: ['Résilient', 'Fragile', 'Agressif', 'Évasif', 'Persévérant', 'Courageux'] },
            'information': { icon: 'brain', label: 'Traitement de l\'information', traits: ['Analytique', 'Intuitif', 'Réfléchi', 'Impulsif', 'Distrait'] },
            'emotions': { icon: 'heart', label: 'Gestion des émotions', traits: ['Expressif', 'Réservé', 'Explosif', 'Équilibré', 'Empathique', 'Apathique', 'Passionné', 'Téméraire'] },
            'motivations': { icon: 'target', label: 'Motivations principales', traits: ['Ambition', 'Curiosité', 'Besoin de sécurité', 'Besoin d\'approbation', 'Quête de sens'] },
            'social': { icon: 'user-check', label: 'Interactions sociales', traits: ['Leader', 'Suiveur', 'Confiant', 'Timide', 'Solitaire', 'Mystérieux', 'Médiateur', 'Manipulateur', 'Pédagogue'] },
            'change': { icon: 'repeat-2', label: 'Gestion du changement', traits: ['Adaptatif', 'Résistant', 'Enthousiaste', 'Craintif', 'Indécis'] },
            'self': { icon: 'eye', label: 'Vision de soi', traits: ['Confiant', 'Insécure', 'Narcissique', 'Humble', 'Critique'] },
            'intimacy': { icon: 'heart-handshake', label: 'Rapport à l\'intimité', traits: ['Prude', 'Pudique', 'Romantique', 'Discret', 'Réservé', 'Ouvert', 'Extraverti'] },
            'sexuality': { icon: 'flame', label: 'Rapport à la sexualité', traits: ['Sensuel', 'Chaste', 'Timide', 'Décomplexé', 'Romantique', 'Passionné', 'Libertin', 'Asexuel'] },
            'pain': { icon: 'bandage', label: 'Rapport à la douleur', traits: ['Sadique', 'Masochiste', 'Stoïque', 'Sensible', 'Endurant', 'Douillet', 'Vulnérable'] },
            'time': { icon: 'clock', label: 'Rapport au temps', traits: ['Nostalgique', 'Tourné vers l\'avenir', 'Carpe Diem', 'Cynique', 'Patient', 'Impatient'] }
        }
    },
    'evolution': {
        icon: 'trending-up',
        label: 'Évolution Personnelle',
        categories: {
            'initial': { icon: 'sparkles', label: 'État initial', traits: ['Innocent', 'Naïf', 'Ferme dans ses convictions', 'Curieux', 'Méfiant', 'Mystérieux', 'Téméraire'] },
            'learning': { icon: 'book-open', label: 'Approche face à l\'apprentissage', traits: ['Autodidacte', 'Chercheur de mentors', 'Expérimentateur', 'Sceptique', 'Réfractaire au changement'] },
            'failure': { icon: 'alert-triangle', label: 'Gestion des échecs', traits: ['Persévérant', 'Résilient', 'Facilement découragé', 'Fuyant', 'Auto-compassion', 'Revanchard', 'Défaitiste'] },
            'quest': { icon: 'compass', label: 'Quête personnelle', traits: ['Chercheur d\'identité', 'Chercheur de vérité', 'Chercheur de sensations', 'Chercheur d\'équilibre', 'Chercheur de pouvoir'] },
            'adaptability': { icon: 'shuffle', label: 'Adaptabilité à l\'évolution', traits: ['Flexible', 'Rigide', 'Conservateur', 'Caméléon'] },
            'world': { icon: 'globe', label: 'Interaction avec le monde', traits: ['Explorateur', 'Protecteur', 'Observateur', 'Pionnier', 'Réformateur'] },
            'relationships': { icon: 'user-heart', label: 'Gestion des relations', traits: ['Loyal', 'Solidaire', 'Indépendant', 'Codépendant'] },
            'death': { icon: 'skull', label: 'Rapport à la mort', traits: ['Stoïque', 'Anxieux', 'Fataliste', 'Spirituel', 'Déni'] }
        }
    },
    'daily': {
        icon: 'home',
        label: 'Au Quotidien',
        categories: {
            'order': { icon: 'list-checks', label: 'Organisation et ordre', traits: ['Désordonné', 'Méticuleux', 'Négligent', 'Soigneux'] },
            'appearance': { icon: 'shirt', label: 'Apparence et style', traits: ['Coquet', 'Négligé', 'Élégant', 'Décontracté', 'Mystérieux', 'Inspirant'] },
            'physical': { icon: 'dumbbell', label: 'Habileté physique', traits: ['Adroit', 'Maladroit', 'Agile', 'Fort', 'Fragile', 'Précis', 'Souple'] },
            'timeManagement': { icon: 'timer', label: 'Gestion du temps', traits: ['Ponctuel', 'Retardataire', 'Organisé', 'Procrastinateur'] }
        }
    },
    'others': {
        icon: 'users',
        label: 'Rapport aux Autres',
        categories: {
            'norms': { icon: 'ban', label: 'Réponse aux normes culturelles', traits: ['Conformiste', 'Rebelle', 'Innovateur', 'Traditionaliste', 'Indifférent'] },
            'group': { icon: 'group', label: 'Rapport au groupe', traits: ['Leader', 'Suiveur', 'Autoritaire', 'Solitaire', 'Médiateur', 'Esprit de contradiction'] },
            'maturity': { icon: 'gem', label: 'Maturité émotionnelle', traits: ['Candide', 'Immature', 'Mature', 'Naïf', 'Sage'] },
            'communication': { icon: 'message-square', label: 'Communication', traits: ['Expressif', 'Réservé', 'Enthousiaste', 'Observateur', 'Provocateur', 'Éloquent', 'Persuasif', 'À l\'écoute', 'Franc'] },
            'diversity': { icon: 'dices', label: 'Réaction à la diversité', traits: ['Tolérant', 'Intolérant', 'Curieux', 'Ignorant', 'Ambivalent'] },
            'pressure': { icon: 'gauge', label: 'Gestion de la pression sociale', traits: ['Influençable', 'Résistant', 'Indécis', 'Évitant'] },
            'identity': { icon: 'user-circle', label: 'Quête d\'identité sociale', traits: ['Cherche l\'appartenance', 'Caméléon social', 'Loup solitaire', 'Conformiste', 'Cosmopolite'] },
            'success': { icon: 'trophy', label: 'Vision de la réussite', traits: ['Ambitieux', 'Minimaliste', 'Opportuniste', 'Idéaliste', 'Pessimiste'] },
            'institutions': { icon: 'gavel', label: 'Interactions avec les institutions', traits: ['Respectueux', 'Critique', 'Manipulateur', 'Défenseur', 'Détaché'] }
        }
    },
    'age': {
        icon: 'hourglass',
        label: 'Personnalité selon l\'Âge',
        categories: {
            'childhood': { icon: 'baby', label: 'Enfance et adolescence', traits: ['Curieux', 'Rebelle', 'Suiveur', 'Protecteur', 'Rêveur'] },
            'youngAdult': { icon: 'briefcase', label: 'Jeunes adultes', traits: ['Ambitieux', 'Aventurier', 'Stable', 'Introspectif', 'Social', 'Téméraire'] },
            'midLife': { icon: 'building-2', label: 'Milieu de vie', traits: ['Responsable', 'Pédagogue', 'Entrepreneur', 'Nostalgique', 'Philanthrope', 'Mentor', 'Sage', 'Expérimenté', 'Accompli'] },
            'mature': { icon: 'library', label: 'Âge mûr', traits: ['Sage', 'Conservateur', 'Libéré', 'Prudent', 'Gardien de la tradition'] },
            'generations': { icon: 'tree-pine', label: 'Interactions entre générations', traits: ['Respectueux', 'Aime les défier', 'Guide', 'Élève', 'Indifférent'] }
        }
    },
    'moral': {
        icon: 'scale',
        label: 'La Morale',
        categories: {
            'virtues': { icon: 'check-circle', label: 'Vertus', traits: ['Courageux', 'Juste', 'Sage', 'Tempéré', 'Tolérant', 'Intègre', 'Honnête', 'Loyal', 'Compatissant', 'Bienveillant', 'Sincère', 'Désintéressé', 'Responsable'] },
            'neutral': { icon: 'circle', label: 'Traits neutres', traits: ['Modéré', 'Prudent', 'Réfléchi', 'Objectif', 'Réaliste', 'Modeste', 'Patient'] },
            'ambiguous': { icon: 'infinity', label: 'Ambiguïté morale', traits: ['Astucieux', 'Manipulateur', 'Séducteur', 'Rusé', 'Stratège', 'Entêté'] },
            'minorVices': { icon: 'alert-circle', label: 'Vices mineurs', traits: ['Paresseux', 'Égoïste', 'Impulsif', 'Moqueur', 'Malhonnête', 'Hypocrite', 'Lâche', 'Cupide', 'Envieux'] },
            'majorVices': { icon: 'skull', label: 'Vices majeurs', traits: ['Cruel', 'Tyrannique', 'Malveillant', 'Traître', 'Violent', 'Sadique'] },
            'redemption': { icon: 'rotate-ccw', label: 'Traits rédempteurs', traits: ['Repentant', 'Humble', 'Reconnaissant', 'Miséricordieux', 'Compatissant'] },
            'moralApproach': { icon: 'compass', label: 'Approche de la moralité', traits: ['Amoral', 'Nihiliste', 'Utilitariste', 'Paragon de vertu'] },
            'values': { icon: 'diamond', label: 'Principes et valeurs', traits: ['Conformiste', 'Conventionnel', 'Éthique', 'Honnête', 'Idéaliste', 'Incorruptible', 'Intransigeant', 'Non-conformiste', 'Pragmatique', 'Rebelle', 'Respectueux', 'Révolutionnaire', 'Traditionnel', 'Transgressif'] }
        }
    },
    'past': {
        icon: 'history',
        label: 'En Fonction du Passé',
        categories: {
            'privileged': { icon: 'crown', label: 'Enfance privilégiée', traits: ['Confiant', 'Naïf', 'Entreprenant', 'Éduqué'] },
            'trauma': { icon: 'x-circle', label: 'Traumatismes passés', traits: ['Méfiant', 'Résilient', 'Tourmenté', 'Secret', 'Vigilant', 'MystÉRIEUX'] },
            'hardship': { icon: 'pickaxe', label: 'Enfance dans l\'adversité', traits: ['Combattif', 'Ingénieux', 'Méfiant', 'Endurci', 'Tenace'] },
            'nomad': { icon: 'tent', label: 'Passé nomade', traits: ['S\'adapte facilement', 'Curieux', 'Indépendant', 'Nomade', 'Polyglotte'] },
            'educated': { icon: 'microscope', label: 'Éducation formelle', traits: ['Analytique', 'Érudit', 'Précis', 'Structuré', 'Sceptique'] },
            'artist': { icon: 'palette', label: 'Passé d\'artiste', traits: ['Imaginatif', 'Sensible', 'Non-conformiste', 'Passionné', 'Perfectionniste'] },
            'delinquent': { icon: 'handcuffs', label: 'Ancien délinquant', traits: ['Rusé', 'Secret', 'Rebelle', 'Débrouillard', 'Insoumis'] },
            'noble': { icon: 'castle', label: 'Origines nobles', traits: ['Digne', 'Autoritaire', 'Élitiste', 'Gracieux', 'Maniéré', 'Conservateur'] }
        }
    },
    'elements': {
        icon: 'leaf',
        label: 'Éléments Naturels',
        categories: {
            'earth': { icon: 'mountain', label: 'Terre', traits: ['Ancré', 'Résistant', 'Patient', 'Pratique', 'Loyal'] },
            'water': { icon: 'water', label: 'Eau', traits: ['Sensible', 'Profond', 'Réfléchi', 'Adaptable', 'Empathique'] },
            'fire': { icon: 'flame', label: 'Feu', traits: ['Enthousiaste', 'Colérique', 'Charismatique', 'Audacieux', 'Créatif', 'Impulsif'] },
            'air': { icon: 'wind', label: 'Air', traits: ['Analytique', 'Expressif', 'Léger', 'Intuitif', 'Curieux'] },
            'metal': { icon: 'hammer', label: 'Métal', traits: ['Organisé', 'Tenace', 'Réfléchi', 'Précis', 'Discipliné'] },
            'wood': { icon: 'tree-pine', label: 'Bois', traits: ['Innovateur', 'Visionnaire', 'Ambitieux', 'Flexible', 'Énergique'] },
            'space': { icon: 'satellite', label: 'Espace', traits: ['Indépendant', 'Mystérieux', 'Rêveur', 'Explorateur', 'Contemplatif'] },
            'light': { icon: 'sun', label: 'Lumière', traits: ['Lumineux', 'Optimiste', 'Inspirant', 'Chaleureux', 'Rayonnant', 'Bienveillant', 'Leader'] }
        }
    }
};

// ========== js-refactor/characters/characters.repository.js ==========
/**
 * [MVVM : Characters Repository]
 * Gestion de la persistance et de l'accès aux données des personnages et des races.
 */

const CharacterRepository = {
    /**
     * Récupère tous les personnages.
     */
    getAll() {
        if (!project.characters) project.characters = [];
        return project.characters;
    },

    /**
     * Récupère un personnage par son ID.
     */
    getById(id) {
        return this.getAll().find(c => c.id === id);
    },

    /**
     * Ajoute un personnage au projet.
     */
    add(character) {
        if (!project.characters) project.characters = [];
        project.characters.push(character);
    },

    /**
     * Supprime un personnage par son ID.
     */
    remove(id) {
        if (!project.characters) return;
        project.characters = project.characters.filter(c => c.id !== id);
    },

    /**
     * Met à jour un personnage par son ID.
     */
    update(id, updates) {
        const char = this.getById(id);
        if (char) {
            Object.assign(char, updates, { updatedAt: Date.now() });
            return { ...char }; // Return a clone
        }
        return null;
    },

    /**
     * Récupère toutes les races définies.
     */
    getRaces() {
        if (!project.races) {
            project.races = ['Humain', 'Elfe', 'Nain', 'Orc', 'Autre'];
        }
        return project.races;
    },

    /**
     * Ajoute une nouvelle race à la liste globale.
     */
    addRace(raceName) {
        const races = this.getRaces();
        if (!races.includes(raceName)) {
            races.push(raceName);
            races.sort();
            return true;
        }
        return false;
    },

    /**
     * Récupère tous les regroupements personnalisés définis.
     */
    getGroups() {
        if (!project.groups) {
            project.groups = [];
        }
        return project.groups;
    },

    /**
     * Ajoute un nouveau regroupement à la liste globale.
     */
    addGroup(groupName) {
        const groups = this.getGroups();
        if (!groups.includes(groupName)) {
            groups.push(groupName);
            groups.sort();
            return true;
        }
        return false;
    }
};

// ========== js-refactor/characters/characters.viewmodel.js ==========
/**
 * [MVVM : Characters ViewModel]
 * Logique métier et préparation des données pour l'interface des personnages.
 */

/**
 * [MVVM : Purpose] 
 * Centraliser la logique de manipulation des personnages et isoler la Vue des détails du Repository.
 */

/**
 * Coordination pour ajouter un personnage.
 */
function addCharacterViewModel(name, role, description) {
    if (!name) return { success: false, message: 'Le nom est obligatoire' };

    const characterData = {
        name: name,
        role: role,
        physicalDescription: description
    };

    const newCharacter = CharacterModel.create(characterData);
    CharacterRepository.add(newCharacter);

    return {
        success: true,
        character: newCharacter,
        sideEffects: {
            shouldSave: true,
            shouldOpen: newCharacter.id
        }
    };
}

/**
 * Coordination pour supprimer un personnage.
 */
function deleteCharacterViewModel(id) {
    CharacterRepository.remove(id);
    return {
        success: true,
        sideEffects: {
            shouldSave: true,
            shouldResetView: true
        }
    };
}

/**
 * Groupement des personnages pour l'affichage dans la liste.
 * Retourne un objet contenant les groupements par race et par groupe personnalisé.
 */
function getGroupedCharactersViewModel() {
    const characters = CharacterRepository.getAll();
    const races = CharacterRepository.getRaces();
    const customGroups = CharacterRepository.getGroups();

    const byRace = {};
    races.forEach(race => byRace[race] = []);
    byRace['Race non classée'] = [];

    const byGroup = {};
    customGroups.forEach(g => byGroup[g] = []);
    byGroup['Sans groupe'] = [];

    characters.forEach(char => {
        const migrated = CharacterModel.migrate(char);

        // Groupement par race
        const raceKey = (migrated.race && races.includes(migrated.race)) ? migrated.race : 'Race non classée';
        if (!byRace[raceKey]) byRace[raceKey] = [];
        byRace[raceKey].push(migrated);

        // Groupement par groupe perso
        const groupKey = (migrated.group && customGroups.includes(migrated.group)) ? migrated.group : 'Sans groupe';
        if (!byGroup[groupKey]) byGroup[groupKey] = [];
        byGroup[groupKey].push(migrated);
    });

    // Tri alphabétique dans chaque groupe
    const sortFn = (a, b) => {
        const nameA = (a.name || '').toLowerCase();
        const nameB = (b.name || '').toLowerCase();
        return nameA.localeCompare(nameB, 'fr');
    };

    [byRace, byGroup].forEach(container => {
        Object.keys(container).forEach(key => container[key].sort(sortFn));
    });

    return { byRace, byGroup };
}

/**
 * Prépare les données pour la fiche détaillée d'un personnage.
 */
function getCharacterDetailViewModel(id) {
    const rawChar = CharacterRepository.getById(id);
    if (!rawChar) return null;

    const character = CharacterModel.migrate(rawChar);
    const races = CharacterRepository.getRaces();
    const groups = CharacterRepository.getGroups();
    const linkedScenes = getLinkedScenesViewModel(id);

    return {
        character,
        races,
        groups,
        linkedScenes
    };
}

/**
 * Récupère les scènes où le personnage apparaît.
 */
function getLinkedScenesViewModel(characterId) {
    if (typeof findScenesWithCharacter !== 'function') return [];

    // findScenesWithCharacter utilise probablement déjà project, 
    // mais on l'encapsule ici pour que la Vue n'ait pas à le savoir.
    const scenes = findScenesWithCharacter(characterId);

    return scenes.map(scene => {
        const acts = typeof ActRepository !== 'undefined' ? ActRepository.getAll() : (project.acts || []);
        const actIndex = acts.findIndex(a => a.id === scene.actId);

        return {
            actId: scene.actId,
            chapterId: scene.chapterId,
            sceneId: scene.sceneId,
            sceneTitle: scene.sceneTitle,
            actTitle: scene.actTitle,
            chapterTitle: scene.chapterTitle,
            actNumber: actIndex !== -1 ? (actIndex + 1) : '?',
            chapterNumber: scene.chapterId ? '?' : '?' // On pourrait affiner en cherchant dans l'acte
        };
    });
}

/**
 * Mise à jour générique d'un champ.
 */
function updateCharacterFieldViewModel(id, field, value) {
    const updates = { [field]: value };
    const char = CharacterRepository.getById(id);
    if (!char) return { success: false };

    // Logique spéciale pour le nom complet -> split
    if (field === 'name') {
        const parts = (value || '').trim().split(' ');
        updates.firstName = parts[0] || '';
        updates.lastName = parts.slice(1).join(' ') || '';
    }
    // Logique spéciale pour les composants du nom -> join
    else if (field === 'firstName' || field === 'lastName') {
        const fName = field === 'firstName' ? value : char.firstName;
        const lName = field === 'lastName' ? value : char.lastName;
        updates.name = `${fName || ''} ${lName || ''}`.trim() || 'Sans nom';
    }

    const nextValue = CharacterRepository.update(id, updates);
    return {
        success: !!nextValue,
        sideEffects: {
            shouldSave: true,
            shouldRefreshList: (field === 'firstName' || field === 'lastName' || field === 'race' || field === 'group' || field === 'name')
        }
    };
}

/**
 * Ajout d'un nouveau regroupement personnalisé.
 */
function addGroupViewModel(groupName, charIdToAssign) {
    if (!groupName || !groupName.trim()) return { success: false };

    const formatted = groupName.trim();
    const added = CharacterRepository.addGroup(formatted);

    if (added && charIdToAssign) {
        CharacterRepository.update(charIdToAssign, { group: formatted });
    }

    return {
        success: true,
        alreadyExists: !added,
        sideEffects: {
            shouldSave: true,
            shouldRefreshAll: true
        }
    };
}

/**
 * Gestion des traits (toggle).
 */
function toggleCharacterTraitViewModel(id, trait) {
    const char = CharacterRepository.getById(id);
    if (!char) return { success: false, message: 'Personnage introuvable' };

    const currentTraits = char.traits || [];
    let newTraits;

    if (currentTraits.includes(trait)) {
        newTraits = currentTraits.filter(t => t !== trait);
    } else {
        newTraits = [...currentTraits, trait];
    }

    const updatedChar = CharacterRepository.update(id, { traits: newTraits });

    return {
        success: !!updatedChar,
        data: updatedChar,
        sideEffects: {
            shouldSave: true,
            shouldRefreshTraits: true
        }
    };
}

/**
 * Ajout d'une nouvelle race.
 */
function addRaceViewModel(raceName, charIdToAssign) {
    if (!raceName || !raceName.trim()) return { success: false };

    const formatted = raceName.trim();
    const added = CharacterRepository.addRace(formatted);

    if (added && charIdToAssign) {
        CharacterRepository.update(charIdToAssign, { race: formatted });
    }

    return {
        success: true,
        alreadyExists: !added,
        sideEffects: {
            shouldSave: true,
            shouldRefreshAll: true
        }
    };
}

/**
 * Inventaire.
 */
function addInventoryItemViewModel(id, listType) {
    const char = CharacterRepository.getById(id);
    if (!char) return { success: false, message: 'Personnage introuvable' };

    const currentList = char[listType] || [];
    const newList = [...currentList, {
        id: Date.now(),
        name: '',
        quantity: 1,
        description: ''
    }];

    const updatedChar = CharacterRepository.update(id, { [listType]: newList });
    return {
        success: !!updatedChar,
        data: updatedChar,
        sideEffects: {
            shouldSave: true,
            shouldRefreshInventory: listType
        }
    };
}

function removeInventoryItemViewModel(id, listType, index) {
    const char = CharacterRepository.getById(id);
    if (!char || !char[listType]) return { success: false, message: 'Personnage ou liste introuvable' };

    const newList = char[listType].filter((_, i) => i !== index);
    const updatedChar = CharacterRepository.update(id, { [listType]: newList });

    return {
        success: !!updatedChar,
        data: updatedChar,
        sideEffects: {
            shouldSave: true,
            shouldRefreshInventory: listType
        }
    };
}

function updateInventoryItemViewModel(id, listType, index, field, value) {
    const char = CharacterRepository.getById(id);
    if (!char || !char[listType] || !char[listType][index]) return { success: false };

    const newList = char[listType].map((item, i) =>
        i === index ? { ...item, [field]: value } : item
    );

    const updatedChar = CharacterRepository.update(id, { [listType]: newList });
    return {
        success: !!updatedChar,
        data: updatedChar,
        sideEffects: {
            shouldSave: true
        }
    };
}

/**
 * Mise à jour des stats de personnalité.
 */
function updatePersonalityStatViewModel(id, stat, value) {
    const character = CharacterRepository.getById(id);
    if (!character || !character.personality) return { success: false };

    const newPersonality = {
        ...character.personality,
        [stat]: parseInt(value)
    };

    const updatedChar = CharacterRepository.update(id, { personality: newPersonality });
    return {
        success: !!updatedChar,
        data: updatedChar,
        sideEffects: {
            shouldSave: true,
            shouldRefreshRadar: true
        }
    };
}

/**
 * Mise à jour de l'avatar.
 */
function updateAvatarViewModel(id, choice) {
    const updates = {};
    if (choice.startsWith('http')) {
        updates.avatarImage = choice;
        updates.avatarEmoji = '';
    } else {
        updates.avatarEmoji = choice;
        updates.avatarImage = '';
    }

    CharacterRepository.update(id, updates);
    return { success: true, sideEffects: { shouldSave: true } };
}

// ========== js-refactor/characters/characters.view.js ==========
/**
 * [MVVM : Characters View]
 * Gestion de l'affichage et des interactions utilisateur pour les personnages.
 */

/**
 * [MVVM : View]
 * Affiche la modale d'ajout de personnage.
 */
function openAddCharacterModal() {
    const modal = document.getElementById('addCharacterModal');
    if (modal) {
        modal.classList.add('active');
        setTimeout(() => {
            const input = document.getElementById('characterNameInput');
            if (input) input.focus();
        }, 100);
    }
}

/**
 * [MVVM : View]
 * Action utilisateur : Ajouter un personnage.
 */
function addCharacter() {
    const nameInput = document.getElementById('characterNameInput');
    const roleInput = document.getElementById('characterRoleInput');
    const descInput = document.getElementById('characterDescInput');

    if (!nameInput) return;

    const result = addCharacterViewModel(
        nameInput.value.trim(),
        roleInput ? roleInput.value.trim() : '',
        descInput ? descInput.value.trim() : ''
    );

    if (result.success) {
        nameInput.value = '';
        if (roleInput) roleInput.value = '';
        if (descInput) descInput.value = '';

        closeModal('addCharacterModal');
        processCharacterSideEffects(result);
    }
}

/**
 * [MVVM : View]
 * Action utilisateur : Supprimer un personnage.
 */
function deleteCharacter(id) {
    if (!confirm('Êtes-vous sûr de vouloir supprimer ce personnage ?')) return;

    const result = deleteCharacterViewModel(id);
    processCharacterSideEffects(result);
}

/**
 * [MVVM : View]
 * Rendu de la liste latérale des personnages.
 */
function renderCharactersList() {
    const container = document.getElementById('charactersList');
    if (!container) return;

    const { byRace, byGroup } = getGroupedCharactersViewModel();
    const hasAnyByRace = Object.values(byRace).some(group => group.length > 0);
    const hasAnyByGroup = Object.values(byGroup).some(group => group.length > 0);

    if (!hasAnyByRace && !hasAnyByGroup) {
        container.innerHTML = '<div style="padding: 1rem; text-align: center; color: var(--text-muted); font-size: 0.85rem;">Aucun personnage</div>';
        return;
    }

    let html = '<div class="treeview-children" style="margin-left: 0; border-left: none; padding-left: 0;">';

    // Helper pour générer une section (Race ou Groupe)
    const renderSection = (title, groupedData) => {
        let sectionHtml = `
            <div style="padding: 12px 12px 6px 12px; color: var(--primary-color); font-size: 0.8rem; font-weight: bold; border-top: 2px solid var(--primary-color); margin-top: 15px;">
                ${title}
            </div>
        `;

        Object.entries(groupedData).forEach(([headerName, chars]) => {
            if (chars.length === 0) return;

            sectionHtml += `
                <div class="treeview-race-header" style="
                    padding: 6px 12px;
                    background: var(--bg-secondary, rgba(255,255,255,0.05));
                    color: var(--text-muted);
                    font-size: 0.75rem;
                    font-weight: bold;
                    text-transform: uppercase;
                    border-top: 1px solid var(--border-color);
                    border-bottom: 1px solid var(--border-color);
                    margin-top: 8px;
                    margin-bottom: 4px;
                    display: flex; 
                    justify-content: space-between;
                ">
                    <span>${headerName}</span>
                    <span style="opacity: 0.6;">${chars.length}</span>
                </div>
            `;

            chars.forEach(char => {
                const displayName = char.name || char.firstName || 'Sans nom';
                sectionHtml += `
                    <div class="treeview-item" onclick="openCharacterDetail(${char.id})">
                        <span class="treeview-item-icon">
                            <i data-lucide="user" style="width:14px;height:14px;vertical-align:middle;"></i>
                        </span>
                        <span class="treeview-item-label">${displayName}</span>
                        <button class="treeview-item-delete" onclick="event.stopPropagation(); deleteCharacter(${char.id})" title="Supprimer"><i data-lucide="x" style="width:12px;height:12px;"></i></button>
                    </div>
                `;
            });
        });
        return sectionHtml;
    };

    // Toujours afficher le groupement par race
    html += renderSection('PAR RACE', byRace);

    // N'afficher le groupement par groupe que s'il y a des groupes personnalisés (ou si au moins un perso a un groupe)
    const hasRealGroups = Object.keys(byGroup).length > 1 || (byGroup['Sans groupe'] && byGroup['Sans groupe'].length < Object.values(byRace).flat().length);
    if (hasRealGroups) {
        html += renderSection('PAR REGROUPEMENT', byGroup);
    }

    html += '</div>';
    container.innerHTML = html;

    if (typeof lucide !== 'undefined') lucide.createIcons();
}

/**
 * [MVVM : View]
 * Ouvre la fiche détaillée d'un personnage.
 */
function openCharacterDetail(id) {
    const data = getCharacterDetailViewModel(id);
    if (!data) return;

    const { character, races, groups, linkedScenes } = data;

    // Orchestration globale si on est en split view
    if (typeof splitViewActive !== 'undefined' && splitViewActive) {
        const state = splitActivePanel === 'left' ? splitViewState.left : splitViewState.right;
        if (state.view === 'characters') {
            state.characterId = id;
            if (typeof renderSplitPanelViewContent === 'function') {
                renderSplitPanelViewContent(splitActivePanel);
            }
            if (typeof saveSplitViewState === 'function') saveSplitViewState();
            return;
        }
    }

    const editorView = document.getElementById('editorView');
    if (editorView) {
        editorView.innerHTML = renderCharacterSheet(character, races, groups, linkedScenes);

        // Post-rendu
        setTimeout(() => {
            initCharacterRadar(character);
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }, 50);
    }
}

/**
 * [MVVM : View]
 * Template de la fiche personnage complet (Fidèle à l'original).
 */
function renderCharacterSheet(character, racesList, groupsList, linkedScenes) {
    const metaInfo = [];
    if (character.age) metaInfo.push(`${character.age}${character.birthPlace ? ', né à ' + character.birthPlace : ''}`);
    if (character.residence) metaInfo.push(character.residence);

    const raceOptions = (racesList || []).map(r =>
        `<option value="${r}" ${character.race === r ? 'selected' : ''}>${r}</option>`
    ).join('');

    const groupOptions = (groupsList || []).map(g =>
        `<option value="${g}" ${character.group === g ? 'selected' : ''}>${g}</option>`
    ).join('');

    return `
        <div class="character-sheet" data-character-id="${character.id}">
            <!-- Header -->
            <div class="character-sheet-header">
                <div class="character-avatar" onclick="changeCharacterAvatar(${character.id}, '${character.avatarEmoji || ''}', '${character.avatarImage || ''}')" title="Changer l'avatar">
                    ${character.avatarImage
            ? `<img src="${character.avatarImage}" alt="${character.name}">`
            : (character.avatarEmoji && character.avatarEmoji !== '👤' ? `<div class="emoji-avatar" style="font-size: 40px; line-height: 80px; text-align: center;">${character.avatarEmoji}</div>` : `<i data-lucide="user" style="width:80px;height:80px;"></i>`)}
                </div>
                <div class="character-header-info">
                    <h2 contenteditable="true" onblur="updateCharacterName(${character.id}, this.textContent)">${character.firstName}${character.lastName ? ' ' + character.lastName : ''}</h2>
                    <ul class="character-meta">
                        ${metaInfo.map(m => `<li>${m}</li>`).join('')}
                    </ul>
                </div>
                <button class="character-close-btn" onclick="switchView('editor')" title="Fermer"><i data-lucide="x" style="width:20px;height:20px;"></i></button>
            </div>
            

            <!-- Grille des sections -->
            <div class="character-sections-grid">
            
            ${renderCharacterLinkedScenes(linkedScenes)}

            <!-- État Civil -->
            <div class="character-section" id="section-etat-civil">
                <div class="character-section-header" onclick="toggleCharacterSection('etat-civil')">
                    <div class="character-section-title">État Civil</div>
                    <span class="character-section-toggle">
                        <i data-lucide="chevron-down" style="width:18px;height:18px;"></i>
                    </span>
                </div>
                <div class="character-section-content">
                    <div class="character-field-row">
                        <div class="character-field">
                            <label class="character-field-label">Prénom</label>
                            <input type="text" value="${character.firstName || ''}" 
                                   onchange="updateCharacterField(${character.id}, 'firstName', this.value)">
                        </div>
                        <div class="character-field">
                            <label class="character-field-label">Nom de famille</label>
                            <input type="text" value="${character.lastName || ''}" 
                                   onchange="updateCharacterField(${character.id}, 'lastName', this.value)">
                        </div>
                    </div>
                    <div class="character-field-row">
                        <div class="character-field">
                            <label class="character-field-label">Surnom</label>
                            <input type="text" value="${character.nickname || ''}" 
                                   onchange="updateCharacterField(${character.id}, 'nickname', this.value)">
                        </div>
                        <div class="character-field">
                            <label class="character-field-label">Pronoms</label>
                            <input type="text" value="${character.pronouns || ''}" placeholder="il/lui, elle/elle, iel..."
                                   onchange="updateCharacterField(${character.id}, 'pronouns', this.value)">
                        </div>
                    </div>
                    <div class="character-field-row">
                        <div class="character-field">
                            <label class="character-field-label">Sexe</label>
                            <div class="character-radio-group">
                                <label><input type="radio" name="sex-${character.id}" value="F" ${character.sex === 'F' ? 'checked' : ''} onchange="updateCharacterField(${character.id}, 'sex', 'F')"> Femme</label>
                                <label><input type="radio" name="sex-${character.id}" value="M" ${character.sex === 'M' ? 'checked' : ''} onchange="updateCharacterField(${character.id}, 'sex', 'M')"> Homme</label>
                                <label><input type="radio" name="sex-${character.id}" value="A" ${character.sex === 'A' ? 'checked' : ''} onchange="updateCharacterField(${character.id}, 'sex', 'A')"> Autre</label>
                            </div>
                        </div>
                        <div class="character-field">
                            <label class="character-field-label">Race</label>
                            <div style="display: flex; gap: 5px; align-items: center;">
                                <select class="detail-input" style="flex-grow: 1;"
                                    onchange="updateCharacterField(${character.id}, 'race', this.value)">
                                    <option value="">Sélectionner...</option>
                                    ${raceOptions}
                                </select>
                                <button onclick="addNewRace(${character.id})" class="btn-icon" title="Créer une nouvelle race">
                                    <i data-lucide="plus" style="width:14px;height:14px;"></i>
                                </button>
                            </div>
                        </div>
                        <div class="character-field">
                            <label class="character-field-label">Regroupement (Famille, Clan, etc.)</label>
                            <div style="display: flex; gap: 5px; align-items: center;">
                                <select class="detail-input" style="flex-grow: 1;"
                                    onchange="updateCharacterField(${character.id}, 'group', this.value)">
                                    <option value="">Aucun</option>
                                    ${groupOptions}
                                </select>
                                <button onclick="addNewGroup(${character.id})" class="btn-icon" title="Créer un nouveau regroupement">
                                    <i data-lucide="plus" style="width:14px;height:14px;"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                    <div class="character-field-row">
                        <div class="character-field" style="max-width: 100px;">
                            <label class="character-field-label">Âge</label>
                            <input type="text" value="${character.age || ''}" 
                                   onchange="updateCharacterField(${character.id}, 'age', this.value)">
                        </div>
                        <div class="character-field">
                            <label class="character-field-label">Date de naissance</label>
                            <input type="text" value="${character.birthDate || ''}" placeholder="JJ/MM/AAAA"
                                   onchange="updateCharacterField(${character.id}, 'birthDate', this.value)">
                        </div>
                        <div class="character-field">
                            <label class="character-field-label">Lieu de naissance</label>
                            <input type="text" value="${character.birthPlace || ''}" 
                                   onchange="updateCharacterField(${character.id}, 'birthPlace', this.value)">
                        </div>
                    </div>
                    <div class="character-field-row">
                        <div class="character-field" style="max-width: 100px;"></div>
                        <div class="character-field">
                            <label class="character-field-label">Date de décès</label>
                            <input type="text" value="${character.deathDate || ''}" placeholder="JJ/MM/AAAA"
                                   onchange="updateCharacterField(${character.id}, 'deathDate', this.value)">
                        </div>
                        <div class="character-field">
                            <label class="character-field-label">Lieu de décès</label>
                            <input type="text" value="${character.deathPlace || ''}" 
                                   onchange="updateCharacterField(${character.id}, 'deathPlace', this.value)">
                        </div>
                    </div>
                    <div class="character-field-row">
                        <div class="character-field">
                            <label class="character-field-label">Lieu de résidence</label>
                            <input type="text" value="${character.residence || ''}" 
                                   onchange="updateCharacterField(${character.id}, 'residence', this.value)">
                        </div>
                        <div class="character-field">
                            <label class="character-field-label">Occupation</label>
                            <input type="text" value="${character.occupation || ''}" 
                                   onchange="updateCharacterField(${character.id}, 'occupation', this.value)">
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Physique -->
            <div class="character-section" id="section-physique">
                <div class="character-section-header" onclick="toggleCharacterSection('physique')">
                    <div class="character-section-title">Physique</div>
                        <span class="character-section-toggle"><i data-lucide="chevron-down" style="width:18px;height:18px;"></i></span>
                    </div>
                <div class="character-section-content">
                    <div class="character-field-row">
                        <div class="character-field">
                            <label class="character-field-label">Taille</label>
                            <input type="text" value="${character.height || ''}" placeholder="cm"
                                   onchange="updateCharacterField(${character.id}, 'height', this.value)">
                        </div>
                        <div class="character-field">
                            <label class="character-field-label">Poids</label>
                            <input type="text" value="${character.weight || ''}" placeholder="kg"
                                   onchange="updateCharacterField(${character.id}, 'weight', this.value)">
                        </div>
                        <div class="character-field">
                            <label class="character-field-label">Corpulence</label>
                            <input type="text" value="${character.bodyType || ''}" 
                                   onchange="updateCharacterField(${character.id}, 'bodyType', this.value)">
                        </div>
                    </div>
                    <div class="character-field-row">
                        <div class="character-field">
                            <label class="character-field-label">Couleur des cheveux</label>
                            <input type="text" value="${character.hairColor || ''}" 
                                   onchange="updateCharacterField(${character.id}, 'hairColor', this.value)">
                        </div>
                        <div class="character-field">
                            <label class="character-field-label">Couleur des yeux</label>
                            <input type="text" value="${character.eyeColor || ''}" 
                                   onchange="updateCharacterField(${character.id}, 'eyeColor', this.value)">
                        </div>
                        <div class="character-field">
                            <label class="character-field-label">Voix / Manière de parler</label>
                            <input type="text" value="${character.voice || ''}" 
                                   onchange="updateCharacterField(${character.id}, 'voice', this.value)">
                        </div>
                    </div>
                    <div class="character-field-row">
                        <div class="character-field">
                            <label class="character-field-label">Tenue</label>
                            <textarea rows="3" onchange="updateCharacterField(${character.id}, 'clothing', this.value)">${character.clothing || ''}</textarea>
                        </div>
                        <div class="character-field">
                            <label class="character-field-label">Accessoires</label>
                            <textarea rows="3" onchange="updateCharacterField(${character.id}, 'accessories', this.value)">${character.accessories || ''}</textarea>
                        </div>
                    </div>
                    <div class="character-field">
                        <label class="character-field-label">Description</label>
                        <textarea rows="4" onchange="updateCharacterField(${character.id}, 'physicalDescription', this.value)">${character.physicalDescription || ''}</textarea>
                    </div>
                </div>
            </div>

            <!-- Radar Chart -->
            <div class="character-section" id="section-radar">
                <div class="character-section-header">
                    <div class="character-section-title">Statistiques de Personnalité</div>
                </div>
                <div class="character-section-content" style="display: flex; flex-direction: column; align-items: center;">
                    <canvas id="radarChart-${character.id}" width="300" height="300"></canvas>
                    <div class="radar-controls">
                        ${Object.entries(character.personality).map(([stat, val]) => `
                            <div class="radar-control-item" style="display: flex; align-items: center; gap: 10px; width: 100%; margin-bottom: 5px;">
                                <label style="flex: 1; font-size: 0.8rem;">${stat.charAt(0).toUpperCase() + stat.slice(1)}</label>
                                <input type="range" min="0" max="20" value="${val}" style="flex: 2;" onchange="updatePersonalityStat(${character.id}, '${stat}', this.value)">
                                <span class="radar-value" style="width: 25px; text-align: right; font-weight: bold;">${val}</span>
                            </div>
                        `).join('')}
                    </div>
                </div>
            </div>
            
            <!-- Évolution - Full width -->
            <div class="character-section full-width" id="section-evolution">
                <div class="character-section-header" onclick="toggleCharacterSection('evolution')">
                    <div class="character-section-title">Évolution</div>
                    <span class="character-section-toggle"><i data-lucide="chevron-down" style="width:18px;height:18px;"></i></span>
                </div>
                <div class="character-section-content">
                    <div class="character-field">
                        <label class="character-field-label">Buts / Objectifs</label>
                        <textarea rows="3" onchange="updateCharacterField(${character.id}, 'goals', this.value)">${character.goals || ''}</textarea>
                    </div>
                        
                    <div class="character-timeline">
                        <div class="timeline-card">
                            <div class="timeline-card-title">Passé</div>
                            <textarea placeholder="Enfance, passé..." onchange="updateCharacterField(${character.id}, 'past', this.value)">${character.past || ''}</textarea>
                        </div>
                        <div class="timeline-card">
                            <div class="timeline-card-title">Présent</div>
                            <textarea placeholder="État actuel..." onchange="updateCharacterField(${character.id}, 'present', this.value)">${character.present || ''}</textarea>
                        </div>
                        <div class="timeline-card">
                            <div class="timeline-card-title">Futur</div>
                            <textarea placeholder="Devenir..." onchange="updateCharacterField(${character.id}, 'future', this.value)">${character.future || ''}</textarea>
                        </div>
                    </div>
                </div>
            </div>



            <!-- Caractère - Full width -->
            <div class="character-section full-width" id="section-caractere">
                <div class="character-section-header" onclick="toggleCharacterSection('caractere')">
                    <div class="character-section-title">Traits de Caractère</div>
                    <span class="character-section-toggle"><i data-lucide="chevron-down" style="width:18px;height:18px;"></i></span>
                </div>
                <div class="character-section-content">
                    <!-- Traits sélectionnés -->
                    <div class="character-field">
                        <label class="character-field-label">Traits sélectionnés</label>
                        <div class="selected-traits-container" id="selectedTraits-${character.id}">
                            ${(character.traits || []).map((t, i) => `
                                <span class="selected-trait">${t}<span class="trait-remove" onclick="removeCharacterTrait(${character.id}, ${i})"><i data-lucide="x" style="width:10px;height:10px;"></i></span></span>
                            `).join('') || '<span class="no-traits">Cliquez sur les traits ci-dessous pour les ajouter</span>'}
                        </div>
                    </div>
                    
                    <!-- Catégories de traits -->
                    <div class="traits-categories">
                        ${renderTraitsCategories(character.id, character.traits || [])}
                    </div>
                    
                    <div class="character-field" style="margin-top: 1rem;">
                        <label class="character-field-label">Goûts</label>
                        <textarea rows="2" onchange="updateCharacterField(${character.id}, 'tastes', this.value)">${character.tastes || ''}</textarea>
                    </div>
                    <div class="character-field">
                        <label class="character-field-label">Tics, manies, habitudes</label>
                        <textarea rows="2" onchange="updateCharacterField(${character.id}, 'habits', this.value)">${character.habits || ''}</textarea>
                    </div>
                    <div class="character-field">
                        <label class="character-field-label">Peurs et doutes</label>
                        <textarea rows="2" onchange="updateCharacterField(${character.id}, 'fears', this.value)">${character.fears || ''}</textarea>
                    </div>
                </div>
            </div>
            
            <!-- Profil -->
            <div class="character-section" id="section-profil">
                <div class="character-section-header" onclick="toggleCharacterSection('profil')">
                    <div class="character-section-title">Profil</div>
                    <span class="character-section-toggle"><i data-lucide="chevron-down" style="width:18px;height:18px;"></i></span>
                </div>
                <div class="character-section-content">
                    <div class="character-field">
                        <label class="character-field-label">Éducation</label>
                        <textarea rows="3" onchange="updateCharacterField(${character.id}, 'education', this.value)">${character.education || ''}</textarea>
                    </div>
                    <div class="character-field">
                        <label class="character-field-label">Secrets</label>
                        <textarea rows="3" onchange="updateCharacterField(${character.id}, 'secrets', this.value)">${character.secrets || ''}</textarea>
                    </div>
                    <div class="character-field">
                        <label class="character-field-label">Croyances et idéologies</label>
                        <textarea rows="2" onchange="updateCharacterField(${character.id}, 'beliefs', this.value)">${character.beliefs || ''}</textarea>
                    </div>
                    <div class="character-field-row">
                        <div class="character-field">
                            <label class="character-field-label">Lieux marquants</label>
                            <input type="text" value="${character.importantPlaces || ''}" 
                                   onchange="updateCharacterField(${character.id}, 'importantPlaces', this.value)">
                        </div>
                        <div class="character-field">
                            <label class="character-field-label">Phrases ou expressions typiques</label>
                            <textarea rows="3" onchange="updateCharacterField(${character.id}, 'catchphrases', this.value)">${character.catchphrases || ''}</textarea>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Inventaire -->
            <div class="character-section" id="section-inventaire">
                <div class="character-section-header" onclick="toggleCharacterSection('inventaire')">
                    <div class="character-section-title">Inventaire</div>
                    <span class="character-section-toggle"><i data-lucide="chevron-down" style="width:18px;height:18px;"></i></span>
                </div>
                <div class="character-section-content">
                    <div id="inventory-list-${character.id}">
                        ${(character.inventory || []).map((item, i) => renderInventoryItem(character.id, 'inventory', item, i)).join('')}
                    </div>
                    <button class="inventory-add-btn" onclick="addInventoryItem(${character.id}, 'inventory')">
                        Ajouter <i data-lucide="plus-circle" style="width:16px;height:16px;"></i>
                    </button>
                </div>
            </div>
            
            <!-- Autres -->
            <div class="character-section" id="section-autres">
                <div class="character-section-header" onclick="toggleCharacterSection('autres')">
                    <div class="character-section-title">Autres</div>
                    <span class="character-section-toggle"><i data-lucide="chevron-down" style="width:18px;height:18px;"></i></span>
                </div>
                <div class="character-section-content">
                    <div class="character-field">
                        <textarea rows="5" placeholder="Notes diverses..." 
                                  onchange="updateCharacterField(${character.id}, 'notes', this.value)">${character.notes || ''}</textarea>
                    </div>
                </div>
            </div>
            
            </div><!-- Fin de character-sections-grid -->
            

        </div>
    `;
}

/**
 * [MVVM : View]
 * Traitement centralisé des effets de bord.
 */
function processCharacterSideEffects(result) {
    if (!result || !result.success) return;

    const effects = result.sideEffects || {};

    if (effects.shouldSave && typeof saveProject === 'function') {
        saveProject();
    }

    if (effects.shouldRefreshList) {
        renderCharactersList();
    }

    if (effects.shouldRefreshAll) {
        renderCharactersList();
        if (result.character) openCharacterDetail(result.character.id);
    }

    if (effects.shouldResetView && typeof showEmptyState === 'function') {
        showEmptyState();
    }

    if (effects.shouldOpen) {
        openCharacterDetail(effects.shouldOpen);
    }

    if (effects.shouldRefreshTraits && result.data) {
        refreshTraitsDisplay(result.data);
    }

    if (effects.shouldRefreshInventory && result.data) {
        refreshInventoryList(result.data, effects.shouldRefreshInventory);
    }

    if (effects.shouldRefreshRadar && result.data) {
        // Mise à jour locale rapide
        const id = result.data.id;
        const charSheet = document.querySelector(`.character-sheet[data-character-id="${id}"]`);
        if (charSheet) {
            Object.entries(result.data.personality).forEach(([stat, val]) => {
                const valueSpan = charSheet.querySelector(`.radar-control-item[data-stat="${stat}"] .radar-value`);
                if (valueSpan) valueSpan.textContent = val;
            });
            initCharacterRadar(result.data);
        }
    }
}

/**
 * [MVVM : View]
 * Redirection des actions utilisateur vers le ViewModel et traitement des effets.
 */
function updateCharacterField(id, field, value) {
    const result = updateCharacterFieldViewModel(id, field, value);
    if (result.success) {
        processCharacterSideEffects(result);

        // Mise à jour du header si nécessaire
        if (field === 'firstName' || field === 'lastName' || field === 'name') {
            const headerTitle = document.querySelector(`.character-sheet[data-character-id="${id}"] h2`);
            if (headerTitle && result.data) headerTitle.textContent = result.data.name;
        }
    }
}

function updateCharacterName(id, newName) {
    updateCharacterField(id, 'name', newName.trim());
}

function toggleCharacterTrait(id, trait) {
    const result = toggleCharacterTraitViewModel(id, trait);
    processCharacterSideEffects(result);
}

function removeCharacterTrait(id, trait) {
    const result = toggleCharacterTraitViewModel(id, trait);
    processCharacterSideEffects(result);
}

function updatePersonalityStat(id, stat, value) {
    const result = updatePersonalityStatViewModel(id, stat, value);
    processCharacterSideEffects(result);
}

function addNewRace(charId) {
    const newRace = prompt("Nom de la nouvelle race :");
    if (newRace && newRace.trim()) {
        const result = addRaceViewModel(newRace, charId);
        if (result.success) {
            if (result.alreadyExists) alert("Cette race existe déjà !");
            processCharacterSideEffects(result);
            if (result.sideEffects.shouldRefreshAll) openCharacterDetail(charId);
        }
    }
}

function addNewGroup(charId) {
    const newGroup = prompt("Nom du nouveau regroupement (Famille, Clan, Groupe...) :");
    if (newGroup && newGroup.trim()) {
        const result = addGroupViewModel(newGroup, charId);
        if (result.success) {
            if (result.alreadyExists) alert("Ce regroupement existe déjà !");
            processCharacterSideEffects(result);
            if (result.sideEffects.shouldRefreshAll) openCharacterDetail(charId);
        }
    }
}

function addInventoryItem(id, listType) {
    const result = addInventoryItemViewModel(id, listType);
    processCharacterSideEffects(result);
}

function removeInventoryItem(id, listType, index) {
    const result = removeInventoryItemViewModel(id, listType, index);
    processCharacterSideEffects(result);
}

function updateInventoryItem(id, listType, index, field, value) {
    const result = updateInventoryItemViewModel(id, listType, index, field, value);
    processCharacterSideEffects(result);
}

function refreshInventoryList(character, listType) {
    const container = document.getElementById(`inventory-list-${character.id}`);
    if (container) {
        container.innerHTML = (character[listType] || []).map((item, i) => renderInventoryItem(character.id, listType, item, i)).join('');
        if (typeof lucide !== 'undefined') lucide.createIcons();
    }
}

function renderInventoryItem(charId, listType, item, index) {
    return `
        <div class="inventory-item">
            <button class="inventory-item-delete" onclick="removeInventoryItem(${charId}, '${listType}', ${index})"><i data-lucide="x" style="width:12px;height:12px;"></i></button>
            <div class="character-field-row">
                <input type="text" value="${item.name || ''}" placeholder="Nom" onchange="updateInventoryItem(${charId}, '${listType}', ${index}, 'name', this.value)">
                <input type="number" value="${item.quantity || 1}" style="width: 50px;" onchange="updateInventoryItem(${charId}, '${listType}', ${index}, 'quantity', parseInt(this.value))">
            </div>
            <input type="text" value="${item.description || ''}" placeholder="Description" onchange="updateInventoryItem(${charId}, '${listType}', ${index}, 'description', this.value)">
        </div>
    `;
}

/**
 * [MVVM : View]
 * Radar Chart & Traits Helpers.
 */
function initCharacterRadar(character) {
    const canvas = document.getElementById(`radarChart-${character.id}`);
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    const radius = Math.min(centerX, centerY) - 50;

    const stats = character.personality;
    const labels = ['Intelligence', 'Force', 'Robustesse', 'Empathie', 'Perception', 'Agilité', 'Sociabilité'];
    const values = [stats.intelligence, stats.force, stats.robustesse, stats.empathie, stats.perception, stats.agilite, stats.sociabilite];
    const numPoints = labels.length;
    const angleStep = (Math.PI * 2) / numPoints;

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Grid circles
    ctx.strokeStyle = '#e0e0e0';
    for (let i = 1; i <= 4; i++) {
        ctx.beginPath();
        const r = (radius / 4) * i;
        for (let j = 0; j <= numPoints; j++) {
            const angle = (angleStep * j) - Math.PI / 2;
            const x = centerX + Math.cos(angle) * r;
            const y = centerY + Math.sin(angle) * r;
            if (j === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
        }
        ctx.stroke();
    }

    // Data polygon
    ctx.fillStyle = 'rgba(100, 100, 120, 0.3)';
    ctx.strokeStyle = 'var(--primary-color)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    for (let i = 0; i < numPoints; i++) {
        const angle = (angleStep * i) - Math.PI / 2;
        const val = (values[i] / 20) * radius;
        const x = centerX + Math.cos(angle) * val;
        const y = centerY + Math.sin(angle) * val;
        if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    }
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    // Labels
    ctx.fillStyle = 'var(--text-secondary)';
    ctx.font = '10px sans-serif';
    ctx.textAlign = 'center';
    for (let i = 0; i < numPoints; i++) {
        const angle = (angleStep * i) - Math.PI / 2;
        const x = centerX + Math.cos(angle) * (radius + 25);
        const y = centerY + Math.sin(angle) * (radius + 25);
        ctx.fillText(labels[i], x, y);
    }
}

function renderTraitsCategories(charId, selectedTraits) {
    return Object.entries(TRAIT_SECTIONS).map(([sectionKey, section]) => `
        <div class="trait-section" id="trait-section-${sectionKey}">
            <div class="trait-section-header" onclick="toggleTraitSection('${sectionKey}')">
                <span><i data-lucide="${section.icon}" style="width:16px; height:16px; vertical-align: middle; margin-right:8px;"></i>${section.label}</span>
            </div>
            <div class="trait-section-content">
                ${Object.entries(section.categories).map(([catKey, category]) => `
                    <div class="trait-category">
                        <div class="trait-category-header">${category.label}</div>
                        <div class="trait-category-content">
                            ${category.traits.map(trait => `
                                <span class="trait-option ${selectedTraits.includes(trait) ? 'selected' : ''}" 
                                    onclick="toggleCharacterTrait(${charId}, '${trait.replace(/'/g, "\\'")}')">${trait}</span>
                            `).join('')}
                        </div>
                    </div>
                `).join('')}
            </div>
        </div>
    `).join('');
}

function toggleTraitSection(key) {
    const el = document.getElementById(`trait-section-${key}`);
    if (el) el.classList.toggle('collapsed');
}

function toggleCharacterSection(key) {
    const el = document.getElementById(`section-${key}`);
    if (el) el.classList.toggle('collapsed');
}

function refreshTraitsDisplay(character) {
    const traits = character.traits || [];
    const container = document.getElementById(`selectedTraits-${character.id}`);

    if (container) {
        container.innerHTML = traits.length > 0
            ? traits.map((t, i) => `<span class="selected-trait">${t}<span class="trait-remove" onclick="removeCharacterTrait(${character.id}, '${t.replace(/'/g, "\\'")}')"><i data-lucide="x" style="width:10px;height:10px;"></i></span></span>`).join('')
            : '<span class="no-traits">Cliquez sur les traits ci-dessous pour les ajouter</span>';
    }

    document.querySelectorAll('.trait-option').forEach(opt => {
        opt.classList.toggle('selected', traits.includes(opt.textContent));
    });
}

function changeCharacterAvatar(id, currentEmoji, currentImage) {
    const defaultValue = currentImage || currentEmoji || '';
    const choice = prompt('Emoji ou URL d\'image :', defaultValue);
    if (choice === null) return;

    const result = updateAvatarViewModel(id, choice);
    processCharacterSideEffects(result);
}

// Génération du HTML pour les scènes liées
function renderCharacterLinkedScenes(linkedScenes) {
    if (!linkedScenes || linkedScenes.length === 0) return '';

    return `
        <div class="detail-section" style="margin-bottom: 20px;">
            <div class="detail-section-title"><i data-lucide="file-text" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Apparaît dans ${linkedScenes.length} scène(s)</div>
            <div class="quick-links" style="display: flex; flex-wrap: wrap; gap: 5px; margin-top: 10px;">
                ${linkedScenes.map(scene => {
        const actNumNum = scene.actNumber || '?';
        const breadcrumb = `Acte ${actNumNum} › Chapitre ${scene.chapterNumber || '?'} › ${scene.sceneTitle}`;

        return `
                    <span class="link-badge" onclick="openScene(${scene.actId}, ${scene.chapterId}, ${scene.sceneId})" 
                            title="${scene.actTitle} - ${scene.chapterTitle}"
                            style="padding: 4px 8px; background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 4px; font-size: 0.75rem; cursor: pointer;">
                        ${breadcrumb}
                    </span>
                `;
    }).join('')}
            </div>
        </div>
    `;
}

// ========== js-refactor/16.split-view.js ==========
// ==========================================
// SPLIT VIEW SYSTEM - New Architecture
// ==========================================

const viewLabels = {
    'editor': 'Structure',
    'characters': 'Personnages',
    'world': 'Univers',
    'notes': 'Notes',
    'codex': 'Codex',
    'stats': 'Statistiques',
    'analysis': 'Analyse',
    'versions': 'Snapshots',
    'todos': 'TODOs',
    'corkboard': 'Tableau',
    'mindmap': 'Mindmap',
    'plot': 'Intrigue',
    'relations': 'Relations',
    'map': 'Carte',
    'timelineviz': 'Timeline'
};

const viewIcons = {
    'editor': 'pen-line',
    'characters': 'users',
    'world': 'globe',
    'notes': 'sticky-note',
    'codex': 'book-open',
    'stats': 'bar-chart-3',
    'analysis': 'scan-search',
    'versions': 'history',
    'todos': 'check-square',
    'corkboard': 'layout-grid',
    'mindmap': 'git-branch',
    'plot': 'trending-up',
    'relations': 'link',
    'map': 'map',
    'timelineviz': 'clock'
};

// [MVVM : ViewModel]
// Gère le basculement de l'état global du mode split
function toggleSplitView() {
    if (splitViewActive) {
        closeSplitView();
    } else {
        activateSplitView();
    }
}

// [MVVM : ViewModel]
// Initialise l'état pour l'activation du mode split
function activateSplitView() {
    splitViewActive = true;
    splitActivePanel = 'left';

    // Initialize left panel with current view state
    splitViewState.left.view = currentView || 'editor';
    if (currentSceneId) {
        splitViewState.left.sceneId = currentSceneId;
        splitViewState.left.actId = currentActId;
        splitViewState.left.chapterId = currentChapterId;
    }

    // Right panel starts empty or with a default
    if (!splitViewState.right.view) {
        splitViewState.right.view = null;
    }

    renderSplitView();
    updateSplitToggleButton();
    showNotification('Mode split activé - Cliquez sur un panneau pour le sélectionner');
}

// [MVVM : ViewModel]
// Réinitialise l'état et restaure la vue standard
function closeSplitView() {
    splitViewActive = false;

    // Find which panel has the editor and restore it as the main view
    let viewToRestore = 'editor';
    let sceneToRestore = null;

    if (splitViewState.left.view === 'editor') {
        viewToRestore = 'editor';
        sceneToRestore = splitViewState.left.sceneId;
        currentActId = splitViewState.left.actId;
        currentChapterId = splitViewState.left.chapterId;
    } else if (splitViewState.right.view === 'editor') {
        viewToRestore = 'editor';
        sceneToRestore = splitViewState.right.sceneId;
        currentActId = splitViewState.right.actId;
        currentChapterId = splitViewState.right.chapterId;
    } else {
        // No editor found, restore left panel view
        viewToRestore = splitViewState.left.view || 'editor';
    }

    currentView = viewToRestore;
    if (sceneToRestore) {
        currentSceneId = sceneToRestore;
    }

    // Reset split state
    splitViewState.right.view = null;

    // Restore normal view
    switchView(currentView);

    updateSplitToggleButton();
    saveSplitViewState();
    showNotification('Mode split désactivé');
}

// [MVVM : View]
// Met à jour l'état visuel du bouton de bascule dans le DOM
function updateSplitToggleButton() {
    const btn = document.getElementById('splitModeToggle');
    if (btn) {
        if (splitViewActive) {
            btn.classList.add('active');
            btn.innerHTML = '<i data-lucide="columns-2" style="width:14px;height:14px;"></i> <span>Split actif</span>';
        } else {
            btn.classList.remove('active');
            btn.innerHTML = '<i data-lucide="columns-2" style="width:14px;height:14px;"></i> <span>Split</span>';
        }
        if (typeof lucide !== 'undefined') lucide.createIcons();
    }
}

// [MVVM : View]
// Génère et injecte la structure HTML principale du mode split
function renderSplitView() {
    if (!splitViewActive) return;

    const editorView = document.getElementById('editorView');
    const ratio = splitViewState.ratio || 60;

    const leftLabel = splitViewState.left.view ? viewLabels[splitViewState.left.view] || 'Vue' : 'Vide';
    const rightLabel = splitViewState.right.view ? viewLabels[splitViewState.right.view] || 'Vue' : 'Vide';
    const leftIcon = splitViewState.left.view ? viewIcons[splitViewState.left.view] || 'file' : 'plus-circle';
    const rightIcon = splitViewState.right.view ? viewIcons[splitViewState.right.view] || 'file' : 'plus-circle';

    editorView.innerHTML = `
                <div class="split-view-container" id="splitViewContainer">
                    <div class="split-panel split-panel-left ${splitActivePanel === 'left' ? 'active' : ''}" 
                         id="splitPanelLeft" 
                         style="flex: ${ratio};"
                         onclick="setActiveSplitPanel('left')">
                        <div class="split-panel-header" onclick="openSplitViewSelector('left'); event.stopPropagation();">
                            <div class="split-panel-title" id="splitLeftTitle">
                                <i data-lucide="${leftIcon}" style="width:14px;height:14px;"></i>
                                <span>${leftLabel}</span>
                                <i data-lucide="chevron-down" style="width:12px;height:12px;opacity:0.5;margin-left:4px;"></i>
                            </div>
                            <div class="split-panel-actions" onclick="event.stopPropagation();">
                                <span class="split-panel-indicator ${splitActivePanel === 'left' ? 'active' : ''}" title="Panneau actif">
                                    <i data-lucide="circle" style="width:8px;height:8px;fill:currentColor;"></i>
                                </span>
                            </div>
                        </div>
                        <div class="split-panel-content" id="splitLeftContent">
                            <!-- Content rendered by renderSplitPanelViewContent -->
                        </div>
                    </div>
                    
                    <div class="split-resizer horizontal" id="splitResizer" 
                         onmousedown="startSplitResize(event)"
                         ontouchstart="startSplitResize(event)"></div>
                    
                    <div class="split-panel split-panel-right ${splitActivePanel === 'right' ? 'active' : ''}" 
                         id="splitPanelRight" 
                         style="flex: ${100 - ratio};"
                         onclick="setActiveSplitPanel('right')">
                        <div class="split-panel-header" onclick="openSplitViewSelector('right'); event.stopPropagation();">
                            <div class="split-panel-title" id="splitRightTitle">
                                <i data-lucide="${rightIcon}" style="width:14px;height:14px;"></i>
                                <span>${rightLabel}</span>
                                <i data-lucide="chevron-down" style="width:12px;height:12px;opacity:0.5;margin-left:4px;"></i>
                            </div>
                            <div class="split-panel-actions" onclick="event.stopPropagation();">
                                <span class="split-panel-indicator ${splitActivePanel === 'right' ? 'active' : ''}" title="Panneau actif">
                                    <i data-lucide="circle" style="width:8px;height:8px;fill:currentColor;"></i>
                                </span>
                                <button class="split-panel-btn" onclick="closeSplitView(); event.stopPropagation();" title="Fermer le split">
                                    <i data-lucide="x" style="width:12px;height:12px;"></i>
                                </button>
                            </div>
                        </div>
                        <div class="split-panel-content" id="splitRightContent">
                            <!-- Content rendered by renderSplitPanelViewContent -->
                        </div>
                    </div>
                </div>
            `;

    // Render content for both panels
    renderSplitPanelViewContent('left');
    renderSplitPanelViewContent('right');

    // Update sidebar for active panel
    updateSidebarForSplitPanel(splitActivePanel);

    if (typeof lucide !== 'undefined') lucide.createIcons();
}

// [MVVM : ViewModel]
// Gère le changement de panneau actif et met à jour les indicateurs visuels
function setActiveSplitPanel(panel) {
    if (splitActivePanel === panel) return;

    splitActivePanel = panel;

    // Update visual indicators
    document.getElementById('splitPanelLeft')?.classList.toggle('active', panel === 'left');
    document.getElementById('splitPanelRight')?.classList.toggle('active', panel === 'right');

    // Update indicators
    document.querySelectorAll('.split-panel-indicator').forEach((el, index) => {
        el.classList.toggle('active', (index === 0 && panel === 'left') || (index === 1 && panel === 'right'));
    });

    // Update sidebar for this panel's view
    updateSidebarForSplitPanel(panel);

    // Update header nav to reflect active panel's view
    const activeView = panel === 'left' ? splitViewState.left.view : splitViewState.right.view;
    if (activeView) {
        document.querySelectorAll('[id^="header-tab-"]').forEach(btn => btn.classList.remove('active'));
        const headerBtn = document.getElementById(`header-tab-${activeView}`);
        if (headerBtn) headerBtn.classList.add('active');
    }
}

// [MVVM : View]
// Manipulle le DOM de la barre latérale pour correspondre à la vue du panneau actif
function updateSidebarForSplitPanel(panel) {
    const state = panel === 'left' ? splitViewState.left : splitViewState.right;
    const view = state.view;

    if (!view) return;

    // Map views to their sidebar lists
    const sidebarViews = {
        'editor': 'chaptersList',
        'characters': 'charactersList',
        'world': 'worldList',
        'notes': 'notesList',
        'codex': 'codexList',
        'arcs': 'arcsList',
        'mindmap': 'mindmapList',
        'timelineviz': 'timelineVizList'
    };

    // Views that don't use sidebar (full-screen views)
    const noSidebarViews = ['stats', 'analysis', 'versions', 'todos', 'timeline', 'corkboard', 'plot', 'relations', 'map'];

    // Labels for views without sidebar
    const viewLabelsNoSidebar = {
        'stats': 'Statistiques',
        'analysis': 'Analyse',
        'versions': 'Versions',
        'todos': 'TODOs',
        'timeline': 'Timeline',
        'corkboard': 'Tableau',
        'plot': 'Intrigue',
        'relations': 'Relations',
        'map': 'Carte'
    };

    // Hide all sidebar lists including noSidebarMessage
    const allLists = [
        'chaptersList', 'charactersList', 'worldList', 'timelineList',
        'notesList', 'codexList', 'statsList', 'versionsList', 'analysisList',
        'todosList', 'corkboardList', 'mindmapList', 'plotList',
        'relationsList', 'mapList', 'timelineVizList', 'noSidebarMessage'
    ];
    allLists.forEach(listId => {
        const el = document.getElementById(listId);
        if (el) el.style.display = 'none';
    });

    // Show the appropriate list and refresh its content
    if (sidebarViews[view]) {
        const listEl = document.getElementById(sidebarViews[view]);
        if (listEl) listEl.style.display = 'block';

        // Refresh the list content based on view
        switch (view) {
            case 'editor':
                renderActsList();
                break;
            case 'characters':
                if (typeof renderCharactersList === 'function') renderCharactersList();
                break;
            case 'world':
                if (typeof renderWorldList === 'function') renderWorldList();
                break;
            case 'notes':
                if (typeof renderNotesList === 'function') renderNotesList();
                break;
            case 'codex':
                if (typeof renderCodexList === 'function') renderCodexList();
                break;
            case 'mindmap':
                if (typeof renderMindmapList === 'function') renderMindmapList();
                break;
            case 'timelineviz':
                if (typeof renderTimelineVizList === 'function') renderTimelineVizList();
                break;
        }
    } else if (noSidebarViews.includes(view)) {
        // Show message for views without sidebar
        const noSidebarEl = document.getElementById('noSidebarMessage');
        if (noSidebarEl) {
            const viewLabel = viewLabelsNoSidebar[view] || 'Cette vue';
            noSidebarEl.innerHTML = `
                        <div style="padding: 2rem 1rem; text-align: center; color: var(--text-muted);">
                            <i data-lucide="layout-dashboard" style="width: 48px; height: 48px; opacity: 0.3; margin-bottom: 1rem;"></i>
                            <div style="font-size: 0.9rem; line-height: 1.6;">
                                <strong>${viewLabel}</strong> utilise tout l'espace disponible.
                            </div>
                            <div style="font-size: 0.85rem; margin-top: 0.5rem; opacity: 0.8;">
                                La barre latérale n'est pas utilisée dans cette vue.
                            </div>
                        </div>
                    `;
            noSidebarEl.style.display = 'block';

            // Refresh icons
            setTimeout(() => {
                if (typeof lucide !== 'undefined') lucide.createIcons();
            }, 50);
        }
    }

    // Update sidebar actions
    const actionsHTML = {
        editor: '<button class="btn btn-primary" onclick="openAddActModal()">+ Acte</button><button class="btn btn-primary" onclick="openAddChapterModal()">+ Chapitre</button><button class="btn btn-primary" onclick="openAddSceneModalQuick()">+ Scène</button>',
        characters: '<button class="btn btn-primary" onclick="openAddCharacterModal()">+ Personnage</button>',
        world: '<button class="btn btn-primary" onclick="openAddWorldModal()">+ Élément</button>',
        notes: '<button class="btn btn-primary" onclick="openAddNoteModal()">+ Note</button>',
        codex: '<button class="btn btn-primary" onclick="openAddCodexModal()">+ Entrée</button>',
        arcs: '<button class="btn btn-primary" onclick="createNewArc()">+ Arc narratif</button>'
    };
    const sidebarActions = document.getElementById('sidebarActions');
    if (sidebarActions) {
        sidebarActions.innerHTML = actionsHTML[view] || '';
    }

    // Update structure-only elements visibility
    const structureOnlyElements = ['projectProgressBar', 'statusFilters', 'sceneTools', 'toolsSidebar'];
    structureOnlyElements.forEach(id => {
        const el = document.getElementById(id);
        if (el) el.style.display = (view === 'editor') ? '' : 'none';
    });

    // Update tree collapse toolbar visibility (for views with collapsible groups)
    const treeCollapseToolbar = document.getElementById('treeCollapseToolbar');
    const viewsWithGroups = ['editor', 'world', 'notes', 'codex'];
    if (treeCollapseToolbar) {
        treeCollapseToolbar.style.display = viewsWithGroups.includes(view) ? '' : 'none';
    }

    // Refresh Lucide icons
    if (typeof lucide !== 'undefined') lucide.createIcons();
}

// [MVVM : ViewModel]
// Gère le changement de type de vue au sein d'un panneau spécifique
function switchSplitPanelView(panel, view) {
    const state = panel === 'left' ? splitViewState.left : splitViewState.right;
    state.view = view;

    // Reset specific IDs when changing view type
    state.sceneId = null;
    state.characterId = null;
    state.worldId = null;
    state.noteId = null;

    // If switching to editor view and we have a current scene, use it
    if (view === 'editor' && currentSceneId) {
        state.sceneId = currentSceneId;
        state.actId = currentActId;
        state.chapterId = currentChapterId;
    }

    // Re-render the panel content
    renderSplitPanelViewContent(panel);

    // Update panel header
    updateSplitPanelHeader(panel);

    // Update sidebar if this is the active panel
    if (splitActivePanel === panel) {
        updateSidebarForSplitPanel(panel);

        // Update header nav
        document.querySelectorAll('[id^="header-tab-"]').forEach(btn => btn.classList.remove('active'));
        const headerBtn = document.getElementById(`header-tab-${view}`);
        if (headerBtn) headerBtn.classList.add('active');
    }

    saveSplitViewState();
    if (typeof lucide !== 'undefined') lucide.createIcons();
}

// [MVVM : View]
// Met à jour l'en-tête (titre et icône) d'un panneau split
function updateSplitPanelHeader(panel) {
    const state = panel === 'left' ? splitViewState.left : splitViewState.right;
    const titleEl = document.getElementById(panel === 'left' ? 'splitLeftTitle' : 'splitRightTitle');

    if (titleEl) {
        const label = state.view ? viewLabels[state.view] || 'Vue' : 'Vide';
        const icon = state.view ? viewIcons[state.view] || 'file' : 'plus-circle';
        titleEl.innerHTML = `
                    <i data-lucide="${icon}" style="width:14px;height:14px;"></i>
                    <span>${label}</span>
                    <i data-lucide="chevron-down" style="width:12px;height:12px;opacity:0.5;margin-left:4px;"></i>
                `;
        if (typeof lucide !== 'undefined') lucide.createIcons();
    }
}

// [MVVM : View]
// Prépare et initialise le conteneur de contenu pour un panneau
function renderSplitPanelViewContent(panel) {
    const container = document.getElementById(panel === 'left' ? 'splitLeftContent' : 'splitRightContent');
    if (!container) return;

    const state = panel === 'left' ? splitViewState.left : splitViewState.right;
    const view = state.view;

    if (!view) {
        container.innerHTML = `
                    <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; color: var(--text-muted); text-align: center; padding: 2rem;">
                        <i data-lucide="plus-circle" style="width:48px;height:48px;stroke-width:1;margin-bottom:1rem;opacity:0.5;"></i>
                        <div style="font-size: 1rem; margin-bottom: 0.5rem;">Panneau vide</div>
                        <div style="font-size: 0.85rem; margin-bottom: 1rem;">Cliquez sur l'en-tête pour choisir une vue</div>
                    </div>
                `;
        if (typeof lucide !== 'undefined') lucide.createIcons();
        return;
    }

    // Create a unique container ID for this panel's content
    const contentId = `split-${panel}-view-content`;
    container.innerHTML = `<div id="${contentId}" style="height: 100%; overflow: auto;"></div>`;

    const contentContainer = document.getElementById(contentId);

    // Render the view content into this container
    renderViewInSplitPanel(view, contentContainer, state, panel);
}

// [MVVM : Other]
// Group: Coordinator | Naming: SplitViewCoordinator
// Logique de routage de rendu vers les différentes vues spécifiques (Mixte)
function renderViewInSplitPanel(view, container, state, panel) {
    // Technique: créer un faux editorView temporaire pour que les fonctions de rendu existantes fonctionnent
    const realEditorView = document.getElementById('editorView');

    // Créer un conteneur temporaire avec l'ID editorView
    const tempContainer = document.createElement('div');
    tempContainer.id = 'editorView';
    tempContainer.style.cssText = 'height: 100%; overflow: auto;';
    container.innerHTML = '';
    container.appendChild(tempContainer);

    // Temporairement masquer le vrai editorView et changer son ID
    if (realEditorView) {
        realEditorView.id = 'editorView-backup';
    }

    // Fonction pour restaurer après le rendu
    const restoreEditorView = () => {
        // Restaurer l'ID du vrai editorView
        if (realEditorView) {
            realEditorView.id = 'editorView';
        }
        // Le tempContainer garde le contenu rendu mais perd son ID
        tempContainer.id = 'splitPanelContent-' + panel;
    };

    switch (view) {
        case 'editor':
            if (state.sceneId) {
                const act = project.acts.find(a => a.id === state.actId);
                const chapter = act?.chapters.find(c => c.id === state.chapterId);
                const scene = chapter?.scenes.find(s => s.id === state.sceneId);
                if (act && chapter && scene) {
                    renderEditorInContainer(act, chapter, scene, container, panel);
                    restoreEditorView();
                    return; // On sort car renderEditorInContainer gère tout
                }
            } else {
                tempContainer.innerHTML = `
                            <div class="empty-state">
                                <div class="empty-state-icon"><i data-lucide="pencil" style="width:48px;height:48px;stroke-width:1;"></i></div>
                                <div class="empty-state-title">Sélectionnez une scène</div>
                                <div class="empty-state-text">Choisissez une scène dans la barre latérale</div>
                            </div>
                        `;
            }
            break;

        case 'characters':
            if (state.characterId) {
                const data = getCharacterDetailViewModel(state.characterId);
                if (data) {
                    const { character, races, linkedScenes } = data;
                    tempContainer.innerHTML = renderCharacterSheet(character, races, linkedScenes);
                    setTimeout(() => {
                        initCharacterRadar(character);
                        if (typeof lucide !== 'undefined') lucide.createIcons();
                    }, 100);
                }
            } else {
                tempContainer.innerHTML = `
                            <div class="empty-state">
                                <div class="empty-state-icon"><i data-lucide="users" style="width:48px;height:48px;stroke-width:1.5;"></i></div>
                                <div class="empty-state-title">Personnages</div>
                                <div class="empty-state-text">Sélectionnez un personnage dans la barre latérale</div>
                            </div>
                        `;
            }
            break;

        case 'world':
            if (state.worldId) {
                const elem = project.world?.find(e => e.id === state.worldId);
                if (elem) {
                    // Appeler la vraie fonction openWorldDetail via le faux editorView
                    if (typeof renderWorldDetailFull === 'function') {
                        renderWorldDetailFull(elem, tempContainer);
                    } else {
                        // Générer le même HTML que openWorldDetail
                        tempContainer.innerHTML = `
                                    <div class="detail-view">
                                        <div class="detail-header">
                                            <div style="display: flex; align-items: center; gap: 1rem;">
                                                <div class="detail-title">${elem.name}</div>
                                                <span style="font-size: 0.9rem; padding: 0.5rem 1rem; background: var(--accent-gold); color: var(--bg-primary); border-radius: 2px;">${elem.type}</span>
                                            </div>
                                        </div>
                                        
                                        ${typeof renderElementLinkedScenes === 'function' ? renderElementLinkedScenes(elem) : ''}
                                        
                                        <div class="detail-section">
                                            <div class="detail-section-title">Informations de base</div>
                                            <div class="detail-field">
                                                <div class="detail-label">Nom</div>
                                                <input type="text" class="form-input" value="${elem.name}" 
                                                       onchange="updateWorldField(${elem.id}, 'name', this.value)">
                                            </div>
                                        </div>

                                        <div class="detail-section">
                                            <div class="detail-section-title">Type</div>
                                            <select class="form-input" onchange="updateWorldField(${elem.id}, 'type', this.value)">
                                                <option value="Lieu" ${elem.type === 'Lieu' ? 'selected' : ''}>Lieu</option>
                                                <option value="Objet" ${elem.type === 'Objet' ? 'selected' : ''}>Objet</option>
                                                <option value="Concept" ${elem.type === 'Concept' ? 'selected' : ''}>Concept</option>
                                                <option value="Organisation" ${elem.type === 'Organisation' ? 'selected' : ''}>Organisation</option>
                                                <option value="Événement" ${elem.type === 'Événement' ? 'selected' : ''}>Événement</option>
                                            </select>
                                        </div>

                                        <div class="detail-section">
                                            <div class="detail-section-title">Description</div>
                                            <textarea class="form-input" rows="6" 
                                                      onchange="updateWorldField(${elem.id}, 'description', this.value)">${elem.description || ''}</textarea>
                                        </div>

                                        <div class="detail-section">
                                            <div class="detail-section-title">Détails</div>
                                            <textarea class="form-input" rows="6" 
                                                      onchange="updateWorldField(${elem.id}, 'details', this.value)">${elem.details || ''}</textarea>
                                        </div>

                                        <div class="detail-section">
                                            <div class="detail-section-title">Histoire</div>
                                            <textarea class="form-input" rows="6" 
                                                      onchange="updateWorldField(${elem.id}, 'history', this.value)">${elem.history || ''}</textarea>
                                        </div>

                                        <div class="detail-section">
                                            <div class="detail-section-title">Notes</div>
                                            <textarea class="form-input" rows="4" 
                                                      onchange="updateWorldField(${elem.id}, 'notes', this.value)">${elem.notes || ''}</textarea>
                                        </div>
                                    </div>
                                `;
                    }
                }
            } else {
                tempContainer.innerHTML = `
                            <div class="empty-state">
                                <div class="empty-state-icon"><i data-lucide="globe" style="width:48px;height:48px;stroke-width:1.5;"></i></div>
                                <div class="empty-state-title">Univers</div>
                                <div class="empty-state-text">Sélectionnez un élément dans la barre latérale</div>
                            </div>
                        `;
            }
            break;

        case 'notes':
            if (state.noteId) {
                const note = project.notes?.find(n => n.id === state.noteId);
                if (note) {
                    // Même HTML que openNoteDetail
                    tempContainer.innerHTML = `
                                <div class="detail-view">
                                    <div class="detail-header">
                                        <div style="display: flex; align-items: center; gap: 1rem; flex: 1;">
                                            <input type="text" class="form-input" value="${note.title || ''}" 
                                                   style="font-size: 1.8rem; font-weight: 600; font-family: 'Noto Serif JP', serif; padding: 0.5rem;"
                                                   onchange="updateNoteField(${note.id}, 'title', this.value)"
                                                   placeholder="Titre de la note">
                                            <span style="font-size: 0.8rem; padding: 0.4rem 0.8rem; background: var(--accent-gold); color: var(--bg-primary); border-radius: 2px;">${note.category || 'Note'}</span>
                                        </div>
                                    </div>
                                    
                                    <div class="detail-section">
                                        <div class="detail-section-title">Catégorie</div>
                                        <select class="form-input" onchange="updateNoteField(${note.id}, 'category', this.value)">
                                            <option value="Recherche" ${note.category === 'Recherche' ? 'selected' : ''}>Recherche</option>
                                            <option value="Idée" ${note.category === 'Idée' ? 'selected' : ''}>Idée</option>
                                            <option value="Référence" ${note.category === 'Référence' ? 'selected' : ''}>Référence</option>
                                            <option value="A faire" ${note.category === 'A faire' ? 'selected' : ''}>À faire</option>
                                            <option value="Question" ${note.category === 'Question' ? 'selected' : ''}>Question</option>
                                            <option value="Autre" ${note.category === 'Autre' ? 'selected' : ''}>Autre</option>
                                        </select>
                                    </div>

                                    <div class="detail-section">
                                        <div class="detail-section-title">Tags</div>
                                        <input type="text" class="form-input" value="${(note.tags || []).join(', ')}" 
                                               onchange="updateNoteTags(${note.id}, this.value)">
                                        <small style="color: var(--text-muted); font-style: italic;">Séparez les tags par des virgules</small>
                                    </div>

                                    <div class="detail-section">
                                        <div class="detail-section-title">Contenu</div>
                                        <textarea class="form-input" rows="20" 
                                                  oninput="updateNoteField(${note.id}, 'content', this.value)">${note.content || ''}</textarea>
                                    </div>

                                    <div style="font-size: 0.8rem; color: var(--text-muted); margin-top: 2rem; font-family: 'Source Code Pro', monospace;">
                                        Créée le ${new Date(note.createdAt).toLocaleDateString('fr-FR')} • 
                                        Modifiée le ${new Date(note.updatedAt).toLocaleDateString('fr-FR')}
                                    </div>
                                </div>
                            `;
                }
            } else {
                tempContainer.innerHTML = `
                            <div class="empty-state">
                                <div class="empty-state-icon"><i data-lucide="sticky-note" style="width:48px;height:48px;stroke-width:1.5;"></i></div>
                                <div class="empty-state-title">Notes</div>
                                <div class="empty-state-text">Sélectionnez une note dans la barre latérale</div>
                            </div>
                        `;
            }
            break;

        case 'mindmap':
            // Appeler la vraie fonction renderMindmapView
            if (typeof renderMindmapView === 'function') {
                renderMindmapView();
            }
            break;

        case 'corkboard':
            // Call real render function
            if (typeof openCorkBoardView === 'function') {
                openCorkBoardView();
            }
            break;

        case 'stats':
            // Call real render function
            if (typeof renderStats === 'function') {
                renderStats();
            }
            break;

        case 'analysis':
            // Call real render function
            if (typeof renderAnalysis === 'function') {
                renderAnalysis();
            }
            break;

        case 'map':
            // Call real render function
            if (typeof renderMapView === 'function') {
                renderMapView();
            }
            break;

        case 'codex':
            if (state.codexId) {
                // Render specific codex entry directly in the container
                const entry = project.codex?.find(c => c.id === state.codexId);
                if (entry) {
                    tempContainer.innerHTML = `
                                <div class="detail-view">
                                    <div class="detail-header">
                                        <div style="display: flex; align-items: center; gap: 1rem; flex: 1;">
                                            <input type="text" class="form-input" value="${entry.title}" 
                                                   style="font-size: 1.8rem; font-weight: 600; font-family: 'Noto Serif JP', serif; padding: 0.5rem;"
                                                   onchange="updateCodexField(${entry.id}, 'title', this.value)"
                                                   placeholder="Titre de l'entrée">
                                            <span style="font-size: 0.8rem; padding: 0.4rem 0.8rem; background: var(--accent-gold); color: var(--bg-primary); border-radius: 2px;">${entry.category}</span>
                                        </div>
                                    </div>
                                    
                                    <div class="detail-section">
                                        <div class="detail-section-title">Catégorie</div>
                                        <select class="form-input" onchange="updateCodexField(${entry.id}, 'category', this.value)">
                                            <option value="Culture" ${entry.category === 'Culture' ? 'selected' : ''}>Culture</option>
                                            <option value="Histoire" ${entry.category === 'Histoire' ? 'selected' : ''}>Histoire</option>
                                            <option value="Technologie" ${entry.category === 'Technologie' ? 'selected' : ''}>Technologie</option>
                                            <option value="Géographie" ${entry.category === 'Géographie' ? 'selected' : ''}>Géographie</option>
                                            <option value="Politique" ${entry.category === 'Politique' ? 'selected' : ''}>Politique</option>
                                            <option value="Magie/Pouvoir" ${entry.category === 'Magie/Pouvoir' ? 'selected' : ''}>Magie/Pouvoir</option>
                                            <option value="Religion" ${entry.category === 'Religion' ? 'selected' : ''}>Religion</option>
                                            <option value="Société" ${entry.category === 'Société' ? 'selected' : ''}>Société</option>
                                            <option value="Autre" ${entry.category === 'Autre' ? 'selected' : ''}>Autre</option>
                                        </select>
                                    </div>

                                    <div class="detail-section">
                                        <div class="detail-section-title">Résumé</div>
                                        <textarea class="form-input" rows="3" 
                                                  onchange="updateCodexField(${entry.id}, 'summary', this.value)">${entry.summary || ''}</textarea>
                                    </div>

                                    <div class="detail-section">
                                        <div class="detail-section-title">Contenu détaillé</div>
                                        <textarea class="form-input" rows="20" 
                                                  oninput="updateCodexField(${entry.id}, 'content', this.value)">${entry.content || ''}</textarea>
                                    </div>
                                </div>
                            `;
                }
            } else {
                tempContainer.innerHTML = `
                            <div class="empty-state">
                                <div class="empty-state-icon"><i data-lucide="book-open" style="width:48px;height:48px;stroke-width:1.5;"></i></div>
                                <div class="empty-state-title">Codex</div>
                                <div class="empty-state-text">Sélectionnez une entrée dans la barre latérale</div>
                            </div>
                        `;
            }
            break;

        case 'plot':
            // Call real render function
            if (typeof renderPlotView === 'function') {
                renderPlotView();
            }
            break;

        case 'relations':
            // Call real render function
            if (typeof renderRelationsView === 'function') {
                renderRelationsView();
            }
            break;

        case 'timelineviz':
            // Render timeline metro in split panel (without sidebar, just the main content)
            const charCount = project.characters?.length || 0;

            if (charCount === 0) {
                tempContainer.innerHTML = `
                            <div class="metro-empty-state">
                                <i data-lucide="users" style="width: 64px; height: 64px; opacity: 0.3;"></i>
                                <h3 style="margin: 1rem 0 0.5rem;">Aucun personnage</h3>
                                <p style="margin-bottom: 1.5rem;">Créez d'abord des personnages dans l'onglet "Personnages".</p>
                            </div>
                        `;
            } else {
                tempContainer.innerHTML = `
                            <div style="padding: 1rem; height: 100%; overflow: auto;">
                                <div class="metro-toolbar" style="margin-bottom: 1rem;">
                                    <button class="btn btn-primary" onclick="openMetroEventModal()">
                                        <i data-lucide="plus" style="width: 16px; height: 16px;"></i>
                                        Nouvel événement
                                    </button>
                                    <button class="btn" onclick="sortMetroByDate()">
                                        <i data-lucide="calendar" style="width: 16px; height: 16px;"></i>
                                        Trier par date
                                    </button>
                                </div>
                                
                                <div class="metro-timeline-container" id="metroTimelineContainer-split-${panel}">
                                    ${renderMetroSVG()}
                                </div>
                                
                                <div class="metro-legend" style="margin-top: 1rem;">
                                    ${project.characters.map(char => `
                                        <div class="metro-legend-item" onclick="openMetroColorPicker(${char.id})" style="cursor: pointer;" title="Cliquer pour changer la couleur">
                                            <div class="metro-legend-line" style="background: ${project.characterColors[char.id] || '#999'};"></div>
                                            <span>${char.name}</span>
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                        `;
            }
            break;

        case 'versions':
            // Call real render function
            if (typeof renderVersionsList === 'function') {
                renderVersionsList();
            }
            break;

        case 'todos':
            // Call real render function
            if (typeof renderTodosList === 'function') {
                renderTodosList();
            }
            break;

        case 'timeline':
            // Call real render function
            if (typeof renderTimelineList === 'function') {
                renderTimelineList();
            }
            break;

        default:
            tempContainer.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-state-icon"><i data-lucide="${viewIcons[view] || 'file'}" style="width:48px;height:48px;stroke-width:1.5;"></i></div>
                            <div class="empty-state-title">${viewLabels[view] || view}</div>
                            <div class="empty-state-text">Cette vue est disponible</div>
                        </div>
                    `;
    }

    // Restaurer l'ID du vrai editorView
    restoreEditorView();

    if (typeof lucide !== 'undefined') lucide.createIcons();
}

// Render the full editor with toolbar in a container (for split view)
/** [View] - Génère le HTML complet de l'éditeur pour un panneau split */
function renderEditorInContainer(act, chapter, scene, container, panel) {
    const wordCount = getWordCount(scene.content || '');

    // Vérifier si une version finale existe
    const hasFinalVersion = scene.versions && scene.versions.some(v => v.isFinal === true);
    const finalVersion = hasFinalVersion ? scene.versions.find(v => v.isFinal === true) : null;
    const finalVersionBadge = hasFinalVersion
        ? `<span style="display: inline-flex; align-items: center; gap: 0.25rem; background: var(--accent-gold); color: var(--bg-accent); font-size: 0.7rem; font-weight: 600; padding: 0.2rem 0.5rem; border-radius: 10px; margin-left: 0.5rem;" title="Version finale : ${finalVersion.number}"><i data-lucide="star" style="width:10px;height:10px;fill:currentColor;"></i> ${finalVersion.number}</span>`
        : '';

    container.innerHTML = `
                <div class="editor-fixed-top" style="position: relative;">
                    <div class="editor-header">
                        <div class="editor-breadcrumb">${act.title} > ${chapter.title}</div>
                        <div style="display: flex; align-items: center; gap: 1rem;">
                            <div class="editor-title" style="flex: 1;">${scene.title}${finalVersionBadge}</div>
                        </div>
                        <div class="editor-meta">
                            <span class="split-word-count-${panel}">${wordCount} mots</span>
                            <span>Dernière modification : ${new Date().toLocaleDateString('fr-FR')}</span>
                        </div>
                    </div>
                    <button class="toolbar-mobile-toggle" onclick="toggleSplitEditorToolbar('${panel}')">
                        <span><i data-lucide="pen-line" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Outils de formatage</span>
                    </button>
                    <div class="editor-toolbar" id="editorToolbar-${panel}">
                        ${getEditorToolbarHTML(panel)}
                    </div>
                    <div class="links-panel-sticky" id="linksPanel-${panel}">
                        <div style="display: flex; gap: 2rem; align-items: start;">
                            <div style="flex: 1;">
                                <div style="font-size: 0.85rem; font-weight: 600; margin-bottom: 0.5rem; color: var(--text-muted);"><i data-lucide="users" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Personnages</div>
                                <div class="quick-links"></div>
                            </div>
                            <div style="flex: 1;">
                                <div style="font-size: 0.85rem; font-weight: 600; margin-bottom: 0.5rem; color: var(--text-muted);"><i data-lucide="globe" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Lieux/Éléments</div>
                                <div class="quick-links"></div>
                            </div>
                            <div style="flex: 1;">
                                <div style="font-size: 0.85rem; font-weight: 600; margin-bottom: 0.5rem; color: var(--text-muted);"><i data-lucide="train-track" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Timeline</div>
                                <div class="quick-links"></div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="editor-workspace">
                    <div class="editor-content">
                        <div 
                            class="editor-textarea" 
                            contenteditable="true"
                            spellcheck="true"
                            id="editor-${panel}"
                            data-panel="${panel}"
                            data-scene-id="${scene.id}"
                            data-chapter-id="${chapter.id}"
                            data-act-id="${act.id}"
                            data-placeholder="Commencez à écrire votre scène..."
                            oninput="updateSplitSceneContent(this)"
                            onkeydown="handleEditorKeydown(event)"
                        >${scene.content || ''}</div>
                    </div>
                </div>
            `;

    // Initialize lucide icons and color pickers
    setTimeout(() => {
        if (typeof lucide !== 'undefined') lucide.createIcons();
        if (typeof initializeColorPickers === 'function') initializeColorPickers(panel);
    }, 50);
}

// Toggle toolbar visibility in split panel
/** [View] - Alterne la visibilité de la barre d'outils de l'éditeur en mode split */
function toggleSplitEditorToolbar(panel) {
    const toolbar = document.getElementById('editorToolbar-' + panel);
    if (toolbar) {
        toolbar.classList.toggle('visible');
    }
}

// Format text in a specific panel's editor
/** [View] - Applique des commandes de formatage directement au DOM de l'éditeur */
function formatTextInPanel(panel, command, value = null) {
    const editor = document.getElementById('editor-' + panel);
    if (!editor) return;

    // Focus the editor first
    editor.focus();

    // Execute the command
    if (value) {
        document.execCommand(command, false, value);
    } else {
        document.execCommand(command, false, null);
    }
}

// Render full world detail in container
/** [View] - Génère le HTML des détails d'un élément de l'univers pour un conteneur */
function renderWorldDetailInContainer(element, container) {
    container.innerHTML = `
                <div class="detail-view" style="height: 100%; overflow-y: auto;">
                    <div class="detail-header" style="position: sticky; top: 0; background: var(--bg-primary); z-index: 10; padding: 1rem; border-bottom: 1px solid var(--border-color);">
                        <div style="display: flex; align-items: center; gap: 1rem;">
                            <div class="detail-title" style="font-size: 1.5rem; font-weight: 600;">${element.name}</div>
                            <span style="font-size: 0.85rem; padding: 0.4rem 0.8rem; background: var(--primary-color); color: white; border-radius: 4px;">${element.type}</span>
                        </div>
                    </div>
                    
                    <div style="padding: 1.5rem;">
                        <div class="detail-section" style="margin-bottom: 1.5rem;">
                            <div class="detail-section-title" style="font-size: 0.9rem; font-weight: 600; color: var(--text-muted); margin-bottom: 0.5rem;">Nom</div>
                            <input type="text" class="form-input" value="${element.name}" 
                                   onchange="updateWorldField(${element.id}, 'name', this.value)" style="width: 100%;">
                        </div>

                        <div class="detail-section" style="margin-bottom: 1.5rem;">
                            <div class="detail-section-title" style="font-size: 0.9rem; font-weight: 600; color: var(--text-muted); margin-bottom: 0.5rem;">Type</div>
                            <select class="form-input" onchange="updateWorldField(${element.id}, 'type', this.value)" style="width: 100%;">
                                <option value="Lieu" ${element.type === 'Lieu' ? 'selected' : ''}>Lieu</option>
                                <option value="Objet" ${element.type === 'Objet' ? 'selected' : ''}>Objet</option>
                                <option value="Concept" ${element.type === 'Concept' ? 'selected' : ''}>Concept</option>
                                <option value="Organisation" ${element.type === 'Organisation' ? 'selected' : ''}>Organisation</option>
                                <option value="Événement" ${element.type === 'Événement' ? 'selected' : ''}>Événement</option>
                            </select>
                        </div>

                        <div class="detail-section" style="margin-bottom: 1.5rem;">
                            <div class="detail-section-title" style="font-size: 0.9rem; font-weight: 600; color: var(--text-muted); margin-bottom: 0.5rem;">Description</div>
                            <textarea class="form-input" rows="6" style="width: 100%; resize: vertical;"
                                      onchange="updateWorldField(${element.id}, 'description', this.value)">${element.description || ''}</textarea>
                        </div>

                        <div class="detail-section" style="margin-bottom: 1.5rem;">
                            <div class="detail-section-title" style="font-size: 0.9rem; font-weight: 600; color: var(--text-muted); margin-bottom: 0.5rem;">Détails</div>
                            <textarea class="form-input" rows="6" style="width: 100%; resize: vertical;"
                                      onchange="updateWorldField(${element.id}, 'details', this.value)">${element.details || ''}</textarea>
                        </div>

                        <div class="detail-section" style="margin-bottom: 1.5rem;">
                            <div class="detail-section-title" style="font-size: 0.9rem; font-weight: 600; color: var(--text-muted); margin-bottom: 0.5rem;">Histoire</div>
                            <textarea class="form-input" rows="6" style="width: 100%; resize: vertical;"
                                      onchange="updateWorldField(${element.id}, 'history', this.value)">${element.history || ''}</textarea>
                        </div>

                        <div class="detail-section" style="margin-bottom: 1.5rem;">
                            <div class="detail-section-title" style="font-size: 0.9rem; font-weight: 600; color: var(--text-muted); margin-bottom: 0.5rem;">Notes</div>
                            <textarea class="form-input" rows="4" style="width: 100%; resize: vertical;"
                                      onchange="updateWorldField(${element.id}, 'notes', this.value)">${element.notes || ''}</textarea>
                        </div>
                    </div>
                </div>
            `;
}

// Render full note detail in container
/** [View] - Génère le HTML des détails d'une note pour un conteneur */
function renderNoteDetailInContainer(note, container) {
    container.innerHTML = `
                <div class="detail-view" style="height: 100%; display: flex; flex-direction: column; overflow: hidden;">
                    <div class="detail-header" style="padding: 1rem; background: var(--bg-secondary); border-bottom: 1px solid var(--border-color);">
                        <div style="display: flex; align-items: center; gap: 1rem;">
                            <input type="text" class="form-input" value="${note.title || ''}" 
                                   style="font-size: 1.3rem; font-weight: 600; flex: 1; border: none; background: transparent;"
                                   onchange="updateNoteField(${note.id}, 'title', this.value)"
                                   placeholder="Titre de la note">
                            <select class="form-input" onchange="updateNoteField(${note.id}, 'category', this.value)" style="width: auto;">
                                <option value="Recherche" ${note.category === 'Recherche' ? 'selected' : ''}>Recherche</option>
                                <option value="Idée" ${note.category === 'Idée' ? 'selected' : ''}>Idée</option>
                                <option value="Référence" ${note.category === 'Référence' ? 'selected' : ''}>Référence</option>
                                <option value="A faire" ${note.category === 'A faire' ? 'selected' : ''}>À faire</option>
                                <option value="Question" ${note.category === 'Question' ? 'selected' : ''}>Question</option>
                                <option value="Autre" ${note.category === 'Autre' ? 'selected' : ''}>Autre</option>
                            </select>
                        </div>
                        <div style="margin-top: 0.5rem;">
                            <input type="text" class="form-input" value="${(note.tags || []).join(', ')}" 
                                   style="font-size: 0.85rem; width: 100%;"
                                   onchange="updateNoteTags(${note.id}, this.value)"
                                   placeholder="Tags (séparés par des virgules)">
                        </div>
                    </div>
                    <div style="flex: 1; padding: 1rem; overflow: hidden;">
                        <textarea class="form-input" 
                                  style="width: 100%; height: 100%; resize: none; font-size: 1rem; line-height: 1.7; border: none; background: var(--bg-primary);"
                                  oninput="updateNoteField(${note.id}, 'content', this.value)"
                                  placeholder="Contenu de la note...">${note.content || ''}</textarea>
                    </div>
                    <div style="padding: 0.5rem 1rem; font-size: 0.75rem; color: var(--text-muted); background: var(--bg-secondary); border-top: 1px solid var(--border-color);">
                        Créée le ${new Date(note.createdAt).toLocaleDateString('fr-FR')} • 
                        Modifiée le ${new Date(note.updatedAt).toLocaleDateString('fr-FR')}
                    </div>
                </div>
            `;
}

/** [View] - Génère le HTML de la vue "Tableau de liège" en mode split */
function renderCorkboardInSplitPanel(containerId) {
    const container = document.getElementById(containerId);
    if (!container) return;

    container.innerHTML = `
                <div style="padding: 1rem;">
                    <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 1rem;">
                        ${project.acts.map(act =>
        act.chapters.map(chapter =>
            chapter.scenes.map(scene => `
                                    <div class="cork-card" onclick="openSceneFromSplit(${act.id}, ${chapter.id}, ${scene.id})" style="background: var(--bg-secondary); padding: 1rem; border-radius: 8px; border: 1px solid var(--border-color); cursor: pointer; transition: transform 0.15s, box-shadow 0.15s;">
                                        <div style="font-weight: 600; margin-bottom: 0.5rem;">${scene.title || 'Sans titre'}</div>
                                        <div style="font-size: 0.8rem; color: var(--text-muted);">${chapter.title}</div>
                                        <div style="font-size: 0.75rem; color: var(--text-muted); margin-top: 0.5rem;">${getWordCount(scene.content || '')} mots</div>
                                    </div>
                                `).join('')
        ).join('')
    ).join('')}
                    </div>
                </div>
            `;
}

// Helper to open a scene from corkboard in split mode
/** [ViewModel] - Logique métier pour l'ouverture d'une scène via le tableau de liège */
function openSceneFromSplit(actId, chapterId, sceneId) {
    if (splitViewActive) {
        const state = splitActivePanel === 'left' ? splitViewState.left : splitViewState.right;
        state.view = 'editor';
        state.actId = actId;
        state.chapterId = chapterId;
        state.sceneId = sceneId;
        renderSplitPanelViewContent(splitActivePanel);
        updateSplitPanelHeader(splitActivePanel);
        updateSidebarForSplitPanel(splitActivePanel);
    } else {
        openScene(actId, chapterId, sceneId);
    }
}

/** [Mixte] - Agrège les données (Model) et génère le HTML des statistiques (View) */
function renderStatsInSplitPanel(containerId) {
    const container = document.getElementById(containerId);
    if (!container) return;

    let totalWords = 0;
    let totalScenes = 0;
    let totalChapters = 0;

    project.acts.forEach(act => {
        act.chapters.forEach(chapter => {
            totalChapters++;
            chapter.scenes.forEach(scene => {
                totalScenes++;
                totalWords += getWordCount(scene.content || '');
            });
        });
    });

    container.innerHTML = `
                <div style="padding: 1.5rem;">
                    <h3 style="margin-bottom: 1.5rem;">Statistiques du projet</h3>
                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem;">
                        <div style="background: var(--bg-secondary); padding: 1.5rem; border-radius: 8px; text-align: center;">
                            <div style="font-size: 2rem; font-weight: 700; color: var(--primary-color);">${totalWords.toLocaleString()}</div>
                            <div style="color: var(--text-muted);">Mots</div>
                        </div>
                        <div style="background: var(--bg-secondary); padding: 1.5rem; border-radius: 8px; text-align: center;">
                            <div style="font-size: 2rem; font-weight: 700; color: var(--primary-color);">${totalScenes}</div>
                            <div style="color: var(--text-muted);">Scènes</div>
                        </div>
                        <div style="background: var(--bg-secondary); padding: 1.5rem; border-radius: 8px; text-align: center;">
                            <div style="font-size: 2rem; font-weight: 700; color: var(--primary-color);">${totalChapters}</div>
                            <div style="color: var(--text-muted);">Chapitres</div>
                        </div>
                        <div style="background: var(--bg-secondary); padding: 1.5rem; border-radius: 8px; text-align: center;">
                            <div style="font-size: 2rem; font-weight: 700; color: var(--primary-color);">${project.characters?.length || 0}</div>
                            <div style="color: var(--text-muted);">Personnages</div>
                        </div>
                    </div>
                </div>
            `;
}

// Render Plot view in split panel
/** [View] - Génère le graphique SVG de l'intrigue pour un conteneur */
function renderPlotInSplitPanel(container) {
    // Initialiser les points d'intrigue si nécessaire
    if (typeof plotPoints === 'undefined' || plotPoints.length === 0) {
        if (typeof initPlotPoints === 'function') {
            initPlotPoints();
        }
    }

    const svgWidth = 600;
    const svgHeight = 350;
    const padding = 50;
    const plotWidth = svgWidth - padding * 2;
    const plotHeight = svgHeight - padding * 2;

    let pathData = '';
    let pointsHTML = '';
    let gridLines = '';

    // Lignes de grille
    for (let i = 0; i <= 4; i++) {
        const y = padding + (plotHeight / 4) * i;
        gridLines += `<line x1="${padding}" y1="${y}" x2="${svgWidth - padding}" y2="${y}" stroke="var(--border-color)" stroke-width="1" opacity="0.3" stroke-dasharray="5,5"/>`;
    }

    // Générer la courbe si plotPoints existe
    if (typeof plotPoints !== 'undefined' && plotPoints.length > 0) {
        plotPoints.forEach((point, index) => {
            const x = padding + (plotWidth / Math.max(plotPoints.length - 1, 1)) * index;
            const y = padding + plotHeight - (point.intensity / 100) * plotHeight;

            if (index === 0) {
                pathData = `M ${x} ${y}`;
            } else {
                pathData += ` L ${x} ${y}`;
            }

            pointsHTML += `
                        <circle cx="${x}" cy="${y}" r="5" fill="var(--accent-gold)" stroke="white" stroke-width="2" 
                                style="cursor: pointer;" 
                                onclick="openScene(${point.actId}, ${point.chapterId}, ${point.sceneId})">
                            <title>${point.title} - Tension: ${Math.round(point.intensity)}%</title>
                        </circle>
                    `;
        });
    }

    container.innerHTML = `
                <div style="padding: 1.5rem;">
                    <h3 style="margin-bottom: 1rem;"><i data-lucide="trending-up" style="width:18px;height:18px;vertical-align:middle;margin-right:6px;"></i>Graphique d'Intrigue</h3>
                    <div style="background: var(--bg-secondary); border-radius: 8px; padding: 1rem; overflow-x: auto;">
                        <svg viewBox="0 0 ${svgWidth} ${svgHeight}" style="width: 100%; max-width: ${svgWidth}px; height: auto;">
                            ${gridLines}
                            ${pathData ? `<path d="${pathData}" fill="none" stroke="var(--primary-color)" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/>` : ''}
                            ${pointsHTML}
                        </svg>
                    </div>
                    <div style="margin-top: 1rem; font-size: 0.85rem; color: var(--text-muted);">
                        ${typeof plotPoints !== 'undefined' ? plotPoints.length : 0} points d'intrigue • Cliquez sur un point pour ouvrir la scène
                    </div>
                </div>
            `;
    if (typeof lucide !== 'undefined') lucide.createIcons();
}

// Render Relations view in split panel
/** [View] - Génère le HTML des relations entre personnages pour un conteneur */
function renderRelationsInSplitPanel(container) {
    const relationships = project.relationships || [];
    const characters = project.characters || [];

    if (characters.length < 2) {
        container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon"><i data-lucide="heart-handshake" style="width:48px;height:48px;stroke-width:1.5;"></i></div>
                        <div class="empty-state-title">Relations</div>
                        <div class="empty-state-text">Créez au moins 2 personnages pour définir leurs relations</div>
                    </div>
                `;
        if (typeof lucide !== 'undefined') lucide.createIcons();
        return;
    }

    let relationsHTML = '';
    if (relationships.length > 0) {
        relationsHTML = relationships.map(rel => {
            const char1 = characters.find(c => c.id === rel.character1Id);
            const char2 = characters.find(c => c.id === rel.character2Id);
            if (!char1 || !char2) return '';

            return `
                        <div style="background: var(--bg-secondary); padding: 1rem; border-radius: 8px; margin-bottom: 0.75rem;">
                            <div style="display: flex; align-items: center; gap: 1rem;">
                                <span style="font-weight: 600;">${char1.name || char1.firstName || 'Personnage 1'}</span>
                                <span style="color: var(--primary-color);">↔</span>
                                <span style="font-weight: 600;">${char2.name || char2.firstName || 'Personnage 2'}</span>
                            </div>
                            <div style="font-size: 0.9rem; color: var(--text-muted); margin-top: 0.5rem;">${rel.type || 'Relation'}</div>
                            ${rel.description ? `<div style="font-size: 0.85rem; margin-top: 0.5rem;">${rel.description}</div>` : ''}
                        </div>
                    `;
        }).join('');
    } else {
        relationsHTML = '<div style="color: var(--text-muted); text-align: center; padding: 2rem;">Aucune relation définie</div>';
    }

    container.innerHTML = `
                <div style="padding: 1.5rem;">
                    <h3 style="margin-bottom: 1rem;"><i data-lucide="heart-handshake" style="width:18px;height:18px;vertical-align:middle;margin-right:6px;"></i>Relations entre personnages</h3>
                    <div>${relationsHTML}</div>
                    <button class="btn btn-primary" onclick="openAddRelationModal()" style="margin-top: 1rem;">+ Ajouter une relation</button>
                </div>
            `;
    if (typeof lucide !== 'undefined') lucide.createIcons();
}

// Render Timeline view in split panel
/** [View] - Génère le HTML de la chronologie pour un conteneur */
function renderTimelineInSplitPanel(container) {
    const events = project.timeline || [];

    if (events.length === 0) {
        container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon"><i data-lucide="calendar-range" style="width:48px;height:48px;stroke-width:1.5;"></i></div>
                        <div class="empty-state-title">Timeline</div>
                        <div class="empty-state-text">Aucun événement dans la chronologie</div>
                        <button class="btn btn-primary" onclick="openAddTimelineModal()" style="margin-top: 1rem;">+ Ajouter un événement</button>
                    </div>
                `;
        if (typeof lucide !== 'undefined') lucide.createIcons();
        return;
    }

    // Trier par date si possible
    const sortedEvents = [...events].sort((a, b) => {
        if (a.date && b.date) return new Date(a.date) - new Date(b.date);
        return 0;
    });

    const eventsHTML = sortedEvents.map((event, index) => `
                <div style="display: flex; gap: 1rem; margin-bottom: 1.5rem;">
                    <div style="display: flex; flex-direction: column; align-items: center;">
                        <div style="width: 12px; height: 12px; background: var(--primary-color); border-radius: 50%;"></div>
                        ${index < sortedEvents.length - 1 ? '<div style="width: 2px; flex: 1; background: var(--border-color);"></div>' : ''}
                    </div>
                    <div style="flex: 1; background: var(--bg-secondary); padding: 1rem; border-radius: 8px;">
                        <div style="font-weight: 600;">${event.title}</div>
                        ${event.date ? `<div style="font-size: 0.85rem; color: var(--primary-color); margin-top: 0.25rem;">${event.date}</div>` : ''}
                        ${event.description ? `<div style="font-size: 0.9rem; color: var(--text-muted); margin-top: 0.5rem;">${event.description}</div>` : ''}
                    </div>
                </div>
            `).join('');

    container.innerHTML = `
                <div style="padding: 1.5rem;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
                        <h3 style="margin: 0;"><i data-lucide="calendar-range" style="width:18px;height:18px;vertical-align:middle;margin-right:6px;"></i>Chronologie</h3>
                        <button class="btn btn-small" onclick="openAddTimelineModal()">+ Événement</button>
                    </div>
                    <div>${eventsHTML}</div>
                </div>
            `;
    if (typeof lucide !== 'undefined') lucide.createIcons();
}

// View selector for split panels
let currentSplitSelectorPanel = null;

/** [View] - Ouvre la modal de sélection de vue pour un panneau */
function openSplitViewSelector(panel) {
    currentSplitSelectorPanel = panel;

    const content = document.getElementById('splitSelectorContent');
    if (!content) return;

    const currentView = panel === 'left' ? splitViewState.left.view : splitViewState.right.view;

    const views = [
        { id: 'editor', label: 'Structure', icon: 'pen-line', desc: 'Écrire vos scènes' },
        { id: 'characters', label: 'Personnages', icon: 'users', desc: 'Fiches personnages' },
        { id: 'world', label: 'Univers', icon: 'globe', desc: 'Lieux et éléments' },
        { id: 'notes', label: 'Notes', icon: 'sticky-note', desc: 'Vos notes' },
        { id: 'codex', label: 'Codex', icon: 'book-open', desc: 'Encyclopédie' },
        { id: 'corkboard', label: 'Tableau', icon: 'layout-grid', desc: 'Vue tableau liège' },
        { id: 'mindmap', label: 'Mindmap', icon: 'git-branch', desc: 'Carte mentale' },
        { id: 'plot', label: 'Intrigue', icon: 'trending-up', desc: 'Arcs narratifs' },
        { id: 'relations', label: 'Relations', icon: 'heart-handshake', desc: 'Liens entre personnages' },
        { id: 'map', label: 'Carte', icon: 'map', desc: 'Carte du monde' },
        { id: 'timelineviz', label: 'Timeline Métro', icon: 'train-track', desc: 'Timeline visuelle' },
        { id: 'timeline', label: 'Timeline', icon: 'calendar-range', desc: 'Timeline classique' },
        { id: 'stats', label: 'Statistiques', icon: 'bar-chart-3', desc: 'Stats du projet' },
        { id: 'analysis', label: 'Analyse', icon: 'trending-up', desc: 'Analyse du texte' },
        { id: 'versions', label: 'Versions', icon: 'file-clock', desc: 'Versions des scènes' },
        { id: 'todos', label: 'TODOs', icon: 'list-todo', desc: 'Liste des tâches' }
    ];

    content.innerHTML = `
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.5rem; padding: 0.5rem;">
                    ${views.map(v => `
                        <div class="split-view-option ${currentView === v.id ? 'active' : ''}" 
                             onclick="selectSplitPanelView('${v.id}')"
                             style="display: flex; flex-direction: column; align-items: center; gap: 0.5rem; padding: 1rem 0.5rem; border-radius: 8px; cursor: pointer; background: ${currentView === v.id ? 'var(--primary-color)' : 'var(--bg-secondary)'}; color: ${currentView === v.id ? 'white' : 'var(--text-primary)'}; transition: all 0.15s; text-align: center;">
                            <i data-lucide="${v.icon}" style="width:28px;height:28px;"></i>
                            <div>
                                <div style="font-weight: 600; font-size: 0.9rem;">${v.label}</div>
                                <div style="font-size: 0.7rem; opacity: 0.7; margin-top: 0.25rem;">${v.desc}</div>
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;

    document.getElementById('splitSelectorModal').classList.add('active');
    if (typeof lucide !== 'undefined') lucide.createIcons();
}

/** [ViewModel] - Action utilisateur de sélection d'une vue dans la modal */
function selectSplitPanelView(view) {
    if (!currentSplitSelectorPanel) return;

    switchSplitPanelView(currentSplitSelectorPanel, view);
    closeModal('splitSelectorModal');
}

// Handle scene selection in split view
/** [ViewModel] - Met à jour l'état métier pour afficher une scène spécifique */
function openSceneInSplitPanel(actId, chapterId, sceneId) {
    if (!splitViewActive) return;

    const state = splitActivePanel === 'left' ? splitViewState.left : splitViewState.right;

    // Only update if the active panel is showing editor view
    if (state.view === 'editor') {
        state.actId = actId;
        state.chapterId = chapterId;
        state.sceneId = sceneId;

        // Also update global current IDs
        currentActId = actId;
        currentChapterId = chapterId;
        currentSceneId = sceneId;

        renderSplitPanelViewContent(splitActivePanel);
        saveSplitViewState();
    }
}

// Handle character selection in split view
/** [ViewModel] - Met à jour l'état métier pour afficher un personnage spécifique */
function openCharacterInSplitPanel(charId) {
    if (!splitViewActive) return;

    const state = splitActivePanel === 'left' ? splitViewState.left : splitViewState.right;

    if (state.view === 'characters') {
        state.characterId = charId;
        renderSplitPanelViewContent(splitActivePanel);
        saveSplitViewState();
    }
}

// Handle world element selection in split view
/** [ViewModel] - Met à jour l'état métier pour afficher un élément de l'univers */
function openWorldElementInSplitPanel(elemId) {
    if (!splitViewActive) return;

    const state = splitActivePanel === 'left' ? splitViewState.left : splitViewState.right;

    if (state.view === 'world') {
        state.worldId = elemId;
        renderSplitPanelViewContent(splitActivePanel);
        saveSplitViewState();
    }
}

// Handle note selection in split view  
/** [ViewModel] - Met à jour l'état métier pour afficher une note spécifique */
function openNoteInSplitPanel(noteId) {
    if (!splitViewActive) return;

    const state = splitActivePanel === 'left' ? splitViewState.left : splitViewState.right;

    if (state.view === 'notes') {
        state.noteId = noteId;
        renderSplitPanelViewContent(splitActivePanel);
        saveSplitViewState();
    }
}

/** [Mixte] - Synchronise le contenu du DOM (View) vers les données du projet (Model) */
function updateSplitSceneContent(editor) {
    const sceneId = parseInt(editor.dataset.sceneId);
    const chapterId = parseInt(editor.dataset.chapterId);
    const actId = parseInt(editor.dataset.actId);
    const panel = editor.dataset.panel;

    const act = project.acts.find(a => a.id === actId);
    if (!act) return;
    const chapter = act.chapters.find(c => c.id === chapterId);
    if (!chapter) return;
    const scene = chapter.scenes.find(s => s.id === sceneId);
    if (!scene) return;

    scene.content = editor.innerHTML;
    const wordCount = getWordCount(editor.innerHTML);
    scene.wordCount = wordCount;

    // Update word count display
    const wcDisplay = document.querySelector(`.split-word-count-${panel}`);
    if (wcDisplay) wcDisplay.textContent = wordCount;

    saveProject();
}

/** [Mixte] - Synchronise le contenu du textarea (View) vers les données de la note (Model) */
function updateSplitNoteContent(textarea) {
    const noteId = parseInt(textarea.dataset.noteId);
    const note = project.notes?.find(n => n.id === noteId);
    if (note) {
        note.content = textarea.value;
        saveProject();
    }
}

// Resizer functionality
let isResizing = false;

/** [View] - Initialise le processus de redimensionnement des panneaux via la souris/tactile */
function startSplitResize(e) {
    isResizing = true;

    const resizer = document.getElementById('splitResizer');
    if (resizer) resizer.classList.add('dragging');

    document.body.style.cursor = 'col-resize';
    document.body.style.userSelect = 'none';

    document.addEventListener('mousemove', doSplitResize);
    document.addEventListener('mouseup', stopSplitResize);
    document.addEventListener('touchmove', doSplitResize, { passive: false });
    document.addEventListener('touchend', stopSplitResize);

    e.preventDefault();
}

/** [Mixte/View] - Calcule le nouveau ratio et met à jour le style CSS des panneaux */
function doSplitResize(e) {
    if (!isResizing) return;

    const container = document.getElementById('splitViewContainer');
    if (!container) return;

    const currentX = e.clientX || (e.touches && e.touches[0].clientX);
    const containerRect = container.getBoundingClientRect();
    const containerWidth = containerRect.width;

    let newRatio = ((currentX - containerRect.left) / containerWidth) * 100;
    newRatio = Math.max(20, Math.min(80, newRatio));

    splitViewState.ratio = newRatio;

    const leftPanel = document.getElementById('splitPanelLeft');
    const rightPanel = document.getElementById('splitPanelRight');

    if (leftPanel) leftPanel.style.flex = newRatio;
    if (rightPanel) rightPanel.style.flex = 100 - newRatio;

    e.preventDefault();
}

/** [ViewModel/View] - Finalise le redimensionnement et sauvegarde l'état */
function stopSplitResize() {
    isResizing = false;

    const resizer = document.getElementById('splitResizer');
    if (resizer) resizer.classList.remove('dragging');

    document.body.style.cursor = '';
    document.body.style.userSelect = '';

    document.removeEventListener('mousemove', doSplitResize);
    document.removeEventListener('mouseup', stopSplitResize);
    document.removeEventListener('touchmove', doSplitResize);
    document.removeEventListener('touchend', stopSplitResize);

    saveSplitViewState();
}

/** [Model] - Persiste l'état actuel du mode split dans le stockage local */
function saveSplitViewState() {
    if (splitViewState.persistOnReload) {
        localStorage.setItem('plume_splitViewState', JSON.stringify({
            active: splitViewActive,
            activePanel: splitActivePanel,
            state: splitViewState
        }));
    }
}

/** [Model] - Récupère l'état sauvegardé du mode split du stockage local */
function loadSplitViewState() {
    const saved = localStorage.getItem('plume_splitViewState');
    if (saved) {
        try {
            const data = JSON.parse(saved);
            if (data.state && data.state.persistOnReload) {
                splitViewState = { ...splitViewState, ...data.state };
                splitActivePanel = data.activePanel || 'left';
                if (data.active) {
                    splitViewActive = true;
                    setTimeout(() => {
                        renderSplitView();
                        updateSplitToggleButton();
                    }, 500);
                }
            }
        } catch (e) {
            console.error('Error loading split view state:', e);
        }
    }
}

// Legacy function for compatibility
/** [ViewModel] - Fonction legacy pour ouvrir un personnage en panneau latéral droit */
function openCharacterBeside(charId) {
    if (!splitViewActive) {
        activateSplitView();
    }

    // Set right panel to characters view with this character
    splitViewState.right.view = 'characters';
    splitViewState.right.characterId = charId;
    splitActivePanel = 'right';

    renderSplitView();
    showNotification('Personnage ouvert dans le panneau droit');
}

/** [Mixte/ViewModel] - Met à jour un champ personnage et déclenche rendu/sauvegarde */
function updateCharacterField(id, field, value) {
    const character = project.characters.find(c => c.id === id);
    if (character) {
        character[field] = value;
        saveProject();
        renderCharactersList();
    }
}


// ========== js-refactor/world/world.model.js ==========
/**
 * [MVVM : World Model]
 * Defines the structure of world elements and factory functions.
 */

const WorldModel = {
    /**
     * Create a new world element.
     * @param {Object} data - Initial data for the element.
     * @returns {Object} A new world element object.
     */
    create: function (data = {}) {
        const now = Date.now();
        return {
            id: data.id || now,
            name: data.name || '',
            type: data.type || 'Lieu',
            description: data.description || '',
            details: data.details || '',
            history: data.history || '',
            notes: data.notes || '',
            linkedScenes: data.linkedScenes || [], // Array of scene IDs
            linkedElements: data.linkedElements || [], // Array of {type, id}
            createdAt: data.createdAt || new Date(now).toISOString(),
            updatedAt: data.updatedAt || new Date(now).toISOString()
        };
    },

    /**
     * Migrate a legacy world element structure if necessary.
     * @param {Object} raw - Raw data from project.world.
     * @returns {Object} Migrated element.
     */
    migrate: function (raw) {
        if (!raw) return null;

        // Ensure all required fields exist
        return {
            ...this.create(raw),
            // Add specific migration logic here if fields changed in the past
            linkedScenes: raw.linkedScenes || [],
            linkedElements: raw.linkedElements || []
        };
    }
};

// ========== js-refactor/world/world.repository.js ==========
/**
 * [MVVM : World Repository]
 * Data access layer for world elements.
 */

const WorldRepository = {
    /**
     * Get all world elements.
     * @returns {Array} List of world elements.
     */
    getAll: () => {
        return project.world || [];
    },

    /**
     * Get a world element by ID.
     * @param {number} id - Element ID.
     * @returns {Object|null} The element or null if not found.
     */
    getById: (id) => {
        return (project.world || []).find(w => w.id === id) || null;
    },

    /**
     * Add a new world element.
     * @param {Object} element - The element to add.
     * @returns {Object} The added element.
     */
    add: (element) => {
        if (!project.world) project.world = [];
        project.world.push(element);
        return element;
    },

    /**
     * Update an existing world element.
     * @param {number} id - Element ID.
     * @param {Object} updates - Data to update.
     * @returns {Object|null} The updated element or null if not found.
     */
    update: (id, updates) => {
        const index = (project.world || []).findIndex(w => w.id === id);
        if (index === -1) return null;

        const updated = {
            ...project.world[index],
            ...updates,
            updatedAt: new Date().toISOString()
        };
        project.world[index] = updated;
        return updated;
    },

    /**
     * Remove a world element.
     * @param {number} id - Element ID.
     * @returns {Object|null} The removed element or null if not found.
     */
    remove: (id) => {
        const index = (project.world || []).findIndex(w => w.id === id);
        if (index === -1) return null;

        const removed = project.world[index];
        project.world = project.world.filter(w => w.id !== id);
        return removed;
    }
};

// ========== js-refactor/world/world.viewmodel.js ==========
/**
 * [MVVM : World ViewModel]
 * Business logic and data preparation for the World UI.
 */

/**
 * Coordination to add a world element.
 */
function addWorldElementViewModel(name, type, description) {
    if (!name) return { success: false, message: 'Le nom est obligatoire' };

    const elementData = {
        name: name,
        type: type,
        description: description
    };

    const newElement = WorldModel.create(elementData);
    WorldRepository.add(newElement);

    return {
        success: true,
        element: newElement,
        sideEffects: {
            shouldSave: true,
            shouldRefreshList: true,
            shouldCloseModal: 'addWorldModal'
        }
    };
}

/**
 * Coordination to delete a world element.
 */
function deleteWorldElementViewModel(id) {
    WorldRepository.remove(id);

    return {
        success: true,
        sideEffects: {
            shouldSave: true,
            shouldRefreshList: true,
            shouldShowEmptyState: true
        }
    };
}

/**
 * Group world elements by type for display.
 */
function getGroupedWorldElementsViewModel() {
    const elements = WorldRepository.getAll();
    const groups = {};

    elements.forEach(elem => {
        const type = elem.type || 'Autre';
        if (!groups[type]) groups[type] = [];
        groups[type].push(WorldModel.migrate(elem));
    });

    // Sort elements alphabetically within each group
    Object.keys(groups).forEach(type => {
        groups[type].sort((a, b) => {
            return (a.name || '').toLowerCase().localeCompare((b.name || '').toLowerCase(), 'fr');
        });
    });

    return groups;
}

/**
 * Prepare data for the detail view of a world element.
 */
function getWorldDetailViewModel(id) {
    const rawElement = WorldRepository.getById(id);
    if (!rawElement) return null;

    const element = WorldModel.migrate(rawElement);
    const linkedScenes = getLinkedScenesForElementViewModel(id);

    return {
        element,
        linkedScenes
    };
}

/**
 * Get scenes linked to a world element.
 */
function getLinkedScenesForElementViewModel(elementId) {
    if (typeof findScenesWithElement !== 'function') return [];

    const scenes = findScenesWithElement(elementId);

    return scenes.map(scene => {
        const acts = (typeof project !== 'undefined' && project.acts) ? project.acts : [];
        const actIndex = acts.findIndex(a => a.id === scene.actId);

        // Calculation of act and chapter indices for breadcrumbs
        const actNumber = actIndex !== -1 ? toRoman(actIndex + 1) : '?';

        let chapterNumber = '?';
        if (actIndex !== -1) {
            const chapIndex = acts[actIndex].chapters.findIndex(c => c.id === scene.chapterId);
            if (chapIndex !== -1) chapterNumber = chapIndex + 1;
        }

        return {
            ...scene,
            actNumber,
            chapterNumber,
            breadcrumb: `Acte ${actNumber} › Chapitre ${chapterNumber} › ${scene.sceneTitle}`
        };
    });
}

/**
 * Generic field update.
 */
function updateWorldFieldViewModel(id, field, value) {
    const updated = WorldRepository.update(id, { [field]: value });

    return {
        success: !!updated,
        sideEffects: {
            shouldSave: true,
            shouldRefreshList: (field === 'name' || field === 'type')
        }
    };
}

// ========== js-refactor/world/world.view.js ==========
/**
 * [MVVM : World View]
 * UI Rendering and DOM interactions for World management.
 */

// Icons for each type
const WORLD_TYPE_ICONS = {
    'Lieu': 'map-pin',
    'Objet': 'package',
    'Concept': 'lightbulb',
    'Organisation': 'users',
    'Événement': 'calendar',
    'Autre': 'more-horizontal'
};

/**
 * Opens the add world modal and sets focus.
 */
function openAddWorldModal() {
    const modal = document.getElementById('addWorldModal');
    if (modal) {
        modal.classList.add('active');
        setTimeout(() => {
            const input = document.getElementById('worldNameInput');
            if (input) input.focus();
        }, 100);
    }
}

/**
 * Handles the "Add" button click in the modal.
 */
function handleAddWorldElement() {
    const name = document.getElementById('worldNameInput').value.trim();
    const type = document.getElementById('worldTypeInput').value;
    const description = document.getElementById('worldDescInput').value.trim();

    const result = addWorldElementViewModel(name, type, description);

    if (result.success) {
        // Clear inputs
        document.getElementById('worldNameInput').value = '';
        document.getElementById('worldDescInput').value = '';

        if (result.sideEffects.shouldCloseModal) {
            closeModal(result.sideEffects.shouldCloseModal);
        }
        if (result.sideEffects.shouldSave && typeof saveProject === 'function') {
            saveProject();
        }
        if (result.sideEffects.shouldRefreshList) {
            renderWorldList();
        }
    }
}

/**
 * Handles the delete button click.
 */
function handleDeleteWorldElement(id) {
    if (!confirm('Êtes-vous sûr de vouloir supprimer cet élément ?')) return;

    const result = deleteWorldElementViewModel(id);

    if (result.success) {
        if (result.sideEffects.shouldSave && typeof saveProject === 'function') {
            saveProject();
        }
        if (result.sideEffects.shouldRefreshList) {
            renderWorldList();
        }
        if (result.sideEffects.shouldShowEmptyState && typeof showEmptyState === 'function') {
            showEmptyState();
        }
    }
}

/**
 * Renders the list of world elements grouped by type.
 */
function renderWorldList() {
    const container = document.getElementById('worldList');
    if (!container) return;

    const groups = getGroupedWorldElementsViewModel();
    const groupKeys = Object.keys(groups).sort();

    if (groupKeys.length === 0) {
        container.innerHTML = '<div style="padding: 1rem; text-align: center; color: var(--text-muted); font-size: 0.85rem;">Aucun élément</div>';
        return;
    }

    const collapsedState = JSON.parse(localStorage.getItem('plume_treeview_collapsed') || '{}');

    let html = '';
    groupKeys.forEach(type => {
        const groupKey = 'world_' + type;
        const isCollapsed = collapsedState[groupKey] === true;
        const elements = groups[type];

        html += `
            <div class="treeview-group">
                <div class="treeview-header" onclick="toggleTreeviewGroup('${groupKey}')">
                    <i data-lucide="${isCollapsed ? 'chevron-right' : 'chevron-down'}" class="treeview-chevron"></i>
                    <span class="treeview-label">${type}</span>
                    <span class="treeview-count">${elements.length}</span>
                </div>
                <div class="treeview-children ${isCollapsed ? 'collapsed' : ''}">
                    ${elements.map(elem => {
            const iconName = WORLD_TYPE_ICONS[type] || 'circle';
            return `
                            <div class="treeview-item" onclick="openWorldDetail(${elem.id})">
                                <span class="treeview-item-icon"><i data-lucide="${iconName}" style="width:14px;height:14px;vertical-align:middle;"></i></span>
                                <span class="treeview-item-label">${elem.name}</span>
                                <button class="treeview-item-delete" onclick="event.stopPropagation(); handleDeleteWorldElement(${elem.id})" title="Supprimer"><i data-lucide="x" style="width:12px;height:12px;"></i></button>
                            </div>
                        `;
        }).join('')}
                </div>
            </div>
        `;
    });

    container.innerHTML = html;
    if (typeof lucide !== 'undefined') lucide.createIcons();
}

/**
 * Opens the detail view for a world element.
 */
function openWorldDetail(id) {
    const data = getWorldDetailViewModel(id);
    if (!data) return;

    // Handle split view mode
    if (typeof splitViewActive !== 'undefined' && splitViewActive) {
        const state = splitActivePanel === 'left' ? splitViewState.left : splitViewState.right;
        if (state.view === 'world') {
            state.worldId = id;
            if (typeof renderSplitPanelViewContent === 'function') {
                renderSplitPanelViewContent(splitActivePanel);
            }
            if (typeof saveSplitViewState === 'function') {
                saveSplitViewState();
            }
            return;
        }
    }

    const editorView = document.getElementById('editorView');
    if (!editorView) return;

    editorView.innerHTML = `
        <div class="detail-view">
            <div class="detail-header">
                <div style="display: flex; align-items: center; gap: 1rem;">
                    <div class="detail-title">${data.element.name}</div>
                    <span style="font-size: 0.9rem; padding: 0.5rem 1rem; background: var(--accent-gold); color: var(--bg-primary); border-radius: 2px;">${data.element.type}</span>
                </div>
                <div style="display: flex; gap: 0.5rem;">
                    <button class="btn btn-small" onclick="showReferencesForElement(${id})"><i data-lucide="link" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Voir les références</button>
                    <button class="btn" onclick="switchView('editor')"><i data-lucide="arrow-left" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i> Retour à l'éditeur</button>
                </div>
            </div>
            
            ${renderLinkedScenesFragment(data.linkedScenes)}
            
            <div class="detail-section">
                <div class="detail-section-title">Informations de base</div>
                <div class="detail-field">
                    <div class="detail-label">Nom</div>
                    <input type="text" class="form-input" value="${data.element.name}" 
                           onchange="handleUpdateWorldField(${id}, 'name', this.value)">
                </div>
            </div>

            <div class="detail-section">
                <div class="detail-section-title">Type</div>
                <select class="form-input" onchange="handleUpdateWorldField(${id}, 'type', this.value)">
                    <option value="Lieu" ${data.element.type === 'Lieu' ? 'selected' : ''}>Lieu</option>
                    <option value="Objet" ${data.element.type === 'Objet' ? 'selected' : ''}>Objet</option>
                    <option value="Concept" ${data.element.type === 'Concept' ? 'selected' : ''}>Concept</option>
                    <option value="Organisation" ${data.element.type === 'Organisation' ? 'selected' : ''}>Organisation</option>
                    <option value="Événement" ${data.element.type === 'Événement' ? 'selected' : ''}>Événement</option>
                </select>
            </div>

            <div class="detail-section">
                <div class="detail-section-title">Description</div>
                <textarea class="form-input" rows="6" 
                          onchange="handleUpdateWorldField(${id}, 'description', this.value)">${data.element.description}</textarea>
            </div>

            <div class="detail-section">
                <div class="detail-section-title">Détails</div>
                <textarea class="form-input" rows="6" 
                          onchange="handleUpdateWorldField(${id}, 'details', this.value)">${data.element.details}</textarea>
            </div>

            <div class="detail-section">
                <div class="detail-section-title">Histoire</div>
                <textarea class="form-input" rows="6" 
                          onchange="handleUpdateWorldField(${id}, 'history', this.value)">${data.element.history}</textarea>
            </div>

            <div class="detail-section">
                <div class="detail-section-title">Notes</div>
                <textarea class="form-input" rows="4" 
                          onchange="handleUpdateWorldField(${id}, 'notes', this.value)">${data.element.notes}</textarea>
            </div>
        </div>
    `;

    if (typeof lucide !== 'undefined') lucide.createIcons();
}

/**
 * Renders the linked scenes section.
 */
function renderLinkedScenesFragment(linkedScenes) {
    if (!linkedScenes || linkedScenes.length === 0) return '';

    return `
        <div class="detail-section">
            <div class="detail-section-title"><i data-lucide="file-text" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Apparaît dans ${linkedScenes.length} scène(s)</div>
            <div class="quick-links">
                ${linkedScenes.map(scene => `
                    <span class="link-badge" onclick="openScene(${scene.actId}, ${scene.chapterId}, ${scene.sceneId})" title="${scene.actTitle} - ${scene.chapterTitle}">
                        ${scene.breadcrumb}
                    </span>
                `).join('')}
            </div>
        </div>
    `;
}

/**
 * Handles field updates from the UI.
 */
function handleUpdateWorldField(id, field, value) {
    const result = updateWorldFieldViewModel(id, field, value);
    if (result.success) {
        if (result.sideEffects.shouldSave && typeof saveProject === 'function') {
            saveProject();
        }
        if (result.sideEffects.shouldRefreshList) {
            renderWorldList();
        }
    }
}

// Map original function name to keep compatibility with other modules if needed
// or if the UI expects the old function name.
function addWorldElement() { handleAddWorldElement(); }
function updateWorldField(id, field, value) { handleUpdateWorldField(id, field, value); }
function deleteWorldElement(id) { handleDeleteWorldElement(id); }
// renderElementLinkedScenes is now internal to openWorldDetail via renderLinkedScenesFragment

// ========== js/18.timeline.js ==========

// Timeline Management
// [MVVM : View]
// Manipule directement le DOM pour afficher le modal d'ajout
function openAddTimelineModal() {
    document.getElementById('addTimelineModal').classList.add('active');
    setTimeout(() => document.getElementById('timelineTitleInput').focus(), 100);
}

// [MVVM : Other]
// Group: Use Case | Naming: AddTimelineEventUseCase
// Ajoute un événement à la chronologie (Mixte ViewModel)
function addTimelineEvent() {
    const title = document.getElementById('timelineTitleInput').value.trim();
    const date = document.getElementById('timelineDateInput').value.trim();
    const location = document.getElementById('timelineLocationInput').value.trim();
    const characters = document.getElementById('timelineCharactersInput').value.trim();
    const description = document.getElementById('timelineDescInput').value.trim();

    if (!title) return;

    const event = {
        id: Date.now(),
        title: title,
        date: date || '',
        location: location || '',
        characters: characters || '',
        description: description || '',
        order: project.timeline.length, // For manual reordering
        consequences: '',
        notes: ''
    };

    project.timeline.push(event);

    // Clear inputs
    document.getElementById('timelineTitleInput').value = '';
    document.getElementById('timelineDateInput').value = '';
    document.getElementById('timelineLocationInput').value = '';
    document.getElementById('timelineCharactersInput').value = '';
    document.getElementById('timelineDescInput').value = '';

    closeModal('addTimelineModal');
    saveProject();
    renderTimelineList();
}

// [MVVM : Other]
// Group: Use Case | Naming: DeleteTimelineEventUseCase
// Gère la suppression d'un événement (Mixte ViewModel)
function deleteTimelineEvent(id) {
    if (!confirm('Êtes-vous sûr de vouloir supprimer cet événement ?')) return;
    project.timeline = project.timeline.filter(e => e.id !== id);
    saveProject();
    renderTimelineList();
    showEmptyState();
}

// [MVVM : View]
// Rend la liste chronologique dans le DOM à partir du Model
function renderTimelineList() {
    const container = document.getElementById('timelineList');

    if (project.timeline.length === 0) {
        container.innerHTML = '<div style="padding: 2rem; text-align: center; color: var(--text-muted);">Aucun événement</div>';
        return;
    }

    // Sort by order field for manual ordering
    const sortedTimeline = [...project.timeline].sort((a, b) => a.order - b.order);

    container.innerHTML = `
                <div class="timeline-container">
                    <div class="timeline-line"></div>
                    ${sortedTimeline.map(event => `
                        <div class="timeline-event" onclick="openTimelineDetail(${event.id})">
                            <div style="display: flex; justify-content: space-between; align-items: start;">
                                <div style="flex: 1;">
                                    ${event.date ? `<div class="timeline-date">?? ${event.date}</div>` : ''}
                                    <div class="timeline-title">${event.title}</div>
                                    <div class="timeline-meta">
                                        ${event.location ? `<div class="timeline-meta-item">?? ${event.location}</div>` : ''}
                                        ${event.characters ? `<div class="timeline-meta-item"><i data-lucide="users" style="width:12px;height:12px;vertical-align:middle;margin-right:4px;"></i>${event.characters}</div>` : ''}
                                    </div>
                                    ${event.description ? `<div class="timeline-description">${event.description}</div>` : ''}
                                </div>
                                <button class="btn btn-icon btn-small" onclick="event.stopPropagation(); deleteTimelineEvent(${event.id})" title="Supprimer">×</button>
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
}

// [MVVM : View]
// Construit la vue détaillée d'un événement chronologique
function openTimelineDetail(id) {
    const event = project.timeline.find(e => e.id === id);
    if (!event) return;

    const editorView = document.getElementById('editorView');
    editorView.innerHTML = `
                <div class="detail-view">
                    <div class="detail-header">
                        <div class="detail-title">${event.title}</div>
                        <button class="btn" onclick="switchView('editor')">? Retour à l'éditeur</button>
                    </div>
                    
                    <div class="detail-section">
                        <div class="detail-section-title">Informations</div>
                        <div class="detail-field">
                            <div class="detail-label">Date / Moment</div>
                            <input type="text" class="form-input" value="${event.date}" 
                                   onchange="updateTimelineField(${id}, 'date', this.value)">
                        </div>
                        <div class="detail-field">
                            <div class="detail-label">Localisation</div>
                            <input type="text" class="form-input" value="${event.location}" 
                                   onchange="updateTimelineField(${id}, 'location', this.value)">
                        </div>
                        <div class="detail-field">
                            <div class="detail-label">Personnages impliqués</div>
                            <input type="text" class="form-input" value="${event.characters}" 
                                   onchange="updateTimelineField(${id}, 'characters', this.value)">
                        </div>
                    </div>

                    <div class="detail-section">
                        <div class="detail-section-title">Description</div>
                        <textarea class="form-input" rows="6" 
                                  onchange="updateTimelineField(${id}, 'description', this.value)">${event.description}</textarea>
                    </div>

                    <div class="detail-section">
                        <div class="detail-section-title">Conséquences</div>
                        <textarea class="form-input" rows="6" 
                                  onchange="updateTimelineField(${id}, 'consequences', this.value)">${event.consequences}</textarea>
                        <small style="color: var(--text-muted); font-style: italic;">Qu'est-ce que cet événement déclenche ou change dans l'histoire ?</small>
                    </div>

                    <div class="detail-section">
                        <div class="detail-section-title">Notes</div>
                        <textarea class="form-input" rows="4" 
                                  onchange="updateTimelineField(${id}, 'notes', this.value)">${event.notes}</textarea>
                    </div>
                </div>
            `;
}

// [MVVM : ViewModel]
// Met à jour un champ de l'événement et rafraîchit la View
function updateTimelineField(id, field, value) {
    const event = project.timeline.find(e => e.id === id);
    if (event) {
        event[field] = value;
        saveProject();
        renderTimelineList();
    }
}

// ========== js/19.notes.js ==========
// Notes Management

// [MVVM : View]
// Affiche la modal d'ajout ; interaction UI uniquement.
function openAddNoteModal() {
    document.getElementById('addNoteModal').classList.add('active');
    setTimeout(() => document.getElementById('noteTitleInput').focus(), 100);
}

// [MVVM : ViewModel]
// Crée un nouvel objet Model, met à jour project.notes, persiste et déclenche le rendu.
function addNote() {
    const title = document.getElementById('noteTitleInput').value.trim();
    const category = document.getElementById('noteCategoryInput').value;
    const tags = document.getElementById('noteTagsInput').value.trim();
    const content = document.getElementById('noteContentInput').value.trim();

    if (!title) return;

    const note = {
        id: Date.now(),
        title: title,
        category: category,
        tags: tags ? tags.split(',').map(t => t.trim()).filter(t => t) : [],
        content: content || '',
        medias: [], // Support pour les médias: {type: 'url'|'image'|'audio', url: '', title: ''}
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
    };

    project.notes.push(note);

    // Clear inputs
    document.getElementById('noteTitleInput').value = '';
    document.getElementById('noteTagsInput').value = '';
    document.getElementById('noteContentInput').value = '';

    closeModal('addNoteModal');
    saveProject();
    renderNotesList();
}

// [MVVM : ViewModel]
// Modifie le Model (suppression), persiste et met à jour la View.
function deleteNote(id) {
    if (!confirm('Êtes-vous sûr de vouloir supprimer cette note ?')) return;
    project.notes = project.notes.filter(n => n.id !== id);
    saveProject();
    renderNotesList();
    showEmptyState();
}

// [MVVM : ViewModel]
// État UI local (quelle catégorie est développée). Gère le comportement d'affichage.
let expandedNoteCategories = new Set(['Idée', 'Recherche', 'Référence', 'A faire', 'Question', 'Autre']);

// [MVVM : View]
// Rend la liste des notes dans le DOM ; lecture du Model mais responsabilité d'affichage.
function renderNotesList() {
    const container = document.getElementById('notesList');

    if (project.notes.length === 0) {
        container.innerHTML = '<div style="padding: 1rem; text-align: center; color: var(--text-muted); font-size: 0.85rem;">Aucune note</div>';
        return;
    }

    // Group notes by category
    const categories = {};
    // Icônes Lucide pour les catégories
    const categoryIcons = {
        'Idée': 'lightbulb',
        'Recherche': 'search',
        'Référence': 'bookmark',
        'A faire': 'check-circle',
        'Question': 'help-circle',
        'Autre': 'file-text'
    };

    project.notes.forEach(note => {
        const cat = note.category || 'Autre';
        if (!categories[cat]) categories[cat] = [];
        categories[cat].push(note);
    });

    // Sort notes within categories alphabetically by title
    Object.keys(categories).forEach(cat => {
        categories[cat].sort((a, b) => {
            return (a.title || '').toLowerCase().localeCompare((b.title || '').toLowerCase(), 'fr');
        });
    });

    let html = '';

    // Render each category as a collapsible group
    const categoryOrder = ['Idée', 'Recherche', 'Référence', 'A faire', 'Question', 'Autre'];
    categoryOrder.forEach(cat => {
        if (!categories[cat] || categories[cat].length === 0) return;

        const isExpanded = expandedNoteCategories.has(cat);
        const icon = categoryIcons[cat] || 'file-text';

        html += `
                    <div class="treeview-group" data-category="${cat}">
                        <div class="treeview-header" onclick="toggleNoteCategory('${cat}')">
                            <span class="treeview-icon ${isExpanded ? 'expanded' : ''}"><i data-lucide="${isExpanded ? 'chevron-down' : 'chevron-right'}" style="width:14px; height:14px;"></i></span>
                            <span class="treeview-category-icon"><i data-lucide="${icon}" style="width:16px; height:16px;"></i></span>
                            <span class="treeview-title">${cat}</span>
                            <span class="treeview-count">${categories[cat].length}</span>
                        </div>
                        <div class="treeview-children ${isExpanded ? '' : 'collapsed'}">
                            ${categories[cat].map(note => {
            const hasMedia = note.medias && note.medias.length > 0;
            // Remplacement du ?? par l'icône de trombone
            const mediaIcon = hasMedia ? 'paperclip' : '';
            return `
                                    <div class="treeview-item" onclick="openNoteDetail(${note.id})">
                                        <span class="treeview-item-title">${note.title}</span>
                                        ${mediaIcon ? `<span class="treeview-media-icon"><i data-lucide="${mediaIcon}" style="width:14px; height:14px;"></i></span>` : ''}
                                        <button class="btn btn-icon btn-small delete-btn" onclick="event.stopPropagation(); deleteNote(${note.id})" title="Supprimer">×</button>
                                    </div>
                                `;
        }).join('')}
                        </div>
                    </div>
                `;
    });

    container.innerHTML = html;
    if (typeof lucide !== 'undefined') lucide.createIcons();
}

// [MVVM : ViewModel]
// Mutations de l'état d'affichage (expand/collapse) et déclenche rendu.
function toggleNoteCategory(category) {
    if (expandedNoteCategories.has(category)) {
        expandedNoteCategories.delete(category);
    } else {
        expandedNoteCategories.add(category);
    }
    renderNotesList();
}

// [MVVM : ViewModel]
// Opération sur l'état UI et rafraîchissement de la View.
function expandAllNoteCategories() {
    expandedNoteCategories = new Set(['Idée', 'Recherche', 'Référence', 'A faire', 'Question', 'Autre']);
    renderNotesList();
}

// [MVVM : ViewModel]
// Opération sur l'état UI et rafraîchissement de la View.
function collapseAllNoteCategories() {
    expandedNoteCategories.clear();
    renderNotesList();
}

// [MVVM : Other]
// Rend la vue détail et gère la navigation (Mixte View/ViewModel).
function openNoteDetail(id) {
    const note = project.notes.find(n => n.id === id);
    if (!note) return;

    // Ensure medias array exists
    if (!note.medias) note.medias = [];

    // Handle split view mode
    if (splitViewActive) {
        const state = splitActivePanel === 'left' ? splitViewState.left : splitViewState.right;
        if (state.view === 'notes') {
            state.noteId = id;
            renderSplitPanelViewContent(splitActivePanel);
            saveSplitViewState();
            return;
        }
    }

    const editorView = document.getElementById('editorView');
    editorView.innerHTML = `
                <div class="detail-view">
                    <div class="detail-header">
                        <div style="display: flex; align-items: center; gap: 1rem; flex: 1;">
                            <input type="text" class="form-input" value="${note.title}" 
                                   style="font-size: 1.8rem; font-weight: 600; font-family: 'Noto Serif JP', serif; padding: 0.5rem;"
                                   onchange="updateNoteField(${id}, 'title', this.value)"
                                   placeholder="Titre de la note">
                            <span style="font-size: 0.8rem; padding: 0.4rem 0.8rem; background: var(--accent-gold); color: var(--bg-primary); border-radius: 2px;">${note.category}</span>
                        </div>
                        <button class="btn" onclick="switchView('editor')">? Retour à l'éditeur</button>
                    </div>
                    
                    <div class="detail-section">
                        <div class="detail-section-title">Catégorie</div>
                        <select class="form-input" onchange="updateNoteField(${id}, 'category', this.value)">
                            <option value="Recherche" ${note.category === 'Recherche' ? 'selected' : ''}>Recherche</option>
                            <option value="Idée" ${note.category === 'Idée' ? 'selected' : ''}>Idée</option>
                            <option value="Référence" ${note.category === 'Référence' ? 'selected' : ''}>Référence</option>
                            <option value="A faire" ${note.category === 'A faire' ? 'selected' : ''}>À faire</option>
                            <option value="Question" ${note.category === 'Question' ? 'selected' : ''}>Question</option>
                            <option value="Autre" ${note.category === 'Autre' ? 'selected' : ''}>Autre</option>
                        </select>
                    </div>

                    <div class="detail-section">
                        <div class="detail-section-title">Tags</div>
                        <input type="text" class="form-input" value="${note.tags.join(', ')}" 
                               onchange="updateNoteTags(${id}, this.value)">
                        <small style="color: var(--text-muted); font-style: italic;">Séparez les tags par des virgules</small>
                    </div>

                    <div class="detail-section">
                        <div class="detail-section-title">Contenu</div>
                        <textarea class="form-input" rows="12" 
                                  oninput="updateNoteField(${id}, 'content', this.value)">${note.content}</textarea>
                    </div>

                    <div class="detail-section">
                        <div class="detail-section-title">
                            Médias
                            <button class="btn btn-small" onclick="openAddMediaModal(${id})" style="margin-left: 1rem;">
                                <i data-lucide="plus" style="width:14px;height:14px;margin-right:0.3rem;"></i>Ajouter
                            </button>
                        </div>
                        <div class="note-medias-container" id="noteMedias-${id}">
                            ${renderNoteMedias(note)}
                        </div>
                    </div>

                    <div style="font-size: 0.8rem; color: var(--text-muted); margin-top: 2rem; font-family: 'Source Code Pro', monospace;">
                        Créée le ${new Date(note.createdAt).toLocaleDateString('fr-FR')} • 
                        Modifiée le ${new Date(note.updatedAt).toLocaleDateString('fr-FR')}
                    </div>
                </div>
            `;
    if (typeof lucide !== 'undefined') lucide.createIcons();
}

// [MVVM : View]
// Génère le markup HTML des médias pour une note.
function renderNoteMedias(note) {
    if (!note.medias || note.medias.length === 0) {
        return '<div style="color: var(--text-muted); font-style: italic; padding: 1rem; text-align: center; border: 1px dashed var(--border-color); border-radius: 8px;">Aucun média ajouté</div>';
    }

    return `<div class="note-medias-grid">${note.medias.map((media, index) => {
        if (media.type === 'image') {
            return `
                        <div class="note-media-item note-media-image">
                            <img src="${media.url}" alt="${media.title || 'Image'}" onclick="window.open('${media.url}', '_blank')">
                            <div class="note-media-overlay">
                                <span class="note-media-title">${media.title || 'Image'}</span>
                                <button class="note-media-delete" onclick="deleteNoteMedia(${note.id}, ${index})">×</button>
                            </div>
                        </div>
                    `;
        } else if (media.type === 'audio') {
            return `
                        <div class="note-media-item note-media-audio">
                            <div class="note-media-audio-icon"><i data-lucide="volume-2" style="width:24px; height:24px;"></i></div>
                            <div class="note-media-audio-info">
                                <span class="note-media-title">${media.title || 'Audio'}</span>
                                <audio controls src="${media.url}" style="width: 100%; margin-top: 0.5rem;"></audio>
                            </div>
                            <button class="note-media-delete" onclick="deleteNoteMedia(${note.id}, ${index})">×</button>
                        </div>
                    `;
        } else if (media.type === 'url') {
            const domain = extractDomain(media.url);
            return `
                        <div class="note-media-item note-media-url" onclick="window.open('${media.url}', '_blank')">
                            <div class="note-media-url-icon"><i data-lucide="link" style="width:24px; height:24px;"></i></div>
                            <div class="note-media-url-info">
                                <span class="note-media-title">${media.title || media.url}</span>
                                <span class="note-media-domain">${domain}</span>
                            </div>
                            <button class="note-media-delete" onclick="event.stopPropagation(); deleteNoteMedia(${note.id}, ${index})">×</button>
                        </div>
                    `;
        } else if (media.type === 'youtube') {
            const videoId = extractYoutubeId(media.url);
            return `
                        <div class="note-media-item note-media-youtube">
                            <div class="note-media-youtube-thumb" onclick="window.open('${media.url}', '_blank')">
                                <img src="https://img.youtube.com/vi/${videoId}/mqdefault.jpg" alt="YouTube">
                                <div class="note-media-youtube-play"><i data-lucide="play" style="width:32px; height:32px; fill: white; stroke: white;"></i></div>
                            </div>
                            <div class="note-media-overlay">
                                <span class="note-media-title">${media.title || 'Vidéo YouTube'}</span>
                                <button class="note-media-delete" onclick="deleteNoteMedia(${note.id}, ${index})">×</button>
                            </div>
                        </div>
                    `;
        }
        return '';
    }).join('')}</div>`;
}

// [MVVM : Other]
// Fonction utilitaire (extraction de domaine).
function extractDomain(url) {
    try {
        const urlObj = new URL(url);
        return urlObj.hostname.replace('www.', '');
    } catch {
        return url;
    }
}

// [MVVM : Other]
// Parse l'ID YouTube depuis une URL.
function extractYoutubeId(url) {
    const match = url.match(/(?:youtube\.com\/(?:watch\?v=|embed\/)|youtu\.be\/)([^&\s?]+)/);
    return match ? match[1] : '';
}

// [MVVM : View]
// Crée et affiche la modal d'ajout de média.
function openAddMediaModal(noteId) {
    // Create modal dynamically
    let modal = document.getElementById('addMediaModal');
    if (!modal) {
        modal = document.createElement('div');
        modal.id = 'addMediaModal';
        modal.className = 'modal';
        document.body.appendChild(modal);
    }

    modal.innerHTML = `
                <div class="modal-content" style="max-width: 500px;">
                    <div class="modal-header">
                        <h3>Ajouter un média</h3>
                        <button class="modal-close" onclick="closeModal('addMediaModal')">×</button>
                    </div>
                    <div class="modal-body">
                        <div class="form-group">
                            <label class="form-label">Type de média</label>
                            <select id="mediaTypeInput" class="form-input" onchange="updateMediaInputPlaceholder()">
                                <option value="url">Lien URL</option>
                                <option value="image">Image (URL)</option>
                                <option value="audio">Audio (URL)</option>
                                <option value="youtube">Vidéo YouTube</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label class="form-label">Titre (optionnel)</label>
                            <input type="text" id="mediaTitleInput" class="form-input" placeholder="Titre du média">
                        </div>
                        <div class="form-group">
                            <label class="form-label">URL</label>
                            <input type="text" id="mediaUrlInput" class="form-input" placeholder="https://...">
                        </div>
                        <div id="mediaPreview" style="margin-top: 1rem;"></div>
                    </div>
                    <div class="modal-footer">
                        <button class="btn" onclick="closeModal('addMediaModal')">Annuler</button>
                        <button class="btn btn-primary" onclick="addNoteMedia(${noteId})">Ajouter</button>
                    </div>
                </div>
            `;
    modal.classList.add('active');
}

// [MVVM : View]
// Aide l'UI en adaptant le placeholder selon le type.
function updateMediaInputPlaceholder() {
    const type = document.getElementById('mediaTypeInput').value;
    const urlInput = document.getElementById('mediaUrlInput');
    const placeholders = {
        'url': 'https://example.com/article',
        'image': 'https://example.com/image.jpg',
        'audio': 'https://example.com/music.mp3',
        'youtube': 'https://www.youtube.com/watch?v=...'
    };
    urlInput.placeholder = placeholders[type] || 'https://...';
}

// [MVVM : ViewModel]
// Ajoute un média au Model, met à jour les timestamps, persiste et rafraîchit la View.
function addNoteMedia(noteId) {
    const type = document.getElementById('mediaTypeInput').value;
    const title = document.getElementById('mediaTitleInput').value.trim();
    const url = document.getElementById('mediaUrlInput').value.trim();

    if (!url) {
        alert('Veuillez entrer une URL');
        return;
    }

    const note = project.notes.find(n => n.id === noteId);
    if (!note) return;

    if (!note.medias) note.medias = [];

    note.medias.push({
        type: type,
        title: title || '',
        url: url,
        addedAt: new Date().toISOString()
    });

    note.updatedAt = new Date().toISOString();
    saveProject();
    closeModal('addMediaModal');
    openNoteDetail(noteId);
    renderNotesList();
}

// [MVVM : ViewModel]
// Supprime un média du Model, persiste et met à jour la View.
function deleteNoteMedia(noteId, mediaIndex) {
    if (!confirm('Supprimer ce média ?')) return;

    const note = project.notes.find(n => n.id === noteId);
    if (!note || !note.medias) return;

    note.medias.splice(mediaIndex, 1);
    note.updatedAt = new Date().toISOString();
    saveProject();
    openNoteDetail(noteId);
    renderNotesList();
}

// [MVVM : ViewModel]
// Met à jour un champ du Model, persiste et rafraîchit la View.
function updateNoteField(id, field, value) {
    const note = project.notes.find(n => n.id === id);
    if (note) {
        note[field] = value;
        note.updatedAt = new Date().toISOString();
        saveProject();
        renderNotesList();
    }
}

// [MVVM : ViewModel]
// Transforme la saisie en tableau dans le Model, persiste et rafraîchit la View.
function updateNoteTags(id, tagsString) {
    const note = project.notes.find(n => n.id === id);
    if (note) {
        note.tags = tagsString.split(',').map(t => t.trim()).filter(t => t);
        note.updatedAt = new Date().toISOString();
        saveProject();
        renderNotesList();
    }
}
// ========== js/20.snapshots.js ==========

// Version Control Management

// [MVVM : ViewModel]
// Coordonne la création d'un snapshot du project, persiste et demande la mise à jour de la vue.
function createVersion() {
    const label = prompt('Nom de la version (ex: "Version 1.0", "Avant révision", etc.)');
    if (!label || !label.trim()) return;

    const totalWords = project.acts.reduce((sum, act) => {
        return sum + act.chapters.reduce((chSum, chapter) => {
            return chSum + chapter.scenes.reduce((sceneSum, scene) => {
                return sceneSum + getWordCount(scene.content);
            }, 0);
        }, 0);
    }, 0);

    const version = {
        id: Date.now(),
        label: label.trim(),
        timestamp: new Date().toISOString(),
        wordCount: totalWords,
        snapshot: JSON.parse(JSON.stringify({
            acts: project.acts,
            characters: project.characters,
            world: project.world,
            timeline: project.timeline,
            notes: project.notes,
            codex: project.codex
        }))
    };

    project.versions.push(version);
    saveProject();
    renderVersionsList();
    alert('Version créée avec succès !');
}

// [MVVM : ViewModel]
// Modifie le project (Model) en supprimant une version, persiste et notifie la vue.
function deleteVersion(id) {
    if (!confirm('Êtes-vous sûr de vouloir supprimer cette version ?')) return;
    project.versions = project.versions.filter(v => v.id !== id);
    saveProject();
    renderVersionsList();
}

// [MVVM : ViewModel]
// Restaure l'état du project (Model) depuis un snapshot.
function restoreVersion(id) {
    if (!confirm('?? ATTENTION: Restaurer cette version va remplacer votre travail actuel. Voulez-vous créer une sauvegarde avant de continuer ?')) {
        return;
    }

    // Create backup of current state
    createVersion();

    const version = project.versions.find(v => v.id === id);
    if (!version) return;

    // Restore snapshot
    project.acts = JSON.parse(JSON.stringify(version.snapshot.acts));
    project.characters = JSON.parse(JSON.stringify(version.snapshot.characters || []));
    project.world = JSON.parse(JSON.stringify(version.snapshot.world || []));
    project.timeline = JSON.parse(JSON.stringify(version.snapshot.timeline || []));
    project.notes = JSON.parse(JSON.stringify(version.snapshot.notes || []));
    project.codex = JSON.parse(JSON.stringify(version.snapshot.codex || []));

    saveProject();
    switchView('editor');
    renderActsList();
    alert('Version restaurée avec succès !');
}

// [MVVM : View]
// Génère directement du HTML et manipule le DOM (Vue).
function renderVersionsList() {
    const editorView = document.getElementById('editorView');
    if (!editorView) {
        console.error('editorView not found');
        return;
    }

    // Sort by most recent first
    const sortedVersions = [...project.versions].sort((a, b) =>
        new Date(b.timestamp) - new Date(a.timestamp)
    );

    editorView.innerHTML = `
                <div style="height: 100%; overflow-y: auto; padding: 2rem 3rem;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 2rem;">
                        <h2 style="color: var(--accent-gold);"><i data-lucide="history" style="width:24px;height:24px;vertical-align:middle;margin-right:8px;"></i>Gestion des Versions</h2>
                        <button class="btn btn-primary" onclick="createVersion()">
                            + Créer une version
                        </button>
                    </div>
                    
                    ${project.versions.length === 0 ? `
                        <div style="text-align: center; padding: 4rem 2rem; color: var(--text-muted);">
                            <div style="font-size: 3rem; margin-bottom: 1rem;">??</div>
                            <div style="font-size: 1.2rem; margin-bottom: 0.5rem;">Aucune version sauvegardée</div>
                            <div style="font-size: 0.9rem; margin-bottom: 2rem;">
                                Les versions vous permettent de créer des snapshots de votre projet<br>
                                pour revenir à un état antérieur si nécessaire.
                            </div>
                            <button class="btn btn-primary" onclick="createVersion()">
                                Créer votre première version
                            </button>
                        </div>
                    ` : `
                        <div style="display: grid; gap: 1rem;">
                            ${sortedVersions.map(version => `
                                <div style="background: var(--bg-secondary); padding: 1.5rem; border-radius: 8px; border-left: 4px solid var(--accent-gold);">
                                    <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 1rem;">
                                        <div>
                                            <div style="font-size: 1.1rem; font-weight: 600; color: var(--text-primary); margin-bottom: 0.25rem;">
                                                ${version.label}
                                            </div>
                                            <div style="font-size: 0.85rem; color: var(--text-muted);">
                                                ${new Date(version.timestamp).toLocaleString('fr-FR', {
        dateStyle: 'long',
        timeStyle: 'short'
    })}
                                            </div>
                                        </div>
                                        <div style="text-align: right;">
                                            <div style="font-size: 1.5rem; font-weight: 700; color: var(--accent-gold);">
                                                ${version.wordCount.toLocaleString('fr-FR')}
                                            </div>
                                            <div style="font-size: 0.75rem; color: var(--text-muted);">
                                                mots
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                                        <button class="btn btn-small" onclick="restoreVersion(${version.id})" 
                                                style="background: var(--accent-gold); color: white; border: none;">
                                            <i data-lucide="undo" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i> 
                                            Restaurer
                                        </button>
                                        <button class="btn btn-small" onclick="compareVersion(${version.id})">
                                            <i data-lucide="git-compare" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>
                                            Comparer
                                        </button>
                                        <button class="btn btn-small" onclick="deleteVersion(${version.id})" 
                                                style="background: var(--accent-red); color: white; border: none;">
                                            <i data-lucide="trash-2" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i> 
                                            Supprimer
                                        </button>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    `}
                </div>
            `;
}

// [MVVM : Other]
// Calcule une différence (ViewModel) et l'affiche via alert (View).
function compareVersion(id) {
    const version = project.versions.find(v => v.id === id);
    if (!version) return;

    const currentWords = project.acts.reduce((sum, act) => {
        return sum + act.chapters.reduce((chSum, chapter) => {
            return chSum + chapter.scenes.reduce((sceneSum, scene) => {
                return sceneSum + getWordCount(scene.content);
            }, 0);
        }, 0);
    }, 0);

    const diff = currentWords - version.wordCount;
    const diffText = diff > 0 ? `+${diff}` : diff;

    alert(`Comparaison avec "${version.label}":\n\nVersion sauvegardée: ${version.wordCount.toLocaleString('fr-FR')} mots\nVersion actuelle: ${currentWords.toLocaleString('fr-FR')} mots\nDifférence: ${diffText} mots`);
}
// ========== js-refactor/21.sceneVersions.refactor.js ==========
// ==========================================
// SCENE VERSION MANAGEMENT (Versions par scène)
// ==========================================

// [MVVM : ViewModel]
// État d'interface utilisé par la vue (visibilité du panneau)
let sceneVersionsSidebarVisible = false;

// [MVVM : Other]
// Met à jour l'état et manipule le DOM (Mixte ViewModel + View)
function toggleVersionsSidebar() {
    const sidebar = document.getElementById('sidebarVersions');
    const toggleBtn = document.getElementById('headerVersionsToggle');
    const toolBtn = document.getElementById('toolVersionsBtn');
    sceneVersionsSidebarVisible = !sceneVersionsSidebarVisible;

    if (sceneVersionsSidebarVisible) {
        sidebar.classList.remove('hidden');
        if (toggleBtn) {
            toggleBtn.classList.add('active');
            toggleBtn.title = 'Masquer les versions de scène';
        }
        if (toolBtn) {
            toolBtn.classList.add('active');
        }
    } else {
        sidebar.classList.add('hidden');
        if (toggleBtn) {
            toggleBtn.classList.remove('active');
            toggleBtn.title = 'Afficher les versions de scène';
        }
        if (toolBtn) {
            toolBtn.classList.remove('active');
        }
    }
}

// [MVVM : Other]
// Force l'état d'affichage et modifie directement la Vue (Mixte ViewModel + View)
function showVersionsSidebar() {
    const sidebar = document.getElementById('sidebarVersions');
    const toggleBtn = document.getElementById('headerVersionsToggle');
    const toolBtn = document.getElementById('toolVersionsBtn');
    sceneVersionsSidebarVisible = true;
    sidebar.classList.remove('hidden');
    if (toggleBtn) {
        toggleBtn.classList.add('active');
    }
    if (toolBtn) {
        toolBtn.classList.add('active');
    }
}

// [MVVM : Model]
// Accès et initialisation des données de modèle (versions d'une scène)
function getSceneVersions(actId, chapterId, sceneId) {
    const act = project.acts.find(a => a.id === actId);
    if (!act) return [];
    const chapter = act.chapters.find(c => c.id === chapterId);
    if (!chapter) return [];
    const scene = chapter.scenes.find(s => s.id === sceneId);
    if (!scene) return [];

    // Ensure versions array exists
    if (!scene.versions) {
        scene.versions = [];
    }
    return scene.versions;
}

// [MVVM : ViewModel]
// Localise et expose l'act/chapter/scene courant pour la Vue
function getCurrentSceneForVersions() {
    if (!currentActId || !currentChapterId || !currentSceneId) return null;

    const act = project.acts.find(a => a.id === currentActId);
    if (!act) return null;
    const chapter = act.chapters.find(c => c.id === currentChapterId);
    if (!chapter) return null;
    const scene = chapter.scenes.find(s => s.id === currentSceneId);

    return scene ? { act, chapter, scene } : null;
}

// [MVVM : Other]
// Orchestration : lit la Vue, met à jour le Modèle, et rafraîchit la Vue (Mixte)
function createSceneVersion() {
    const current = getCurrentSceneForVersions();
    if (!current) {
        alert('Veuillez d\'abord sélectionner une scène.');
        return;
    }

    const { scene } = current;

    // Ensure versions array exists
    if (!scene.versions) {
        scene.versions = [];
    }

    // Sauvegarder le contenu actuel de l'éditeur dans la version active
    const editor = document.getElementById('sceneEditor');
    const currentContent = editor ? editor.innerHTML : (scene.content || '');

    // Obtenir les annotations de la version active actuelle (pour les copier)
    const currentAnnotations = getVersionAnnotations(scene);

    // Sauvegarder le contenu de la version active actuelle
    const currentActiveVersion = scene.versions.find(v => v.isActive);
    if (currentActiveVersion) {
        currentActiveVersion.content = currentContent;
        currentActiveVersion.wordCount = getWordCount(currentContent);
    }

    // Create version - GARDER les mêmes IDs d'annotations car le HTML contient ces IDs
    const versionNumber = scene.versions.length + 1;
    const version = {
        id: Date.now(),
        number: versionNumber,
        label: '',
        content: currentContent,
        wordCount: getWordCount(currentContent),
        createdAt: new Date().toISOString(),
        isActive: false,
        // Copier les annotations avec les MÊMES IDs (deep copy sans changer les IDs)
        annotations: currentAnnotations.map(a => ({ ...a }))
    };

    // Mark all previous versions as inactive
    scene.versions.forEach(v => v.isActive = false);

    // Add new version as active
    version.isActive = true;
    scene.versions.push(version);

    // Update scene content reference to this version
    scene.activeVersionId = version.id;
    scene.content = currentContent;

    saveProject();
    renderSceneVersionsList();

    // Rafraîchir le panneau d'annotations
    const annotationsPanel = document.getElementById('annotationsPanel');
    if (annotationsPanel && !annotationsPanel.classList.contains('hidden')) {
        renderAnnotationsPanel();
    }
    updateAnnotationsButton(false);

    showNotification(`Version ${versionNumber} créée`);
}

// [MVVM : Other]
// Met à jour l'état du modèle et rafraîchit la Vue (Mixte)
function switchToSceneVersion(versionId) {
    const current = getCurrentSceneForVersions();
    if (!current) return;

    const { scene } = current;
    if (!scene.versions) return;

    const version = scene.versions.find(v => v.id === versionId);
    if (!version) return;

    // Save current editor content to current active version before switching
    const currentActiveVersion = scene.versions.find(v => v.isActive);
    if (currentActiveVersion) {
        const editor = document.getElementById('sceneEditor');
        const currentContent = editor ? editor.innerHTML : (scene.content || '');
        currentActiveVersion.content = currentContent;
        currentActiveVersion.wordCount = getWordCount(currentContent);
    }

    // Mark all versions as inactive
    scene.versions.forEach(v => v.isActive = false);

    // Activate the selected version
    version.isActive = true;
    scene.activeVersionId = version.id;

    // Load version content into scene
    scene.content = version.content;
    scene.wordCount = version.wordCount;

    saveProject();
    renderSceneVersionsList();

    // Refresh editor if this scene is currently open
    if (currentSceneId === scene.id) {
        const act = project.acts.find(a => a.id === currentActId);
        const chapter = act.chapters.find(c => c.id === currentChapterId);
        renderEditor(act, chapter, scene);

        // Réattacher les event listeners sur les marqueurs d'annotation
        setTimeout(() => {
            reattachAnnotationMarkerListeners();
        }, 50);

        // Rafraîchir le panneau d'annotations pour la nouvelle version
        const annotationsPanel = document.getElementById('annotationsPanel');
        if (annotationsPanel && !annotationsPanel.classList.contains('hidden')) {
            renderAnnotationsPanel();
        }
        updateAnnotationsButton(false);
    }
}

// Réattacher les event listeners sur les marqueurs d'annotation après changement de version
// [MVVM : View]
// Rattache des écouteurs DOM aux marqueurs d'annotation
function reattachAnnotationMarkerListeners() {
    const markers = document.querySelectorAll('[data-annotation-id]');
    markers.forEach(marker => {
        const annotationId = parseInt(marker.getAttribute('data-annotation-id'));
        marker.style.cursor = 'pointer';
        marker.onclick = function (e) {
            e.stopPropagation();
            highlightAnnotation(annotationId);
        };
    });
}

// [MVVM : Other]
// Supprime le modèle (versions) et rafraîchit la Vue (Mixte)
function deleteSceneVersion(versionId) {
    const current = getCurrentSceneForVersions();
    if (!current) return;

    const { scene } = current;
    if (!scene.versions || scene.versions.length <= 1) {
        alert('Impossible de supprimer la dernière version.');
        return;
    }

    const version = scene.versions.find(v => v.id === versionId);
    if (!version) return;

    if (!confirm(`Supprimer la version ${version.number} ?`)) return;

    const wasActive = version.isActive;
    scene.versions = scene.versions.filter(v => v.id !== versionId);

    // Renumber remaining versions
    scene.versions.forEach((v, index) => {
        v.number = index + 1;
    });

    // If deleted version was active, activate the last one
    if (wasActive && scene.versions.length > 0) {
        const lastVersion = scene.versions[scene.versions.length - 1];
        lastVersion.isActive = true;
        scene.activeVersionId = lastVersion.id;
        scene.content = lastVersion.content;
        scene.wordCount = lastVersion.wordCount;

        // Refresh editor
        if (currentSceneId === scene.id) {
            const act = project.acts.find(a => a.id === currentActId);
            const chapter = act.chapters.find(c => c.id === currentChapterId);
            renderEditor(act, chapter, scene);
        }
    }

    saveProject();
    renderSceneVersionsList();
}

// [MVVM : Other]
// Met à jour le modèle (label) et demande à la Vue de se rafraîchir (Mixte)
function renameSceneVersion(versionId) {
    const current = getCurrentSceneForVersions();
    if (!current) return;

    const { scene } = current;
    if (!scene.versions) return;

    const version = scene.versions.find(v => v.id === versionId);
    if (!version) return;

    const newLabel = prompt('Nom de la version (optionnel):', version.label || '');
    if (newLabel === null) return; // Cancelled

    version.label = newLabel.trim();
    saveProject();
    renderSceneVersionsList();
}

// [MVVM : View]
// Construit et injecte le HTML pour la liste des versions
function renderSceneVersionsList() {
    const listContainer = document.getElementById('sceneVersionsList');
    const sceneNameEl = document.getElementById('versionsSceneName');
    const btnNewVersion = document.getElementById('btnNewVersion');

    if (!listContainer) return;

    const current = getCurrentSceneForVersions();

    if (!current) {
        // No scene selected
        sceneNameEl.textContent = 'Aucune scène sélectionnée';
        btnNewVersion.disabled = true;
        listContainer.innerHTML = `
                    <div class="versions-no-scene">
                        <div class="versions-no-scene-icon"><i data-lucide="file-text" style="width:48px;height:48px;opacity:0.3;"></i></div>
                        <div class="versions-no-scene-text">
                            Sélectionnez une scène<br>dans la structure<br>pour voir ses versions
                        </div>
                    </div>
                `;
        return;
    }

    const { act, chapter, scene } = current;

    // Update scene name
    sceneNameEl.textContent = `${act.title} › ${chapter.title} › ${scene.title}`;
    btnNewVersion.disabled = false;

    // Ensure versions array exists
    if (!scene.versions) {
        scene.versions = [];
    }

    if (scene.versions.length === 0) {
        listContainer.innerHTML = `
                    <div class="versions-empty">
                        <div class="versions-empty-icon"><i data-lucide="git-branch" style="width:48px;height:48px;"></i></div>
                        <div class="versions-empty-text">
                            Aucune version<br>
                            Créez votre première version pour tester différentes idées
                        </div>
                    </div>
                `;
        return;
    }

    // Sort by most recent first
    const sortedVersions = [...scene.versions].sort((a, b) =>
        new Date(b.createdAt) - new Date(a.createdAt)
    );

    let html = '';
    sortedVersions.forEach(version => {
        const date = new Date(version.createdAt);
        const dateStr = date.toLocaleDateString('fr-FR');
        const timeStr = date.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' });
        const canCompare = scene.versions.length >= 2;
        const isFinal = version.isFinal === true;
        const finalClass = isFinal ? 'final' : '';
        const activeClass = version.isActive ? 'active' : '';

        html += `
                    <div class="version-card ${activeClass} ${finalClass}" 
                         onclick="switchToSceneVersion(${version.id})">
                        <div class="version-card-header">
                            <span class="version-card-number">
                                ${version.number}
                                ${isFinal ? '<span class="version-card-final-badge">Finale</span>' : ''}
                            </span>
                            <div class="version-card-actions">
                                <button class="version-card-btn final ${isFinal ? 'is-final' : ''}" onclick="event.stopPropagation(); toggleFinalVersion(${version.id})" title="${isFinal ? 'Retirer comme version finale' : 'Marquer comme version finale'}"><i data-lucide="star" style="width:14px;height:14px;"></i></button>
                                ${canCompare ? `<button class="version-card-btn compare" onclick="event.stopPropagation(); openDiffModal(${version.id})" title="Comparer"><i data-lucide="git-compare" style="width:14px;height:14px;"></i></button>` : ''}
                                <button class="version-card-btn" onclick="event.stopPropagation(); renameSceneVersion(${version.id})" title="Renommer"><i data-lucide="pencil" style="width:14px;height:14px;"></i></button>
                                <button class="version-card-btn delete" onclick="event.stopPropagation(); deleteSceneVersion(${version.id})" title="Supprimer"><i data-lucide="trash-2" style="width:14px;height:14px;"></i></button>
                            </div>
                        </div>
                        <div class="version-card-date">${dateStr} ${timeStr}</div>
                        <div class="version-card-stats">${version.wordCount.toLocaleString('fr-FR')} mots</div>
                        ${version.label ? `<div class="version-card-label">${version.label}</div>` : ''}
                    </div>
                `;
    });

    listContainer.innerHTML = html;
    if (typeof lucide !== 'undefined') lucide.createIcons();
}

// Marquer/démarquer une version comme finale
// [MVVM : Other]
// Met à jour le modèle (flag isFinal) puis rafraîchit la Vue (Mixte)
function toggleFinalVersion(versionId) {
    const current = getCurrentSceneForVersions();
    if (!current) return;

    const { scene } = current;
    if (!scene.versions) return;

    const version = scene.versions.find(v => v.id === versionId);
    if (!version) return;

    if (version.isFinal) {
        // Retirer le statut final
        version.isFinal = false;
        showNotification('Version retirée comme finale');
    } else {
        // Retirer le statut final des autres versions
        scene.versions.forEach(v => v.isFinal = false);
        // Marquer cette version comme finale
        version.isFinal = true;
        showNotification(`Version "${version.number}" marquée comme finale`);
    }

    saveProject();
    renderSceneVersionsList();
}

// Obtenir le contenu à exporter pour une scène (version finale si existe, sinon contenu actuel)
// [MVVM : Model]
// Logique d'accès pour l'export (choisit la version finale si présente)
function getSceneExportContent(scene) {
    if (scene.versions && scene.versions.length > 0) {
        const finalVersion = scene.versions.find(v => v.isFinal === true);
        if (finalVersion) {
            return finalVersion.content;
        }
    }
    return scene.content;
}

// Update scene content when editing (also updates active version)
// [MVVM : ViewModel]
// Synchronise le contenu édité (Vue) avec le Modèle et ses versions actives
function updateSceneContentWithVersion(content) {
    const current = getCurrentSceneForVersions();
    if (!current) return;

    const { scene } = current;
    scene.content = content;
    scene.wordCount = getWordCount(content);

    // Also update active version if exists
    if (scene.versions && scene.versions.length > 0) {
        const activeVersion = scene.versions.find(v => v.isActive);
        if (activeVersion) {
            activeVersion.content = content;
            activeVersion.wordCount = scene.wordCount;
        }
    }
}


// ========== js/22.diff.js ==========
// ==========================================
// DIFF VIEWER (Comparaison de versions)
// ==========================================

let currentDiffView = 'unified';
let diffVersions = { old: null, new: null };

// [MVVM : View]
// Manipule directement le DOM (sélecteurs, affichage du modal).
function openDiffModal(versionId) {
    const current = getCurrentSceneForVersions();
    if (!current || !current.scene.versions || current.scene.versions.length < 2) {
        alert('Il faut au moins 2 versions pour comparer.');
        return;
    }

    const versions = current.scene.versions;
    const selectOld = document.getElementById('diffVersionOld');
    const selectNew = document.getElementById('diffVersionNew');

    // Remplir les sélecteurs
    selectOld.innerHTML = '';
    selectNew.innerHTML = '';

    versions.forEach((v, index) => {
        const label = v.label || `Version ${v.number}`;
        const date = new Date(v.createdAt).toLocaleDateString('fr-FR');
        const optionText = `${label} (${date})`;

        selectOld.innerHTML += `<option value="${v.id}">${optionText}</option>`;
        selectNew.innerHTML += `<option value="${v.id}">${optionText}</option>`;
    });

    // Sélectionner par défaut : version cliquée vs version active (ou la plus récente)
    const clickedVersion = versions.find(v => v.id === versionId);
    const activeVersion = versions.find(v => v.isActive);

    if (clickedVersion && activeVersion && clickedVersion.id !== activeVersion.id) {
        // Comparer la version cliquée avec l'active
        if (clickedVersion.number < activeVersion.number) {
            selectOld.value = clickedVersion.id;
            selectNew.value = activeVersion.id;
        } else {
            selectOld.value = activeVersion.id;
            selectNew.value = clickedVersion.id;
        }
    } else {
        // Comparer les 2 dernières versions
        const sorted = [...versions].sort((a, b) => b.number - a.number);
        if (sorted.length >= 2) {
            selectOld.value = sorted[1].id;
            selectNew.value = sorted[0].id;
        }
    }

    document.getElementById('diffModal').style.display = 'flex';
    updateDiff();
}

// [MVVM : View]
// Simple action d'interface qui masque le modal.
function closeDiffModal() {
    document.getElementById('diffModal').style.display = 'none';
}

// [MVVM : Other]
// Group: Util / Helper | Naming: DiffUtils
// Met à jour l'état (ViewModel) et modifie des classes DOM (View) (Mixte).
function setDiffView(view) {
    currentDiffView = view;
    document.getElementById('btnDiffUnified').classList.toggle('active', view === 'unified');
    document.getElementById('btnDiffSide').classList.toggle('active', view === 'side');
    updateDiff();
}

// [MVVM : ViewModel]
// Orchestrateur — récupère les données, calcule le diff et appelle le rendu.
function updateDiff() {
    const current = getCurrentSceneForVersions();
    if (!current) return;

    const versions = current.scene.versions;
    const oldId = parseInt(document.getElementById('diffVersionOld').value);
    const newId = parseInt(document.getElementById('diffVersionNew').value);

    const oldVersion = versions.find(v => v.id === oldId);
    const newVersion = versions.find(v => v.id === newId);

    if (!oldVersion || !newVersion) return;

    // Extraire le texte brut du HTML
    const oldText = stripHtml(oldVersion.content || '');
    const newText = stripHtml(newVersion.content || '');

    // Calculer le diff
    const diff = computeDiff(oldText, newText);

    // Afficher les statistiques
    updateDiffStats(diff);

    // Afficher le diff selon le mode
    if (currentDiffView === 'unified') {
        renderUnifiedDiff(diff, oldVersion, newVersion);
    } else {
        renderSideBySideDiff(diff, oldVersion, newVersion);
    }
}

// [MVVM : Model]
// Transformation de données (HTML -> texte brut).
function stripHtml(html) {
    // Remplacer les balises de bloc par des sauts de ligne
    let text = html
        .replace(/<br\s*\/?>/gi, '\n')
        .replace(/<\/p>/gi, '\n\n')
        .replace(/<\/div>/gi, '\n')
        .replace(/<\/h[1-6]>/gi, '\n\n')
        .replace(/<\/li>/gi, '\n')
        .replace(/<\/tr>/gi, '\n');

    // Supprimer toutes les autres balises HTML
    const tmp = document.createElement('div');
    tmp.innerHTML = text;
    text = tmp.textContent || tmp.innerText || '';

    // Normaliser les sauts de ligne multiples
    text = text.replace(/\n{3,}/g, '\n\n');

    return text.trim();
}

// [MVVM : Model]
// Calcule la différence entre deux textes (logique métier).
function computeDiff(oldText, newText) {
    // Normaliser les textes - préserver les sauts de ligne comme marqueurs
    const oldWords = tokenizeText(oldText);
    const newWords = tokenizeText(newText);

    // Utiliser l'algorithme de Myers (comme git)
    const diff = myersDiff(oldWords, newWords);

    // Convertir en format paragraphe unique pour le rendu
    return [{ type: 'paragraph', items: diff }];
}

// [MVVM : Model]
// Prépare les données (tokenisation) pour l'algorithme de diff.
function tokenizeText(text) {
    // Diviser le texte en tokens (mots + marqueurs de saut de ligne)
    const tokens = [];
    const lines = text.split(/\n/);

    lines.forEach((line, lineIndex) => {
        const words = line.split(/\s+/).filter(w => w.length > 0);
        words.forEach(word => {
            tokens.push({ word: word, isBreak: false });
        });
        // Ajouter un marqueur de saut de ligne (sauf pour la dernière ligne)
        if (lineIndex < lines.length - 1) {
            tokens.push({ word: '\n', isBreak: true });
        }
    });

    return tokens;
}

// Algorithme de Myers - le même que git utilise
// [MVVM : Model]
// Implémentation de l'algorithme de diff (Myers).
function myersDiff(oldTokens, newTokens) {
    const N = oldTokens.length;
    const M = newTokens.length;
    const MAX = N + M;

    // Fonction pour comparer deux tokens
    const tokensEqual = (a, b) => {
        if (a.isBreak && b.isBreak) return true;
        if (a.isBreak || b.isBreak) return false;
        return a.word === b.word;
    };

    // Cas simples
    if (N === 0 && M === 0) return [];
    if (N === 0) return newTokens.map(t => ({ type: 'added', text: t.word, isBreak: t.isBreak }));
    if (M === 0) return oldTokens.map(t => ({ type: 'removed', text: t.word, isBreak: t.isBreak }));

    // V contient les endpoints les plus éloignés pour chaque diagonale
    const V = new Map();
    V.set(1, 0);

    // Trace garde l'historique pour reconstruire le chemin
    const trace = [];

    // Chercher le chemin le plus court
    let found = false;
    for (let D = 0; D <= MAX && !found; D++) {
        trace.push(new Map(V));

        for (let k = -D; k <= D; k += 2) {
            // Décider si on va vers le bas ou vers la droite
            let x;
            if (k === -D || (k !== D && (V.get(k - 1) || 0) < (V.get(k + 1) || 0))) {
                x = V.get(k + 1) || 0; // Aller vers le bas (insertion)
            } else {
                x = (V.get(k - 1) || 0) + 1; // Aller vers la droite (suppression)
            }

            let y = x - k;

            // Suivre la diagonale (éléments identiques)
            while (x < N && y < M && tokensEqual(oldTokens[x], newTokens[y])) {
                x++;
                y++;
            }

            V.set(k, x);

            // Vérifier si on a atteint la fin
            if (x >= N && y >= M) {
                found = true;
                break;
            }
        }
    }

    // Reconstruire le chemin (backtrack)
    const result = [];
    let x = N;
    let y = M;

    for (let d = trace.length - 1; d >= 0; d--) {
        const V = trace[d];
        const k = x - y;

        let prevK;
        if (k === -d || (k !== d && (V.get(k - 1) || 0) < (V.get(k + 1) || 0))) {
            prevK = k + 1;
        } else {
            prevK = k - 1;
        }

        const prevX = V.get(prevK) || 0;
        const prevY = prevX - prevK;

        // Ajouter les diagonales (éléments identiques)
        while (x > prevX && y > prevY) {
            x--;
            y--;
            result.unshift({ type: 'same', text: oldTokens[x].word, isBreak: oldTokens[x].isBreak });
        }

        // Ajouter l'insertion ou la suppression
        if (d > 0) {
            if (x === prevX) {
                // Insertion
                y--;
                result.unshift({ type: 'added', text: newTokens[y].word, isBreak: newTokens[y].isBreak });
            } else {
                // Suppression
                x--;
                result.unshift({ type: 'removed', text: oldTokens[x].word, isBreak: oldTokens[x].isBreak });
            }
        }
    }

    return result;
}

// [MVVM : Model]
// Aide à construire la structure de donnée de sortie (utilitaire).
function addParagraphToResult(result, text, type) {
    const words = text.split(/\s+/).filter(w => w.length > 0);
    const items = words.map(word => ({ type: type, text: word }));
    result.push({ type: 'paragraph', status: type, items: items });
}

// [MVVM : View]
// Met à jour le DOM pour afficher des statistiques.
function updateDiffStats(diff) {
    let added = 0;
    let removed = 0;

    diff.forEach(para => {
        if (para.items) {
            para.items.forEach(item => {
                if (item.isBreak) return; // Ignorer les sauts de ligne
                if (item.type === 'added' && item.text.trim()) added++;
                if (item.type === 'removed' && item.text.trim()) removed++;
            });
        }
    });

    document.getElementById('diffStats').innerHTML = `
                <span class="diff-stat added">+${added} mot${added > 1 ? 's' : ''} ajouté${added > 1 ? 's' : ''}</span>
                <span class="diff-stat removed">−${removed} mot${removed > 1 ? 's' : ''} supprimé${removed > 1 ? 's' : ''}</span>
            `;
}

// [MVVM : View]
// Génère et injecte du HTML pour la vue unifiée.
function renderUnifiedDiff(diff, oldVersion, newVersion) {
    const container = document.getElementById('diffContent');

    if (diff.length === 0) {
        container.innerHTML = `
                    <div class="diff-empty-state">
                        <div class="diff-empty-state-icon"><i data-lucide="check" style="width:48px;height:48px;"></i></div>
                        <div>Les deux versions sont identiques</div>
                    </div>
                `;
        return;
    }

    let html = '<div class="diff-unified">';

    diff.forEach((para, paraIndex) => {
        if (paraIndex > 0) html += '<br><br>';

        const paraClass = para.status === 'added' ? 'diff-paragraph added' :
            para.status === 'removed' ? 'diff-paragraph removed' :
                'diff-paragraph';

        html += `<div class="${paraClass}">`;

        if (para.items) {
            let needSpace = false;
            para.items.forEach((item) => {
                // Gérer les sauts de ligne
                if (item.isBreak) {
                    html += '<br>';
                    needSpace = false;
                    return;
                }

                const space = needSpace ? ' ' : '';

                if (item.type === 'same') {
                    html += space + escapeHtml(item.text);
                } else if (item.type === 'added') {
                    html += space + `<span class="diff-word added">${escapeHtml(item.text)}</span>`;
                } else if (item.type === 'removed') {
                    html += space + `<span class="diff-word removed">${escapeHtml(item.text)}</span>`;
                }
                needSpace = true;
            });
        }

        html += '</div>';
    });

    html += '</div>';
    container.innerHTML = html;
}

// [MVVM : View]
// Génère et injecte le HTML pour l'affichage côte-à-côte.
function renderSideBySideDiff(diff, oldVersion, newVersion) {
    const container = document.getElementById('diffContent');

    const oldLabel = oldVersion.label || `Version ${oldVersion.number}`;
    const newLabel = newVersion.label || `Version ${newVersion.number}`;
    const oldDate = new Date(oldVersion.createdAt).toLocaleDateString('fr-FR');
    const newDate = new Date(newVersion.createdAt).toLocaleDateString('fr-FR');

    let oldHtml = '';
    let newHtml = '';

    diff.forEach((para, paraIndex) => {
        if (paraIndex > 0) {
            oldHtml += '<br><br>';
            newHtml += '<br><br>';
        }

        if (para.status === 'removed') {
            // Paragraphe supprimé - seulement à gauche
            oldHtml += '<div class="diff-paragraph removed">';
            let needSpace = false;
            para.items.forEach((item) => {
                if (item.isBreak) {
                    oldHtml += '<br>';
                    needSpace = false;
                    return;
                }
                const space = needSpace ? ' ' : '';
                oldHtml += space + `<span class="diff-word removed">${escapeHtml(item.text)}</span>`;
                needSpace = true;
            });
            oldHtml += '</div>';
        } else if (para.status === 'added') {
            // Paragraphe ajouté - seulement à droite
            newHtml += '<div class="diff-paragraph added">';
            let needSpace = false;
            para.items.forEach((item) => {
                if (item.isBreak) {
                    newHtml += '<br>';
                    needSpace = false;
                    return;
                }
                const space = needSpace ? ' ' : '';
                newHtml += space + `<span class="diff-word added">${escapeHtml(item.text)}</span>`;
                needSpace = true;
            });
            newHtml += '</div>';
        } else if (para.status === 'same') {
            // Paragraphe identique
            const text = para.items.filter(item => !item.isBreak).map(item => item.text).join(' ');
            oldHtml += `<div class="diff-paragraph">${escapeHtml(text)}</div>`;
            newHtml += `<div class="diff-paragraph">${escapeHtml(text)}</div>`;
        } else {
            // Paragraphe modifié - afficher le diff mot par mot
            oldHtml += '<div class="diff-paragraph modified">';
            newHtml += '<div class="diff-paragraph modified">';

            let oldNeedSpace = false;
            let newNeedSpace = false;

            para.items.forEach(item => {
                if (item.isBreak) {
                    if (item.type === 'same' || item.type === 'removed') {
                        oldHtml += '<br>';
                        oldNeedSpace = false;
                    }
                    if (item.type === 'same' || item.type === 'added') {
                        newHtml += '<br>';
                        newNeedSpace = false;
                    }
                    return;
                }

                if (item.type === 'same') {
                    const oldSpace = oldNeedSpace ? ' ' : '';
                    const newSpace = newNeedSpace ? ' ' : '';
                    oldHtml += oldSpace + escapeHtml(item.text);
                    newHtml += newSpace + escapeHtml(item.text);
                    oldNeedSpace = true;
                    newNeedSpace = true;
                } else if (item.type === 'added') {
                    const space = newNeedSpace ? ' ' : '';
                    newHtml += space + `<span class="diff-word added">${escapeHtml(item.text)}</span>`;
                    newNeedSpace = true;
                } else if (item.type === 'removed') {
                    const space = oldNeedSpace ? ' ' : '';
                    oldHtml += space + `<span class="diff-word removed">${escapeHtml(item.text)}</span>`;
                    oldNeedSpace = true;
                }
            });

            oldHtml += '</div>';
            newHtml += '</div>';
        }
    });

    container.innerHTML = `
                <div class="diff-side-by-side">
                    <div class="diff-side">
                        <div class="diff-side-header old">
                            <span>${oldLabel}</span>
                            <span style="font-weight: normal; font-size: 0.75rem;">${oldDate} • ${oldVersion.wordCount} mots</span>
                        </div>
                        <div class="diff-side-content">${oldHtml}</div>
                    </div>
                    <div class="diff-side">
                        <div class="diff-side-header new">
                            <span>${newLabel}</span>
                            <span style="font-weight: normal; font-size: 0.75rem;">${newDate} • ${newVersion.wordCount} mots</span>
                        </div>
                        <div class="diff-side-content">${newHtml}</div>
                    </div>
                </div>
            `;
}

// [MVVM : View]
// Sécurise le texte inséré dans le DOM (utilitaire).
function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}


// ========== js/23.stats.js ==========

// Statistics Management
// [MVVM : Other]
// Calcule des métriques (ViewModel) et injecte du HTML (View).
function renderStats() {
    const editorView = document.getElementById('editorView');
    if (!editorView) {
        console.error('editorView not found');
        return;
    }

    // Calculate total words
    const totalWords = project.acts.reduce((sum, act) => {
        return sum + act.chapters.reduce((chSum, chapter) => {
            return chSum + chapter.scenes.reduce((sceneSum, scene) => {
                return sceneSum + getWordCount(scene.content);
            }, 0);
        }, 0);
    }, 0);

    // Calculate today's words
    const today = new Date().toDateString();
    const todaySession = project.stats.writingSessions.find(s => new Date(s.date).toDateString() === today);
    const todayWords = todaySession ? todaySession.words : 0;

    // Progress percentages
    const dailyProgress = Math.min((todayWords / project.stats.dailyGoal) * 100, 100);
    const totalProgress = Math.min((totalWords / project.stats.totalGoal) * 100, 100);

    editorView.innerHTML = `
                <div style="height: 100%; overflow-y: auto; padding: 2rem 3rem;">
                    <h2 style="margin-bottom: 2rem; color: var(--accent-gold);"><i data-lucide="bar-chart-3" style="width:24px;height:24px;vertical-align:middle;margin-right:8px;"></i>Statistiques</h2>
                    
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 2rem;">
                        <div class="stat-box" style="background: var(--bg-secondary); padding: 2rem; border-radius: 8px; border-left: 4px solid var(--accent-gold);">
                            <div style="font-size: 0.9rem; color: var(--text-muted); margin-bottom: 0.5rem;">Total de mots</div>
                            <div style="font-size: 2.5rem; font-weight: 700; color: var(--accent-gold); margin-bottom: 0.5rem;">${totalWords.toLocaleString('fr-FR')}</div>
                            <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 1rem;">sur ${project.stats.totalGoal.toLocaleString('fr-FR')} mots</div>
                            <div style="background: var(--bg-primary); height: 8px; border-radius: 4px; overflow: hidden;">
                                <div style="background: var(--accent-gold); height: 100%; width: ${totalProgress}%; transition: width 0.3s;"></div>
                            </div>
                            <div style="margin-top: 1rem; display: flex; gap: 0.5rem; align-items: center;">
                                <input type="number" class="form-input" value="${project.stats.totalGoal}" 
                                       id="totalGoalInput"
                                       style="flex: 1;" placeholder="Objectif total">
                                <button class="btn btn-small" onclick="updateGoal('totalGoal', document.getElementById('totalGoalInput').value)">Mettre à jour</button>
                            </div>
                        </div>

                        <div class="stat-box" style="background: var(--bg-secondary); padding: 2rem; border-radius: 8px; border-left: 4px solid var(--accent-red);">
                            <div style="font-size: 0.9rem; color: var(--text-muted); margin-bottom: 0.5rem;">Aujourd'hui</div>
                            <div style="font-size: 2.5rem; font-weight: 700; color: var(--accent-red); margin-bottom: 0.5rem;">${todayWords}</div>
                            <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 1rem;">sur ${project.stats.dailyGoal} mots</div>
                            <div style="background: var(--bg-primary); height: 8px; border-radius: 4px; overflow: hidden;">
                                <div style="background: var(--accent-red); height: 100%; width: ${dailyProgress}%; transition: width 0.3s;"></div>
                            </div>
                            <div style="margin-top: 1rem; display: flex; gap: 0.5rem; align-items: center;">
                                <input type="number" class="form-input" value="${project.stats.dailyGoal}" 
                                       id="dailyGoalInput"
                                       style="flex: 1;" placeholder="Objectif quotidien">
                                <button class="btn btn-small" onclick="updateGoal('dailyGoal', document.getElementById('dailyGoalInput').value)">Mettre à jour</button>
                            </div>
                        </div>
                    </div>
                    
                    <div style="margin-top: 2rem;">
                        <h3 style="margin-bottom: 1rem; color: var(--text-primary);">Par acte</h3>
                        <div style="background: var(--bg-secondary); padding: 1.5rem; border-radius: 8px;">
                            ${project.acts.map(act => {
        const actWords = act.chapters.reduce((sum, chapter) => {
            return sum + chapter.scenes.reduce((sceneSum, scene) => {
                return sceneSum + getWordCount(scene.content);
            }, 0);
        }, 0);
        return `
                                    <div style="display: flex; justify-content: space-between; padding: 0.75rem 0; border-bottom: 1px solid var(--border-color);">
                                        <span style="color: var(--text-primary);">${act.title}</span>
                                        <span style="font-weight: 600; color: var(--accent-gold);">${actWords.toLocaleString('fr-FR')} mots</span>
                                    </div>
                                `;
    }).join('')}
                        </div>
                    </div>

                    <div style="margin-top: 2rem;">
                        <h3 style="margin-bottom: 1rem; color: var(--text-primary);">Historique (7 derniers jours)</h3>
                        <div style="background: var(--bg-secondary); padding: 1.5rem; border-radius: 8px;">
                            ${renderWritingHistory()}
                        </div>
                    </div>
                </div>
            `;
}

// [MVVM : View]
// Transforme les données d'historique en fragments HTML.
function renderWritingHistory() {
    const last7Days = [];
    for (let i = 6; i >= 0; i--) {
        const date = new Date();
        date.setDate(date.getDate() - i);
        last7Days.push(date);
    }

    return last7Days.map(date => {
        const dateStr = date.toDateString();
        const session = project.stats.writingSessions.find(s => new Date(s.date).toDateString() === dateStr);
        const words = session ? session.words : 0;
        const dayName = date.toLocaleDateString('fr-FR', { weekday: 'short', day: 'numeric', month: 'short' });

        return `
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.5rem 0;">
                        <span style="font-size: 0.85rem;">${dayName}</span>
                        <div style="flex: 1; margin: 0 1rem;">
                            <div class="progress-bar" style="height: 4px;">
                                <div class="progress-fill" style="width: ${Math.min((words / project.stats.dailyGoal) * 100, 100)}%; background: ${words >= project.stats.dailyGoal ? 'var(--accent-gold)' : 'var(--text-muted)'}"></div>
                            </div>
                        </div>
                        <span style="font-size: 0.85rem; font-weight: 600; font-family: 'Source Code Pro', monospace;">${words}</span>
                    </div>
                `;
    }).join('');
}

// [MVVM : ViewModel]
// Met à jour le modèle (project.stats), persiste et déclenche un re-render.
function updateGoal(type, value) {
    const numValue = parseInt(value);
    if (numValue && numValue > 0) {
        project.stats[type] = numValue;
        saveProject();
        renderStats();
    }
}

// [MVVM : ViewModel]
// Suit et modifie l'état du modèle (writingSessions), calculs métier.
function trackWritingSession() {
    // Track writing session for stats
    const today = new Date().toDateString();
    const totalWords = project.acts.reduce((sum, act) => {
        return sum + act.chapters.reduce((chSum, chapter) => {
            return chSum + chapter.scenes.reduce((sceneSum, scene) => {
                return sceneSum + getWordCount(scene.content);
            }, 0);
        }, 0);
    }, 0);

    const sessionIndex = project.stats.writingSessions.findIndex(s => new Date(s.date).toDateString() === today);

    if (sessionIndex >= 0) {
        project.stats.writingSessions[sessionIndex].words = totalWords - (project.stats.writingSessions[sessionIndex].startWords || 0);
    } else {
        project.stats.writingSessions.push({
            date: new Date().toISOString(),
            words: 0,
            startWords: totalWords
        });
    }
}

// ========== js-refactor/codex/codex.model.js ==========
/**
 * [MVVM : Codex Model]
 * Définition de la structure de données et usines pour le codex.
 */

const CodexModel = {
    /**
     * Crée une nouvelle entrée de codex avec les valeurs par défaut.
     */
    create(data = {}) {
        const id = data.id || Date.now();
        
        return {
            id: id,
            title: data.title || '',
            category: data.category || 'Autre',
            summary: data.summary || '',
            content: data.content || '',
            relatedTo: data.relatedTo || [], // IDs of related characters, world elements, etc.
            createdAt: data.createdAt || id,
            updatedAt: data.updatedAt || Date.now()
        };
    },

    /**
     * Migre une ancienne entrée vers la nouvelle structure.
     */
    migrate(entry) {
        if (!entry) return null;
        
        // Si déjà migré, on vérifie juste les champs manquants
        const migrated = this.create(entry);
        
        return migrated;
    },

    /**
     * Valide une entrée de codex.
     */
    validate(entry) {
        if (!entry) return false;
        if (!entry.title || entry.title.trim() === '') return false;
        return true;
    }
};

/**
 * Configuration des catégories de codex avec leurs icônes Lucide.
 */
const CODEX_CATEGORIES = {
    'Culture': {
        icon: 'palette',
        label: 'Culture',
        description: 'Art, traditions, coutumes'
    },
    'Histoire': {
        icon: 'scroll',
        label: 'Histoire',
        description: 'Événements historiques, chronologie'
    },
    'Technologie': {
        icon: 'cpu',
        label: 'Technologie',
        description: 'Inventions, sciences, technologies'
    },
    'Géographie': {
        icon: 'globe',
        label: 'Géographie',
        description: 'Lieux, territoires, cartes'
    },
    'Politique': {
        icon: 'scale',
        label: 'Politique',
        description: 'Systèmes politiques, gouvernements'
    },
    'Magie/Pouvoir': {
        icon: 'sparkles',
        label: 'Magie/Pouvoir',
        description: 'Systèmes magiques, pouvoirs surnaturels'
    },
    'Religion': {
        icon: 'book-open',
        label: 'Religion',
        description: 'Croyances, cultes, spiritualité'
    },
    'Société': {
        icon: 'users',
        label: 'Société',
        description: 'Organisation sociale, classes, groupes'
    },
    'Autre': {
        icon: 'file-text',
        label: 'Autre',
        description: 'Autres informations'
    }
};

/**
 * Obtient l'icône pour une catégorie donnée.
 */
function getCodexCategoryIcon(category) {
    return CODEX_CATEGORIES[category]?.icon || 'file-text';
}

/**
 * Obtient toutes les catégories disponibles.
 */
function getCodexCategories() {
    return Object.keys(CODEX_CATEGORIES);
}

// ========== js-refactor/codex/codex.repository.js ==========
/**
 * [MVVM : Codex Repository]
 * Gestion de l'accès aux données du codex dans le projet.
 */

const CodexRepository = {
    /**
     * Récupère toutes les entrées du codex.
     */
    getAll() {
        if (!project.codex) {
            project.codex = [];
        }
        return project.codex;
    },

    /**
     * Récupère une entrée par son ID.
     */
    getById(id) {
        return this.getAll().find(entry => entry.id === id);
    },

    /**
     * Récupère les entrées par catégorie.
     */
    getByCategory(category) {
        return this.getAll().filter(entry => entry.category === category);
    },

    /**
     * Ajoute une nouvelle entrée.
     */
    add(entry) {
        if (!project.codex) {
            project.codex = [];
        }
        project.codex.push(entry);
        return entry;
    },

    /**
     * Met à jour une entrée existante.
     */
    update(id, updates) {
        const entry = this.getById(id);
        if (entry) {
            Object.assign(entry, updates);
            entry.updatedAt = Date.now();
            return entry;
        }
        return null;
    },

    /**
     * Supprime une entrée.
     */
    delete(id) {
        if (!project.codex) return false;
        const index = project.codex.findIndex(entry => entry.id === id);
        if (index > -1) {
            project.codex.splice(index, 1);
            return true;
        }
        return false;
    },

    /**
     * Compte le nombre d'entrées.
     */
    count() {
        return this.getAll().length;
    },

    /**
     * Compte le nombre d'entrées par catégorie.
     */
    countByCategory(category) {
        return this.getByCategory(category).length;
    },

    /**
     * Recherche dans les entrées.
     */
    search(query) {
        const lowerQuery = query.toLowerCase();
        return this.getAll().filter(entry =>
            entry.title.toLowerCase().includes(lowerQuery) ||
            entry.summary.toLowerCase().includes(lowerQuery) ||
            entry.content.toLowerCase().includes(lowerQuery)
        );
    },

    /**
     * Groupe les entrées par catégorie.
     */
    groupByCategory() {
        const groups = {};
        this.getAll().forEach(entry => {
            const cat = entry.category || 'Autre';
            if (!groups[cat]) {
                groups[cat] = [];
            }
            groups[cat].push(entry);
        });
        return groups;
    }
};

// ========== js-refactor/codex/codex.viewmodel.js ==========
/**
 * [MVVM : Codex ViewModel]
 * Logique métier et médiation entre le Model (Repository) et la View.
 */

const CodexViewModel = {
    /**
     * Initialise le module (listeners, etc.)
     */
    init() {
        // Peut-être s'abonner à des événements globaux ici si nécessaire
    },

    /**
     * Ajoute une nouvelle entrée au codex à partir des données du formulaire.
     * @param {string} title - Titre de l'entrée
     * @param {string} category - Catégorie de l'entrée
     * @param {string} summary - Résumé de l'entrée
     */
    addEntry(title, category, summary) {
        if (!title || !title.trim()) {
            return { success: false, error: "Le titre est obligatoire." };
        }

        const entryData = {
            title: title.trim(),
            category: category,
            summary: summary ? summary.trim() : ''
        };

        const newEntry = CodexModel.create(entryData);
        CodexRepository.add(newEntry);

        saveProject(); // Global save

        // Rafraîchir la vue principale si elle est active
        CodexView.renderList();

        return { success: true, entry: newEntry };
    },

    /**
     * Supprime une entrée du codex.
     * @param {number} id - ID de l'entrée à supprimer
     */
    deleteEntry(id) {
        // Confirmation gérée par la View avant d'appeler ceci, ou ici ?
        // Dans MVVM pur, ViewModel exécute l'action. La confirmation UI est View.

        const success = CodexRepository.delete(id);
        if (success) {
            saveProject();
            CodexView.renderList();

            // Si c'était la dernière entrée, la vue gérera l'affichage vide
            if (CodexRepository.count() === 0) {
                // Peut-être déclencher un état vide spécifique si nécessaire
            }
        }
        return success;
    },

    /**
     * Met à jour un champ d'une entrée.
     * @param {number} id - ID de l'entrée
     * @param {string} field - Nom du champ ('title', 'category', 'summary', 'content')
     * @param {*} value - Nouvelle valeur
     */
    updateField(id, field, value) {
        const updates = {};
        updates[field] = value;

        const updatedEntry = CodexRepository.update(id, updates);

        if (updatedEntry) {
            saveProject();

            // Si le titre ou la catégorie change, la liste doit être rafraîchie
            if (field === 'title' || field === 'category') {
                CodexView.renderList();
            }
        }
    },

    /**
     * Récupère les données pour afficher le détail d'une entrée.
     * @param {number} id - ID de l'entrée
     */
    getDetail(id) {
        return CodexRepository.getById(id);
    },

    /**
     * Trouve les scènes où un personnage apparaît.
     * @param {number} characterId 
     */
    findScenesWithCharacter(characterId) {
        const scenes = [];
        if (!project.acts) return scenes;

        project.acts.forEach(act => {
            act.chapters.forEach(chapter => {
                chapter.scenes.forEach(scene => {
                    if (scene.linkedCharacters && scene.linkedCharacters.includes(characterId)) {
                        scenes.push({
                            actId: act.id,
                            actTitle: act.title,
                            chapterId: chapter.id,
                            chapterTitle: chapter.title,
                            sceneId: scene.id,
                            sceneTitle: scene.title
                        });
                    }
                });
            });
        });
        return scenes;
    },

    /**
     * Trouve les scènes où un élément du monde apparaît.
     * @param {number} elementId 
     */
    findScenesWithElement(elementId) {
        const scenes = [];
        if (!project.acts) return scenes;

        project.acts.forEach(act => {
            act.chapters.forEach(chapter => {
                chapter.scenes.forEach(scene => {
                    if (scene.linkedElements && scene.linkedElements.includes(elementId)) {
                        scenes.push({
                            actId: act.id,
                            actTitle: act.title,
                            chapterId: chapter.id,
                            chapterTitle: chapter.title,
                            sceneId: scene.id,
                            sceneTitle: scene.title
                        });
                    }
                });
            });
        });
        return scenes;
    },

    /**
     * Bascule la présence d'un personnage dans une scène.
     * @param {number} sceneActId 
     * @param {number} sceneChapterId 
     * @param {number} sceneId 
     * @param {number} characterId 
     */
    toggleCharacterInScene(sceneActId, sceneChapterId, sceneId, characterId) {
        const act = project.acts.find(a => a.id === sceneActId);
        if (!act) return;
        const chapter = act.chapters.find(c => c.id === sceneChapterId);
        if (!chapter) return;
        const scene = chapter.scenes.find(s => s.id === sceneId);
        if (!scene) return;

        if (!scene.linkedCharacters) scene.linkedCharacters = [];

        const index = scene.linkedCharacters.indexOf(characterId);
        if (index > -1) {
            scene.linkedCharacters.splice(index, 1);
        } else {
            scene.linkedCharacters.push(characterId);
        }

        saveProject();

        // Rafraîchissement spécifique de la vue si nécessaire
        // Note: C'est une dépendance croisée avec l'éditeur principal.
        // Idéalement, on utiliserait un système d'événements : EventBus.emit('scene-updated', sceneId);
        // Pour l'instant, on garde la logique de rafraîchissement DOM direct si on est dans la vue active,
        // mais cela devrait être délégué à la View ou via un callback.

        return {
            currentSceneId: currentSceneId,
            sceneActId,
            sceneChapterId,
            sceneId,
            scene
        };
    },

    /**
     * Bascule la présence d'un élément dans une scène.
     */
    toggleElementInScene(sceneActId, sceneChapterId, sceneId, elementId) {
        const act = project.acts.find(a => a.id === sceneActId);
        if (!act) return;
        const chapter = act.chapters.find(c => c.id === sceneChapterId);
        if (!chapter) return;
        const scene = chapter.scenes.find(s => s.id === sceneId);
        if (!scene) return;

        if (!scene.linkedElements) scene.linkedElements = [];

        const index = scene.linkedElements.indexOf(elementId);
        let hasChanged = false;

        if (index > -1) {
            scene.linkedElements.splice(index, 1);
            hasChanged = true;
        } else {
            scene.linkedElements.push(elementId);
            hasChanged = true;
        }

        if (hasChanged) {
            saveProject();
        }

        return {
            hasChanged,
            currentSceneId: currentSceneId,
            sceneActId,
            sceneChapterId,
            sceneId
        };
    }
};

// ========== js-refactor/codex/codex.view.js ==========
/**
 * [MVVM : Codex View]
 * Gestion de l'affichage et des interactions DOM pour le Codex.
 */

const CodexView = {
    /**
     * Affiche la liste des entrées du codex dans la barre latérale.
     */
    renderList() {
        const container = document.getElementById('codexList');
        if (!container) return;

        // Récupérer les données via le ViewModel ou Repository
        // Ici on utilise le Repository car c'est de la lecture pure pour affichage
        if (CodexRepository.count() === 0) {
            container.innerHTML = '<div style="padding: 1rem; text-align: center; color: var(--text-muted); font-size: 0.85rem;">Aucune entrée</div>';
            return;
        }

        const groups = CodexRepository.groupByCategory();
        const collapsedState = JSON.parse(localStorage.getItem('plume_treeview_collapsed') || '{}');

        let html = '';
        Object.keys(groups).sort().forEach(category => {
            const groupKey = 'codex_' + category;
            const isCollapsed = collapsedState[groupKey] === true;

            // Sort entries alphabetically within each group
            const sortedEntries = [...groups[category]].sort((a, b) => {
                return (a.title || '').toLowerCase().localeCompare((b.title || '').toLowerCase(), 'fr');
            });

            html += `
                <div class="treeview-group">
                    <div class="treeview-header" onclick="toggleCodexGroup('${groupKey}')">
                        <i data-lucide="${isCollapsed ? 'chevron-right' : 'chevron-down'}" class="treeview-chevron"></i>
                        <span class="treeview-label">${category}</span>
                        <span class="treeview-count">${groups[category].length}</span>
                    </div>
                    <div class="treeview-children ${isCollapsed ? 'collapsed' : ''}">
                        ${sortedEntries.map(entry => {
                const iconName = getCodexCategoryIcon(category);
                return `
                                <div class="treeview-item" onclick="openCodexDetail(${entry.id})">
                                    <span class="treeview-item-icon"><i data-lucide="${iconName}" style="width:14px;height:14px;vertical-align:middle;"></i></span>
                                    <span class="treeview-item-label">${entry.title}</span>
                                    <button class="treeview-item-delete" onclick="event.stopPropagation(); deleteCodexEntry(${entry.id})" title="Supprimer">×</button>
                                </div>
                            `;
            }).join('')}
                    </div>
                </div>
            `;
        });

        container.innerHTML = html;
        if (typeof lucide !== 'undefined') lucide.createIcons();
    },

    /**
     * Ouvre la modale d'ajout d'entrée.
     */
    openAddModal() {
        const modal = document.getElementById('addCodexModal');
        if (modal) {
            modal.classList.add('active');
            setTimeout(() => {
                const input = document.getElementById('codexTitleInput');
                if (input) input.focus();
            }, 100);
        }
    },

    /**
     * Affiche le détail d'une entrée dans l'éditeur.
     */
    openDetail(id) {
        const entry = CodexViewModel.getDetail(id);
        if (!entry) return;

        // Handle split view mode
        if (typeof splitViewActive !== 'undefined' && splitViewActive) {
            const state = splitActivePanel === 'left' ? splitViewState.left : splitViewState.right;
            if (state.view === 'codex') {
                state.codexId = id;
                if (typeof renderSplitPanelViewContent === 'function') renderSplitPanelViewContent(splitActivePanel);
                if (typeof saveSplitViewState === 'function') saveSplitViewState();
                return;
            }
        }

        const editorView = document.getElementById('editorView');
        if (!editorView) return;

        // Générer les options de catégorie
        const categories = getCodexCategories();
        const categoryOptions = categories.map(cat =>
            `<option value="${cat}" ${entry.category === cat ? 'selected' : ''}>${cat}</option>`
        ).join('');

        editorView.innerHTML = `
            <div class="detail-view">
                <div class="detail-header">
                    <div style="display: flex; align-items: center; gap: 1rem; flex: 1;">
                        <input type="text" class="form-input" value="${entry.title}" 
                               style="font-size: 1.8rem; font-weight: 600; font-family: 'Noto Serif JP', serif; padding: 0.5rem;"
                               onchange="updateCodexField(${id}, 'title', this.value)"
                               placeholder="Titre de l'entrée">
                        <span style="font-size: 0.8rem; padding: 0.4rem 0.8rem; background: var(--accent-gold); color: var(--bg-primary); border-radius: 2px;">${entry.category}</span>
                    </div>
                    <button class="btn" onclick="switchView('editor')">← Retour à l'éditeur</button>
                </div>
                
                <div class="detail-section">
                    <div class="detail-section-title">Catégorie</div>
                    <select class="form-input" onchange="updateCodexField(${id}, 'category', this.value)">
                        ${categoryOptions}
                    </select>
                </div>

                <div class="detail-section">
                    <div class="detail-section-title">Résumé</div>
                    <textarea class="form-input" rows="3" 
                              onchange="updateCodexField(${id}, 'summary', this.value)">${entry.summary}</textarea>
                </div>

                <div class="detail-section">
                    <div class="detail-section-title">Contenu détaillé</div>
                    <textarea class="form-input" rows="20" 
                              onchange="updateCodexField(${id}, 'content', this.value)">${entry.content}</textarea>
                </div>
            </div>
        `;
    },

    /**
     * Affiche la modale des références pour un personnage.
     */
    showReferencesForCharacter(characterId) {
        // Obtenir le personnage (direct du Model global ou repository Characters si dispo)
        const character = project.characters ? project.characters.find(c => c.id === characterId) : null;
        if (!character) return;

        const scenes = CodexViewModel.findScenesWithCharacter(characterId);

        const modalTitle = document.getElementById('referencesModalTitle');
        const modalContent = document.getElementById('referencesModalContent');
        const modal = document.getElementById('referencesModal');

        if (modalTitle) modalTitle.textContent = `Références : ${character.name}`;
        if (modalContent) {
            modalContent.innerHTML = `
                <div class="references-section">
                    <div class="references-title"><i data-lucide="file-text" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Scènes où ${character.name} apparaît (${scenes.length})</div>
                    ${scenes.length > 0 ? scenes.map(scene => `
                        <div class="reference-item" onclick="openScene(${scene.actId}, ${scene.chapterId}, ${scene.sceneId}); closeModal('referencesModal');">
                            <div>
                                <div style="font-weight: 600;">${scene.sceneTitle}</div>
                                <div style="font-size: 0.8rem; color: var(--text-muted);">${scene.actTitle} > ${scene.chapterTitle}</div>
                            </div>
                            <span>→</span>
                        </div>
                    `).join('') : '<div style="padding: 1rem; color: var(--text-muted);">Aucune scène liée</div>'}
                </div>

                <div class="references-section">
                    <div class="references-title"><i data-lucide="link" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Gérer les liens</div>
                    <button class="btn btn-small" onclick="openLinkManagerForCharacter(${characterId})">+ Lier à des scènes</button>
                </div>
            `;
        }

        if (modal) {
            modal.classList.add('active');
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }
    },

    /**
     * Affiche la modale des références pour un élément.
     */
    showReferencesForElement(elementId) {
        const element = project.world ? project.world.find(e => e.id === elementId) : null;
        if (!element) return;

        const scenes = CodexViewModel.findScenesWithElement(elementId);

        const modalTitle = document.getElementById('referencesModalTitle');
        const modalContent = document.getElementById('referencesModalContent');
        const modal = document.getElementById('referencesModal');

        if (modalTitle) modalTitle.textContent = `Références : ${element.name}`;
        if (modalContent) {
            modalContent.innerHTML = `
                <div class="references-section">
                    <div class="references-title"><i data-lucide="file-text" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Scènes où ${element.name} apparaît (${scenes.length})</div>
                    ${scenes.length > 0 ? scenes.map(scene => `
                        <div class="reference-item" onclick="openScene(${scene.actId}, ${scene.chapterId}, ${scene.sceneId}); closeModal('referencesModal');">
                            <div>
                                <div style="font-weight: 600;">${scene.sceneTitle}</div>
                                <div style="font-size: 0.8rem; color: var(--text-muted);">${scene.actTitle} > ${scene.chapterTitle}</div>
                            </div>
                            <span>→</span>
                        </div>
                    `).join('') : '<div style="padding: 1rem; color: var(--text-muted);">Aucune scène liée</div>'}
                </div>

                <div class="references-section">
                    <div class="references-title"><i data-lucide="link" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Gérer les liens</div>
                    <button class="btn btn-small" onclick="openLinkManagerForElement(${elementId})">+ Lier à des scènes</button>
                </div>
            `;
        }

        if (modal) {
            modal.classList.add('active');
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }
    },

    /**
     * Rafraîchit spécifiquement le panneau des liens (utilisé après linkage).
     */
    refreshLinksPanel() {
        if (typeof window.refreshLinksPanel === 'function') {
            window.refreshLinksPanel();
        }
    }
};

// ============================================
// Global Controllers / Event Handlers
// ============================================

function openAddCodexModal() {
    CodexView.openAddModal();
}

function addCodexEntry() {
    const title = document.getElementById('codexTitleInput')?.value;
    const category = document.getElementById('codexCategoryInput')?.value;
    const summary = document.getElementById('codexSummaryInput')?.value;

    const result = CodexViewModel.addEntry(title, category, summary);

    if (result.success) {
        // Clear inputs
        if (document.getElementById('codexTitleInput')) document.getElementById('codexTitleInput').value = '';
        if (document.getElementById('codexSummaryInput')) document.getElementById('codexSummaryInput').value = '';

        closeModal('addCodexModal');
    } else {
        alert(result.error || "Erreur lors de l'ajout");
    }
}

function deleteCodexEntry(id) {
    if (!confirm('Êtes-vous sûr de vouloir supprimer cette entrée ?')) return;
    CodexViewModel.deleteEntry(id);
}

function renderCodexList() {
    CodexView.renderList();
}

function openCodexDetail(id) {
    CodexView.openDetail(id);
}

function updateCodexField(id, field, value) {
    CodexViewModel.updateField(id, field, value);
}

function showReferencesForCharacter(characterId) {
    CodexView.showReferencesForCharacter(characterId);
}

function showReferencesForElement(elementId) {
    CodexView.showReferencesForElement(elementId);
}

function toggleCodexGroup(groupKey) {
    const collapsedState = JSON.parse(localStorage.getItem('plume_treeview_collapsed') || '{}');
    collapsedState[groupKey] = !collapsedState[groupKey];
    localStorage.setItem('plume_treeview_collapsed', JSON.stringify(collapsedState));
    CodexView.renderList();
}

function toggleCharacterInScene(sceneActId, sceneChapterId, sceneId, characterId) {
    const result = CodexViewModel.toggleCharacterInScene(sceneActId, sceneChapterId, sceneId, characterId);
    if (result) {
        CodexView.refreshLinksPanel();
    }
}

function toggleElementInScene(sceneActId, sceneChapterId, sceneId, elementId) {
    const result = CodexViewModel.toggleElementInScene(sceneActId, sceneChapterId, sceneId, elementId);
    if (result && result.hasChanged) {
        CodexView.refreshLinksPanel();
    }
}

// Stubs for missing link managers if they don't exist
if (typeof openLinkManagerForCharacter === 'undefined') {
    window.openLinkManagerForCharacter = function (id) {
        console.warn("openLinkManagerForCharacter non implémenté. Utilisez le lien depuis la scène.");
        alert("Cette fonctionnalité n'est pas encore disponible. Veuillez utiliser le panneau 'Liens' depuis une scène.");
    };
}

if (typeof openLinkManagerForElement === 'undefined') {
    window.openLinkManagerForElement = function (id) {
        console.warn("openLinkManagerForElement non implémenté.");
        alert("Cette fonctionnalité n'est pas encore disponible. Veuillez utiliser le panneau 'Liens' depuis une scène.");
    };
}

// Global helpers for inter-module compatibility
window.findScenesWithCharacter = function (characterId) {
    return CodexViewModel.findScenesWithCharacter(characterId);
};

window.findScenesWithElement = function (elementId) {
    return CodexViewModel.findScenesWithElement(elementId);
};

// Generic treeview toggler buffer if not defined elsewhere (Compatibility Layer)
if (typeof window.toggleTreeviewGroup === 'undefined') {
    window.toggleTreeviewGroup = function (groupKey) {
        const collapsedState = JSON.parse(localStorage.getItem('plume_treeview_collapsed') || '{}');
        collapsedState[groupKey] = !collapsedState[groupKey];
        localStorage.setItem('plume_treeview_collapsed', JSON.stringify(collapsedState));

        // Router for re-rendering
        if (groupKey.startsWith('codex_')) CodexView.renderList();
        else if (groupKey.startsWith('chars_') && typeof renderCharactersList === 'function') renderCharactersList();
        else if (groupKey.startsWith('world_') && typeof renderWorldList === 'function') renderWorldList();
    };
}

// ========== js/25.globalSearch.js ==========

// Global Search

// [MVVM : ViewModel]
// État local pour le debounce de la recherche.
let searchTimeout = null;

// [MVVM : ViewModel]
// Traite l'entrée utilisateur pour la recherche globale.
function performGlobalSearch(query) {
    clearTimeout(searchTimeout);

    const resultsContainer = document.getElementById('searchResults');

    if (!query || query.trim().length < 2) {
        resultsContainer.classList.remove('active');
        return;
    }

    // Debounce search
    searchTimeout = setTimeout(() => {
        const results = searchEverywhere(query.trim());
        displaySearchResults(results, query.trim());
    }, 300);
}

// [MVVM : ViewModel]
// Parcourt les données du Model et les prépare pour la View.
function searchEverywhere(query) {
    const results = [];
    const lowerQuery = query.toLowerCase();

    // Search in scenes
    project.acts.forEach(act => {
        act.chapters.forEach(chapter => {
            chapter.scenes.forEach(scene => {
                const temp = document.createElement('div');
                temp.innerHTML = scene.content;
                const textContent = temp.textContent || temp.innerText || '';

                if (scene.title.toLowerCase().includes(lowerQuery) ||
                    textContent.toLowerCase().includes(lowerQuery)) {

                    const matchIndex = textContent.toLowerCase().indexOf(lowerQuery);
                    const preview = matchIndex >= 0
                        ? getPreview(textContent, matchIndex, query.length)
                        : textContent.substring(0, 150);

                    results.push({
                        type: 'Scène',
                        title: scene.title,
                        path: `${act.title} > ${chapter.title}`,
                        preview: preview,
                        action: () => openScene(act.id, chapter.id, scene.id)
                    });
                }
            });
        });
    });

    // Search in characters
    project.characters.forEach(char => {
        const searchText = `${char.name} ${char.role} ${char.description} ${char.personality} ${char.background}`.toLowerCase();
        if (searchText.includes(lowerQuery)) {
            results.push({
                type: 'Personnage',
                title: char.name,
                path: char.role || 'Personnage',
                preview: char.description || 'Aucune description',
                action: () => { switchView('characters'); openCharacterDetail(char.id); }
            });
        }
    });

    // Search in world elements
    project.world.forEach(element => {
        const searchText = `${element.name} ${element.description} ${element.details}`.toLowerCase();
        if (searchText.includes(lowerQuery)) {
            results.push({
                type: 'Univers',
                title: element.name,
                path: element.type,
                preview: element.description || 'Aucune description',
                action: () => { switchView('world'); openWorldDetail(element.id); }
            });
        }
    });

    // Search in timeline
    project.timeline.forEach(event => {
        const searchText = `${event.title} ${event.description} ${event.location} ${event.characters}`.toLowerCase();
        if (searchText.includes(lowerQuery)) {
            results.push({
                type: 'Chronologie',
                title: event.title,
                path: event.date || 'Événement',
                preview: event.description || 'Aucune description',
                action: () => { switchView('timeline'); openTimelineDetail(event.id); }
            });
        }
    });

    // Search in notes
    project.notes.forEach(note => {
        const searchText = `${note.title} ${note.content}`.toLowerCase();
        if (searchText.includes(lowerQuery)) {
            const matchIndex = note.content.toLowerCase().indexOf(lowerQuery);
            const preview = matchIndex >= 0
                ? getPreview(note.content, matchIndex, query.length)
                : note.content.substring(0, 150);

            results.push({
                type: 'Note',
                title: note.title,
                path: note.category,
                preview: preview,
                action: () => { switchView('notes'); openNoteDetail(note.id); }
            });
        }
    });

    // Search in codex
    project.codex.forEach(entry => {
        const searchText = `${entry.title} ${entry.summary} ${entry.content}`.toLowerCase();
        if (searchText.includes(lowerQuery)) {
            const matchIndex = entry.content.toLowerCase().indexOf(lowerQuery);
            const preview = matchIndex >= 0
                ? getPreview(entry.content, matchIndex, query.length)
                : entry.summary || entry.content.substring(0, 150);

            results.push({
                type: 'Codex',
                title: entry.title,
                path: entry.category,
                preview: preview,
                action: () => { switchView('codex'); openCodexDetail(entry.id); }
            });
        }
    });

    return results;
}

// [MVVM : ViewModel]
// Utilitaire de transformation pour générer un extrait.
function getPreview(text, matchIndex, queryLength) {
    const start = Math.max(0, matchIndex - 60);
    const end = Math.min(text.length, matchIndex + queryLength + 90);
    let preview = text.substring(start, end);

    if (start > 0) preview = '...' + preview;
    if (end < text.length) preview = preview + '...';

    return preview;
}

// [MVVM : View]
// Responsable du rendu DOM des résultats de recherche.
function displaySearchResults(results, query) {
    const container = document.getElementById('searchResults');

    if (results.length === 0) {
        container.innerHTML = '<div class="search-no-results">Aucun résultat trouvé</div>';
        container.classList.add('active');
        return;
    }

    const highlightQuery = (text) => {
        const regex = new RegExp(`(${query})`, 'gi');
        return text.replace(regex, '<span class="search-highlight">$1</span>');
    };

    container.innerHTML = results.map((result, index) => `
                        <div class="search-result-item" onclick="executeSearchAction(${index}); closeSearchResults();">
                            <div class="search-result-type">${result.type}</div>
                            <div class="search-result-title">${highlightQuery(result.title)}</div>
                            <div class="search-result-path">${result.path}</div>
                            <div class="search-result-preview">${highlightQuery(result.preview)}</div>
                        </div>
                    `).join('');

    // Store actions for execution
    window.searchResultActions = results.map(r => r.action);

    container.classList.add('active');
}

// [MVVM : ViewModel]
// Exécute l'action associée au résultat.
function executeSearchAction(index) {
    if (window.searchResultActions && window.searchResultActions[index]) {
        window.searchResultActions[index]();
    }
}

// [MVVM : View]
// Logique d'interface pour fermer les résultats de recherche.
function closeSearchResults() {
    document.getElementById('searchResults').classList.remove('active');
    document.getElementById('globalSearch').value = '';
}

// [MVVM : View]
// Écoute globale pour fermer les résultats au clic extérieur.
document.addEventListener('click', (e) => {
    const searchContainer = document.querySelector('.search-container');
    if (searchContainer && !searchContainer.contains(e.target)) {
        closeSearchResults();
    }
});

// ========== js-refactor/26.focusMode.refactor.js ==========

// Focus Mode Management
let focusModeActive = false;
let focusPanelOpen = false;
let focusStartWordCount = 0;
let linksPanelVisible = true; // État de visibilité du linksPanel

// Objectif de mots pour le projet (peut être configuré)
let projectWordGoal = 50000;

// [MVVM : ViewModel]
// Calcule les données de progression et met à jour la vue.
function updateWritingProgress() {
    if (!currentSceneId) return;

    const act = project.acts.find(a => a.id === currentActId);
    if (!act) return;
    const chapter = act.chapters.find(c => c.id === currentChapterId);
    if (!chapter) return;
    const scene = chapter.scenes.find(s => s.id === currentSceneId);
    if (!scene) return;

    const currentWords = getWordCount(scene.content || '');

    // Calculer le total de mots du projet
    const totalProjectWords = project.acts.reduce((sum, a) =>
        sum + a.chapters.reduce((s, ch) =>
            s + ch.scenes.reduce((sc, scene) => sc + (scene.wordCount || 0), 0), 0), 0);

    // Mettre à jour la barre de progression
    const progressPercent = Math.min((totalProjectWords / projectWordGoal) * 100, 100);
    const progressFill = document.getElementById('writingProgressFill');
    if (progressFill) {
        progressFill.style.width = progressPercent + '%';
    }

    // Mettre à jour l'indicateur de position
    const positionIndicator = document.getElementById('positionIndicator');
    if (positionIndicator) {
        positionIndicator.textContent = `Mot ${currentWords.toLocaleString()} • Total: ${totalProjectWords.toLocaleString()} / ${projectWordGoal.toLocaleString()}`;
    }
}

// [MVVM : Other]
// Group: Use Case | Naming: ToggleFocusUseCase
// Gère l'état logique et manipule les classes CSS/affichage (Mixte).
function toggleFocusMode() {
    console.log('toggleFocusMode called, current state:', focusModeActive);

    focusModeActive = !focusModeActive;
    const appContainer = document.querySelector('.app-container');
    const focusBtn = document.querySelector('.focus-toggle-btn');

    console.log('App container found:', !!appContainer);
    console.log('Focus button found:', !!focusBtn);

    if (focusModeActive) {
        console.log('ACTIVATING FOCUS MODE');
        appContainer.classList.add('focus-mode');

        // Hide left sidebar
        const sidebar = document.querySelector('.sidebar');
        if (sidebar) sidebar.style.display = 'none';

        // Ensure tools sidebar and its panels are visible and accessible
        const toolsSidebar = document.getElementById('toolsSidebar');
        if (toolsSidebar) {
            toolsSidebar.style.display = 'flex';
            toolsSidebar.style.zIndex = '105'; // Above editor
        }

        // Configure sidebars to be visible over the fullscreen editor
        const panels = [
            'sidebarVersions',
            'annotationsPanel',
            'todosPanel',
            'linksPanel',
            'arcScenePanel',
            'sidebarPlot'
        ];

        panels.forEach(id => {
            const el = document.getElementById(id);
            if (el) {
                // Ensure they have higher z-index to show on top of fullscreen mode
                el.style.zIndex = '110';
                // We don't force display here, as their specific toggle functions manage .hidden class
                // But we act as if they are part of the focus layout
                el.style.position = 'relative'; // Or keep default flex behavior if parent allows
            }
        });

        // Track starting word count
        if (currentSceneId) {
            const act = project.acts.find(a => a.id === currentActId);
            const chapter = act.chapters.find(c => c.id === currentChapterId);
            const scene = chapter.scenes.find(s => s.id === currentSceneId);
            focusStartWordCount = getWordCount(scene.content);
        }

        // Mettre à jour les indicateurs
        updateWritingProgress();

        // Request fullscreen on app-container
        if (appContainer.requestFullscreen) {
            appContainer.requestFullscreen().catch((err) => {
                console.log('Fullscreen not available or denied:', err);
            });
        }
    } else {
        console.log('DEACTIVATING FOCUS MODE');
        appContainer.classList.remove('focus-mode');

        // Forcer la réinitialisation des styles inline si nécessaire
        const sidebar = document.querySelector('.sidebar');
        const toolsSidebar = document.getElementById('toolsSidebar');
        const sidebarVersions = document.querySelector('.sidebar-versions');
        const appContent = document.querySelector('.app-content');
        const editorContainer = document.querySelector('.editor-container');

        if (sidebar) sidebar.style.cssText = '';
        if (toolsSidebar) toolsSidebar.style.cssText = '';

        // Reset panels styles
        const panels = [
            'sidebarVersions',
            'annotationsPanel',
            'todosPanel',
            'linksPanel',
            'arcScenePanel',
            'sidebarPlot'
        ];
        panels.forEach(id => {
            const el = document.getElementById(id);
            if (el) el.style.zIndex = '';
        });

        if (sidebarVersions && !sidebarVersions.classList.contains('hidden')) {
            sidebarVersions.style.cssText = '';
        }
        if (appContent) appContent.style.cssText = '';
        if (editorContainer) editorContainer.style.cssText = '';

        // Exit fullscreen
        if (document.exitFullscreen && document.fullscreenElement) {
            document.exitFullscreen();
        }
        focusPanelOpen = false;
        document.getElementById('focusPanel').classList.remove('active');
    }

    // Gestion visuelle du Tension Meter en mode Focus
    const tensionMeter = document.getElementById('liveTensionMeter');
    if (tensionMeter) {
        if (focusModeActive) tensionMeter.classList.add('focus-hide');
        else tensionMeter.classList.remove('focus-hide');
    }
}

// [MVVM : View]
// Bascule la visibilité d'un élément d'interface (panneau focus).
function toggleFocusPanel() {
    focusPanelOpen = !focusPanelOpen;
    const panel = document.getElementById('focusPanel');

    if (focusPanelOpen) {
        panel.classList.add('active');
        console.log('Focus panel opened');
    } else {
        panel.classList.remove('active');
        console.log('Focus panel closed');
    }
}

// [MVVM : View]
// Bascule l'affichage d'un composant UI (barre d'outils).
function toggleToolbar() {
    const toolbar = document.getElementById('editorToolbar');
    if (toolbar) {
        toolbar.style.display = document.getElementById('hideToolbar').checked ? 'none' : 'flex';
    }
}

// [MVVM : View]
// Bascule l'affichage d'un composant UI (panneau des liens).
function toggleLinksPanelVisibility() {
    const linksPanel = document.getElementById('linksPanel');
    const toolBtn = document.getElementById('toolLinksPanelBtn');
    const checkbox = document.getElementById('hideLinksPanel');

    if (!linksPanel) return;

    const isCurrentlyHidden = linksPanel.classList.contains('hidden');

    if (isCurrentlyHidden) {
        // Afficher le panneau
        if (typeof renderLinksPanelSidebar === 'function') {
            renderLinksPanelSidebar();
        }
        linksPanel.classList.remove('hidden');
        linksPanelVisible = true;
        if (toolBtn) toolBtn.classList.add('active');
        if (checkbox) checkbox.checked = false;
    } else {
        // Masquer le panneau
        linksPanel.classList.add('hidden');
        linksPanelVisible = false;
        if (toolBtn) toolBtn.classList.remove('active');
        if (checkbox) checkbox.checked = true;
    }
}

// [MVVM : ViewModel]
// Met à jour les statistiques affichées dans le mode focus.
function updateFocusStats() {
    if (!focusModeActive || !currentSceneId) return;

    const act = project.acts.find(a => a.id === currentActId);
    const chapter = act.chapters.find(c => c.id === currentChapterId);
    const scene = chapter.scenes.find(s => s.id === currentSceneId);

    const currentWordCount = getWordCount(scene.content);
    const wordsWritten = Math.max(0, currentWordCount - focusStartWordCount);

    document.getElementById('focusWordCount').textContent = wordsWritten;
}

// Pomodoro Timer
let pomodoroTime = 25 * 60; // 25 minutes in seconds
let pomodoroInterval = null;
let pomodoroRunning = false;
let pomodorosCompleted = 0;

// [MVVM : View]
// Affiche ou masque la popup du timer Pomodoro.
function togglePomodoroPopup() {
    const popup = document.getElementById('pomodoroPopup');
    popup.classList.toggle('active');
}

// Fermer la popup si on clique ailleurs
document.addEventListener('click', function (event) {
    const popup = document.getElementById('pomodoroPopup');
    const btn = document.getElementById('pomodoroHeaderBtn');
    if (popup && btn && !popup.contains(event.target) && !btn.contains(event.target)) {
        popup.classList.remove('active');
    }
});

// [MVVM : ViewModel]
// Gère la logique de démarrage du timer Pomodoro.
function startPomodoro() {
    if (pomodoroRunning) return;

    pomodoroRunning = true;
    // Ajouter indicateur visuel sur le bouton header
    const headerBtn = document.getElementById('pomodoroHeaderBtn');
    if (headerBtn) headerBtn.classList.add('pomodoro-active');

    pomodoroInterval = setInterval(() => {
        if (pomodoroTime > 0) {
            pomodoroTime--;
            updatePomodoroDisplay();
        } else {
            // Pomodoro completed
            completedPomodoro();
        }
    }, 1000);
}

// [MVVM : ViewModel]
// Gère la logique de pause du timer Pomodoro.
function pausePomodoro() {
    pomodoroRunning = false;
    // Retirer indicateur visuel
    const headerBtn = document.getElementById('pomodoroHeaderBtn');
    if (headerBtn) headerBtn.classList.remove('pomodoro-active');

    if (pomodoroInterval) {
        clearInterval(pomodoroInterval);
        pomodoroInterval = null;
    }
}

// [MVVM : ViewModel]
// Réinitialise l'état logique du timer Pomodoro.
function resetPomodoro() {
    pausePomodoro();
    pomodoroTime = 25 * 60;
    updatePomodoroDisplay();
}

// [MVVM : ViewModel]
// Gère la fin d'un cycle Pomodoro (logique métier et notification).
function completedPomodoro() {
    pausePomodoro();
    pomodorosCompleted++;
    document.getElementById('pomodorosCompleted').textContent = pomodorosCompleted;

    // Play notification sound (simple beep)
    playNotificationSound();

    // Alert user
    alert('Pomodoro terminé ! Temps de faire une pause de 5 minutes.');

    // Reset for next session
    pomodoroTime = 25 * 60;
    updatePomodoroDisplay();
}

// [MVVM : View]
// Met à jour l'affichage textuel du timer dans l'interface.
function updatePomodoroDisplay() {
    const minutes = Math.floor(pomodoroTime / 60);
    const seconds = pomodoroTime % 60;
    document.getElementById('pomodoroDisplay').textContent =
        `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
}

// [MVVM : Other]
// Group: Service | Naming: AudioService
// Produit une sortie audio (Feedback UI).
function playNotificationSound() {
    // Create a simple beep sound using Web Audio API
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();

    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);

    oscillator.frequency.value = 800;
    oscillator.type = 'sine';

    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);

    oscillator.start(audioContext.currentTime);
    oscillator.stop(audioContext.currentTime + 0.5);
}

// Update focus stats on content change
// [MVVM : Other]
// Group: Util / Helper | Naming: FocusUtils
// Décore une fonction pour déclencher une mise à jour du ViewModel (Mixte).
const originalUpdateSceneContent = updateSceneContent;
updateSceneContent = function () {
    originalUpdateSceneContent();
    updateFocusStats();
};



// ========== js/27.keyboardShortcuts.js ==========

// Keyboard shortcuts
// [MVVM : ViewModel]
// Gestionnaire d'événements pour les raccourcis clavier globaux.
// Relie les entrées utilisateur (Vue) aux actions de l'application (ViewModel/Model).
document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
        closeModal('addChapterModal');
        closeModal('addSceneModal');
        closeModal('addActModal');
        closeModal('addCharacterModal');
        closeModal('addWorldModal');
        closeModal('addTimelineModal');
        closeModal('addNoteModal');
        closeModal('addCodexModal');
        closeModal('backupModal');
        closeModal('referencesModal');
        closeModal('projectsModal');
        closeModal('newProjectModal');
        closeSearchResults();

        // Close focus panel if open
        if (focusPanelOpen) {
            toggleFocusPanel();
        }
    }
    if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
        e.preventDefault();
        document.getElementById('globalSearch').focus();
    }
    if ((e.ctrlKey || e.metaKey) && e.key === 's') {
        e.preventDefault();
        saveProject();
    }
    if (e.key === 'F11') {
        e.preventDefault();
        toggleFocusMode();
    }
    // Raccourci pour le mode révision (Ctrl+R)
    if ((e.ctrlKey || e.metaKey) && e.key === 'r') {
        e.preventDefault();
        if (currentSceneId) {
            toggleRevisionMode();
        }
    }
});

// ========== js-refactor/28.revision.refactor.js ==========
// ============================================
// REVISION MODE FUNCTIONS - REFACTORED
// ============================================

// [MVVM : Other]
// Group: Use Case | Naming: ToggleRevisionUseCase
// Bascule l'état du mode révision et met à jour l'interface de la barre d'outils.
function toggleRevisionMode() {
    // Vérifier qu'une scène est ouverte
    if (!currentSceneId) {
        alert('Veuillez d\'abord ouvrir une scène pour activer le mode révision.');
        return;
    }

    revisionMode = !revisionMode;
    let toolbar = document.getElementById('editorToolbar');
    if (!toolbar) {
        toolbar = document.querySelector('.editor-toolbar, .revision-toolbar');
    }
    if (!toolbar) {
        console.error('Toolbar not found!');
        alert('Erreur: Barre d\'outils introuvable. Rechargez la page.');
        return;
    }
    const editor = document.querySelector('.editor-textarea');
    const panel = document.getElementById('annotationsPanel');

    if (revisionMode) {
        // Activer le mode révision
        toolbar.className = 'editor-toolbar revision-toolbar';
        toolbar.innerHTML = `
                    <span class="revision-badge"><i data-lucide="pencil" style="width:14px;height:14px;vertical-align:middle;margin-right:6px;"></i>MODE RÉVISION</span>
                    <button class="highlight-btn yellow ${selectedHighlightColor === 'yellow' ? 'active' : ''}" 
                            onclick="selectHighlightColor('yellow')">Jaune</button>
                    <button class="highlight-btn green ${selectedHighlightColor === 'green' ? 'active' : ''}" 
                            onclick="selectHighlightColor('green')">Vert</button>
                    <button class="highlight-btn blue ${selectedHighlightColor === 'blue' ? 'active' : ''}" 
                            onclick="selectHighlightColor('blue')">Bleu</button>
                    <button class="highlight-btn red ${selectedHighlightColor === 'red' ? 'active' : ''}" 
                            onclick="selectHighlightColor('red')">Rouge</button>
                    <button class="highlight-btn purple ${selectedHighlightColor === 'purple' ? 'active' : ''}" 
                            onclick="selectHighlightColor('purple')">Violet</button>
                    <button class="btn" onclick="applyHighlight()"><i data-lucide="highlighter" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Surligner</button>
                    <button class="btn" onclick="removeHighlight()"><i data-lucide="trash-2" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Retirer</button>
                    <button class="btn" onclick="openAnnotationPopup()"><i data-lucide="message-square" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Annoter</button>
                    <div style="flex: 1;"></div>
                    <button class="btn btn-primary" onclick="toggleRevisionMode()"><i data-lucide="check" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Quitter</button>
                `;
        if (editor) editor.contentEditable = 'false';
        // Ne pas afficher automatiquement le panneau
        // L'utilisateur cliquera sur "Voir annotations" s'il le souhaite
    } else {
        // Désactiver le mode révision
        toolbar.className = 'editor-toolbar';
        // USE CENTRALIZED TOOLBAR
        toolbar.innerHTML = getEditorToolbarHTML();
        if (editor) editor.contentEditable = 'true';
        if (panel) panel.classList.remove('visible');

        // Réinitialiser les color pickers après reconstruction de la toolbar
        initializeColorPickers();
    }

    // Refresh Lucide icons
    if (typeof lucide !== 'undefined') {
        lucide.createIcons();
    }
}

// [MVVM : ViewModel]
// Gère la sélection de la couleur de surlignage dans l'interface.
function selectHighlightColor(color) {
    selectedHighlightColor = color;
    document.querySelectorAll('.highlight-btn').forEach(btn => btn.classList.remove('active'));
    document.querySelector(`.highlight-btn.${color}`).classList.add('active');
}

// [MVVM : Other]
// Group: Use Case | Naming: ApplyHighlightUseCase
// Applique un surlignage à la sélection de texte et met à jour le contenu de la scène.
function applyHighlight() {
    const sel = window.getSelection();
    if (!sel.rangeCount || sel.isCollapsed) {
        alert('Sélectionnez du texte à surligner');
        return;
    }

    const range = sel.getRangeAt(0);
    const span = document.createElement('span');
    span.className = `highlight-${selectedHighlightColor}`;

    try {
        range.surroundContents(span);
        updateSceneContent();
    } catch (e) {
        alert('Impossible de surligner cette sélection (essayez une sélection plus simple)');
    }

    sel.removeAllRanges();
}

// [MVVM : Other]
// Group: Use Case | Naming: RemoveHighlightUseCase
// Retire le surlignage de la sélection et met à jour le contenu de la scène.
function removeHighlight() {
    const sel = window.getSelection();
    if (!sel.rangeCount) {
        alert('Sélectionnez un texte surligné à retirer');
        return;
    }

    const range = sel.getRangeAt(0);
    let node = range.commonAncestorContainer;

    if (node.nodeType === 3) {
        node = node.parentElement;
    }

    if (node.className && node.className.includes('highlight-')) {
        const parent = node.parentNode;
        while (node.firstChild) {
            parent.insertBefore(node.firstChild, node);
        }
        parent.removeChild(node);
        updateSceneContent();
    } else {
        alert('Sélectionnez un texte surligné');
    }

    sel.removeAllRanges();
}

// [MVVM : View]
// Ouvre la fenêtre contextuelle de création d' annotation.
function openAnnotationPopup() {
    const sel = window.getSelection();
    if (!sel.rangeCount || sel.isCollapsed) {
        alert('Sélectionnez du texte à annoter');
        return;
    }

    currentSelection = {
        text: sel.toString(),
        range: sel.getRangeAt(0).cloneRange()
    };

    document.getElementById('annotationPopup').classList.add('visible');
    document.getElementById('annotationText').value = '';
    document.getElementById('annotationText').focus();
}

// [MVVM : View]
// Ferme la fenêtre contextuelle de création d' annotation.
function closeAnnotationPopup() {
    document.getElementById('annotationPopup').classList.remove('visible');
    currentSelection = null;
}

// [MVVM : ViewModel]
// Gère le changement de type d' annotation dans l'interface.
function selectAnnotationType(type) {
    selectedAnnotationType = type;
    document.querySelectorAll('.annotation-type-btn').forEach(btn => btn.classList.remove('active'));
    document.querySelector(`.annotation-type-btn.${type}`).classList.add('active');
}

// [MVVM : Other]
// Group: Use Case | Naming: SaveAnnotationUseCase
// Enregistre une nouvelle annotation dans le modèle et l'insère visuellement dans l'éditeur.
function saveAnnotation() {
    const text = document.getElementById('annotationText').value.trim();
    if (!text) {
        alert('Veuillez entrer une annotation');
        return;
    }

    const act = project.acts.find(a => a.id === currentActId);
    const chapter = act.chapters.find(c => c.id === currentChapterId);
    const scene = chapter.scenes.find(s => s.id === currentSceneId);

    const annotationId = Date.now();

    // Ajouter l'annotation à la version active
    addVersionAnnotation(scene, {
        id: annotationId,
        type: selectedAnnotationType,
        text: text,
        context: currentSelection ? currentSelection.text : '',
        completed: false,
        createdAt: new Date().toISOString()
    });

    // Wrapper le texte sélectionné avec un marqueur
    if (currentSelection && currentSelection.range) {
        try {
            const span = document.createElement('span');
            span.id = `annotation-${annotationId}`;
            span.className = `annotation-marker ${selectedAnnotationType}`;
            span.setAttribute('data-annotation-id', annotationId);
            span.style.cursor = 'pointer';
            span.title = `${getAnnotationTypeLabel(selectedAnnotationType)}: ${text}`;

            // Définir les styles selon le type
            const styles = {
                comment: 'background: rgba(255, 235, 59, 0.3); border-bottom: 2px solid #FBC02D;',
                question: 'background: rgba(33, 150, 243, 0.3); border-bottom: 2px solid #1976D2;',
                todo: 'background: rgba(244, 67, 54, 0.3); border-bottom: 2px solid #D32F2F;'
            };
            span.style.cssText = styles[selectedAnnotationType] || '';

            // Wrapper le contenu
            currentSelection.range.surroundContents(span);

            // Ajouter un event listener pour cliquer sur le marqueur
            span.onclick = function (e) {
                e.stopPropagation();
                highlightAnnotation(annotationId);
            };

            // IMPORTANT: Mettre à jour le contenu de la scène ET de la version active avec le nouveau HTML
            const editor = document.getElementById('sceneEditor') || document.querySelector('.editor-textarea');
            if (editor) {
                scene.content = editor.innerHTML;
                // Mettre à jour aussi le contenu de la version active
                const activeVersion = getActiveVersion(scene);
                if (activeVersion) {
                    activeVersion.content = editor.innerHTML;
                }
            }
        } catch (e) {
            console.warn('Impossible de wrapper le texte:', e);
        }
    }

    saveProject();
    closeAnnotationPopup();
    renderAnnotationsPanel();
    renderActsList();
}

// [MVVM : View]
// Génère et affiche la liste des annotations de la scène dans le panneau latéral.
function renderAnnotationsPanel() {
    const panel = document.getElementById('annotationsPanelContent');
    const parentPanel = document.getElementById('annotationsPanel');

    if (!panel || !parentPanel) {
        console.error('Panneau annotations introuvable');
        return;
    }

    // Vérifier qu'une scène est sélectionnée
    if (!currentSceneId || !currentChapterId || !currentActId) {
        panel.innerHTML = `
                    <div class="annotations-panel-header">
                        <h3 style="margin: 0;">Annotations</h3>
                        <span class="annotations-panel-close" onclick="closeAnnotationsPanel()" title="Fermer"><i data-lucide="x" style="width:16px;height:16px;"></i></span>
                    </div>
                    <p style="text-align: center; color: var(--text-muted); padding: 2rem;">Sélectionnez une scène pour voir ses annotations</p>
                `;
        parentPanel.classList.add('visible');
        return;
    }

    const act = project.acts.find(a => a.id === currentActId);
    const chapter = act ? act.chapters.find(c => c.id === currentChapterId) : null;
    const scene = chapter ? chapter.scenes.find(s => s.id === currentSceneId) : null;

    if (!scene) {
        panel.innerHTML = `
                    <div class="annotations-panel-header">
                        <h3 style="margin: 0;">Annotations</h3>
                        <span class="annotations-panel-close" onclick="closeAnnotationsPanel()" title="Fermer"><i data-lucide="x" style="width:16px;height:16px;"></i></span>
                    </div>
                    <p style="text-align: center; color: var(--text-muted); padding: 2rem;">Scène introuvable</p>
                `;
        parentPanel.classList.add('visible');
        return;
    }

    // Migrer les anciennes annotations si nécessaire
    migrateSceneAnnotationsToVersion(scene);

    // Obtenir les annotations de la version active
    const annotations = getVersionAnnotations(scene);
    const activeVersion = getActiveVersion(scene);
    const versionLabel = activeVersion ? (activeVersion.label || `Version ${activeVersion.number}`) : '';

    if (!annotations || annotations.length === 0) {
        panel.innerHTML = `
                    <div class="annotations-panel-header">
                        <h3 style="margin: 0;">Annotations (0)</h3>
                        <span class="annotations-panel-close" onclick="closeAnnotationsPanel()" title="Fermer"><i data-lucide="x" style="width:16px;height:16px;"></i></span>
                    </div>
                    ${versionLabel ? `<div style="font-size: 0.75rem; color: var(--text-muted); padding: 0.5rem 1rem; background: var(--bg-tertiary); border-bottom: 1px solid var(--border-color);"><i data-lucide="pin" style="width:12px;height:12px;vertical-align:middle;margin-right:6px;"></i> ${versionLabel}</div>` : ''}
                    <p style="text-align: center; color: var(--text-muted); padding: 2rem;">Aucune annotation pour cette version</p>
                `;
    } else {
        panel.innerHTML = `
                    <div class="annotations-panel-header">
                        <h3 style="margin: 0;">Annotations (${annotations.length})</h3>
                        <span class="annotations-panel-close" onclick="closeAnnotationsPanel()" title="Fermer"><i data-lucide="x" style="width:16px;height:16px;"></i></span>
                    </div>
                    ${versionLabel ? `<div style="font-size: 0.75rem; color: var(--text-muted); padding: 0.5rem 1rem; background: var(--bg-tertiary); border-bottom: 1px solid var(--border-color);"><i data-lucide="pin" style="width:12px;height:12px;vertical-align:middle;margin-right:6px;"></i> ${versionLabel}</div>` : ''}
                    ${annotations.map(a => `
                        <div class="annotation-card ${a.type}" onclick="scrollToAnnotation(${a.id})">
                            <div class="annotation-type ${a.type}">${getAnnotationTypeLabel(a.type)}</div>
                            <div class="annotation-content">${a.text}</div>
                            ${a.context ? `<div class="annotation-context">"${a.context}"</div>` : ''}
                            ${a.type === 'todo' ? `
                                <button class="btn btn-small ${a.completed ? 'btn-primary' : ''}" 
                                        onclick="event.stopPropagation(); toggleAnnotationComplete(${a.id})" 
                                        style="margin-top: 0.5rem;">
                                    ${a.completed ? '<i data-lucide="check" style="width:12px;height:12px;vertical-align:middle;margin-right:4px;"></i>Terminé' : '<i data-lucide="circle" style="width:12px;height:12px;vertical-align:middle;margin-right:4px;"></i>À faire'}
                                </button>
                            ` : ''}
                            <button class="btn btn-small" onclick="event.stopPropagation(); deleteAnnotation(${a.id})" 
                                    style="margin-top: 0.5rem;"><i data-lucide="trash-2" style="width:12px;height:12px;vertical-align:middle;margin-right:4px;"></i>Supprimer</button>
                        </div>
                    `).join('')}
                `;
    }

    // Afficher le panneau
    parentPanel.classList.remove('hidden');
}



// [MVVM : ViewModel]
// Alterne l'affichage du panneau des annotations.
function toggleAnnotationsPanel() {
    const panel = document.getElementById('annotationsPanel');
    if (panel.classList.contains('hidden')) {
        renderAnnotationsPanel();
        updateAnnotationsButton(true);
    } else {
        panel.classList.add('hidden');
        updateAnnotationsButton(false);
    }
}

// [MVVM : View]
// Masque le panneau des annotations.
function closeAnnotationsPanel() {
    const panel = document.getElementById('annotationsPanel');
    if (panel) {
        panel.classList.add('hidden');
        updateAnnotationsButton(false);
    }
}

// [MVVM : View]
// Met à jour les compteurs et l'état visuel des boutons d' accès aux annotations.
function updateAnnotationsButton(isOpen) {
    const sidebarBtn = document.getElementById('sidebarAnnotationsBtn');
    const sidebarBadge = document.getElementById('annotationsBadge');
    const todosBadge = document.getElementById('todosBadge');

    // Compter les annotations et TODOs de la scène courante (version active)
    let annotationCount = 0;
    let todoCount = 0;

    if (currentSceneId) {
        const act = project.acts.find(a => a.id === currentActId);
        if (act) {
            const chapter = act.chapters.find(c => c.id === currentChapterId);
            if (chapter) {
                const scene = chapter.scenes.find(s => s.id === currentSceneId);
                if (scene) {
                    const annotations = getVersionAnnotations(scene);
                    annotationCount = annotations.length;
                    todoCount = annotations.filter(a => a.type === 'todo' && !a.completed).length;
                }
            }
        }
    }

    // Compter tous les TODOs non complétés du projet (toutes versions actives)
    let totalTodos = 0;
    project.acts.forEach(act => {
        act.chapters.forEach(chapter => {
            chapter.scenes.forEach(scene => {
                const annotations = getVersionAnnotations(scene);
                totalTodos += annotations.filter(a => a.type === 'todo' && !a.completed).length;
            });
        });
    });


    // Mettre à jour le bouton sidebar annotations
    if (sidebarBtn) {
        if (isOpen) {
            sidebarBtn.classList.add('active');
        } else {
            sidebarBtn.classList.remove('active');
        }
    }

    // Mettre à jour le badge sidebar annotations
    if (sidebarBadge) {
        if (annotationCount > 0) {
            sidebarBadge.style.display = 'inline';
            sidebarBadge.textContent = annotationCount > 9 ? '9+' : annotationCount;
        } else {
            sidebarBadge.style.display = 'none';
        }
    }

    // Mettre à jour le badge sidebar TODOs
    if (todosBadge) {
        if (totalTodos > 0) {
            todosBadge.style.display = 'inline';
            todosBadge.textContent = totalTodos > 9 ? '9+' : totalTodos;
        } else {
            todosBadge.style.display = 'none';
        }
    }

    // Mettre à jour les nouveaux badges de la toolbar verticale
    const toolAnnotationsBtn = document.getElementById('toolAnnotationsBtn');
    const toolAnnotationsBadge = document.getElementById('toolAnnotationsBadge');
    const toolTodosBtn = document.getElementById('toolTodosBtn');
    const toolTodosBadge = document.getElementById('toolTodosBadge');

    // Badge annotations de la toolbar verticale
    if (toolAnnotationsBadge) {
        if (annotationCount > 0) {
            toolAnnotationsBadge.style.display = 'inline';
            toolAnnotationsBadge.textContent = annotationCount > 9 ? '9+' : annotationCount;
        } else {
            toolAnnotationsBadge.style.display = 'none';
        }
    }

    // Badge TODOs de la toolbar verticale
    if (toolTodosBadge) {
        if (totalTodos > 0) {
            toolTodosBadge.style.display = 'inline';
            toolTodosBadge.textContent = totalTodos > 9 ? '9+' : totalTodos;
        } else {
            toolTodosBadge.style.display = 'none';
        }
    }

    // État actif des boutons de la toolbar
    if (toolAnnotationsBtn) {
        if (isOpen) {
            toolAnnotationsBtn.classList.add('active');
        } else {
            toolAnnotationsBtn.classList.remove('active');
        }
    }
}

// [MVVM : Other]
// Group: Util / Helper | Naming: AnnotationUtils
// Fonction utilitaire retournant le libellé lisible d' un type d' annotation.
function getAnnotationTypeLabel(type) {
    const labels = {
        comment: 'Commentaire',
        todo: 'TODO',
        note: 'Note',
        question: 'Question'
    };
    return labels[type] || type;
}

// ============ ANNOTATIONS LIÉES AUX VERSIONS ============

// Obtenir la version active d'une scène (ou créer une version par défaut)
// [MVVM : Model]
// Récupère la version active d' une scène.
function getActiveVersion(scene) {
    if (!scene.versions || scene.versions.length === 0) {
        return null;
    }
    return scene.versions.find(v => v.isActive) || scene.versions[scene.versions.length - 1];
}

// Obtenir les annotations de la version active
// [MVVM : Model]
// Récupère la liste des annotations pour la version active d' une scène.
function getVersionAnnotations(scene) {
    const activeVersion = getActiveVersion(scene);
    if (activeVersion) {
        if (!activeVersion.annotations) {
            activeVersion.annotations = [];
        }
        return activeVersion.annotations;
    }
    // Fallback: annotations au niveau scène (anciennes données)
    if (!scene.annotations) {
        scene.annotations = [];
    }
    return scene.annotations;
}

// Ajouter une annotation à la version active
// [MVVM : Model]
// Ajoute une annotation à la version désirée.
function addVersionAnnotation(scene, annotation) {
    const activeVersion = getActiveVersion(scene);
    if (activeVersion) {
        if (!activeVersion.annotations) {
            activeVersion.annotations = [];
        }
        activeVersion.annotations.push(annotation);
    } else {
        // Fallback si pas de version
        if (!scene.annotations) {
            scene.annotations = [];
        }
        scene.annotations.push(annotation);
    }
}

// Supprimer une annotation de la version active
// [MVVM : Model]
// Supprime une annotation de la version.
function removeVersionAnnotation(scene, annotationId) {
    const activeVersion = getActiveVersion(scene);
    if (activeVersion && activeVersion.annotations) {
        activeVersion.annotations = activeVersion.annotations.filter(a => a.id !== annotationId);
    } else if (scene.annotations) {
        scene.annotations = scene.annotations.filter(a => a.id !== annotationId);
    }
}

// Trouver une annotation dans la version active
// [MVVM : Model]
// Recherche une annotation spécifique par son ID.
function findVersionAnnotation(scene, annotationId) {
    const annotations = getVersionAnnotations(scene);
    return annotations.find(a => a.id === annotationId);
}

// Migrer les annotations d'une scène vers sa version active (migration one-time)
// [MVVM : Model]
// Assure la compatibilité en migrant les anciennes annotations vers le nouveau système de versions.
function migrateSceneAnnotationsToVersion(scene) {
    if (scene.annotations && scene.annotations.length > 0) {
        const activeVersion = getActiveVersion(scene);
        if (activeVersion) {
            if (!activeVersion.annotations) {
                activeVersion.annotations = [];
            }
            // Migrer seulement si la version n'a pas déjà ces annotations
            scene.annotations.forEach(ann => {
                if (!activeVersion.annotations.find(a => a.id === ann.id)) {
                    activeVersion.annotations.push(ann);
                }
            });
            // Vider les annotations au niveau scène après migration
            scene.annotations = [];
            return true; // Migration effectuée
        }
    }
    return false;
}

// ============ FIN ANNOTATIONS LIÉES AUX VERSIONS ============

// [MVVM : Other]
// Group: Use Case | Naming: ToggleAnnotationCompleteUseCase
// Alterne l' état d' achèvement d' une annotation et rafraîchit l' interface.
function toggleAnnotationComplete(annotationId) {
    const act = project.acts.find(a => a.id === currentActId);
    const chapter = act.chapters.find(c => c.id === currentChapterId);
    const scene = chapter.scenes.find(s => s.id === currentSceneId);
    const annotation = findVersionAnnotation(scene, annotationId);

    if (annotation) {
        annotation.completed = !annotation.completed;
        saveProject();
        renderAnnotationsPanel();
        renderActsList();
    }
}

// [MVVM : Other]
// Group: Use Case | Naming: DeleteAnnotationUseCase
// Supprime une annotation du modèle et retire son marqueur visuel de l' éditeur.
function deleteAnnotation(annotationId) {
    if (!confirm('Supprimer cette annotation ?')) return;

    const act = project.acts.find(a => a.id === currentActId);
    const chapter = act.chapters.find(c => c.id === currentChapterId);
    const scene = chapter.scenes.find(s => s.id === currentSceneId);

    // Supprimer le marqueur visuel dans l'éditeur
    const marker = document.getElementById(`annotation-${annotationId}`);
    if (marker) {
        // Remplacer le span par son contenu textuel
        const textContent = marker.textContent;
        const textNode = document.createTextNode(textContent);
        marker.parentNode.replaceChild(textNode, marker);

        // Mettre à jour le contenu de la scène avec le HTML nettoyé
        const editor = document.querySelector('.editor-textarea');
        if (editor) {
            scene.content = editor.innerHTML;
            // Mettre à jour aussi la version active
            const activeVersion = getActiveVersion(scene);
            if (activeVersion) {
                activeVersion.content = editor.innerHTML;
            }
        }
    }

    // Aussi nettoyer dans scene.content si le marqueur est sauvegardé (fallback)
    if (scene.content) {
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = scene.content;
        const savedMarker = tempDiv.querySelector(`#annotation-${annotationId}, [data-annotation-id="${annotationId}"]`);
        if (savedMarker) {
            const textContent = savedMarker.textContent;
            const textNode = document.createTextNode(textContent);
            savedMarker.parentNode.replaceChild(textNode, savedMarker);
            scene.content = tempDiv.innerHTML;
        }
    }

    // Supprimer l'annotation de la version active
    removeVersionAnnotation(scene, annotationId);

    // Mettre à jour aussi le contenu de la version active (fallback)
    const activeVersion = getActiveVersion(scene);
    if (activeVersion && activeVersion.content) {
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = activeVersion.content;
        const versionMarker = tempDiv.querySelector(`#annotation-${annotationId}, [data-annotation-id="${annotationId}"]`);
        if (versionMarker) {
            const textContent = versionMarker.textContent;
            const textNode = document.createTextNode(textContent);
            versionMarker.parentNode.replaceChild(textNode, versionMarker);
            activeVersion.content = tempDiv.innerHTML;
        }
    }

    saveProject();
    renderAnnotationsPanel();
    renderActsList();
    showNotification('✓ Annotation supprimée');
}

// [MVVM : View]
// Fait défiler l' éditeur pour centrer une annotation spécifique.
function scrollToAnnotation(annotationId) {
    // NE PAS fermer le panneau - l'utilisateur veut peut-être voir plusieurs annotations

    // Trouver le marqueur dans le texte
    const marker = document.getElementById(`annotation-${annotationId}`);

    if (marker) {
        // Trouver le conteneur scrollable de l'éditeur
        const editorWorkspace = document.querySelector('.editor-workspace');

        if (editorWorkspace) {
            // Calculer la position relative du marqueur
            const markerRect = marker.getBoundingClientRect();
            const workspaceRect = editorWorkspace.getBoundingClientRect();

            // Calculer le scroll nécessaire pour centrer le marqueur
            const targetScroll = editorWorkspace.scrollTop + (markerRect.top - workspaceRect.top) - (workspaceRect.height / 2);

            editorWorkspace.scrollTo({
                top: Math.max(0, targetScroll),
                behavior: 'smooth'
            });
        }

        // Highlighter temporairement
        highlightAnnotation(annotationId);
    } else {
        // Si le marqueur n'existe pas (ancienne annotation), juste informer
        console.warn(`Marqueur annotation-${annotationId} introuvable`);
        showNotification('Annotation non localisée dans le texte');
    }
}

// [MVVM : View]
// Crée une animation visuelle pour mettre en évidence une annotation dans le texte.
function highlightAnnotation(annotationId) {
    const marker = document.getElementById(`annotation-${annotationId}`);
    if (!marker) return;

    // Sauvegarder le style original
    const originalStyle = marker.style.cssText;

    // Ajouter une animation de highlight
    marker.style.cssText = originalStyle + ' background: rgba(212, 175, 55, 0.8) !important; transition: background 0.3s;';

    // Pulser 3 fois
    let pulseCount = 0;
    const pulseInterval = setInterval(() => {
        if (pulseCount >= 6) {
            clearInterval(pulseInterval);
            // Restaurer le style original
            marker.style.cssText = originalStyle;
            return;
        }

        if (pulseCount % 2 === 0) {
            marker.style.cssText = originalStyle + ' background: rgba(212, 175, 55, 0.8) !important;';
        } else {
            marker.style.cssText = originalStyle;
        }
        pulseCount++;
    }, 400);
}

// ========== js-refactor/29.todos.refactor.js ==========
// ==========================================
// TODOS PANEL
// ==========================================

// [MVVM : Other]
// Group: Use Case | Naming: ToggleTodosUseCase
// Alterne l'affichage du panneau des TODOs et déclenche le rendu
function toggleTodosPanel() {
    const panel = document.getElementById('todosPanel');
    const btn = document.getElementById('sidebarTodosBtn');
    const toolBtn = document.getElementById('toolTodosBtn');

    if (panel.classList.contains('hidden')) {
        renderTodosPanel();
        panel.classList.remove('hidden');
        if (btn) btn.classList.add('active');
        if (toolBtn) toolBtn.classList.add('active');
    } else {
        panel.classList.add('hidden');
        if (btn) btn.classList.remove('active');
        if (toolBtn) toolBtn.classList.remove('active');
    }
}

// [MVVM : View]
// Ferme le panneau des TODOs
function closeTodosPanel() {
    const panel = document.getElementById('todosPanel');
    const btn = document.getElementById('sidebarTodosBtn');
    const toolBtn = document.getElementById('toolTodosBtn');
    if (panel) {
        panel.classList.add('hidden');
    }
    if (btn) btn.classList.remove('active');
    if (toolBtn) toolBtn.classList.remove('active');
}

// [MVVM : Other]
// Group: Coordinator | Naming: TodosCoordinator
// Collecte les TODOs depuis le Model (project) et construit l'interface du panneau
function renderTodosPanel() {
    const panel = document.getElementById('todosPanelContent');
    const parentPanel = document.getElementById('todosPanel');

    if (!panel || !parentPanel) {
        console.error('Panneau TODOs introuvable');
        return;
    }

    // Collecter tous les TODOs du projet (de la version active de chaque scène)
    const todos = [];
    project.acts.forEach(act => {
        act.chapters.forEach(chapter => {
            chapter.scenes.forEach(scene => {
                const annotations = getVersionAnnotations(scene);
                annotations
                    .filter(a => a.type === 'todo')
                    .forEach(todo => {
                        todos.push({
                            ...todo,
                            actId: act.id,
                            actTitle: act.title,
                            chapterId: chapter.id,
                            chapterTitle: chapter.title,
                            sceneId: scene.id,
                            sceneTitle: scene.title
                        });
                    });
            });
        });
    });

    const pendingTodos = todos.filter(t => !t.completed);
    const completedTodos = todos.filter(t => t.completed);

    if (todos.length === 0) {
        panel.innerHTML = `
            <div class="annotations-panel-header">
                <h3 style="margin: 0;"><i data-lucide="check-square" style="width:18px;height:18px;vertical-align:middle;margin-right:6px;"></i>TODOs (0)</h3>
                <span class="annotations-panel-close" onclick="closeTodosPanel()" title="Fermer"><i data-lucide="x" style="width:16px;height:16px;"></i></span>
            </div>
            <p style="text-align: center; color: var(--text-muted); padding: 2rem;">Aucun TODO dans le projet</p>
        `;
    } else {
        panel.innerHTML = `
            <div class="annotations-panel-header">
                <h3 style="margin: 0;"><i data-lucide="check-square" style="width:18px;height:18px;vertical-align:middle;margin-right:6px;"></i>TODOs (${pendingTodos.length} actif${pendingTodos.length > 1 ? 's' : ''})</h3>
                <span class="annotations-panel-close" onclick="closeTodosPanel()" title="Fermer"><i data-lucide="x" style="width:16px;height:16px;"></i></span>
            </div>
            
            ${pendingTodos.length > 0 ? `
                <div style="margin-bottom: 1rem;">
                    <div style="font-size: 0.75rem; font-weight: 600; color: var(--text-muted); margin-bottom: 0.5rem; text-transform: uppercase;">À faire</div>
                    ${pendingTodos.map(todo => `
                        <div class="annotation-card todo" onclick="goToTodoScene(${todo.actId}, ${todo.chapterId}, ${todo.sceneId})" style="cursor: pointer;">
                            <div style="font-size: 0.7rem; color: var(--text-muted); margin-bottom: 0.25rem;">${todo.sceneTitle}</div>
                            <div class="annotation-content">${todo.text}</div>
                            <div style="display: flex; gap: 0.5rem; margin-top: 0.5rem;">
                                <button class="btn btn-small" onclick="event.stopPropagation(); toggleTodoFromPanel(${todo.actId}, ${todo.chapterId}, ${todo.sceneId}, ${todo.id})">
                                    <i data-lucide="check" style="width:12px;height:12px;vertical-align:middle;margin-right:4px;"></i>Marquer terminé
                                </button>
                            </div>
                        </div>
                    `).join('')}
                </div>
            ` : ''}
            
            ${completedTodos.length > 0 ? `
                <div>
                    <div style="font-size: 0.75rem; font-weight: 600; color: var(--text-muted); margin-bottom: 0.5rem; text-transform: uppercase;">Terminés (${completedTodos.length})</div>
                    ${completedTodos.map(todo => `
                        <div class="annotation-card" style="opacity: 0.6; cursor: pointer;" onclick="goToTodoScene(${todo.actId}, ${todo.chapterId}, ${todo.sceneId})">
                            <div style="font-size: 0.7rem; color: var(--text-muted); margin-bottom: 0.25rem;">${todo.sceneTitle}</div>
                            <div class="annotation-content" style="text-decoration: line-through;">${todo.text}</div>
                            <div style="display: flex; gap: 0.5rem; margin-top: 0.5rem;">
                                <button class="btn btn-small" onclick="event.stopPropagation(); toggleTodoFromPanel(${todo.actId}, ${todo.chapterId}, ${todo.sceneId}, ${todo.id})">
                                    <i data-lucide="rotate-ccw" style="width:12px;height:12px;vertical-align:middle;margin-right:4px;"></i>Rouvrir
                                </button>
                            </div>
                        </div>
                    `).join('')}
                </div>
            ` : ''}
        `;
    }

    // Afficher le panneau
    parentPanel.classList.remove('hidden');

    // Rafraîchir les icônes Lucide
    setTimeout(() => {
        if (typeof lucide !== 'undefined') lucide.createIcons();
    }, 10);
}

// [MVVM : ViewModel]
// Ouvre une scène spécifique et ferme le panneau
function goToTodoScene(actId, chapterId, sceneId) {
    openScene(actId, chapterId, sceneId);
    closeTodosPanel();
}

// [MVVM : ViewModel]
// Bascule l'état d'un TODO depuis le panneau et met à jour le Model et la View
function toggleTodoFromPanel(actId, chapterId, sceneId, todoId) {
    const act = project.acts.find(a => a.id === actId);
    if (!act) return;
    const chapter = act.chapters.find(c => c.id === chapterId);
    if (!chapter) return;
    const scene = chapter.scenes.find(s => s.id === sceneId);
    if (!scene) return;

    const todo = findVersionAnnotation(scene, todoId);
    if (todo) {
        todo.completed = !todo.completed;
        saveProject();
        if (typeof saveToHistory === 'function') {
            saveToHistory('toggleTodo');
        }
        renderTodosPanel();
        updateAnnotationsButton(false);
        renderActsList();
    }
}

// [MVVM : Model]
// Retourne le nombre total d'annotations pour une scène (logique de données)
function getSceneAnnotationCount(scene) {
    const annotations = getVersionAnnotations(scene);
    return annotations.length;
}

// [MVVM : Model]
// Retourne le nombre de TODOs non terminés pour une scène (logique de données)
function getSceneTodoCount(scene) {
    const annotations = getVersionAnnotations(scene);
    return annotations.filter(a => a.type === 'todo' && !a.completed).length;
}

// Modifier la fonction renderEditor pour ajouter le bouton révision
// [MVVM : Other]
// Group: Util / Helper | Naming: RevisionUtils
// Extension du rendu de l'éditeur pour intégrer les options de révision
const originalRenderEditor = renderEditor;
renderEditor = function (act, chapter, scene) {
    originalRenderEditor(act, chapter, scene);

    // Ajouter le bouton révision dans la toolbar si pas déjà en mode révision
    if (!revisionMode) {
        const toolbar = document.getElementById('editorToolbar');
        if (toolbar && !toolbar.querySelector('[onclick*="toggleRevisionMode"]')) {
            const revisionGroup = document.createElement('div');
            revisionGroup.className = 'toolbar-group';
            revisionGroup.innerHTML = '<button class="toolbar-btn" onclick="toggleRevisionMode()" title="Mode Révision (Ctrl+R)"><i data-lucide="pencil" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>RÉVISION</button>';
            try {
                toolbar.appendChild(revisionGroup);
            } catch (e) {
                console.error('Erreur appendChild toolbar:', e);
            }
        }
    }

    // Rafraîchir les icônes Lucide après le rendu
    setTimeout(() => {
        if (typeof lucide !== 'undefined') lucide.createIcons();
        // Réattacher les event listeners sur les marqueurs d'annotation
        reattachAnnotationMarkerListeners();
    }, 10);
};

// Modifier renderActsList pour afficher les badges d'annotations
// [MVVM : Other]
// Group: Util / Helper | Naming: RevisionUtils
// Extension du rendu de la liste des actes pour inclure les badges d'annotations (Model -> View)
const originalRenderActsList = renderActsList;
renderActsList = function () {
    originalRenderActsList();

    // Ajouter les badges d'annotations aux scènes (version active)
    project.acts.forEach(act => {
        act.chapters.forEach(chapter => {
            chapter.scenes.forEach(scene => {
                const sceneElement = document.querySelector(`[data-scene-id="${scene.id}"]`);
                const annotations = getVersionAnnotations(scene);
                if (sceneElement && annotations.length > 0) {
                    const annotCount = annotations.length;
                    const todoCount = annotations.filter(a => a.type === 'todo' && !a.completed).length;

                    let badgeHTML = `<span class="scene-badge">${annotCount}</span>`;
                    if (todoCount > 0) {
                        badgeHTML += `<span class="scene-badge" style="background: var(--accent-red);"><i data-lucide="check" style="width:10px;height:10px;vertical-align:middle;margin-right:2px;"></i>${todoCount}</span>`;
                    }

                    // Chercher spécifiquement le span du titre
                    const titleSpan = sceneElement.querySelector('.scene-title') ||
                        sceneElement.querySelector('span[ondblclick*="startEditingScene"]') ||
                        sceneElement.querySelector('div > span:not(.drag-handle)');

                    if (titleSpan && !titleSpan.querySelector('.scene-badge')) {
                        titleSpan.innerHTML += badgeHTML;
                    }
                }
            });
        });
    });
};

// Initialiser les annotations dans les scènes existantes (migration vers versions)
// [MVVM : Model]
// Gère la structure des données et la migration des annotations
function ensureAnnotationsStructure() {
    let needsSave = false;
    project.acts.forEach(act => {
        act.chapters.forEach(chapter => {
            chapter.scenes.forEach(scene => {
                // Migrer les anciennes annotations vers la version active
                if (migrateSceneAnnotationsToVersion(scene)) {
                    needsSave = true;
                }
            });
        });
    });
    if (needsSave) {
        saveProject();
        console.log('Migration des annotations vers les versions effectuée');
    }
}

// Appeler au chargement
// [MVVM : ViewModel]
// Initialisation globale intégrant la structure des annotations
const originalInit = init;
init = function () {
    originalInit();
    ensureAnnotationsStructure();
};

// ============================================
// TODO LIST VIEW
// ============================================

// [MVVM : Other]
// Group: Coordinator | Naming: TodosCoordinator
// Construit et affiche la vue complète de la liste des TODOs au milieu de l'écran
function renderTodosList() {
    // Afficher dans editorView au lieu de la sidebar
    const editorView = document.getElementById('editorView');
    if (!editorView) {
        console.error('editorView not found');
        return;
    }

    // Collecter tous les TODOs (de la version active de chaque scène)
    const todos = [];
    project.acts.forEach(act => {
        act.chapters.forEach(chapter => {
            chapter.scenes.forEach(scene => {
                const annotations = getVersionAnnotations(scene);
                annotations.filter(a => a.type === 'todo').forEach(todo => {
                    todos.push({
                        ...todo,
                        actId: act.id,
                        actTitle: act.title,
                        chapterId: chapter.id,
                        chapterTitle: chapter.title,
                        sceneId: scene.id,
                        sceneTitle: scene.title
                    });
                });
            });
        });
    });

    // Trier: non terminés d'abord
    todos.sort((a, b) => {
        if (a.completed === b.completed) return 0;
        return a.completed ? 1 : -1;
    });

    if (todos.length === 0) {
        editorView.innerHTML = '<div style="height: 100%; overflow-y: auto; padding: 3rem; text-align: center; color: var(--text-muted); font-size: 1.2rem;"><i data-lucide="clipboard-list" style="width:48px;height:48px;margin-bottom:1rem;color:var(--text-muted);display:block;margin: 0 auto 1rem;"></i> Aucun TODO<br><br><small style="font-size: 0.9rem;">Les TODOs apparaissent lorsque vous utilisez le mode révision</small></div>';
    } else {
        editorView.innerHTML = `
            <div style="height: 100%; overflow-y: auto; padding: 2rem 3rem;">
                <h2 style="margin-bottom: 2rem; color: var(--accent-gold);"><i data-lucide="check-square" style="width:24px;height:24px;vertical-align:middle;margin-right:8px;"></i>TODOs (${todos.filter(t => !t.completed).length} actifs)</h2>
                <div style="display: flex; flex-direction: column; gap: 1rem;">
                ${todos.map(todo => `
                    <div class="todo-item" onclick="openSceneFromTodo(${todo.actId}, ${todo.chapterId}, ${todo.sceneId})" 
                         style="display: flex; gap: 1rem; padding: 1rem; background: var(--bg-secondary); border-left: 3px solid ${todo.completed ? 'var(--text-muted)' : 'var(--accent-gold)'}; border-radius: 4px; cursor: pointer; transition: all 0.2s;">
                        <input type="checkbox" ${todo.completed ? 'checked' : ''} 
                               onclick="event.stopPropagation(); toggleTodoFromList(${todo.id}, ${todo.actId}, ${todo.chapterId}, ${todo.sceneId})"
                               style="margin-top: 0.25rem;">
                        <div style="flex: 1;">
                            <div style="font-size: 1rem; ${todo.completed ? 'text-decoration: line-through; opacity: 0.6;' : 'font-weight: 500;'}">${todo.text}</div>
                            <div style="font-size: 0.85rem; color: var(--text-muted); margin-top: 0.5rem;">
                                <i data-lucide="map-pin" style="width:12px;height:12px;margin-right:4px;vertical-align:middle;"></i> ${todo.actTitle} › ${todo.chapterTitle} › ${todo.sceneTitle}
                            </div>
                        </div>
                    </div>
                `).join('')}
                </div>
            </div>
        `;
    }
    if (typeof lucide !== 'undefined') lucide.createIcons();
}

// [MVVM : ViewModel]
// Bascule l'état d'un TODO depuis la liste et rafraîchit les interfaces
function toggleTodoFromList(todoId, actId, chapterId, sceneId) {
    const act = project.acts.find(a => a.id === actId);
    if (!act) return;
    const chapter = act.chapters.find(c => c.id === chapterId);
    if (!chapter) return;
    const scene = chapter.scenes.find(s => s.id === sceneId);
    if (!scene) return;
    const todo = findVersionAnnotation(scene, todoId);

    if (todo) {
        todo.completed = !todo.completed;
        saveProject();
        if (typeof saveToHistory === 'function') {
            saveToHistory('toggleTodo');
        }
        renderTodosList();
        renderActsList();
    }
}

// [MVVM : ViewModel]
// Change la vue et ouvre la scène correspondante à un TODO
function openSceneFromTodo(actId, chapterId, sceneId) {
    switchView('editor');
    openScene(actId, chapterId, sceneId);
}

// ============================================
// FIN REVISION MODE
// ============================================

// Initialize on load

// [MVVM : View]
// Calcule et positionne le panneau d'annotations en fonction de la toolbar
function updateAnnotationsPanelPosition() {
    const header = document.querySelector('.editor-header');
    const toolbar = document.querySelector('.editor-toolbar, .revision-toolbar');
    const linksPanel = document.getElementById('linksPanel');
    const panel = document.getElementById('annotationsPanel');

    if (header && toolbar && panel) {
        let totalHeight = header.offsetHeight + toolbar.offsetHeight;
        if (linksPanel && linksPanel.style.display !== 'none') {
            totalHeight += linksPanel.offsetHeight;
        }
        panel.style.setProperty('--toolbar-height', totalHeight + 'px');
    }
}

// [MVVM : Other]
// Group: Util / Helper | Naming: RevisionUtils
// Extension du rendu du panneau d'annotations pour ajuster sa position
const originalRenderAnnotationsPanel = renderAnnotationsPanel;
renderAnnotationsPanel = function () {
    originalRenderAnnotationsPanel();
    setTimeout(updateAnnotationsPanelPosition, 50);
};

// ========== js-refactor/corkboard/corkboard.model.js ==========
// ============================================
// CORKBOARD MODEL
// ============================================
// Définit les structures de données et les règles métier du Cork Board

/**
 * Modèle de filtre pour le Cork Board
 * @typedef {Object} CorkBoardFilter
 * @property {string} type - Type de filtre: 'all', 'act', 'chapter'
 * @property {number|null} actId - ID de l'acte filtré
 * @property {number|null} chapterId - ID du chapitre filtré
 * @property {string} mode - Mode d'affichage: 'structured' ou 'kanban'
 */

/**
 * Modèle de scène enrichie pour le Cork Board
 * @typedef {Object} CorkBoardScene
 * @property {number} id - ID de la scène
 * @property {string} title - Titre de la scène
 * @property {string} content - Contenu de la scène
 * @property {string} synopsis - Synopsis de la scène
 * @property {string} status - Statut: 'draft', 'progress', 'complete', 'review'
 * @property {string} corkColor - Couleur de la carte: 'default', 'yellow', 'blue', 'green', 'red', 'purple'
 * @property {number} actId - ID de l'acte parent
 * @property {string} actTitle - Titre de l'acte parent
 * @property {number} chapterId - ID du chapitre parent
 * @property {string} chapterTitle - Titre du chapitre parent
 * @property {Array} characters - Personnages de la scène
 * @property {Array} locations - Lieux de la scène
 * @property {string} notes - Notes de la scène
 */

/**
 * Modèle de statut Kanban
 * @typedef {Object} KanbanStatus
 * @property {string} id - ID du statut
 * @property {string} label - Label affiché
 * @property {string} color - Couleur CSS du statut
 */

/**
 * Statuts disponibles pour la vue Kanban
 */
const CorkBoardModel = {
    /**
     * Statuts Kanban disponibles
     */
    KANBAN_STATUSES: [
        { id: 'draft', label: 'Brouillon', color: 'var(--accent-red)' },
        { id: 'progress', label: 'En cours', color: 'var(--accent-gold)' },
        { id: 'complete', label: 'Terminé', color: 'var(--accent-green)' },
        { id: 'review', label: 'À réviser', color: 'var(--accent-blue)' }
    ],

    /**
     * Couleurs disponibles pour les cartes Cork Board
     */
    CORK_COLORS: [
        'default',
        'yellow',
        'blue',
        'green',
        'red',
        'purple'
    ],

    /**
     * Modes d'affichage disponibles
     */
    DISPLAY_MODES: {
        STRUCTURED: 'structured',
        KANBAN: 'kanban'
    },

    /**
     * Types de filtres disponibles
     */
    FILTER_TYPES: {
        ALL: 'all',
        ACT: 'act',
        CHAPTER: 'chapter'
    },

    /**
     * Crée un nouveau filtre Cork Board
     * @param {string} type - Type de filtre
     * @param {number|null} actId - ID de l'acte
     * @param {number|null} chapterId - ID du chapitre
     * @param {string} mode - Mode d'affichage
     * @returns {CorkBoardFilter}
     */
    createFilter(type = 'all', actId = null, chapterId = null, mode = 'structured') {
        return {
            type,
            actId,
            chapterId,
            mode
        };
    },

    /**
     * Enrichit une scène avec les informations de contexte (acte, chapitre)
     * @param {Object} scene - Scène brute
     * @param {Object} act - Acte parent
     * @param {Object} chapter - Chapitre parent
     * @returns {CorkBoardScene}
     */
    enrichScene(scene, act, chapter) {
        return {
            ...scene,
            actId: act.id,
            actTitle: act.title,
            chapterId: chapter.id,
            chapterTitle: chapter.title
        };
    },

    /**
     * Valide un filtre Cork Board
     * @param {CorkBoardFilter} filter - Filtre à valider
     * @returns {boolean}
     */
    validateFilter(filter) {
        if (!filter || typeof filter !== 'object') return false;

        const validTypes = Object.values(this.FILTER_TYPES);
        if (!validTypes.includes(filter.type)) return false;

        const validModes = Object.values(this.DISPLAY_MODES);
        if (filter.mode && !validModes.includes(filter.mode)) return false;

        return true;
    },

    /**
     * Valide un statut de scène
     * @param {string} status - Statut à valider
     * @returns {boolean}
     */
    validateStatus(status) {
        const validStatuses = this.KANBAN_STATUSES.map(s => s.id);
        return validStatuses.includes(status);
    },

    /**
     * Valide une couleur de carte
     * @param {string} color - Couleur à valider
     * @returns {boolean}
     */
    validateColor(color) {
        return this.CORK_COLORS.includes(color);
    }
};

// ========== js-refactor/corkboard/corkboard.repository.js ==========
// ============================================
// CORKBOARD REPOSITORY
// ============================================
// Gère l'accès aux données et les opérations CRUD

const CorkBoardRepository = {
    /**
     * READ: Récupère toutes les scènes selon le filtre
     * @param {CorkBoardFilter} filter - Filtre à appliquer
     * @param {Object} project - Projet contenant les données
     * @returns {Array<CorkBoardScene>}
     */
    getFilteredScenes(filter, project) {
        if (!project || !project.acts) return [];

        const scenes = [];

        if (filter.type === CorkBoardModel.FILTER_TYPES.ALL) {
            // Toutes les scènes de tous les actes
            project.acts.forEach(act => {
                act.chapters.forEach(chapter => {
                    chapter.scenes.forEach(scene => {
                        scenes.push(CorkBoardModel.enrichScene(scene, act, chapter));
                    });
                });
            });
        } else if (filter.type === CorkBoardModel.FILTER_TYPES.ACT) {
            // Scènes d'un acte spécifique
            const act = this.getActById(filter.actId, project);
            if (act) {
                act.chapters.forEach(chapter => {
                    chapter.scenes.forEach(scene => {
                        scenes.push(CorkBoardModel.enrichScene(scene, act, chapter));
                    });
                });
            }
        } else if (filter.type === CorkBoardModel.FILTER_TYPES.CHAPTER) {
            // Scènes d'un chapitre spécifique
            const act = this.getActById(filter.actId, project);
            if (act) {
                const chapter = this.getChapterById(filter.chapterId, act);
                if (chapter) {
                    chapter.scenes.forEach(scene => {
                        scenes.push(CorkBoardModel.enrichScene(scene, act, chapter));
                    });
                }
            }
        }

        return scenes;
    },

    /**
     * READ: Récupère un acte par son ID
     * @param {number} actId - ID de l'acte
     * @param {Object} project - Projet
     * @returns {Object|null}
     */
    getActById(actId, project) {
        if (!project || !project.acts) return null;
        return project.acts.find(a => a.id === parseInt(actId)) || null;
    },

    /**
     * READ: Récupère un chapitre par son ID dans un acte
     * @param {number} chapterId - ID du chapitre
     * @param {Object} act - Acte parent
     * @returns {Object|null}
     */
    getChapterById(chapterId, act) {
        if (!act || !act.chapters) return null;
        return act.chapters.find(c => c.id === parseInt(chapterId)) || null;
    },

    /**
     * READ: Récupère une scène par son ID dans un chapitre
     * @param {number} sceneId - ID de la scène
     * @param {Object} chapter - Chapitre parent
     * @returns {Object|null}
     */
    getSceneById(sceneId, chapter) {
        if (!chapter || !chapter.scenes) return null;
        return chapter.scenes.find(s => s.id === parseInt(sceneId)) || null;
    },

    /**
     * READ: Récupère les chapitres d'un acte
     * @param {number} actId - ID de l'acte
     * @param {Object} project - Projet
     * @returns {Array}
     */
    getChaptersByActId(actId, project) {
        const act = this.getActById(actId, project);
        return act ? act.chapters : [];
    },

    /**
     * UPDATE: Met à jour le synopsis d'une scène
     * @param {number} actId - ID de l'acte
     * @param {number} chapterId - ID du chapitre
     * @param {number} sceneId - ID de la scène
     * @param {string} synopsis - Nouveau synopsis
     * @param {Object} project - Projet
     * @returns {boolean} - Succès de l'opération
     */
    updateSceneSynopsis(actId, chapterId, sceneId, synopsis, project) {
        const act = this.getActById(actId, project);
        if (!act) return false;

        const chapter = this.getChapterById(chapterId, act);
        if (!chapter) return false;

        const scene = this.getSceneById(sceneId, chapter);
        if (!scene) return false;

        scene.synopsis = synopsis;
        return true;
    },

    /**
     * UPDATE: Met à jour la couleur d'une scène
     * @param {number} actId - ID de l'acte
     * @param {number} chapterId - ID du chapitre
     * @param {number} sceneId - ID de la scène
     * @param {string} color - Nouvelle couleur
     * @param {Object} project - Projet
     * @returns {boolean} - Succès de l'opération
     */
    updateSceneColor(actId, chapterId, sceneId, color, project) {
        if (!CorkBoardModel.validateColor(color)) return false;

        const act = this.getActById(actId, project);
        if (!act) return false;

        const chapter = this.getChapterById(chapterId, act);
        if (!chapter) return false;

        const scene = this.getSceneById(sceneId, chapter);
        if (!scene) return false;

        scene.corkColor = color;
        return true;
    },

    /**
     * UPDATE: Réorganise les scènes dans un chapitre
     * @param {number} actId - ID de l'acte
     * @param {number} chapterId - ID du chapitre
     * @param {number} fromIndex - Index source
     * @param {number} toIndex - Index destination
     * @param {Object} project - Projet
     * @returns {boolean} - Succès de l'opération
     */
    reorderScenes(actId, chapterId, fromIndex, toIndex, project) {
        const act = this.getActById(actId, project);
        if (!act) return false;

        const chapter = this.getChapterById(chapterId, act);
        if (!chapter) return false;

        if (fromIndex < 0 || fromIndex >= chapter.scenes.length) return false;
        if (toIndex < 0 || toIndex >= chapter.scenes.length) return false;

        const [movedScene] = chapter.scenes.splice(fromIndex, 1);
        chapter.scenes.splice(toIndex, 0, movedScene);

        return true;
    },

    /**
     * CREATE: Crée un nouvel acte
     * @param {string} title - Titre de l'acte
     * @param {Object} project - Projet
     * @returns {Object|null} - Nouvel acte créé
     */
    createAct(title, project) {
        if (!project || !project.acts) return null;
        if (!title || title.trim() === '') return null;

        const newAct = {
            id: Date.now(),
            title: title.trim(),
            chapters: []
        };

        project.acts.push(newAct);
        return newAct;
    },

    /**
     * CREATE: Crée un nouveau chapitre dans un acte
     * @param {number} actId - ID de l'acte
     * @param {string} title - Titre du chapitre
     * @param {Object} project - Projet
     * @returns {Object|null} - Nouveau chapitre créé
     */
    createChapter(actId, title, project) {
        const act = this.getActById(actId, project);
        if (!act) return null;
        if (!title || title.trim() === '') return null;

        const newChapter = {
            id: Date.now(),
            title: title.trim(),
            scenes: []
        };

        act.chapters.push(newChapter);
        return newChapter;
    },

    /**
     * CREATE: Crée une nouvelle scène dans un chapitre
     * @param {number} actId - ID de l'acte
     * @param {number} chapterId - ID du chapitre
     * @param {string} title - Titre de la scène
     * @param {Object} project - Projet
     * @returns {Object|null} - Nouvelle scène créée
     */
    createScene(actId, chapterId, title, project) {
        const act = this.getActById(actId, project);
        if (!act) return null;

        const chapter = this.getChapterById(chapterId, act);
        if (!chapter) return null;
        if (!title || title.trim() === '') return null;

        const newScene = {
            id: Date.now(),
            title: title.trim(),
            content: '',
            synopsis: '',
            status: 'draft',
            characters: [],
            locations: [],
            notes: ''
        };

        chapter.scenes.push(newScene);
        return newScene;
    },

    /**
     * READ: Récupère les scènes par statut (pour vue Kanban)
     * @param {Array<CorkBoardScene>} scenes - Scènes à filtrer
     * @param {string} status - Statut recherché
     * @returns {Array<CorkBoardScene>}
     */
    getScenesByStatus(scenes, status) {
        return scenes.filter(s => (s.status || 'draft') === status);
    },

    /**
     * READ: Compte le nombre total de chapitres dans le projet
     * @param {Object} project - Projet
     * @returns {number}
     */
    getTotalChaptersCount(project) {
        if (!project || !project.acts) return 0;
        return project.acts.reduce((sum, act) => sum + act.chapters.length, 0);
    }
};

// ========== js-refactor/corkboard/corkboard.viewmodel.js ==========
// ============================================
// CORKBOARD VIEWMODEL
// ============================================
// Gère la logique métier et coordonne Model, Repository et View

const CorkBoardViewModel = {
    /**
     * Filtre actuel du Cork Board (état global)
     */
    currentFilter: null,

    /**
     * Initialise le ViewModel avec un filtre par défaut
     */
    init() {
        if (!this.currentFilter) {
            this.currentFilter = CorkBoardModel.createFilter('all', null, null, 'structured');
        }
    },

    /**
     * Met à jour le filtre par acte
     * @param {string|number} actId - ID de l'acte ou 'all'
     */
    updateActFilter(actId) {
        if (actId === 'all') {
            this.currentFilter = CorkBoardModel.createFilter('all', null, null, this.currentFilter.mode);
        } else {
            this.currentFilter = CorkBoardModel.createFilter('act', parseInt(actId), null, this.currentFilter.mode);
        }
    },

    /**
     * Met à jour le filtre par chapitre
     * @param {string|number} chapterId - ID du chapitre ou 'all'
     */
    updateChapterFilter(chapterId) {
        if (chapterId === 'all') {
            this.currentFilter.type = 'act';
            this.currentFilter.chapterId = null;
        } else {
            this.currentFilter.type = 'chapter';
            this.currentFilter.chapterId = parseInt(chapterId);
        }
    },

    /**
     * Change le mode d'affichage (structured/kanban)
     * @param {string} mode - Nouveau mode
     */
    switchMode(mode) {
        if (Object.values(CorkBoardModel.DISPLAY_MODES).includes(mode)) {
            this.currentFilter.mode = mode;
        }
    },

    /**
     * Récupère le filtre actuel
     * @returns {CorkBoardFilter}
     */
    getCurrentFilter() {
        if (!this.currentFilter) {
            this.init();
        }
        return this.currentFilter;
    },

    /**
     * Récupère les scènes filtrées pour l'affichage
     * @returns {Array<CorkBoardScene>}
     */
    getFilteredScenes() {
        if (!this.currentFilter) {
            this.init();
        }
        return CorkBoardRepository.getFilteredScenes(this.currentFilter, project);
    },

    /**
     * Récupère les chapitres d'un acte pour le sélecteur
     * @param {number} actId - ID de l'acte
     * @returns {Array}
     */
    getChaptersForSelector(actId) {
        return CorkBoardRepository.getChaptersByActId(actId, project);
    },

    /**
     * Met à jour le synopsis d'une scène
     * @param {number} actId - ID de l'acte
     * @param {number} chapterId - ID du chapitre
     * @param {number} sceneId - ID de la scène
     * @param {string} synopsis - Nouveau synopsis
     * @returns {boolean}
     */
    updateSceneSynopsis(actId, chapterId, sceneId, synopsis) {
        const success = CorkBoardRepository.updateSceneSynopsis(
            actId, chapterId, sceneId, synopsis, project
        );

        if (success && typeof saveProject === 'function') {
            saveProject();
        }

        return success;
    },

    /**
     * Met à jour la couleur d'une scène
     * @param {number} actId - ID de l'acte
     * @param {number} chapterId - ID du chapitre
     * @param {number} sceneId - ID de la scène
     * @param {string} color - Nouvelle couleur
     * @returns {boolean}
     */
    updateSceneColor(actId, chapterId, sceneId, color) {
        const success = CorkBoardRepository.updateSceneColor(
            actId, chapterId, sceneId, color, project
        );

        if (success && typeof saveProject === 'function') {
            saveProject();
        }

        return success;
    },

    /**
     * Gère le drag & drop de scènes
     * @param {number} draggedSceneId - ID de la scène déplacée
     * @param {number} draggedActId - ID de l'acte source
     * @param {number} draggedChapterId - ID du chapitre source
     * @param {number} targetSceneId - ID de la scène cible
     * @param {number} targetActId - ID de l'acte cible
     * @param {number} targetChapterId - ID du chapitre cible
     * @returns {Object} - {success: boolean, message: string}
     */
    handleSceneDrop(draggedSceneId, draggedActId, draggedChapterId, targetSceneId, targetActId, targetChapterId) {
        // Vérifier qu'on est dans le même chapitre
        if (draggedChapterId !== targetChapterId) {
            return {
                success: false,
                message: 'Vous ne pouvez déplacer des scènes que dans le même chapitre.\n\nPour déplacer entre chapitres, utilisez la vue Structure (sidebar).'
            };
        }

        // Trouver les index
        const act = CorkBoardRepository.getActById(draggedActId, project);
        if (!act) return { success: false, message: 'Acte introuvable' };

        const chapter = CorkBoardRepository.getChapterById(draggedChapterId, act);
        if (!chapter) return { success: false, message: 'Chapitre introuvable' };

        const draggedSceneIndex = chapter.scenes.findIndex(s => s.id === draggedSceneId);
        const targetSceneIndex = chapter.scenes.findIndex(s => s.id === targetSceneId);

        if (draggedSceneIndex === -1 || targetSceneIndex === -1) {
            return { success: false, message: 'Scène introuvable' };
        }

        // Réorganiser
        const success = CorkBoardRepository.reorderScenes(
            draggedActId, draggedChapterId, draggedSceneIndex, targetSceneIndex, project
        );

        if (success) {
            if (typeof saveProject === 'function') saveProject();
            if (typeof renderActsList === 'function') renderActsList();
            return { success: true, message: '✓ Scènes réorganisées' };
        }

        return { success: false, message: 'Erreur lors de la réorganisation' };
    },

    /**
     * Crée un nouvel acte
     * @param {string} title - Titre de l'acte
     * @returns {Object} - {success: boolean, act: Object|null, message: string}
     */
    createAct(title) {
        if (!title || title.trim() === '') {
            return { success: false, act: null, message: 'Le titre ne peut pas être vide' };
        }

        const newAct = CorkBoardRepository.createAct(title, project);

        if (newAct) {
            if (typeof saveProject === 'function') saveProject();
            if (typeof renderActsList === 'function') renderActsList();
            return { success: true, act: newAct, message: `✓ Acte "${title}" créé` };
        }

        return { success: false, act: null, message: 'Erreur lors de la création de l\'acte' };
    },

    /**
     * Crée un nouveau chapitre
     * @param {number} actId - ID de l'acte
     * @param {string} title - Titre du chapitre
     * @returns {Object} - {success: boolean, chapter: Object|null, message: string}
     */
    createChapter(actId, title) {
        if (!title || title.trim() === '') {
            return { success: false, chapter: null, message: 'Le titre ne peut pas être vide' };
        }

        const newChapter = CorkBoardRepository.createChapter(actId, title, project);

        if (newChapter) {
            if (typeof saveProject === 'function') saveProject();
            if (typeof renderActsList === 'function') renderActsList();
            return { success: true, chapter: newChapter, message: `✓ Chapitre "${title}" créé` };
        }

        return { success: false, chapter: null, message: 'Erreur lors de la création du chapitre' };
    },

    /**
     * Crée une nouvelle scène
     * @param {number} actId - ID de l'acte
     * @param {number} chapterId - ID du chapitre
     * @param {string} title - Titre de la scène
     * @returns {Object} - {success: boolean, scene: Object|null, message: string}
     */
    createScene(actId, chapterId, title) {
        if (!title || title.trim() === '') {
            return { success: false, scene: null, message: 'Le titre ne peut pas être vide' };
        }

        const newScene = CorkBoardRepository.createScene(actId, chapterId, title, project);

        if (newScene) {
            if (typeof saveProject === 'function') saveProject();
            if (typeof renderActsList === 'function') renderActsList();
            return { success: true, scene: newScene, message: `✓ Scène "${title}" créée` };
        }

        return { success: false, scene: null, message: 'Erreur lors de la création de la scène' };
    },

    /**
     * Ouvre une scène dans l'éditeur
     * @param {number} actId - ID de l'acte
     * @param {number} chapterId - ID du chapitre
     * @param {number} sceneId - ID de la scène
     */
    openSceneInEditor(actId, chapterId, sceneId) {
        if (typeof switchView === 'function') {
            switchView('editor');
        }
        if (typeof openScene === 'function') {
            openScene(actId, chapterId, sceneId);
        }
    },

    /**
     * Vérifie si le projet est vide
     * @returns {boolean}
     */
    isProjectEmpty() {
        if (!project || !project.acts || project.acts.length === 0) return true;
        if (project.acts.length === 1 && project.acts[0].chapters.length === 0) return true;
        return false;
    },

    /**
     * Récupère le nombre total de chapitres
     * @returns {number}
     */
    getTotalChaptersCount() {
        return CorkBoardRepository.getTotalChaptersCount(project);
    },

    /**
     * Récupère les scènes par statut pour la vue Kanban
     * @param {string} status - Statut recherché
     * @returns {Array<CorkBoardScene>}
     */
    getScenesByStatus(status) {
        const allScenes = this.getFilteredScenes();
        return CorkBoardRepository.getScenesByStatus(allScenes, status);
    }
};

// ========== js-refactor/corkboard/corkboard.view.js ==========
// ============================================
// CORKBOARD VIEW
// ============================================
// Gère le rendu HTML et les interactions utilisateur

const CorkBoardView = {
    /**
     * Rend le panneau latéral du Cork Board (sélecteur de filtres)
     */
    renderSidebar() {
        const container = document.getElementById('corkboardList');
        if (!container) return;

        const filter = CorkBoardViewModel.getCurrentFilter();

        // Construire les options de chapitres
        let chaptersOptions = '';
        if (filter.actId) {
            const chapters = CorkBoardViewModel.getChaptersForSelector(filter.actId);
            chaptersOptions = chapters.map(ch =>
                `<option value="${ch.id}" ${filter.chapterId == ch.id ? 'selected' : ''}>${ch.title}</option>`
            ).join('');
        }

        container.innerHTML = `
            <div style="padding: 1.5rem;">
                <div style="margin-bottom: 1.5rem;">
                    <h3 style="margin-bottom: 0.5rem;"><i data-lucide="layout-grid" style="width:18px;height:18px;vertical-align:middle;margin-right:6px;"></i>Tableau Cork Board</h3>
                    <p style="font-size: 0.85rem; color: var(--text-muted);">
                        Organisez vos scènes visuellement
                    </p>
                </div>
                
                <div style="margin-bottom: 1rem;">
                    <label style="font-size: 0.85rem; color: var(--text-muted); display: block; margin-bottom: 0.5rem;">
                        Filtrer par acte :
                    </label>
                    <select id="corkActFilter" class="form-input" onchange="CorkBoardHandlers.onActFilterChange(this.value)">
                        <option value="all" ${filter.type === 'all' ? 'selected' : ''}>Tous les actes</option>
                        ${project.acts.map(act =>
            `<option value="${act.id}" ${filter.actId == act.id ? 'selected' : ''}>${act.title}</option>`
        ).join('')}
                    </select>
                </div>
                
                ${filter.actId ? `
                    <div style="margin-bottom: 1rem;">
                        <label style="font-size: 0.85rem; color: var(--text-muted); display: block; margin-bottom: 0.5rem;">
                            Filtrer par chapitre :
                        </label>
                        <select id="corkChapterFilter" class="form-input" onchange="CorkBoardHandlers.onChapterFilterChange(this.value)">
                            <option value="all">Tous les chapitres de cet acte</option>
                            ${chaptersOptions}
                        </select>
                    </div>
                ` : ''}
                
                <button class="btn btn-primary" style="width: 100%;" onclick="CorkBoardHandlers.onOpenFullView()">
                    Ouvrir le tableau
                </button>
            </div>
        `;
    },

    /**
     * Rend la vue complète du Cork Board
     * @returns {string} - HTML de la vue complète
     */
    renderFullView() {
        // Vérifier si le projet est vide
        if (CorkBoardViewModel.isProjectEmpty()) {
            return this.renderEmptyState();
        }

        const filter = CorkBoardViewModel.getCurrentFilter();

        // Vue Kanban
        if (filter.mode === CorkBoardModel.DISPLAY_MODES.KANBAN) {
            return this.renderKanbanView();
        }

        // Vue structurée
        return this.renderStructuredView();
    },

    /**
     * Rend l'état vide (pas de chapitres)
     * @returns {string}
     */
    renderEmptyState() {
        return `
            <div class="cork-board-container">
                <div class="cork-board-header">
                    <div class="cork-board-title"><i data-lucide="layout-grid" style="width:16px;height:16px;vertical-align:middle;margin-right:6px;"></i>Cork Board</div>
                    <button class="btn btn-primary" onclick="CorkBoardHandlers.onClose()">← Retour</button>
                </div>
                <div class="cork-board-empty">
                    <div class="cork-board-empty-icon"><i data-lucide="layout-grid" style="width:48px;height:48px;"></i></div>
                    <div style="font-size: 1.2rem; margin-bottom: 0.5rem;">Aucun chapitre</div>
                    <div style="margin-bottom: 1rem;">Créez votre premier chapitre pour commencer à structurer votre histoire</div>
                    <button class="btn btn-primary" onclick="openAddChapterModal()">+ Créer un chapitre</button>
                </div>
            </div>
        `;
    },

    /**
     * Rend la vue structurée (par actes et chapitres)
     * @returns {string}
     */
    renderStructuredView() {
        const filter = CorkBoardViewModel.getCurrentFilter();
        const scenes = CorkBoardViewModel.getFilteredScenes();

        let html = `
            <div class="cork-board-container" style="min-height: 100vh; padding: 2rem;">
                ${this.renderHeader('structured')}
                
                <div style="display: flex; flex-direction: column; gap: 2rem;">
        `;

        // Générer les actes
        project.acts.forEach(act => {
            const actScenes = scenes.filter(s => s.actId === act.id);

            html += `
                <div class="structured-act-container">
                    <div class="structured-act-header">
                        <button class="structured-collapse-btn" onclick="CorkBoardHandlers.onToggleAct(${act.id})">
                            <span class="collapse-icon" id="collapse-icon-${act.id}"><i data-lucide="chevron-down" style="width:16px;height:16px;"></i></span>
                        </button>
                        <span class="structured-act-title">${act.title}</span>
                        <button class="btn btn-primary" onclick="CorkBoardHandlers.onCreateChapter(${act.id})">+ Nouveau Chapitre</button>
                        <span class="structured-count">${act.chapters.length} chapitre${act.chapters.length > 1 ? 's' : ''}</span>
                    </div>
                    
                    <div class="structured-chapters-grid" id="act-content-${act.id}">
            `;

            // Générer les chapitres de l'acte
            act.chapters.forEach(chapter => {
                const chapterScenes = actScenes.filter(s => s.chapterId === chapter.id);

                html += `
                    <div class="structured-chapter-container">
                        <div class="structured-chapter-header">
                            <div style="display: flex; align-items: center; gap: 0.5rem;">
                                <span class="structured-chapter-icon"><i data-lucide="grip-vertical" style="width:14px;height:14px;"></i></span>
                                <span class="structured-chapter-title">${chapter.title}</span>
                            </div>
                        </div>
                        
                        <div class="structured-scenes-list">
                `;

                // Générer les scènes du chapitre
                chapterScenes.forEach(scene => {
                    html += this.renderSceneCard(scene, 'structured');
                });

                // Bouton + Nouvelle Scène
                html += `
                            <button class="structured-add-scene-btn" onclick="CorkBoardHandlers.onCreateScene(${act.id}, ${chapter.id})">
                                <span style="font-size: 1.2rem;">+</span> Nouvelle Scène
                            </button>
                        </div>
                    </div>
                `;
            });

            // Si l'acte n'a pas de chapitres
            if (act.chapters.length === 0) {
                html += `
                    <div style="padding: 2rem; text-align: center; color: var(--text-muted); opacity: 0.7; font-style: italic;">
                        Cet acte est vide. Cliquez sur "+ Nouveau Chapitre" pour commencer.
                    </div>
                `;
            }

            html += `
                    </div>
                </div>
            `;
        });

        html += `
                </div>
                
                <div class="structured-bottom-actions">
                    <button class="btn btn-primary" onclick="CorkBoardHandlers.onCreateAct()">+ Ajouter un Acte</button>
                </div>
            </div>
        `;

        return html;
    },

    /**
     * Rend la vue Kanban (par statut)
     * @returns {string}
     */
    renderKanbanView() {
        const scenes = CorkBoardViewModel.getFilteredScenes();

        let html = `
            <div class="cork-board-container" style="min-height: 100vh; padding: 2rem;">
                ${this.renderHeader('kanban')}

                <div class="kanban-grid" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 1.5rem; align-items: start;">
        `;

        CorkBoardModel.KANBAN_STATUSES.forEach(status => {
            const statusScenes = CorkBoardViewModel.getScenesByStatus(status.id);

            html += `
                <div class="kanban-column" style="background: var(--bg-secondary); border-radius: 8px; border: 1px solid var(--border-color); display: flex; flex-direction: column; min-height: 500px;">
                    <div class="kanban-column-header" style="padding: 1rem; border-bottom: 2px solid ${status.color}; display: flex; justify-content: space-between; align-items: center;">
                        <span style="font-weight: 700; color: var(--text-primary);">${status.label}</span>
                        <span style="background: ${status.color}; color: white; font-size: 0.75rem; padding: 2px 8px; border-radius: 10px;">${statusScenes.length}</span>
                    </div>
                    <div class="kanban-scenes-list" style="padding: 1rem; display: flex; flex-direction: column; gap: 1rem; flex: 1;">
            `;

            statusScenes.forEach(scene => {
                html += this.renderSceneCard(scene, 'kanban', status.id);
            });

            if (statusScenes.length === 0) {
                html += `
                    <div style="padding: 2rem; text-align: center; color: var(--text-muted); font-size: 0.8rem; font-style: italic;">
                        Aucune scène
                    </div>
                `;
            }

            html += `
                    </div>
                </div>
            `;
        });

        html += `
                </div>
            </div>
        `;

        return html;
    },

    /**
     * Rend l'en-tête du Cork Board
     * @param {string} currentMode - Mode actuel ('structured' ou 'kanban')
     * @returns {string}
     */
    renderHeader(currentMode) {
        const isStructured = currentMode === 'structured';
        const titleIcon = isStructured ? 'list' : 'columns';
        const titleText = isStructured ? 'Vue Structure' : 'Vue Kanban';

        return `
            <div class="cork-board-header" style="margin-bottom: 2rem;">
                <div class="cork-board-title" style="width: 250px; flex-shrink: 0;">
                    <i data-lucide="${titleIcon}" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>${titleText}
                </div>

                <div style="display: flex; background: var(--bg-secondary); padding: 4px; border-radius: 8px;">
                    <button class="btn ${isStructured ? 'btn-primary' : 'btn-small'}" onclick="CorkBoardHandlers.onSwitchMode('structured')">Structure</button>
                    <button class="btn ${!isStructured ? 'btn-primary' : 'btn-small'}" onclick="CorkBoardHandlers.onSwitchMode('kanban')">Kanban</button>
                </div>
                
                <div style="display: flex; align-items: center; gap: 1rem; margin-left: auto; ${isStructured ? '' : 'visibility: hidden;'}">
                    <label style="font-size: 0.8rem; color: var(--text-muted); display: flex; align-items: center; gap: 0.5rem;">
                        <i data-lucide="zoom-in" style="width:16px;height:16px;"></i>
                        <input type="range" 
                               min="150" 
                               max="800" 
                               value="300" 
                               step="10"
                               style="width: 120px; cursor: pointer;"
                               oninput="CorkBoardHandlers.onUpdateGridSize(this.value)"
                               title="Ajuster la largeur des colonnes">
                    </label>
                </div>
            </div>
        `;
    },

    /**
     * Rend une carte de scène
     * @param {CorkBoardScene} scene - Scène à afficher
     * @param {string} viewType - Type de vue ('structured' ou 'kanban')
     * @param {string} statusId - ID du statut (pour Kanban)
     * @returns {string}
     */
    renderSceneCard(scene, viewType, statusId = null) {
        const synopsis = scene.synopsis || '';
        const wordCount = scene.content ? scene.content.split(/\s+/).filter(w => w.length > 0).length : 0;
        const color = scene.corkColor || 'default';
        const status = statusId || scene.status || 'draft';

        if (viewType === 'kanban') {
            return `
                <div class="structured-scene-card scene-status-${status}" 
                     data-scene-id="${scene.id}"
                     data-act-id="${scene.actId}"
                     data-chapter-id="${scene.chapterId}"
                     onclick="CorkBoardHandlers.onOpenScene(${scene.actId}, ${scene.chapterId}, ${scene.id})"
                     style="background: var(--bg-primary); border-radius: 6px; box-shadow: 0 2px 4px var(--shadow);">
                    <div style="font-size: 0.7rem; color: var(--text-muted); margin-bottom: 0.25rem;">${scene.actTitle} > ${scene.chapterTitle}</div>
                    <div style="font-weight: 600; font-size: 0.9rem; margin-bottom: 0.5rem;">${scene.title}</div>
                    ${synopsis ? `<div style="font-size: 0.8rem; color: var(--text-secondary); line-height: 1.4; display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical; overflow: hidden;">${synopsis}</div>` : ''}
                    <div style="font-size: 0.7rem; color: var(--text-muted); margin-top: 0.5rem; display: flex; justify-content: space-between;">
                        <span>${wordCount} mots</span>
                    </div>
                </div>
            `;
        }

        // Vue structurée
        return `
            <div class="structured-scene-card structured-color-${color} scene-status-${status}" 
                 data-scene-id="${scene.id}"
                 data-act-id="${scene.actId}"
                 data-chapter-id="${scene.chapterId}"
                 draggable="true"
                 onclick="CorkBoardHandlers.onOpenScene(${scene.actId}, ${scene.chapterId}, ${scene.id})">
                <div class="structured-scene-header">
                    <span class="structured-scene-icon"><i data-lucide="grip-vertical" style="width:14px;height:14px;"></i></span>
                    <span class="structured-scene-title">${scene.title}</span>
                </div>
                
                <div class="structured-scene-synopsis" 
                     contenteditable="true"
                     onclick="event.stopPropagation()"
                     onblur="CorkBoardHandlers.onUpdateSynopsis(${scene.actId}, ${scene.chapterId}, ${scene.id}, this.innerText)"
                     data-placeholder="Ajouter un résumé...">${synopsis}</div>
                
                <div class="structured-scene-meta" style="font-size: 0.75rem; color: var(--text-muted); margin-top: 0.5rem;">
                    ${wordCount} mots
                </div>
            </div>
        `;
    },

    /**
     * Affiche une notification temporaire
     * @param {string} message - Message à afficher
     */
    showNotification(message) {
        const notif = document.createElement('div');
        notif.style.cssText = `
            position: fixed;
            top: 2rem;
            right: 2rem;
            background: var(--accent-gold);
            color: white;
            padding: 1rem 2rem;
            border-radius: 4px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            z-index: 10000;
            font-weight: 600;
            animation: slideIn 0.3s ease;
        `;
        notif.textContent = message;
        document.body.appendChild(notif);

        setTimeout(() => {
            notif.style.animation = 'slideOut 0.3s ease';
            setTimeout(() => notif.remove(), 300);
        }, 2000);
    },

    /**
     * Met à jour dynamiquement la taille de la grille
     * @param {number} value - Nouvelle largeur en pixels
     */
    updateGridSize(value) {
        document.documentElement.style.setProperty('--chapter-card-width', value + 'px');

        const label = document.getElementById('gridSizeLabel');
        if (label) label.textContent = value + 'px';
    }
};

// ========== js-refactor/corkboard/corkboard.handlers.js ==========
// ============================================
// CORKBOARD HANDLERS
// ============================================
// Gère les événements utilisateur et le drag & drop

const CorkBoardHandlers = {
    /**
     * État du drag & drop
     */
    draggedCard: null,

    /**
     * Gestionnaire: Changement du filtre par acte
     * @param {string} actId - ID de l'acte ou 'all'
     */
    onActFilterChange(actId) {
        CorkBoardViewModel.updateActFilter(actId);
        CorkBoardView.renderSidebar();
    },

    /**
     * Gestionnaire: Changement du filtre par chapitre
     * @param {string} chapterId - ID du chapitre ou 'all'
     */
    onChapterFilterChange(chapterId) {
        CorkBoardViewModel.updateChapterFilter(chapterId);
        CorkBoardView.renderSidebar();
    },

    /**
     * Gestionnaire: Ouverture de la vue complète
     */
    onOpenFullView() {
        const editorView = document.getElementById('editorView');
        if (!editorView) return;

        editorView.innerHTML = CorkBoardView.renderFullView();
        this.setupDragAndDrop();

        if (typeof lucide !== 'undefined') lucide.createIcons();
    },

    /**
     * Gestionnaire: Fermeture de la vue Cork Board
     */
    onClose() {
        if (typeof switchView === 'function') {
            switchView('corkboard');
        }
        CorkBoardView.renderSidebar();
    },

    /**
     * Gestionnaire: Changement de mode (structured/kanban)
     * @param {string} mode - Nouveau mode
     */
    onSwitchMode(mode) {
        CorkBoardViewModel.switchMode(mode);
        this.onOpenFullView();
    },

    /**
     * Gestionnaire: Toggle d'un acte (expand/collapse)
     * @param {number} actId - ID de l'acte
     */
    onToggleAct(actId) {
        const content = document.getElementById(`act-content-${actId}`);
        const icon = document.getElementById(`collapse-icon-${actId}`);

        if (!content || !icon) return;

        if (content.style.display === 'none') {
            content.style.display = 'grid';
            icon.innerHTML = '<i data-lucide="chevron-down" style="width:16px;height:16px;"></i>';
        } else {
            content.style.display = 'none';
            icon.innerHTML = '<i data-lucide="chevron-right" style="width:16px;height:16px;"></i>';
        }

        if (typeof lucide !== 'undefined') lucide.createIcons();
    },

    /**
     * Gestionnaire: Mise à jour du synopsis d'une scène
     * @param {number} actId - ID de l'acte
     * @param {number} chapterId - ID du chapitre
     * @param {number} sceneId - ID de la scène
     * @param {string} synopsis - Nouveau synopsis
     */
    onUpdateSynopsis(actId, chapterId, sceneId, synopsis) {
        CorkBoardViewModel.updateSceneSynopsis(actId, chapterId, sceneId, synopsis);
    },

    /**
     * Gestionnaire: Mise à jour de la couleur d'une scène
     * @param {number} actId - ID de l'acte
     * @param {number} chapterId - ID du chapitre
     * @param {number} sceneId - ID de la scène
     * @param {string} color - Nouvelle couleur
     */
    onUpdateColor(actId, chapterId, sceneId, color) {
        const success = CorkBoardViewModel.updateSceneColor(actId, chapterId, sceneId, color);
        if (success) {
            this.onOpenFullView();
        }
    },

    /**
     * Gestionnaire: Ouverture d'une scène dans l'éditeur
     * @param {number} actId - ID de l'acte
     * @param {number} chapterId - ID du chapitre
     * @param {number} sceneId - ID de la scène
     */
    onOpenScene(actId, chapterId, sceneId) {
        CorkBoardViewModel.openSceneInEditor(actId, chapterId, sceneId);
    },

    /**
     * Gestionnaire: Création d'un nouvel acte
     */
    onCreateAct() {
        const actTitle = prompt('Nom du nouvel acte:', `Acte ${project.acts.length + 1}`);
        if (!actTitle || actTitle.trim() === '') return;

        const result = CorkBoardViewModel.createAct(actTitle);
        if (result.success) {
            this.onOpenFullView();
            CorkBoardView.showNotification(result.message);
        } else {
            alert(result.message);
        }
    },

    /**
     * Gestionnaire: Création d'un nouveau chapitre
     * @param {number} actId - ID de l'acte
     */
    onCreateChapter(actId) {
        const act = CorkBoardRepository.getActById(actId, project);
        if (!act) return;

        const chapterTitle = prompt('Nom du nouveau chapitre:', `Chapitre ${act.chapters.length + 1}`);
        if (!chapterTitle || chapterTitle.trim() === '') return;

        const result = CorkBoardViewModel.createChapter(actId, chapterTitle);
        if (result.success) {
            this.onOpenFullView();
            CorkBoardView.showNotification(result.message);
        } else {
            alert(result.message);
        }
    },

    /**
     * Gestionnaire: Création d'une nouvelle scène
     * @param {number} actId - ID de l'acte
     * @param {number} chapterId - ID du chapitre
     */
    onCreateScene(actId, chapterId) {
        const act = CorkBoardRepository.getActById(actId, project);
        if (!act) return;

        const chapter = CorkBoardRepository.getChapterById(chapterId, act);
        if (!chapter) return;

        const sceneTitle = prompt('Nom de la nouvelle scène:', `Scène ${chapter.scenes.length + 1}`);
        if (!sceneTitle || sceneTitle.trim() === '') return;

        const result = CorkBoardViewModel.createScene(actId, chapterId, sceneTitle);
        if (result.success) {
            this.onOpenFullView();
            CorkBoardView.showNotification(result.message);
        } else {
            alert(result.message);
        }
    },

    /**
     * Gestionnaire: Mise à jour de la taille de la grille
     * @param {number} value - Nouvelle largeur
     */
    onUpdateGridSize(value) {
        CorkBoardView.updateGridSize(value);
    },

    /**
     * Configure le drag & drop pour les cartes de scènes
     */
    setupDragAndDrop() {
        const cards = document.querySelectorAll('.cork-card, .structured-scene-card');

        cards.forEach(card => {
            card.addEventListener('dragstart', this.handleDragStart.bind(this));
            card.addEventListener('dragend', this.handleDragEnd.bind(this));
            card.addEventListener('dragover', this.handleDragOver.bind(this));
            card.addEventListener('drop', this.handleDrop.bind(this));
        });
    },

    /**
     * Gestionnaire: Début du drag
     * @param {DragEvent} e - Événement drag
     */
    handleDragStart(e) {
        this.draggedCard = e.currentTarget;
        e.currentTarget.classList.add('dragging');
        e.dataTransfer.effectAllowed = 'move';
    },

    /**
     * Gestionnaire: Fin du drag
     * @param {DragEvent} e - Événement drag
     */
    handleDragEnd(e) {
        e.currentTarget.classList.remove('dragging');
        this.draggedCard = null;
    },

    /**
     * Gestionnaire: Survol pendant le drag
     * @param {DragEvent} e - Événement drag
     */
    handleDragOver(e) {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
    },

    /**
     * Gestionnaire: Drop de la carte
     * @param {DragEvent} e - Événement drop
     */
    handleDrop(e) {
        e.preventDefault();

        if (!this.draggedCard || this.draggedCard === e.currentTarget) return;

        // Récupérer les IDs
        const draggedSceneId = parseInt(this.draggedCard.dataset.sceneId);
        const draggedActId = parseInt(this.draggedCard.dataset.actId);
        const draggedChapterId = parseInt(this.draggedCard.dataset.chapterId);

        const targetSceneId = parseInt(e.currentTarget.dataset.sceneId);
        const targetActId = parseInt(e.currentTarget.dataset.actId);
        const targetChapterId = parseInt(e.currentTarget.dataset.chapterId);

        // Gérer le drop via le ViewModel
        const result = CorkBoardViewModel.handleSceneDrop(
            draggedSceneId, draggedActId, draggedChapterId,
            targetSceneId, targetActId, targetChapterId
        );

        if (result.success) {
            this.onOpenFullView();
            CorkBoardView.showNotification(result.message);
        } else {
            alert(result.message);
        }
    }
};

// ========== js-refactor/corkboard/corkboard.main.js ==========
// ============================================
// CORKBOARD MAIN
// ============================================
// Point d'entrée principal et compatibilité avec l'ancienne API

/**
 * Initialise le module Cork Board
 */
function initCorkBoard() {
    CorkBoardViewModel.init();
}

// ============================================
// FONCTIONS DE COMPATIBILITÉ (Ancienne API)
// ============================================
// Ces fonctions maintiennent la compatibilité avec le code existant

/**
 * @deprecated Utiliser CorkBoardView.renderSidebar()
 */
function renderCorkBoard() {
    CorkBoardView.renderSidebar();
}

/**
 * @deprecated Utiliser CorkBoardHandlers.onActFilterChange()
 */
function updateCorkActFilter(actId) {
    CorkBoardHandlers.onActFilterChange(actId);
}

/**
 * @deprecated Utiliser CorkBoardHandlers.onChapterFilterChange()
 */
function updateCorkChapterFilter(chapterId) {
    CorkBoardHandlers.onChapterFilterChange(chapterId);
}

/**
 * @deprecated Utiliser CorkBoardHandlers.onOpenFullView()
 */
function openCorkBoardView() {
    CorkBoardHandlers.onOpenFullView();
}

/**
 * @deprecated Utiliser CorkBoardHandlers.onClose()
 */
function closeCorkBoardView() {
    CorkBoardHandlers.onClose();
}

/**
 * @deprecated Utiliser CorkBoardHandlers.onSwitchMode()
 */
function switchCorkMode(mode) {
    CorkBoardHandlers.onSwitchMode(mode);
}

/**
 * @deprecated Utiliser CorkBoardHandlers.onToggleAct()
 */
function toggleStructuredAct(actId) {
    CorkBoardHandlers.onToggleAct(actId);
}

/**
 * @deprecated Utiliser CorkBoardHandlers.onUpdateSynopsis()
 */
function updateSceneSynopsis(actId, chapterId, sceneId, synopsis) {
    CorkBoardHandlers.onUpdateSynopsis(actId, chapterId, sceneId, synopsis);
}

/**
 * @deprecated Utiliser CorkBoardHandlers.onUpdateColor()
 */
function setCorkColor(actId, chapterId, sceneId, color) {
    CorkBoardHandlers.onUpdateColor(actId, chapterId, sceneId, color);
}

/**
 * @deprecated Utiliser CorkBoardHandlers.onOpenScene()
 */
function openSceneFromCork(actId, chapterId, sceneId) {
    CorkBoardHandlers.onOpenScene(actId, chapterId, sceneId);
}

/**
 * @deprecated Utiliser CorkBoardHandlers.onCreateAct()
 */
function createActFromCork() {
    CorkBoardHandlers.onCreateAct();
}

/**
 * @deprecated Utiliser CorkBoardHandlers.onCreateChapter()
 */
function createChapterFromCork(actId) {
    CorkBoardHandlers.onCreateChapter(actId);
}

/**
 * @deprecated Utiliser CorkBoardHandlers.onCreateScene()
 */
function openAddSceneModalFromCork(actId, chapterId) {
    CorkBoardHandlers.onCreateScene(actId, chapterId);
}

/**
 * @deprecated Utiliser CorkBoardHandlers.onUpdateGridSize()
 */
function updateCorkGridSize(value) {
    CorkBoardHandlers.onUpdateGridSize(value);
}

/**
 * @deprecated Utiliser CorkBoardView.showNotification()
 */
function showNotification(message) {
    CorkBoardView.showNotification(message);
}

/**
 * Fonctions obsolètes (non implémentées dans la nouvelle architecture)
 */
function toggleColorPalette(sceneId) {
    console.warn('toggleColorPalette() est obsolète et n\'est plus utilisé');
}

function toggleSceneMenu(sceneId) {
    console.warn('toggleSceneMenu() est obsolète et n\'est plus utilisé');
}

function openCreateFromOutlineModal() {
    alert('Fonctionnalité "Create from Outline" à venir');
}

function showImportOptions() {
    alert('Fonctionnalité "Import" à venir');
}

function showActions() {
    alert('Fonctionnalité "Actions" à venir');
}

/**
 * Fonctions de rendu (compatibilité)
 */
function renderCorkBoardFullView() {
    return CorkBoardView.renderFullView();
}

function renderKanbanView(scenes) {
    // Cette fonction n'est plus utilisée directement
    // Le rendu Kanban est géré par CorkBoardView.renderKanbanView()
    return CorkBoardView.renderKanbanView();
}

function renderCorkCard(scene, index) {
    // Cette fonction n'est plus utilisée directement
    // Le rendu des cartes est géré par CorkBoardView.renderSceneCard()
    return CorkBoardView.renderSceneCard(scene, 'structured');
}

/**
 * Fonctions de drag & drop (compatibilité)
 */
function setupCorkBoardDragAndDrop() {
    CorkBoardHandlers.setupDragAndDrop();
}

function handleCorkDragStart(e) {
    CorkBoardHandlers.handleDragStart(e);
}

function handleCorkDragEnd(e) {
    CorkBoardHandlers.handleDragEnd(e);
}

function handleCorkDragOver(e) {
    CorkBoardHandlers.handleDragOver(e);
}

function handleCorkDrop(e) {
    CorkBoardHandlers.handleDrop(e);
}

/**
 * Fonction utilitaire (compatibilité)
 */
function filterAndRefreshCork(actId, chapterId) {
    if (actId === 'all') {
        CorkBoardViewModel.updateActFilter('all');
    } else if (chapterId === 'all' || !chapterId) {
        CorkBoardViewModel.updateActFilter(actId);
    } else {
        CorkBoardViewModel.updateActFilter(actId);
        CorkBoardViewModel.updateChapterFilter(chapterId);
    }
    CorkBoardHandlers.onOpenFullView();
}

// ============================================
// INITIALISATION
// ============================================
// Initialiser le module au chargement
if (typeof document !== 'undefined') {
    document.addEventListener('DOMContentLoaded', function () {
        initCorkBoard();
    });
}

// ========== js/31.mindmap.js ==========
// ============================================
// NOUVELLES FONCTIONNALITÉS DE VISUALISATION
// ============================================

// Initialiser les données de visualisation si elles n'existent pas
if (!project.mindmapNodes) project.mindmapNodes = [];
if (!project.plotPoints) project.plotPoints = [];
if (!project.relationships) project.relationships = [];
if (!project.mapLocations) project.mapLocations = [];
if (!project.mapImage) project.mapImage = null;
if (!project.visualTimeline) project.visualTimeline = [];

// ============================================
// ========================================
// MINDMAP SYSTEM - Custom drag & drop mindmaps
// ========================================

let mindmapState = {
    zoom: 1,
    panX: 0,
    panY: 0,
    isDragging: false,
    draggedNode: null,
    selectedNode: null,
    isPanning: false,
    lastMouseX: 0,
    lastMouseY: 0,
    linkStart: null,
    libraryCollapsed: false,
    activeLibraryTab: 'characters'
};

// [MVVM : View]
// Gère l'affichage de la liste des mindmaps dans la barre latérale.
function renderMindmapView() {
    const container = document.getElementById('mindmapList');
    if (!container) return;

    // Initialiser mindmaps si nécessaire
    if (!project.mindmaps) {
        project.mindmaps = [];
    }

    container.innerHTML = `
                <div class="mindmap-sidebar-header">
                    <h3 style="margin-bottom: 0.5rem; font-size: 1.1rem;"><i data-lucide="map" style="width:18px;height:18px;vertical-align:middle;margin-right:6px;"></i> Mindmaps</h3>
                    <button class="btn btn-small" onclick="createNewMindmap()" style="width: 100%;">
                        <i data-lucide="plus" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i> Nouvelle Mindmap
                    </button>
                </div>
                <div class="mindmap-list">
                    ${project.mindmaps.length === 0 ? `
                        <div style="padding: 1rem; text-align: center; color: var(--text-muted); font-size: 0.9rem;">
                            Aucune mindmap.<br>Créez-en une !
                        </div>
                    ` : project.mindmaps.map(mm => `
                        <div class="mindmap-item ${currentMindmapId === mm.id ? 'active' : ''}" 
                             onclick="selectMindmap(${mm.id})">
                            <span style="flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
                                ${mm.title}
                            </span>
                            <span onclick="event.stopPropagation(); deleteMindmap(${mm.id})" 
                                  style="cursor: pointer; color: var(--accent-red); opacity: 0.7; padding: 0 0.5rem;"
                                  title="Supprimer"><i data-lucide="x" style="width:14px;height:14px;"></i></span>
                        </div>
                    `).join('')}
                </div>
            `;

    renderMindmapCanvas();
    if (typeof lucide !== 'undefined') lucide.createIcons();
}

// [MVVM : ViewModel]
// Commande pour créer une nouvelle mindmap avec un titre saisi par l'utilisateur.
function createNewMindmap() {
    const title = prompt('Nom de la mindmap:', 'Nouvelle mindmap');
    if (!title) return;

    const newMindmap = {
        id: Date.now(),
        title: title,
        nodes: [],
        links: []
    };

    project.mindmaps.push(newMindmap);
    currentMindmapId = newMindmap.id;
    saveProject();
    renderMindmapView();
}

// [MVVM : ViewModel]
// Commande pour supprimer une mindmap après confirmation.
function deleteMindmap(id) {
    if (!confirm('Supprimer cette mindmap ?')) return;

    const index = project.mindmaps.findIndex(mm => mm.id === id);
    if (index !== -1) {
        project.mindmaps.splice(index, 1);
        if (currentMindmapId === id) {
            currentMindmapId = project.mindmaps.length > 0 ? project.mindmaps[0].id : null;
        }
        saveProject();
        renderMindmapView();
    }
}

// [MVVM : ViewModel]
// Gère la sélection d'une mindmap et met à jour l'affichage.
function selectMindmap(id) {
    currentMindmapId = id;
    renderMindmapCanvas();
    // Mettre à jour l'affichage de la sidebar
    document.querySelectorAll('.mindmap-item').forEach(item => {
        item.classList.remove('active');
    });
    event.currentTarget.classList.add('active');
}

// [MVVM : ViewModel]
// Commande pour renommer la mindmap actuellement sélectionnée.
function renameMindmap() {
    const mindmap = project.mindmaps.find(mm => mm.id === currentMindmapId);
    if (!mindmap) return;

    const newTitle = prompt('Nouveau nom:', mindmap.title);
    if (newTitle && newTitle.trim()) {
        mindmap.title = newTitle.trim();
        saveProject();
        renderMindmapView();
    }
}

// [MVVM : View]
// Rendu principal de la zone de travail (canvas) de la mindmap.
function renderMindmapCanvas() {
    const editorView = document.getElementById('editorView');
    if (!editorView) return;

    const mindmap = project.mindmaps.find(mm => mm.id === currentMindmapId);

    if (!mindmap) {
        // Afficher un message d'accueil
        editorView.innerHTML = `
                    <div class="mindmap-empty">
                        <div class="mindmap-empty-icon"><i data-lucide="map" style="width:48px;height:48px;"></i></div>
                        <h3 style="margin-bottom: 0.5rem;">Aucune mindmap sélectionnée</h3>
                        <p style="margin-bottom: 1rem;">Créez une mindmap pour commencer à organiser vos idées visuellement.</p>
                        <button class="btn" onclick="createNewMindmap()"><i data-lucide="plus" style="width:14px;height:14px;"></i> Créer une mindmap</button>
                    </div>
                `;
        return;
    }

    editorView.innerHTML = `
                <div class="mindmap-wrapper">
                    <div class="mindmap-main">
                        <div class="mindmap-toolbar">
                            <button class="btn btn-small" onclick="renameMindmap()" title="Renommer"><i data-lucide="pencil" style="width:14px;height:14px;"></i></button>
                            <button class="btn btn-small" onclick="addNoteNode()" title="Ajouter une note"><i data-lucide="sticky-note" style="width:14px;height:14px;"></i></button>
                            <button class="btn btn-small" onclick="resetMindmapView()" title="Réinitialiser la vue"><i data-lucide="target" style="width:14px;height:14px;"></i></button>
                            ${mindmapState.linkStart ? `
                                <button class="btn btn-small" onclick="cancelLinking()" style="background: var(--accent-red); color: white;" title="Annuler la liaison">
                                    <i data-lucide="x" style="width:14px;height:14px;"></i> Annuler
                                </button>
                                <span style="font-size: 0.85rem; color: var(--accent-red); font-weight: 600; animation: pulse-text 1s infinite;">
                                    <i data-lucide="link" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>
                                    Cliquez sur un autre nœud pour créer le lien
                                </span>
                            ` : `
                                <span style="font-size: 0.75rem; color: var(--text-muted); font-style: italic;">
                                    <i data-lucide="lightbulb" style="width:12px;height:12px;vertical-align:middle;margin-right:4px;"></i>Survolez un nœud et cliquez sur <i data-lucide="link" style="width:12px;height:12px;vertical-align:middle;"></i> pour créer un lien
                                </span>
                            `}
                            <div style="flex: 1;"></div>
                            <span style="font-size: 0.85rem; color: var(--text-muted);">
                                ${mindmap.nodes.length} nœud(s) · ${mindmap.links.length} lien(s)
                            </span>
                        </div>
                        <div class="mindmap-canvas-wrapper ${mindmapState.linkStart ? 'linking-mode' : ''}" id="mindmapCanvasWrapper">
                            <div class="mindmap-canvas" id="mindmapCanvas"
                                 style="transform: scale(${mindmapState.zoom}) translate(${mindmapState.panX}px, ${mindmapState.panY}px);">
                                <svg id="mindmapSvg" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0; pointer-events: painted;">
                                    ${renderMindmapLinks(mindmap)}
                                </svg>
                                ${renderMindmapNodes(mindmap)}
                            </div>
                        </div>
                    </div>
                    <div class="mindmap-library ${mindmapState.libraryCollapsed ? 'collapsed' : ''}">
                        <div class="mindmap-library-toggle" onclick="toggleLibrary()">
                            ${mindmapState.libraryCollapsed ? '<i data-lucide="chevron-left" style="width:12px;height:12px;"></i>' : '<i data-lucide="chevron-right" style="width:12px;height:12px;"></i>'}
                        </div>
                        <div class="mindmap-library-tabs">
                            <div class="mindmap-library-tab ${mindmapState.activeLibraryTab === 'characters' ? 'active' : ''}"
                                 onclick="setLibraryTab('characters')" title="Personnages"><i data-lucide="users" style="width:16px;height:16px;"></i></div>
                            <div class="mindmap-library-tab ${mindmapState.activeLibraryTab === 'elements' ? 'active' : ''}"
                                 onclick="setLibraryTab('elements')" title="Univers"><i data-lucide="globe" style="width:16px;height:16px;"></i></div>
                            <div class="mindmap-library-tab ${mindmapState.activeLibraryTab === 'codex' ? 'active' : ''}"
                                 onclick="setLibraryTab('codex')" title="Codex"><i data-lucide="book-open" style="width:16px;height:16px;"></i></div>
                            <div class="mindmap-library-tab ${mindmapState.activeLibraryTab === 'structure' ? 'active' : ''}"
                                 onclick="setLibraryTab('structure')" title="Structure"><i data-lucide="list-tree" style="width:16px;height:16px;"></i></div>
                        </div>
                        <div class="mindmap-library-content">
                            ${renderLibraryContent()}
                        </div>
                    </div>
                </div>
        `;

    // Initialiser les événements
    initMindmapEvents();

    // Réinitialiser les icônes Lucide après le rendu
    if (typeof lucide !== 'undefined') {
        lucide.createIcons();
    }
}

// [MVVM : View]
// Génère le code HTML pour afficher les nœuds de la mindmap.
function renderMindmapNodes(mindmap) {
    if (!mindmap.nodes || mindmap.nodes.length === 0) {
        return `
                    <div style="position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); 
                                text-align: center; color: var(--text-muted); pointer-events: none;">
                        <div style="font-size: 3rem; margin-bottom: 1rem; opacity: 0.3;"><i data-lucide="map" style="width:64px;height:64px;"></i></div>
                        <p style="font-size: 0.9rem;">Glissez des éléments depuis la bibliothèque →</p>
                    </div>
                `;
    }

    return mindmap.nodes.map(node => {
        const icon = getNodeIcon(node);
        const typeClass = `type-${node.type}`;
        const content = getNodeContent(node);
        const isLinkingSource = mindmapState.linkStart === node.id;

        return `
                    <div class="mindmap-node ${typeClass} ${mindmapState.selectedNode === node.id ? 'selected' : ''} ${isLinkingSource ? 'linking-source' : ''}"
                         data-node-id="${node.id}"
                         style="left: ${node.x}px; top: ${node.y}px; background-color: ${node.color || 'var(--bg-primary)'};">
                        <div class="mindmap-node-header">
                            <span class="mindmap-node-icon">${icon}</span>
                            <span class="mindmap-node-title">${node.title || 'Sans titre'}</span>
                            <span class="mindmap-node-link-btn" onclick="event.stopPropagation(); startLinkFrom(${node.id})" title="Créer un lien"><i data-lucide="link" style="width:12px;height:12px;"></i></span>
                            <span class="mindmap-node-delete" onclick="event.stopPropagation(); deleteNode(${node.id})"><i data-lucide="x" style="width:12px;height:12px;"></i></span>
                        </div>
                        ${content ? `<div class="mindmap-node-content">${content}</div>` : ''}
                    </div>
                `;
    }).join('');
}

// [MVVM : View]
// Génère le code SVG pour afficher les liens entre les nœuds.
function renderMindmapLinks(mindmap) {
    if (!mindmap.links || mindmap.links.length === 0) return '';

    // Créer les markers pour chaque couleur de lien
    const linkColors = new Set(mindmap.links.map(l => l.color || 'var(--accent-gold)'));
    const markers = Array.from(linkColors).map((color, index) => `
                <marker id="arrowhead-${index}" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
                    <polygon points="0 0, 10 3, 0 6" fill="${color}" opacity="0.7"/>
                </marker>
            `).join('');

    const colorToMarkerId = {};
    Array.from(linkColors).forEach((color, index) => {
        colorToMarkerId[color] = `arrowhead-${index}`;
    });

    return mindmap.links.map(link => {
        const fromNode = mindmap.nodes.find(n => n.id === link.from);
        const toNode = mindmap.nodes.find(n => n.id === link.to);

        if (!fromNode || !toNode) return '';

        const x1 = fromNode.x + 100; // Centre approximatif du nœud
        const y1 = fromNode.y + 40;
        const x2 = toNode.x + 100;
        const y2 = toNode.y + 40;

        // Calculer la position du label au milieu
        const labelX = (x1 + x2) / 2;
        const labelY = (y1 + y2) / 2;

        const linkColor = link.color || 'var(--accent-gold)';
        const markerId = colorToMarkerId[linkColor];
        const escapedLabel = (link.label || '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');

        return `
                    <line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" 
                          stroke="${linkColor}" stroke-width="4" 
                          opacity="0.7" marker-end="url(#${markerId})"
                          data-link-id="${link.id}"
                          onclick="editLink(${link.id})"
                          style="cursor: pointer; pointer-events: stroke;"/>
                    ${link.label ? `
                        <text x="${labelX}" y="${labelY}" 
                              text-anchor="middle" 
                              dominant-baseline="middle"
                              style="font-size: 12px; fill: ${linkColor}; font-weight: 600; 
                                     cursor: pointer; pointer-events: auto; user-select: none;"
                              onclick="editLink(${link.id})">
                            <tspan x="${labelX}" dy="0" 
                                   style="paint-order: stroke; stroke: var(--bg-primary); 
                                          stroke-width: 3px; stroke-linejoin: round;">
                                ${escapedLabel}
                            </tspan>
                        </text>
                    ` : ''}
                `;
    }).join('') + `
                <defs>
                    ${markers}
                </defs>
            `;
}

// [MVVM : View]
// Génère le contenu HTML de la bibliothèque d'éléments (personnages, univers, etc.).
function renderLibraryContent() {
    const tab = mindmapState.activeLibraryTab;

    if (tab === 'characters') {
        return project.characters.map(char => `
                    <div class="mindmap-library-item" draggable="true" 
                         data-type="character" data-id="${char.id}" data-title="${char.name}">
                        <span class="mindmap-library-item-icon"><i data-lucide="user" style="width:16px;height:16px;"></i></span>
                        <span class="mindmap-library-item-text">${char.name}</span>
                    </div>
                `).join('') || '<div style="padding: 1rem; text-align: center; color: var(--text-muted); font-size: 0.85rem;">Aucun personnage</div>';
    }

    if (tab === 'elements') {
        return project.world.map(elem => {
            const elemType = elem.type || 'Lieu';
            // Icônes Lucide selon le type
            const iconMap = {
                'Lieu': 'map-pin',
                'Objet': 'box',
                'Concept': 'lightbulb',
                'Organisation': 'building-2',
                'Événement': 'zap'
            };
            const iconName = iconMap[elemType] || 'map-pin';

            return `
                    <div class="mindmap-library-item" draggable="true" 
                         data-type="element" 
                         data-element-type="${elemType}"
                         data-id="${elem.id}" 
                         data-title="${elem.name}">
                        <span class="mindmap-library-item-icon"><i data-lucide="${iconName}" style="width:16px;height:16px;"></i></span>
                        <span class="mindmap-library-item-text">${elem.name}</span>
                    </div>
                `;
        }).join('') || '<div style="padding: 1rem; text-align: center; color: var(--text-muted); font-size: 0.85rem;">Aucun élément</div>';
    }

    if (tab === 'codex') {
        return (project.codex || []).map(entry => `
                    <div class="mindmap-library-item" draggable="true" 
                         data-type="codex" 
                         data-id="${entry.id}" 
                         data-title="${entry.title || entry.name || 'Sans titre'}">
                        <span class="mindmap-library-item-icon"><i data-lucide="book-open" style="width:16px;height:16px;"></i></span>
                        <span class="mindmap-library-item-text">${entry.title || entry.name || 'Sans titre'}</span>
                    </div>
                `).join('') || '<div style="padding: 1rem; text-align: center; color: var(--text-muted); font-size: 0.85rem;">Aucune entrée codex</div>';
    }

    if (tab === 'structure') {
        let structureHTML = '';
        project.acts.forEach((act, actIndex) => {
            const actNum = toRoman(actIndex + 1);
            // Ajouter l'acte
            structureHTML += `
                        <div class="mindmap-library-item" draggable="true" 
                             data-type="act" 
                             data-id="${act.id}" 
                             data-title="Acte ${actNum}: ${act.title || 'Sans titre'}">
                            <span class="mindmap-library-item-icon"><i data-lucide="folder" style="width:16px;height:16px;"></i></span>
                            <span class="mindmap-library-item-text" style="font-weight: 600;">Acte ${actNum}</span>
                        </div>
                    `;

            act.chapters.forEach((chapter, chapIndex) => {
                const chapNum = chapIndex + 1;
                // Ajouter le chapitre
                structureHTML += `
                            <div class="mindmap-library-item" draggable="true" 
                                 data-type="chapter" 
                                 data-id="${chapter.id}" 
                                 data-act="${act.id}" 
                                 data-title="A${actNum} › Ch.${chapNum}: ${chapter.title || 'Sans titre'}" 
                                 style="margin-left: 0.5rem;">
                                <span class="mindmap-library-item-icon"><i data-lucide="file-text" style="width:16px;height:16px;"></i></span>
                                <span class="mindmap-library-item-text" style="font-size: 0.8rem;">Ch.${chapNum}: ${chapter.title || 'Sans titre'}</span>
                            </div>
                        `;

                chapter.scenes.forEach(scene => {
                    const sceneLabel = scene.title || 'Sans titre';
                    structureHTML += `
                                <div class="mindmap-library-item" draggable="true" 
                                     data-type="scene" 
                                     data-id="${scene.id}" 
                                     data-act="${act.id}" 
                                     data-chapter="${chapter.id}" 
                                     data-title="A${actNum} › C${chapNum} › ${sceneLabel}" 
                                     style="margin-left: 1rem;">
                                    <span class="mindmap-library-item-icon"><i data-lucide="pen-line" style="width:16px;height:16px;"></i></span>
                                    <span class="mindmap-library-item-text" style="font-size: 0.75rem;">${sceneLabel}</span>
                                </div>
                            `;
                });
            });
        });
        return structureHTML || '<div style="padding: 1rem; text-align: center; color: var(--text-muted); font-size: 0.85rem;">Aucune structure</div>';
    }

    return '';
}

// [MVVM : View]
// Détermine l'icône à afficher pour un nœud en fonction de son type.
function getNodeIcon(node) {
    if (node.type === 'element') {
        // Icônes Lucide spécifiques selon le type d'élément d'univers
        const elementIconMap = {
            'Lieu': 'map-pin',
            'Objet': 'box',
            'Concept': 'lightbulb',
            'Organisation': 'building-2',
            'Événement': 'zap'
        };
        const iconName = elementIconMap[node.elementType] || 'map-pin';
        return `<i data-lucide="${iconName}" style="width:16px;height:16px;"></i>`;
    }

    const icons = {
        'character': 'user',
        'scene': 'pen-line',
        'note': 'sticky-note',
        'codex': 'book-open',
        'act': 'folder',
        'chapter': 'file-text'
    };
    const iconName = icons[node.type] || 'pin';
    return `<i data-lucide="${iconName}" style="width:16px;height:16px;"></i>`;
}

// [MVVM : ViewModel]
// Extrait le contenu textuel d'un nœud pour l'affichage.
function getNodeContent(node) {
    if (node.type === 'note') {
        return node.content || '';
    }
    return '';
}

// [MVVM : ViewModel]
// Alterne l'état replié/déplié de la bibliothèque.
function toggleLibrary() {
    mindmapState.libraryCollapsed = !mindmapState.libraryCollapsed;
    renderMindmapCanvas();
}

// [MVVM : ViewModel]
// Change l'onglet actif dans la bibliothèque et rafraîchit son contenu.
function setLibraryTab(tab) {
    mindmapState.activeLibraryTab = tab;
    document.querySelectorAll('.mindmap-library-tab').forEach(t => t.classList.remove('active'));
    event.currentTarget.classList.add('active');
    document.querySelector('.mindmap-library-content').innerHTML = renderLibraryContent();
    initLibraryDragEvents();

    // Réinitialiser les icônes Lucide
    if (typeof lucide !== 'undefined') {
        lucide.createIcons();
    }
}

// [MVVM : ViewModel]
// Gère l'initialisation ou la finalisation de la création d'un lien entre deux nœuds.
function startLinkFrom(nodeId) {
    if (mindmapState.linkStart === nodeId) {
        // Annuler si on reclique sur le même nœud
        cancelLinking();
    } else if (mindmapState.linkStart && mindmapState.linkStart !== nodeId) {
        // Créer le lien
        const mindmap = project.mindmaps.find(mm => mm.id === currentMindmapId);
        if (!mindmap) return;

        const newLink = {
            id: Date.now(),
            from: mindmapState.linkStart,
            to: nodeId,
            label: '',
            color: '#d4af37' // Couleur or par défaut
        };
        mindmap.links.push(newLink);
        mindmapState.linkStart = null;
        saveProject();
        renderMindmapCanvas();
    } else {
        // Démarrer une nouvelle liaison
        mindmapState.linkStart = nodeId;
        renderMindmapCanvas();
    }
}

// [MVVM : ViewModel]
// Annule le processus de création de lien en cours.
function cancelLinking() {
    mindmapState.linkStart = null;
    renderMindmapCanvas();
}

// [MVVM : ViewModel]
// Commande pour ajouter un nœud de type note à la mindmap.
function addNoteNode() {
    const mindmap = project.mindmaps.find(mm => mm.id === currentMindmapId);
    if (!mindmap) return;

    const content = prompt('Contenu de la note:');
    if (!content) return;

    const newNode = {
        id: Date.now(),
        type: 'note',
        title: 'Note',
        content: content,
        x: 100 + Math.random() * 200,
        y: 100 + Math.random() * 200,
        color: 'var(--bg-primary)'
    };

    mindmap.nodes.push(newNode);
    saveProject();
    renderMindmapCanvas();
}

// [MVVM : ViewModel]
// Commande pour supprimer un nœud et ses liens associés.
function deleteNode(nodeId) {
    const mindmap = project.mindmaps.find(mm => mm.id === currentMindmapId);
    if (!mindmap) return;

    if (!confirm('Supprimer ce nœud ?')) return;

    // Supprimer le nœud
    const nodeIndex = mindmap.nodes.findIndex(n => n.id === nodeId);
    if (nodeIndex !== -1) {
        mindmap.nodes.splice(nodeIndex, 1);
    }

    // Supprimer les liens associés
    mindmap.links = mindmap.links.filter(l => l.from !== nodeId && l.to !== nodeId);

    saveProject();
    renderMindmapCanvas();
}

// [MVVM : Mixte]
// Affiche un modal d'édition pour les liens (Vue) et gère la logique de modification (ViewModel).
function editLink(linkId) {
    const mindmap = project.mindmaps.find(mm => mm.id === currentMindmapId);
    if (!mindmap) return;

    const link = mindmap.links.find(l => l.id === linkId);
    if (!link) return;

    // Couleurs prédéfinies
    const colors = [
        { name: 'Or', value: '#d4af37' },
        { name: 'Rouge', value: '#c44536' },
        { name: 'Bleu', value: '#2196f3' },
        { name: 'Vert', value: '#4caf50' },
        { name: 'Violet', value: '#9c27b0' },
        { name: 'Orange', value: '#ff9800' },
        { name: 'Rose', value: '#e91e63' },
        { name: 'Gris', value: '#757575' }
    ];

    let selectedColor = link.color || '#d4af37';

    // Créer le modal
    const overlay = document.createElement('div');
    overlay.className = 'link-editor-overlay';
    overlay.innerHTML = `
                <div class="link-editor-modal">
                    <div class="link-editor-header"><i data-lucide="pencil" style="width:16px;height:16px;vertical-align:middle;margin-right:6px;"></i> Éditer le lien</div>
                    
                    <div class="link-editor-field">
                        <label class="link-editor-label">Étiquette</label>
                        <input type="text" class="link-editor-input" id="linkLabelInput" 
                                value="${(link.label || '').replace(/"/g, '&quot;')}" 
                                placeholder="Ex: ennemi de, père de, aime...">
                    </div>
                    
                    <div class="link-editor-field">
                        <label class="link-editor-label">Couleur</label>
                        <div class="link-editor-colors" id="linkColorPicker">
                            ${colors.map(c => `
                                <div class="link-color-option ${c.value === selectedColor ? 'selected' : ''}" 
                                     style="background: ${c.value};"
                                     data-color="${c.value}"
                                     title="${c.name}"></div>
                            `).join('')}
                        </div>
                    </div>
                    
                    <div class="link-editor-buttons">
                        <button class="btn" id="saveLinkBtn" style="flex: 1;"><i data-lucide="save" style="width:14px;height:14px;margin-right:4px;"></i> Enregistrer</button>
                        <button class="btn" id="deleteLinkBtn" style="background: var(--accent-red); color: white;"><i data-lucide="trash-2" style="width:14px;height:14px;margin-right:4px;"></i> Supprimer</button>
                        <button class="btn" id="cancelLinkBtn" style="background: var(--bg-secondary);"><i data-lucide="x" style="width:14px;height:14px;margin-right:4px;"></i> Annuler</button>
                    </div>
                </div>
            `;

    if (!document.body) {
        console.error('document.body not available');
        return;
    }

    document.body.appendChild(overlay);

    // Gestionnaires d'événements
    const modal = overlay.querySelector('.link-editor-modal');

    // Empêcher la fermeture au clic sur le modal
    modal.addEventListener('click', (e) => {
        e.stopPropagation();
    });

    // Fermer au clic sur l'overlay
    overlay.addEventListener('click', () => {
        overlay.remove();
    });

    // Sélection de couleur
    document.querySelectorAll('.link-color-option').forEach(opt => {
        opt.addEventListener('click', () => {
            selectedColor = opt.getAttribute('data-color');
            document.querySelectorAll('.link-color-option').forEach(o => o.classList.remove('selected'));
            opt.classList.add('selected');
        });
    });

    // Bouton Enregistrer
    document.getElementById('saveLinkBtn').addEventListener('click', () => {
        const newLabel = document.getElementById('linkLabelInput').value.trim();
        link.label = newLabel;
        link.color = selectedColor;
        saveProject();
        overlay.remove();
        renderMindmapCanvas();
    });

    // Bouton Supprimer
    document.getElementById('deleteLinkBtn').addEventListener('click', () => {
        if (!confirm('Supprimer ce lien ?')) return;
        const linkIndex = mindmap.links.findIndex(l => l.id === linkId);
        if (linkIndex !== -1) {
            mindmap.links.splice(linkIndex, 1);
            saveProject();
            overlay.remove();
            renderMindmapCanvas();
        }
    });

    // Bouton Annuler
    document.getElementById('cancelLinkBtn').addEventListener('click', () => {
        overlay.remove();
    });

    // Focus sur l'input
    document.getElementById('linkLabelInput').focus();
}

// [MVVM : ViewModel]
// Réinitialise le zoom et le panoramique de la vue mindmap.
function resetMindmapView() {
    mindmapState.zoom = 1;
    mindmapState.panX = 0;
    mindmapState.panY = 0;
    renderMindmapCanvas();
}

// [MVVM : View]
// Initialise les écouteurs d'événements pour les interactions avec la mindmap.
function initMindmapEvents() {
    const canvas = document.getElementById('mindmapCanvas');
    const wrapper = document.getElementById('mindmapCanvasWrapper');
    if (!canvas || !wrapper) return;

    // Drag & drop des nœuds (souris + tactile)
    canvas.querySelectorAll('.mindmap-node').forEach(node => {
        node.addEventListener('mousedown', handleNodeMouseDown);
        node.addEventListener('click', handleNodeClick);
        node.addEventListener('touchstart', handleNodeTouchStart, { passive: false });
    });

    // Pan de la canvas (souris)
    wrapper.addEventListener('mousedown', handleCanvasMouseDown);
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);

    // Pan de la canvas (tactile)
    wrapper.addEventListener('touchstart', handleCanvasTouchStart, { passive: false });
    document.addEventListener('touchmove', handleTouchMove, { passive: false });
    document.addEventListener('touchend', handleTouchEnd);

    // Zoom
    wrapper.addEventListener('wheel', handleWheel);

    // Drop depuis la bibliothèque
    wrapper.addEventListener('dragover', handleDragOver);
    wrapper.addEventListener('drop', handleDrop);

    // Initialiser le drag des items de la bibliothèque
    initLibraryDragEvents();
}

// [MVVM : View]
// Initialise les événements de glisser-déposer pour les éléments de la bibliothèque.
function initLibraryDragEvents() {
    document.querySelectorAll('.mindmap-library-item').forEach(item => {
        // Support souris (desktop)
        item.addEventListener('dragstart', handleLibraryDragStart);

        // Support tactile (mobile)
        item.addEventListener('touchstart', handleLibraryTouchStart, { passive: false });
    });
}

// Variables pour le drag tactile
let touchDragData = null;
let touchDragElement = null;
let touchDragClone = null;

// [MVVM : ViewModel]
// Gère le début du glisser-déposer tactile pour un élément de la bibliothèque.
function handleLibraryTouchStart(e) {
    e.preventDefault();

    const item = e.currentTarget;
    const touch = e.touches[0];

    // Sauvegarder les données
    touchDragData = {
        type: item.getAttribute('data-type'),
        linkedId: item.getAttribute('data-id'),
        title: item.getAttribute('data-title'),
        actId: item.getAttribute('data-act'),
        chapterId: item.getAttribute('data-chapter'),
        elementType: item.getAttribute('data-element-type')
    };

    touchDragElement = item;

    // Créer un clone visuel
    touchDragClone = item.cloneNode(true);
    touchDragClone.style.position = 'fixed';
    touchDragClone.style.left = touch.clientX - 60 + 'px';
    touchDragClone.style.top = touch.clientY - 20 + 'px';
    touchDragClone.style.width = '120px';
    touchDragClone.style.opacity = '0.7';
    touchDragClone.style.pointerEvents = 'none';
    touchDragClone.style.zIndex = '10000';
    touchDragClone.style.transform = 'scale(0.9)';

    if (document.body) {
        document.body.appendChild(touchDragClone);
    }

    // Écouter les mouvements
    document.addEventListener('touchmove', handleLibraryTouchMove, { passive: false });
    document.addEventListener('touchend', handleLibraryTouchEnd);
}

// [MVVM : ViewModel]
// Gère le mouvement du glisser-déposer tactile.
function handleLibraryTouchMove(e) {
    e.preventDefault();

    if (!touchDragClone) return;

    const touch = e.touches[0];
    touchDragClone.style.left = touch.clientX - 60 + 'px';
    touchDragClone.style.top = touch.clientY - 20 + 'px';
}

// [MVVM : ViewModel]
// Gère la fin du glisser-déposer tactile et le drop sur la canvas.
function handleLibraryTouchEnd(e) {
    if (!touchDragClone || !touchDragData) {
        cleanupTouchDrag();
        return;
    }

    const touch = e.changedTouches[0];

    // Vérifier si on est sur la zone de drop
    const wrapper = document.getElementById('mindmapCanvasWrapper');
    if (!wrapper) {
        cleanupTouchDrag();
        return;
    }

    const rect = wrapper.getBoundingClientRect();
    if (touch.clientX >= rect.left && touch.clientX <= rect.right &&
        touch.clientY >= rect.top && touch.clientY <= rect.bottom) {

        // Drop sur la canvas
        const mindmap = project.mindmaps.find(mm => mm.id === currentMindmapId);
        if (mindmap) {
            // Calculer la position en tenant compte du zoom et du pan
            const x = (touch.clientX - rect.left - mindmapState.panX * mindmapState.zoom) / mindmapState.zoom;
            const y = (touch.clientY - rect.top - mindmapState.panY * mindmapState.zoom) / mindmapState.zoom;

            const newNode = {
                id: Date.now(),
                type: touchDragData.type,
                linkedId: touchDragData.linkedId,
                title: touchDragData.title,
                x: x,
                y: y,
                color: 'var(--bg-primary)'
            };

            // Ajouter les données supplémentaires pour les scènes
            if (touchDragData.type === 'scene') {
                newNode.actId = touchDragData.actId;
                newNode.chapterId = touchDragData.chapterId;
            }

            // Ajouter le type d'élément pour les éléments d'univers
            if (touchDragData.type === 'element' && touchDragData.elementType) {
                newNode.elementType = touchDragData.elementType;
            }

            mindmap.nodes.push(newNode);
            saveProject();
            renderMindmapCanvas();
        }
    }

    cleanupTouchDrag();
}

// [MVVM : ViewModel]
// Nettoie les données et les clones visuels après un glisser-déposer tactile.
function cleanupTouchDrag() {
    if (touchDragClone && touchDragClone.parentNode) {
        touchDragClone.parentNode.removeChild(touchDragClone);
    }
    touchDragClone = null;
    touchDragData = null;
    touchDragElement = null;

    document.removeEventListener('touchmove', handleLibraryTouchMove);
    document.removeEventListener('touchend', handleLibraryTouchEnd);
}

// [MVVM : ViewModel]
// Prépare les données à transférer lors du début d'un glisser-déposer (souris).
function handleLibraryDragStart(e) {
    const type = e.currentTarget.getAttribute('data-type');
    const id = e.currentTarget.getAttribute('data-id');
    const title = e.currentTarget.getAttribute('data-title');
    const actId = e.currentTarget.getAttribute('data-act');
    const chapterId = e.currentTarget.getAttribute('data-chapter');
    const elementType = e.currentTarget.getAttribute('data-element-type');

    e.dataTransfer.setData('application/json', JSON.stringify({
        type,
        linkedId: id,
        title,
        actId,
        chapterId,
        elementType
    }));
    e.dataTransfer.effectAllowed = 'copy';
}

// [MVVM : ViewModel]
// Autorise le survol de la zone de drop.
function handleDragOver(e) {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'copy';
}

// [MVVM : ViewModel]
// Gère le dépôt d'un élément de la bibliothèque sur la canvas.
function handleDrop(e) {
    e.preventDefault();

    const mindmap = project.mindmaps.find(mm => mm.id === currentMindmapId);
    if (!mindmap) return;

    try {
        const data = JSON.parse(e.dataTransfer.getData('application/json'));
        const wrapper = document.getElementById('mindmapCanvasWrapper');
        const canvas = document.getElementById('mindmapCanvas');
        const rect = wrapper.getBoundingClientRect();

        // Calculer la position en tenant compte du zoom et du pan
        const x = (e.clientX - rect.left - mindmapState.panX * mindmapState.zoom) / mindmapState.zoom;
        const y = (e.clientY - rect.top - mindmapState.panY * mindmapState.zoom) / mindmapState.zoom;

        const newNode = {
            id: Date.now(),
            type: data.type,
            linkedId: data.linkedId,
            title: data.title,
            x: x,
            y: y,
            color: 'var(--bg-primary)'
        };

        // Ajouter les données supplémentaires pour les scènes
        if (data.type === 'scene') {
            newNode.actId = data.actId;
            newNode.chapterId = data.chapterId;
        }

        // Ajouter le type d'élément pour les éléments d'univers
        if (data.type === 'element' && data.elementType) {
            newNode.elementType = data.elementType;
        }

        mindmap.nodes.push(newNode);
        saveProject();
        renderMindmapCanvas();
    } catch (err) {
        console.error('Erreur lors du drop:', err);
    }
}

// [MVVM : ViewModel]
// Initialise le déplacement d'un nœud à la souris.
function handleNodeMouseDown(e) {
    e.stopPropagation();

    const mindmap = project.mindmaps.find(mm => mm.id === currentMindmapId);
    if (!mindmap) return;

    const nodeId = parseInt(e.currentTarget.getAttribute('data-node-id'));

    // Mode déplacement uniquement
    mindmapState.isDragging = true;
    mindmapState.draggedNode = nodeId;
    mindmapState.selectedNode = nodeId;

    const node = mindmap.nodes.find(n => n.id === nodeId);
    const canvas = document.getElementById('mindmapCanvas');
    const rect = canvas.getBoundingClientRect();

    mindmapState.dragOffsetX = (e.clientX - rect.left) / mindmapState.zoom - node.x;
    mindmapState.dragOffsetY = (e.clientY - rect.top) / mindmapState.zoom - node.y;

    e.currentTarget.classList.add('dragging');
}

// [MVVM : ViewModel]
// Gère le clic (sélection/liaison) et le double-clic (navigation) sur un nœud.
function handleNodeClick(e) {
    const nodeId = parseInt(e.currentTarget.getAttribute('data-node-id'));
    const mindmap = project.mindmaps.find(mm => mm.id === currentMindmapId);
    if (!mindmap) return;

    const node = mindmap.nodes.find(n => n.id === nodeId);
    if (!node) return;

    // Double-clic pour ouvrir l'élément lié
    if (e.detail === 2 && node.linkedId) {
        if (node.type === 'character') {
            switchView('characters');
            setTimeout(() => openCharacterDetail(node.linkedId), 100);
        } else if (node.type === 'element') {
            switchView('world');
            setTimeout(() => openWorldDetail(node.linkedId), 100);
        } else if (node.type === 'codex') {
            switchView('codex');
            setTimeout(() => {
                if (typeof openCodexDetail === 'function') {
                    openCodexDetail(node.linkedId);
                }
            }, 100);
        } else if (node.type === 'scene' && node.actId && node.chapterId) {
            switchView('editor');
            setTimeout(() => openScene(node.actId, node.chapterId, node.linkedId), 100);
        } else if (node.type === 'chapter' && node.actId) {
            switchView('editor');
            // Trouver la première scène du chapitre
            const act = project.acts.find(a => a.id == node.actId);
            if (act) {
                const chapter = act.chapters.find(c => c.id == node.linkedId);
                if (chapter && chapter.scenes.length > 0) {
                    setTimeout(() => openScene(node.actId, node.linkedId, chapter.scenes[0].id), 100);
                }
            }
        } else if (node.type === 'act') {
            switchView('editor');
            // Trouver le premier chapitre et scène de l'acte
            const act = project.acts.find(a => a.id == node.linkedId);
            if (act && act.chapters.length > 0 && act.chapters[0].scenes.length > 0) {
                setTimeout(() => openScene(node.linkedId, act.chapters[0].id, act.chapters[0].scenes[0].id), 100);
            }
        }
    }

    // Simple clic en mode liaison : créer le lien vers ce nœud
    if (e.detail === 1 && mindmapState.linkStart && mindmapState.linkStart !== nodeId) {
        // Créer le lien immédiatement
        const newLink = {
            id: Date.now(),
            from: mindmapState.linkStart,
            to: nodeId,
            label: '',
            color: '#d4af37'
        };
        mindmap.links.push(newLink);
        mindmapState.linkStart = null;
        saveProject();
        renderMindmapCanvas();
    }
}

// [MVVM : ViewModel]
// Initialise le déplacement panoramique de la canvas.
function handleCanvasMouseDown(e) {
    if (e.target.id === 'mindmapCanvasWrapper' || e.target.id === 'mindmapCanvas') {
        mindmapState.isPanning = true;
        mindmapState.lastMouseX = e.clientX;
        mindmapState.lastMouseY = e.clientY;
        document.getElementById('mindmapCanvas').classList.add('panning');
    }
}

// [MVVM : ViewModel]
// Met à jour la position des nœuds ou de la canvas lors du déplacement de la souris.
function handleMouseMove(e) {
    const mindmap = project.mindmaps.find(mm => mm.id === currentMindmapId);
    if (!mindmap) return;

    if (mindmapState.isDragging && mindmapState.draggedNode) {
        const node = mindmap.nodes.find(n => n.id === mindmapState.draggedNode);
        if (node) {
            const canvas = document.getElementById('mindmapCanvas');
            const rect = canvas.getBoundingClientRect();

            node.x = (e.clientX - rect.left) / mindmapState.zoom - mindmapState.dragOffsetX;
            node.y = (e.clientY - rect.top) / mindmapState.zoom - mindmapState.dragOffsetY;

            // Mise à jour en temps réel
            const nodeElem = document.querySelector(`[data - node - id="${node.id}"]`);
            if (nodeElem) {
                nodeElem.style.left = node.x + 'px';
                nodeElem.style.top = node.y + 'px';
            }

            // Redessiner les liens
            document.getElementById('mindmapSvg').innerHTML = renderMindmapLinks(mindmap);
        }
    } else if (mindmapState.isPanning) {
        const deltaX = e.clientX - mindmapState.lastMouseX;
        const deltaY = e.clientY - mindmapState.lastMouseY;

        mindmapState.panX += deltaX / mindmapState.zoom;
        mindmapState.panY += deltaY / mindmapState.zoom;

        mindmapState.lastMouseX = e.clientX;
        mindmapState.lastMouseY = e.clientY;

        const canvas = document.getElementById('mindmapCanvas');
        canvas.style.transform = `scale(${mindmapState.zoom}) translate(${mindmapState.panX}px, ${mindmapState.panY}px)`;
    }
}

// [MVVM : ViewModel]
// Finalise le déplacement d'un nœud ou de la canvas.
function handleMouseUp(e) {
    if (mindmapState.isDragging) {
        const mindmap = project.mindmaps.find(mm => mm.id === currentMindmapId);
        if (mindmap) {
            saveProject();
        }

        document.querySelectorAll('.mindmap-node').forEach(node => {
            node.classList.remove('dragging');
        });
    }

    if (mindmapState.isPanning) {
        document.getElementById('mindmapCanvas').classList.remove('panning');
    }

    mindmapState.isDragging = false;
    mindmapState.draggedNode = null;
    mindmapState.isPanning = false;
}


// ========== js/32.touch-events.js ==========
// ========================================
// TOUCH EVENTS FOR MOBILE
// ========================================

// [MVVM : Other]
// Group: Util / Helper | Naming: TouchUtils
// Gère le début d'un événement tactile sur un nœud de la mindmap (déplacement ou sélection)
function handleNodeTouchStart(e) {
    // Empêcher le comportement par défaut mais permettre les boutons
    if (e.target.classList.contains('mindmap-node-link-btn') ||
        e.target.classList.contains('mindmap-node-delete')) {
        return; // Laisser les boutons fonctionner
    }

    e.preventDefault();
    e.stopPropagation();

    const mindmap = project.mindmaps.find(mm => mm.id === currentMindmapId);
    if (!mindmap) return;

    const nodeId = parseInt(e.currentTarget.getAttribute('data-node-id'));
    const touch = e.touches[0];

    // Mode déplacement
    mindmapState.isDragging = true;
    mindmapState.draggedNode = nodeId;
    mindmapState.selectedNode = nodeId;

    const node = mindmap.nodes.find(n => n.id === nodeId);
    const canvas = document.getElementById('mindmapCanvas');
    const rect = canvas.getBoundingClientRect();

    mindmapState.dragOffsetX = (touch.clientX - rect.left) / mindmapState.zoom - node.x;
    mindmapState.dragOffsetY = (touch.clientY - rect.top) / mindmapState.zoom - node.y;

    e.currentTarget.classList.add('dragging');
}

// [MVVM : Other]
// Group: Util / Helper | Naming: TouchUtils
// Gère le début du toucher sur le canvas pour l'initiation du panoramique (panning)
function handleCanvasTouchStart(e) {
    if (e.target.id === 'mindmapCanvasWrapper' || e.target.id === 'mindmapCanvas') {
        e.preventDefault();
        const touch = e.touches[0];
        mindmapState.isPanning = true;
        mindmapState.lastMouseX = touch.clientX;
        mindmapState.lastMouseY = touch.clientY;
        document.getElementById('mindmapCanvas').classList.add('panning');
    }
}

// [MVVM : Other]
// Group: Util / Helper | Naming: TouchUtils
// Gère le mouvement du toucher pour déplacer les nœuds ou effectuer un panoramique
function handleTouchMove(e) {
    const mindmap = project.mindmaps.find(mm => mm.id === currentMindmapId);
    if (!mindmap) return;

    const touch = e.touches[0];

    if (mindmapState.isDragging && mindmapState.draggedNode) {
        e.preventDefault();
        const node = mindmap.nodes.find(n => n.id === mindmapState.draggedNode);
        if (node) {
            const canvas = document.getElementById('mindmapCanvas');
            const rect = canvas.getBoundingClientRect();

            node.x = (touch.clientX - rect.left) / mindmapState.zoom - mindmapState.dragOffsetX;
            node.y = (touch.clientY - rect.top) / mindmapState.zoom - mindmapState.dragOffsetY;

            // Mise à jour en temps réel
            const nodeElem = document.querySelector(`[data-node-id="${node.id}"]`);
            if (nodeElem) {
                nodeElem.style.left = node.x + 'px';
                nodeElem.style.top = node.y + 'px';
            }

            // Redessiner les liens
            document.getElementById('mindmapSvg').innerHTML = renderMindmapLinks(mindmap);
        }
    } else if (mindmapState.isPanning) {
        e.preventDefault();
        const deltaX = touch.clientX - mindmapState.lastMouseX;
        const deltaY = touch.clientY - mindmapState.lastMouseY;

        mindmapState.panX += deltaX / mindmapState.zoom;
        mindmapState.panY += deltaY / mindmapState.zoom;

        mindmapState.lastMouseX = touch.clientX;
        mindmapState.lastMouseY = touch.clientY;

        const canvas = document.getElementById('mindmapCanvas');
        canvas.style.transform = `scale(${mindmapState.zoom}) translate(${mindmapState.panX}px, ${mindmapState.panY}px)`;
    }
}

// [MVVM : Other]
// Group: Util / Helper | Naming: TouchUtils
// Finalise le déplacement ou le panoramique lors du relâchement du toucher
function handleTouchEnd(e) {
    if (mindmapState.isDragging) {
        const mindmap = project.mindmaps.find(mm => mm.id === currentMindmapId);
        if (mindmap) {
            saveProject();
        }

        document.querySelectorAll('.mindmap-node').forEach(node => {
            node.classList.remove('dragging');
        });
    }

    if (mindmapState.isPanning) {
        const canvas = document.getElementById('mindmapCanvas');
        if (canvas) {
            canvas.classList.remove('panning');
        }
    }

    mindmapState.isDragging = false;
    mindmapState.draggedNode = null;
    mindmapState.isPanning = false;
}

// [MVVM : Other]
// Group: Util / Helper | Naming: TouchUtils
// Gère le zoom de la mindmap via la molette de la souris ou le geste de pincement
function handleWheel(e) {
    e.preventDefault();

    const delta = e.deltaY > 0 ? 0.9 : 1.1;
    const newZoom = Math.max(0.1, Math.min(3, mindmapState.zoom * delta));

    mindmapState.zoom = newZoom;

    const canvas = document.getElementById('mindmapCanvas');
    canvas.style.transform = `scale(${mindmapState.zoom}) translate(${mindmapState.panX}px, ${mindmapState.panY}px)`;
}



// ========== js-refactor/plot/plot.model.js ==========
/**
 * Modèle de données pour le module Plot (Intrigue)
 * Gère la structure des points d'intrigue et le calcul de la tension.
 */
class PlotPoint {
    constructor(data) {
        this.position = data.position || 0;
        this.intensity = data.intensity || 0;
        this.title = data.title || '';
        this.actId = data.actId;
        this.chapterId = data.chapterId;
        this.sceneId = data.sceneId;
        this.description = data.description || '';
        this.wordCount = data.wordCount || 0;
    }
}

class PlotModel {
    /**
     * Calcule le score de tension d'une scène.
     * @param {Object} scene - L'objet scène
     * @param {Object} context - Informations contextuelles (indices, totaux)
     * @returns {number} Score de tension (0-100)
     */
    static calculateSceneTension(scene, context) {
        // Validation des paramètres
        if (!scene) return 0;

        // Utilisation de calculateLiveTension si disponible (analyseur sémantique)
        if (typeof calculateLiveTension === 'function' && context.act && context.chapter) {
            const analysisContext = {
                actId: context.act.id,
                chapterId: context.chapter.id,
                sceneId: scene.id
            };
            const result = calculateLiveTension(scene.content || '', analysisContext);
            return result.score;
        }

        // Fallback: Algorithme simplifié
        let tension = 25;
        const content = (scene.content || '').toLowerCase();
        const wordCount = content.split(/\s+/).filter(w => w.length > 0).length;

        // Bonification pour les scènes courtes (souvent plus intenses)
        if (wordCount < 500 && wordCount > 50) tension += 10;

        // Ce fallback est basique, l'analyseur sémantique est préférable
        return Math.min(100, Math.max(0, tension));
    }
}

// ========== js-refactor/plot/plot.repository.js ==========
/**
 * Repository pour le module Plot
 * Gère le stockage et la récupération des points d'intrigue.
 */
class PlotRepository {
    constructor() {
        this._plotPoints = [];
    }

    /**
     * Récupère tous les points d'intrigue.
     * @returns {Array<PlotPoint>} Liste des points
     */
    getAll() {
        return this._plotPoints;
    }

    /**
     * Définit la liste des points d'intrigue.
     * @param {Array<PlotPoint>} points 
     */
    setAll(points) {
        this._plotPoints = points;
        // Synchroniser avec la variable globale pour compatibilité descendante si nécessaire
        if (typeof plotPoints !== 'undefined') {
            // On vide le tableau global et on le remplit
            plotPoints.length = 0;
            // On ne peut pas réassigner plotPoints si c'est const, mais c'est sûrement let/var ou un tableau mutable
            points.forEach(p => plotPoints.push(p));
        }
    }

    /**
     * Vide la liste des points.
     */
    clear() {
        this._plotPoints = [];
        if (typeof plotPoints !== 'undefined') {
            plotPoints.length = 0;
        }
    }

    /**
     * Ajoute un point à la liste.
     * @param {PlotPoint} point 
     */
    add(point) {
        this._plotPoints.push(point);
    }

    /**
     * Génère les points d'intrigue à partir des données du projet.
     * @param {Object} projectData - L'objet projet global (project)
     */
    generateFromProject(projectData) {
        if (!projectData || !projectData.acts) return;

        const points = [];
        let position = 0;
        const totalActs = projectData.acts.length;

        projectData.acts.forEach((act, actIndex) => {
            const totalChapters = act.chapters.length;

            act.chapters.forEach((chapter, chapIndex) => {
                const totalScenes = chapter.scenes.length;

                chapter.scenes.forEach((scene, sceneIndex) => {
                    const context = {
                        act: act,
                        chapter: chapter,
                        actIndex: actIndex,
                        totalActs: totalActs,
                        chapterIndex: chapIndex,
                        totalChapters: totalChapters,
                        sceneIndex: sceneIndex,
                        totalScenes: totalScenes
                    };

                    const intensity = PlotModel.calculateSceneTension(scene, context);

                    points.push(new PlotPoint({
                        position: position++,
                        intensity: intensity,
                        title: scene.title,
                        actId: act.id,
                        chapterId: chapter.id,
                        sceneId: scene.id,
                        description: `${act.title} > ${chapter.title} > ${scene.title}`,
                        wordCount: scene.content ? scene.content.split(/\s+/).filter(w => w.length > 0).length : 0
                    }));
                });
            });
        });

        this.setAll(points);
        return points;
    }
}

// ========== js-refactor/plot/plot.viewmodel.js ==========
/**
 * ViewModel pour le module Plot
 * Gère la logique de présentation et les interactions utilisateur.
 */
/**
 * ViewModel pour le module Plot
 * Gère la logique de présentation et les interactions utilisateur.
 */
class PlotViewModel {
    constructor(repository, view) {
        this.repository = repository;
        this.view = view;

        // Initialiser l'état
        this.isInitialized = false;
        this.currentTab = 'overview'; // 'overview', 'analysis', 'suggestions'
        this.analysisData = null;
        this.suggestionsData = null;
    }

    /**
     * Initialise le ViewModel et rend la vue si nécessaire.
     */
    init() {
        if (this.isInitialized) return;

        // Initialiser les bindings de la vue
        this.view.bindRecalculate(() => this.resetPoints());
        this.view.bindAnalyze(() => this.analyzeCurve());
        this.view.bindSuggestions(() => this.showSuggestions());
        this.view.bindExport(() => this.exportPlot());

        // Ajouter un binding pour revenir à la vue d'ensemble
        // Note: La vue devra appeler window.showPlotOverview() ou une méthode liée

        this.isInitialized = true;
    }

    /**
     * Charge les données et met à jour la vue.
     */
    loadAndRender() {
        // Reset tab on full reload
        this.currentTab = 'overview';
        const points = this.repository.getAll();

        // Si aucun point n'existe mais qu'on a un projet, on génère
        if (points.length === 0 && typeof project !== 'undefined' && project.acts && project.acts.length > 0) {
            this.repository.generateFromProject(project);
        }

        this._refreshView();
    }

    /**
     * Rafraîchit la vue en fonction de l'état actuel
     */
    _refreshView() {
        const points = this.repository.getAll();
        this.view.render(points, this.currentTab, {
            analysis: this.analysisData,
            suggestions: this.suggestionsData
        });
    }

    /**
     * Ouvre une scène spécifique.
     */
    openPoint(actId, chapterId, sceneId) {
        if (typeof switchView === 'function') switchView('editor');
        if (typeof openScene === 'function') openScene(actId, chapterId, sceneId);
    }

    /**
     * Réinitialise et recalcule les points.
     */
    resetPoints() {
        if (confirm('Recalculer tous les points d\'intrigue ?\n\nLa tension sera recalculée automatiquement pour toutes les scènes.')) {
            if (typeof project !== 'undefined') {
                this.repository.generateFromProject(project);
                this.analysisData = null; // Reset cached analysis
                this.suggestionsData = null; // Reset cached suggestions
                this._refreshView();
                if (typeof showNotification === 'function') {
                    showNotification('✓ Points recalculés automatiquement');
                }
            }
        }
    }

    /**
     * Bascule vers l'onglet Vue d'ensemble
     */
    showOverview() {
        this.currentTab = 'overview';
        this._refreshView();
    }

    /**
     * Lance l'analyse de la courbe et affiche l'onglet Analyse.
     */
    analyzeCurve() {
        const points = this.repository.getAll();
        if (points.length === 0) {
            alert('Aucun point à analyser. Créez d\'abord des scènes.');
            return;
        }

        const stats = this._computeStats(points);
        this.analysisData = this._generateAnalysisData(points, stats);
        this.currentTab = 'analysis';
        this._refreshView();
    }

    /**
     * Affiche les suggestions d'amélioration dans l'onglet Suggestions.
     */
    showSuggestions() {
        const points = this.repository.getAll();
        if (points.length === 0) {
            alert('Créez d\'abord des scènes pour obtenir des suggestions.');
            return;
        }

        const stats = this._computeStats(points);
        this.suggestionsData = this._generateSuggestionsData(points, stats);
        this.currentTab = 'suggestions';
        this._refreshView();
    }

    /**
     * Exporte le graphique en SVG.
     */
    exportPlot() {
        // L'export ne fonctionne que si le SVG est visible (onglet overview)
        // Mais on permet l'export depuis n'importe quel onglet si on peut grabber les données
        // Ici on suppose qu'on doit être sur l'onglet graph pour grabber le SVG du DOM
        if (this.currentTab !== 'overview') {
            if (confirm("L'export nécessite d'afficher le graphique. Basculer vers la vue d'ensemble ?")) {
                this.showOverview();
                // Petit délai pour laisser le DOM se mettre à jour
                setTimeout(() => this.exportPlot(), 100);
            }
            return;
        }

        const svgElement = document.getElementById('plotSvg');
        if (!svgElement) return;

        const svgData = new XMLSerializer().serializeToString(svgElement);
        const blob = new Blob([svgData], { type: 'image/svg+xml' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${project.title || 'projet'}_plot.svg`;
        a.click();
        URL.revokeObjectURL(url);
    }

    // --- Méthodes privées d'analyse ---

    _computeStats(points) {
        const tensions = points.map(p => p.intensity);
        if (tensions.length === 0) return null;

        const avg = tensions.reduce((a, b) => a + b, 0) / tensions.length;
        const max = Math.max(...tensions);
        const min = Math.min(...tensions);
        const maxIndex = tensions.indexOf(max);
        const minIndex = tensions.indexOf(min);

        // Variance et écart-type
        const variance = tensions.reduce((sum, t) => sum + Math.pow(t - avg, 2), 0) / tensions.length;
        const stdDev = Math.sqrt(variance);

        return { tensions, avg, max, min, maxIndex, minIndex, stdDev, count: points.length };
    }

    _generateAnalysisData(points, stats) {
        if (!stats) return null;
        const { avg, max, min, maxIndex, minIndex, stdDev, tensions, count } = stats;

        // Détection du climax
        const lastThird = Math.floor(count * 0.66);
        const climaxInLastThird = maxIndex >= lastThird;

        // Analyse progression
        const firstHalf = tensions.slice(0, Math.floor(count / 2));
        const secondHalf = tensions.slice(Math.floor(count / 2));
        const firstAvg = firstHalf.length ? firstHalf.reduce((a, b) => a + b, 0) / firstHalf.length : 0;
        const secondAvg = secondHalf.length ? secondHalf.reduce((a, b) => a + b, 0) / secondHalf.length : 0;
        const isRising = secondAvg > firstAvg;

        // Pics
        let peaks = 0;
        for (let i = 1; i < tensions.length - 1; i++) {
            if (tensions[i] > tensions[i - 1] + 20 && tensions[i] > tensions[i + 1] + 20) {
                peaks++;
            }
        }

        return {
            stats: {
                avg, max, min, maxIndex, minIndex, stdDev, peaks,
                amplitude: max - min,
                maxTitle: points[maxIndex].title,
                minTitle: points[minIndex].title
            },
            narrative: {
                avgLow: avg < 40,
                avgHigh: avg > 70,
                climaxGood: climaxInLastThird,
                climaxPercent: Math.round((maxIndex / count) * 100),
                isRising,
                flatCurve: stdDev < 10,
                irregularCurve: stdDev > 25,
                noPeaks: peaks === 0,
                tooManyPeaks: peaks > count / 3
            }
        };
    }

    _generateSuggestionsData(points, stats) {
        if (!stats) return null;
        const { avg, tensions } = stats;

        // Zones plates
        let flatZones = [];
        for (let i = 0; i < tensions.length - 2; i++) {
            const range = tensions.slice(i, i + 3);
            const rangeAvg = range.reduce((a, b) => a + b, 0) / range.length;
            const rangeVariance = range.reduce((sum, t) => sum + Math.pow(t - rangeAvg, 2), 0) / range.length;
            if (rangeVariance < 5) flatZones.push(i);
        }

        return {
            flatZonesCount: flatZones.length,
            avgLow: avg < 40,
            avgHigh: avg > 70
        };
    }
}

// ========== js-refactor/plot/plot.view.js ==========
/**
 * Vue pour le module Plot
 * Gère le rendu SVG et HTML du graphique.
 */
class PlotView {
    constructor() {
        this.containerId = 'editorView';
        // Callbacks
        this.onRecalculate = null;
        this.onAnalyze = null;
        this.onSuggestions = null;
        this.onExport = null;
    }

    bindRecalculate(handler) { this.onRecalculate = handler; }
    bindAnalyze(handler) { this.onAnalyze = handler; }
    bindSuggestions(handler) { this.onSuggestions = handler; }
    bindExport(handler) { this.onExport = handler; }

    /**
     * Rend l'interface complète du graphique.
     * @param {Array<PlotPoint>} plotPoints 
     * @param {string} activeTab - 'overview', 'analysis', 'suggestions'
     * @param {Object} data - Données pour les onglets (analysis, suggestions)
     */
    render(plotPoints, activeTab = 'overview', data = {}) {
        const container = document.getElementById(this.containerId);
        if (!container) {
            console.error('PlotView: container not found');
            return;
        }

        let mainContent = '';

        switch (activeTab) {
            case 'overview':
                mainContent = this._renderGraph(plotPoints);
                break;
            case 'analysis':
                mainContent = this._renderAnalysis(data.analysis);
                break;
            case 'suggestions':
                mainContent = this._renderSuggestions(data.suggestions);
                break;
            default:
                mainContent = this._renderGraph(plotPoints);
        }

        container.innerHTML = `
            <div style="padding: 2rem; height: 100%; display: flex; flex-direction: column;">
                ${this._renderHeader(plotPoints)}
                ${this._renderToolbar(activeTab)}
                <div class="visualization-canvas" style="flex: 1; overflow: auto; min-height: 0;">
                    ${mainContent}
                </div>
            </div>
        `;

        // Rendre les icônes lucide
        if (window.lucide) {
            window.lucide.createIcons();
        }
    }

    _renderGraph(plotPoints) {
        // Configuration SVG
        const svgWidth = 1000;
        const svgHeight = 700;
        const paddingX = 60;
        const paddingYTop = 40;
        const paddingYBottom = 180;

        const plotWidth = svgWidth - paddingX * 2;
        const plotHeight = svgHeight - paddingYTop - paddingYBottom;
        const axisY = svgHeight - paddingYBottom;

        // Génération composant par composant
        const gridLines = this._generateGridLines(svgWidth, paddingX, paddingYTop, plotHeight);
        const { pathData, pointsHTML, structuralLabels } = this._generateCurveAndPoints(plotPoints, plotWidth, plotHeight, paddingX, paddingYTop, axisY);

        return `
            <div class="plot-graph">
                <svg width="100%" height="${svgHeight}" viewBox="0 0 ${svgWidth} ${svgHeight}" id="plotSvg">
                    ${gridLines}
                    <path d="${pathData}" fill="none" stroke="var(--accent-gold)" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" />
                    ${pointsHTML}
                    <line x1="${paddingX}" y1="${axisY}" x2="${svgWidth - paddingX}" y2="${axisY}" stroke="var(--text-primary)" stroke-width="2"/>
                    <line x1="${paddingX}" y1="${paddingYTop}" x2="${paddingX}" y2="${axisY}" stroke="var(--text-primary)" stroke-width="2"/>
                    ${structuralLabels}
                    <text x="${svgWidth / 2}" y="${svgHeight - 10}" text-anchor="middle" fill="var(--text-muted)" font-size="11" opacity="0.4">Progression du récit</text>
                    <text x="20" y="${axisY / 2}" text-anchor="middle" fill="var(--text-muted)" font-size="13" transform="rotate(-90 20 ${axisY / 2})">Tension dramatique</text>
                </svg>
            </div>
            ${this._renderFooter()}
        `;
    }

    _renderAnalysis(data) {
        if (!data) return '<div class="empty-state">Aucune donnée d\'analyse disponible.</div>';

        const { stats, narrative } = data;

        return `
            <div class="analysis-container" style="max-width: 800px; margin: 0 auto; padding: 1rem;">
                <h2 style="margin-bottom: 2rem; border-bottom: 1px solid var(--border-color); padding-bottom: 0.5rem;">
                    <i data-lucide="scan-search" style="vertical-align: middle; margin-right: 10px;"></i> Analyse de l'Intrigue
                </h2>

                <div class="stats-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1.5rem; margin-bottom: 2rem;">
                    <div class="stat-card" style="background: var(--bg-secondary); padding: 1.5rem; border-radius: 8px;">
                        <div style="font-size: 0.85rem; color: var(--text-muted); margin-bottom: 0.5rem;">Tension Moyenne</div>
                        <div style="font-size: 2rem; font-weight: bold; color: var(--accent-gold);">${Math.round(stats.avg)}%</div>
                        <div style="font-size: 0.8rem; margin-top: 0.5rem;">
                            ${narrative.avgLow ? '<span style="color: #e67e22;"><i data-lucide="alert-triangle" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Un peu basse</span>' : narrative.avgHigh ? '<span style="color: #e74c3c;"><i data-lucide="alert-triangle" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Trop élevée</span>' : '<span style="color: #2ecc71;"><i data-lucide="check-circle" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Équilibrée</span>'}
                        </div>
                    </div>
                    <div class="stat-card" style="background: var(--bg-secondary); padding: 1.5rem; border-radius: 8px;">
                        <div style="font-size: 0.85rem; color: var(--text-muted); margin-bottom: 0.5rem;">Amplitude</div>
                        <div style="font-size: 2rem; font-weight: bold;">${Math.round(stats.amplitude)}%</div>
                        <div style="font-size: 0.8rem; margin-top: 0.5rem; color: var(--text-secondary);">Max: ${Math.round(stats.max)}% / Min: ${Math.round(stats.min)}%</div>
                    </div>
                    <div class="stat-card" style="background: var(--bg-secondary); padding: 1.5rem; border-radius: 8px;">
                        <div style="font-size: 0.85rem; color: var(--text-muted); margin-bottom: 0.5rem;">Variation</div>
                        <div style="font-size: 1.5rem; font-weight: bold;">${narrative.flatCurve ? 'Faible' : narrative.irregularCurve ? 'Forte' : 'Modérée'}</div>
                        <div style="font-size: 0.8rem; margin-top: 0.5rem; color: var(--text-secondary);">Écart-type: ${Math.round(stats.stdDev)}</div>
                    </div>
                </div>

                <div style="margin-bottom: 2rem;">
                    <h3 style="margin-bottom: 1rem;">Évaluation Narrative</h3>
                    <ul style="list-style: none; padding: 0;">
                        <li style="padding: 1rem; border-bottom: 1px solid var(--border-color); display: flex; align-items: start; gap: 1rem;">
                            ${narrative.climaxGood ? '<i data-lucide="check-circle" style="color: #2ecc71;"></i>' : '<i data-lucide="alert-triangle" style="color: #e67e22;"></i>'}
                            <div>
                                <strong>Position du Climax</strong><br>
                                ${narrative.climaxGood ? 'Le climax est bien placé dans le dernier tiers du récit.' : `Le climax semble arriver trop tôt (${narrative.climaxPercent}% du récit).`}
                            </div>
                        </li>
                        <li style="padding: 1rem; border-bottom: 1px solid var(--border-color); display: flex; align-items: start; gap: 1rem;">
                            ${narrative.isRising ? '<i data-lucide="check-circle" style="color: #2ecc71;"></i>' : '<i data-lucide="alert-triangle" style="color: #e67e22;"></i>'}
                            <div>
                                <strong>Progression de la Tension</strong><br>
                                ${narrative.isRising ? 'La tension monte globalement vers la fin, ce qui maintient l\'intérêt.' : 'La tension semble décroître en moyenne sur la seconde moitié.'}
                            </div>
                        </li>
                        <li style="padding: 1rem; border-bottom: 1px solid var(--border-color); display: flex; align-items: start; gap: 1rem;">
                            ${!narrative.noPeaks && !narrative.tooManyPeaks ? '<i data-lucide="check-circle" style="color: #2ecc71;"></i>' : '<i data-lucide="alert-triangle" style="color: #e67e22;"></i>'}
                            <div>
                                <strong>Rythme et Pics</strong><br>
                                ${narrative.noPeaks ? 'Aucun pic de tension majeur détecté. Le récit risque d\'être monotone.' : narrative.tooManyPeaks ? 'Beaucoup de pics détectés. Le lecteur pourrait manquer de temps pour souffler.' : `Nombre de pics de tension approprié (${stats.peaks}).`}
                            </div>
                        </li>
                    </ul>
                </div>
            </div>
        `;
    }

    _renderSuggestions(data) {
        if (!data) return '<div class="empty-state">Aucune suggestion disponible.</div>';

        return `
            <div class="suggestions-container" style="max-width: 800px; margin: 0 auto; padding: 1rem;">
                <h2 style="margin-bottom: 2rem; border-bottom: 1px solid var(--border-color); padding-bottom: 0.5rem;">
                    <i data-lucide="lightbulb" style="vertical-align: middle; margin-right: 10px;"></i> Suggestions d'Amélioration
                </h2>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem;">
                    <div>
                        <h3 style="color: var(--accent-gold); margin-bottom: 1rem;">Diagnostic</h3>
                        ${data.flatZonesCount > 0 ? `
                            <div class="suggestion-card" style="background: rgba(230, 126, 34, 0.1); border-left: 4px solid #e67e22; padding: 1rem; margin-bottom: 1rem;">
                                <strong><i data-lucide="trending-down" style="width:16px;height:16px;vertical-align:middle;margin-right:4px;"></i>Zones Plates Détectées</strong>
                                <p>${data.flatZonesCount} séquences manquent de variation. Pensez à ajouter des rebondissements ou à alterner le rythme.</p>
                            </div>
                        ` : ''}
                        
                        ${data.avgLow ? `
                            <div class="suggestion-card" style="background: rgba(231, 76, 60, 0.1); border-left: 4px solid #e74c3c; padding: 1rem; margin-bottom: 1rem;">
                                <strong><i data-lucide="flame" style="width:16px;height:16px;vertical-align:middle;margin-right:4px;"></i>Tension Globale Basse</strong>
                                <p>Votre histoire pourrait bénéficier de plus de conflits. Augmentez les enjeux pour vos personnages.</p>
                            </div>
                        ` : ''}

                         ${data.avgHigh ? `
                            <div class="suggestion-card" style="background: rgba(52, 152, 219, 0.1); border-left: 4px solid #3498db; padding: 1rem; margin-bottom: 1rem;">
                                <strong><i data-lucide="coffee" style="width:16px;height:16px;vertical-align:middle;margin-right:4px;"></i>Tension Très Élevée</strong>
                                <p>Le rythme est très soutenu. N'oubliez pas d'offrir des moments de répit au lecteur (scènes de suite).</p>
                            </div>
                        ` : ''}
                    </div>

                    <div>
                        <h3 style="color: var(--text-primary); margin-bottom: 1rem;">Boîte à Outils</h3>
                        
                        <div style="margin-bottom: 1.5rem;">
                            <strong>Pour augmenter la tension :</strong>
                            <ul style="margin-top: 0.5rem; color: var(--text-secondary);">
                                <li>Ajoutez une contrainte de temps (deadline)</li>
                                <li>Mettez en danger quelque chose que le héros aime</li>
                                <li>Révélez un secret dévastateur</li>
                                <li>Créez un dilemme moral impossible</li>
                            </ul>
                        </div>

                        <div>
                            <strong>Pour diminuer la tension :</strong>
                            <ul style="margin-top: 0.5rem; color: var(--text-secondary);">
                                <li>Résolvez un sous-conflit</li>
                                <li>Offrez une victoire temporaire</li>
                                <li>Scène d'intimité ou de camaraderie</li>
                                <li>Description contemplative ou humoristique</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <div style="margin-top: 2rem; padding: 1.5rem; background: var(--bg-secondary); border-radius: 8px;">
                    <h3 style="margin-bottom: 1rem;">Structure Recommandée</h3>
                    <div style="display: flex; height: 20px; width: 100%; border-radius: 10px; overflow: hidden; margin-bottom: 1rem;">
                        <div style="width: 25%; background: #3498db; opacity: 0.6;" title="Début"></div>
                        <div style="width: 40%; background: #f1c40f; opacity: 0.6;" title="Milieu"></div>
                        <div style="width: 25%; background: #e74c3c; opacity: 0.8;" title="Climax"></div>
                        <div style="width: 10%; background: #2ecc71; opacity: 0.6;" title="Résolution"></div>
                    </div>
                    <div style="display: flex; justify-content: space-between; font-size: 0.8rem; color: var(--text-muted);">
                        <span>Début (20-40%)</span>
                        <span>Milieu (40-60%)</span>
                        <span>Climax (60-90%)</span>
                        <span>Fin</span>
                    </div>
                </div>
            </div>
        `;
    }

    _renderToolbar(activeTab) {
        return `
            <div class="visualization-toolbar">
                <button class="viz-tool-btn ${activeTab === 'overview' ? 'active' : ''}" onclick="window.plumePlot.showOverview()">Vue d'ensemble</button>
                <button class="viz-tool-btn ${activeTab === 'analysis' ? 'active' : ''}" onclick="analyzePlotCurve()"><i data-lucide="scan-search" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i> Analyser la courbe</button>
                <button class="viz-tool-btn ${activeTab === 'suggestions' ? 'active' : ''}" onclick="showPlotSuggestions()"><i data-lucide="lightbulb" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Suggestions</button>
                <button class="viz-tool-btn" onclick="resetPlotPoints()"><i data-lucide="refresh-cw" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i> Recalculer</button>
                <button class="viz-tool-btn" onclick="exportPlot()"><i data-lucide="upload" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i> Exporter</button>
            </div>
        `;
    }


    // _attachEventListeners supprimé car on utilise les attributs onclick globaux pour plus de robustesse avec innerHTML
    _generateGridLines(width, paddingX, startY, height) {
        let lines = '';
        for (let i = 0; i <= 4; i++) {
            const y = startY + (height / 4) * i;
            lines += `<line x1="${paddingX}" y1="${y}" x2="${width - paddingX}" y2="${y}" stroke="var(--border-color)" stroke-width="1" opacity="0.3" stroke-dasharray="5,5"/>`;
            lines += `<text x="${paddingX - 10}" y="${y + 5}" text-anchor="end" font-size="12" fill="var(--text-muted)">${100 - i * 25}%</text>`;
        }
        return lines;
    }

    _generateCurveAndPoints(points, width, height, paddingX, startY, axisY) {
        let pathData = '';
        let pointsHTML = '';
        let structuralLabels = '';
        let currentActRef = null;
        let currentChapterRef = null;

        if (points.length > 0) {
            points.forEach((point, index) => {
                const x = paddingX + (width / Math.max(points.length - 1, 1)) * index;
                const y = startY + height - (point.intensity / 100) * height;

                if (index === 0) pathData = `M ${x} ${y}`;
                else pathData += ` L ${x} ${y}`;

                // Labels structurels
                const structuralInfo = point.description.split(' > ');
                const actTitle = structuralInfo[0];
                const chapterTitle = structuralInfo[1];

                if (actTitle !== currentActRef) {
                    structuralLabels += `
                        <line x1="${x}" y1="${axisY}" x2="${x}" y2="${axisY + 40}" stroke="var(--accent-gold)" stroke-width="2" />
                        <text x="${x + 5}" y="${axisY + 15}" fill="var(--accent-gold)" font-weight="bold" font-size="12" transform="rotate(45 ${x + 5} ${axisY + 15})">${actTitle}</text>
                    `;
                    currentActRef = actTitle;
                }

                if (chapterTitle !== currentChapterRef) {
                    structuralLabels += `
                        <line x1="${x}" y1="${axisY}" x2="${x}" y2="${axisY + 10}" stroke="var(--border-color)" stroke-width="1" />
                        <text x="${x}" y="${axisY + 50}" fill="var(--text-muted)" font-size="10" transform="rotate(60 ${x} ${axisY + 50})">${chapterTitle}</text>
                    `;
                    currentChapterRef = chapterTitle;
                }

                pointsHTML += `
                    <g style="cursor: pointer;" onclick="window.plumePlot.openPoint('${point.actId}', '${point.chapterId}', '${point.sceneId}')" oncontextmenu="event.preventDefault(); window.plumePlot.openPoint('${point.actId}', '${point.chapterId}', '${point.sceneId}')">
                        <circle cx="${x}" cy="${y}" r="12" fill="transparent" />
                        <circle cx="${x}" cy="${y}" r="6" fill="var(--accent-gold)" stroke="white" stroke-width="2" class="plot-point-dot" />
                        <title>${point.description}\n--------------------------------\nTension: ${Math.round(point.intensity)}%\n--------------------------------\nClic pour ouvrir la scène</title>
                    </g>
                `;
            });
        }
        return { pathData, pointsHTML, structuralLabels };
    }

    _renderHeader(points) {
        const avgTension = points.length > 0 ? Math.round(points.reduce((sum, p) => sum + p.intensity, 0) / points.length) : 0;

        return `
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
                <div>
                    <h3 style="margin: 0;"><i data-lucide="trending-up" style="width:18px;height:18px;vertical-align:middle;margin-right:6px;"></i>Graphique d'Intrigue</h3>
                    <div style="font-size: 0.85rem; color: var(--text-secondary); margin-top: 0.5rem;">
                        <i data-lucide="bar-chart-3" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i> ${points.length} point(s) d'intrigue • <i data-lucide="target" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i> Tension moyenne: ${avgTension}%
                    </div>
                </div>
                <!-- Le bouton "Personnaliser" utilise une fonction globale externe à ce module (openTensionWordsEditor) -->
                <button onclick="if(typeof openTensionWordsEditor === 'function') openTensionWordsEditor()" 
                        style="padding: 10px 18px; background: #3a7bc8; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.9rem; font-weight: 500; transition: all 0.2s; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"
                        onmouseover="this.style.background='#2d6bb3'; this.style.boxShadow='0 4px 8px rgba(0,0,0,0.15)'"
                        onmouseout="this.style.background='#3a7bc8'; this.style.boxShadow='0 2px 4px rgba(0,0,0,0.1)'">
                    <i data-lucide="pencil" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i> Personnaliser les mots de tension
                </button>
            </div>
        `;
    }

    _renderFooter() {
        return `
            <div style="margin-top: 1rem; padding: 1rem; background: var(--bg-secondary); border-radius: 4px;">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                    <div>
                        <p style="font-size: 0.9rem; color: var(--text-secondary); line-height: 1.6; margin: 0;">
                            <i data-lucide="lightbulb" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;color:var(--accent-gold);"></i> <strong>Utilisation:</strong><br>
                            • <strong>Clic</strong> sur un point → Ouvrir la scène pour l'éditer<br>
                            • <strong>Affichage</strong> → Survoler un point pour voir : Acte > Chapitre > Scène<br>
                            • <strong>Intégration</strong> → La tension est calculée automatiquement selon votre texte<br>
                            • <strong>Analyser</strong> → Obtenez un rapport complet sur votre courbe<br>
                            • <strong>Suggestions</strong> → Conseils personnalisés pour améliorer l'intrigue
                        </p>
                    </div>
                    <div style="padding: 0.75rem; background: var(--bg-primary); border-radius: 4px; border: 1px solid var(--border-color);">
                        <div style="font-size: 0.85rem; font-weight: 600; margin-bottom: 0.5rem; color: var(--text-primary);">Calcul de la tension :</div>
                        <div style="font-size: 0.75rem; line-height: 1.6; color: var(--text-secondary);">
                            • Analyse lexicale (mots-clés personnalisables)<br>
                            • Longueur de la scène<br>
                            • Ponctuation expressive<br>
                            • Position narrative (structure en 3 actes)
                        </div>
                    </div>
                </div>
            </div>
        `;
    }
}

// ========== js-refactor/plot/plot.init.js ==========
/**
 * Point d'entrée pour le module Plot
 * Initialise le modèle, la vue et le view-model, et expose l'API publique.
 */

(function () {
    // Initialisation
    const repository = new PlotRepository();
    const view = new PlotView();
    const viewModel = new PlotViewModel(repository, view);

    // Namespace global pour le module Plot
    window.plumePlot = {
        init: () => viewModel.init(),
        render: () => viewModel.loadAndRender(),
        showOverview: () => viewModel.showOverview(),
        openPoint: (a, c, s) => viewModel.openPoint(a, c, s),
        // Méthodes exposées pour compatibilité avec d'autres modules si nécessaire
        reset: () => viewModel.resetPoints()
    };

    // Fonctions globales pour la rétrocompatibilité (appelées depuis le HTML existant ou autres modules)
    window.renderPlotView = () => viewModel.loadAndRender();

    // Ces fonctions étaient globales dans le fichier original, on les garde pour ne pas casser l'existant
    window.calculateSceneTension = (scene, a, ta, c, tc, s, ts) => {
        // Adapter les arguments plats au format context object attendu par le nouveau modèle
        // Note: c'est un wrapper de compatibilité. Le calcul complet nécessite les objets Act/Chapter réels généralement.
        // Si cette fonction est appelée de l'extérieur avec juste des index, ça risque d'être limité pour calculateLiveTension qui veut des IDs.
        // On fait au mieux.
        const context = {
            // On ne peut pas facilement reconstruire l'objet act/chapter juste avec des index ici sans accès à project
            // Mais le nouveau modèle gère ça.
            // Pour l'instant, on redirige vers une version simplifiée ou on essaie de récupérer le contexte si project est dispo.
        };

        if (typeof project !== 'undefined') {
            const act = project.acts[a];
            const chapter = act ? act.chapters[c] : null;
            context.act = act;
            context.chapter = chapter;
        }

        return PlotModel.calculateSceneTension(scene, context);
    };

    // Fonctions boutons précédemment globales
    window.analyzePlotCurve = () => viewModel.analyzeCurve();
    window.showPlotSuggestions = () => viewModel.showSuggestions();
    window.resetPlotPoints = () => viewModel.resetPoints();
    window.exportPlot = () => viewModel.exportPlot();
    // openPlotPoint existait déjà globalement
    window.openPlotPoint = (a, c, s) => viewModel.openPoint(a, c, s);

    // Initialisation explicite
    viewModel.init();

})();

// ========== js/34.relations-graph.js ==========
// ============================================
// RELATIONS GRAPH FUNCTIONS
// ============================================

// [MVVM : Other]
// Group: Coordinator | Naming: RelationsCoordinator
// Génère et affiche la vue globale du graphe des relations, incluant le calcul des positions et le rendu HTML/SVG.
function renderRelationsView() {
    const editorView = document.getElementById('editorView');
    if (!editorView) {
        console.error('editorView not found');
        return;
    }

    // S'assurer que relations existe
    if (!project.relations) project.relations = [];

    // S'assurer que les positions personnalisées existent
    if (!project.characterPositions) project.characterPositions = {};

    // Types de relations avec couleurs
    const relationTypes = {
        'amour': { color: '#e91e63', label: 'Amour', icon: 'heart' },
        'amitie': { color: '#4caf50', label: 'Amitié', icon: 'handshake' },
        'rivalite': { color: '#f44336', label: 'Rivalité', icon: 'swords' },
        'famille': { color: '#2196f3', label: 'Famille', icon: 'house' },
        'mentor': { color: '#ff9800', label: 'Mentor', icon: 'graduation-cap' },
        'ennemi': { color: '#9c27b0', label: 'Ennemi', icon: 'skull' },
        'alliance': { color: '#00bcd4', label: 'Alliance', icon: 'shield' },
        'neutre': { color: '#757575', label: 'Neutre', icon: 'meh' }
    };

    let graphHTML = '';
    if (project.characters.length >= 2) {
        const centerX = 400;
        const centerY = 350;
        const radius = 220;

        // Calculer les positions (personnalisées ou par défaut en cercle)
        const positions = project.characters.map((char, i) => {
            if (project.characterPositions[char.id]) {
                return project.characterPositions[char.id];
            } else {
                const angle = (i / project.characters.length) * 2 * Math.PI;
                return {
                    x: centerX + radius * Math.cos(angle),
                    y: centerY + radius * Math.sin(angle)
                };
            }
        });

        // SVG pour les lignes de relation
        let svgLines = '<svg id="relationsSvg" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0; pointer-events: none;">';

        // Dessiner les relations existantes
        project.relations.forEach(rel => {
            const char1 = project.characters.find(c => c.id === rel.char1Id);
            const char2 = project.characters.find(c => c.id === rel.char2Id);

            if (char1 && char2) {
                const i1 = project.characters.indexOf(char1);
                const i2 = project.characters.indexOf(char2);

                const x1 = positions[i1].x;
                const y1 = positions[i1].y;
                const x2 = positions[i2].x;
                const y2 = positions[i2].y;

                const relType = relationTypes[rel.type] || relationTypes['neutre'];

                svgLines += `
                            <line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" 
                                  stroke="${relType.color}" 
                                  stroke-width="3" 
                                  opacity="0.7"
                                  style="cursor: pointer;"
                                  onclick="editRelation('${rel.id}')"/>
                            <foreignObject x="${(x1 + x2) / 2 - 10}" y="${(y1 + y2) / 2 - 25}" width="20" height="20" style="pointer-events: none;">
                                <div xmlns="http://www.w3.org/1999/xhtml" style="color:${relType.color}; display:flex; align-items:center; justify-content:center;">
                                    <i data-lucide="${relType.icon}" style="width:16px;height:16px;"></i>
                                </div>
                            </foreignObject>
                        `;
            }
        });

        svgLines += '</svg>';

        // Positionner les personnages (draggables)
        project.characters.forEach((char, i) => {
            const pos = positions[i];

            graphHTML += `
                        <div id="char-node-${char.id}" 
                             class="char-node-draggable"
                             data-char-id="${char.id}"
                             style="position: absolute; left: ${pos.x}px; top: ${pos.y}px; transform: translate(-50%, -50%); text-align: center; cursor: move;"
                             onmousedown="startDragCharacter(event, ${char.id})"
                             onclick="handleCharacterClick(event, ${char.id})">
                            <div style="width: 70px; height: 70px; border-radius: 50%; background: var(--accent-gold); 
                                        display: flex; align-items: center; justify-content: center; font-size: 2rem;
                                        border: 3px solid white; box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                                        ${selectedCharsForRelation.includes(char.id) ? 'border-color: var(--accent-red); border-width: 5px;' : ''}
                                        transition: transform 0.2s;">
                                ${char.avatar ? char.avatar : '<i data-lucide="user" style="width:40px;height:40px;color:white;"></i>'}
                            </div>
                            <div style="margin-top: 0.5rem; font-weight: 600; font-size: 0.9rem; background: var(--bg-accent); color: white;
                                        padding: 0.25rem 0.5rem; border-radius: 4px; white-space: nowrap; pointer-events: none;">${char.name}</div>
                        </div>
                    `;
        });

        graphHTML = svgLines + graphHTML;
    } else {
        graphHTML = `
                    <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center;">
                        <div style="font-size: 4rem; margin-bottom: 1rem;"><i data-lucide="users" style="width:64px;height:64px;"></i></div>
                        <div style="font-size: 1.3rem; font-weight: 600; margin-bottom: 0.5rem;">Aucune relation à afficher</div>
                        <div style="color: var(--text-muted); margin-bottom: 1rem;">Créez au moins 2 personnages pour visualiser leurs relations</div>
                        <button class="btn btn-primary" onclick="switchView('characters')">+ Créer des personnages</button>
                    </div>
                `;
    }

    editorView.innerHTML = `
                <div style="height: 100%; overflow-y: auto; padding: 2rem 3rem;">
                    <h2 style="margin-bottom: 2rem; color: var(--accent-gold);"><i data-lucide="network" style="width:24px;height:24px;vertical-align:middle;margin-right:8px;"></i>Carte des Relations</h2>
                    
                    ${project.characters.length >= 2 ? `
                        <div style="margin-bottom: 2rem; display: flex; gap: 1rem; flex-wrap: wrap;">
                            <div style="flex: 1; min-width: 300px; padding: 1.5rem; background: var(--bg-secondary); border-radius: 8px; border-left: 4px solid var(--accent-gold);">
                                <div style="font-weight: 600; margin-bottom: 0.5rem;"><i data-lucide="pen-line" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Créer une relation:</div>
                                <div style="font-size: 0.9rem; color: var(--text-secondary); line-height: 1.6;">
                                    1. Cliquez sur un premier personnage<br>
                                    2. Cliquez sur un second personnage<br>
                                    3. Choisissez le type de relation
                                </div>
                            </div>
                            <div style="flex: 1; min-width: 300px; padding: 1.5rem; background: var(--bg-secondary); border-radius: 8px; border-left: 4px solid var(--accent-red);">
                                <div style="font-weight: 600; margin-bottom: 0.5rem;"><i data-lucide="move" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i> Déplacer les personnages:</div>
                                <div style="font-size: 0.9rem; color: var(--text-secondary); line-height: 1.6;">
                                    Faites glisser les personnages pour réorganiser le graphe<br>
                                    Les liens suivent automatiquement
                                </div>
                            </div>
                        </div>
                        <div style="margin-bottom: 1rem; display: flex; gap: 0.5rem;">
                            <button class="btn btn-small" onclick="resetCharacterPositions()"><i data-lucide="refresh-cw" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i> Réinitialiser positions</button>
                            <button class="btn btn-small" onclick="autoArrangeCharacters()"><i data-lucide="sparkles" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Arranger automatiquement</button>
                        </div>
                    ` : ''}
                    
                    <div id="relationsGraph" style="position: relative; height: 700px; background: var(--bg-secondary); border-radius: 8px; margin-bottom: 2rem;">
                        ${graphHTML}
                    </div>
                    
                    ${project.characters.length >= 2 ? `
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1rem; margin-bottom: 2rem;">
                            ${Object.entries(relationTypes).map(([key, rel]) => `
                                <div style="display: flex; align-items: center; gap: 0.75rem; padding: 1rem; background: var(--bg-secondary); border-radius: 8px; border-left: 4px solid ${rel.color};">
                                    <div style="font-size: 1.5rem; color: ${rel.color};"><i data-lucide="${rel.icon}" style="width:24px;height:24px;"></i></div>
                                    <div style="flex: 1;">
                                        <div style="font-weight: 600; font-size: 0.95rem;">${rel.label}</div>
                                        <div style="font-size: 0.75rem; color: var(--text-muted);">${getRelationCount(key)} relation(s)</div>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    ` : ''}
                    
                    ${project.relations && project.relations.length > 0 ? `
                        <div style="background: var(--bg-secondary); padding: 1.5rem; border-radius: 8px;">
                            <h3 style="margin-bottom: 1rem; color: var(--text-primary);"><i data-lucide="list" style="width:18px;height:18px;vertical-align:middle;margin-right:6px;"></i>Liste des relations (${project.relations.length})</h3>
                            <div style="display: flex; flex-direction: column; gap: 0.75rem;">
                                ${project.relations.map(rel => {
        const char1 = project.characters.find(c => c.id === rel.char1Id);
        const char2 = project.characters.find(c => c.id === rel.char2Id);
        const relType = relationTypes[rel.type] || relationTypes['neutre'];
        return char1 && char2 ? `
                                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 1rem; background: var(--bg-primary); border-radius: 4px; border-left: 4px solid ${relType.color};">
                                            <div style="display: flex; align-items: center; gap: 1rem;">
                                                <span style="font-size: 1.5rem; color: ${relType.color};"><i data-lucide="${relType.icon}" style="width:20px;height:20px;"></i></span>
                                                <span style="font-weight: 600;">${char1.name}</span>
                                                <span style="color: var(--text-muted);"><i data-lucide="split" style="width:14px;height:14px;transform: rotate(90deg);"></i></span>
                                                <span style="font-weight: 600;">${char2.name}</span>
                                                ${rel.description ? `<span style="color: var(--text-muted); font-size: 0.85rem;">· ${rel.description}</span>` : ''}
                                            </div>
                                            <div style="display: flex; gap: 0.5rem;">
                                                <button class="btn btn-small" onclick="editRelation('${rel.id}')"><i data-lucide="pencil" style="width:14px;height:14px;"></i></button>
                                                <button class="btn btn-small" onclick="deleteRelation('${rel.id}')"><i data-lucide="trash-2" style="width:14px;height:14px;"></i></button>
                                            </div>
                                        </div>
                                    ` : '';
    }).join('')}
                            </div>
                        </div>
                    ` : ''}
                </div>
            `;

    // Ajouter les événements de hover sur les personnages
    setTimeout(() => {
        document.querySelectorAll('.char-node-draggable').forEach(node => {
            node.addEventListener('mouseenter', () => {
                node.querySelector('div').style.transform = 'scale(1.1)';
            });
            node.addEventListener('mouseleave', () => {
                node.querySelector('div').style.transform = 'scale(1)';
            });
        });
    }, 0);
}

// Variables pour le drag-and-drop
let draggedCharId = null;
let dragStartX = 0;
let dragStartY = 0;
let isDragging = false;
let dragMoved = false;

// [MVVM : ViewModel]
// Initialise le processus de glisser-déposer pour un personnage.
function startDragCharacter(event, charId) {
    event.preventDefault();
    draggedCharId = charId;
    dragStartX = event.clientX;
    dragStartY = event.clientY;
    isDragging = true;
    dragMoved = false;

    document.addEventListener('mousemove', dragCharacter);
    document.addEventListener('mouseup', stopDragCharacter);
}

// [MVVM : Other]
// Group: Util / Helper | Naming: GraphUtils
// Gère le mouvement du personnage pendant le drag, met à jour sa position DOM et les lignes de relation.
function dragCharacter(event) {
    if (!isDragging || !draggedCharId) return;

    const deltaX = event.clientX - dragStartX;
    const deltaY = event.clientY - dragStartY;

    // Considérer comme un drag si mouvement > 5px
    if (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5) {
        dragMoved = true;
    }

    const node = document.getElementById(`char-node-${draggedCharId}`);
    if (!node) return;

    const graph = document.getElementById('relationsGraph');
    const graphRect = graph.getBoundingClientRect();

    // Position actuelle
    const currentLeft = parseFloat(node.style.left);
    const currentTop = parseFloat(node.style.top);

    // Nouvelle position
    let newLeft = currentLeft + deltaX;
    let newTop = currentTop + deltaY;

    // Limiter aux bords du graphe
    newLeft = Math.max(50, Math.min(graphRect.width - 50, newLeft));
    newTop = Math.max(50, Math.min(graphRect.height - 50, newTop));

    node.style.left = newLeft + 'px';
    node.style.top = newTop + 'px';

    dragStartX = event.clientX;
    dragStartY = event.clientY;

    // Mettre à jour les lignes SVG
    updateRelationLines();
}

// [MVVM : Other]
// Group: Util / Helper | Naming: GraphUtils
// Termine le glisser-déposer, enregistre la nouvelle position dans le modèle et sauvegarde le projet.
function stopDragCharacter(event) {
    if (!isDragging) return;

    document.removeEventListener('mousemove', dragCharacter);
    document.removeEventListener('mouseup', stopDragCharacter);

    if (dragMoved) {
        // Sauvegarder la nouvelle position
        const node = document.getElementById(`char-node-${draggedCharId}`);
        if (node) {
            if (!project.characterPositions) project.characterPositions = {};
            project.characterPositions[draggedCharId] = {
                x: parseFloat(node.style.left),
                y: parseFloat(node.style.top)
            };
            saveProject();
            showNotification('📍 Position sauvegardée');
        }
    }

    isDragging = false;
    draggedCharId = null;
    dragMoved = false;
}

// [MVVM : ViewModel]
// Gère le clic sur un personnage, en distinguant le simple clic du glissement.
function handleCharacterClick(event, charId) {
    // Ne pas traiter comme un clic si c'était un drag
    if (dragMoved) {
        event.stopPropagation();
        return;
    }

    selectCharacterForRelation(charId);
}

// [MVVM : View]
// Met à jour dynamiquement les lignes SVG représentant les relations entre les personnages.
function updateRelationLines() {
    const svg = document.getElementById('relationsSvg');
    if (!svg) return;

    const relationTypes = {
        'amour': { color: '#e91e63', icon: '❤️' },
        'amitie': { color: '#4caf50', icon: '🤝' },
        'rivalite': { color: '#f44336', icon: '⚔️' },
        'famille': { color: '#2196f3', icon: '👨‍👩‍👧' },
        'mentor': { color: '#ff9800', icon: '📚' },
        'ennemi': { color: '#9c27b0', icon: '💀' },
        'alliance': { color: '#00bcd4', icon: '🤜🤛' },
        'neutre': { color: '#757575', icon: '😐' }
    };

    let svgContent = '';

    project.relations.forEach(rel => {
        const char1 = project.characters.find(c => c.id === rel.char1Id);
        const char2 = project.characters.find(c => c.id === rel.char2Id);

        if (char1 && char2) {
            const node1 = document.getElementById(`char-node-${char1.id}`);
            const node2 = document.getElementById(`char-node-${char2.id}`);

            if (node1 && node2) {
                const x1 = parseFloat(node1.style.left);
                const y1 = parseFloat(node1.style.top);
                const x2 = parseFloat(node2.style.left);
                const y2 = parseFloat(node2.style.top);

                const relType = relationTypes[rel.type] || relationTypes['neutre'];

                svgContent += `
                            <line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" 
                                  stroke="${relType.color}" 
                                  stroke-width="3" 
                                  opacity="0.7"
                                  style="cursor: pointer;"
                                  onclick="editRelation('${rel.id}')"/>
                            <foreignObject x="${(x1 + x2) / 2 - 10}" y="${(y1 + y2) / 2 - 25}" width="20" height="20" style="pointer-events: none;">
                                <div xmlns="http://www.w3.org/1999/xhtml" style="color:${relType.color}; display:flex; align-items:center; justify-content:center;">
                                    <i data-lucide="${relType.icon}" style="width:16px;height:16px;"></i>
                                </div>
                            </foreignObject>
                        `;
            }
        }
    });

    svg.innerHTML = svgContent;
}

// [MVVM : ViewModel]
// Réinitialise toutes les positions personnalisées des personnages dans le modèle.
function resetCharacterPositions() {
    if (confirm('Réinitialiser toutes les positions des personnages ?')) {
        project.characterPositions = {};
        saveProject();
        renderRelationsView();
        showNotification('🔄 Positions réinitialisées');
    }
}

// [MVVM : ViewModel]
// Calcule et applique automatiquement une disposition en cercle pour tous les personnages.
function autoArrangeCharacters() {
    // Arranger en cercle avec plus d'espace
    const centerX = 400;
    const centerY = 350;
    const radius = 220;

    project.characterPositions = {};
    project.characters.forEach((char, i) => {
        const angle = (i / project.characters.length) * 2 * Math.PI;
        project.characterPositions[char.id] = {
            x: centerX + radius * Math.cos(angle),
            y: centerY + radius * Math.sin(angle)
        };
    });

    saveProject();
    renderRelationsView();
    showNotification('✨ Personnages arrangés automatiquement');
}

// Variables pour la sélection de personnages
let selectedCharsForRelation = [];

// [MVVM : ViewModel]
// Gère la sélection séquentielle de deux personnages pour créer une nouvelle relation.
function selectCharacterForRelation(charId) {
    if (selectedCharsForRelation.includes(charId)) {
        // Désélectionner
        selectedCharsForRelation = selectedCharsForRelation.filter(id => id !== charId);
    } else {
        selectedCharsForRelation.push(charId);
    }

    // Si 2 personnages sélectionnés, demander le type de relation
    if (selectedCharsForRelation.length === 2) {
        createRelationModal();
    } else {
        renderRelationsView();
    }
}

// [MVVM : View]
// Affiche la boîte de dialogue modale permettant de définir les détails d'une nouvelle relation.
function createRelationModal() {
    const char1 = project.characters.find(c => c.id === selectedCharsForRelation[0]);
    const char2 = project.characters.find(c => c.id === selectedCharsForRelation[1]);

    const relationTypes = {
        'amour': { color: '#e91e63', label: 'Amour', icon: 'heart' },
        'amitie': { color: '#4caf50', label: 'Amitié', icon: 'handshake' },
        'rivalite': { color: '#f44336', label: 'Rivalité', icon: 'swords' },
        'famille': { color: '#2196f3', label: 'Famille', icon: 'house' },
        'mentor': { color: '#ff9800', label: 'Mentor', icon: 'graduation-cap' },
        'ennemi': { color: '#9c27b0', label: 'Ennemi', icon: 'skull' },
        'alliance': { color: '#00bcd4', label: 'Alliance', icon: 'shield' },
        'neutre': { color: '#757575', label: 'Neutre', icon: 'meh' }
    };

    const modalHTML = `
                <div class="modal active" id="relationModal" onclick="if(event.target===this) closeRelationModal()">
                    <div class="modal-content" style="max-width: 500px;">
                        <h2 style="margin-bottom: 1.5rem;"><i data-lucide="link" style="width:20px;height:20px;vertical-align:middle;margin-right:6px;"></i>Créer une relation</h2>
                        
                        <div style="margin-bottom: 1.5rem; padding: 1rem; background: var(--bg-secondary); border-radius: 8px; text-align: center;">
                            <span style="font-weight: 600; font-size: 1.1rem;">${char1.name}</span>
                            <span style="margin: 0 1rem; color: var(--text-muted);">↔</span>
                            <span style="font-weight: 600; font-size: 1.1rem;">${char2.name}</span>
                        </div>
                        
                        <div style="margin-bottom: 1.5rem;">
                            <label style="display: block; font-weight: 600; margin-bottom: 0.75rem;">Type de relation:</label>
                            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.5rem;">
                                ${Object.entries(relationTypes).map(([key, rel]) => `
                                    <button class="btn" onclick="selectRelationType('${key}')" 
                                            id="relType-${key}"
                                            style="justify-content: flex-start; text-align: left; padding: 0.75rem; display: flex; align-items: center; gap: 0.5rem;">
                                        <div style="width: 4px; height: 100%; background: ${rel.color}; position: absolute; left: 0; top: 0; bottom: 0;"></div>
                                        <i data-lucide="${rel.icon}" style="width:16px;height:16px;color:${rel.color};"></i>
                                        ${rel.label}
                                    </button>
                                `).join('')}
                            </div>
                        </div>
                        
                        <div style="margin-bottom: 1.5rem;">
                            <label style="display: block; font-weight: 600; margin-bottom: 0.5rem;">Description (optionnel):</label>
                            <input type="text" class="form-input" id="relationDescription" placeholder="Ex: Frère et sœur, alliés depuis l'enfance...">
                        </div>
                        
                        <div style="display: flex; gap: 0.5rem; justify-content: flex-end;">
                            <button class="btn" onclick="closeRelationModal()">Annuler</button>
                            <button class="btn btn-primary" onclick="saveRelation()" id="saveRelationBtn" disabled>Créer la relation</button>
                        </div>
                    </div>
                </div>
            `;

    document.body.insertAdjacentHTML('beforeend', modalHTML);
}

let selectedRelationType = null;

// [MVVM : ViewModel]
// Enregistre temporairement le type de relation sélectionné dans l'interface de création.
function selectRelationType(type) {
    selectedRelationType = type;

    // Mettre à jour l'UI
    document.querySelectorAll('[id^="relType-"]').forEach(btn => {
        btn.classList.remove('btn-primary');
    });
    document.getElementById(`relType-${type}`).classList.add('btn-primary');
    document.getElementById('saveRelationBtn').disabled = false;
}

// [MVVM : ViewModel]
// Crée l'objet relation, l'ajoute au modèle du projet et déclenche la sauvegarde et le rafraîchissement.
function saveRelation() {
    if (!selectedRelationType) return;

    const description = document.getElementById('relationDescription').value;

    if (!project.relations) project.relations = [];

    project.relations.push({
        id: 'rel_' + Date.now(),
        char1Id: selectedCharsForRelation[0],
        char2Id: selectedCharsForRelation[1],
        type: selectedRelationType,
        description: description,
        createdAt: new Date().toISOString()
    });

    saveProject();
    closeRelationModal();
    selectedCharsForRelation = [];
    selectedRelationType = null;
    renderRelationsView();
    showNotification('🔗 Relation créée');
}

// [MVVM : ViewModel]
// Ferme la modale de création de relation et réinitialise l'état de sélection.
function closeRelationModal() {
    const modal = document.getElementById('relationModal');
    if (modal) modal.remove();
    selectedCharsForRelation = [];
    selectedRelationType = null;
    renderRelationsView();
}

// [MVVM : Model]
// Compte le nombre de relations d'un type spécifique présentes dans les données du projet.
function getRelationCount(type) {
    if (!project.relations) return 0;
    return project.relations.filter(r => r.type === type).length;
}

// [MVVM : ViewModel]
// Permet de modifier la description d'une relation existante via une invite de commande.
function editRelation(relId) {
    const relation = project.relations.find(r => r.id === relId);
    if (!relation) return;

    // Pour l'instant, juste permettre de changer la description
    const newDesc = prompt('Modifier la description:', relation.description || '');
    if (newDesc !== null) {
        relation.description = newDesc;
        saveProject();
        renderRelationsView();
        showNotification('✏️ Relation modifiée');
    }
}

// [MVVM : ViewModel]
// Supprime une relation du modèle après confirmation de l'utilisateur.
function deleteRelation(relId) {
    if (confirm('Supprimer cette relation ?')) {
        project.relations = project.relations.filter(r => r.id !== relId);
        saveProject();
        renderRelationsView();
        showNotification('Relation supprimée');
    }
}

// [MVVM : Other]
// Group: Service | Naming: ExportService
// Placeholder pour une future fonctionnalité d'exportation graphique des relations.
function exportRelations() {
    alert('Export graphique des relations à venir');
}
// ========== js/35.renderMap.js ==========

// ============================================
// MAP FUNCTIONS
// ============================================

// [MVVM : View]
// Gère l'affichage de la carte géographique et de ses marqueurs dans l'interface utilisateur.
function renderMapView() {
    const editorView = document.getElementById('editorView');
    if (!editorView) {
        console.error('editorView not found');
        return;
    }

    // S'assurer que mapLocations et mapImage existent
    if (!project.mapLocations) project.mapLocations = [];
    if (!project.mapImage) project.mapImage = null;

    let mapContent = '';
    if (project.mapImage) {
        mapContent = `
                    <div style="position: relative; display: inline-block; max-width: 100%;">
                        <img src="${project.mapImage}" 
                             id="worldMapImage"
                             style="max-width: 100%; height: auto; display: block; cursor: crosshair; border: 2px solid var(--border-color); border-radius: 4px;" 
                             alt="Carte du monde"
                             onclick="handleMapClick(event)">
                        ${project.mapLocations.map((loc, i) => `
                            <div class="map-location" 
                                 style="position: absolute; left: ${loc.x}%; top: ${loc.y}%; 
                                        width: 20px; height: 20px; 
                                        background: var(--accent-red); 
                                        border: 2px solid white;
                                        border-radius: 50%; 
                                        transform: translate(-50%, -50%);
                                        cursor: pointer;
                                        box-shadow: 0 2px 8px rgba(0,0,0,0.3);
                                        z-index: 10;"
                                 title="${loc.name}"
                                 onclick="event.stopPropagation(); editMapLocation(${i})">
                                <div style="position: absolute; top: -30px; left: 50%; transform: translateX(-50%);
                                           background: var(--bg-accent); color: white; padding: 0.25rem 0.5rem;
                                           border-radius: 4px; white-space: nowrap; font-size: 0.75rem;
                                           pointer-events: none; opacity: 0; transition: opacity 0.2s;"
                                     class="map-location-label">${loc.name}</div>
                            </div>
                        `).join('')}
                    </div>
                    <style>
                        .map-location:hover .map-location-label {
                            opacity: 1 !important;
                        }
                    </style>
                `;
    } else {
        mapContent = `
                    <div style="padding: 4rem; text-align: center; background: var(--bg-secondary); border-radius: 8px; border: 2px dashed var(--border-color);">
                        <div style="font-size: 4rem; margin-bottom: 1rem;">???</div>
                        <div style="font-size: 1.2rem; font-weight: 600; margin-bottom: 0.5rem;">Aucune carte chargée</div>
                        <div style="color: var(--text-muted); margin-bottom: 1.5rem;">Cliquez sur "Charger carte" pour ajouter une image</div>
                        <button class="btn btn-primary" onclick="uploadMapImage()">?? Charger une carte</button>
                    </div>
                `;
    }

    editorView.innerHTML = `
                <div style="height: 100%; overflow-y: auto; padding: 2rem 3rem;">
                    <h2 style="margin-bottom: 2rem; color: var(--accent-gold);">??? Carte Géographique</h2>
                    
                    <div style="margin-bottom: 2rem; display: flex; gap: 0.5rem; flex-wrap: wrap;">
                        <button class="btn btn-primary" onclick="uploadMapImage()">??? Charger carte</button>
                        <button class="btn" onclick="addMapLocation()" ${!project.mapImage ? 'disabled' : ''}>?? Ajouter lieu</button>
                        <button class="btn btn-small" onclick="clearMap()" ${!project.mapImage ? 'disabled' : ''}>??? Effacer carte</button>
                        <button class="btn btn-small" onclick="exportMapData()">?? Exporter données</button>
                    </div>
                    
                    <div style="background: var(--bg-secondary); padding: 2rem; border-radius: 8px; text-align: center;">
                        ${mapContent}
                    </div>
                    
                    ${project.mapLocations.length > 0 ? `
                        <div style="margin-top: 2rem; background: var(--bg-secondary); padding: 1.5rem; border-radius: 8px;">
                            <h3 style="margin-bottom: 1rem; color: var(--text-primary);">?? Lieux marqués (${project.mapLocations.length})</h3>
                            <div style="display: grid; gap: 0.5rem;">
                                ${project.mapLocations.map((loc, i) => `
                                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.75rem; background: var(--bg-primary); border-radius: 4px;">
                                        <span style="font-weight: 500;">${loc.name}</span>
                                        <div style="display: flex; gap: 0.5rem;">
                                            <button class="btn btn-small" onclick="editMapLocation(${i})">??</button>
                                            <button class="btn btn-small" onclick="deleteMapLocation(${i})">???</button>
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    ` : ''}
                    
                    <div style="margin-top: 2rem; padding: 1.5rem; background: var(--bg-secondary); border-radius: 8px; border-left: 4px solid var(--accent-gold);">
                        <p style="font-size: 0.95rem; color: var(--text-secondary); line-height: 1.6;">
                            ?? <strong>Utilisation:</strong><br>
                            1. Chargez une image de carte (dessinée à la main, générée par IA, etc.)<br>
                            2. Cliquez directement sur la carte pour placer un marqueur<br>
                            3. Cliquez sur un marqueur existant pour le modifier ou le supprimer
                        </p>
                    </div>
                </div>
            `;
}

// [MVVM : Other]
// Group: Use Case | Naming: HandleMapClickUseCase
// Gère le clic sur la carte pour créer un nouveau marqueur à l'emplacement cliqué.
function handleMapClick(event) {
    // S'assurer que mapLocations existe
    if (!project.mapLocations) project.mapLocations = [];

    const img = event.target;
    const rect = img.getBoundingClientRect();
    const x = ((event.clientX - rect.left) / rect.width) * 100;
    const y = ((event.clientY - rect.top) / rect.height) * 100;

    const name = prompt('Nom du lieu:');
    if (name) {
        project.mapLocations.push({
            name: name,
            x: Math.max(0, Math.min(100, x)),
            y: Math.max(0, Math.min(100, y)),
            description: ''
        });
        saveProject();
        renderMapView();
        showNotification(`?? Lieu "${name}" ajouté`);
    }
}

// [MVVM : ViewModel]
// Permet à l'utilisateur de charger une image pour la carte via un sélecteur de fichiers.
function uploadMapImage() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'image/*';
    input.onchange = (e) => {
        const file = e.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (event) => {
                project.mapImage = event.target.result;
                saveProject();
                renderMapView();
            };
            reader.readAsDataURL(file);
        }
    };
    input.click();
}

// [MVVM : ViewModel]
// Ajoute un nouveau lieu à la carte avec des coordonnées par défaut ou aléatoires.
function addMapLocation() {
    if (!project.mapImage) {
        alert('Veuillez d\'abord charger une carte');
        return;
    }
    // S'assurer que mapLocations existe
    if (!project.mapLocations) project.mapLocations = [];

    const name = prompt('Nom du lieu:');
    if (name) {
        project.mapLocations.push({
            name: name,
            x: 50 + Math.random() * 40,
            y: 30 + Math.random() * 40,
            description: ''
        });
        saveProject();
        renderMapView();
    }
}

// [MVVM : ViewModel]
// Permet de modifier le nom d'un marqueur existant sur la carte.
function editMapLocation(index) {
    const loc = project.mapLocations[index];
    const newName = prompt('Modifier le nom:', loc.name);
    if (newName) {
        loc.name = newName;
        saveProject();
        renderMapView();
        showNotification(`?? Lieu modifié: ${newName}`);
    }
}

// [MVVM : ViewModel]
// Supprime un marqueur de la carte après confirmation.
function deleteMapLocation(index) {
    const loc = project.mapLocations[index];
    if (confirm(`Supprimer le lieu "${loc.name}" ?`)) {
        project.mapLocations.splice(index, 1);
        saveProject();
        renderMapView();
        showNotification(`??? Lieu supprimé: ${loc.name}`);
    }
}

// [MVVM : ViewModel]
// Réinitialise complètement la carte et supprime tous les marqueurs associés.
function clearMap() {
    if (confirm('Effacer la carte et tous les lieux ?')) {
        project.mapImage = null;
        project.mapLocations = [];
        saveProject();
        renderMapView();
        showNotification('??? Carte effacée');
    }
}

// [MVVM : ViewModel]
// Exporte les données de localisation de la carte au format JSON.
function exportMapData() {
    const data = {
        image: project.mapImage ? 'Image présente' : 'Pas d\'image',
        locations: project.mapLocations
    };
    const json = JSON.stringify(data, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `carte_${project.title.replace(/[^a-z0-9]/gi, '_')}.json`;
    a.click();
    showNotification('?? Données de la carte exportées');
}

// ========== js/36.timeline-metro.js ==========
// ============================================
// ============================================
// ============================================
// TIMELINE VIZ FUNCTIONS
// ============================================

// [MVVM : View]
// Rend la liste latérale (sidebar) des évènements de la timeline.
function renderTimelineVizList() {
    const container = document.getElementById('timelineVizList');
    if (!container) {
        console.error('timelineVizList container not found');
        return;
    }

    // S'assurer que metroTimeline et characterColors existent
    if (!project.metroTimeline) {
        project.metroTimeline = [];
    }
    if (!project.characterColors) {
        project.characterColors = {};
    }

    // Assigner des couleurs par défaut aux personnages qui n'en ont pas
    const defaultColors = ['#E53935', '#1E88E5', '#43A047', '#FB8C00', '#8E24AA', '#00ACC1', '#FFB300', '#D81B60', '#5E35B1', '#00897B'];
    project.characters.forEach((char, i) => {
        if (!project.characterColors[char.id]) {
            project.characterColors[char.id] = defaultColors[i % defaultColors.length];
        }
    });

    // Compter les évènements
    const eventCount = project.metroTimeline.length;
    const charCount = project.characters.length;

    // Sidebar avec personnages et liste d'évènements
    container.innerHTML = `
                <div style="padding: 1rem;">
                    <h3 style="margin-bottom: 1rem; display: flex; align-items: center; gap: 0.5rem;">
                        <i data-lucide="train-track" style="width: 20px; height: 20px;"></i>
                        Timeline Métro
                    </h3>
                    <div style="font-size: 0.85rem; color: var(--text-secondary); line-height: 1.6;">
                        <div style="margin-bottom: 0.5rem;"><i data-lucide="calendar" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i> ${eventCount} évènement(s)</div>
                        <div style="margin-bottom: 0.5rem;"><i data-lucide="users" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i> ${charCount} personnage(s)</div>
                        <div style="margin-top: 1rem;">
                            <button class="btn btn-primary" onclick="openMetroEventModal()" style="width: 100%;">
                                + Nouvel évènement
                            </button>
                        </div>
                    </div>
                    ${eventCount > 0 ? `
                        <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--border-color);">
                            <div style="font-size: 0.85rem; font-weight: 600; margin-bottom: 0.5rem;">
                                <span>évènements:</span>
                            </div>
                            <div id="metroEventsList" class="metro-events-sortable">
                                ${project.metroTimeline.sort((a, b) => (a.order || 0) - (b.order || 0)).map((event, i, arr) => `
                                    <div class="metro-event-item" data-event-id="${event.id}">
                                        <div class="metro-event-reorder-btns">
                                            <button class="metro-reorder-btn" onclick="moveMetroEvent(${event.id}, -1)" ${i === 0 ? 'disabled' : ''} title="Monter"><i data-lucide="chevron-up" style="width:12px;height:12px;"></i></button>
                                            <button class="metro-reorder-btn" onclick="moveMetroEvent(${event.id}, 1)" ${i === arr.length - 1 ? 'disabled' : ''} title="Descendre"><i data-lucide="chevron-down" style="width:12px;height:12px;"></i></button>
                                        </div>
                                        <div class="metro-event-item-content" onclick="openMetroEventModal(${event.id})">
                                            <div style="display: flex; align-items: center; gap: 0.5rem;">
                                                <div style="font-weight: 600; flex: 1;">${event.title}</div>
                                                ${event.sceneId ? `<i data-lucide="file-text" style="width: 14px; height: 14px; color: var(--accent-blue); cursor: pointer;" onclick="event.stopPropagation(); openMetroLinkedScene(${event.sceneId})" title="Scène liée"></i>` : ''}
                                            </div>
                                            <div style="color: var(--text-muted); font-size: 0.75rem;">${event.date || 'Sans date'}</div>
                                            <div style="display: flex; gap: 2px; margin-top: 4px;">
                                                ${(event.characters || []).map(charId => {
        const char = project.characters.find(c => c.id === charId);
        return char ? `<span style="width: 12px; height: 12px; border-radius: 50%; background: ${project.characterColors[charId] || '#999'};" title="${char.name}"></span>` : '';
    }).join('')}
                                            </div>
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    ` : ''}
                </div>
            `;

    // Rafraîchir les icônes Lucide pour la sidebar
    if (eventCount > 0) {
        if (typeof lucide !== 'undefined') lucide.createIcons();
    }
}

// [MVVM : View]
// Rend la vue principale de la timeline métro.
function renderTimelineVizView() {
    // Render sidebar first
    renderTimelineVizList();

    // Render main view
    const editorView = document.getElementById('editorView');
    if (!editorView) {
        console.error('editorView not found for metro timeline');
        return;
    }

    const charCount = project.characters?.length || 0;

    if (charCount === 0) {
        editorView.innerHTML = `
                    <div class="metro-empty-state">
                        <i data-lucide="users" style="width: 64px; height: 64px; opacity: 0.3;"></i>
                        <h3 style="margin: 1rem 0 0.5rem;">Aucun personnage</h3>
                        <p style="margin-bottom: 1.5rem;">Créez d'abord des personnages dans l'onglet "Personnages" pour pouvoir les lier aux évènements de votre timeline.</p>
                        <button class="btn btn-primary" onclick="switchView('characters')">Créer des personnages</button>
                    </div>
                `;
        lucide.createIcons();
        return;
    }

    editorView.innerHTML = `
                <div style="padding: 2rem;">
                    <div class="metro-toolbar">
                        <button class="btn btn-primary" onclick="openMetroEventModal()">
                            <i data-lucide="plus" style="width: 16px; height: 16px;"></i>
                            Nouvel évènement
                        </button>
                        <button class="btn" onclick="sortMetroByDate()">
                            <i data-lucide="calendar" style="width: 16px; height: 16px;"></i>
                            Trier par date
                        </button>
                        <button class="btn" onclick="exportMetroTimelineCSV()">
                            <i data-lucide="download" style="width: 16px; height: 16px;"></i>
                            Exporter CSV
                        </button>
                        <button class="btn" onclick="clearMetroTimeline()" style="margin-left: auto;">
                            <i data-lucide="trash-2" style="width: 16px; height: 16px;"></i>
                            Tout effacer
                        </button>
                    </div>
                    
                    <div class="metro-timeline-container" id="metroTimelineContainer">
                        ${renderMetroSVG()}
                    </div>
                    
                    <div class="metro-legend">
                        ${project.characters.map(char => `
                            <div class="metro-legend-item" onclick="openMetroColorPicker(${char.id})" style="cursor: pointer;" title="Cliquer pour changer la couleur">
                                <div class="metro-legend-line" style="background: ${project.characterColors[char.id] || '#999'};"></div>
                                <span>${char.name}</span>
                            </div>
                        `).join('')}
                    </div>
                    
                    <div style="margin-top: 1rem; padding: 1rem; background: var(--bg-secondary); border-radius: 4px;">
                        <p style="font-size: 0.9rem; color: var(--text-secondary);">
                            💡 <strong>Utilisation:</strong> Cliquez sur les cercles pour éditer les évènements. Les petites icônes bleues 📄 permettent d'ouvrir directement la scène liée. Cliquez sur les couleurs dans la légende pour les personnaliser. Les lignes se rejoignent quand des personnages partagent un évènement.
                        </p>
                    </div>
                </div>
            `;

    lucide.createIcons();
}

// [MVVM : View]
// Génère le code SVG pour la visualisation de la timeline métro.
function renderMetroSVG() {
    const events = (project.metroTimeline || []).sort((a, b) => (a.order || 0) - (b.order || 0));
    const characters = project.characters || [];

    if (events.length === 0) {
        return `
                    <div class="metro-empty-state">
                        <i data-lucide="train-track" style="width: 64px; height: 64px; opacity: 0.3;"></i>
                        <h3 style="margin: 1rem 0 0.5rem;">Aucun évènement</h3>
                        <p style="margin-bottom: 1.5rem;">Créez votre premier évènement pour commencer à visualiser les interactions entre personnages.</p>
                        <button class="btn btn-primary" onclick="openMetroEventModal()">+ Créer un évènement</button>
                    </div>
                `;
    }

    // Calculer les dimensions
    const rowHeight = 60;
    const eventWidth = 180;
    const leftMargin = 180;
    const topMargin = 40;
    const nodeRadius = 10;

    const svgWidth = leftMargin + (events.length * eventWidth) + 100;
    const svgHeight = Math.max(200, topMargin + (characters.length * rowHeight) + 60);

    // Générer les lignes horizontales et les paths courbes
    let pathsHTML = '';
    let nodesHTML = '';
    let labelsHTML = '';
    let characterLabelsHTML = '';

    // Pour chaque personnage, dessiner sa ligne
    characters.forEach((char, charIndex) => {
        const y = topMargin + (charIndex * rowHeight) + (rowHeight / 2);
        const color = project.characterColors[char.id] || '#999';

        // Label du personnage à gauche
        characterLabelsHTML += `
                    <g class="metro-char-label" onclick="openMetroColorPicker(${char.id})" style="cursor: pointer;">
                        <rect x="5" y="${y - 15}" width="160" height="30" fill="transparent"/>
                        <circle cx="25" cy="${y}" r="10" fill="${color}" stroke="white" stroke-width="2"/>
                        <text x="42" y="${y + 5}" font-size="13" fill="var(--text-primary)" font-weight="500">${char.name.substring(0, 18)}${char.name.length > 18 ? '...' : ''}</text>
                    </g>
                `;

        // Trouver les évènements où ce personnage participe
        const charEvents = events.filter(e => (e.characters || []).includes(char.id));

        if (charEvents.length === 0) {
            // Ligne en pointillés si pas d'évènements
            pathsHTML += `<line x1="${leftMargin}" y1="${y}" x2="${svgWidth - 50}" y2="${y}" stroke="${color}" stroke-width="3" stroke-dasharray="5,5" opacity="0.3"/>`;
        } else {
            // Dessiner le chemin entre les évènements
            let pathD = '';
            let lastX = leftMargin;

            charEvents.forEach((event, eventIdx) => {
                const eventGlobalIdx = events.indexOf(event);
                const eventX = leftMargin + (eventGlobalIdx * eventWidth) + (eventWidth / 2);

                // Calculer Y pour cet évènement (converger vers le centre si plusieurs personnages)
                const eventChars = event.characters || [];
                const charPosInEvent = eventChars.indexOf(char.id);
                const totalCharsInEvent = eventChars.length;

                // Y central de l'évènement (moyenne des Y de tous les personnages présents)
                const avgY = eventChars.reduce((sum, cId) => {
                    const cIdx = characters.findIndex(c => c.id === cId);
                    return sum + (cIdx >= 0 ? topMargin + (cIdx * rowHeight) + (rowHeight / 2) : 0);
                }, 0) / totalCharsInEvent;

                const eventY = avgY;

                if (eventIdx === 0) {
                    // Premier segment: de la ligne de base vers le premier évènement
                    pathD = `M ${lastX} ${y}`;

                    // Courbe vers le point de convergence
                    const midX = (lastX + eventX) / 2;
                    pathD += ` C ${midX} ${y}, ${midX} ${eventY}, ${eventX} ${eventY}`;
                } else {
                    // Segments intermédiaires
                    const prevEvent = charEvents[eventIdx - 1];
                    const prevEventIdx = events.indexOf(prevEvent);
                    const prevX = leftMargin + (prevEventIdx * eventWidth) + (eventWidth / 2);

                    // Y du précédent évènement
                    const prevEventChars = prevEvent.characters || [];
                    const prevAvgY = prevEventChars.reduce((sum, cId) => {
                        const cIdx = characters.findIndex(c => c.id === cId);
                        return sum + (cIdx >= 0 ? topMargin + (cIdx * rowHeight) + (rowHeight / 2) : 0);
                    }, 0) / prevEventChars.length;

                    // Courbe du précédent vers l'actuel
                    const midX = (prevX + eventX) / 2;
                    pathD += ` C ${midX} ${prevAvgY}, ${midX} ${eventY}, ${eventX} ${eventY}`;
                }

                lastX = eventX;
            });

            // Prolonger la ligne après le dernier évènement
            const lastEvent = charEvents[charEvents.length - 1];
            const lastEventIdx = events.indexOf(lastEvent);
            const lastEventX = leftMargin + (lastEventIdx * eventWidth) + (eventWidth / 2);
            const lastEventChars = lastEvent.characters || [];
            const lastAvgY = lastEventChars.reduce((sum, cId) => {
                const cIdx = characters.findIndex(c => c.id === cId);
                return sum + (cIdx >= 0 ? topMargin + (cIdx * rowHeight) + (rowHeight / 2) : 0);
            }, 0) / lastEventChars.length;

            const endX = svgWidth - 50;
            const midX = (lastEventX + endX) / 2;
            pathD += ` C ${midX} ${lastAvgY}, ${midX} ${y}, ${endX} ${y}`;

            pathsHTML += `<path d="${pathD}" class="metro-line" stroke="${color}" fill="none"/>`;
        }
    });

    // Dessiner les nœuds d'évènements (par-dessus les lignes)
    events.forEach((event, eventIdx) => {
        const eventX = leftMargin + (eventIdx * eventWidth) + (eventWidth / 2);
        const eventChars = event.characters || [];

        if (eventChars.length > 0) {
            // Calculer le Y moyen
            const avgY = eventChars.reduce((sum, cId) => {
                const cIdx = characters.findIndex(c => c.id === cId);
                return sum + (cIdx >= 0 ? topMargin + (cIdx * rowHeight) + (rowHeight / 2) : 0);
            }, 0) / eventChars.length;

            // Nœud principal
            nodesHTML += `
                        <g class="metro-event-node" onclick="openMetroEventModal(${event.id})">
                            <circle cx="${eventX}" cy="${avgY}" r="${nodeRadius + 2}" fill="white" stroke="var(--border-color)" stroke-width="2"/>
                            <circle cx="${eventX}" cy="${avgY}" r="${nodeRadius - 2}" fill="var(--text-primary)"/>
                        </g>
                        ${event.sceneId ? `
                            <g onclick="event.stopPropagation(); openMetroLinkedScene(${event.sceneId})" style="cursor: pointer;" title="Ouvrir la scène">
                                <circle cx="${eventX + nodeRadius + 8}" cy="${avgY - nodeRadius - 8}" r="8" fill="var(--accent-blue)" stroke="white" stroke-width="1.5"/>
                                <foreignObject x="${eventX + nodeRadius + 1}" y="${avgY - nodeRadius - 15}" width="14" height="14">
                                    <div xmlns="http://www.w3.org/1999/xhtml" style="color:white; display:flex; align-items:center; justify-content:center;">
                                        <i data-lucide="file-text" style="width:10px;height:10px;"></i>
                                    </div>
                                </foreignObject>
                            </g>
                        ` : ''}
                    `;

            // Label de l'évènement
            const labelY = avgY < svgHeight / 2 ? avgY - 25 : avgY + 30;
            labelsHTML += `
                        <g class="metro-event-label-group" onclick="openMetroEventModal(${event.id})" style="cursor: pointer;">
                            <text x="${eventX}" y="${labelY}" text-anchor="middle" class="metro-event-label" font-weight="600">${event.title.substring(0, 20)}${event.title.length > 20 ? '...' : ''}</text>
                            <text x="${eventX}" y="${labelY + 14}" text-anchor="middle" class="metro-event-label" font-size="10" fill="var(--text-muted)">${event.date || ''}</text>
                        </g>
                    `;
        } else {
            // évènement sans personnages - afficher en haut
            const floatingY = topMargin - 10;
            nodesHTML += `
                        <g class="metro-event-node" onclick="openMetroEventModal(${event.id})">
                            <circle cx="${eventX}" cy="${floatingY}" r="${nodeRadius}" fill="var(--text-muted)" stroke="white" stroke-width="2"/>
                        </g>
                    `;
            labelsHTML += `
                        <g onclick="openMetroEventModal(${event.id})" style="cursor: pointer;">
                            <text x="${eventX}" y="${floatingY - 15}" text-anchor="middle" class="metro-event-label" fill="var(--text-muted)">${event.title.substring(0, 15)}...</text>
                        </g>
                    `;
        }
    });

    return `
                <svg width="${svgWidth}" height="${svgHeight}" class="metro-svg-container">
                    <!-- Fond -->
                    <rect width="100%" height="100%" fill="var(--bg-primary)"/>
                    
                    <!-- Lignes de grille légères -->
                    ${characters.map((_, i) => {
        const y = topMargin + (i * rowHeight) + (rowHeight / 2);
        return `<line x1="${leftMargin}" y1="${y}" x2="${svgWidth}" y2="${y}" stroke="var(--border-color)" stroke-width="1" opacity="0.3" stroke-dasharray="2,4"/>`;
    }).join('')}
                    
                    <!-- Labels personnages -->
                    ${characterLabelsHTML}
                    
                    <!-- Chemins des lignes de métro -->
                    ${pathsHTML}
                    
                    <!-- Nœuds des évènements -->
                    ${nodesHTML}
                    
                    <!-- Labels des évènements -->
                    ${labelsHTML}
                </svg>
            `;
}

// [MVVM : ViewModel]
// Ouvre la modale de création ou d'édition d'un évènement métro.
function openMetroEventModal(eventId = null) {
    const modal = document.getElementById('metroEventModal');
    const titleEl = document.getElementById('metroEventModalTitle');
    const deleteBtn = document.getElementById('metroDeleteBtn');

    // Reset form
    document.getElementById('metroEventId').value = '';
    document.getElementById('metroEventTitle').value = '';
    document.getElementById('metroEventDate').value = '';
    document.getElementById('metroEventOrder').value = '';
    document.getElementById('metroEventDesc').value = '';
    document.getElementById('metroEventScene').value = '';

    // Populate scene selector
    const sceneSelect = document.getElementById('metroEventScene');
    let sceneOptions = '<option value="">Aucune scène</option>';
    project.acts.forEach(act => {
        act.chapters.forEach(chapter => {
            chapter.scenes.forEach(scene => {
                const scenePath = `${act.title} > ${chapter.title} > ${scene.title}`;
                sceneOptions += `<option value="${scene.id}">${scenePath}</option>`;
            });
        });
    });
    sceneSelect.innerHTML = sceneOptions;

    // Populate position selector
    const positionSelect = document.getElementById('metroEventPosition');
    const sortedEvents = (project.metroTimeline || []).sort((a, b) => (a.order || 0) - (b.order || 0));

    let positionOptions = '<option value="0">🔼 Au début de la timeline</option>';
    sortedEvents.forEach((evt, idx) => {
        if (!eventId || evt.id !== eventId) {
            positionOptions += `<option value="${evt.order || idx + 1}">↳ Après: ${evt.title}${evt.date ? ' (' + evt.date + ')' : ''}</option>`;
        }
    });
    positionSelect.innerHTML = positionOptions;

    // Populate character selector
    const selectorDiv = document.getElementById('metroCharactersSelector');
    selectorDiv.innerHTML = project.characters.map(char => `
                <label class="metro-char-option" data-char-id="${char.id}">
                    <input type="checkbox" value="${char.id}" onchange="updateMetroLinkedChars()">
                    <span class="metro-char-color-dot" style="background: ${project.characterColors[char.id] || '#999'};"></span>
                    <span>${char.name}</span>
                </label>
            `).join('');

    if (eventId) {
        // Edit mode
        const event = project.metroTimeline.find(e => e.id === eventId);
        if (!event) return;

        titleEl.textContent = 'Modifier l\'évènement';
        deleteBtn.style.display = '';

        document.getElementById('metroEventId').value = event.id;
        document.getElementById('metroEventTitle').value = event.title || '';
        document.getElementById('metroEventDate').value = event.date || '';
        document.getElementById('metroEventOrder').value = event.order !== undefined ? event.order : '';
        document.getElementById('metroEventDesc').value = event.description || '';
        document.getElementById('metroEventScene').value = event.sceneId || '';

        // Select current position (the event just before this one)
        const currentIdx = sortedEvents.findIndex(e => e.id === eventId);
        if (currentIdx > 0) {
            const prevEvent = sortedEvents[currentIdx - 1];
            positionSelect.value = prevEvent.order || currentIdx;
        } else {
            positionSelect.value = '0';
        }

        // Check characters
        (event.characters || []).forEach(charId => {
            const checkbox = selectorDiv.querySelector(`input[value="${charId}"]`);
            if (checkbox) {
                checkbox.checked = true;
                checkbox.closest('.metro-char-option').classList.add('selected');
            }
        });
    } else {
        // Create mode
        titleEl.textContent = 'Nouvel évènement';
        deleteBtn.style.display = 'none';

        // Default position = at the end
        if (sortedEvents.length > 0) {
            const lastEvent = sortedEvents[sortedEvents.length - 1];
            positionSelect.value = lastEvent.order || sortedEvents.length;
        } else {
            positionSelect.value = '0';
        }
        document.getElementById('metroEventOrder').value = sortedEvents.length + 1;
    }

    updateMetroLinkedChars();
    modal.classList.add('active');
    document.getElementById('metroEventTitle').focus();
}

// [MVVM : ViewModel]
// Met à jour l'affichage des personnages liés dans la modale d'évènement.
function updateMetroLinkedChars() {
    const selectorDiv = document.getElementById('metroCharactersSelector');
    const linkedDiv = document.getElementById('metroLinkedChars');

    const checked = Array.from(selectorDiv.querySelectorAll('input:checked'));

    // Update visual selection
    selectorDiv.querySelectorAll('.metro-char-option').forEach(opt => {
        const checkbox = opt.querySelector('input');
        opt.classList.toggle('selected', checkbox.checked);
    });

    // Update linked tags
    linkedDiv.innerHTML = checked.map(cb => {
        const charId = parseInt(cb.value);
        const char = project.characters.find(c => c.id === charId);
        if (!char) return '';
        const color = project.characterColors[charId] || '#999';
        return `
                    <span class="metro-linked-char-tag" style="background: ${color};">
                        ${char.name}
                        <span class="remove-char" onclick="removeMetroCharFromEvent(${charId})"><i data-lucide="x" style="width:10px;height:10px;vertical-align:middle;"></i></span>
                    </span>
                `;
    }).join('');
}

// [MVVM : ViewModel]
// Retire un personnage de la sélection dans la modale d'évènement.
function removeMetroCharFromEvent(charId) {
    const selectorDiv = document.getElementById('metroCharactersSelector');
    const checkbox = selectorDiv.querySelector(`input[value="${charId}"]`);
    if (checkbox) {
        checkbox.checked = false;
        updateMetroLinkedChars();
    }
}

// [MVVM : ViewModel]
// Enregistre les modifications d'un évènement métro.
function saveMetroEvent() {
    const eventId = document.getElementById('metroEventId').value;
    const title = document.getElementById('metroEventTitle').value.trim();
    const date = document.getElementById('metroEventDate').value.trim();
    const positionAfter = parseFloat(document.getElementById('metroEventPosition').value) || 0;
    const description = document.getElementById('metroEventDesc').value.trim();
    const sceneIdValue = document.getElementById('metroEventScene').value;
    const sceneId = sceneIdValue ? parseInt(sceneIdValue) : null;

    if (!title) {
        alert('Le titre est obligatoire');
        return;
    }

    // Get selected characters
    const selectorDiv = document.getElementById('metroCharactersSelector');
    const characters = Array.from(selectorDiv.querySelectorAll('input:checked')).map(cb => parseInt(cb.value));

    if (!project.metroTimeline) {
        project.metroTimeline = [];
    }

    // Calculate new order based on position selection
    // positionAfter = 0 means "at the beginning"
    // positionAfter = N means "after the event with order N"
    let newOrder;
    if (positionAfter === 0) {
        newOrder = 0.5; // Will be normalized to 1 after reordering
    } else {
        newOrder = positionAfter + 0.5; // Insert after the selected event
    }

    if (eventId) {
        // Update existing
        const event = project.metroTimeline.find(e => e.id === parseInt(eventId));
        if (event) {
            event.title = title;
            event.date = date;
            event.order = newOrder;
            event.description = description;
            event.characters = characters;
            event.sceneId = sceneId;
        }
        showNotification('✓ évènement mis à jour');
    } else {
        // Create new
        project.metroTimeline.push({
            id: Date.now(),
            title,
            date,
            order: newOrder,
            description,
            characters,
            sceneId: sceneId
        });
        showNotification('✓ évènement créé');
    }

    // Reorder all events to have clean sequential numbers
    normalizeMetroEventOrder();

    saveProject();
    closeModal('metroEventModal');

    // Check if we're in split-view mode
    if (splitViewActive && (splitViewState.left.view === 'timelineviz' || splitViewState.right.view === 'timelineviz')) {
        // Refresh the split panel(s) showing timeline
        if (splitViewState.left.view === 'timelineviz') {
            renderSplitPanelViewContent('left');
        }
        if (splitViewState.right.view === 'timelineviz') {
            renderSplitPanelViewContent('right');
        }
        // Also refresh the editor panel if it's showing a scene (to update the timeline badge)
        if (splitViewState.left.view === 'editor' && splitViewState.left.sceneId) {
            renderSplitPanelViewContent('left');
        }
        if (splitViewState.right.view === 'editor' && splitViewState.right.sceneId) {
            renderSplitPanelViewContent('right');
        }
    } else if (currentView === 'timelineviz') {
        // Normal full-screen timeline view
        renderTimelineVizView();
    } else if (currentSceneId && currentView === 'editor') {
        // Normal full-screen editor view - refresh to show the new link
        const act = project.acts.find(a => a.id === currentActId);
        const chapter = act?.chapters.find(c => c.id === currentChapterId);
        const scene = chapter?.scenes.find(s => s.id === currentSceneId);
        if (act && chapter && scene) {
            renderEditor(act, chapter, scene);
        }
    }
}

// [MVVM : Model]
// Réorganise les ordres des évènements pour qu'ils soient séquentiels.
function normalizeMetroEventOrder() {
    // Sort by current order
    project.metroTimeline.sort((a, b) => (a.order || 0) - (b.order || 0));

    // Reassign clean sequential numbers (1, 2, 3, ...)
    project.metroTimeline.forEach((event, i) => {
        event.order = i + 1;
    });
}

// [MVVM : ViewModel]
// Déplace un évènement vers le haut ou le bas dans l'ordre.
function moveMetroEvent(eventId, direction) {
    // direction: -1 = monter, 1 = descendre
    const sortedEvents = project.metroTimeline.sort((a, b) => (a.order || 0) - (b.order || 0));
    const currentIndex = sortedEvents.findIndex(e => e.id === eventId);

    if (currentIndex === -1) return;

    const newIndex = currentIndex + direction;

    // Vérifier les limites
    if (newIndex < 0 || newIndex >= sortedEvents.length) return;

    // Échanger les positions
    const temp = sortedEvents[currentIndex];
    sortedEvents[currentIndex] = sortedEvents[newIndex];
    sortedEvents[newIndex] = temp;

    // Mettre à jour les ordres
    sortedEvents.forEach((event, i) => {
        event.order = i + 1;
    });

    project.metroTimeline = sortedEvents;

    saveProject();
    refreshTimelineView();
}

// [MVVM : ViewModel]
// Supprime un évènement de la timeline métro.
function deleteMetroEvent() {
    const eventId = document.getElementById('metroEventId').value;
    if (!eventId) return;

    if (!confirm('Supprimer cet évènement ?')) return;

    project.metroTimeline = project.metroTimeline.filter(e => e.id !== parseInt(eventId));
    saveProject();
    closeModal('metroEventModal');

    // Check if we're in split-view mode
    if (splitViewActive && (splitViewState.left.view === 'timelineviz' || splitViewState.right.view === 'timelineviz')) {
        // Refresh the split panel(s) showing timeline
        if (splitViewState.left.view === 'timelineviz') {
            renderSplitPanelViewContent('left');
        }
        if (splitViewState.right.view === 'timelineviz') {
            renderSplitPanelViewContent('right');
        }
    } else if (currentView === 'timelineviz') {
        // Normal full-screen timeline view
        renderTimelineVizView();
    }

    showNotification('✓ évènement supprimé');
}

// [MVVM : ViewModel]
// Ouvre la scène liée à un évènement dans l'éditeur.
function openMetroLinkedScene(sceneId) {
    // Find the scene
    let foundScene = null;
    let foundChapter = null;
    let foundAct = null;

    for (const act of project.acts) {
        for (const chapter of act.chapters) {
            const scene = chapter.scenes.find(s => s.id === sceneId);
            if (scene) {
                foundScene = scene;
                foundChapter = chapter;
                foundAct = act;
                break;
            }
        }
        if (foundScene) break;
    }

    if (!foundScene) {
        showNotification('❌ Scène introuvable', 'error');
        return;
    }

    // Switch to editor view and open the scene
    switchView('editor');

    // Use the proper openScene function which handles everything
    setTimeout(() => {
        openScene(foundAct.id, foundChapter.id, foundScene.id);
        showNotification(`📄 Scène ouverte : ${foundScene.title}`);
    }, 100);
}

// [MVVM : ViewModel]
// Affiche la modale de choix de vue lors de l'ouverture d'un évènement depuis l'éditeur.
function openMetroEventFromScene(eventId) {
    // Store the event ID and show the choice modal
    document.getElementById('metroViewChoiceEventId').value = eventId;
    document.getElementById('metroViewChoiceModal').classList.add('active');

    // Refresh icons
    setTimeout(() => {
        if (typeof lucide !== 'undefined') {
            lucide.createIcons();
        }
    }, 50);
}

// [MVVM : ViewModel]
// Bascule vers la vue complète de la timeline pour un évènement donné.
function openMetroEventFullView() {
    const eventId = parseInt(document.getElementById('metroViewChoiceEventId').value);
    closeModal('metroViewChoiceModal');

    // Switch to timeline viz view properly
    currentView = 'timelineviz';

    // Update nav buttons
    document.querySelectorAll('.nav-btn').forEach(btn => btn.classList.remove('active'));
    const timelineBtn = Array.from(document.querySelectorAll('.nav-btn')).find(btn =>
        btn.textContent.includes('Timeline') || btn.onclick?.toString().includes('timelineviz')
    );
    if (timelineBtn) timelineBtn.classList.add('active');

    // Hide all sidebar lists
    const sidebarLists = [
        'chaptersList', 'charactersList', 'worldList', 'timelineList',
        'notesList', 'codexList', 'statsList', 'versionsList', 'analysisList',
        'todosList', 'corkboardList', 'mindmapList', 'plotList',
        'relationsList', 'mapList', 'timelineVizList'
    ];

    sidebarLists.forEach(listId => {
        const el = document.getElementById(listId);
        if (el) el.style.display = 'none';
    });

    // Show the timelineVizList sidebar
    const timelineVizList = document.getElementById('timelineVizList');
    if (timelineVizList) timelineVizList.style.display = 'block';

    // Render the timeline viz view completely
    renderTimelineVizView();

    // Wait for rendering to complete, then open the modal
    setTimeout(() => {
        // Ensure icons are rendered
        if (typeof lucide !== 'undefined') {
            lucide.createIcons();
        }
        // Open the event modal
        setTimeout(() => {
            openMetroEventModal(eventId);
        }, 100);
    }, 300);
}

// [MVVM : ViewModel]
// Ouvre la timeline métro en vue partagée (split view).
function openMetroEventSplitView() {
    const eventId = parseInt(document.getElementById('metroViewChoiceEventId').value);
    closeModal('metroViewChoiceModal');

    // Enable split view if not already active
    if (!splitViewActive) {
        toggleSplitView();
    }

    // Set the right panel to show timeline viz
    splitViewState.right.view = 'timelineviz';
    splitActivePanel = 'right';

    // Update the header to show "Timeline" instead of "Vide"
    updateSplitPanelHeader('right');

    // Render the right panel with timeline
    renderSplitPanelViewContent('right');

    // Wait for rendering, then open the event modal
    setTimeout(() => {
        if (typeof lucide !== 'undefined') {
            lucide.createIcons();
        }
        setTimeout(() => {
            openMetroEventModal(eventId);
        }, 100);
    }, 300);

    saveSplitViewState();
}

// [MVVM : ViewModel]
// Ouvre le sélecteur de couleur pour un personnage.
function openMetroColorPicker(charId) {
    const char = project.characters.find(c => c.id === charId);
    if (!char) return;

    document.getElementById('metroColorCharId').value = charId;
    document.getElementById('metroColorCharName').textContent = char.name;

    const currentColor = project.characterColors[charId] || '#999';
    document.getElementById('metroCustomColor').value = currentColor;

    // Highlight current color
    document.querySelectorAll('.metro-color-option').forEach(opt => {
        opt.classList.toggle('selected', opt.dataset.color === currentColor);
    });

    document.getElementById('metroColorModal').classList.add('active');
}

// [MVVM : ViewModel]
// Sélectionne une couleur dans le sélecteur de couleur.
function selectMetroColor(color) {
    document.getElementById('metroCustomColor').value = color;
    document.querySelectorAll('.metro-color-option').forEach(opt => {
        opt.classList.toggle('selected', opt.dataset.color === color);
    });
}

// [MVVM : ViewModel]
// Applique la couleur sélectionnée au personnage et met à jour le modèle.
function applyMetroColor() {
    const charId = parseInt(document.getElementById('metroColorCharId').value);
    const color = document.getElementById('metroCustomColor').value;

    if (!project.characterColors) {
        project.characterColors = {};
    }

    project.characterColors[charId] = color;
    saveProject();
    closeModal('metroColorModal');
    refreshTimelineView();
    showNotification('✓ Couleur mise à jour');
}

// Helper function to refresh timeline view (works in both normal and split view)
// [MVVM : ViewModel]
// Rafraîchit l'affichage de la timeline (vue normale ou partagée).
function refreshTimelineView() {
    if (splitViewActive) {
        // In split view, refresh the active panel
        if (splitActivePanel === 'left' && splitViewState.left.view === 'timelineviz') {
            renderSplitPanelViewContent('left');
        } else if (splitActivePanel === 'right' && splitViewState.right.view === 'timelineviz') {
            renderSplitPanelViewContent('right');
        } else {
            // If neither panel is showing timeline, just render normally
            renderTimelineVizView();
        }
    } else {
        // Normal view
        renderTimelineVizView();
    }
}

// [MVVM : ViewModel]
// Trie la timeline métro par date.
function sortMetroByDate() {
    if (!project.metroTimeline || project.metroTimeline.length === 0) {
        showNotification('Aucun évènement à trier');
        return;
    }

    // Helper function to parse date in DD/MM/YYYY format
    // [MVVM : Other]
    // Group: Util / Helper | Naming: DateUtils
    // Analyse une date réelle au format JJ/MM/AAAA.
    function parseRealDate(dateStr) {
        if (!dateStr || !dateStr.trim()) return null;

        const trimmed = dateStr.trim();
        const parts = trimmed.split('/');

        if (parts.length < 2 || parts.length > 3) return null;

        const day = parseInt(parts[0], 10);
        const month = parseInt(parts[1], 10);
        let year = parts[2] ? parseInt(parts[2], 10) : null;

        if (isNaN(day) || isNaN(month)) return null;
        if (year === null) return null;

        // Handle 2-digit years (assume 1900-1999 for < 50, 2000-2099 for >= 50)
        if (year < 100) {
            year = year < 50 ? 2000 + year : 1900 + year;
        }

        // Create date object (month is 0-indexed in JavaScript Date)
        const date = new Date(year, month - 1, day);

        // Validate the date
        if (isNaN(date.getTime())) return null;

        return date;
    }

    // Helper function to extract a numeric value from fictional dates
    // Handles: "An 2157", "Année 5", "Year 42", "2157", "-500" (BCE), etc.
    // [MVVM : Other]
    // Group: Util / Helper | Naming: DateUtils
    // Extrait l'année d'une chaîne de caractères (pour calendriers fictifs).
    function extractYearNumber(dateStr) {
        if (!dateStr || !dateStr.trim()) return null;

        const trimmed = dateStr.trim();

        // Try to match patterns like "An 2157", "Année 5", "Year 42"
        const yearMatch = trimmed.match(/(?:an|année|year|yr)\s*[:\-]?\s*(-?\d+)/i);
        if (yearMatch) {
            return parseInt(yearMatch[1], 10);
        }

        // Try to match pure numbers (with optional negative for BCE)
        const numberMatch = trimmed.match(/^(-?\d+)/);
        if (numberMatch) {
            return parseInt(numberMatch[1], 10);
        }

        return null;
    }

    // Sort by date (events without valid dates go to the end)
    project.metroTimeline.sort((a, b) => {
        const dateStrA = (a.date || '').trim();
        const dateStrB = (b.date || '').trim();

        // Without date = at the end
        if (!dateStrA && !dateStrB) return 0;
        if (!dateStrA) return 1;
        if (!dateStrB) return -1;

        // Try to parse as real dates first (DD/MM/YYYY)
        const realDateA = parseRealDate(dateStrA);
        const realDateB = parseRealDate(dateStrB);

        if (realDateA && realDateB) {
            return realDateA.getTime() - realDateB.getTime();
        }

        // If one is real date and other is not, real date comes first
        if (realDateA) return -1;
        if (realDateB) return 1;

        // Try to extract year numbers for fictional calendars
        const yearA = extractYearNumber(dateStrA);
        const yearB = extractYearNumber(dateStrB);

        if (yearA !== null && yearB !== null) {
            return yearA - yearB;
        }

        // If one has a year number and other doesn't, number comes first
        if (yearA !== null) return -1;
        if (yearB !== null) return 1;

        // Fallback to alphabetical sorting
        return dateStrA.localeCompare(dateStrB);
    });

    // Reassign orders sequentially
    project.metroTimeline.forEach((event, i) => {
        event.order = i + 1;
    });

    saveProject();
    refreshTimelineView();
    showNotification('✓ Timeline triée par date');
}

// [MVVM : ViewModel]
// Efface tous les évènements de la timeline métro.
function clearMetroTimeline() {
    if (!project.metroTimeline || project.metroTimeline.length === 0) {
        showNotification('La timeline est déjà vide');
        return;
    }

    if (confirm(`Effacer les ${project.metroTimeline.length} évènement(s) de la timeline ?`)) {
        project.metroTimeline = [];
        saveProject();
        refreshTimelineView();
        showNotification('✓ Timeline effacée');
    }
}

// [MVVM : ViewModel]
// Exporte la timeline métro au format CSV.
function exportMetroTimelineCSV() {
    if (!project.metroTimeline || project.metroTimeline.length === 0) {
        alert('Aucun évènement à exporter');
        return;
    }

    let csv = 'Ordre,Titre,Date,Description,Personnages\n';

    project.metroTimeline.sort((a, b) => (a.order || 0) - (b.order || 0)).forEach(event => {
        const charNames = (event.characters || []).map(cId => {
            const char = project.characters.find(c => c.id === cId);
            return char ? char.name : '';
        }).filter(n => n).join('; ');

        csv += `${event.order || ''},${escapeCSVField(event.title)},${escapeCSVField(event.date || '')},${escapeCSVField(event.description || '')},${escapeCSVField(charNames)}\n`;
    });

    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${project.title}_metro_timeline.csv`;
    a.click();
    URL.revokeObjectURL(url);

    showNotification(`✓ ${project.metroTimeline.length} évènement(s) exporté(s)`);
}

// Legacy functions for old timeline (keeping for backward compatibility)
// [MVVM : ViewModel]
// Ajoute un évènement (legacy).
function addTimelineVizEvent() {
    openMetroEventModal();
}

// [MVVM : ViewModel]
// Modifie un évènement (legacy).
function editTimelineVizEvent(id) {
    // Try to find in new metro timeline first
    if (project.metroTimeline && project.metroTimeline.find(e => e.id === id)) {
        openMetroEventModal(id);
        return;
    }
    // Fallback to old visual timeline
    const event = project.visualTimeline?.find(e => e.id === id);
    if (!event) return;

    const newTitle = prompt('Modifier le titre:', event.title);
    if (newTitle === null) return;

    if (newTitle.trim() !== '') {
        event.title = newTitle.trim();

        const newDate = prompt('Modifier la date:', event.date);
        if (newDate !== null) {
            event.date = newDate.trim();
        }

        const newDesc = prompt('Modifier la description:', event.description);
        if (newDesc !== null) {
            event.description = newDesc.trim();
        }

        saveProject();
        refreshTimelineView();
        showNotification('✓ évènement mis à jour');
    }
}

// [MVVM : ViewModel]
// Trie par date (legacy).
function sortTimelineByDate() {
    sortMetroTimeline();
}

// [MVVM : ViewModel]
// Efface la timeline (legacy).
function clearTimeline() {
    clearMetroTimeline();
}

// [MVVM : ViewModel]
// Exporte la timeline (legacy).
function exportTimelineViz() {
    exportMetroTimelineCSV();
}

// ============================================
// IMPORT/EXPORT CSV POUR TIMELINE (Legacy)
// ============================================

// [MVVM : ViewModel]
// Importe des évènements depuis un fichier CSV.
function importTimelineCSV() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.csv';

    input.onchange = (e) => {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (event) => {
            try {
                parseMetroTimelineCSV(event.target.result);
            } catch (error) {
                alert('Erreur lors de la lecture du fichier CSV:\n' + error.message);
            }
        };
        reader.readAsText(file);
    };

    input.click();
}

// [MVVM : ViewModel]
// Analyse le contenu d'un CSV d'importation.
function parseMetroTimelineCSV(csvContent) {
    const lines = csvContent.split('\n').filter(line => line.trim() !== '');

    if (lines.length === 0) {
        alert('Le fichier CSV est vide');
        return;
    }

    // Skip header if present
    const header = lines[0].toLowerCase();
    if (header.includes('titre') || header.includes('title') || header.includes('ordre') || header.includes('order')) {
        lines.shift();
    }

    if (lines.length === 0) {
        alert('Le fichier CSV ne contient aucun évènement');
        return;
    }

    if (!confirm(`Importer ${lines.length} évènement(s) ? Les évènements existants seront conservés.`)) {
        return;
    }

    if (!project.metroTimeline) {
        project.metroTimeline = [];
    }

    let imported = 0;
    const maxOrder = Math.max(0, ...project.metroTimeline.map(e => e.order || 0));

    lines.forEach((line, idx) => {
        const parts = parseCSVLine(line);
        const title = parts[1]?.trim() || parts[0]?.trim() || '';

        if (title) {
            project.metroTimeline.push({
                id: Date.now() + idx,
                order: maxOrder + idx + 1,
                title: title,
                date: parts[2]?.trim() || '',
                description: parts[3]?.trim() || '',
                characters: []
            });
            imported++;
        }
    });

    saveProject();
    refreshTimelineView();
    showNotification(`✓ ${imported} évènement(s) importé(s)`);
}

// [MVVM : Other]
// Group: Util / Helper | Naming: CSVUtils
// Analyse une ligne CSV en tenant compte des guillemets.
function parseCSVLine(line) {
    const result = [];
    let current = '';
    let inQuotes = false;

    for (let i = 0; i < line.length; i++) {
        const char = line[i];

        if (char === '"') {
            if (inQuotes && line[i + 1] === '"') {
                current += '"';
                i++;
            } else {
                inQuotes = !inQuotes;
            }
        } else if (char === ',' && !inQuotes) {
            result.push(current);
            current = '';
        } else {
            current += char;
        }
    }

    result.push(current);
    return result;
}

// [MVVM : ViewModel]
// Exporte au format CSV (legacy).
function exportTimelineCSV() {
    exportMetroTimelineCSV();
}

// [MVVM : Other]
// Group: Util / Helper | Naming: CSVUtils
// Échappe les champs pour l'exportation CSV.
function escapeCSVField(field) {
    if (!field) return '""';

    if (field.includes(',') || field.includes('"') || field.includes('\n')) {
        field = field.replace(/"/g, '""');
        return `"${field}"`;
    }

    return field;
}

// ========== js/37.theme-manager.js ==========
// ============================================
// Module: ui/theme-manager
// Généré automatiquement - Plume Writer
// ============================================

// ===================================
// SYSTÈME DE GESTION DES THÈMES
// ===================================

// Utilitaire : convertir rgba/rgb/hex en hex
// [MVVM : Modèle]
// Utilitaire de conversion de couleur pour le stockage et le traitement des données de thème.
function rgbaToHex(color) {
    if (!color) return '#000000';

    // Si c'est déjà un hex
    if (color.startsWith('#')) {
        return color.length === 7 ? color : color + 'FF';
    }

    // Si c'est rgba ou rgb
    const match = color.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
    if (match) {
        const r = parseInt(match[1]);
        const g = parseInt(match[2]);
        const b = parseInt(match[3]);
        return '#' + [r, g, b].map(x => {
            const hex = x.toString(16);
            return hex.length === 1 ? '0' + hex : hex;
        }).join('');
    }

    return '#000000';
}

function hexToRgb(hex) {
    if (!hex) return '0, 0, 0';
    if (hex.startsWith('rgba') || hex.startsWith('rgb')) {
        const match = hex.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
        return match ? `${match[1]}, ${match[2]}, ${match[3]}` : '0, 0, 0';
    }
    // Handle #FFF
    if (hex.length === 4) {
        const r = parseInt(hex[1] + hex[1], 16);
        const g = parseInt(hex[2] + hex[2], 16);
        const b = parseInt(hex[3] + hex[3], 16);
        return `${r}, ${g}, ${b}`;
    }
    // Handle #FFFFFF
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return `${r}, ${g}, ${b}`;
}

const themeManager = {
    currentTheme: null,
    customThemes: [],

    defaultVariables: {
        '--bg-primary': '#faf9f6',
        '--bg-secondary': '#f5f3ed',
        '--bg-accent': '#2a2622',
        '--text-primary': '#2a2622',
        '--text-secondary': '#5a5550',
        '--text-muted': '#5a5550', // CORRECTION : Amélioration du contraste (était #8a847d)
        '--border-color': '#d4cfc5',
        '--primary-color': '#d4af37',
        '--primary-hover': '#b8941f',
        '--accent-red': '#c44536',
        '--accent-gold': '#d4af37',
        '--highlight-yellow': 'rgba(255, 235, 59, 0.4)',
        '--highlight-green': 'rgba(76, 175, 80, 0.3)',
        '--highlight-blue': 'rgba(33, 150, 243, 0.3)',
        '--highlight-red': 'rgba(244, 67, 54, 0.3)',
        '--highlight-purple': 'rgba(156, 39, 176, 0.3)'
    },

    presetThemes: {
        'Classique': {
            '--bg-primary': '#faf9f6',
            '--bg-secondary': '#f5f3ed',
            '--bg-accent': '#2a2622',
            '--text-primary': '#2a2622',
            '--text-secondary': '#5a5550',
            '--text-muted': '#5a5550', // CORRECTION
            '--border-color': '#d4cfc5',
            '--primary-color': '#d4af37',
            '--primary-hover': '#b8941f',
            '--accent-red': '#c44536',
            '--accent-gold': '#d4af37',
            '--highlight-yellow': 'rgba(255, 235, 59, 0.4)',
            '--highlight-green': 'rgba(76, 175, 80, 0.3)',
            '--highlight-blue': 'rgba(33, 150, 243, 0.3)',
            '--highlight-red': 'rgba(244, 67, 54, 0.3)',
            '--highlight-purple': 'rgba(156, 39, 176, 0.3)'
        },
        'Sombre': {
            '--bg-primary': '#1a1a1a',
            '--bg-secondary': '#252525',
            '--bg-tertiary': '#121212',
            '--bg-accent': '#f5f3ed',
            '--text-primary': '#e8e6e3',
            '--text-secondary': '#b8b6b3',
            '--text-muted': '#a8a6a3',
            '--border-color': '#3a3a3a',
            '--primary-color': '#ffd700',
            '--primary-hover': '#ffed4e',
            '--accent-red': '#ff6b5a',
            '--accent-gold': '#ffd700',
            '--shadow-color': '0, 0, 0',
            '--cork-bg-default': '#2a2a2a',
            '--highlight-yellow': 'rgba(255, 235, 59, 0.3)',
            '--highlight-green': 'rgba(76, 175, 80, 0.25)',
            '--highlight-blue': 'rgba(33, 150, 243, 0.25)',
            '--highlight-red': 'rgba(244, 67, 54, 0.25)',
            '--highlight-purple': 'rgba(156, 39, 176, 0.25)'
        },
        'Océan': {
            '--bg-primary': '#e8f4f8',
            '--bg-secondary': '#d0e8f0',
            '--bg-accent': '#1e3a52',
            '--text-primary': '#1e3a52',
            '--text-secondary': '#2a5270',
            '--text-muted': '#2a5270', // CORRECTION (était #5a7a90)
            '--border-color': '#a8c8d8',
            '--primary-color': '#3498db',
            '--primary-hover': '#2980b9',
            '--accent-red': '#c84a4a',
            '--accent-gold': '#3498db',
            '--highlight-yellow': 'rgba(255, 235, 59, 0.3)',
            '--highlight-green': 'rgba(46, 204, 113, 0.3)',
            '--highlight-blue': 'rgba(52, 152, 219, 0.4)',
            '--highlight-red': 'rgba(231, 76, 60, 0.3)',
            '--highlight-purple': 'rgba(155, 89, 182, 0.3)'
        },
        'Forêt': {
            '--bg-primary': '#f0f4ed',
            '--bg-secondary': '#e1e8dc',
            '--bg-accent': '#2d3e2d',
            '--text-primary': '#2d3e2d',
            '--text-secondary': '#4a5e4a',
            '--text-muted': '#4a5e4a', // CORRECTION (était #7a8a7a)
            '--border-color': '#c1d0bb',
            '--primary-color': '#6b8e23',
            '--primary-hover': '#557a1c',
            '--accent-red': '#c44536',
            '--accent-gold': '#6b8e23',
            '--highlight-yellow': 'rgba(255, 235, 59, 0.3)',
            '--highlight-green': 'rgba(107, 142, 35, 0.4)',
            '--highlight-blue': 'rgba(70, 130, 180, 0.3)',
            '--highlight-red': 'rgba(178, 34, 34, 0.3)',
            '--highlight-purple': 'rgba(147, 112, 219, 0.3)'
        },
        'Crépuscule': {
            '--bg-primary': '#2b2d42',
            '--bg-secondary': '#3a3d54',
            '--bg-accent': '#edf2f4',
            '--text-primary': '#edf2f4',
            '--text-secondary': '#c5cad4',
            '--text-muted': '#8d99ae',
            '--border-color': '#4a4d64',
            '--primary-color': '#ffd166',
            '--primary-hover': '#ffbe3d',
            '--accent-red': '#ef476f',
            '--accent-gold': '#ffd166',
            '--highlight-yellow': 'rgba(255, 209, 102, 0.3)',
            '--highlight-green': 'rgba(6, 214, 160, 0.3)',
            '--highlight-blue': 'rgba(118, 171, 174, 0.3)',
            '--highlight-red': 'rgba(239, 71, 111, 0.3)',
            '--highlight-purple': 'rgba(177, 98, 134, 0.3)'
        },
        'Sépia': {
            '--bg-primary': '#f4ecd8',
            '--bg-secondary': '#e8dcc4',
            '--bg-accent': '#3e2723',
            '--text-primary': '#3e2723',
            '--text-secondary': '#5d4037',
            '--text-muted': '#5d4037', // CORRECTION (était #8d6e63)
            '--border-color': '#d7cdb8',
            '--primary-color': '#a1887f',
            '--primary-hover': '#8d6e63',
            '--accent-red': '#bf360c',
            '--accent-gold': '#a1887f',
            '--highlight-yellow': 'rgba(255, 224, 130, 0.4)',
            '--highlight-green': 'rgba(139, 195, 74, 0.3)',
            '--highlight-blue': 'rgba(121, 134, 203, 0.3)',
            '--highlight-red': 'rgba(191, 54, 12, 0.3)',
            '--highlight-purple': 'rgba(142, 110, 99, 0.3)'
        },
        'Minuit': {
            '--bg-primary': '#0d1b2a',
            '--bg-secondary': '#1b263b',
            '--bg-accent': '#e0e1dd',
            '--text-primary': '#e0e1dd',
            '--text-secondary': '#c0c2be',
            '--text-muted': '#778da9',
            '--border-color': '#2b3a4f',
            '--primary-color': '#457b9d',
            '--primary-hover': '#5a92b5',
            '--accent-red': '#e63946',
            '--accent-gold': '#f1faee',
            '--highlight-yellow': 'rgba(241, 250, 238, 0.2)',
            '--highlight-green': 'rgba(168, 218, 220, 0.2)',
            '--highlight-blue': 'rgba(69, 123, 157, 0.3)',
            '--highlight-red': 'rgba(230, 57, 70, 0.3)',
            '--highlight-purple': 'rgba(163, 177, 138, 0.2)'
        },
        'Pastel': {
            '--bg-primary': '#fff5f7',
            '--bg-secondary': '#ffe8ec',
            '--bg-accent': '#4a4a4a',
            '--text-primary': '#2a2a2a',
            '--text-secondary': '#5a5a5a',
            '--text-muted': '#5a5a5a', // CORRECTION (était #8a8a8a)
            '--border-color': '#ffd4dc',
            '--primary-color': '#ff6b9d',
            '--primary-hover': '#ff5285',
            '--accent-red': '#ff6b9d',
            '--accent-gold': '#c9ada7',
            '--highlight-yellow': 'rgba(255, 223, 186, 0.5)',
            '--highlight-green': 'rgba(186, 220, 180, 0.5)',
            '--highlight-blue': 'rgba(173, 216, 230, 0.5)',
            '--highlight-red': 'rgba(255, 182, 193, 0.5)',
            '--highlight-purple': 'rgba(221, 160, 221, 0.5)'
        },
        // ===================================
        // NOUVEAUX THÈMES AJOUTÉS
        // ===================================
        'Cyberpunk': {
            '--bg-primary': '#0b0c15',
            '--bg-secondary': '#161829',
            '--bg-accent': '#2a2d45',
            '--text-primary': '#00f3ff',
            '--text-secondary': '#b300ff',
            '--text-muted': '#565c8d',
            '--border-color': '#2a2d45',
            '--primary-color': '#00f3ff',
            '--primary-hover': '#00bbcc',
            '--accent-red': '#ff0055',
            '--accent-gold': '#ffee00',
            '--highlight-yellow': 'rgba(255, 238, 0, 0.25)',
            '--highlight-green': 'rgba(0, 243, 255, 0.2)',
            '--highlight-blue': 'rgba(0, 85, 255, 0.3)',
            '--highlight-red': 'rgba(255, 0, 85, 0.3)',
            '--highlight-purple': 'rgba(179, 0, 255, 0.3)'
        },
        'Café': {
            '--bg-primary': '#f5ebe0',
            '--bg-secondary': '#e3d5ca',
            '--bg-accent': '#d5bdaf',
            '--text-primary': '#4a3b32',
            '--text-secondary': '#8d7966',
            '--text-muted': '#8d7966', // Applique aussi la correction ici
            '--border-color': '#d6ccc2',
            '--primary-color': '#d5bdaf',
            '--primary-hover': '#c7a998',
            '--accent-red': '#bc6c25',
            '--accent-gold': '#dda15e',
            '--highlight-yellow': 'rgba(221, 161, 94, 0.3)',
            '--highlight-green': 'rgba(96, 108, 56, 0.3)',
            '--highlight-blue': 'rgba(100, 149, 237, 0.3)',
            '--highlight-red': 'rgba(188, 108, 37, 0.3)',
            '--highlight-purple': 'rgba(156, 102, 68, 0.3)'
        },
        'Nordique': {
            '--bg-primary': '#2e3440',
            '--bg-secondary': '#3b4252',
            '--bg-accent': '#434c5e',
            '--text-primary': '#eceff4',
            '--text-secondary': '#d8dee9',
            '--text-muted': '#6c7a96',
            '--border-color': '#4c566a',
            '--primary-color': '#88c0d0',
            '--primary-hover': '#81a1c1',
            '--accent-red': '#bf616a',
            '--accent-gold': '#ebcb8b',
            '--highlight-yellow': 'rgba(235, 203, 139, 0.25)',
            '--highlight-green': 'rgba(163, 190, 140, 0.25)',
            '--highlight-blue': 'rgba(136, 192, 208, 0.25)',
            '--highlight-red': 'rgba(191, 97, 106, 0.25)',
            '--highlight-purple': 'rgba(180, 142, 173, 0.25)'
        },
        'Terminal': {
            '--bg-primary': '#000000',
            '--bg-secondary': '#0c0c0c',
            '--bg-accent': '#1a1a1a',
            '--text-primary': '#33ff00',
            '--text-secondary': '#24b300',
            '--text-muted': '#156600',
            '--border-color': '#333333',
            '--primary-color': '#33ff00',
            '--primary-hover': '#2bd900',
            '--accent-red': '#ff3333',
            '--accent-gold': '#ffff33',
            '--highlight-yellow': 'rgba(255, 255, 51, 0.2)',
            '--highlight-green': 'rgba(51, 255, 0, 0.2)',
            '--highlight-blue': 'rgba(0, 204, 255, 0.2)',
            '--highlight-red': 'rgba(255, 51, 51, 0.2)',
            '--highlight-purple': 'rgba(204, 51, 255, 0.2)'
        },
        'Sakura': {
            '--bg-primary': '#fff0f5',
            '--bg-secondary': '#ffe6ea',
            '--bg-accent': '#ffc0cb',
            '--text-primary': '#594a4e',
            '--text-secondary': '#8c7b7f',
            '--text-muted': '#8c7b7f', // Applique aussi la correction ici (était #bdacb0)
            '--border-color': '#fadadd',
            '--primary-color': '#ff69b4',
            '--primary-hover': '#ff1493',
            '--accent-red': '#db7093',
            '--accent-gold': '#ffb6c1',
            '--highlight-yellow': 'rgba(255, 250, 205, 0.5)',
            '--highlight-green': 'rgba(152, 251, 152, 0.4)',
            '--highlight-blue': 'rgba(176, 224, 230, 0.5)',
            '--highlight-red': 'rgba(255, 182, 193, 0.5)',
            '--highlight-purple': 'rgba(221, 160, 221, 0.4)'
        },
        'Luxe': {
            '--bg-primary': '#050505',
            '--bg-secondary': '#111111',
            '--bg-tertiary': '#000000',
            '--bg-accent': '#1a1a1a',
            '--text-primary': '#e0e0e0',
            '--text-secondary': '#a0a0a0',
            '--text-muted': '#808080',
            '--border-color': '#333333',
            '--primary-color': '#cfb53b',
            '--primary-hover': '#e6c94c',
            '--accent-red': '#800020',
            '--accent-gold': '#cfb53b',
            '--shadow-color': '0, 0, 0',
            '--cork-bg-default': '#1a1a1a',
            '--highlight-yellow': 'rgba(207, 181, 59, 0.25)',
            '--highlight-green': 'rgba(85, 107, 47, 0.3)',
            '--highlight-blue': 'rgba(70, 130, 180, 0.3)',
            '--highlight-red': 'rgba(139, 0, 0, 0.3)',
            '--highlight-purple': 'rgba(75, 0, 130, 0.3)'
        }
    },

    // [MVVM : ViewModel]
    // Initialise le gestionnaire de thèmes en chargeant les données persistantes.
    init() {
        this.loadCustomThemes();
        this.loadCurrentTheme();
    },

    // [MVVM : Other]
    // Group: Util / Helper | Naming: ThemeUtils
    // Applique les couleurs d'un thème au document (Vue) et met à jour l'état interne (Modèle).
    applyTheme(colors) {
        const root = document.documentElement;
        Object.entries(colors).forEach(([variable, value]) => {
            root.style.setProperty(variable, value);

            // Gérer les variables RGB correspondantes si possible
            if (!variable.endsWith('-rgb') && !variable.includes('highlight') && !variable.includes('shadow')) {
                try {
                    const rgbValue = hexToRgb(value);
                    root.style.setProperty(`${variable}-rgb`, rgbValue);
                } catch (e) {
                    // Ignorer les échecs de conversion (ex: dégradés ou valeurs complexes)
                }
            }
        });
        this.currentTheme = colors;
        this.saveCurrentTheme();
    },

    // [MVVM : Modèle]
    // Sauvegarde le thème actuel dans le stockage local (Persistance).
    saveCurrentTheme() {
        localStorage.setItem('plume_locale-current-theme', JSON.stringify(this.currentTheme));
    },

    // [MVVM : Modèle]
    // Charge le thème actuel depuis le stockage local (Persistance).
    loadCurrentTheme() {
        const saved = localStorage.getItem('plume_locale-current-theme');
        if (saved) {
            try {
                this.currentTheme = JSON.parse(saved);
                this.applyTheme(this.currentTheme);
            } catch (e) {
                console.error('Erreur chargement thème', e);
            }
        }
    },

    // [MVVM : Modèle]
    // Sauvegarde la liste des thèmes personnalisés dans le stockage local (Persistance).
    saveCustomThemes() {
        localStorage.setItem('plume_locale-custom-themes', JSON.stringify(this.customThemes));
    },

    // [MVVM : Modèle]
    // Charge la liste des thèmes personnalisés depuis le stockage local (Persistance).
    loadCustomThemes() {
        const saved = localStorage.getItem('plume_locale-custom-themes');
        if (saved) {
            try {
                this.customThemes = JSON.parse(saved);
            } catch (e) {
                console.error('Erreur chargement thèmes personnalisés', e);
            }
        }
    },

    // [MVVM : Modèle]
    // Ajoute un nouveau thème personnalisé à la collection (Données).
    addCustomTheme(name, colors) {
        this.customThemes.push({ name, colors });
        this.saveCustomThemes();
    },

    // [MVVM : Modèle]
    // Supprime un thème personnalisé de la collection (Données).
    deleteCustomTheme(name) {
        this.customThemes = this.customThemes.filter(t => t.name !== name);
        this.saveCustomThemes();
    },

    // [MVVM : Modèle]
    // Gère l'exportation des données de thème vers un fichier JSON (Persistance/Données).
    exportTheme(colors, name) {
        const theme = {
            name: name,
            colors: colors,
            version: '1.0'
        };

        const json = JSON.stringify(theme, null, 2);
        const blob = new Blob([json], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `theme-${name.toLowerCase().replace(/\s+/g, '-')}.json`;
        a.click();
        URL.revokeObjectURL(url);
    },

    // [MVVM : Modèle]
    // Gère l'importation des données de thème depuis un fichier JSON (Données).
    importTheme(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const theme = JSON.parse(e.target.result);
                    if (theme.colors && theme.name) {
                        resolve(theme);
                    } else {
                        reject(new Error('Format de thème invalide'));
                    }
                } catch (error) {
                    reject(error);
                }
            };
            reader.onerror = () => reject(new Error('Erreur de lecture du fichier'));
            reader.readAsText(file);
        });
    }
};

// [MVVM : Vue]
// Crée et affiche l'interface utilisateur (modal) du gestionnaire de thèmes.
function openThemeManager() {
    const modal = document.createElement('div');
    modal.className = 'modal-overlay';
    modal.style.zIndex = '10000';

    const currentColors = {};
    Object.keys(themeManager.defaultVariables).forEach(variable => {
        const value = getComputedStyle(document.documentElement).getPropertyValue(variable);
        currentColors[variable] = value.trim();
    });

    modal.innerHTML = `
                <div class="modal-content" style="max-width: 1000px; max-height: 90vh; overflow: hidden; display: flex; flex-direction: column;">
                    <div class="modal-header">
                        <h2><i data-lucide="palette" style="width:24px;height:24px;vertical-align:middle;margin-right:8px;"></i>Gestionnaire de Thèmes</h2>
                        <button class="modal-close" onclick="this.closest('.modal-overlay').remove()"><i data-lucide="x" style="width:18px;height:18px;"></i></button>
                    </div>
                    
                    <div style="flex: 1; overflow-y: auto; padding: 1.5rem;">
                        <!-- Thèmes prédéfinis -->
                        <div style="margin-bottom: 2rem;">
                            <h3 style="margin-bottom: 1rem; font-size: 1.2rem; color: var(--accent-gold);">
                                <i data-lucide="book-copy" style="width:18px;height:18px;vertical-align:middle;margin-right:6px;"></i>Thèmes Prédéfinis
                            </h3>
                            <div id="presetThemesList" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 1rem;">
                            </div>
                        </div>
                        
                        <!-- Thèmes personnalisés -->
                        <div style="margin-bottom: 2rem;">
                            <h3 style="margin-bottom: 1rem; font-size: 1.2rem; color: var(--accent-gold);">
                                <i data-lucide="sparkles" style="width:18px;height:18px;vertical-align:middle;margin-right:6px;"></i>Mes Thèmes Personnalisés
                            </h3>
                            <div id="customThemesList" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 1rem;">
                            </div>
                        </div>
                        
                        <!-- Éditeur de couleurs -->
                        <div style="border-top: 2px solid var(--border-color); padding-top: 1.5rem;">
                            <h3 style="margin-bottom: 1rem; font-size: 1.2rem; color: var(--accent-gold);">
                                <i data-lucide="sliders-horizontal" style="width:18px;height:18px;vertical-align:middle;margin-right:6px;"></i>Éditeur de Thème
                            </h3>
                            
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 1rem; margin-bottom: 1.5rem;">
                                ${Object.entries(themeManager.defaultVariables).map(([variable, defaultValue]) => {
        const label = variable.replace('--', '').split('-').map(w =>
            w.charAt(0).toUpperCase() + w.slice(1)
        ).join(' ');

        const currentValue = currentColors[variable] || defaultValue;
        const hexColor = rgbaToHex(currentValue);

        return `
                                        <div class="color-input-group">
                                            <label style="display: block; margin-bottom: 0.5rem; font-weight: 500; font-size: 0.9rem;">
                                                ${label}
                                            </label>
                                            <div style="display: flex; gap: 0.5rem; align-items: center;">
                                                <input 
                                                    type="color" 
                                                    data-variable="${variable}"
                                                    value="${hexColor}"
                                                    style="width: 50px; height: 40px; border: 2px solid var(--border-color); border-radius: 4px; cursor: pointer;"
                                                >
                                                <input 
                                                    type="text" 
                                                    data-variable-text="${variable}"
                                                    value="${currentValue}"
                                                    placeholder="${currentValue}"
                                                    style="flex: 1; padding: 0.5rem; border: 1px solid var(--border-color); border-radius: 4px; font-family: 'Source Code Pro', monospace; font-size: 0.85rem;"
                                                >
                                            </div>
                                        </div>
                                    `;
    }).join('')}
                            </div>
                            
                            <!-- Actions de l'éditeur -->
                            <div style="display: flex; gap: 0.75rem; flex-wrap: wrap; padding-top: 1rem; border-top: 1px solid var(--border-color);">
                                <button onclick="applyCurrentEditorColors()" class="btn-primary">
                                    <i data-lucide="check" style="width:16px;height:16px;vertical-align:middle;margin-right:4px;"></i>Appliquer les Couleurs
                                </button>
                                <button onclick="saveThemeAsCustom()" class="btn-primary" style="background: var(--accent-gold);">
                                    <i data-lucide="save" style="width:16px;height:16px;vertical-align:middle;margin-right:4px;"></i>Sauvegarder comme Thème
                                </button>
                                <button onclick="exportCurrentTheme()" class="btn-secondary">
                                    <i data-lucide="upload" style="width:16px;height:16px;vertical-align:middle;margin-right:4px;"></i>Exporter en JSON
                                </button>
                                <button onclick="importThemeFile()" class="btn-secondary">
                                    <i data-lucide="download" style="width:16px;height:16px;vertical-align:middle;margin-right:4px;"></i>Importer depuis JSON
                                </button>
                                <button onclick="resetToDefault()" class="btn-secondary" style="margin-left: auto;">
                                    <i data-lucide="refresh-cw" style="width:16px;height:16px;vertical-align:middle;margin-right:4px;"></i>Réinitialiser
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            `;

    document.body.appendChild(modal);

    // Remplir les thèmes prédéfinis
    renderPresetThemes();
    renderCustomThemes();

    // Activer les icônes Lucide dans la modale
    if (typeof lucide !== 'undefined') {
        lucide.createIcons();
    }

    // Lier les changements de couleur en temps réel
    modal.querySelectorAll('input[type="color"]').forEach(input => {
        input.addEventListener('input', (e) => {
            const variable = e.target.dataset.variable;
            const color = e.target.value;
            const textInput = modal.querySelector(`input[data-variable-text="${variable}"]`);
            textInput.value = color;
            document.documentElement.style.setProperty(variable, color);
        });
    });

    modal.querySelectorAll('input[data-variable-text]').forEach(input => {
        input.addEventListener('change', (e) => {
            const variable = e.target.dataset.variableText;
            const color = e.target.value;
            document.documentElement.style.setProperty(variable, color);

            // Mettre à jour le color picker si possible
            const hexColor = rgbaToHex(color);
            const colorInput = modal.querySelector(`input[data-variable="${variable}"]`);
            if (colorInput && hexColor.match(/^#[0-9A-F]{6}$/i)) {
                colorInput.value = hexColor;
            }
        });
    });
}

// [MVVM : Vue]
// Génère et affiche la liste des thèmes prédéfinis dans l'interface.
function renderPresetThemes() {
    const container = document.getElementById('presetThemesList');
    container.innerHTML = Object.entries(themeManager.presetThemes).map(([name, colors]) => `
                <div class="theme-card" style="border: 2px solid var(--border-color); border-radius: 8px; padding: 1rem; cursor: pointer; transition: all 0.2s;"
                     onmouseover="this.style.borderColor='var(--accent-gold)'"
                     onmouseout="this.style.borderColor='var(--border-color)'"
                     onclick="applyPresetTheme('${name}')">
                    <div style="font-weight: 600; margin-bottom: 0.75rem; font-size: 1rem;">
                        ${name}
                    </div>
                    <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 0.25rem;">
                        ${Object.values(colors).slice(0, 10).map(color => `
                            <div style="width: 100%; padding-bottom: 100%; background: ${color}; border-radius: 2px; border: 1px solid rgba(0,0,0,0.1);"></div>
                        `).join('')}
                    </div>
                </div>
            `).join('');
}

// [MVVM : Vue]
// Génère et affiche la liste des thèmes personnalisés dans l'interface.
function renderCustomThemes() {
    const container = document.getElementById('customThemesList');
    if (themeManager.customThemes.length === 0) {
        container.innerHTML = '<p style="color: var(--text-muted); font-style: italic;">Aucun thème personnalisé</p>';
        return;
    }

    container.innerHTML = themeManager.customThemes.map(theme => `
                <div class="theme-card" style="border: 2px solid var(--border-color); border-radius: 8px; padding: 1rem; position: relative;">
                    <button onclick="deleteCustomTheme('${theme.name}')" 
                            style="position: absolute; top: 0.5rem; right: 0.5rem; background: var(--accent-red); color: white; border: none; border-radius: 4px; width: 24px; height: 24px; cursor: pointer; font-size: 0.9rem;"
                            title="Supprimer">✕</button>
                    <div style="font-weight: 600; margin-bottom: 0.75rem; font-size: 1rem; padding-right: 2rem;">
                        ${theme.name}
                    </div>
                    <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 0.25rem; margin-bottom: 0.75rem;">
                        ${Object.values(theme.colors).slice(0, 10).map(color => `
                            <div style="width: 100%; padding-bottom: 100%; background: ${color}; border-radius: 2px; border: 1px solid rgba(0,0,0,0.1);"></div>
                        `).join('')}
                    </div>
                    <button onclick="applyCustomTheme('${theme.name}')" class="btn-secondary" style="width: 100%; padding: 0.5rem; font-size: 0.85rem;">
                        Appliquer
                    </button>
                </div>
            `).join('');
}

// [MVVM : ViewModel]
// Logique de coordination pour appliquer un thème prédéfini et mettre à jour l'éditeur.
function applyPresetTheme(name) {
    const colors = themeManager.presetThemes[name];
    themeManager.applyTheme(colors);
    showNotification(`✓ Thème "${name}" appliqué`);

    // Mettre à jour l'éditeur
    Object.entries(colors).forEach(([variable, value]) => {
        const colorInput = document.querySelector(`input[data-variable="${variable}"]`);
        const textInput = document.querySelector(`input[data-variable-text="${variable}"]`);
        if (colorInput && textInput) {
            textInput.value = value;
            const hexColor = rgbaToHex(value);
            if (hexColor.match(/^#[0-9A-F]{6}$/i)) {
                colorInput.value = hexColor;
            }
        }
    });
}

// [MVVM : ViewModel]
// Logique de coordination pour appliquer un thème personnalisé et mettre à jour l'éditeur.
function applyCustomTheme(name) {
    const theme = themeManager.customThemes.find(t => t.name === name);
    if (theme) {
        themeManager.applyTheme(theme.colors);
        showNotification(`✓ Thème "${name}" appliqué`);

        // Mettre à jour l'éditeur
        Object.entries(theme.colors).forEach(([variable, value]) => {
            const colorInput = document.querySelector(`input[data-variable="${variable}"]`);
            const textInput = document.querySelector(`input[data-variable-text="${variable}"]`);
            if (colorInput && textInput) {
                textInput.value = value;
                const hexColor = rgbaToHex(value);
                if (hexColor.match(/^#[0-9A-F]{6}$/i)) {
                    colorInput.value = hexColor;
                }
            }
        });
    }
}

// [MVVM : ViewModel]
// Logique de transition pour supprimer un thème et mettre à jour l'interface.
function deleteCustomTheme(name) {
    if (confirm(`Supprimer le thème "${name}" ?`)) {
        themeManager.deleteCustomTheme(name);
        renderCustomThemes();
        showNotification(`✓ Thème "${name}" supprimé`);
    }
}

// [MVVM : ViewModel]
// Récupère les valeurs de l'éditeur pour les appliquer au document.
function applyCurrentEditorColors() {
    const colors = {};
    document.querySelectorAll('input[data-variable-text]').forEach(input => {
        const variable = input.dataset.variableText;
        colors[variable] = input.value;
    });
    themeManager.applyTheme(colors);
    showNotification('✓ Couleurs appliquées');
}

// [MVVM : ViewModel]
// Gère le flux de sauvegarde d'un nouveau thème personnalisé.
function saveThemeAsCustom() {
    const name = prompt('Nom du thème :');
    if (!name) return;

    // Vérifier si le nom existe déjà
    if (themeManager.customThemes.find(t => t.name === name)) {
        if (!confirm(`Un thème nommé "${name}" existe déjà. Remplacer ?`)) {
            return;
        }
        themeManager.deleteCustomTheme(name);
    }

    const colors = {};
    document.querySelectorAll('input[data-variable-text]').forEach(input => {
        const variable = input.dataset.variableText;
        colors[variable] = input.value;
    });

    themeManager.addCustomTheme(name, colors);
    renderCustomThemes();
    showNotification(`✓ Thème "${name}" sauvegardé`);
}

// [MVVM : ViewModel]
// Prépare et lance l'exportation du thème actuellement édité.
function exportCurrentTheme() {
    const name = prompt('Nom du thème pour l\'export :', 'Mon Thème');
    if (!name) return;

    const colors = {};
    document.querySelectorAll('input[data-variable-text]').forEach(input => {
        const variable = input.dataset.variableText;
        colors[variable] = input.value;
    });

    themeManager.exportTheme(colors, name);
    showNotification(`✓ Thème "${name}" exporté`);
}

// [MVVM : ViewModel]
// Coordonne l'importation de fichier et la décision de l'utilisateur.
function importThemeFile() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';
    input.onchange = async (e) => {
        try {
            const file = e.target.files[0];
            const theme = await themeManager.importTheme(file);

            // Demander si on veut l'appliquer ou le sauvegarder
            const choice = confirm(`Thème "${theme.name}" importé.\n\nOK = Appliquer maintenant\nAnnuler = Sauvegarder dans mes thèmes`);

            if (choice) {
                themeManager.applyTheme(theme.colors);
                showNotification(`✓ Thème "${theme.name}" appliqué`);
            } else {
                // Vérifier si le nom existe
                if (themeManager.customThemes.find(t => t.name === theme.name)) {
                    if (!confirm(`Un thème nommé "${theme.name}" existe déjà. Remplacer ?`)) {
                        return;
                    }
                    themeManager.deleteCustomTheme(theme.name);
                }
                themeManager.addCustomTheme(theme.name, theme.colors);
                renderCustomThemes();
                showNotification(`✓ Thème "${theme.name}" sauvegardé`);
            }

            // Mettre à jour l'éditeur
            Object.entries(theme.colors).forEach(([variable, value]) => {
                const colorInput = document.querySelector(`input[data-variable="${variable}"]`);
                const textInput = document.querySelector(`input[data-variable-text="${variable}"]`);
                if (colorInput && textInput) {
                    textInput.value = value;
                    const hexColor = rgbaToHex(value);
                    if (hexColor.match(/^#[0-9A-F]{6}$/i)) {
                        colorInput.value = hexColor;
                    }
                }
            });

        } catch (error) {
            alert(`Erreur lors de l'import : ${error.message}`);
        }
    };
    input.click();
}

// [MVVM : ViewModel]
// Restaure les couleurs par défaut du document et de l'éditeur.
function resetToDefault() {
    if (confirm('Revenir au thème par défaut ?')) {
        themeManager.applyTheme(themeManager.defaultVariables);
        showNotification('✓ Thème par défaut restauré');

        // Mettre à jour l'éditeur
        Object.entries(themeManager.defaultVariables).forEach(([variable, value]) => {
            const colorInput = document.querySelector(`input[data-variable="${variable}"]`);
            const textInput = document.querySelector(`input[data-variable-text="${variable}"]`);
            if (colorInput && textInput) {
                textInput.value = value;
                const hexColor = rgbaToHex(value);
                if (hexColor.match(/^#[0-9A-F]{6}$/i)) {
                    colorInput.value = hexColor;
                }
            }
        });
    }
}


// ========== js/39.export.js ==========
// ============================================
// EXPORT NOVEL FUNCTIONS
// ============================================

/**
 * Strips HTML tags from a string.
 */
function stripHTML(html) {
    if (!html) return '';
    const div = document.createElement('div');
    div.innerHTML = html;
    return div.textContent || div.innerText || '';
}


// Global variable to track selection state
let exportSelectionState = {};

// [MVVM : Other]
// Group: Coordinator | Naming: ExportCoordinator
// Ouvre la modale d'exportation du roman et initialise l'état de sélection.
function openExportNovelModal() {
    // Initialize selection state with all items checked
    exportSelectionState = {};
    project.acts.forEach(act => {
        exportSelectionState[`act-${act.id}`] = true;
        act.chapters.forEach(chapter => {
            exportSelectionState[`chapter-${chapter.id}`] = true;
            chapter.scenes.forEach(scene => {
                exportSelectionState[`scene-${scene.id}`] = true;
            });
        });
    });

    renderExportTree();
    updateExportFormatInfo();
    document.getElementById('exportNovelModal').classList.add('active');
}

// [MVVM : View]
// Génère et affiche l'arborescence des éléments (actes, chapitres, scènes) à exporter.
function renderExportTree() {
    const container = document.getElementById('exportTreeContainer');
    console.log('renderExportTree called, container:', container);
    console.log('project.acts:', project.acts);
    if (!container) return;

    let html = '';

    if (!project.acts || project.acts.length === 0) {
        html = '<p style="color: var(--text-muted); text-align: center;">Aucun acte à exporter</p>';
        container.innerHTML = html;
        return;
    }

    project.acts.forEach((act, actIndex) => {
        const actChecked = exportSelectionState[`act-${act.id}`] ? 'checked' : '';
        html += `
                    <div style="margin-bottom: 1rem;">
                        <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-weight: 600; font-size: 1rem; margin-bottom: 0.5rem;">
                            <input type="checkbox" ${actChecked} onchange="toggleAct(${act.id})" id="export-act-${act.id}" style="cursor: pointer;">
                            <span>Acte ${actIndex + 1}</span>
                        </label>
                        <div style="margin-left: 1.5rem;">
                `;

        act.chapters.forEach((chapter, chapIndex) => {
            const chapterChecked = exportSelectionState[`chapter-${chapter.id}`] ? 'checked' : '';
            html += `
                        <div style="margin-bottom: 0.75rem;">
                            <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-weight: 500; font-size: 0.95rem; margin-bottom: 0.25rem;">
                                <input type="checkbox" ${chapterChecked} onchange="toggleChapter(${act.id}, ${chapter.id})" id="export-chapter-${chapter.id}" style="cursor: pointer;">
                                <span>Chapitre ${chapIndex + 1}</span>
                            </label>
                            <div style="margin-left: 1.5rem;">
                    `;

            chapter.scenes.forEach((scene, sceneIndex) => {
                const sceneChecked = exportSelectionState[`scene-${scene.id}`] ? 'checked' : '';
                html += `
                            <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-size: 0.9rem; color: var(--text-secondary); margin-bottom: 0.25rem;">
                                <input type="checkbox" ${sceneChecked} onchange="toggleScene(${act.id}, ${chapter.id}, ${scene.id})" id="export-scene-${scene.id}" style="cursor: pointer;">
                                <span>Scène ${sceneIndex + 1}</span>
                            </label>
                        `;
            });

            html += `
                            </div>
                        </div>
                    `;
        });

        html += `
                        </div>
                    </div>
                `;
    });

    container.innerHTML = html;
}

// [MVVM : ViewModel]
// Alterne la sélection de l'ensemble des éléments du projet pour l'export.
function toggleAllScenes() {
    // Check if all are currently selected
    const allSelected = Object.values(exportSelectionState).every(v => v === true);

    // Toggle all to opposite state
    const newState = !allSelected;

    project.acts.forEach(act => {
        exportSelectionState[`act-${act.id}`] = newState;
        act.chapters.forEach(chapter => {
            exportSelectionState[`chapter-${chapter.id}`] = newState;
            chapter.scenes.forEach(scene => {
                exportSelectionState[`scene-${scene.id}`] = newState;
            });
        });
    });

    renderExportTree();
}

// Act Management
// Fonctions toggleAct et toggleChapter déjà définies plus haut (lignes ~5854 et ~5944)
// Les définitions en double ont été supprimées pour éviter les conflits

// [MVVM : ViewModel]
// Gère le changement d'état de sélection d'une scène et met à jour les parents (chapitre, acte).
function toggleScene(actId, chapterId, sceneId) {
    const checkbox = document.getElementById(`export-scene-${sceneId}`);
    exportSelectionState[`scene-${sceneId}`] = checkbox.checked;

    // Update chapter checkbox
    const act = project.acts.find(a => a.id === actId);
    if (act) {
        const chapter = act.chapters.find(c => c.id === chapterId);
        if (chapter) {
            const allScenesChecked = chapter.scenes.every(s => exportSelectionState[`scene-${s.id}`]);
            exportSelectionState[`chapter-${chapterId}`] = allScenesChecked;

            // Update act checkbox
            const allChaptersChecked = act.chapters.every(c => exportSelectionState[`chapter-${c.id}`]);
            exportSelectionState[`act-${actId}`] = allChaptersChecked;
        }
    }

    renderExportTree();
}

// [MVVM : View]
// Met à jour les informations textuelles affichées selon le format d'export choisi.
function updateExportFormatInfo() {
    const format = document.getElementById('exportFormatSelect').value;
    const infoBox = document.getElementById('formatInfoBox');

    const messages = {
        docx: '<strong style="color: var(--text-primary);">ℹ️ Note :</strong> Toutes les fonctionnalités ne sont pas supportées en format DOCX. Le texte exporté pourrait ne pas ressembler exactement à l\'éditeur. Pour une compatibilité complète, utilisez un autre format.',
        markdown: '<strong style="color: var(--text-primary);">✅ Format Markdown :</strong> Excellent pour la portabilité et la compatibilité avec la plupart des éditeurs de texte et des plateformes de publication.',
        txt: '<strong style="color: var(--text-primary);">📋 Texte brut :</strong> Format universel sans formatage. Compatible avec tous les logiciels.',
        html: '<strong style="color: var(--text-primary);">🌐 HTML :</strong> Format web avec préservation complète du formatage. Ouvrez dans un navigateur ou importez dans des éditeurs HTML.',
        epub: '<strong style="color: var(--text-primary);">📚 EPUB :</strong> Format e-book standard. Compatible avec Kindle (via conversion), Kobo, Apple Books, et la plupart des liseuses.'
    };

    infoBox.innerHTML = messages[format] || messages.docx;
}

// [MVVM : ViewModel]
// Récupère les options de l'interface et lance le processus d'exportation approprié.
function executeNovelExport() {
    const format = document.getElementById('exportFormatSelect').value;
    const options = {
        exportSummaries: document.getElementById('exportSummariesCheck').checked,
        exportProse: document.getElementById('exportProseCheck').checked,
        includeActTitles: document.getElementById('includeActTitlesCheck').checked,
        includeSceneSubtitles: document.getElementById('includeSceneSubtitlesCheck').checked,
        sceneDivider: document.getElementById('sceneDividerSelect').value,
        includeCharacters: document.getElementById('includeCharactersCheck').checked,
        includeWorld: document.getElementById('includeWorldCheck').checked,
        includeTimeline: document.getElementById('includeTimelineCheck').checked,
        includeRelations: document.getElementById('includeRelationsCheck').checked,
        includeCodex: document.getElementById('includeCodexCheck').checked,
        includeNotes: document.getElementById('includeNotesCheck').checked
    };

    // Check if creating a ZIP archive (project export)
    const isProjectExport = options.includeCharacters || options.includeWorld ||
        options.includeTimeline || options.includeRelations ||
        options.includeCodex || options.includeNotes;

    if (isProjectExport) {
        exportProjectAsZip(format, options);
    } else {
        // Single file export
        switch (format) {
            case 'docx':
                exportAsDOCX(options);
                break;
            case 'markdown':
                exportAsMarkdown(options);
                break;
            case 'txt':
                exportAsTXT(options);
                break;
            case 'html':
                exportAsHTML(options);
                break;
            case 'epub':
                exportAsEPUB(options);
                break;
        }
    }
}

// [MVVM : ViewModel]
// Coche ou décoche toutes les options additionnelles d'export (personnages, univers, etc.).
function toggleAllExportOptions(selectAll) {
    const checkboxes = [
        'includeCharactersCheck', 'includeWorldCheck', 'includeTimelineCheck',
        'includeRelationsCheck', 'includeCodexCheck', 'includeNotesCheck'
    ];
    checkboxes.forEach(id => {
        const checkbox = document.getElementById(id);
        if (checkbox) checkbox.checked = selectAll;
    });
}

// [MVVM : ViewModel]
// Extrait et structure les données du projet sélectionnées pour l'exportation.
function getSelectedContent(options) {
    let content = {
        acts: []
    };

    project.acts.forEach((act, actIndex) => {
        if (!exportSelectionState[`act-${act.id}`]) return;

        let exportAct = {
            title: `Acte ${actIndex + 1}`,
            chapters: []
        };

        act.chapters.forEach((chapter, chapIndex) => {
            if (!exportSelectionState[`chapter-${chapter.id}`]) return;

            let exportChapter = {
                title: chapter.title || `Chapitre ${chapIndex + 1}`,
                scenes: []
            };

            chapter.scenes.forEach((scene, sceneIndex) => {
                if (!exportSelectionState[`scene-${scene.id}`]) return;

                // Utiliser la version finale si elle existe, sinon le contenu actuel
                const sceneContent = getSceneExportContent(scene);

                let exportScene = {
                    title: scene.title || `Scène ${sceneIndex + 1}`,
                    summary: scene.summary || '',
                    content: sceneContent || ''
                };

                exportChapter.scenes.push(exportScene);
            });

            if (exportChapter.scenes.length > 0) {
                exportAct.chapters.push(exportChapter);
            }
        });

        if (exportAct.chapters.length > 0) {
            content.acts.push(exportAct);
        }
    });

    return content;
}

// [MVVM : Other]
// Group: Util / Helper | Naming: ExportUtils
// Retourne la chaîne de caractères utilisée comme séparateur de scènes selon le type choisi.
function getSceneDivider(dividerType) {
    switch (dividerType) {
        case 'asterisks':
            return '\n\n* * *\n\n';
        case 'hash':
            return '\n\n###\n\n';
        case 'line':
            return '\n\n---\n\n';
        case 'space':
            return '\n\n\n';
        case 'none':
            return '\n\n';
        default:
            return '\n\n* * *\n\n';
    }
}

// [MVVM : Other]
// Group: Service | Naming: ExportService
// Génère et télécharge le contenu du projet au format Markdown.
function exportAsMarkdown(options) {
    const content = getSelectedContent(options);
    const divider = getSceneDivider(options.sceneDivider);
    let markdown = `# ${project.title}\n\n`;

    content.acts.forEach((act, actIndex) => {
        if (options.includeActTitles) {
            markdown += `# ${act.title}\n\n`;
        }

        act.chapters.forEach((chapter, chapIndex) => {
            markdown += `## ${chapter.title}\n\n`;

            chapter.scenes.forEach((scene, sceneIndex) => {
                if (options.includeSceneSubtitles && scene.title) {
                    markdown += `### ${scene.title}\n\n`;
                }

                if (options.exportSummaries && scene.summary) {
                    markdown += `> ${scene.summary}\n\n`;
                }

                if (options.exportProse && scene.content) {
                    markdown += `${stripHTML(scene.content)}\n`;
                }

                // Add divider between scenes (except after last scene)
                if (sceneIndex < chapter.scenes.length - 1) {
                    markdown += divider;
                }
            });

            markdown += '\n\n';
        });
    });

    downloadFile(markdown, `${project.title}.md`, 'text/markdown');
    showNotification('✓ Export Markdown terminé');
    closeModal('exportNovelModal');
}

// [MVVM : Other]
// Group: Service | Naming: ExportService
// Génère et télécharge le contenu du projet au format texte brut (.txt).
function exportAsTXT(options) {
    const content = getSelectedContent(options);
    const divider = getSceneDivider(options.sceneDivider);
    let text = `${project.title}\n${'='.repeat(project.title.length)}\n\n`;

    content.acts.forEach((act, actIndex) => {
        if (options.includeActTitles) {
            text += `${act.title}\n${'-'.repeat(act.title.length)}\n\n`;
        }

        act.chapters.forEach((chapter, chapIndex) => {
            text += `${chapter.title}\n\n`;

            chapter.scenes.forEach((scene, sceneIndex) => {
                if (options.includeSceneSubtitles && scene.title) {
                    text += `${scene.title}\n\n`;
                }

                if (options.exportSummaries && scene.summary) {
                    text += `[Résumé: ${scene.summary}]\n\n`;
                }

                if (options.exportProse && scene.content) {
                    text += `${stripHTML(scene.content)}\n`;
                }

                if (sceneIndex < chapter.scenes.length - 1) {
                    text += divider;
                }
            });

            text += '\n\n';
        });
    });

    downloadFile(text, `${project.title}.txt`, 'text/plain');
    showNotification('✓ Export TXT terminé');
    closeModal('exportNovelModal');
}

// [MVVM : Other]
// Group: Service | Naming: ExportService
// Génère et télécharge le contenu du projet au format HTML.
function exportAsHTML(options) {
    const content = getSelectedContent(options);
    const divider = getSceneDivider(options.sceneDivider).replace(/\n/g, '<br>');

    let html = `<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${project.title}</title>
    <style>
        body {
            font-family: 'Georgia', serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 2rem;
            line-height: 1.8;
            color: #333;
            background: #fafafa;
        }
        h1 {
            font-size: 2.5rem;
            margin-bottom: 2rem;
            text-align: center;
            border-bottom: 3px solid #333;
            padding-bottom: 1rem;
        }
        h2 {
            font-size: 2rem;
            margin-top: 3rem;
            margin-bottom: 1.5rem;
            border-bottom: 2px solid #666;
            padding-bottom: 0.5rem;
        }
        h3 {
            font-size: 1.5rem;
            margin-top: 2rem;
            margin-bottom: 1rem;
            color: #666;
        }
        h4 {
            font-size: 1.2rem;
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
            color: #888;
            font-style: italic;
        }
        p {
            margin-bottom: 1rem;
            text-align: justify;
        }
        .summary {
            background: #f0f0f0;
            padding: 1rem;
            border-left: 4px solid #999;
            margin: 1rem 0;
            font-style: italic;
            color: #666;
        }
        .divider {
            text-align: center;
            margin: 2rem 0;
            color: #999;
        }
    </style>
</head>
<body>
    <h1>${project.title}</h1>
`;

    content.acts.forEach((act, actIndex) => {
        if (options.includeActTitles) {
            html += `    <h2>${act.title}</h2>\n`;
        }

        act.chapters.forEach((chapter, chapIndex) => {
            html += `    <h3>${chapter.title}</h3>\n`;

            chapter.scenes.forEach((scene, sceneIndex) => {
                if (options.includeSceneSubtitles && scene.title) {
                    html += `    <h4>${scene.title}</h4>\n`;
                }

                if (options.exportSummaries && scene.summary) {
                    html += `    <div class="summary">${scene.summary}</div>\n`;
                }

                if (options.exportProse && scene.content) {
                    // Convert line breaks to paragraphs after stripping HTML
                    const plainText = stripHTML(scene.content);
                    const paragraphs = plainText.split('\n').filter(p => p.trim());
                    paragraphs.forEach(para => {
                        html += `    <p>${para}</p>\n`;
                    });
                }

                if (sceneIndex < chapter.scenes.length - 1 && options.sceneDivider !== 'none') {
                    html += `    <div class="divider">${divider}</div>\n`;
                }
            });
        });
    });

    html += `    </body>\n</html>`;

    downloadFile(html, `${project.title}.html`, 'text/html');
    showNotification('✓ Export HTML terminé');
    closeModal('exportNovelModal');
}

// [MVVM : Other]
// Group: Service | Naming: ExportService
// Génère et télécharge le contenu du projet au format EPUB (utilisant JSZip).
async function exportAsEPUB(options) {
    if (typeof JSZip === 'undefined') {
        alert('❌ Erreur : La bibliothèque JSZip n\'est pas chargée. Veuillez rafraîchir la page.');
        return;
    }

    const content = getSelectedContent(options);
    const zip = new JSZip();
    const bookId = 'plume-' + Date.now();
    const timestamp = new Date().toISOString().split('.')[0] + 'Z';

    // Helper to escape XML
    const escapeXML = (str) => {
        if (!str) return '';
        return str.replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&apos;');
    };

    // Helper to convert HTML content to XHTML
    const toXHTML = (html) => {
        if (!html) return '';
        const plainText = stripHTML(html);
        const paragraphs = plainText.split('\n').filter(p => p.trim());
        return paragraphs.map(p => `<p>${escapeXML(p)}</p>`).join('\n');
    };

    // Get scene divider for EPUB
    const getDividerXHTML = () => {
        switch (options.sceneDivider) {
            case 'asterisks': return '<p class="divider">* * *</p>';
            case 'hash': return '<p class="divider">###</p>';
            case 'line': return '<hr class="divider"/>';
            case 'space': return '<p class="divider-space">&#160;</p>';
            case 'none': return '';
            default: return '<p class="divider">* * *</p>';
        }
    };

    // 1. mimetype (must be first and uncompressed)
    zip.file('mimetype', 'application/epub+zip', { compression: 'STORE' });

    // 2. META-INF/container.xml
    const containerXML = `<?xml version="1.0" encoding="UTF-8"?>
<container version="1.0" xmlns="urn:oasis:names:tc:opendocument:xmlns:container">
  <rootfiles>
    <rootfile full-path="OEBPS/content.opf" media-type="application/oebps-package+xml"/>
  </rootfiles>
</container>`;
    zip.file('META-INF/container.xml', containerXML);

    // 3. OEBPS/styles.css
    const stylesCSS = `
body {
    font-family: Georgia, "Times New Roman", serif;
    margin: 1em;
    line-height: 1.6;
}
h1 {
    font-size: 1.8em;
    text-align: center;
    margin: 1em 0;
    page-break-before: always;
}
h2 {
    font-size: 1.4em;
    margin: 1.5em 0 0.5em 0;
    page-break-before: always;
}
h3 {
    font-size: 1.1em;
    font-style: italic;
    margin: 1em 0 0.5em 0;
}
p {
    margin: 0;
    text-indent: 1.5em;
    text-align: justify;
}
p:first-of-type, h1 + p, h2 + p, h3 + p, .divider + p, .divider-space + p, hr + p {
    text-indent: 0;
}
.summary {
    font-style: italic;
    color: #666;
    margin: 1em 0;
    padding: 0.5em;
    border-left: 3px solid #ccc;
    text-indent: 0;
}
.divider {
    text-align: center;
    margin: 1.5em 0;
    text-indent: 0;
}
.divider-space {
    margin: 2em 0;
    text-indent: 0;
}
hr.divider {
    border: none;
    border-top: 1px solid #ccc;
    margin: 1.5em 2em;
}
.title-page {
    text-align: center;
    margin-top: 30%;
}
.title-page h1 {
    page-break-before: avoid;
}
`;
    zip.file('OEBPS/styles.css', stylesCSS);

    // 4. Generate chapter files and build manifest/spine
    const manifestItems = [];
    const spineItems = [];
    let chapterNum = 0;

    // Title page
    const titlePageXHTML = `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="fr" lang="fr">
<head>
    <meta charset="UTF-8"/>
    <title>${escapeXML(project.title)}</title>
    <link rel="stylesheet" type="text/css" href="styles.css"/>
</head>
<body>
    <div class="title-page">
        <h1>${escapeXML(project.title)}</h1>
    </div>
</body>
</html>`;
    zip.file('OEBPS/title.xhtml', titlePageXHTML);
    manifestItems.push('<item id="title" href="title.xhtml" media-type="application/xhtml+xml"/>');
    spineItems.push('<itemref idref="title"/>');

    // NAV document (EPUB 3 navigation)
    let navContent = `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="fr" lang="fr">
<head>
    <meta charset="UTF-8"/>
    <title>Table des matières</title>
    <link rel="stylesheet" type="text/css" href="styles.css"/>
</head>
<body>
    <nav epub:type="toc" id="toc">
        <h1>Table des matières</h1>
        <ol>
            <li><a href="title.xhtml">${escapeXML(project.title)}</a></li>
`;

    // Generate chapter files
    content.acts.forEach((act, actIndex) => {
        if (options.includeActTitles) {
            navContent += `            <li><a href="chapter${chapterNum + 1}.xhtml">${escapeXML(act.title)}</a>
                <ol>\n`;
        }

        act.chapters.forEach((chapter, chapIndex) => {
            chapterNum++;
            const chapterId = `chapter${chapterNum}`;
            const fileName = `${chapterId}.xhtml`;

            let chapterContent = `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="fr" lang="fr">
<head>
    <meta charset="UTF-8"/>
    <title>${escapeXML(chapter.title)}</title>
    <link rel="stylesheet" type="text/css" href="styles.css"/>
</head>
<body>
`;

            if (options.includeActTitles && chapIndex === 0) {
                chapterContent += `    <h1>${escapeXML(act.title)}</h1>\n`;
            }

            chapterContent += `    <h2>${escapeXML(chapter.title)}</h2>\n`;

            chapter.scenes.forEach((scene, sceneIndex) => {
                if (options.includeSceneSubtitles && scene.title) {
                    chapterContent += `    <h3>${escapeXML(scene.title)}</h3>\n`;
                }

                if (options.exportSummaries && scene.summary) {
                    chapterContent += `    <p class="summary">${escapeXML(scene.summary)}</p>\n`;
                }

                if (options.exportProse && scene.content) {
                    chapterContent += toXHTML(scene.content) + '\n';
                }

                if (sceneIndex < chapter.scenes.length - 1 && options.sceneDivider !== 'none') {
                    chapterContent += `    ${getDividerXHTML()}\n`;
                }
            });

            chapterContent += `    </body>\n</html>`;

            zip.file(`OEBPS/${fileName}`, chapterContent);
            manifestItems.push(`<item id="${chapterId}" href="${fileName}" media-type="application/xhtml+xml"/>`);
            spineItems.push(`<itemref idref="${chapterId}"/>`);

            if (options.includeActTitles) {
                navContent += `                    <li><a href="${fileName}">${escapeXML(chapter.title)}</a></li>\n`;
            } else {
                navContent += `            <li><a href="${fileName}">${escapeXML(chapter.title)}</a></li>\n`;
            }
        });

        if (options.includeActTitles) {
            navContent += `                </ol>
            </li>\n`;
        }
    });

    navContent += `    </body>\n</html>`;

    zip.file('OEBPS/nav.xhtml', navContent);
    manifestItems.push('<item id="nav" href="nav.xhtml" media-type="application/xhtml+xml" properties="nav"/>');

    // 5. content.opf (package document)
    const contentOPF = `<?xml version="1.0" encoding="UTF-8"?>
<package xmlns="http://www.idpf.org/2007/opf" version="3.0" unique-identifier="BookId">
    <metadata xmlns:dc="http://purl.org/dc/elements/1.1/">
        <dc:identifier id="BookId">${bookId}</dc:identifier>
        <dc:title>${escapeXML(project.title)}</dc:title>
        <dc:language>fr</dc:language>
        <dc:creator>Plume</dc:creator>
        <meta property="dcterms:modified">${timestamp}</meta>
    </metadata>
    <manifest>
        <item id="css" href="styles.css" media-type="text/css"/>
        ${manifestItems.join('\n        ')}
    </manifest>
    <spine>
        ${spineItems.join('\n        ')}
    </spine>
</package>`;

    zip.file('OEBPS/content.opf', contentOPF);

    // Generate the EPUB file
    try {
        const blob = await zip.generateAsync({
            type: 'blob',
            mimeType: 'application/epub+zip',
            compression: 'DEFLATE',
            compressionOptions: { level: 9 }
        });
        saveAs(blob, `${project.title}.epub`);
        showNotification('✓ Export EPUB terminé');
        closeModal('exportNovelModal');
    } catch (error) {
        alert('❌ Erreur lors de l\'export EPUB : ' + error.message);
        console.error(error);
    }
}

// [MVVM : autre]
// Génère et télécharge le contenu du projet au format DOCX (utilisant la bibliothèque docx).
async function exportAsDOCX(options) {
    // Check if docx library is loaded
    if (typeof docx === 'undefined') {
        alert('❌ Erreur : La bibliothèque DOCX n\'est pas chargée. Veuillez rafraîchir la page.');
        return;
    }

    const content = getSelectedContent(options);
    const { Document, Packer, Paragraph, TextRun, HeadingLevel, AlignmentType } = docx;

    const children = [];

    // Title
    children.push(
        new Paragraph({
            text: project.title,
            heading: HeadingLevel.TITLE,
            alignment: AlignmentType.CENTER,
            spacing: { after: 400 }
        })
    );

    content.acts.forEach((act, actIndex) => {
        if (options.includeActTitles) {
            children.push(
                new Paragraph({
                    text: act.title,
                    heading: HeadingLevel.HEADING_1,
                    spacing: { before: 400, after: 200 }
                })
            );
        }

        act.chapters.forEach((chapter, chapIndex) => {
            children.push(
                new Paragraph({
                    text: chapter.title,
                    heading: HeadingLevel.HEADING_2,
                    spacing: { before: 300, after: 200 }
                })
            );

            chapter.scenes.forEach((scene, sceneIndex) => {
                if (options.includeSceneSubtitles && scene.title) {
                    children.push(
                        new Paragraph({
                            text: scene.title,
                            heading: HeadingLevel.HEADING_3,
                            spacing: { before: 200, after: 100 }
                        })
                    );
                }

                if (options.exportSummaries && scene.summary) {
                    children.push(
                        new Paragraph({
                            children: [
                                new TextRun({
                                    text: scene.summary,
                                    italics: true
                                })
                            ],
                            spacing: { after: 200 }
                        })
                    );
                }

                if (options.exportProse && scene.content) {
                    const plainText = stripHTML(scene.content);
                    const paragraphs = plainText.split('\n').filter(p => p.trim());
                    paragraphs.forEach(para => {
                        children.push(
                            new Paragraph({
                                text: para,
                                spacing: { after: 200 }
                            })
                        );
                    });
                }

                // Add divider between scenes
                if (sceneIndex < chapter.scenes.length - 1) {
                    const dividerText = options.sceneDivider === 'asterisks' ? '* * *' :
                        options.sceneDivider === 'hash' ? '###' :
                            options.sceneDivider === 'line' ? '---' : '';

                    if (dividerText) {
                        children.push(
                            new Paragraph({
                                text: dividerText,
                                alignment: AlignmentType.CENTER,
                                spacing: { before: 200, after: 200 }
                            })
                        );
                    }
                }
            });
        });
    });

    const doc = new Document({
        sections: [{
            properties: {},
            children: children
        }]
    });

    try {
        const blob = await Packer.toBlob(doc);
        saveAs(blob, `${project.title}.docx`);
        showNotification('✓ Export DOCX terminé');
        closeModal('exportNovelModal');
    } catch (error) {
        alert('❌ Erreur lors de l\'export DOCX : ' + error.message);
        console.error(error);
    }
}

// [MVVM : autre]
// Compile le roman et ses annexes (personnages, univers, etc.) dans une archive ZIP.
async function exportProjectAsZip(format, options) {
    if (typeof JSZip === 'undefined') {
        alert('❌ Erreur : La bibliothèque JSZip n\'est pas chargée. Veuillez rafraîchir la page.');
        return;
    }

    const zip = new JSZip();

    // Add main novel file
    const content = getSelectedContent(options);
    let mainFileContent = '';
    let mainFileName = '';

    switch (format) {
        case 'markdown':
            mainFileContent = await generateMarkdownContent(content, options);
            mainFileName = `${project.title}.md`;
            break;
        case 'txt':
            mainFileContent = await generateTXTContent(content, options);
            mainFileName = `${project.title}.txt`;
            break;
        case 'html':
            mainFileContent = await generateHTMLContent(content, options);
            mainFileName = `${project.title}.html`;
            break;
        case 'docx':
            // DOCX is binary, handled separately below
            break;
    }

    if (format !== 'docx') {
        zip.file(mainFileName, mainFileContent);
    } else {
        // For DOCX, we need to generate the binary blob
        const docxBlob = await generateDOCXBlob(content, options);
        zip.file(`${project.title}.docx`, docxBlob);
    }

    // Add Characters if requested
    if (options.includeCharacters && project.characters && project.characters.length > 0) {
        let charactersContent = '# Personnages\n\n';
        project.characters.forEach(char => {
            charactersContent += `## ${char.name}\n\n`;
            if (char.role) charactersContent += `**Rôle:** ${char.role}\n\n`;
            if (char.age) charactersContent += `**Âge:** ${char.age}\n\n`;
            if (char.description) charactersContent += `**Description:** ${char.description}\n\n`;
            if (char.background) charactersContent += `**Histoire:** ${char.background}\n\n`;
            if (char.personality) charactersContent += `**Personnalité:** ${char.personality}\n\n`;
            if (char.goals) charactersContent += `**Objectifs:** ${char.goals}\n\n`;
            if (char.strengths) charactersContent += `**Forces:** ${char.strengths}\n\n`;
            if (char.weaknesses) charactersContent += `**Faiblesses:** ${char.weaknesses}\n\n`;
            if (char.notes) charactersContent += `**Notes:** ${char.notes}\n\n`;
            charactersContent += '---\n\n';
        });
        zip.file('Personnages.md', charactersContent);
    }

    // Add World/Universe if requested
    if (options.includeWorld && project.world && project.world.length > 0) {
        let worldContent = '# Univers\n\n';
        project.world.forEach(elem => {
            worldContent += `## ${elem.name}\n\n`;
            if (elem.type) worldContent += `**Type:** ${elem.type}\n\n`;
            if (elem.description) worldContent += `${elem.description}\n\n`;
            if (elem.history) worldContent += `**Histoire:** ${elem.history}\n\n`;
            if (elem.culture) worldContent += `**Culture:** ${elem.culture}\n\n`;
            if (elem.geography) worldContent += `**Géographie:** ${elem.geography}\n\n`;
            if (elem.notes) worldContent += `**Notes:** ${elem.notes}\n\n`;
            worldContent += '---\n\n';
        });
        zip.file('Univers.md', worldContent);
    }

    // Add Timeline if requested
    if (options.includeTimeline && project.timeline && project.timeline.length > 0) {
        let timelineContent = '# Timeline\n\n';
        const sortedEvents = [...project.timeline].sort((a, b) => {
            if (a.date && b.date) return new Date(a.date) - new Date(b.date);
            return (a.order || 0) - (b.order || 0);
        });
        sortedEvents.forEach(event => {
            timelineContent += `## ${event.title}\n\n`;
            if (event.date) timelineContent += `**Date:** ${event.date}\n\n`;
            if (event.era) timelineContent += `**Ère:** ${event.era}\n\n`;
            if (event.description) timelineContent += `${event.description}\n\n`;
            if (event.characters && event.characters.length > 0) {
                const charNames = event.characters.map(id => {
                    const char = project.characters?.find(c => c.id === id);
                    return char ? char.name : id;
                }).join(', ');
                timelineContent += `**Personnages impliqués:** ${charNames}\n\n`;
            }
            timelineContent += '---\n\n';
        });
        zip.file('Timeline.md', timelineContent);
    }

    // Add Relations if requested
    if (options.includeRelations && project.relationships && project.relationships.length > 0) {
        let relationsContent = '# Relations entre personnages\n\n';
        project.relationships.forEach(rel => {
            const char1 = project.characters?.find(c => c.id === rel.source || c.id === rel.from);
            const char2 = project.characters?.find(c => c.id === rel.target || c.id === rel.to);
            const name1 = char1 ? char1.name : 'Inconnu';
            const name2 = char2 ? char2.name : 'Inconnu';
            relationsContent += `## ${name1} ↔ ${name2}\n\n`;
            if (rel.type) relationsContent += `**Type:** ${rel.type}\n\n`;
            if (rel.label) relationsContent += `**Relation:** ${rel.label}\n\n`;
            if (rel.description) relationsContent += `${rel.description}\n\n`;
            relationsContent += '---\n\n';
        });
        zip.file('Relations.md', relationsContent);
    }

    // Add Codex if requested
    if (options.includeCodex && project.codex && project.codex.length > 0) {
        let codexContent = '# Codex\n\n';
        project.codex.forEach(entry => {
            codexContent += `## ${entry.title || entry.name}\n\n`;
            if (entry.category) codexContent += `**Catégorie:** ${entry.category}\n\n`;
            if (entry.content) codexContent += `${entry.content}\n\n`;
            if (entry.description) codexContent += `${entry.description}\n\n`;
            codexContent += '---\n\n';
        });
        zip.file('Codex.md', codexContent);
    }

    // Add Notes if requested  
    if (options.includeNotes && project.notes && project.notes.length > 0) {
        let notesContent = '# Notes\n\n';
        project.notes.forEach(note => {
            notesContent += `## ${note.title}\n\n`;
            if (note.category) notesContent += `**Catégorie:** ${note.category}\n\n`;
            if (note.content) notesContent += `${note.content}\n\n`;
            notesContent += '---\n\n';
        });
        zip.file('Notes.md', notesContent);
    }

    // Generate and download ZIP
    try {
        const blob = await zip.generateAsync({ type: 'blob' });
        saveAs(blob, `${project.title}_Export.zip`);
        showNotification('✓ Export du projet complet terminé');
        closeModal('exportNovelModal');
    } catch (error) {
        alert('❌ Erreur lors de la création du ZIP : ' + error.message);
        console.error(error);
    }
}

// [MVVM : autre]
// Formate les données sélectionnées en syntaxe Markdown.
async function generateMarkdownContent(content, options) {
    const divider = getSceneDivider(options.sceneDivider);
    let markdown = `# ${project.title}\n\n`;

    content.acts.forEach((act, actIndex) => {
        if (options.includeActTitles) {
            markdown += `# ${act.title}\n\n`;
        }

        act.chapters.forEach((chapter, chapIndex) => {
            markdown += `## ${chapter.title}\n\n`;

            chapter.scenes.forEach((scene, sceneIndex) => {
                if (options.includeSceneSubtitles && scene.title) {
                    markdown += `### ${scene.title}\n\n`;
                }

                if (options.exportSummaries && scene.summary) {
                    markdown += `> ${scene.summary}\n\n`;
                }

                if (options.exportProse && scene.content) {
                    markdown += `${stripHTML(scene.content)}\n`;
                }

                if (sceneIndex < chapter.scenes.length - 1) {
                    markdown += divider;
                }
            });

            markdown += '\n\n';
        });
    });

    return markdown;
}

// [MVVM : autre]
// Formate les données sélectionnées en texte brut.
async function generateTXTContent(content, options) {
    const divider = getSceneDivider(options.sceneDivider);
    let text = `${project.title}\n${'='.repeat(project.title.length)}\n\n`;

    content.acts.forEach((act, actIndex) => {
        if (options.includeActTitles) {
            text += `${act.title}\n${'-'.repeat(act.title.length)}\n\n`;
        }

        act.chapters.forEach((chapter, chapIndex) => {
            text += `${chapter.title}\n\n`;

            chapter.scenes.forEach((scene, sceneIndex) => {
                if (options.includeSceneSubtitles && scene.title) {
                    text += `${scene.title}\n\n`;
                }

                if (options.exportSummaries && scene.summary) {
                    text += `[Résumé: ${scene.summary}]\n\n`;
                }

                if (options.exportProse && scene.content) {
                    text += `${stripHTML(scene.content)}\n`;
                }

                if (sceneIndex < chapter.scenes.length - 1) {
                    text += divider;
                }
            });

            text += '\n\n';
        });
    });

    return text;
}

// [MVVM : autre]
// Formate les données sélectionnées en document HTML structuré.
async function generateHTMLContent(content, options) {
    const divider = getSceneDivider(options.sceneDivider).replace(/\n/g, '<br>');

    let html = `<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${project.title}</title>
    <style>
        body { font-family: 'Georgia', serif; max-width: 800px; margin: 0 auto; padding: 2rem; line-height: 1.8; color: #333; background: #fafafa; }
        h1 { font-size: 2.5rem; margin-bottom: 2rem; text-align: center; border-bottom: 3px solid #333; padding-bottom: 1rem; }
        h2 { font-size: 2rem; margin-top: 3rem; margin-bottom: 1.5rem; border-bottom: 2px solid #666; padding-bottom: 0.5rem; }
        h3 { font-size: 1.5rem; margin-top: 2rem; margin-bottom: 1rem; color: #666; }
        h4 { font-size: 1.2rem; margin-top: 1.5rem; margin-bottom: 0.75rem; color: #888; font-style: italic; }
        p { margin-bottom: 1rem; text-align: justify; }
        .summary { background: #f0f0f0; padding: 1rem; border-left: 4px solid #999; margin: 1rem 0; font-style: italic; color: #666; }
        .divider { text-align: center; margin: 2rem 0; color: #999; }
    </style>
</head>
<body>
    <h1>${project.title}</h1>
`;

    content.acts.forEach((act, actIndex) => {
        if (options.includeActTitles) {
            html += `    <h2>${act.title}</h2>\n`;
        }

        act.chapters.forEach((chapter, chapIndex) => {
            html += `    <h3>${chapter.title}</h3>\n`;

            chapter.scenes.forEach((scene, sceneIndex) => {
                if (options.includeSceneSubtitles && scene.title) {
                    html += `    <h4>${scene.title}</h4>\n`;
                }

                if (options.exportSummaries && scene.summary) {
                    html += `    <div class="summary">${scene.summary}</div>\n`;
                }

                if (options.exportProse && scene.content) {
                    const plainText = stripHTML(scene.content);
                    const paragraphs = plainText.split('\n').filter(p => p.trim());
                    paragraphs.forEach(para => {
                        html += `    <p>${para}</p>\n`;
                    });
                }

                if (sceneIndex < chapter.scenes.length - 1 && options.sceneDivider !== 'none') {
                    html += `    <div class="divider">${divider}</div>\n`;
                }
            });
        });
    });

    html += `    </body>\n</html>`;
    return html;
}

// [MVVM : autre]
// Génère le blob binaire pour un document DOCX à partir du contenu structuré.
async function generateDOCXBlob(content, options) {
    const { Document, Packer, Paragraph, TextRun, HeadingLevel, AlignmentType } = docx;

    const children = [];

    children.push(
        new Paragraph({
            text: project.title,
            heading: HeadingLevel.TITLE,
            alignment: AlignmentType.CENTER,
            spacing: { after: 400 }
        })
    );

    content.acts.forEach((act, actIndex) => {
        if (options.includeActTitles) {
            children.push(
                new Paragraph({
                    text: act.title,
                    heading: HeadingLevel.HEADING_1,
                    spacing: { before: 400, after: 200 }
                })
            );
        }

        act.chapters.forEach((chapter, chapIndex) => {
            children.push(
                new Paragraph({
                    text: chapter.title,
                    heading: HeadingLevel.HEADING_2,
                    spacing: { before: 300, after: 200 }
                })
            );

            chapter.scenes.forEach((scene, sceneIndex) => {
                if (options.includeSceneSubtitles && scene.title) {
                    children.push(
                        new Paragraph({
                            text: scene.title,
                            heading: HeadingLevel.HEADING_3,
                            spacing: { before: 200, after: 100 }
                        })
                    );
                }

                if (options.exportSummaries && scene.summary) {
                    children.push(
                        new Paragraph({
                            children: [
                                new TextRun({
                                    text: scene.summary,
                                    italics: true
                                })
                            ],
                            spacing: { after: 200 }
                        })
                    );
                }

                if (options.exportProse && scene.content) {
                    const plainText = stripHTML(scene.content);
                    const paragraphs = plainText.split('\n').filter(p => p.trim());
                    paragraphs.forEach(para => {
                        children.push(
                            new Paragraph({
                                text: para,
                                spacing: { after: 200 }
                            })
                        );
                    });
                }

                if (sceneIndex < chapter.scenes.length - 1) {
                    const dividerText = options.sceneDivider === 'asterisks' ? '* * *' :
                        options.sceneDivider === 'hash' ? '###' :
                            options.sceneDivider === 'line' ? '---' : '';

                    if (dividerText) {
                        children.push(
                            new Paragraph({
                                text: dividerText,
                                alignment: AlignmentType.CENTER,
                                spacing: { before: 200, after: 200 }
                            })
                        );
                    }
                }
            });
        });
    });

    const doc = new Document({
        sections: [{
            properties: {},
            children: children
        }]
    });

    return await Packer.toBlob(doc);
}

// [MVVM : autre]
// Gère le téléchargement d'un fichier par le navigateur à partir d'un contenu et d'un type MIME.
function downloadFile(content, filename, mimeType) {
    const blob = new Blob([content], { type: `${mimeType};charset=utf-8` });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.click();
    URL.revokeObjectURL(url);
}


// ========== js/40.sidebar-views.js ==========
// ============================================
// MOBILE SIDEBAR VIEWS
// ============================================

// [MVVM : Other]
// Group: Coordinator | Naming: MobileCoordinator
// Gère le rendu des vues de la barre latérale pour la version mobile.
// Cette fonction fait le pont entre les données du projet (Model) et l'interface utilisateur (View)
// en affichant soit un état vide avec un bouton d'action, soit un résumé du nombre d'éléments pour chaque catégorie.
function renderMobileSidebarView(view) {
    const editorView = document.getElementById('editorView');
    if (!editorView) return;

    const viewConfig = {
        editor: {
            icon: '📝',
            title: 'Structure de votre roman',
            description: 'Organisez votre roman en actes, chapitres et scènes',
            emptyMessage: 'Aucun acte créé',
            emptySubMessage: 'Commencez par créer votre premier acte pour structurer votre histoire',
            actionButton: '<button class="btn btn-primary" style="font-size: 1.2rem; padding: 1rem 2rem;" onclick="openAddActModal()">+ Créer un acte</button>',
            sidebarHint: 'Utilisez la poignée dorée sur le bord gauche pour naviguer dans votre structure'
        },
        characters: {
            icon: '👥',
            title: 'Personnages',
            description: 'Gérez vos personnages et leurs caractéristiques',
            emptyMessage: 'Aucun personnage créé',
            emptySubMessage: 'Créez votre premier personnage pour donner vie à votre histoire',
            actionButton: '<button class="btn btn-primary" style="font-size: 1.2rem; padding: 1rem 2rem;" onclick="openAddCharacterModal()">+ Créer un personnage</button>',
            sidebarHint: 'Utilisez la poignée dorée sur le bord gauche pour voir la liste complète'
        },
        world: {
            icon: '🌍',
            title: 'Univers',
            description: 'Créez les éléments de votre monde (lieux, objets, concepts)',
            emptyMessage: 'Aucun élément créé',
            emptySubMessage: 'Ajoutez des lieux, objets ou concepts pour enrichir votre univers',
            actionButton: '<button class="btn btn-primary" style="font-size: 1.2rem; padding: 1rem 2rem;" onclick="openAddWorldModal()">+ Créer un élément</button>',
            sidebarHint: 'Utilisez la poignée dorée sur le bord gauche pour voir tous vos éléments'
        },
        notes: {
            icon: '📋',
            title: 'Notes',
            description: 'Prenez des notes et organisez vos recherches',
            emptyMessage: 'Aucune note créée',
            emptySubMessage: 'Créez des notes pour garder vos idées et recherches organisées',
            actionButton: '<button class="btn btn-primary" style="font-size: 1.2rem; padding: 1rem 2rem;" onclick="openAddNoteModal()">+ Créer une note</button>',
            sidebarHint: 'Utilisez la poignée dorée sur le bord gauche pour voir toutes vos notes'
        },
        codex: {
            icon: '📖',
            title: 'Codex',
            description: 'Wiki de votre univers - glossaire et encyclopédie',
            emptyMessage: 'Aucune entrée dans le codex',
            emptySubMessage: 'Créez des entrées pour documenter votre univers',
            actionButton: '<button class="btn btn-primary" style="font-size: 1.2rem; padding: 1rem 2rem;" onclick="openAddCodexModal()">+ Créer une entrée</button>',
            sidebarHint: 'Utilisez la poignée dorée sur le bord gauche pour parcourir le codex'
        }
    };

    const config = viewConfig[view];
    if (!config) return;

    // Vérifier si vide
    let isEmpty = false;
    let count = 0;

    if (view === 'editor') {
        isEmpty = !project.acts || project.acts.length === 0;
        count = project.acts ? project.acts.length : 0;
    } else if (view === 'characters') {
        isEmpty = !project.characters || project.characters.length === 0;
        count = project.characters ? project.characters.length : 0;
    } else if (view === 'world') {
        isEmpty = !project.world || project.world.length === 0;
        count = project.world ? project.world.length : 0;
    } else if (view === 'notes') {
        isEmpty = !project.notes || project.notes.length === 0;
        count = project.notes ? project.notes.length : 0;
    } else if (view === 'codex') {
        isEmpty = !project.codex || project.codex.length === 0;
        count = project.codex ? project.codex.length : 0;
    }

    let html = `
                <div class="empty-state" style="padding: 2rem 1.5rem; text-align: center;">
                    <div class="empty-state-icon" style="font-size: 4rem; margin-bottom: 1rem;">
                        ${config.icon}
                    </div>
                    <div class="empty-state-title" style="font-size: 1.5rem; font-weight: 600; margin-bottom: 0.5rem; color: var(--text-primary);">
                        ${config.title}
                    </div>
                    <div class="empty-state-text" style="color: var(--text-secondary); margin-bottom: 1.5rem; line-height: 1.6;">
                        ${config.description}
                    </div>
            `;

    if (isEmpty) {
        html += `
                    <div style="background: var(--bg-secondary); padding: 1.5rem; border-radius: 8px; margin-bottom: 1.5rem; border-left: 3px solid var(--accent-gold);">
                        <div style="font-weight: 600; margin-bottom: 0.5rem; color: var(--text-primary);">
                            ${config.emptyMessage}
                        </div>
                        <div style="color: var(--text-secondary); font-size: 0.95rem;">
                            ${config.emptySubMessage}
                        </div>
                    </div>
                    ${config.actionButton}
                `;
    } else {
        html += `
                    <div style="background: var(--bg-secondary); padding: 1.5rem; border-radius: 8px; margin-bottom: 1.5rem;">
                        <div style="font-size: 2rem; font-weight: bold; color: var(--accent-gold); margin-bottom: 0.5rem;">
                            ${count}
                        </div>
                        <div style="color: var(--text-secondary);">
                            ${count === 1 ? 'élément' : 'éléments'}
                        </div>
                    </div>
                    ${config.actionButton}
                `;
    }

    html += `
                    <div style="margin-top: 2rem; padding: 1rem; background: rgba(212, 175, 55, 0.1); border-radius: 8px; border: 1px solid var(--accent-gold);">
                        <div style="font-size: 1.2rem; margin-bottom: 0.5rem;">💡</div>
                        <div style="font-size: 0.9rem; color: var(--text-secondary); line-height: 1.6;">
                            ${config.sidebarHint}
                        </div>
                    </div>
                </div>
            `;

    editorView.innerHTML = html;
}

// ============================================
// END MOBILE SIDEBAR VIEWS
// ============================================
// ========== js/41.storageMonitoring.js ==========


// ============================================
// STORAGE QUOTA MONITORING FUNCTIONS
// ============================================

let storageWarningShown = false;
let storageCriticalShown = false;

// [MVVM : ViewModel]
// Initialise la surveillance du stockage, vérifie la présence des éléments UI et déclenche les premières mises à jour.
function initStorageMonitoring() {
    console.log('🔍 Initialisation de la surveillance du stockage IndexedDB...');

    // Vérifier que les éléments existent
    const badge = document.getElementById('storage-badge');
    const percentage = document.getElementById('storage-percentage');

    if (!badge) {
        console.error('❌ Badge de stockage introuvable dans le DOM');
        return;
    }

    if (!percentage) {
        console.error('❌ Élément storage-percentage introuvable');
        return;
    }

    console.log('✅ Éléments trouvés, mise à jour du badge...');
    updateStorageBadge();
    checkStorageQuota();
    console.log('✅ Surveillance du stockage initialisée');
}

// [MVVM : Model]
// Récupère les données brutes de quota et d'utilisation du stockage via l'API Storage Estimate ou un fallback.
async function getStorageSize() {
    try {
        // Utiliser l'API Storage Estimate pour obtenir la taille réelle
        if ('storage' in navigator && 'estimate' in navigator.storage) {
            const estimate = await navigator.storage.estimate();
            return {
                used: estimate.usage || 0,
                quota: estimate.quota || (50 * 1024 * 1024) // Default 50 MB si non disponible
            };
        } else {
            // Fallback : calculer la taille approximative d'IndexedDB
            const size = await getIndexedDBSize();
            return {
                used: size,
                quota: 50 * 1024 * 1024 // 50 MB par défaut
            };
        }
    } catch (error) {
        console.error('❌ Erreur calcul taille stockage:', error);
        return {
            used: 0,
            quota: 50 * 1024 * 1024
        };
    }
}

// [MVVM : Other]
// Group: Util / Helper | Naming: StorageUtils
// Utilitaire de conversion de bytes en mégaoctets (MB) avec formatage de texte.
function formatBytes(bytes) {
    if (bytes === 0) return '0 MB';
    const mb = bytes / (1024 * 1024);
    return mb.toFixed(2) + ' MB';
}

// [MVVM : Other]
// Group: Coordinator | Naming: StorageCoordinator
// Calcule le pourcentage d'utilisation (ViewModel) et met à jour l'apparence du badge de stockage dans l'interface (View).
async function updateStorageBadge() {
    try {
        const { used, quota } = await getStorageSize();
        const percentage = Math.min(100, Math.round((used / quota) * 100));

        const badge = document.getElementById('storage-badge');
        const percentageText = document.getElementById('storage-percentage');

        if (!badge || !percentageText) return;

        percentageText.textContent = percentage + '%';

        // Update badge status
        badge.className = 'storage-badge';
        if (percentage >= 95) {
            badge.classList.add('status-danger');
        } else if (percentage >= 80) {
            badge.classList.add('status-warning');
        } else {
            badge.classList.add('status-ok');
        }

        // Check and show warnings
        await checkStorageQuota();
    } catch (error) {
        console.error('❌ Erreur mise à jour badge:', error);
    }
}

// [MVVM : ViewModel]
// Surveille les seuils de stockage et décide d'afficher des alertes ou de réinitialiser l'état des avertissements.
async function checkStorageQuota() {
    try {
        const { used, quota } = await getStorageSize();
        const percentage = (used / quota) * 100;

        if (percentage >= 95 && !storageCriticalShown) {
            storageCriticalShown = true;
            showStorageAlert(
                '🚨 Espace critique !',
                `Vous avez utilisé ${Math.round(percentage)}% de l'espace disponible (${formatBytes(used)} / ${formatBytes(quota)}).\n\n` +
                `⚠️ ATTENTION : Vous risquez de perdre vos données !\n\n` +
                `Actions urgentes :\n` +
                `• Exportez immédiatement votre projet en JSON\n` +
                `• Supprimez des versions anciennes\n` +
                `• Réduisez le nombre de notes\n\n` +
                `Voulez-vous exporter maintenant ?`,
                'danger'
            );
        } else if (percentage >= 80 && !storageWarningShown) {
            storageWarningShown = true;
            showStorageAlert(
                '⚠️ Espace limité',
                `Vous avez utilisé ${Math.round(percentage)}% de l'espace disponible.\n\n` +
                `Recommandations :\n` +
                `• Exportez régulièrement votre projet\n` +
                `• Surveillez votre utilisation\n` +
                `• Pensez à nettoyer les anciennes versions`,
                'warning'
            );
        }

        // Reset warnings if space freed
        if (percentage < 80) {
            storageWarningShown = false;
            storageCriticalShown = false;
        }
    } catch (error) {
        console.error('❌ Erreur vérification quota:', error);
    }
}

// [MVVM : View]
// Affiche une boîte de dialogue de confirmation et redirige vers l'export ou les détails selon le choix utilisateur.
function showStorageAlert(title, message, level) {
    if (confirm(`${title}\n\n${message}`)) {
        if (level === 'danger') {
            showExportModal();
        } else {
            showStorageDetails();
        }
    }
}

// [MVVM : Other]
// Group: Coordinator | Naming: StorageCoordinator
// Prépare les données détaillées (ViewModel) et met à jour dynamiquement la modale de détails du stockage (View).
async function showStorageDetails() {
    try {
        const { used, quota } = await getStorageSize();
        const percentage = Math.min(100, Math.round((used / quota) * 100));
        const available = quota - used;

        // Update storage bar
        const barFill = document.getElementById('storage-bar-fill');
        const barText = document.getElementById('storage-bar-text');

        if (barFill && barText) {
            barFill.style.width = percentage + '%';
            barText.textContent = percentage + '%';

            // Update bar color
            barFill.className = 'storage-bar-fill';
            if (percentage >= 95) {
                barFill.classList.add('danger');
            } else if (percentage >= 80) {
                barFill.classList.add('warning');
            } else {
                barFill.classList.add('ok');
            }
        }

        // Update stats
        const usedEl = document.getElementById('storage-used');
        const availableEl = document.getElementById('storage-available');

        if (usedEl) usedEl.textContent = formatBytes(used);
        if (availableEl) availableEl.textContent = formatBytes(available);

        // Update recommendations
        const recommendationsContainer = document.getElementById('storage-recommendations-container');
        const recommendationsDetails = document.getElementById('storage-recommendations-details');
        const recommendationsSummary = recommendationsDetails ? recommendationsDetails.querySelector('summary') : null;

        if (recommendationsContainer && recommendationsSummary) {
            let recommendations = '';
            let summaryText = '';
            let summaryColor = 'var(--accent-green)';

            if (percentage >= 95) {
                summaryText = '🚨 Actions urgentes';
                summaryColor = 'var(--accent-red)';
                recommendations = `
                            <ul style="font-size: 0.8rem; color: var(--text-secondary); line-height: 1.5; padding-left: 1.25rem; margin: 0;">
                                <li>Exportez immédiatement votre projet en JSON</li>
                                <li>Supprimez des versions anciennes</li>
                                <li>Réduisez le nombre de notes archivées</li>
                            </ul>
                        `;
                // Ouvrir automatiquement si urgent
                recommendationsDetails.open = true;
            } else if (percentage >= 80) {
                summaryText = '⚠️ Attention requise';
                summaryColor = 'var(--accent-gold)';
                recommendations = `
                            <ul style="font-size: 0.8rem; color: var(--text-secondary); line-height: 1.5; padding-left: 1.25rem; margin: 0;">
                                <li>Exportez régulièrement votre projet</li>
                                <li>Surveillez l'évolution de votre utilisation</li>
                                <li>Nettoyez les versions inutilisées</li>
                            </ul>
                        `;
            } else {
                summaryText = '✅ Espace suffisant';
                summaryColor = 'var(--accent-green)';
                recommendations = `
                            <ul style="font-size: 0.8rem; color: var(--text-secondary); line-height: 1.5; padding-left: 1.25rem; margin: 0;">
                                <li>Continuez à exporter régulièrement</li>
                                <li>Votre projet est dans la limite normale</li>
                                <li>IndexedDB : ${formatBytes(quota)} disponibles</li>
                            </ul>
                        `;
            }

            recommendationsSummary.textContent = summaryText;
            recommendationsSummary.style.color = summaryColor;
            recommendationsContainer.innerHTML = recommendations;
        }

        // Show modal using Plume's modal system
        const modal = document.getElementById('storage-modal');
        if (modal) {
            modal.classList.add('active');
        } else {
            console.error('Modal storage-modal not found!');
        }
    } catch (error) {
        console.error('❌ Erreur affichage détails stockage:', error);
    }
}

// [MVVM : View]
// Affiche une alerte critique en cas d'échec de sauvegarde pour cause d'espace insuffisant.
function handleStorageError() {
    alert(
        '🚨 ERREUR DE SAUVEGARDE\n\n' +
        'Impossible de sauvegarder : espace de stockage insuffisant.\n\n' +
        'Actions à faire MAINTENANT :\n' +
        '1. Exportez votre projet en JSON\n' +
        '2. Supprimez des versions anciennes\n' +
        '3. Libérez de l\'espace\n\n' +
        'Sans cela, vos modifications récentes seront perdues !'
    );
    showStorageDetails();
}

// Avertir avant de quitter si l'espace est critique
// [MVVM : ViewModel]
// Intercepte la fermeture de la page pour avertir l'utilisateur si l'espace de stockage est à un niveau critique.
window.addEventListener('beforeunload', async function (e) {
    try {
        const { used, quota } = await getStorageSize();
        const percentage = (used / quota) * 100;

        if (percentage >= 95) {
            e.preventDefault();
            e.returnValue = 'ATTENTION : Votre espace de stockage est presque plein. Pensez à exporter votre projet !';
            return e.returnValue;
        }
    } catch (error) {
        console.error('❌ Erreur vérification avant fermeture:', error);
    }
});

// ============================================
// END STORAGE QUOTA MONITORING FUNCTIONS
// ============================================
// ========== js/42.mobile-swipe.js ==========
// ============================================
// MOBILE SWIPE GESTURE SUPPORT
// ============================================

let touchStartX = 0;
let touchStartY = 0;
let touchEndX = 0;
let touchEndY = 0;

// Détecter le swipe depuis le bord gauche
// [MVVM : ViewModel]
// Enregistre les coordonnées de départ du toucher sur l'écran.
document.addEventListener('touchstart', function (e) {
    touchStartX = e.changedTouches[0].screenX;
    touchStartY = e.changedTouches[0].screenY;
}, false);

// [MVVM : ViewModel]
// Enregistre les coordonnées de fin du toucher et déclenche le traitement du swipe.
document.addEventListener('touchend', function (e) {
    touchEndX = e.changedTouches[0].screenX;
    touchEndY = e.changedTouches[0].screenY;
    handleSwipe();
}, false);

// [MVVM : Other]
// Group: Util / Helper | Naming: SwipeUtils
// Calcule la direction et l'amplitude du swipe pour commander l'ouverture ou la fermeture de la barre latérale.
function handleSwipe() {
    const diffX = touchEndX - touchStartX;
    const diffY = touchEndY - touchStartY;

    // Vérifier que c'est un swipe horizontal (pas vertical)
    if (Math.abs(diffX) > Math.abs(diffY)) {
        // Swipe depuis le bord gauche (moins de 50px du bord)
        if (touchStartX < 50 && diffX > 50) {
            // Swipe vers la droite depuis le bord gauche
            const sidebar = document.querySelector('.sidebar');
            if (sidebar && !sidebar.classList.contains('mobile-open')) {
                toggleMobileSidebar();
            }
        }
        // Swipe vers la gauche pour fermer
        else if (diffX < -50) {
            const sidebar = document.querySelector('.sidebar');
            if (sidebar && sidebar.classList.contains('mobile-open')) {
                toggleMobileSidebar();
            }
        }
    }
}

// ============================================
// END MOBILE SWIPE GESTURE SUPPORT
// ============================================
// ========== js-refactor/43.arcs.refactor.js ==========
// ============================================
// ============================================
// ARCS NARRATIFS - INLINE EDITING VERSION
// ============================================

// Arc types avec leurs propriétés
const ARC_TYPES = {
    character: { icon: 'user', label: 'Personnage', color: '#3498db' },
    plot: { icon: 'book-open', label: 'Intrigue', color: '#e74c3c' },
    theme: { icon: 'message-circle', label: 'Thème', color: '#9b59b6' },
    subplot: { icon: 'file-text', label: 'Intrigue secondaire', color: '#16a085' },
    relationship: { icon: 'heart', label: 'Relation', color: '#e91e63' },
    mystery: { icon: 'search', label: 'Mystère', color: '#607d8b' },
    conflict: { icon: 'swords', label: 'Conflit', color: '#ff5722' },
    growth: { icon: 'sprout', label: 'Croissance', color: '#4caf50' },
    redemption: { icon: 'sparkles', label: 'Rédemption', color: '#ffd700' },
    vengeance: { icon: 'flame', label: 'Vengeance', color: '#d32f2f' },
    quest: { icon: 'map', label: 'Quête', color: '#ff9800' },
    discovery: { icon: 'telescope', label: 'Découverte', color: '#00bcd4' },
    transformation: { icon: 'butterfly', label: 'Transformation', color: '#ab47bc' },
    political: { icon: 'crown', label: 'Politique', color: '#795548' },
    philosophical: { icon: 'brain', label: 'Philosophique', color: '#546e7a' },
    comedic: { icon: 'smile', label: 'Comédie', color: '#ffeb3b' },
    tragic: { icon: 'frown', label: 'Tragédie', color: '#424242' },
    action: { icon: 'zap', label: 'Action', color: '#ff6f00' },
    universe: { icon: 'globe', label: 'Univers', color: '#1976d2' },
    linked_characters: { icon: 'users', label: 'Personnages liés', color: '#8e24aa' }
};

// Helper function to render arc type icon
// [MVVM : View]
// Génère le code HTML pour l'icône d'un type d'arc.
function renderArcTypeIcon(iconName, color = null) {
    const colorStyle = color ? `style="color: ${color}"` : '';
    return `<i data-lucide="${iconName}" class="arc-lucide-icon" ${colorStyle}></i>`;
}

// Initialize narrative arcs if not exists
// [MVVM : Model]
// Initialise la structure de données des arcs narratifs dans le projet si elle n'existe pas.
function initNarrativeArcs() {
    if (!project.narrativeArcs) {
        project.narrativeArcs = [];
    }
}

// ============================================
// SIDEBAR FUNCTIONS
// ============================================

// [MVVM : View]
// Rend le HTML de la liste des arcs narratifs dans la barre latérale.
function renderArcsList() {
    const list = document.getElementById('arcsList');
    if (!list) return;

    initNarrativeArcs();
    const arcs = project.narrativeArcs || [];

    if (arcs.length === 0) {
        list.innerHTML = `
                    <div class="sidebar-empty">
                        <div class="sidebar-empty-icon"><i data-lucide="drama"></i></div>
                        <p>Aucun arc narratif</p>
                    </div>
                `;
        if (typeof lucide !== 'undefined') lucide.createIcons();
        return;
    }

    // Group by importance
    const majorArcs = arcs.filter(a => a.importance === 'major');
    const minorArcs = arcs.filter(a => a.importance === 'minor');

    let html = '';

    if (majorArcs.length > 0) {
        html += '<div class="sidebar-group-title">Arcs Majeurs</div>';
        html += majorArcs.map(arc => {
            const typeData = ARC_TYPES[arc.type] || ARC_TYPES.plot;
            const sceneCount = arc.scenePresence ? arc.scenePresence.length : 0;
            return `
                        <div class="sidebar-item" onclick="openArcDetail('${arc.id}')" data-arc-id="${arc.id}">
                            <div class="sidebar-item-header">
                                <span class="sidebar-item-icon" style="color: ${arc.color}"><i data-lucide="${typeData.icon}"></i></span>
                                <span class="sidebar-item-title">${arc.title}</span>
                            </div>
                            <div class="sidebar-item-meta">
                                <span>${sceneCount} scène${sceneCount > 1 ? 's' : ''}</span>
                            </div>
                        </div>
                    `;
        }).join('');
    }

    if (minorArcs.length > 0) {
        html += '<div class="sidebar-group-title">Arcs Mineurs</div>';
        html += minorArcs.map(arc => {
            const typeData = ARC_TYPES[arc.type] || ARC_TYPES.plot;
            const sceneCount = arc.scenePresence ? arc.scenePresence.length : 0;
            return `
                        <div class="sidebar-item" onclick="openArcDetail('${arc.id}')" data-arc-id="${arc.id}">
                            <div class="sidebar-item-header">
                                <span class="sidebar-item-icon" style="color: ${arc.color}"><i data-lucide="${typeData.icon}"></i></span>
                                <span class="sidebar-item-title">${arc.title}</span>
                            </div>
                            <div class="sidebar-item-meta">
                                <span>${sceneCount} scène${sceneCount > 1 ? 's' : ''}</span>
                            </div>
                        </div>
                    `;
        }).join('');
    }

    list.innerHTML = html;

    // Initialize Lucide icons for the new content
    if (typeof lucide !== 'undefined') {
        lucide.createIcons();
    }
}

// [MVVM : View]
// Rend le HTML de l'état initial ou vide de la vue des arcs.
function renderArcsWelcome() {
    const view = document.getElementById('editorView');
    if (!view) return;

    initNarrativeArcs();
    const arcs = project.narrativeArcs || [];

    if (arcs.length === 0) {
        view.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon"><i data-lucide="drama"></i></div>
                        <div class="empty-state-title">Gérez vos arcs narratifs</div>
                        <div class="empty-state-text">
                            Les arcs narratifs vous permettent de suivre l'évolution de vos personnages,<br>
                            intrigues et thèmes à travers votre roman.
                        </div>
                        <button class="btn btn-primary" onclick="createNewArc()">
                            <i data-lucide="sparkles"></i> Créer votre premier arc
                        </button>
                    </div>
                `;
        if (typeof lucide !== 'undefined') lucide.createIcons();
        return;
    }

    view.innerHTML = `
                <div class="empty-state">
                    <div class="empty-state-icon"><i data-lucide="drama"></i></div>
                    <div class="empty-state-title">Sélectionnez un arc</div>
                    <div class="empty-state-text">
                        Choisissez un arc dans la barre latérale pour voir ses détails<br>
                        et sa progression à travers votre roman.
                    </div>
                </div>
            `;
    if (typeof lucide !== 'undefined') lucide.createIcons();
}

// ============================================
// ARC DETAIL VIEW
// ============================================

// [MVVM : ViewModel]
// Gère l'ouverture des détails d'un arc en basculant vers l'éditeur.
function openArcDetail(arcId) {
    // Passer directement en mode édition quand on clique sur un arc
    const arc = project.narrativeArcs.find(a => a.id === arcId);
    if (!arc) return;
    renderArcEditor(arc, false);
}

// ============================================
// INLINE EDITOR
// ============================================

// [MVVM : ViewModel]
// Initialise un nouvel objet arc et affiche l'éditeur pour sa création.
function createNewArc() {
    const newArc = {
        id: 'arc_' + Date.now(),
        title: '',
        type: 'character',
        color: ARC_TYPES.character.color,
        description: '',
        relatedCharacters: [],
        importance: 'major',
        resolution: { type: 'ongoing', sceneId: null },
        scenePresence: [],
        created: new Date().toISOString().split('T')[0],
        updated: new Date().toISOString().split('T')[0]
    };

    renderArcEditor(newArc, true);
}

// [MVVM : View]
// Génère et affiche le formulaire d'édition (création ou modification) d'un arc.
function renderArcEditor(arc, isNew = false) {
    const view = document.getElementById('editorView');
    if (!view) return;

    const typeData = ARC_TYPES[arc.type] || ARC_TYPES.character;

    // Get character options
    const characterOptions = project.characters && project.characters.length > 0
        ? project.characters.map(char => {
            const selected = arc.relatedCharacters.includes(char.id) ? 'selected' : '';
            return `<option value="${char.id}" ${selected}>${char.name}</option>`;
        }).join('')
        : '<option disabled>Aucun personnage créé</option>';

    const arcTypesHTML = Object.entries(ARC_TYPES).map(([key, data]) => {
        const selected = arc.type === key ? 'selected' : '';
        return `
                    <div class="arc-type-card ${selected}" data-type="${key}" onclick="selectArcTypeInEditor('${key}')">
                        <span class="arc-type-icon"><i data-lucide="${data.icon}"></i></span>
                        <span class="arc-type-label">${data.label}</span>
                    </div>
                `;
    }).join('');

    view.innerHTML = `
                <div class="arc-editor-view">
                    <div class="arc-editor-header">
                        <h2><i data-lucide="${isNew ? 'sparkles' : 'pencil'}"></i> ${isNew ? 'Créer un arc narratif' : 'Modifier l\'arc'}</h2>
                        <div class="arc-editor-actions-header">
                            <button class="btn-secondary" onclick="cancelArcEdit()">Annuler</button>
                            <button class="btn-primary" onclick="saveArcFromEditor(${isNew})">
                                <i data-lucide="${isNew ? 'sparkles' : 'save'}"></i> ${isNew ? 'Créer' : 'Enregistrer'}
                            </button>
                        </div>
                    </div>

                    <div class="arc-editor-form">
                        <div class="arc-editor-section">
                            <h3><i data-lucide="pin"></i> Informations de base</h3>

                            <div class="form-group">
                                <label>Titre de l'arc *</label>
                                <input type="text" id="arcTitleInput" class="form-input" 
                                    value="${arc.title}" placeholder="Ex: La vengeance de Kaito">
                            </div>

                            <div class="form-group">
                                <label>Description</label>
                                <textarea id="arcDescriptionInput" class="form-textarea" 
                                    placeholder="Décrivez l'arc narratif...">${arc.description}</textarea>
                            </div>

                            <div class="form-row">
                                <div class="form-group">
                                    <label>Couleur de l'arc</label>
                                    <div class="color-picker-group">
                                        <input type="color" id="arcColorPicker" value="${arc.color}" 
                                            onchange="document.getElementById('arcColorText').value = this.value">
                                        <input type="text" id="arcColorText" class="form-input-small" 
                                            value="${arc.color}" 
                                            onchange="document.getElementById('arcColorPicker').value = this.value">
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="arc-editor-section">
                            <h3><i data-lucide="drama"></i> Type d'arc narratif *</h3>
                            <div class="arc-types-grid">
                                ${arcTypesHTML}
                            </div>
                        </div>

                        <div class="arc-editor-section">
                            <h3><i data-lucide="users"></i> Personnages liés</h3>
                            <select id="arcCharactersSelect" class="form-select" multiple size="5">
                                ${characterOptions}
                            </select>
                            <p class="form-help">Maintenez Ctrl (ou Cmd) pour sélectionner plusieurs personnages</p>
                        </div>

                        <div class="arc-editor-section">
                            <h3><i data-lucide="scale"></i> Importance & Résolution</h3>

                            <div class="form-row">
                                <div class="form-group">
                                    <label>Importance</label>
                                    <select id="arcImportanceSelect" class="form-select">
                                        <option value="major" ${arc.importance === 'major' ? 'selected' : ''}>Majeur</option>
                                        <option value="minor" ${arc.importance === 'minor' ? 'selected' : ''}>Mineur</option>
                                    </select>
                                </div>

                                <div class="form-group">
                                    <label>Statut de résolution</label>
                                    <select id="arcResolutionSelect" class="form-select">
                                        <option value="ongoing" ${arc.resolution.type === 'ongoing' ? 'selected' : ''}>En cours</option>
                                        <option value="resolved" ${arc.resolution.type === 'resolved' ? 'selected' : ''}>Résolu</option>
                                        <option value="abandoned" ${arc.resolution.type === 'abandoned' ? 'selected' : ''}>Abandonné</option>
                                    </select>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;

    // Store current arc in global var
    window.currentEditingArc = arc;
    window.currentEditingArcIsNew = isNew;

    // Initialize Lucide icons for the new content
    if (typeof lucide !== 'undefined') {
        lucide.createIcons();
    }
}

// [MVVM : Other]
// Group: Coordinator | Naming: ArcCoordinator
// Gère la sélection visuelle d'un type d'arc et met à jour les données temporaires de l'éditeur.
function selectArcTypeInEditor(type) {
    // Update UI
    document.querySelectorAll('.arc-type-card').forEach(card => {
        card.classList.remove('selected');
    });
    const selected = document.querySelector(`[data-type="${type}"]`);
    if (selected) selected.classList.add('selected');

    // Update color
    const typeData = ARC_TYPES[type];
    if (typeData) {
        document.getElementById('arcColorPicker').value = typeData.color;
        document.getElementById('arcColorText').value = typeData.color;
    }

    // Update global var
    window.currentEditingArc.type = type;
}

// [MVVM : Other]
// Group: Use Case | Naming: SaveArcUseCase
// Récupère les données du formulaire, les valide et les enregistre dans le modèle.
function saveArcFromEditor(isNew) {
    const arc = window.currentEditingArc;
    if (!arc) return;

    // Get values from form
    arc.title = document.getElementById('arcTitleInput').value.trim();
    arc.description = document.getElementById('arcDescriptionInput').value.trim();
    arc.color = document.getElementById('arcColorPicker').value;
    arc.importance = document.getElementById('arcImportanceSelect').value;
    arc.resolution.type = document.getElementById('arcResolutionSelect').value;

    // Get selected characters
    const select = document.getElementById('arcCharactersSelect');
    arc.relatedCharacters = Array.from(select.selectedOptions).map(opt => opt.value);

    // Validation
    if (!arc.title) {
        alert('Veuillez entrer un titre pour l\'arc');
        document.getElementById('arcTitleInput').focus();
        return;
    }

    // Save
    if (isNew) {
        project.narrativeArcs.push(arc);
    } else {
        const index = project.narrativeArcs.findIndex(a => a.id === arc.id);
        if (index !== -1) {
            project.narrativeArcs[index] = arc;
        }
    }

    arc.updated = new Date().toISOString().split('T')[0];
    saveProject();

    // Refresh sidebar and show detail
    renderArcsList();
    openArcDetail(arc.id);
}

// [MVVM : ViewModel]
// Prépare l'édition d'un arc existant en ouvrant l'éditeur.
function editArcInline(arcId) {
    const arc = project.narrativeArcs.find(a => a.id === arcId);
    if (!arc) return;
    renderArcEditor(arc, false);
}

// [MVVM : ViewModel]
// Annule l'édition en cours et revient à la vue d'accueil.
function cancelArcEdit() {
    const arcs = project.narrativeArcs || [];
    if (arcs.length > 0) {
        renderArcsWelcome();
        renderArcsList();
    } else {
        renderArcsWelcome();
    }
}

// ============================================
// DELETE ARC
// ============================================

// [MVVM : Other]
// Group: Use Case | Naming: DeleteArcUseCase
// Supprime un arc du modèle après confirmation et rafraîchit la vue.
function deleteNarrativeArc(arcId) {
    const arc = project.narrativeArcs.find(a => a.id === arcId);
    if (!arc) return;

    if (!confirm(`Voulez-vous vraiment supprimer l'arc "${arc.title}" ?\n\nCette action est irréversible.`)) {
        return;
    }

    project.narrativeArcs = project.narrativeArcs.filter(a => a.id !== arcId);
    saveProject();

    renderArcsList();
    renderArcsWelcome();
}

// ============================================
// SCENE PANEL (For editing arcs in a scene)
// ============================================

// [MVVM : View]
// Alterne la visibilité du panneau des arcs pour une scène.
function toggleArcScenePanel() {
    const panel = document.getElementById('arcScenePanel');
    const toolBtn = document.getElementById('toolArcsBtn');
    const sidebarBtn = document.getElementById('sidebarArcsBtn');
    if (!panel) return;

    panel.classList.toggle('hidden');
    if (!panel.classList.contains('hidden')) {
        renderArcScenePanel();
        if (toolBtn) toolBtn.classList.add('active');
        if (sidebarBtn) sidebarBtn.classList.add('active');
    } else {
        if (toolBtn) toolBtn.classList.remove('active');
        if (sidebarBtn) sidebarBtn.classList.remove('active');
    }
}

// [MVVM : View]
// Affiche le panneau de gestion des arcs narratifs pour la scène courante.
function renderArcScenePanel() {
    const content = document.getElementById('arcScenePanelContent');
    if (!content) return;

    // Vérifier qu'une scène est sélectionnée
    if (!currentSceneId || !currentChapterId || !currentActId) {
        content.innerHTML = `
            <div class="arc-panel-empty">
                <p>Sélectionnez une scène pour voir ses arcs</p>
            </div>
        `;
        return;
    }

    // Récupérer la scène courante
    const act = project.acts.find(a => a.id === currentActId);
    const chapter = act ? act.chapters.find(c => c.id === currentChapterId) : null;
    const scene = chapter ? chapter.scenes.find(s => s.id === currentSceneId) : null;

    if (!scene) {
        content.innerHTML = `
            <div class="arc-panel-empty">
                <p>Scène introuvable</p>
            </div>
        `;
        return;
    }

    initNarrativeArcs();
    const arcs = project.narrativeArcs || [];

    // Get arcs present in this scene
    const arcsInScene = arcs.filter(arc =>
        arc.scenePresence && arc.scenePresence.some(p => p.sceneId == scene.id)
    );

    if (arcsInScene.length === 0 && arcs.length === 0) {
        content.innerHTML = `
                    <div class="arc-panel-empty">
                        <div class="arc-panel-empty-icon"><i data-lucide="drama"></i></div>
                        <p>Aucun arc narratif créé</p>
                    </div>
                `;
        if (typeof lucide !== 'undefined') lucide.createIcons();
        return;
    }

    let html = `
                <div class="arc-scene-info">
                    <div class="arc-scene-info-title">Scène actuelle</div>
                    <div>${scene.title}</div>
                </div>
            `;

    // Show arcs in scene
    if (arcsInScene.length > 0) {
        arcsInScene.forEach(arc => {
            const presence = arc.scenePresence.find(p => p.sceneId == scene.id);
            if (!presence) return;

            const typeData = ARC_TYPES[arc.type] || ARC_TYPES.plot;

            html += `
                        <div class="arc-in-scene" data-arc-id="${arc.id}">
                            <div class="arc-in-scene-header">
                                <div class="arc-in-scene-title">
                                    <span style="color: ${arc.color}"><i data-lucide="${typeData.icon}"></i></span> ${arc.title}
                                </div>
                                <button class="arc-in-scene-remove" onclick="removeArcFromScene('${arc.id}')" title="Retirer"><i data-lucide="x" style="width:12px;height:12px;"></i></button>
                            </div>

                            <div class="arc-in-scene-control">
                                <label class="arc-in-scene-label">Intensité</label>
                                <input type="range" min="1" max="5" value="${presence.intensity}"
                                    class="arc-intensity-slider"
                                    oninput="updateArcIntensity('${arc.id}', this.value, this)">
                                <div class="arc-intensity-value">${presence.intensity}/5</div>
                            </div>

                            <div class="arc-in-scene-control">
                                <label class="arc-in-scene-label">Statut</label>
                                <select class="arc-status-select" onchange="updateArcStatus('${arc.id}', this.value)">
                                    <option value="setup" ${presence.status === 'setup' ? 'selected' : ''}>Introduction</option>
                                    <option value="development" ${presence.status === 'development' ? 'selected' : ''}>Développement</option>
                                    <option value="climax" ${presence.status === 'climax' ? 'selected' : ''}>Point culminant</option>
                                    <option value="resolution" ${presence.status === 'resolution' ? 'selected' : ''}>Résolution</option>
                                </select>
                            </div>

                            <div class="arc-in-scene-control">
                                <label class="arc-in-scene-label">Colonne du arc-board</label>
                                <select class="arc-column-select" onchange="updateArcColumn('${arc.id}', this.value)">
                                    <option value="">Arc général (aucune colonne)</option>
                                    ${(arc.board && arc.board.items ? arc.board.items.filter(item => item.type === 'column').map(column =>
                `<option value="${column.id}" ${presence.columnId == column.id ? 'selected' : ''}>${column.title || 'Colonne sans titre'}</option>`
            ).join('') : '')}
                                </select>
                            </div>

                            <div class="arc-in-scene-control">
                                <label class="arc-in-scene-label">Notes</label>
                                <textarea class="arc-notes-textarea"
                                    placeholder="Notes pour cette scène..."
                                    onblur="updateArcNotes('${arc.id}', this.value)">${presence.notes || ''}</textarea>
                            </div>
                        </div>
                    `;
        });
    }

    // Add arc button
    const availableArcs = arcs.filter(arc => !arcsInScene.includes(arc));
    if (availableArcs.length > 0) {
        html += `
                    <select id="arcToAddSelect" class="arc-panel-add-select">
                        <option value="">-- Ajouter un arc --</option>
                        ${availableArcs.map(arc => {
            const typeData = ARC_TYPES[arc.type] || ARC_TYPES.plot;
            return `<option value="${arc.id}">${typeData.label} - ${arc.title}</option>`;
        }).join('')}
                    </select>
                    <button class="arc-panel-add-btn" onclick="addArcToCurrentScene()">+ Ajouter l'arc</button>
                `;
    }

    content.innerHTML = html;

    // Initialize Lucide icons for the new content
    if (typeof lucide !== 'undefined') {
        lucide.createIcons();
    }
}

function addArcToCurrentScene() {
    const select = document.getElementById('arcToAddSelect');
    if (!select) return;

    const arcId = select.value;
    if (!arcId) return;

    if (!currentSceneId || !currentChapterId || !currentActId) return;

    const arc = project.narrativeArcs.find(a => a.id === arcId);
    if (!arc) return;

    if (!arc.scenePresence) arc.scenePresence = [];

    // Ajouter la présence (Arc général par défaut = columnId: null)
    arc.scenePresence.push({
        actId: currentActId,
        chapterId: currentChapterId,
        sceneId: currentSceneId,
        intensity: 3,
        notes: '',
        status: 'development',
        columnId: null // Explicitement null pour créer une carte flottante sans ID de colonne
    });

    // IMPORTANT: Créer immédiatement la carte flottante sur le board
    // Cela garantit que "Ajouter l'arc" crée bien l'élément visuel
    updateArcColumn(arcId, null);

    // saveProject est appelé dans updateArcColumn
    renderArcScenePanel();
}

// [MVVM : Other]
// Group: Use Case | Naming: RemoveArcFromSceneUseCase
// Retire un arc de la scène courante et met à jour le modèle.
function removeArcFromScene(arcId) {
    if (!currentSceneId) return;

    const arc = project.narrativeArcs.find(a => a.id === arcId);
    if (!arc) return;

    // Récupérer la presence avant suppression pour obtenir le columnId
    const presence = arc.scenePresence ? arc.scenePresence.find(p => p.sceneId == currentSceneId) : null;

    // Supprimer la carte scene du arc-board si elle existe (dans N'IMPORTE QUELLE colonne pour éviter les zombies)
    if (arc.board && arc.board.items) {
        arc.board.items.forEach(item => {
            if (item.type === 'column' && item.cards) {
                item.cards = item.cards.filter(card => !(card.type === 'scene' && card.sceneId == currentSceneId));
            }
        });
    }

    // Supprimer aussi tout élément flottant scene pour cette scène
    if (arc.board && arc.board.items) {
        arc.board.items = arc.board.items.filter(item => !(item.type === 'scene' && item.sceneId == currentSceneId));
    }

    arc.scenePresence = arc.scenePresence.filter(p => p.sceneId != currentSceneId);
    saveProject();
    renderArcScenePanel();

    // Rafraîchir le arc-board s'il est ouvert
    if (typeof ArcBoardViewModel !== 'undefined' && ArcBoardViewModel.getCurrentArc && ArcBoardViewModel.getCurrentArc()?.id === arcId) {
        ArcBoardViewModel.renderItems();
    }
}

// [MVVM : Other]
// Group: Use Case | Naming: UpdateArcIntensityUseCase
// Met à jour l'intensité d'un arc dans une scène (Model) et rafraîchit l'affichage (View).
function updateArcIntensity(arcId, intensity, sliderElement) {
    if (!currentSceneId) return;

    const arc = project.narrativeArcs.find(a => a.id === arcId);
    if (!arc) return;

    const presence = arc.scenePresence.find(p => p.sceneId == currentSceneId);
    if (presence) {
        presence.intensity = parseInt(intensity);

        // Update display - utilise la navigation relative depuis le slider pour plus de fiabilité
        if (sliderElement) {
            const valueDiv = sliderElement.parentElement.querySelector('.arc-intensity-value');
            if (valueDiv) valueDiv.textContent = `${intensity}/5`;
        } else {
            // Fallback: chercher via data-arc-id
            const arcDiv = document.querySelector(`[data-arc-id="${arcId}"]`);
            if (arcDiv) {
                const valueDiv = arcDiv.querySelector('.arc-intensity-value');
                if (valueDiv) valueDiv.textContent = `${intensity}/5`;
            }
        }

        // Synchroniser avec la carte scene dans le arc-board (colonne ou flottant)
        if (arc.board && arc.board.items) {
            let found = false;

            // 1. Chercher dans les colonnes (via ID stocké)
            if (presence.columnId) {
                const column = arc.board.items.find(item => item.id === presence.columnId && item.type === 'column');
                if (column && column.cards) {
                    const sceneCard = column.cards.find(card => card.type === 'scene' && card.sceneId == currentSceneId);
                    if (sceneCard) {
                        sceneCard.intensity = parseInt(intensity);
                        sceneCard.sceneTitle = getSceneTitle(currentSceneId);
                        sceneCard.breadcrumb = generateSceneBreadcrumb(currentSceneId);
                        found = true;
                    }
                }
            }

            // FAILSAFE: Si pas trouvé via l'ID stocké, chercher partout
            if (!found) {
                arc.board.items.forEach(item => {
                    if (item.type === 'column' && item.cards) {
                        const sceneCard = item.cards.find(card => card.type === 'scene' && card.sceneId == currentSceneId);
                        if (sceneCard) {
                            sceneCard.intensity = parseInt(intensity);
                            sceneCard.sceneTitle = getSceneTitle(currentSceneId);
                            sceneCard.breadcrumb = generateSceneBreadcrumb(currentSceneId);
                            // Auto-repair link
                            presence.columnId = item.id;
                            found = true;
                        }
                    }
                });
            }

            // 2. Chercher en flottant (si toujours pas trouvé ou si c'était le but)
            if (!found) {
                const floatingItem = arc.board.items.find(item => item.type === 'scene' && item.sceneId == currentSceneId);
                if (floatingItem) {
                    floatingItem.intensity = parseInt(intensity);
                    floatingItem.sceneTitle = getSceneTitle(currentSceneId);
                    floatingItem.breadcrumb = generateSceneBreadcrumb(currentSceneId);
                }
            }
        }

        saveProject();

        // Rafraîchir le arc-board s'il est ouvert sur cet arc
        if (typeof ArcBoardViewModel !== 'undefined' && ArcBoardViewModel.getCurrentArc && ArcBoardViewModel.getCurrentArc()?.id === arcId) {
            ArcBoardViewModel.renderItems();
        }
    }
}

// [MVVM : ViewModel]
// Met à jour le statut d'avancement d'un arc pour la scène courante.
function updateArcStatus(arcId, status) {
    if (!currentSceneId) return;

    const arc = project.narrativeArcs.find(a => a.id === arcId);
    if (!arc) return;

    const presence = arc.scenePresence.find(p => p.sceneId == currentSceneId);
    if (presence) {
        presence.status = status;

        // Synchroniser avec la carte scene dans le arc-board (colonne ou flottant)
        if (arc.board && arc.board.items) {
            let found = false;

            // 1. Chercher dans les colonnes
            if (presence.columnId) {
                const column = arc.board.items.find(item => item.id === presence.columnId && item.type === 'column');
                if (column && column.cards) {
                    const sceneCard = column.cards.find(card => card.type === 'scene' && card.sceneId == currentSceneId);
                    if (sceneCard) {
                        sceneCard.status = status;
                        sceneCard.sceneTitle = getSceneTitle(currentSceneId);
                        sceneCard.breadcrumb = generateSceneBreadcrumb(currentSceneId);
                        found = true;
                    }
                }
            }

            // FAILSAFE
            if (!found) {
                arc.board.items.forEach(item => {
                    if (item.type === 'column' && item.cards) {
                        const sceneCard = item.cards.find(card => card.type === 'scene' && card.sceneId == currentSceneId);
                        if (sceneCard) {
                            sceneCard.status = status;
                            sceneCard.sceneTitle = getSceneTitle(currentSceneId);
                            sceneCard.breadcrumb = generateSceneBreadcrumb(currentSceneId);
                            presence.columnId = item.id;
                            found = true;
                        }
                    }
                });
            }

            if (!found) {
                // 2. Chercher en flottant
                const floatingItem = arc.board.items.find(item => item.type === 'scene' && item.sceneId == currentSceneId);
                if (floatingItem) {
                    floatingItem.status = status;
                    floatingItem.sceneTitle = getSceneTitle(currentSceneId);
                    floatingItem.breadcrumb = generateSceneBreadcrumb(currentSceneId);
                }
            }
        }

        saveProject();

        // Rafraîchir le arc-board s'il est ouvert sur cet arc
        if (typeof ArcBoardViewModel !== 'undefined' && ArcBoardViewModel.getCurrentArc && ArcBoardViewModel.getCurrentArc()?.id === arcId) {
            ArcBoardViewModel.renderItems();
        }
    }
}

// [MVVM : ViewModel]
// Enregistre les notes spécifiques à un arc pour la scène courante.
function updateArcNotes(arcId, notes) {
    if (!currentSceneId) return;

    const arc = project.narrativeArcs.find(a => a.id === arcId);
    if (!arc) return;

    const presence = arc.scenePresence.find(p => p.sceneId == currentSceneId);
    if (presence) {
        presence.notes = notes;

        // Synchroniser avec la carte scene dans le arc-board si elle existe
        if (arc.board && arc.board.items) {
            let found = false;

            // 1. Chercher dans les colonnes
            if (presence.columnId) {
                const column = arc.board.items.find(item => item.id === presence.columnId && item.type === 'column');
                if (column && column.cards) {
                    const sceneCard = column.cards.find(card => card.type === 'scene' && card.sceneId == currentSceneId);
                    if (sceneCard) {
                        sceneCard.notes = notes;
                        sceneCard.sceneTitle = getSceneTitle(currentSceneId);
                        sceneCard.breadcrumb = generateSceneBreadcrumb(currentSceneId);
                        found = true;
                    }
                }
            }

            // FAILSAFE
            if (!found) {
                arc.board.items.forEach(item => {
                    if (item.type === 'column' && item.cards) {
                        const sceneCard = item.cards.find(card => card.type === 'scene' && card.sceneId == currentSceneId);
                        if (sceneCard) {
                            sceneCard.notes = notes;
                            sceneCard.sceneTitle = getSceneTitle(currentSceneId);
                            sceneCard.breadcrumb = generateSceneBreadcrumb(currentSceneId);
                            presence.columnId = item.id;
                            found = true;
                        }
                    }
                });
            }

            if (!found) {
                // 2. Chercher en flottant
                const floatingItem = arc.board.items.find(item => item.type === 'scene' && item.sceneId == currentSceneId);
                if (floatingItem) {
                    floatingItem.notes = notes;
                    floatingItem.sceneTitle = getSceneTitle(currentSceneId);
                    floatingItem.breadcrumb = generateSceneBreadcrumb(currentSceneId);
                }
            }
        }

        saveProject();

        // Rafraîchir le arc-board s'il est ouvert sur cet arc
        if (typeof ArcBoardViewModel !== 'undefined' && ArcBoardViewModel.getCurrentArc && ArcBoardViewModel.getCurrentArc()?.id === arcId) {
            ArcBoardViewModel.renderItems();
        }
    }
}

// Helper: Génère le breadcrumb pour une scène
function generateSceneBreadcrumb(sceneId) {
    for (const act of project.acts) {
        for (const chapter of act.chapters) {
            const scene = chapter.scenes.find(s => s.id == sceneId);
            if (scene) {
                const actTitle = act.title || `Acte ${project.acts.indexOf(act) + 1}`;
                const chapterTitle = chapter.title || `Chapitre ${act.chapters.indexOf(chapter) + 1}`;
                return `${actTitle} › ${chapterTitle}`;
            }
        }
    }
    return '';
}

// Helper: Récupère le titre d'une scène
function getSceneTitle(sceneId) {
    for (const act of project.acts) {
        for (const chapter of act.chapters) {
            const scene = chapter.scenes.find(s => s.id == sceneId);
            if (scene) {
                return scene.title || 'Scène sans titre';
            }
        }
    }
    return 'Scène sans titre';
}

// [MVVM : ViewModel]
// Met à jour la colonne du arc-board liée à cette scène pour cet arc
function updateArcColumn(arcId, columnId) {
    if (!currentSceneId) {
        console.error("updateArcColumn: currentSceneId is missing");
        return;
    }

    const arc = project.narrativeArcs.find(a => a.id === arcId);
    if (!arc) {
        console.error("updateArcColumn: Arc not found", arcId);
        return;
    }

    // Ensure board structure exists
    if (!arc.board) arc.board = { items: [], connections: [] };
    if (!arc.board.items) arc.board.items = [];

    const presence = arc.scenePresence ? arc.scenePresence.find(p => p.sceneId == currentSceneId) : null;
    if (!presence) {
        // Create presence if missing (fallback)
        if (!arc.scenePresence) arc.scenePresence = [];
        arc.scenePresence.push({
            sceneId: currentSceneId,
            columnId: null,
            status: 'development',
            intensity: 3,
            notes: ''
        });
    }

    // Update presence columnId
    // Treat string "null" or empty string as actual null
    const targetColumnId = (columnId && columnId !== 'null') ? columnId : null;

    // Update the presence record
    if (arc.scenePresence) {
        const p = arc.scenePresence.find(p => p.sceneId == currentSceneId);
        if (p) p.columnId = targetColumnId;
    }

    // Retrieve scene info for card/item
    const act = project.acts.find(a => a.id === currentActId);
    const chapter = act ? act.chapters.find(c => c.id === currentChapterId) : null;
    const scene = chapter ? chapter.scenes.find(s => s.id === currentSceneId) : null;
    const breadcrumb = scene ? ((act.title || `Acte`) + ' › ' + (chapter.title || `Chapitre`)) : '';
    const sceneTitle = scene ? scene.title : 'Scène sans titre';

    // 1. CLEANUP: Remove any existing Floating Item for this scene
    // We will recreate/update it only if needed (i.e. if targetColumnId is null)
    // Or we can update it in place. But for safety when switching modes, let's allow finding it.

    let existingFloatingItem = arc.board.items.find(i => i.type === 'scene' && i.sceneId == currentSceneId);

    // 2. CLEANUP: Remove card from any column (including the target one to avoid dupes before re-adding)
    arc.board.items.forEach(item => {
        if (item.type === 'column' && item.cards) {
            item.cards = item.cards.filter(c => !(c.type === 'scene' && c.sceneId == currentSceneId));
        }
    });

    // 3. LOGIC
    if (targetColumnId) {
        // CASE: Assigned to a Column
        // Remove floating item if it exists
        if (existingFloatingItem) {
            arc.board.items = arc.board.items.filter(i => i.id !== existingFloatingItem.id);
        }

        // Add to new column
        const column = arc.board.items.find(i => i.id === targetColumnId && i.type === 'column');
        if (column) {
            if (!column.cards) column.cards = [];
            column.cards.push({
                id: 'card_' + Date.now(),
                type: 'scene',
                sceneId: currentSceneId,
                sceneTitle: sceneTitle,
                breadcrumb: breadcrumb,
                intensity: presence ? presence.intensity : 3,
                status: presence ? presence.status : 'development',
                notes: presence ? presence.notes : ''
            });
        }
    } else {
        // CASE: Unassigned (Arc Général)
        // Remove any existing floating item (no longer needed with unassigned zone)
        if (existingFloatingItem) {
            arc.board.items = arc.board.items.filter(i => i.id !== existingFloatingItem.id);
        }
        // La scène apparaîtra automatiquement dans la zone "Non attribué"
        // car renderItems() filtre les scènes avec columnId === null
    }

    saveProject();

    // Rafraîchir le arc-board s'il est ouvert (peu importe quel arc est affiché)
    // Cela garantit que la carte flottante apparaît immédiatement
    if (typeof ArcBoardViewModel !== 'undefined' && ArcBoardViewModel.getCurrentArc) {
        const currentArc = ArcBoardViewModel.getCurrentArc();
        if (currentArc && currentArc.id === arcId) {
            ArcBoardViewModel.renderItems();
        }
    }

    renderArcScenePanel();
}

init();
themeManager.init();

// Initialize Lucide icons
if (typeof lucide !== 'undefined') {
    lucide.createIcons();
}


// ========== js-refactor/arc-board/arc-board.config.js ==========
// ============================================
// ARC BOARD - Configuration & Constants
// ============================================

/**
 * Génère un ID unique avec un préfixe
 * @param {string} prefix - Préfixe de l'ID (ex: 'arc', 'item', 'card', 'conn')
 * @returns {string} ID unique
 */
function generateUniqueId(prefix = 'id') {
    return `${prefix}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}

const ArcBoardConfig = {
    canvas: {
        minZoom: 0.25,
        maxZoom: 2,
        zoomStep: 0.1,
        width: 3000,
        height: 2000
    },
    grid: {
        size: 24,
        snapEnabled: true
    },
    column: {
        defaultWidth: 280,
        minWidth: 200,
        maxWidth: 500
    },
    item: {
        noteWidth: 250,
        imageWidth: 300,
        linkWidth: 280,
        todoWidth: 260,
        commentWidth: 220
    }
};

// Catégories d'arcs prédéfinies
const ArcCategories = Object.freeze({
    intrigue: { label: 'Intrigue principale', icon: 'book-open', color: '#e74c3c' },
    subplot: { label: 'Intrigue secondaire', icon: 'file-text', color: '#16a085' },
    character: { label: 'Arc personnage', icon: 'user', color: '#3498db' },
    relationship: { label: 'Relation', icon: 'heart', color: '#e91e63' },
    theme: { label: 'Thème', icon: 'message-circle', color: '#9b59b6' },
    mystery: { label: 'Mystère', icon: 'search', color: '#607d8b' },
    worldbuilding: { label: 'Worldbuilding', icon: 'globe', color: '#1976d2' }
});

// Types de cartes supportés
const CardTypes = Object.freeze({
    note: { label: 'Note', icon: 'file-text' },
    image: { label: 'Image', icon: 'image' },
    link: { label: 'Lien', icon: 'link' },
    todo: { label: 'Tâches', icon: 'check-square' },
    comment: { label: 'Commentaire', icon: 'message-square' },
    table: { label: 'Tableau', icon: 'table' },
    audio: { label: 'Audio', icon: 'music' },
    scene: { label: 'Scène liée', icon: 'book-open' }
});

// Types d'items sur le board
const BoardItemTypes = Object.freeze({
    COLUMN: 'column',
    NOTE: 'note',
    IMAGE: 'image',
    LINK: 'link',
    TODO: 'todo',
    COMMENT: 'comment',
    TABLE: 'table',
    SCENE: 'scene'
});

// Outils disponibles
const ToolTypes = Object.freeze({
    SELECT: 'select',
    PAN: 'pan',
    CONNECT: 'connect'
});

// Types de drag
const DragTypes = Object.freeze({
    NONE: null,
    CARD: 'card',
    FLOATING: 'floating',
    COLUMN: 'column',
    UNASSIGNED: 'unassigned',
    TOOLBAR: 'toolbar'
});

// Types d'items disponibles pour création (toolbar et menu)
const CreatableItemTypes = Object.freeze({
    note: { label: 'Note', icon: 'file-text', canBeCard: true },
    column: { label: 'Colonne', icon: 'columns-3', canBeCard: false },
    link: { label: 'Lien', icon: 'link', canBeCard: true },
    todo: { label: 'Tâches', icon: 'check-square', canBeCard: true },
    comment: { label: 'Commentaire', icon: 'message-square', canBeCard: true },
    table: { label: 'Tableau', icon: 'table', canBeCard: true },
    image: { label: 'Image', icon: 'image', canBeCard: true }
});

// ========== js-refactor/arc-board/arc-board.models.js ==========
// ============================================
// ARC BOARD - Models (Data Structures)
// ============================================

/**
 * Factory pour créer un nouvel Arc narratif
 */
function createArcModel(data = {}) {
    const now = new Date().toISOString();
    return {
        id: data.id || generateUniqueId('arc'),
        title: data.title || 'Nouvel arc',
        category: data.category || 'intrigue',
        color: data.color || '#e74c3c',
        description: data.description || '',
        created: data.created || now,
        updated: now,
        board: data.board || createBoardModel(),
        type: data.category || 'intrigue',
        importance: data.importance || 'major',
        relatedCharacters: data.relatedCharacters || [],
        resolution: data.resolution || { type: 'ongoing', sceneId: null },
        scenePresence: data.scenePresence || []
    };
}

/**
 * Factory pour créer un Board vide
 */
function createBoardModel() {
    return {
        items: [],
        connections: []
    };
}

/**
 * Factory pour créer un Item du board (colonne, note, image, etc.)
 */
function createBoardItemModel(type, position = { x: 0, y: 0 }, data = {}) {
    const base = {
        id: data.id || generateUniqueId('item'),
        type: type,
        x: position.x,
        y: position.y
    };

    switch (type) {
        case BoardItemTypes.COLUMN:
            return {
                ...base,
                title: data.title || 'Nouvelle colonne',
                width: data.width || ArcBoardConfig.column.defaultWidth,
                cards: data.cards || []
            };

        case BoardItemTypes.NOTE:
            return {
                ...base,
                content: data.content || '',
                width: data.width || ArcBoardConfig.item.noteWidth
            };

        case BoardItemTypes.IMAGE:
            return {
                ...base,
                src: data.src || '',
                width: data.width || ArcBoardConfig.item.imageWidth,
                caption: data.caption || ''
            };

        case BoardItemTypes.LINK:
            return {
                ...base,
                url: data.url || '',
                title: data.title || ''
            };

        case BoardItemTypes.TODO:
            return {
                ...base,
                title: data.title || 'Liste de tâches',
                items: data.items || []
            };

        case BoardItemTypes.COMMENT:
            return {
                ...base,
                content: data.content || ''
            };

        case BoardItemTypes.TABLE:
            return {
                ...base,
                rows: data.rows || 3,
                cols: data.cols || 3,
                data: data.data || []
            };

        case BoardItemTypes.SCENE:
            return {
                ...base,
                sceneId: data.sceneId || '',
                sceneTitle: data.sceneTitle || '',
                breadcrumb: data.breadcrumb || '',
                intensity: data.intensity || 3,
                status: data.status || 'development',
                notes: data.notes || '',
                width: data.width || 220
            };

        default:
            return base;
    }
}

/**
 * Factory pour créer une Carte (dans une colonne)
 */
function createCardModel(type, data = {}) {
    const base = {
        id: data.id || generateUniqueId('card'),
        type: type
    };

    switch (type) {
        case 'note':
            return { ...base, content: data.content || '' };

        case 'image':
            return { ...base, src: data.src || '', caption: data.caption || '' };

        case 'link':
            return { ...base, url: data.url || '', title: data.title || '', previewImage: data.previewImage || '' };

        case 'todo':
            return { ...base, title: data.title || '', items: data.items || [] };

        case 'audio':
            return { ...base, url: data.url || '' };

        case 'scene':
            return {
                ...base,
                sceneId: data.sceneId || '',
                sceneTitle: data.sceneTitle || '',
                breadcrumb: data.breadcrumb || '',
                intensity: data.intensity || 3,
                status: data.status || 'development',
                notes: data.notes || ''
            };

        case 'comment':
            return { ...base, content: data.content || '' };

        case 'table':
            return {
                ...base,
                rows: data.rows || 3,
                cols: data.cols || 3,
                data: data.data || []
            };

        default:
            return { ...base, content: data.content || '' };
    }
}

/**
 * Factory pour créer une Connexion entre deux items
 */
function createConnectionModel(fromId, toId, sides = {}) {
    return {
        id: generateUniqueId('conn'),
        from: fromId,
        fromSide: sides.fromSide || 'right',
        to: toId,
        toSide: sides.toSide || 'left'
    };
}

/**
 * Types de connexions inter-arcs
 */
const InterArcConnectionTypes = {
    PARALLEL: 'parallel',     // Événements simultanés
    CAUSE: 'cause',           // Arc A cause Arc B
    CONSEQUENCE: 'consequence', // Arc A est conséquence de Arc B
    ECHO: 'echo',             // Écho thématique
    CONTRAST: 'contrast'      // Contraste/opposition
};

/**
 * Factory pour créer une connexion inter-arcs
 */
function createInterArcConnectionModel(data = {}) {
    return {
        id: data.id || generateUniqueId('interarc'),
        fromArcId: data.fromArcId,
        fromItemId: data.fromItemId,
        fromSide: data.fromSide || 'right',
        toArcId: data.toArcId,
        toItemId: data.toItemId,
        toSide: data.toSide || 'left',
        type: data.type || InterArcConnectionTypes.PARALLEL,
        label: data.label || '',
        color: data.color || null // Si null, utilise les couleurs des arcs
    };
}

/**
 * Factory pour créer une tâche Todo
 */
function createTodoItemModel(text = '') {
    return {
        text: text,
        completed: false
    };
}

/**
 * Factory pour créer une catégorie custom
 */
function createCategoryModel(name, color) {
    return {
        label: name,
        icon: 'folder',
        color: color,
        custom: true
    };
}

/**
 * Convertit un item flottant en carte
 */
function convertItemToCard(item) {
    const card = createCardModel(item.type);

    switch (item.type) {
        case 'note':
        case 'comment':
            card.content = item.content || '';
            break;
        case 'todo':
            card.title = item.title || '';
            card.items = item.items || [];
            break;
        case 'image':
            card.src = item.src || '';
            card.caption = item.caption || '';
            break;
        case 'link':
            card.url = item.url || '';
            card.title = item.title || '';
            break;
        case 'table':
            card.rows = item.rows || 3;
            card.cols = item.cols || 3;
            card.data = item.data || [];
            break;
        case 'scene':
            card.sceneId = item.sceneId || '';
            card.sceneTitle = item.sceneTitle || '';
            card.breadcrumb = item.breadcrumb || '';
            card.intensity = item.intensity || 3;
            card.status = item.status || 'development';
            card.notes = item.notes || '';
            break;
    }

    return card;
}

/**
 * Convertit une carte en item flottant
 */
function convertCardToItem(card, position) {
    const type = card.type === 'audio' ? 'note' : card.type;
    const item = createBoardItemModel(type, position);

    switch (card.type) {
        case 'note':
            item.content = card.content || '';
            break;
        case 'todo':
            item.title = card.title || '';
            item.items = card.items || [];
            break;
        case 'image':
            item.src = card.src || '';
            break;
        case 'link':
            item.url = card.url || '';
            item.title = card.title || '';
            break;
        case 'scene':
            item.sceneId = card.sceneId || '';
            item.sceneTitle = card.sceneTitle || '';
            item.breadcrumb = card.breadcrumb || '';
            item.intensity = card.intensity || 3;
            item.status = card.status || 'development';
            item.notes = card.notes || '';
            break;
    }

    return item;
}

// ========== js-refactor/arc-board/arc-board.repository.js ==========
// ============================================
// ARC BOARD - Repository (CRUD Operations)
// ============================================

/**
 * Repository pour les opérations CRUD sur les Arcs
 */
const ArcRepository = {
    /**
     * Initialise les structures de données si nécessaires
     */
    init() {
        if (!project.arcCategories) {
            project.arcCategories = {};
        }
        if (!project.narrativeArcs) {
            project.narrativeArcs = [];
        }
        if (!project.collapsedArcCategories) {
            project.collapsedArcCategories = [];
        }
    },

    /**
     * Récupère tous les arcs
     */
    getAll() {
        this.init();
        return project.narrativeArcs || [];
    },

    /**
     * Récupère un arc par son ID
     */
    getById(arcId) {
        return this.getAll().find(arc => arc.id === arcId) || null;
    },

    /**
     * Crée un nouvel arc
     */
    create(data) {
        this.init();
        const arc = createArcModel(data);
        project.narrativeArcs.push(arc);
        this._save();
        return arc;
    },

    /**
     * Met à jour un arc existant
     */
    update(arcId, data) {
        const arc = this.getById(arcId);
        if (!arc) return null;

        Object.assign(arc, data, { updated: new Date().toISOString() });
        this._save();
        return arc;
    },

    /**
     * Supprime un arc
     */
    delete(arcId) {
        this.init();
        const index = project.narrativeArcs.findIndex(a => a.id === arcId);
        if (index === -1) return false;

        project.narrativeArcs.splice(index, 1);
        this._save();
        return true;
    },

    /**
     * Duplique un arc
     */
    duplicate(arcId) {
        const arc = this.getById(arcId);
        if (!arc) return null;

        const newArc = JSON.parse(JSON.stringify(arc));
        newArc.id = generateUniqueId('arc');
        newArc.title = arc.title + ' (copie)';
        newArc.created = new Date().toISOString();
        newArc.updated = new Date().toISOString();

        // Régénérer les IDs
        const idMap = {};
        newArc.board.items.forEach(item => {
            const oldId = item.id;
            item.id = generateUniqueId('item');
            idMap[oldId] = item.id;

            if (item.cards) {
                item.cards.forEach(card => {
                    card.id = generateUniqueId('card');
                });
            }
        });

        if (newArc.board.connections) {
            newArc.board.connections.forEach(conn => {
                conn.id = generateUniqueId('conn');
                conn.from = idMap[conn.from] || conn.from;
                conn.to = idMap[conn.to] || conn.to;
            });
        }

        project.narrativeArcs.push(newArc);
        this._save();
        return newArc;
    },

    /**
     * Récupère toutes les catégories (prédéfinies + custom)
     */
    getAllCategories() {
        this.init();
        return { ...ArcCategories, ...project.arcCategories };
    },

    /**
     * Ajoute une catégorie custom
     */
    addCategory(name, color) {
        this.init();
        const key = name.toLowerCase().replace(/[^a-z0-9]/g, '_').replace(/_+/g, '_');
        project.arcCategories[key] = createCategoryModel(name, color);
        this._save();
        return key;
    },

    /**
     * Toggle l'état collapsed d'une catégorie
     */
    toggleCategoryCollapse(categoryKey) {
        this.init();
        const index = project.collapsedArcCategories.indexOf(categoryKey);
        if (index === -1) {
            project.collapsedArcCategories.push(categoryKey);
        } else {
            project.collapsedArcCategories.splice(index, 1);
        }
        this._save();
    },

    /**
     * Vérifie si une catégorie est collapsed
     */
    isCategoryCollapsed(categoryKey) {
        return project.collapsedArcCategories?.includes(categoryKey) || false;
    },

    _save() {
        if (typeof saveProject === 'function') {
            saveProject();
        }
    }
};

/**
 * Repository pour les opérations CRUD sur les Items du Board
 */
const BoardItemRepository = {
    /**
     * Récupère tous les items d'un arc
     */
    getAll(arcId) {
        const arc = ArcRepository.getById(arcId);
        return arc?.board?.items || [];
    },

    /**
     * Récupère un item par son ID
     */
    getById(arcId, itemId) {
        return this.getAll(arcId).find(item => item.id === itemId) || null;
    },

    /**
     * Crée un nouvel item
     */
    create(arcId, type, position, data = {}) {
        const arc = ArcRepository.getById(arcId);
        if (!arc) return null;

        if (!arc.board) arc.board = createBoardModel();

        const item = createBoardItemModel(type, position, data);
        arc.board.items.push(item);
        this._save();
        return item;
    },

    /**
     * Met à jour un item
     */
    update(arcId, itemId, data) {
        const item = this.getById(arcId, itemId);
        if (!item) return null;

        Object.assign(item, data);
        this._save();
        return item;
    },

    /**
     * Met à jour la position d'un item
     */
    updatePosition(arcId, itemId, x, y) {
        return this.update(arcId, itemId, { x, y });
    },

    /**
     * Supprime un item
     */
    delete(arcId, itemId) {
        const arc = ArcRepository.getById(arcId);
        if (!arc?.board?.items) return false;

        const index = arc.board.items.findIndex(i => i.id === itemId);
        if (index === -1) return false;

        // Récupérer l'item avant suppression pour gérer le cas des items scene
        const item = arc.board.items[index];

        // Si c'est un item scene, retirer complètement de la scenePresence
        // Cela permet de mettre à jour la vue Structure > Arcs
        if (item.type === 'scene' && item.sceneId && arc.scenePresence) {
            arc.scenePresence = arc.scenePresence.filter(p => p.sceneId != item.sceneId);
        }

        arc.board.items.splice(index, 1);

        // Supprimer les connexions liées
        if (arc.board.connections) {
            arc.board.connections = arc.board.connections.filter(
                c => c.from !== itemId && c.to !== itemId
            );
        }

        this._save();
        return true;
    },

    _save() {
        if (typeof saveProject === 'function') {
            saveProject();
        }
    }
};

/**
 * Repository pour les opérations CRUD sur les Cartes
 */
const CardRepository = {
    /**
     * Récupère toutes les cartes d'une colonne
     */
    getAll(arcId, columnId) {
        const column = BoardItemRepository.getById(arcId, columnId);
        return column?.cards || [];
    },

    /**
     * Récupère une carte par son ID
     */
    getById(arcId, columnId, cardId) {
        return this.getAll(arcId, columnId).find(card => card.id === cardId) || null;
    },

    /**
     * Trouve une carte dans tout le board (retourne { column, card, index })
     */
    findInBoard(arcId, cardId) {
        const items = BoardItemRepository.getAll(arcId);
        for (const item of items) {
            if (item.type === 'column' && item.cards) {
                const index = item.cards.findIndex(c => c.id === cardId);
                if (index !== -1) {
                    return { column: item, card: item.cards[index], index };
                }
            }
        }
        return null;
    },

    /**
     * Crée une nouvelle carte
     */
    create(arcId, columnId, type, data = {}) {
        const column = BoardItemRepository.getById(arcId, columnId);
        if (!column || column.type !== 'column') return null;

        if (!column.cards) column.cards = [];

        const card = createCardModel(type, data);
        column.cards.push(card);
        this._save();
        return card;
    },

    /**
     * Met à jour une carte
     */
    update(arcId, columnId, cardId, data) {
        const card = this.getById(arcId, columnId, cardId);
        if (!card) return null;

        Object.assign(card, data);
        this._save();
        return card;
    },

    /**
     * Supprime une carte
     */
    delete(arcId, columnId, cardId) {
        const column = BoardItemRepository.getById(arcId, columnId);
        if (!column?.cards) return false;

        const index = column.cards.findIndex(c => c.id === cardId);
        if (index === -1) return false;

        // Récupérer la carte avant suppression pour gérer le cas des cartes scene
        const card = column.cards[index];

        // Si c'est une carte scene, retirer complètement de la scenePresence
        // Cela permet de mettre à jour la vue Structure > Arcs
        if (card.type === 'scene' && card.sceneId) {
            const arc = ArcRepository.getById(arcId);
            if (arc && arc.scenePresence) {
                arc.scenePresence = arc.scenePresence.filter(p => p.sceneId != card.sceneId);
            }
        }

        column.cards.splice(index, 1);
        this._save();
        return true;
    },

    /**
     * Déplace une carte vers une autre colonne
     */
    move(arcId, fromColumnId, toColumnId, cardId, insertIndex = -1) {
        const arc = ArcRepository.getById(arcId);
        if (!arc) return false;

        const fromColumn = BoardItemRepository.getById(arcId, fromColumnId);
        const toColumn = BoardItemRepository.getById(arcId, toColumnId);

        if (!fromColumn?.cards || !toColumn) return false;
        if (!toColumn.cards) toColumn.cards = [];

        const cardIndex = fromColumn.cards.findIndex(c => c.id === cardId);
        if (cardIndex === -1) return false;

        const [card] = fromColumn.cards.splice(cardIndex, 1);

        if (insertIndex >= 0 && insertIndex < toColumn.cards.length) {
            toColumn.cards.splice(insertIndex, 0, card);
        } else {
            toColumn.cards.push(card);
        }

        // Mise à jour scenePresence si c'est une carte scene
        if (card.type === 'scene' && card.sceneId && arc.scenePresence) {
            const presence = arc.scenePresence.find(p => p.sceneId == card.sceneId);
            if (presence) {
                presence.columnId = toColumnId;
            }
        }

        this._save();
        return true;
    },

    /**
     * Convertit une carte en item flottant
     */
    convertToItem(arcId, columnId, cardId, position) {
        const column = BoardItemRepository.getById(arcId, columnId);
        if (!column?.cards) return null;

        const cardIndex = column.cards.findIndex(c => c.id === cardId);
        if (cardIndex === -1) return null;

        const [card] = column.cards.splice(cardIndex, 1);
        const item = convertCardToItem(card, position);

        const arc = ArcRepository.getById(arcId);
        arc.board.items.push(item);

        // Si c'est une carte scene, mettre à jour scenePresence.columnId à null
        if (card.type === 'scene' && card.sceneId && arc.scenePresence) {
            const presence = arc.scenePresence.find(p => p.sceneId == card.sceneId);
            if (presence) {
                presence.columnId = null;
            }
        }

        this._save();
        return item;
    },

    _save() {
        if (typeof saveProject === 'function') {
            saveProject();
        }
    }
};

/**
 * Repository pour les opérations CRUD sur les Connexions
 */
const ConnectionRepository = {
    /**
     * Récupère toutes les connexions d'un arc
     */
    getAll(arcId) {
        const arc = ArcRepository.getById(arcId);
        return arc?.board?.connections || [];
    },

    /**
     * Récupère une connexion par son ID
     */
    getById(arcId, connectionId) {
        return this.getAll(arcId).find(conn => conn.id === connectionId) || null;
    },

    /**
     * Vérifie si une connexion existe entre deux items
     */
    exists(arcId, fromId, toId) {
        return this.getAll(arcId).some(c =>
            (c.from === fromId && c.to === toId) ||
            (c.from === toId && c.to === fromId)
        );
    },

    /**
     * Crée une nouvelle connexion
     */
    create(arcId, fromId, toId, sides = {}) {
        const arc = ArcRepository.getById(arcId);
        if (!arc) return null;

        if (!arc.board.connections) arc.board.connections = [];

        // Vérifier si la connexion existe déjà
        if (this.exists(arcId, fromId, toId)) return null;

        const connection = createConnectionModel(fromId, toId, sides);
        arc.board.connections.push(connection);
        this._save();
        return connection;
    },

    /**
     * Supprime une connexion
     */
    delete(arcId, connectionId) {
        const arc = ArcRepository.getById(arcId);
        if (!arc?.board?.connections) return false;

        const index = arc.board.connections.findIndex(c => c.id === connectionId);
        if (index === -1) return false;

        arc.board.connections.splice(index, 1);
        this._save();
        return true;
    },

    /**
     * Supprime toutes les connexions liées à un item
     */
    deleteByItemId(arcId, itemId) {
        const arc = ArcRepository.getById(arcId);
        if (!arc?.board?.connections) return;

        arc.board.connections = arc.board.connections.filter(
            c => c.from !== itemId && c.to !== itemId
        );
        this._save();
    },

    _save() {
        if (typeof saveProject === 'function') {
            saveProject();
        }
    }
};

/**
 * Repository pour les connexions inter-arcs
 */
const InterArcConnectionRepository = {
    /**
     * Initialise la structure de données
     */
    init() {
        if (!project.interArcConnections) {
            project.interArcConnections = [];
        }
    },

    /**
     * Récupère toutes les connexions inter-arcs
     */
    getAll() {
        this.init();
        return project.interArcConnections || [];
    },

    /**
     * Récupère une connexion par son ID
     */
    getById(connectionId) {
        return this.getAll().find(c => c.id === connectionId) || null;
    },

    /**
     * Récupère les connexions impliquant un arc spécifique
     */
    getByArcId(arcId) {
        return this.getAll().filter(c =>
            c.fromArcId === arcId || c.toArcId === arcId
        );
    },

    /**
     * Récupère les connexions impliquant un item spécifique
     */
    getByItemId(arcId, itemId) {
        return this.getAll().filter(c =>
            (c.fromArcId === arcId && c.fromItemId === itemId) ||
            (c.toArcId === arcId && c.toItemId === itemId)
        );
    },

    /**
     * Crée une nouvelle connexion inter-arc
     */
    create(data) {
        this.init();

        // Vérifier que les deux arcs sont différents
        if (data.fromArcId === data.toArcId) {
            console.warn('InterArcConnection: les deux arcs doivent être différents');
            return null;
        }

        // Vérifier si la connexion existe déjà
        const existing = this.getAll().find(c =>
            c.fromArcId === data.fromArcId &&
            c.fromItemId === data.fromItemId &&
            c.toArcId === data.toArcId &&
            c.toItemId === data.toItemId
        );
        if (existing) return existing;

        const connection = createInterArcConnectionModel(data);
        project.interArcConnections.push(connection);
        this._save();
        return connection;
    },

    /**
     * Met à jour une connexion
     */
    update(connectionId, data) {
        const connection = this.getById(connectionId);
        if (!connection) return null;

        Object.assign(connection, data);
        this._save();
        return connection;
    },

    /**
     * Supprime une connexion
     */
    delete(connectionId) {
        this.init();
        const index = project.interArcConnections.findIndex(c => c.id === connectionId);
        if (index === -1) return false;

        project.interArcConnections.splice(index, 1);
        this._save();
        return true;
    },

    /**
     * Supprime toutes les connexions liées à un arc
     */
    deleteByArcId(arcId) {
        this.init();
        project.interArcConnections = project.interArcConnections.filter(c =>
            c.fromArcId !== arcId && c.toArcId !== arcId
        );
        this._save();
    },

    /**
     * Supprime toutes les connexions liées à un item
     */
    deleteByItemId(arcId, itemId) {
        this.init();
        project.interArcConnections = project.interArcConnections.filter(c =>
            !(c.fromArcId === arcId && c.fromItemId === itemId) &&
            !(c.toArcId === arcId && c.toItemId === itemId)
        );
        this._save();
    },

    _save() {
        if (typeof saveProject === 'function') {
            saveProject();
        }
    }
};

/**
 * Service pour gérer les connexions inter-arcs
 */
const InterArcConnectionService = {
    connecting: false,
    source: null,

    /**
     * Démarre le mode connexion inter-arc
     */
    startConnection() {
        this.connecting = true;
        this.source = null;

        // Afficher une indication visuelle
        const hint = document.getElementById('connectionModeHint');
        if (hint) {
            hint.style.display = 'flex';
            const text = document.getElementById('connectionHintText');
            if (text) text.textContent = 'Cliquez sur un élément source (dans un des arcs)';
        }
    },

    /**
     * Gère le clic sur un élément pendant le mode connexion
     */
    handleClick(arcId, itemId) {
        if (!this.connecting) return false;

        if (!this.source) {
            // Premier clic : définir la source
            this.source = { arcId, itemId };
            const text = document.getElementById('connectionHintText');
            if (text) text.textContent = 'Cliquez sur l\'élément cible (dans un autre arc)';

            // Highlight la source
            const sourceEl = document.querySelector(`[data-arc-id="${arcId}"] [data-item-id="${itemId}"]`);
            if (sourceEl) sourceEl.classList.add('connection-source');

            return true;
        } else {
            // Second clic : créer la connexion
            if (arcId === this.source.arcId) {
                // Même arc, annuler
                console.warn('La connexion doit être entre deux arcs différents');
                return false;
            }

            const connection = InterArcConnectionRepository.create({
                fromArcId: this.source.arcId,
                fromItemId: this.source.itemId,
                toArcId: arcId,
                toItemId: itemId
            });

            this.cancel();
            ArcBoardViewModel.render();
            return !!connection;
        }
    },

    /**
     * Annule le mode connexion
     */
    cancel() {
        this.connecting = false;
        this.source = null;

        const hint = document.getElementById('connectionModeHint');
        if (hint) hint.style.display = 'none';

        document.querySelectorAll('.connection-source').forEach(el => {
            el.classList.remove('connection-source');
        });
    }
};

// ========== js-refactor/arc-board/arc-board.viewmodel.js ==========
// ============================================
// ARC BOARD - ViewModel (State & Logic)
// ============================================

/**
 * Modes d'affichage multi-arcs
 */
const MultiArcModes = {
    SOLO: 'solo',
    COMPARE: 'compare'
};

/**
 * État global du Arc Board (observable)
 */
const ArcBoardState = {
    // Arc courant
    currentArcId: null,

    // Vue & Navigation
    zoom: 1,
    panX: 0,
    panY: 0,

    // Sélection
    selectedItems: [],

    // Outil actif
    activeTool: ToolTypes.SELECT,

    // Mode connexion
    connectionSource: null,

    // Panneau contextuel
    contextPanelOpen: false,

    // Formulaires inline
    showingArcForm: false,
    showingCategoryForm: false,
    editingArcId: null,

    // Presse-papier
    clipboard: null,

    // === MULTI-ARCS ===
    multiArcMode: MultiArcModes.SOLO,
    multiArcBarExpanded: false,
    compareArcs: [],         // IDs des arcs à comparer (incluant l'arc principal)
    compareLayout: 'horizontal', // 'horizontal' ou 'vertical'
    interArcConnectionSource: null, // Pour créer des connexions inter-arcs
    compareArcHeights: {},   // Hauteurs personnalisées par arc en mode Compare { arcId: height }
    compareArcOpacities: {}, // Opacités personnalisées par arc en mode Compare { arcId: 0-100 }

    // Reset l'état
    reset() {
        this.currentArcId = null;
        this.zoom = 1;
        this.panX = 0;
        this.panY = 0;
        this.selectedItems = [];
        this.activeTool = ToolTypes.SELECT;
        this.connectionSource = null;
        this.contextPanelOpen = false;
        this.showingArcForm = false;
        this.showingCategoryForm = false;
        this.editingArcId = null;
        // Reset multi-arcs
        this.multiArcMode = MultiArcModes.SOLO;
        this.multiArcBarExpanded = false;
        this.compareArcs = [];
        this.compareLayout = 'horizontal';
        this.interArcConnectionSource = null;
        this.compareArcHeights = {};
        this.compareArcOpacities = {};
    }
};

/**
 * ViewModel principal - Coordonne les actions
 */
const ArcBoardViewModel = {
    // ==========================================
    // NAVIGATION & ARCS
    // ==========================================

    /**
     * Ouvre un arc dans le board
     */
    openArc(arcId) {
        const arc = ArcRepository.getById(arcId);
        if (!arc) return false;

        // Initialiser le board si nécessaire
        if (!arc.board) {
            arc.board = createBoardModel();
        }

        ArcBoardState.currentArcId = arcId;
        ArcBoardState.selectedItems = [];
        ArcBoardState.zoom = 1;
        ArcBoardState.panX = 0;
        ArcBoardState.panY = 0;

        this.render();
        return true;
    },

    /**
     * Ferme l'arc courant
     */
    closeArc() {
        ArcBoardState.currentArcId = null;
        ArcBoardState.selectedItems = [];
        ArcBoardView.renderWelcome();
        ArcBoardView.renderSidebar();
    },

    /**
     * Récupère l'arc courant
     */
    getCurrentArc() {
        return ArcRepository.getById(ArcBoardState.currentArcId);
    },

    // ==========================================
    // RENDU
    // ==========================================

    /**
     * Rendu complet de l'interface
     */
    render() {
        ArcBoardView.renderSidebar();

        const arc = this.getCurrentArc();
        if (arc) {
            ArcBoardView.renderCanvas(arc);
            ArcBoardView.renderItems(arc);
            ArcBoardView.renderConnections(arc);
        } else {
            ArcBoardView.renderWelcome();
        }
    },

    /**
     * Rendu partiel des items seulement
     */
    renderItems() {
        const arc = this.getCurrentArc();
        if (arc) {
            ArcBoardView.renderItems(arc);
            ArcBoardView.renderConnections(arc);
        }
    },

    // ==========================================
    // SÉLECTION
    // ==========================================

    /**
     * Sélectionne un item
     * @param {string} itemId - ID de l'item
     * @param {boolean} addToSelection - Ajouter à la sélection existante
     * @param {string|null} arcId - ID de l'arc (optionnel, pour le mode compare)
     */
    selectItem(itemId, addToSelection = false, arcId = null) {
        if (ArcBoardState.activeTool === ToolTypes.CONNECT) {
            return ConnectionService.handleClick(itemId);
        }

        if (addToSelection) {
            const index = ArcBoardState.selectedItems.indexOf(itemId);
            if (index === -1) {
                ArcBoardState.selectedItems.push(itemId);
            } else {
                ArcBoardState.selectedItems.splice(index, 1);
            }
        } else {
            ArcBoardState.selectedItems = [itemId];
        }

        this._updateSelectionUI();

        // Mettre à jour le panneau contextuel
        if (ArcBoardState.selectedItems.length === 1) {
            // Utiliser l'arcId fourni ou l'arc courant
            const targetArcId = arcId || ArcBoardState.currentArcId;
            const arc = ArcRepository.getById(targetArcId);
            if (arc) {
                const item = BoardItemRepository.getById(arc.id, itemId);
                if (item) {
                    ArcBoardView.renderContextPanel(item);
                    if (!ArcBoardState.contextPanelOpen) {
                        this.toggleContextPanel();
                    }
                }
            }
        }
    },

    /**
     * Désélectionne tout
     */
    deselectAll() {
        ArcBoardState.selectedItems = [];
        this._updateSelectionUI();

        const arc = this.getCurrentArc();
        if (arc) {
            ArcBoardView.renderContextPanelDefault(arc);
        }
    },

    /**
     * Sélectionne tous les items
     */
    selectAll() {
        const arc = this.getCurrentArc();
        if (!arc) return;

        ArcBoardState.selectedItems = arc.board.items.map(i => i.id);
        this._updateSelectionUI();
    },

    _updateSelectionUI() {
        document.querySelectorAll('.arc-column, .arc-floating-item').forEach(el => {
            el.classList.remove('selected');
        });
        document.querySelectorAll('.arc-connection-line').forEach(el => {
            el.classList.remove('selected');
        });

        ArcBoardState.selectedItems.forEach(id => {
            const el = document.getElementById(`item-${id}`);
            if (el) el.classList.add('selected');

            const line = document.querySelector(`[data-connection-id="${id}"]`);
            if (line) line.classList.add('selected');
        });
    },

    // ==========================================
    // OUTILS
    // ==========================================

    /**
     * Change l'outil actif
     */
    setTool(tool) {
        // Annuler le mode connexion si on change d'outil
        if (ArcBoardState.activeTool === ToolTypes.CONNECT && tool !== ToolTypes.CONNECT) {
            ConnectionService.cancel();
        }

        ArcBoardState.activeTool = tool;

        // Mettre à jour l'UI
        document.querySelectorAll('.arc-toolbar-btn').forEach(btn => {
            btn.classList.remove('active');
        });

        const activeBtn = document.querySelector(`.arc-toolbar-btn[data-tool="${tool}"]`);
        if (activeBtn) activeBtn.classList.add('active');

        // Changer le curseur
        const canvas = document.getElementById('arcBoardCanvas');
        if (canvas) {
            canvas.classList.remove('tool-pan', 'tool-connect');
            if (tool === ToolTypes.PAN) canvas.classList.add('tool-pan');
            if (tool === ToolTypes.CONNECT) canvas.classList.add('tool-connect');
        }
    },

    // ==========================================
    // ZOOM & PAN
    // ==========================================

    /**
     * Zoom avant/arrière
     */
    zoom(delta) {
        const newZoom = ArcBoardState.zoom + (delta * ArcBoardConfig.canvas.zoomStep);
        ArcBoardState.zoom = Math.max(
            ArcBoardConfig.canvas.minZoom,
            Math.min(ArcBoardConfig.canvas.maxZoom, newZoom)
        );
        this._updateCanvasTransform();
    },

    /**
     * Reset zoom et position
     */
    resetView() {
        ArcBoardState.zoom = 1;
        ArcBoardState.panX = 0;
        ArcBoardState.panY = 0;
        this._updateCanvasTransform();
    },

    /**
     * Pan le canvas
     */
    pan(deltaX, deltaY) {
        ArcBoardState.panX += deltaX;
        ArcBoardState.panY += deltaY;
        this._updateCanvasTransform();
    },

    _updateCanvasTransform() {
        const content = document.getElementById('arcBoardContent');
        if (content) {
            content.style.transform = `scale(${ArcBoardState.zoom}) translate(${ArcBoardState.panX}px, ${ArcBoardState.panY}px)`;
        }

        const zoomLevel = document.getElementById('arcZoomLevel');
        if (zoomLevel) {
            zoomLevel.textContent = `${Math.round(ArcBoardState.zoom * 100)}%`;
        }
    },

    // ==========================================
    // ITEMS
    // ==========================================

    /**
     * Ajoute un item au centre du canvas visible
     */
    addItem(type) {
        const arc = this.getCurrentArc();
        if (!arc) return null;

        const position = this._getCenterPosition();
        const item = BoardItemRepository.create(arc.id, type, position);

        this.renderItems();
        this.selectItem(item.id);

        return item;
    },

    /**
     * Ajoute un item à une position spécifique
     */
    addItemAt(type, clientX, clientY) {
        const arc = this.getCurrentArc();
        if (!arc) return null;

        const position = this._clientToCanvasPosition(clientX, clientY);
        const item = BoardItemRepository.create(arc.id, type, position);

        this.renderItems();
        this.selectItem(item.id);

        return item;
    },

    /**
     * Supprime les items sélectionnés
     */
    deleteSelected() {
        const arc = this.getCurrentArc();
        if (!arc || ArcBoardState.selectedItems.length === 0) return;

        ArcBoardState.selectedItems.forEach(id => {
            // Vérifier si c'est une connexion
            const conn = ConnectionRepository.getById(arc.id, id);
            if (conn) {
                ConnectionRepository.delete(arc.id, id);
            } else {
                BoardItemRepository.delete(arc.id, id);
            }
        });

        ArcBoardState.selectedItems = [];
        this.renderItems();

        // Mettre à jour le panneau arcScenePanel s'il est visible
        const arcPanel = document.getElementById('arcScenePanel');
        if (arcPanel && !arcPanel.classList.contains('hidden') && typeof renderArcScenePanel === 'function') {
            renderArcScenePanel();
        }
    },

    /**
     * Met à jour un item
     * @param {string} itemId - ID de l'item
     * @param {object} data - Données à mettre à jour
     * @param {string|null} arcId - ID de l'arc (optionnel, pour le mode compare)
     */
    updateItem(itemId, data, arcId = null) {
        const targetArcId = arcId || ArcBoardState.currentArcId;
        const arc = ArcRepository.getById(targetArcId);
        if (!arc) return;

        BoardItemRepository.update(arc.id, itemId, data);
    },

    /**
     * Met à jour la position d'un item
     */
    updateItemPosition(itemId, x, y) {
        const arc = this.getCurrentArc();
        if (!arc) return;

        BoardItemRepository.updatePosition(arc.id, itemId, x, y);
        ArcBoardView.renderConnections(arc);
    },

    // ==========================================
    // CARTES
    // ==========================================

    /**
     * Ajoute une carte à une colonne
     * @param {string} columnId - ID de la colonne
     * @param {string} type - Type de carte
     * @param {string|null} arcId - ID de l'arc (optionnel, pour le mode compare)
     */
    addCard(columnId, type = 'note', arcId = null) {
        const targetArcId = arcId || ArcBoardState.currentArcId;
        const arc = ArcRepository.getById(targetArcId);
        if (!arc) return null;

        const card = CardRepository.create(arc.id, columnId, type);
        this.renderItems();
        return card;
    },

    /**
     * Supprime une carte
     * @param {string} columnId - ID de la colonne
     * @param {string} cardId - ID de la carte
     * @param {string|null} arcId - ID de l'arc (optionnel, pour le mode compare)
     */
    deleteCard(columnId, cardId, arcId = null) {
        const targetArcId = arcId || ArcBoardState.currentArcId;
        const arc = ArcRepository.getById(targetArcId);
        if (!arc) return;

        CardRepository.delete(arc.id, columnId, cardId);
        this.renderItems();

        // Mettre à jour le panneau arcScenePanel s'il est visible
        const arcPanel = document.getElementById('arcScenePanel');
        if (arcPanel && !arcPanel.classList.contains('hidden') && typeof renderArcScenePanel === 'function') {
            renderArcScenePanel();
        }
    },

    /**
     * Met à jour une carte
     * @param {string} columnId - ID de la colonne
     * @param {string} cardId - ID de la carte
     * @param {object} data - Données à mettre à jour
     * @param {string|null} arcId - ID de l'arc (optionnel, pour le mode compare)
     */
    updateCard(columnId, cardId, data, arcId = null) {
        const targetArcId = arcId || ArcBoardState.currentArcId;
        const arc = ArcRepository.getById(targetArcId);
        if (!arc) return;

        CardRepository.update(arc.id, columnId, cardId, data);
    },

    // ==========================================
    // COPY/PASTE
    // ==========================================

    /**
     * Copie les items sélectionnés
     */
    copy() {
        const arc = this.getCurrentArc();
        if (!arc) return;

        const itemsToCopy = arc.board.items.filter(i =>
            ArcBoardState.selectedItems.includes(i.id)
        );
        ArcBoardState.clipboard = JSON.parse(JSON.stringify(itemsToCopy));
    },

    /**
     * Colle les items du presse-papier
     */
    paste() {
        if (!ArcBoardState.clipboard?.length) return;

        const arc = this.getCurrentArc();
        if (!arc) return;

        const offset = 40;

        ArcBoardState.clipboard.forEach(item => {
            const newItem = JSON.parse(JSON.stringify(item));
            newItem.id = generateUniqueId('item');
            newItem.x += offset;
            newItem.y += offset;

            if (newItem.cards) {
                newItem.cards.forEach(card => {
                    card.id = generateUniqueId('card');
                });
            }

            arc.board.items.push(newItem);
        });

        saveProject();
        this.renderItems();
    },

    // ==========================================
    // PANNEAU CONTEXTUEL
    // ==========================================

    toggleContextPanel() {
        ArcBoardState.contextPanelOpen = !ArcBoardState.contextPanelOpen;
        const panel = document.getElementById('arcContextPanel');
        if (panel) {
            panel.classList.toggle('collapsed', !ArcBoardState.contextPanelOpen);
        }
    },

    // ==========================================
    // FORMULAIRES
    // ==========================================

    showArcForm(arcId = null) {
        ArcBoardState.editingArcId = arcId;
        ArcBoardState.showingArcForm = true;
        ArcBoardState.showingCategoryForm = false;
        ArcBoardView.renderSidebar();
    },

    hideArcForm() {
        ArcBoardState.showingArcForm = false;
        ArcBoardState.editingArcId = null;
        ArcBoardView.renderSidebar();
    },

    showCategoryForm() {
        ArcBoardState.showingCategoryForm = true;
        ArcBoardState.showingArcForm = false;
        ArcBoardView.renderSidebar();
    },

    hideCategoryForm() {
        ArcBoardState.showingCategoryForm = false;
        ArcBoardView.renderSidebar();
    },

    // ==========================================
    // HELPERS
    // ==========================================

    _getCenterPosition() {
        const canvas = document.getElementById('arcBoardCanvas');
        if (!canvas) return { x: 100, y: 100 };

        const rect = canvas.getBoundingClientRect();
        let x = (rect.width / 2 - ArcBoardState.panX) / ArcBoardState.zoom;
        let y = (rect.height / 2 - ArcBoardState.panY) / ArcBoardState.zoom;

        return this._snapToGrid({ x, y });
    },

    _clientToCanvasPosition(clientX, clientY) {
        const content = document.getElementById('arcBoardContent');
        if (!content) return { x: clientX, y: clientY };

        const rect = content.getBoundingClientRect();
        let x = (clientX - rect.left) / ArcBoardState.zoom;
        let y = (clientY - rect.top) / ArcBoardState.zoom;

        return this._snapToGrid({ x, y });
    },

    _snapToGrid(position) {
        if (!ArcBoardConfig.grid.snapEnabled) return position;

        const gridSize = ArcBoardConfig.grid.size;
        return {
            x: Math.round(position.x / gridSize) * gridSize,
            y: Math.round(position.y / gridSize) * gridSize
        };
    },

    // ==========================================
    // MULTI-ARCS
    // ==========================================

    /**
     * Bascule l'affichage de la barre multi-arcs
     */
    toggleMultiArcBar() {
        ArcBoardState.multiArcBarExpanded = !ArcBoardState.multiArcBarExpanded;
        this.render();
    },

    /**
     * Change le mode d'affichage multi-arcs
     */
    setMultiArcMode(mode) {
        if (!Object.values(MultiArcModes).includes(mode)) return;

        const previousMode = ArcBoardState.multiArcMode;
        ArcBoardState.multiArcMode = mode;

        // Expand la barre si on passe en mode Compare
        if (mode !== MultiArcModes.SOLO) {
            ArcBoardState.multiArcBarExpanded = true;
        }

        // Initialiser compareArcs si on passe en mode Compare
        if (mode === MultiArcModes.COMPARE && ArcBoardState.compareArcs.length === 0) {
            if (ArcBoardState.currentArcId) {
                ArcBoardState.compareArcs = [ArcBoardState.currentArcId];
            }
        }

        // Nettoyer les arcs comparés si on quitte le mode Compare
        if (previousMode === MultiArcModes.COMPARE && mode !== MultiArcModes.COMPARE) {
            ArcBoardState.compareArcs = [];
        }

        this.render();
    },

    /**
     * Ajoute un arc à comparer
     */
    addCompareArc(arcId) {
        if (!arcId) return;
        if (ArcBoardState.compareArcs.includes(arcId)) return;

        ArcBoardState.compareArcs.push(arcId);
        this.render();
    },

    /**
     * Retire un arc de la comparaison
     */
    removeCompareArc(arcId) {
        // Garder au moins un arc
        if (ArcBoardState.compareArcs.length <= 1) return;

        const index = ArcBoardState.compareArcs.indexOf(arcId);
        if (index > -1) {
            ArcBoardState.compareArcs.splice(index, 1);
            this.render();
        }
    },

    /**
     * Change le layout du mode Compare
     */
    setCompareLayout(layout) {
        if (layout === 'vertical' || layout === 'horizontal') {
            ArcBoardState.compareLayout = layout;
            this.render();
        }
    },

    /**
     * Récupère les arcs disponibles pour ajouter à la comparaison
     */
    getAvailableArcsForAdd() {
        const allArcs = ArcRepository.getAll();
        return allArcs.filter(arc => !ArcBoardState.compareArcs.includes(arc.id));
    },

    /**
     * Définit l'opacité d'un arc en mode compare
     * @param {string} arcId - ID de l'arc
     * @param {number} opacity - Opacité (0-100)
     */
    setArcOpacity(arcId, opacity) {
        const value = Math.max(0, Math.min(100, parseInt(opacity)));
        ArcBoardState.compareArcOpacities[arcId] = value;

        // Mettre à jour le DOM sans re-render complet
        const section = document.querySelector(`.arc-compare-section[data-arc-id="${arcId}"]`);
        if (section) {
            section.style.setProperty('--arc-opacity', value / 100);
            // Mettre à jour l'affichage de la valeur
            const valueDisplay = section.querySelector('.arc-compare-opacity-value');
            if (valueDisplay) {
                valueDisplay.textContent = `${value}%`;
            }
        }
    }
};

// ========== js-refactor/arc-board/arc-board.services.js ==========
// ============================================
// ARC BOARD - Services (DragDrop, Connection, etc.)
// ============================================

/**
 * Service unifié de Drag & Drop
 * Gère le drag de cartes, d'items flottants et de colonnes
 */
const DragDropService = {
    // État du drag en cours
    _state: {
        active: false,
        type: null,         // 'card' | 'floating' | 'column'
        itemId: null,
        sourceColumnId: null,
        arcId: null,        // ID de l'arc source (pour le mode compare)
        element: null,
        startX: 0,
        startY: 0,
        offsetX: 0,
        offsetY: 0
    },

    /**
     * Reset l'état
     */
    reset() {
        this._state = {
            active: false,
            type: null,
            itemId: null,
            sourceColumnId: null,
            arcId: null,
            element: null,
            startX: 0,
            startY: 0,
            offsetX: 0,
            offsetY: 0
        };
    },

    /**
     * Démarre le drag d'une carte
     */
    startCardDrag(event, cardId, columnId, arcId = null) {
        event.stopPropagation();

        this._state = {
            active: true,
            type: DragTypes.CARD,
            itemId: cardId,
            sourceColumnId: columnId,
            arcId: arcId,
            element: event.target.closest('.arc-card'),
            startX: event.clientX,
            startY: event.clientY
        };

        event.dataTransfer.effectAllowed = 'move';
        event.dataTransfer.setData('application/json', JSON.stringify({
            type: 'card',
            cardId: cardId,
            columnId: columnId,
            arcId: arcId
        }));

        if (this._state.element) {
            this._state.element.classList.add('dragging');
        }

        // Activer les zones de drop
        requestAnimationFrame(() => {
            document.querySelectorAll('.arc-column-body').forEach(el => {
                el.classList.add('drop-target');
            });
            document.getElementById('arcBoardCanvas')?.classList.add('drop-zone-active');
        });
    },

    /**
     * Démarre le drag d'un item flottant
     */
    startFloatingDrag(event, itemId, arcId = null) {
        event.stopPropagation();

        this._state = {
            active: true,
            type: DragTypes.FLOATING,
            itemId: itemId,
            sourceColumnId: null,
            arcId: arcId,
            element: event.target.closest('.arc-floating-item'),
            startX: event.clientX,
            startY: event.clientY
        };

        event.dataTransfer.effectAllowed = 'move';
        event.dataTransfer.setData('application/json', JSON.stringify({
            type: 'floating',
            itemId: itemId,
            arcId: arcId
        }));

        if (this._state.element) {
            this._state.element.classList.add('dragging');
        }

        // Activer les zones de drop (colonnes uniquement pour les items flottants)
        requestAnimationFrame(() => {
            document.querySelectorAll('.arc-column-body').forEach(el => {
                el.classList.add('drop-target');
            });
        });
    },

    /**
     * Démarre le drag d'une carte de la zone "Non attribué"
     */
    startUnassignedDrag(event, sceneId) {
        event.stopPropagation();

        this._state = {
            active: true,
            type: DragTypes.UNASSIGNED,
            sceneId: sceneId,
            sourceColumnId: null,
            element: event.target.closest('.arc-card'),
            startX: event.clientX,
            startY: event.clientY
        };

        event.dataTransfer.effectAllowed = 'move';
        event.dataTransfer.setData('application/json', JSON.stringify({
            type: 'unassigned',
            sceneId: sceneId
        }));

        if (this._state.element) {
            this._state.element.classList.add('dragging');
        }

        // Activer les zones de drop (colonnes uniquement)
        requestAnimationFrame(() => {
            document.querySelectorAll('.arc-column-body').forEach(el => {
                el.classList.add('drop-target');
            });
        });
    },

    /**
     * Démarre le drag depuis la toolbar pour créer un nouvel item
     */
    startToolbarDrag(event, itemType) {
        event.stopPropagation();

        this._state = {
            active: true,
            type: DragTypes.TOOLBAR,
            itemType: itemType,
            sourceColumnId: null,
            element: event.target.closest('.arc-toolbar-btn'),
            startX: event.clientX,
            startY: event.clientY
        };

        event.dataTransfer.effectAllowed = 'copy';
        event.dataTransfer.setData('application/json', JSON.stringify({
            type: 'toolbar',
            itemType: itemType
        }));

        // Créer un ghost personnalisé
        const ghost = document.createElement('div');
        ghost.className = 'arc-toolbar-drag-ghost';
        ghost.innerHTML = `<i data-lucide="${CreatableItemTypes[itemType]?.icon || 'plus'}"></i><span>${CreatableItemTypes[itemType]?.label || itemType}</span>`;
        ghost.style.position = 'absolute';
        ghost.style.top = '-1000px';
        document.body.appendChild(ghost);
        if (typeof lucide !== 'undefined') lucide.createIcons();
        event.dataTransfer.setDragImage(ghost, 24, 24);
        setTimeout(() => ghost.remove(), 0);

        if (this._state.element) {
            this._state.element.classList.add('dragging');
        }

        // Activer les zones de drop (canvas + colonnes si le type peut être une carte)
        requestAnimationFrame(() => {
            document.getElementById('arcBoardCanvas')?.classList.add('drop-zone-active');

            // Activer les colonnes seulement pour les types qui peuvent être des cartes
            const canBeCard = CreatableItemTypes[itemType]?.canBeCard;
            if (canBeCard) {
                document.querySelectorAll('.arc-column-body').forEach(el => {
                    el.classList.add('drop-target');
                });
            }
        });
    },

    /**
     * Fin du drag
     */
    endDrag(event) {
        if (this._state.element) {
            this._state.element.classList.remove('dragging');
        }

        // Nettoyer les zones de drop
        document.querySelectorAll('.arc-column-body').forEach(el => {
            el.classList.remove('drop-target', 'drop-hover');
        });
        document.getElementById('arcBoardCanvas')?.classList.remove('drop-zone-active', 'drop-hover');

        this.reset();
    },

    /**
     * Gère le dragover sur une colonne
     */
    handleColumnDragOver(event) {
        if (!this._state.active) return;

        // Pour le toolbar, vérifier si le type peut être une carte
        if (this._state.type === DragTypes.TOOLBAR) {
            const canBeCard = CreatableItemTypes[this._state.itemType]?.canBeCard;
            if (!canBeCard) return;
            event.dataTransfer.dropEffect = 'copy';
        } else {
            event.dataTransfer.dropEffect = 'move';
        }

        event.preventDefault();
        event.currentTarget.classList.add('drop-hover');
    },

    /**
     * Gère le dragleave sur une colonne
     */
    handleColumnDragLeave(event) {
        event.currentTarget.classList.remove('drop-hover');
    },

    /**
     * Gère le drop sur une colonne
     */
    handleColumnDrop(event, targetColumnId, targetArcId = null) {
        event.preventDefault();
        event.stopPropagation();
        event.currentTarget.classList.remove('drop-hover');

        if (!this._state.active) return;

        // Utiliser l'arcId de la cible, sinon l'arcId de la source, sinon l'arc courant
        const arcId = targetArcId || this._state.arcId || ArcBoardState.currentArcId;
        const arc = ArcRepository.getById(arcId);
        if (!arc) return;

        try {
            if (this._state.type === DragTypes.TOOLBAR) {
                // Créer une nouvelle carte depuis la toolbar
                const itemType = this._state.itemType;
                const canBeCard = CreatableItemTypes[itemType]?.canBeCard;

                if (canBeCard) {
                    // Pour la toolbar, utiliser l'arcId cible ou l'arc courant
                    const card = CardRepository.create(arcId, targetColumnId, itemType);
                    ArcBoardViewModel.renderItems();
                }
            } else if (this._state.type === DragTypes.CARD) {
                // Déplacer une carte entre colonnes
                if (this._state.sourceColumnId !== targetColumnId) {
                    CardRepository.move(
                        arcId,
                        this._state.sourceColumnId,
                        targetColumnId,
                        this._state.itemId
                    );
                }
            } else if (this._state.type === DragTypes.FLOATING) {
                // Convertir un item flottant en carte
                const item = BoardItemRepository.getById(arcId, this._state.itemId);
                if (item) {
                    const card = convertItemToCard(item);
                    const isSceneItem = item.type === 'scene' && item.sceneId;

                    // Supprimer l'item flottant (cela met columnId à null pour les scenes)
                    BoardItemRepository.delete(arcId, this._state.itemId);

                    const column = BoardItemRepository.getById(arcId, targetColumnId);
                    if (column) {
                        if (!column.cards) column.cards = [];
                        column.cards.push(card);

                        // Si c'est un item scene, mettre à jour scenePresence.columnId APRÈS la suppression
                        if (isSceneItem && arc.scenePresence) {
                            const presence = arc.scenePresence.find(p => p.sceneId == item.sceneId);
                            if (presence) {
                                presence.columnId = targetColumnId;
                            }
                        }

                        saveProject();
                    }
                }
            } else if (this._state.type === DragTypes.UNASSIGNED) {
                // Déplacer une scène non attribuée vers une colonne
                const sceneId = this._state.sceneId;
                if (sceneId && arc.scenePresence) {
                    const presence = arc.scenePresence.find(p => p.sceneId == sceneId);
                    if (presence) {
                        // Récupérer les infos de la scène
                        let sceneTitle = 'Scène sans titre';
                        let breadcrumb = '';

                        for (const act of project.acts || []) {
                            for (const chapter of act.chapters || []) {
                                const scene = chapter.scenes?.find(s => s.id == sceneId);
                                if (scene) {
                                    sceneTitle = scene.title || 'Scène sans titre';
                                    breadcrumb = `${act.title || 'Acte'} › ${chapter.title || 'Chapitre'}`;
                                    break;
                                }
                            }
                        }

                        // Créer la carte scene
                        const card = {
                            id: generateUniqueId('card'),
                            type: 'scene',
                            sceneId: sceneId,
                            sceneTitle: sceneTitle,
                            breadcrumb: breadcrumb,
                            intensity: presence.intensity || 3,
                            status: presence.status || 'development',
                            notes: presence.notes || ''
                        };

                        // Ajouter à la colonne cible
                        const column = BoardItemRepository.getById(arc.id, targetColumnId);
                        if (column) {
                            if (!column.cards) column.cards = [];
                            column.cards.push(card);

                            // Mettre à jour scenePresence.columnId
                            presence.columnId = targetColumnId;

                            saveProject();
                        }
                    }
                }
            }

            ArcBoardViewModel.renderItems();

            // Rafraîchir le panneau arcScenePanel s'il est visible (pour CARD et FLOATING)
            const arcPanel = document.getElementById('arcScenePanel');
            if (arcPanel && !arcPanel.classList.contains('hidden') && typeof renderArcScenePanel === 'function') {
                renderArcScenePanel();
            }
        } finally {
            this.reset();
        }
    },

    /**
     * Gère le drop sur la zone "Non attribué"
     */
    handleUnassignedDrop(event) {
        event.preventDefault();
        event.stopPropagation();
        event.currentTarget.classList.remove('drop-hover', 'drag-over');

        if (!this._state.active) return;

        const arc = ArcBoardViewModel.getCurrentArc();
        if (!arc) return;

        try {
            if (this._state.type === DragTypes.CARD) {
                // Retirer la carte de sa colonne
                const sourceColumn = BoardItemRepository.getById(arc.id, this._state.sourceColumnId);
                if (sourceColumn && sourceColumn.cards) {
                    const card = sourceColumn.cards.find(c => c.id === this._state.itemId);
                    if (card) {
                        // Retirer la carte de la colonne
                        sourceColumn.cards = sourceColumn.cards.filter(c => c.id !== this._state.itemId);

                        // Si c'est une carte de scène, mettre à jour scenePresence.columnId à null
                        if (card.type === 'scene' && card.sceneId && arc.scenePresence) {
                            const presence = arc.scenePresence.find(p => p.sceneId == card.sceneId);
                            if (presence) {
                                presence.columnId = null;
                            }
                        }

                        saveProject();
                    }
                }
            }
            // Si c'est déjà un item flottant, il reste flottant (rien à faire)

            ArcBoardViewModel.renderItems();

            // Rafraîchir le panneau arcScenePanel
            const arcPanel = document.getElementById('arcScenePanel');
            if (arcPanel && !arcPanel.classList.contains('hidden') && typeof renderArcScenePanel === 'function') {
                renderArcScenePanel();
            }
        } finally {
            this.reset();
        }
    },

    /**
     * Gère le dragover sur le canvas
     */
    handleCanvasDragOver(event) {
        // Ne pas accepter si on est sur une colonne
        if (event.target.closest('.arc-column')) return;

        // Permettre le drop pour les cartes (conversion en item flottant) et la toolbar
        if (this._state.type === DragTypes.CARD) {
            event.preventDefault();
            event.dataTransfer.dropEffect = 'move';
            document.getElementById('arcBoardCanvas')?.classList.add('drop-hover');
        } else if (this._state.type === DragTypes.TOOLBAR) {
            event.preventDefault();
            event.dataTransfer.dropEffect = 'copy';
            document.getElementById('arcBoardCanvas')?.classList.add('drop-hover');
        }
    },

    /**
     * Gère le dragleave sur le canvas
     */
    handleCanvasDragLeave(event) {
        if (!event.relatedTarget || !event.currentTarget.contains(event.relatedTarget)) {
            document.getElementById('arcBoardCanvas')?.classList.remove('drop-hover');
        }
    },

    /**
     * Gère le drop sur le canvas (convertit carte en item flottant ou crée depuis toolbar)
     */
    handleCanvasDrop(event) {
        // Ignorer si on drop sur une colonne
        if (event.target.closest('.arc-column')) return;

        event.preventDefault();
        document.getElementById('arcBoardCanvas')?.classList.remove('drop-hover');

        const arc = ArcBoardViewModel.getCurrentArc();
        if (!arc) return;

        try {
            const position = ArcBoardViewModel._clientToCanvasPosition(event.clientX, event.clientY);

            if (this._state.type === DragTypes.TOOLBAR) {
                // Créer un nouvel item depuis la toolbar à la position du drop
                const item = BoardItemRepository.create(arc.id, this._state.itemType, position);
                ArcBoardViewModel.renderItems();
                ArcBoardViewModel.selectItem(item.id);
            } else if (this._state.type === DragTypes.CARD) {
                // Convertir une carte en item flottant
                CardRepository.convertToItem(
                    arc.id,
                    this._state.sourceColumnId,
                    this._state.itemId,
                    position
                );
                ArcBoardViewModel.renderItems();

                // Rafraîchir le panneau arcScenePanel s'il est visible
                const arcPanel = document.getElementById('arcScenePanel');
                if (arcPanel && !arcPanel.classList.contains('hidden') && typeof renderArcScenePanel === 'function') {
                    renderArcScenePanel();
                }
            }
        } finally {
            this.reset();
        }
    },

    /**
     * Vérifie si un drag est en cours
     */
    isActive() {
        return this._state.active;
    },

    /**
     * Récupère le type de drag en cours
     */
    getType() {
        return this._state.type;
    }
};

/**
 * Service de gestion des Connexions
 */
const ConnectionService = {
    /**
     * Active/désactive le mode connexion
     */
    toggle() {
        if (ArcBoardState.activeTool === ToolTypes.CONNECT) {
            this.cancel();
        } else {
            ArcBoardState.activeTool = ToolTypes.CONNECT;
            ArcBoardState.connectionSource = null;
            this._updateUI();
        }
    },

    /**
     * Annule le mode connexion
     */
    cancel() {
        ArcBoardState.activeTool = ToolTypes.SELECT;
        ArcBoardState.connectionSource = null;
        this._cleanupUI();
        ArcBoardViewModel.setTool(ToolTypes.SELECT);
    },

    /**
     * Gère un clic sur un item en mode connexion
     */
    handleClick(itemId) {
        if (ArcBoardState.activeTool !== ToolTypes.CONNECT) return false;

        const arc = ArcBoardViewModel.getCurrentArc();
        if (!arc) return false;

        if (!ArcBoardState.connectionSource) {
            // Premier clic: sélectionner la source
            ArcBoardState.connectionSource = itemId;
            this._updateSourceUI(itemId);
            return true;
        } else {
            // Deuxième clic: créer la connexion ou annuler
            if (ArcBoardState.connectionSource === itemId) {
                // Clic sur le même élément = annuler
                this.cancel();
                return true;
            }

            // Créer la connexion
            const sides = this._calculateBestSides(ArcBoardState.connectionSource, itemId);
            ConnectionRepository.create(arc.id, ArcBoardState.connectionSource, itemId, sides);

            // Reset pour nouvelle connexion
            ArcBoardState.connectionSource = null;
            this._updateUI();
            ArcBoardView.renderConnections(arc);

            return true;
        }
    },

    /**
     * Trouve un élément par son ID (item ou carte)
     */
    _findElement(id) {
        return document.getElementById(`item-${id}`)
            || document.querySelector(`[data-card-id="${id}"]`);
    },

    /**
     * Calcule les meilleurs côtés pour une connexion
     */
    _calculateBestSides(fromId, toId) {
        const fromEl = this._findElement(fromId);
        const toEl = this._findElement(toId);

        if (!fromEl || !toEl) return { fromSide: 'right', toSide: 'left' };

        const fromRect = fromEl.getBoundingClientRect();
        const toRect = toEl.getBoundingClientRect();

        const fromCenterX = fromRect.left + fromRect.width / 2;
        const fromCenterY = fromRect.top + fromRect.height / 2;
        const toCenterX = toRect.left + toRect.width / 2;
        const toCenterY = toRect.top + toRect.height / 2;

        const dx = toCenterX - fromCenterX;
        const dy = toCenterY - fromCenterY;

        if (Math.abs(dx) > Math.abs(dy)) {
            return dx > 0
                ? { fromSide: 'right', toSide: 'left' }
                : { fromSide: 'left', toSide: 'right' };
        } else {
            return dy > 0
                ? { fromSide: 'bottom', toSide: 'top' }
                : { fromSide: 'top', toSide: 'bottom' };
        }
    },

    _updateUI() {
        const hint = document.getElementById('connectionModeHint');
        if (hint) {
            hint.style.display = 'flex';
            document.getElementById('connectionHintText').textContent = 'Cliquez sur l\'élément source';
        }

        // Inclure aussi les cartes comme éléments connectables
        document.querySelectorAll('.arc-column, .arc-floating-item, .arc-card').forEach(el => {
            el.classList.add('connectable');
            el.classList.remove('connection-source', 'connection-target');
        });

        if (typeof lucide !== 'undefined') lucide.createIcons();
    },

    _updateSourceUI(sourceId) {
        const sourceEl = this._findElement(sourceId);
        if (sourceEl) {
            sourceEl.classList.add('connection-source');
            sourceEl.classList.remove('connectable');
        }

        document.getElementById('connectionHintText').textContent = 'Cliquez sur l\'élément cible';

        // Inclure aussi les cartes comme cibles potentielles
        document.querySelectorAll('.arc-column, .arc-floating-item, .arc-card').forEach(el => {
            const elId = el.id?.replace('item-', '') || el.dataset.cardId;
            if (elId !== sourceId) {
                el.classList.add('connection-target');
            }
        });
    },

    _cleanupUI() {
        const hint = document.getElementById('connectionModeHint');
        if (hint) hint.style.display = 'none';

        document.querySelectorAll('.arc-column, .arc-floating-item, .arc-card').forEach(el => {
            el.classList.remove('connectable', 'connection-source', 'connection-target');
        });
    }
};

/**
 * Service de gestion du Pan (déplacement du canvas)
 */
const PanService = {
    _state: {
        active: false,
        startX: 0,
        startY: 0
    },

    start(event) {
        this._state = {
            active: true,
            startX: event.clientX - ArcBoardState.panX,
            startY: event.clientY - ArcBoardState.panY
        };
        document.getElementById('arcBoardCanvas')?.classList.add('panning');
    },

    move(event) {
        if (!this._state.active) return;

        ArcBoardState.panX = event.clientX - this._state.startX;
        ArcBoardState.panY = event.clientY - this._state.startY;
        ArcBoardViewModel._updateCanvasTransform();
    },

    end() {
        this._state.active = false;
        document.getElementById('arcBoardCanvas')?.classList.remove('panning');
    },

    isActive() {
        return this._state.active;
    }
};

/**
 * Service de redimensionnement des colonnes
 */
const ResizeService = {
    _state: {
        active: false,
        columnId: null,
        arcId: null,
        startX: 0,
        startWidth: 0
    },

    start(event, columnId, arcId = null) {
        event.stopPropagation();
        event.preventDefault();

        const el = document.getElementById(`item-${columnId}`);
        if (!el) return;

        this._state = {
            active: true,
            columnId: columnId,
            arcId: arcId,
            startX: event.clientX,
            startWidth: parseInt(el.style.width) || ArcBoardConfig.column.defaultWidth
        };
    },

    move(event) {
        if (!this._state.active) return;

        const dx = (event.clientX - this._state.startX) / ArcBoardState.zoom;
        let newWidth = this._state.startWidth + dx;

        newWidth = Math.max(ArcBoardConfig.column.minWidth, Math.min(ArcBoardConfig.column.maxWidth, newWidth));

        const el = document.getElementById(`item-${this._state.columnId}`);
        if (el) {
            el.style.width = `${newWidth}px`;
        }
    },

    end() {
        if (!this._state.active) return;

        const el = document.getElementById(`item-${this._state.columnId}`);
        if (el) {
            // Utiliser l'arcId stocké ou l'arc courant
            const targetArcId = this._state.arcId || ArcBoardState.currentArcId;
            if (targetArcId) {
                BoardItemRepository.update(targetArcId, this._state.columnId, {
                    width: parseInt(el.style.width) || ArcBoardConfig.column.defaultWidth
                });
            }
        }

        this._state = { active: false, columnId: null, arcId: null, startX: 0, startWidth: 0 };
    },

    isActive() {
        return this._state.active;
    }
};

/**
 * Service de redimensionnement vertical des arcs en mode Compare
 */
const CompareResizeService = {
    _state: {
        active: false,
        arcId: null,
        startY: 0,
        startHeight: 0,
        minHeight: 100  // Hauteur minimale d'un arc
    },

    /**
     * Démarre le redimensionnement d'un arc
     */
    start(event, arcId) {
        event.stopPropagation();
        event.preventDefault();

        const section = document.querySelector(`.arc-compare-section[data-arc-id="${arcId}"]`);
        if (!section) return;

        this._state = {
            active: true,
            arcId: arcId,
            startY: event.clientY,
            startHeight: section.offsetHeight,
            minHeight: 100
        };

        // Ajouter les listeners globaux
        document.addEventListener('mousemove', this._onMouseMove);
        document.addEventListener('mouseup', this._onMouseUp);
        document.body.style.cursor = 'ns-resize';
        document.body.style.userSelect = 'none';
    },

    /**
     * Handler de mouvement (bound)
     */
    _onMouseMove: function(event) {
        CompareResizeService.move(event);
    },

    /**
     * Handler de fin (bound)
     */
    _onMouseUp: function(event) {
        CompareResizeService.end(event);
    },

    /**
     * Déplacement pendant le redimensionnement
     */
    move(event) {
        if (!this._state.active) return;

        const dy = event.clientY - this._state.startY;
        let newHeight = this._state.startHeight + dy;

        // Appliquer la hauteur minimale
        newHeight = Math.max(this._state.minHeight, newHeight);

        // Mettre à jour visuellement la section
        const section = document.querySelector(`.arc-compare-section[data-arc-id="${this._state.arcId}"]`);
        if (section) {
            section.style.height = `${newHeight}px`;

            // Marquer si on est à la hauteur minimale
            if (newHeight <= this._state.minHeight) {
                section.classList.add('min-height');
            } else {
                section.classList.remove('min-height');
            }
        }

        // Recalculer les positions des arcs suivants
        this._updateFollowingArcs();
    },

    /**
     * Met à jour les positions des arcs qui suivent l'arc redimensionné
     */
    _updateFollowingArcs() {
        const sections = document.querySelectorAll('.arc-compare-section');
        let currentY = 0;

        sections.forEach(section => {
            section.style.top = `${currentY}px`;
            currentY += section.offsetHeight;
        });
    },

    /**
     * Fin du redimensionnement
     */
    end(event) {
        if (!this._state.active) return;

        // Sauvegarder la hauteur dans l'état
        const section = document.querySelector(`.arc-compare-section[data-arc-id="${this._state.arcId}"]`);
        if (section) {
            const newHeight = section.offsetHeight;
            ArcBoardState.compareArcHeights[this._state.arcId] = newHeight;
        }

        // Nettoyer
        document.removeEventListener('mousemove', this._onMouseMove);
        document.removeEventListener('mouseup', this._onMouseUp);
        document.body.style.cursor = '';
        document.body.style.userSelect = '';

        this._state = {
            active: false,
            arcId: null,
            startY: 0,
            startHeight: 0,
            minHeight: 100
        };

        // Re-render les connexions
        ArcBoardView._renderCompareConnections();
    },

    isActive() {
        return this._state.active;
    }
};

/**
 * Service de déplacement des items (mousedown/mousemove)
 */
const ItemMoveService = {
    _state: {
        active: false,
        itemId: null,
        arcId: null,
        startX: 0,
        startY: 0,
        itemStartX: 0,
        itemStartY: 0
    },

    start(event, itemId, arcId = null) {
        const el = document.getElementById(`item-${itemId}`);
        if (!el) return;

        this._state = {
            active: true,
            itemId: itemId,
            arcId: arcId,
            startX: event.clientX,
            startY: event.clientY,
            itemStartX: parseInt(el.style.left) || 0,
            itemStartY: parseInt(el.style.top) || 0
        };

        el.classList.add('dragging');
    },

    move(event) {
        if (!this._state.active) return;

        const dx = (event.clientX - this._state.startX) / ArcBoardState.zoom;
        const dy = (event.clientY - this._state.startY) / ArcBoardState.zoom;

        let newX = this._state.itemStartX + dx;
        let newY = this._state.itemStartY + dy;

        // Snap to grid
        if (ArcBoardConfig.grid.snapEnabled) {
            const gridSize = ArcBoardConfig.grid.size;
            newX = Math.round(newX / gridSize) * gridSize;
            newY = Math.round(newY / gridSize) * gridSize;
        }

        const el = document.getElementById(`item-${this._state.itemId}`);
        if (el) {
            el.style.left = `${newX}px`;
            el.style.top = `${newY}px`;
        }

        // Mettre à jour les connexions en temps réel
        if (ArcBoardState.multiArcMode === MultiArcModes.COMPARE) {
            ArcBoardView._renderCompareConnections();
        } else {
            const arc = ArcBoardViewModel.getCurrentArc();
            if (arc) {
                ArcBoardView.renderConnections(arc);
            }
        }
    },

    end() {
        if (!this._state.active) return;

        const el = document.getElementById(`item-${this._state.itemId}`);
        if (el) {
            el.classList.remove('dragging');

            // Utiliser l'arcId stocké ou l'arc courant
            const targetArcId = this._state.arcId || ArcBoardState.currentArcId;
            if (targetArcId) {
                BoardItemRepository.updatePosition(
                    targetArcId,
                    this._state.itemId,
                    parseInt(el.style.left) || 0,
                    parseInt(el.style.top) || 0
                );
            }
        }

        this._state = { active: false, itemId: null, arcId: null, startX: 0, startY: 0, itemStartX: 0, itemStartY: 0 };
    },

    isActive() {
        return this._state.active;
    }
};

// ========== js-refactor/arc-board/arc-board.views.js ==========
// ============================================
// ARC BOARD - Views (HTML Rendering)
// ============================================

/**
 * Vue principale - Génère le HTML
 */
const ArcBoardView = {
    // ==========================================
    // SIDEBAR
    // ==========================================

    /**
     * Rendu de la sidebar avec la liste des arcs
     */
    renderSidebar() {
        const list = document.getElementById('arcsList');
        if (!list) return;

        ArcRepository.init();
        const arcs = ArcRepository.getAll();

        let html = '';

        // Formulaire de création d'arc
        if (ArcBoardState.showingArcForm) {
            html += this._renderArcForm();
        }

        // Formulaire de création de catégorie
        if (ArcBoardState.showingCategoryForm) {
            html += this._renderCategoryForm();
        }

        if (arcs.length === 0 && !ArcBoardState.showingArcForm && !ArcBoardState.showingCategoryForm) {
            html += `
                <div class="sidebar-empty">
                    <div class="sidebar-empty-icon"><i data-lucide="layout-dashboard"></i></div>
                    <p>Aucun arc narratif</p>
                </div>
            `;
        } else if (arcs.length > 0) {
            html += this._renderArcsByCategory(arcs);
        }

        // Bouton nouvelle catégorie
        if (!ArcBoardState.showingCategoryForm && !ArcBoardState.showingArcForm) {
            html += `
                <div class="sidebar-tree-add" onclick="ArcBoardViewModel.showCategoryForm()">
                    <i data-lucide="folder-plus"></i>
                    <span>Nouvelle catégorie</span>
                </div>
            `;
        }

        list.innerHTML = html;
        if (typeof lucide !== 'undefined') lucide.createIcons();

        // Focus sur le formulaire
        if (ArcBoardState.showingArcForm) {
            document.getElementById('inlineArcTitle')?.focus();
        } else if (ArcBoardState.showingCategoryForm) {
            document.getElementById('inlineCategoryName')?.focus();
        }
    },

    _renderArcsByCategory(arcs) {
        const allCategories = ArcRepository.getAllCategories();
        const arcsByCategory = {};
        const uncategorized = [];

        arcs.forEach(arc => {
            const cat = arc.category || 'uncategorized';
            if (cat === 'uncategorized' || !allCategories[cat]) {
                uncategorized.push(arc);
            } else {
                if (!arcsByCategory[cat]) arcsByCategory[cat] = [];
                arcsByCategory[cat].push(arc);
            }
        });

        let html = '';

        // Non catégorisés en premier
        if (uncategorized.length > 0) {
            html += this._renderCategory('uncategorized', {
                label: 'Non catégorisé',
                icon: 'folder',
                color: 'var(--text-muted)'
            }, uncategorized);
        }

        // Autres catégories
        Object.entries(allCategories).forEach(([key, data]) => {
            const categoryArcs = arcsByCategory[key] || [];
            if (categoryArcs.length > 0) {
                html += this._renderCategory(key, data, categoryArcs);
            }
        });

        return html;
    },

    _renderCategory(key, data, arcs) {
        const isExpanded = !ArcRepository.isCategoryCollapsed(key);
        return `
            <div class="sidebar-tree-category" data-category="${key}">
                <div class="sidebar-tree-header" onclick="ArcRepository.toggleCategoryCollapse('${key}'); ArcBoardView.renderSidebar();">
                    <span class="sidebar-tree-toggle">
                        <i data-lucide="${isExpanded ? 'chevron-down' : 'chevron-right'}"></i>
                    </span>
                    <span class="sidebar-tree-icon" style="color: ${data.color}">
                        <i data-lucide="${data.icon}"></i>
                    </span>
                    <span class="sidebar-tree-label">${data.label}</span>
                    <span class="sidebar-tree-count">${arcs.length}</span>
                </div>
                <div class="sidebar-tree-children ${isExpanded ? '' : 'collapsed'}">
                    ${arcs.map(arc => this._renderArcItem(arc)).join('')}
                </div>
            </div>
        `;
    },

    _renderArcItem(arc) {
        const isActive = ArcBoardState.currentArcId === arc.id;
        const allCategories = ArcRepository.getAllCategories();
        const catData = allCategories[arc.category] || { color: '#999' };

        return `
            <div class="sidebar-tree-item ${isActive ? 'active' : ''}"
                 onclick="ArcBoardViewModel.openArc('${arc.id}')"
                 data-arc-id="${arc.id}">
                <span class="sidebar-tree-item-dot" style="background: ${arc.color || catData.color}"></span>
                <span class="sidebar-tree-item-title">${arc.title || 'Sans titre'}</span>
                <button class="sidebar-tree-item-menu" onclick="event.stopPropagation(); ArcBoardView.showArcContextMenu(event, '${arc.id}')">
                    <i data-lucide="more-horizontal"></i>
                </button>
            </div>
        `;
    },

    _renderArcForm() {
        const allCategories = ArcRepository.getAllCategories();
        const editingArc = ArcBoardState.editingArcId
            ? ArcRepository.getById(ArcBoardState.editingArcId)
            : null;

        const isEditing = !!editingArc;
        const formTitle = isEditing ? "Modifier l'arc" : 'Nouvel arc narratif';
        const buttonText = isEditing ? 'Enregistrer' : 'Créer';

        const arcTitle = editingArc?.title || '';
        const arcCategory = editingArc?.category || 'intrigue';
        const arcColor = editingArc?.color || '#e74c3c';

        return `
            <div class="sidebar-inline-form" id="arc-form-panel">
                <div class="sidebar-inline-form-header">
                    <i data-lucide="${isEditing ? 'settings' : 'sparkles'}"></i>
                    <span>${formTitle}</span>
                    <button class="sidebar-inline-form-close" onclick="ArcBoardViewModel.hideArcForm()">
                        <i data-lucide="x"></i>
                    </button>
                </div>
                <div class="sidebar-inline-form-body">
                    <input type="hidden" id="inlineArcId" value="${ArcBoardState.editingArcId || ''}">
                    <div class="sidebar-inline-form-group">
                        <label>Titre *</label>
                        <input type="text" id="inlineArcTitle" class="sidebar-inline-input"
                               placeholder="Ex: La quête de rédemption"
                               value="${arcTitle.replace(/"/g, '&quot;')}"
                               onkeydown="ArcBoardEventHandlers.handleArcFormKeydown(event)">
                    </div>
                    <div class="sidebar-inline-form-group">
                        <label>Catégorie</label>
                        <select id="inlineArcCategory" class="sidebar-inline-select" onchange="ArcBoardEventHandlers.updateArcFormColor()">
                            ${Object.entries(allCategories).map(([key, cat]) =>
            `<option value="${key}" ${key === arcCategory ? 'selected' : ''}>${cat.label}</option>`
        ).join('')}
                        </select>
                    </div>
                    <div class="sidebar-inline-form-group">
                        <label>Couleur</label>
                        <div class="sidebar-inline-color-row">
                            <input type="color" id="inlineArcColor" value="${arcColor}" class="sidebar-inline-color">
                            <span id="inlineArcColorHex" class="sidebar-inline-color-hex">${arcColor}</span>
                        </div>
                    </div>
                    <div class="sidebar-inline-form-actions">
                        <button class="btn-secondary btn-sm" onclick="ArcBoardViewModel.hideArcForm()">Annuler</button>
                        <button class="btn-primary btn-sm" onclick="ArcBoardEventHandlers.confirmArcForm()">
                            <i data-lucide="${isEditing ? 'save' : 'plus'}"></i> ${buttonText}
                        </button>
                    </div>
                </div>
            </div>
        `;
    },

    _renderCategoryForm() {
        return `
            <div class="sidebar-inline-form">
                <div class="sidebar-inline-form-header">
                    <i data-lucide="folder-plus"></i>
                    <span>Nouvelle catégorie</span>
                    <button class="sidebar-inline-form-close" onclick="ArcBoardViewModel.hideCategoryForm()">
                        <i data-lucide="x"></i>
                    </button>
                </div>
                <div class="sidebar-inline-form-body">
                    <div class="sidebar-inline-form-group">
                        <label>Nom *</label>
                        <input type="text" id="inlineCategoryName" class="sidebar-inline-input"
                               placeholder="Ex: Arcs de croissance"
                               onkeydown="ArcBoardEventHandlers.handleCategoryFormKeydown(event)">
                    </div>
                    <div class="sidebar-inline-form-group">
                        <label>Couleur</label>
                        <div class="sidebar-inline-color-row">
                            <input type="color" id="inlineCategoryColor" value="#6c757d" class="sidebar-inline-color">
                        </div>
                    </div>
                    <div class="sidebar-inline-form-actions">
                        <button class="btn-secondary btn-sm" onclick="ArcBoardViewModel.hideCategoryForm()">Annuler</button>
                        <button class="btn-primary btn-sm" onclick="ArcBoardEventHandlers.confirmCategoryForm()">
                            <i data-lucide="plus"></i> Créer
                        </button>
                    </div>
                </div>
            </div>
        `;
    },

    // ==========================================
    // CANVAS
    // ==========================================

    /**
     * Rendu du canvas principal
     */
    renderCanvas(arc) {
        const view = document.getElementById('editorView');
        if (!view) return;

        view.innerHTML = `
            <div class="arc-board-container">
                ${this._renderToolbar()}

                <div class="arc-board-main">
                    ${this._renderMultiArcBar(arc)}

                    <div class="arc-board-body">
                        <!-- Zone Non attribué en sidebar -->
                        <div id="arcUnassignedSidebar"></div>

                        <div class="arc-board-canvas-wrapper">
                    <div class="arc-board-canvas" id="arcBoardCanvas"
                         onmousedown="ArcBoardEventHandlers.onCanvasMouseDown(event)"
                         onmousemove="ArcBoardEventHandlers.onCanvasMouseMove(event)"
                         onmouseup="ArcBoardEventHandlers.onCanvasMouseUp(event)"
                         onwheel="ArcBoardEventHandlers.onCanvasWheel(event)"
                         oncontextmenu="ArcBoardEventHandlers.onCanvasContextMenu(event)"
                         ondrop="DragDropService.handleCanvasDrop(event)"
                         ondragover="DragDropService.handleCanvasDragOver(event)"
                         ondragleave="DragDropService.handleCanvasDragLeave(event)">

                        <div class="arc-board-content" id="arcBoardContent"
                             style="transform: scale(${ArcBoardState.zoom}) translate(${ArcBoardState.panX}px, ${ArcBoardState.panY}px)">

                            <div class="arc-connections-layer" id="arcConnectionsLayer">
                                <svg id="arcConnectionsSvg">
                                    <defs>
                                        <marker id="arrowhead" markerWidth="10" markerHeight="7"
                                                refX="9" refY="3.5" orient="auto">
                                            <polygon points="0 0, 10 3.5, 0 7" class="arc-connection-arrow"/>
                                        </marker>
                                        <marker id="arrowhead-interarc" markerWidth="10" markerHeight="7"
                                                refX="9" refY="3.5" orient="auto">
                                            <polygon points="0 0, 10 3.5, 0 7" fill="var(--primary-color)"/>
                                        </marker>
                                    </defs>
                                </svg>
                            </div>

                            <div id="arcBoardItems"></div>
                        </div>

                        <div class="arc-connection-mode-hint" id="connectionModeHint" style="display:none">
                            <i data-lucide="git-branch"></i>
                            <span id="connectionHintText">Cliquez sur l'élément source</span>
                            <button onclick="ConnectionService.cancel()"><i data-lucide="x"></i> Annuler</button>
                        </div>

                        ${arc.board.items.length === 0 ? this._renderEmptyState() : ''}
                    </div>

                    ${this._renderZoomControls()}
                        </div>

                        ${this._renderContextPanel(arc)}
                    </div>
                </div>
            </div>

            <input type="file" id="arcFileInput" style="display:none" accept="image/*"
                   onchange="ArcBoardEventHandlers.onFileUpload(event)">
        `;

        if (typeof lucide !== 'undefined') lucide.createIcons();
    },

    _renderToolbar() {
        // Génère un bouton draggable pour les items de création
        const draggableBtn = (type, tooltip, icon) => `
            <button class="arc-toolbar-btn arc-toolbar-draggable"
                    data-tooltip="${tooltip}"
                    data-item-type="${type}"
                    draggable="true"
                    onclick="ArcBoardViewModel.addItem('${type}')"
                    ondragstart="DragDropService.startToolbarDrag(event, '${type}')"
                    ondragend="DragDropService.endDrag(event)">
                <i data-lucide="${icon}"></i>
            </button>
        `;

        return `
            <div class="arc-board-toolbar">
                <button class="arc-toolbar-btn ${ArcBoardState.activeTool === 'select' ? 'active' : ''}"
                        data-tool="select" data-tooltip="Sélection" onclick="ArcBoardViewModel.setTool('select')">
                    <i data-lucide="mouse-pointer-2"></i>
                </button>
                <button class="arc-toolbar-btn ${ArcBoardState.activeTool === 'pan' ? 'active' : ''}"
                        data-tool="pan" data-tooltip="Déplacer" onclick="ArcBoardViewModel.setTool('pan')">
                    <i data-lucide="hand"></i>
                </button>

                <div class="arc-toolbar-separator"></div>

                ${draggableBtn('note', 'Note (glisser-déposer)', 'file-text')}
                ${draggableBtn('column', 'Colonne (glisser-déposer)', 'columns-3')}
                ${draggableBtn('link', 'Lien (glisser-déposer)', 'link')}
                ${draggableBtn('todo', 'Tâches (glisser-déposer)', 'check-square')}
                ${draggableBtn('comment', 'Commentaire (glisser-déposer)', 'message-square')}
                ${draggableBtn('table', 'Tableau (glisser-déposer)', 'table')}

                <div class="arc-toolbar-separator"></div>

                ${draggableBtn('image', 'Image (glisser-déposer)', 'image')}
                <button class="arc-toolbar-btn" data-tooltip="Upload" onclick="document.getElementById('arcFileInput').click()">
                    <i data-lucide="upload"></i>
                </button>

                <div class="arc-toolbar-separator"></div>

                <button class="arc-toolbar-btn ${ArcBoardState.activeTool === 'connect' ? 'active' : ''}"
                        data-tool="connect" data-tooltip="Connexion" onclick="ConnectionService.toggle()">
                    <i data-lucide="git-branch"></i>
                </button>

                <div style="flex:1"></div>

                <button class="arc-toolbar-btn" data-tooltip="Supprimer" onclick="ArcBoardViewModel.deleteSelected()">
                    <i data-lucide="trash-2"></i>
                </button>
            </div>
        `;
    },

    _renderZoomControls() {
        return `
            <div class="arc-zoom-controls">
                <button class="arc-zoom-btn" onclick="ArcBoardViewModel.zoom(-1)" title="Zoom arrière">
                    <i data-lucide="zoom-out"></i>
                </button>
                <span class="arc-zoom-level" id="arcZoomLevel">${Math.round(ArcBoardState.zoom * 100)}%</span>
                <button class="arc-zoom-btn" onclick="ArcBoardViewModel.zoom(1)" title="Zoom avant">
                    <i data-lucide="zoom-in"></i>
                </button>
                <button class="arc-zoom-btn" onclick="ArcBoardViewModel.resetView()" title="Réinitialiser">
                    <i data-lucide="maximize-2"></i>
                </button>
            </div>
        `;
    },

    _renderEmptyState() {
        return `
            <div class="arc-board-empty">
                <div class="arc-board-empty-icon"><i data-lucide="layout-dashboard"></i></div>
                <div class="arc-board-empty-title">Board vide</div>
                <div class="arc-board-empty-text">
                    Utilisez la barre d'outils à gauche pour ajouter<br>
                    des colonnes, notes, images et plus encore.
                </div>
            </div>
        `;
    },

    // ==========================================
    // MULTI-ARCS
    // ==========================================

    /**
     * Rendu de la barre multi-arcs (version compacte sur une ligne)
     */
    _renderMultiArcBar(arc) {
        const mode = ArcBoardState.multiArcMode;
        const allArcs = ArcRepository.getAll();
        const availableArcs = ArcBoardViewModel.getAvailableArcsForAdd();
        const interArcConnections = InterArcConnectionRepository.getAll();

        // Tags des arcs en comparaison
        const compareTagsHtml = ArcBoardState.compareArcs.map(arcId => {
            const compareArc = ArcRepository.getById(arcId);
            if (!compareArc) return '';
            const isMain = arcId === arc.id;
            return `<span class="arc-compare-tag ${isMain ? 'main' : ''}" style="--tag-color: ${compareArc.color}">
                <span class="arc-compare-tag-dot" style="background:${compareArc.color}"></span>
                ${compareArc.title}
                ${!isMain && ArcBoardState.compareArcs.length > 1 ? `<button onclick="ArcBoardViewModel.removeCompareArc('${arcId}')"><i data-lucide="x"></i></button>` : ''}
            </span>`;
        }).join('');

        // Liste des connexions inter-arcs
        const interArcHtml = interArcConnections.length > 0 ? `
            <div class="arc-interarc-tags">
                ${interArcConnections.map(conn => {
                    const fromArc = ArcRepository.getById(conn.fromArcId);
                    const toArc = ArcRepository.getById(conn.toArcId);
                    return `<span class="arc-interarc-tag" title="Lien inter-arc: ${fromArc?.title || '?'} vers ${toArc?.title || '?'}">
                        <span class="arc-interarc-tag-dot" style="background:${fromArc?.color || '#999'}"></span>
                        <span class="arc-interarc-tag-name">${fromArc?.title || '?'}</span>
                        <i data-lucide="arrow-right"></i>
                        <span class="arc-interarc-tag-dot" style="background:${toArc?.color || '#999'}"></span>
                        <span class="arc-interarc-tag-name">${toArc?.title || '?'}</span>
                        <button onclick="InterArcConnectionRepository.delete('${conn.id}'); ArcBoardViewModel.render()"><i data-lucide="x"></i></button>
                    </span>`;
                }).join('')}
            </div>
        ` : '';

        return `
            <div class="arc-multi-bar">
                <div class="arc-multi-left">
                    <select class="arc-multi-select" onchange="ArcBoardViewModel.openArc(this.value)">
                        ${allArcs.map(a => `<option value="${a.id}" ${a.id === arc.id ? 'selected' : ''}>${a.title}</option>`).join('')}
                    </select>
                </div>

                <div class="arc-multi-modes">
                    <button class="${mode === MultiArcModes.SOLO ? 'active' : ''}" onclick="ArcBoardViewModel.setMultiArcMode('solo')">Solo</button>
                    <button class="${mode === MultiArcModes.COMPARE ? 'active' : ''}" onclick="ArcBoardViewModel.setMultiArcMode('compare')">Comparer</button>
                </div>

                ${mode === MultiArcModes.COMPARE ? `
                    <div class="arc-compare-controls">
                        ${compareTagsHtml}
                        ${availableArcs.length > 0 ? `
                            <select class="arc-compare-add" onchange="if(this.value) { ArcBoardViewModel.addCompareArc(this.value); this.value=''; }">
                                <option value="">+ Arc...</option>
                                ${availableArcs.map(a => `<option value="${a.id}">${a.title}</option>`).join('')}
                            </select>
                        ` : ''}
                        <button class="arc-compare-link-btn" onclick="InterArcConnectionService.startConnection()" title="Créer un lien entre arcs">
                            <i data-lucide="link"></i>
                        </button>
                        ${interArcHtml}
                    </div>
                ` : ''}
            </div>
        `;
    },

    /**
     * Helper pour calculer le point de connexion
     */
    _getConnectionPoint(item, side) {
        const width = item.width || 280;
        const height = 200; // Estimation

        switch (side) {
            case 'top': return { x: item.x + width / 2, y: item.y };
            case 'bottom': return { x: item.x + width / 2, y: item.y + height };
            case 'left': return { x: item.x, y: item.y + height / 2 };
            case 'right': return { x: item.x + width, y: item.y + height / 2 };
            default: return { x: item.x + width, y: item.y + height / 2 };
        }
    },

    /**
     * Helper pour créer le path SVG d'une connexion
     */
    _createConnectionPath(from, to) {
        const dx = to.x - from.x;
        const dy = to.y - from.y;
        const cx = Math.abs(dx) / 2;

        return `M ${from.x} ${from.y} C ${from.x + cx} ${from.y}, ${to.x - cx} ${to.y}, ${to.x} ${to.y}`;
    },

    _renderContextPanel(arc) {
        return `
            <div class="arc-board-context-panel ${ArcBoardState.contextPanelOpen ? '' : 'collapsed'}" id="arcContextPanel">
                <div class="arc-context-header">
                    <div class="arc-context-title">
                        <i data-lucide="sliders-horizontal"></i>
                        <span>Propriétés</span>
                    </div>
                    <button class="arc-context-close" onclick="ArcBoardViewModel.toggleContextPanel()">
                        <i data-lucide="x"></i>
                    </button>
                </div>
                <div class="arc-context-body" id="arcContextBody">
                    ${this._renderContextPanelDefault(arc)}
                </div>
            </div>
        `;
    },

    _renderContextPanelDefault(arc) {
        const allCategories = ArcRepository.getAllCategories();
        const catData = allCategories[arc.category] || { label: 'Non catégorisé', color: '#999' };

        return `
            <div class="arc-context-section">
                <div class="arc-context-section-title">Arc actuel</div>
                <div style="margin-bottom:12px">
                    <input type="text" class="form-input" value="${arc.title}"
                           onchange="ArcBoardEventHandlers.updateArcTitle(this.value)"
                           style="font-weight:600">
                </div>
                <div style="display:flex;align-items:center;gap:8px;margin-bottom:8px">
                    <span style="width:12px;height:12px;border-radius:50%;background:${arc.color}"></span>
                    <span style="font-size:13px;color:var(--text-secondary)">${catData.label}</span>
                </div>
            </div>

            <div class="arc-context-section">
                <div class="arc-context-section-title">Ajouter au board</div>
                <div class="arc-context-tools">
                    <div class="arc-context-tool" onclick="ArcBoardViewModel.addItem('column')">
                        <i data-lucide="columns-3"></i><span>Colonne</span>
                    </div>
                    <div class="arc-context-tool" onclick="ArcBoardViewModel.addItem('note')">
                        <i data-lucide="file-text"></i><span>Note</span>
                    </div>
                    <div class="arc-context-tool" onclick="ArcBoardViewModel.addItem('image')">
                        <i data-lucide="image"></i><span>Image</span>
                    </div>
                    <div class="arc-context-tool" onclick="ArcBoardViewModel.addItem('todo')">
                        <i data-lucide="check-square"></i><span>Tâches</span>
                    </div>
                </div>
            </div>

            <div class="arc-context-section">
                <div class="arc-context-section-title">Statistiques</div>
                <div style="font-size:13px;color:var(--text-secondary)">
                    <div style="margin-bottom:4px">${arc.board.items.length} élément${arc.board.items.length > 1 ? 's' : ''}</div>
                    <div>${arc.board.connections?.length || 0} connexion${(arc.board.connections?.length || 0) > 1 ? 's' : ''}</div>
                </div>
            </div>
        `;
    },

    renderContextPanelDefault(arc) {
        const body = document.getElementById('arcContextBody');
        if (body) {
            body.innerHTML = this._renderContextPanelDefault(arc);
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }
    },

    renderContextPanel(item) {
        const body = document.getElementById('arcContextBody');
        if (!body) return;

        body.innerHTML = this._getContextPanelForItem(item);
        if (typeof lucide !== 'undefined') lucide.createIcons();
    },

    _getContextPanelForItem(item) {
        switch (item.type) {
            case 'column':
                return `
                    <div class="arc-context-section">
                        <div class="arc-context-section-title">Colonne</div>
                        <div class="form-group">
                            <label style="font-size:12px">Titre</label>
                            <input type="text" class="form-input" value="${item.title || ''}"
                                   onchange="ArcBoardViewModel.updateItem('${item.id}', { title: this.value })">
                        </div>
                        <div class="form-group">
                            <label style="font-size:12px">Largeur (px)</label>
                            <input type="number" class="form-input" value="${item.width || ArcBoardConfig.column.defaultWidth}"
                                   min="${ArcBoardConfig.column.minWidth}" max="${ArcBoardConfig.column.maxWidth}"
                                   onchange="ArcBoardViewModel.updateItem('${item.id}', { width: parseInt(this.value) }); ArcBoardViewModel.renderItems();">
                        </div>
                    </div>
                    <div class="arc-context-section">
                        <button class="arc-context-delete" onclick="ArcBoardViewModel.deleteSelected()">
                            <i data-lucide="trash-2"></i> Supprimer
                        </button>
                    </div>
                `;
            default:
                return `
                    <div class="arc-context-section">
                        <div class="arc-context-section-title">Élément</div>
                        <p style="font-size:13px;color:var(--text-secondary)">Type: ${item.type}</p>
                    </div>
                    <div class="arc-context-section">
                        <button class="arc-context-delete" onclick="ArcBoardViewModel.deleteSelected()">
                            <i data-lucide="trash-2"></i> Supprimer
                        </button>
                    </div>
                `;
        }
    },

    // ==========================================
    // ITEMS
    // ==========================================

    /**
     * Rendu de tous les items du board
     */
    renderItems(arc) {
        const itemsContainer = document.getElementById('arcBoardItems');
        const sidebarContainer = document.getElementById('arcUnassignedSidebar');
        if (!itemsContainer || !arc.board) return;

        // MODE COMPARE : afficher plusieurs arcs empilés verticalement
        if (ArcBoardState.multiArcMode === MultiArcModes.COMPARE && ArcBoardState.compareArcs.length > 0) {
            this._renderCompareItems(itemsContainer, sidebarContainer);
            return;
        }

        // MODE SOLO : affichage normal
        this._renderSoloItems(arc, itemsContainer, sidebarContainer);
    },

    /**
     * Rendu mode Solo (un seul arc)
     */
    _renderSoloItems(arc, itemsContainer, sidebarContainer) {
        // Construire la liste des scènes non attribuées depuis scenePresence
        const unassignedScenes = this._getUnassignedScenes(arc);

        // Filtrer les items réguliers
        const regularItems = arc.board.items.filter(item => item.type !== 'scene');

        // Rendre la zone "Non attribué" dans la sidebar
        if (sidebarContainer) {
            sidebarContainer.innerHTML = this._renderUnassignedZone(unassignedScenes);
        }

        // Rendre les items normaux dans le canvas
        itemsContainer.innerHTML = regularItems.map(item => this._renderItem(item)).join('');

        if (typeof lucide !== 'undefined') lucide.createIcons();

        // Masquer l'empty state si items présents
        const emptyState = document.querySelector('.arc-board-empty');
        if (emptyState) {
            emptyState.style.display = arc.board.items.length > 0 ? 'none' : 'block';
        }
    },

    /**
     * Rendu mode Compare (plusieurs arcs empilés)
     */
    _renderCompareItems(itemsContainer, sidebarContainer) {
        const HEADER_HEIGHT = 40; // Hauteur de l'en-tête d'arc
        const MIN_ARC_HEIGHT = 100; // Hauteur minimale d'un arc
        let html = '';
        let currentY = 0;

        // Stocker les offsets par arc pour le rendu des connexions
        this._compareArcOffsets = {};

        // Pour chaque arc à comparer
        ArcBoardState.compareArcs.forEach((arcId, index) => {
            const compareArc = ArcRepository.getById(arcId);
            if (!compareArc) return;

            // Utiliser la hauteur personnalisée ou calculer automatiquement
            const contentHeight = this._getArcContentHeight(compareArc);
            const storedHeight = ArcBoardState.compareArcHeights[arcId];
            const sectionHeight = storedHeight !== undefined
                ? Math.max(MIN_ARC_HEIGHT, storedHeight)
                : Math.max(MIN_ARC_HEIGHT, contentHeight + HEADER_HEIGHT);

            // Stocker l'offset pour cet arc
            this._compareArcOffsets[arcId] = { x: 0, y: currentY + HEADER_HEIGHT };

            // Section complète de l'arc (conteneur redimensionnable)
            // Récupérer l'opacité sauvegardée ou 100% par défaut
            const savedOpacity = ArcBoardState.compareArcOpacities?.[arcId] ?? 100;
            html += `
                <div class="arc-compare-section" data-arc-id="${arcId}"
                     style="top:${currentY}px; height:${sectionHeight}px; z-index:${100 - index}; --arc-color:${compareArc.color}; --arc-opacity:${savedOpacity / 100}">
                    <div class="arc-compare-header" style="--arc-color:${compareArc.color}">
                        <span class="arc-compare-header-dot" style="background:${compareArc.color}"></span>
                        <span class="arc-compare-header-title">${compareArc.title}</span>
                        <div class="arc-compare-opacity-control">
                            <i data-lucide="eye" class="arc-compare-opacity-icon"></i>
                            <input type="range" class="arc-compare-opacity-slider"
                                   min="0" max="100" value="${savedOpacity}"
                                   oninput="ArcBoardViewModel.setArcOpacity('${arcId}', this.value)"
                                   title="Transparence (${savedOpacity}%)">
                            <span class="arc-compare-opacity-value">${savedOpacity}%</span>
                        </div>
                        <span class="arc-compare-header-count">${compareArc.board.items.filter(i => i.type === 'column').length} colonnes</span>
                    </div>
                    <div class="arc-compare-content" style="position:relative; top:${HEADER_HEIGHT}px; height:calc(100% - ${HEADER_HEIGHT}px);">
            `;

            // Items de cet arc - offset Y est juste pour le header, pas pour la position globale
            // car les items sont maintenant à l'intérieur de arc-compare-content
            compareArc.board.items.filter(item => item.type !== 'scene').forEach(item => {
                html += this._renderItem(item, arcId, 0, 0);
            });

            html += `
                    </div>
            `;

            // Poignée de redimensionnement en bas de la section
            html += `
                    <div class="arc-compare-resize-handle"
                         onmousedown="CompareResizeService.start(event, '${arcId}')"
                         title="Glisser pour redimensionner"></div>
                </div>
            `;

            currentY += sectionHeight;
        });

        itemsContainer.innerHTML = html;

        // Sidebar : scènes non attribuées du premier arc
        if (sidebarContainer && ArcBoardState.compareArcs.length > 0) {
            const mainArc = ArcRepository.getById(ArcBoardState.compareArcs[0]);
            if (mainArc) {
                const unassignedScenes = this._getUnassignedScenes(mainArc);
                sidebarContainer.innerHTML = this._renderUnassignedZone(unassignedScenes);
            }
        }

        if (typeof lucide !== 'undefined') lucide.createIcons();

        // Masquer l'empty state
        const emptyState = document.querySelector('.arc-board-empty');
        if (emptyState) emptyState.style.display = 'none';

        // Rendre les connexions après le DOM mis à jour
        requestAnimationFrame(() => {
            this._renderCompareConnections();
        });
    },

    /**
     * Calcule la hauteur du contenu d'un arc (basée sur les éléments réels)
     */
    _getArcContentHeight(arc) {
        let maxBottom = 0;

        arc.board.items.forEach(item => {
            const itemY = item.y || 0;
            let itemHeight = 100; // Hauteur par défaut

            if (item.type === 'column') {
                // Calculer la hauteur réelle de la colonne basée sur les cartes
                const cardCount = (item.cards || []).length;
                const headerHeight = 45;
                const cardHeight = 80; // Hauteur moyenne d'une carte
                const addBtnHeight = 35;
                const padding = 20;
                itemHeight = headerHeight + (cardCount * cardHeight) + addBtnHeight + padding;
                itemHeight = Math.max(itemHeight, 150); // Minimum 150px
            } else if (item.type === 'note' || item.type === 'comment') {
                itemHeight = 80;
            } else if (item.type === 'image') {
                itemHeight = item.height || 150;
            } else if (item.type === 'todo') {
                const todoCount = (item.items || []).length;
                itemHeight = 80 + (todoCount * 30);
            } else if (item.type === 'table') {
                const rows = item.rows || 3;
                itemHeight = 50 + (rows * 35);
            }

            const bottom = itemY + itemHeight;
            if (bottom > maxBottom) maxBottom = bottom;
        });

        return Math.max(maxBottom, 100); // Minimum 100px
    },

    /**
     * Rend les connexions en mode Compare (internes + inter-arcs)
     */
    _renderCompareConnections() {
        const svg = document.getElementById('arcConnectionsSvg');
        const content = document.getElementById('arcBoardContent');
        if (!svg || !content) return;

        const defs = svg.querySelector('defs');
        svg.innerHTML = '';
        if (defs) svg.appendChild(defs);

        const contentRect = content.getBoundingClientRect();

        // Helper pour obtenir la position relative au canvas
        const getRelativePosition = (element, side) => {
            const rect = element.getBoundingClientRect();
            const x = (rect.left - contentRect.left) / ArcBoardState.zoom;
            const y = (rect.top - contentRect.top) / ArcBoardState.zoom;
            const w = rect.width / ArcBoardState.zoom;
            const h = rect.height / ArcBoardState.zoom;

            switch (side) {
                case 'top': return { x: x + w / 2, y: y };
                case 'bottom': return { x: x + w / 2, y: y + h };
                case 'left': return { x: x, y: y + h / 2 };
                case 'right': return { x: x + w, y: y + h / 2 };
                default: return { x: x + w / 2, y: y + h / 2 };
            }
        };

        // 1. Connexions internes de chaque arc
        ArcBoardState.compareArcs.forEach(arcId => {
            const arc = ArcRepository.getById(arcId);
            if (!arc?.board?.connections) return;

            arc.board.connections.forEach(conn => {
                const fromEl = document.getElementById(`item-${conn.from}`);
                const toEl = document.getElementById(`item-${conn.to}`);

                if (!fromEl || !toEl) return;

                const fromPos = getRelativePosition(fromEl, conn.fromSide);
                const toPos = getRelativePosition(toEl, conn.toSide);

                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                const d = this._createBezierPath(fromPos, toPos, conn.fromSide, conn.toSide);

                path.setAttribute('d', d);
                path.setAttribute('class', 'arc-connection-line');
                path.setAttribute('data-connection-id', conn.id);
                path.setAttribute('data-arc-id', arcId);
                path.setAttribute('marker-end', 'url(#arrowhead)');
                path.style.stroke = arc.color;
                path.style.opacity = '0.6';

                svg.appendChild(path);
            });
        });

        // 2. Connexions inter-arcs
        const interArcConnections = InterArcConnectionRepository?.getAll?.() || [];
        interArcConnections.forEach(conn => {
            // Trouver les éléments dans les arcs comparés
            if (!ArcBoardState.compareArcs.includes(conn.fromArcId) ||
                !ArcBoardState.compareArcs.includes(conn.toArcId)) return;

            // Chercher par data-item-id (colonnes, notes, etc.) OU data-card-id (cartes)
            const fromEl = document.querySelector(`[data-arc-id="${conn.fromArcId}"][data-item-id="${conn.fromItemId}"]`)
                        || document.querySelector(`[data-arc-id="${conn.fromArcId}"][data-card-id="${conn.fromItemId}"]`);
            const toEl = document.querySelector(`[data-arc-id="${conn.toArcId}"][data-item-id="${conn.toItemId}"]`)
                      || document.querySelector(`[data-arc-id="${conn.toArcId}"][data-card-id="${conn.toItemId}"]`);

            if (!fromEl || !toEl) return;

            const fromPos = getRelativePosition(fromEl, 'right');
            const toPos = getRelativePosition(toEl, 'left');

            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            const d = this._createBezierPath(fromPos, toPos, 'right', 'left');

            path.setAttribute('d', d);
            path.setAttribute('class', 'arc-connection-line arc-interarc-connection');
            path.setAttribute('data-interarc-id', conn.id);
            path.setAttribute('marker-end', 'url(#arrowhead-interarc)');
            path.style.stroke = 'var(--primary-color)';
            path.style.strokeWidth = '2';
            path.style.strokeDasharray = '5,5';

            svg.appendChild(path);
        });
    },

    /**
     * Récupère les scènes non attribuées d'un arc
     */
    _getUnassignedScenes(arc) {
        const unassignedScenes = [];
        if (arc.scenePresence) {
            arc.scenePresence
                .filter(p => !p.columnId || p.columnId === null)
                .forEach(presence => {
                    let sceneTitle = 'Scène sans titre';
                    let breadcrumb = '';

                    for (const act of project.acts) {
                        for (const chapter of act.chapters) {
                            const scene = chapter.scenes.find(s => s.id == presence.sceneId);
                            if (scene) {
                                sceneTitle = scene.title || 'Scène sans titre';
                                breadcrumb = `${act.title || 'Acte'} › ${chapter.title || 'Chapitre'}`;
                                break;
                            }
                        }
                    }

                    unassignedScenes.push({
                        id: 'unassigned_' + presence.sceneId,
                        type: 'scene',
                        sceneId: presence.sceneId,
                        sceneTitle,
                        breadcrumb,
                        intensity: presence.intensity || 3,
                        status: presence.status || 'development',
                        notes: presence.notes || ''
                    });
                });
        }
        return unassignedScenes;
    },

    _renderUnassignedZone(floatingScenes) {
        const cardsHtml = floatingScenes.map(scene => this._renderSceneCard(scene)).join('');

        return `
            <div class="arc-unassigned-zone" id="arc-unassigned-zone">
                <div class="arc-unassigned-header">
                    <div class="arc-unassigned-title">
                        <i data-lucide="inbox"></i>
                        <span>Non attribué</span>
                    </div>
                    <span class="arc-unassigned-count">${floatingScenes.length}</span>
                </div>
                <div class="arc-unassigned-body"
                     ondrop="DragDropService.handleUnassignedDrop(event)"
                     ondragover="DragDropService.handleColumnDragOver(event)"
                     ondragleave="DragDropService.handleColumnDragLeave(event)">
                    ${cardsHtml}
                    ${floatingScenes.length === 0 ? `
                        <div class="arc-unassigned-empty">
                            <i data-lucide="check-circle" style="width:24px;height:24px;opacity:0.3;"></i>
                            <span>Toutes les scènes sont organisées</span>
                        </div>
                    ` : ''}
                </div>
            </div>
        `;
    },

    _renderSceneCard(scene, isUnassigned = true) {
        const statusLabels = { 'setup': 'Introduction', 'development': 'Développement', 'climax': 'Point culminant', 'resolution': 'Résolution' };

        const dragHandle = `
            <div class="arc-card-drag-handle"
                 draggable="true"
                 ondragstart="DragDropService.startUnassignedDrag(event, '${scene.sceneId}')"
                 ondragend="DragDropService.endDrag(event)"
                 onmousedown="event.stopPropagation()"
                 title="Glisser pour déplacer">
                <i data-lucide="grip-vertical"></i>
            </div>
        `;

        const deleteBtn = `
            <button class="arc-card-delete" onclick="event.stopPropagation(); deleteArcItem('${scene.id}')" title="Supprimer">
                <i data-lucide="x"></i>
            </button>
        `;

        return `
            <div class="arc-card arc-card-scene" data-card-id="${scene.id}" data-scene-id="${scene.sceneId || ''}">
                ${dragHandle}${deleteBtn}
                <div class="arc-card-scene-header">
                    <i data-lucide="book-open"></i>
                    <div class="arc-card-scene-title-wrapper">
                        <div class="arc-card-scene-breadcrumb">${scene.breadcrumb || ''}</div>
                        <div class="arc-card-scene-title">${scene.sceneTitle || 'Scène'}</div>
                    </div>
                </div>
                <div class="arc-card-scene-meta">
                    <div class="arc-card-scene-status">
                        <span class="arc-card-scene-label">Statut:</span>
                        <span class="arc-card-scene-value">${statusLabels[scene.status] || 'Développement'}</span>
                    </div>
                </div>
                <button class="arc-card-scene-open" onclick="ArcBoardEventHandlers.openScene('${scene.sceneId}'); event.stopPropagation();">
                    <i data-lucide="external-link"></i> Ouvrir
                </button>
            </div>
        `;
    },

    _renderItem(item, arcId = null, offsetX = 0, offsetY = 0) {
        const isSelected = ArcBoardState.selectedItems.includes(item.id);
        const isCompareMode = ArcBoardState.multiArcMode === MultiArcModes.COMPARE;

        switch (item.type) {
            case 'column': return this._renderColumn(item, isSelected, arcId, offsetX, offsetY);
            case 'note': return this._renderNote(item, isSelected, arcId, offsetX, offsetY);
            case 'image': return this._renderImage(item, isSelected, arcId, offsetX, offsetY);
            case 'link': return this._renderLink(item, isSelected, arcId, offsetX, offsetY);
            case 'todo': return this._renderTodo(item, isSelected, arcId, offsetX, offsetY);
            case 'comment': return this._renderComment(item, isSelected, arcId, offsetX, offsetY);
            case 'table': return this._renderTable(item, isSelected, arcId, offsetX, offsetY);
            case 'scene': return this._renderSceneItem(item, isSelected, arcId, offsetX, offsetY);
            default: return '';
        }
    },

    _renderDragHandle(itemId, isFloating = false, arcId = null) {
        const className = isFloating ? 'arc-floating-drag-handle' : 'arc-card-drag-handle';
        const arcParam = arcId ? `, '${arcId}'` : '';

        if (isFloating) {
            // Pour les éléments flottants: deux poignées
            // 1. Poignée de repositionnement (ItemMoveService)
            // 2. Poignée de drop dans colonne (DragDropService)
            return `
                <div class="${className}">
                    <div class="arc-drag-move"
                         onmousedown="ItemMoveService.start(event, '${itemId}'${arcParam}); event.stopPropagation();"
                         title="Déplacer sur le canvas">
                        <i data-lucide="grip-vertical"></i>
                    </div>
                    <div class="arc-drag-to-column"
                         draggable="true"
                         ondragstart="DragDropService.startFloatingDrag(event, '${itemId}'${arcParam})"
                         ondragend="DragDropService.endDrag(event)"
                         onmousedown="event.stopPropagation()"
                         title="Déposer dans une colonne">
                        <i data-lucide="columns-3"></i>
                    </div>
                </div>
            `;
        } else {
            // Pour les cartes: utiliser DragDropService pour le drag & drop entre colonnes
            return `
                <div class="${className}"
                     draggable="true"
                     ondragstart="DragDropService.startCardDrag(event, '${itemId}', this.closest('.arc-column').dataset.itemId${arcParam})"
                     ondragend="DragDropService.endDrag(event)"
                     onmousedown="event.stopPropagation()"
                     title="Glisser pour déplacer">
                    <i data-lucide="grip-vertical"></i>
                </div>
            `;
        }
    },

    _renderColumn(item, isSelected, arcId = null, offsetX = 0, offsetY = 0) {
        const cardsHtml = (item.cards || []).map(card => this._renderCard(card, item.id, arcId)).join('');
        const isCompareMode = arcId !== null;
        const arc = isCompareMode ? ArcRepository.getById(arcId) : null;
        const borderColor = arc ? arc.color : 'var(--border-color)';

        // En mode compare, on permet l'interaction mais on garde aussi la possibilité de créer des liens inter-arcs
        const clickHandler = isCompareMode
            ? `ArcBoardViewModel.selectItem('${item.id}', event.ctrlKey || event.metaKey, '${arcId}'); if(InterArcConnectionService.connecting) InterArcConnectionService.handleClick('${arcId}', '${item.id}')`
            : `ArcBoardViewModel.selectItem('${item.id}', event.ctrlKey || event.metaKey)`;

        return `
            <div class="arc-column ${isSelected ? 'selected' : ''} ${isCompareMode ? 'arc-column-compare' : ''}"
                 id="item-${item.id}"
                 data-item-id="${item.id}"
                 data-item-type="column"
                 ${arcId ? `data-arc-id="${arcId}"` : ''}
                 style="left: ${(item.x || 0) + offsetX}px; top: ${(item.y || 0) + offsetY}px; width: ${item.width || ArcBoardConfig.column.defaultWidth}px; ${isCompareMode ? `--column-accent: ${borderColor}` : ''}"
                 onclick="${clickHandler}">

                <div class="arc-column-header" onmousedown="ItemMoveService.start(event, '${item.id}'${isCompareMode ? `, '${arcId}'` : ''})">
                    <input type="text" class="arc-column-title" value="${item.title || ''}"
                           placeholder="Titre de la colonne"
                           onchange="ArcBoardViewModel.updateItem('${item.id}', { title: this.value }${isCompareMode ? `, '${arcId}'` : ''})"
                           onclick="event.stopPropagation()">
                    <span class="arc-column-meta">${(item.cards || []).length} carte${(item.cards || []).length > 1 ? 's' : ''}</span>
                </div>

                <div class="arc-column-body"
                     ondrop="DragDropService.handleColumnDrop(event, '${item.id}'${isCompareMode ? `, '${arcId}'` : ''})"
                     ondragover="DragDropService.handleColumnDragOver(event)"
                     ondragleave="DragDropService.handleColumnDragLeave(event)">
                    ${cardsHtml}
                    <div class="arc-card-add" onclick="event.stopPropagation(); ArcBoardView.showCardTypeMenu(event, '${item.id}'${isCompareMode ? `, '${arcId}'` : ''})">
                        <i data-lucide="plus"></i> Ajouter une carte
                    </div>
                </div>

                <div class="arc-column-resize" onmousedown="ResizeService.start(event, '${item.id}'${isCompareMode ? `, '${arcId}'` : ''})"></div>
            </div>
        `;
    },

    _renderCard(card, columnId, arcId = null) {
        const arcParam = arcId ? `, '${arcId}'` : '';
        const deleteBtn = `
            <button class="arc-card-delete" onclick="event.stopPropagation(); ArcBoardViewModel.deleteCard('${columnId}', '${card.id}'${arcParam})" title="Supprimer">
                <i data-lucide="x"></i>
            </button>
        `;

        const dragHandle = `
            <div class="arc-card-drag-handle"
                 draggable="true"
                 ondragstart="DragDropService.startCardDrag(event, '${card.id}', '${columnId}'${arcParam})"
                 ondragend="DragDropService.endDrag(event)"
                 onmousedown="event.stopPropagation()"
                 title="Glisser pour déplacer">
                <i data-lucide="grip-vertical"></i>
            </div>
        `;

        // Handler pour les connexions (inter-arcs OU intra-arc)
        const connectionClick = arcId
            ? `if(InterArcConnectionService.connecting) { InterArcConnectionService.handleClick('${arcId}', '${card.id}'); event.stopPropagation(); }`
            : `if(ArcBoardState.activeTool === 'connect') { ConnectionService.handleClick('${card.id}'); event.stopPropagation(); }`;

        switch (card.type) {
            case 'note':
                return `
                    <div class="arc-card arc-card-note" data-card-id="${card.id}" ${arcId ? `data-arc-id="${arcId}"` : ''} onclick="${connectionClick}">
                        ${dragHandle}${deleteBtn}
                        <div class="arc-card-content" contenteditable="true"
                             onblur="ArcBoardViewModel.updateCard('${columnId}', '${card.id}', { content: this.innerHTML }${arcParam})"
                             onclick="event.stopPropagation()">${card.content || ''}</div>
                    </div>
                `;

            case 'image':
                return `
                    <div class="arc-card arc-card-image" data-card-id="${card.id}" ${arcId ? `data-arc-id="${arcId}"` : ''} onclick="${connectionClick}">
                        ${dragHandle}${deleteBtn}
                        ${card.src
                        ? `<img src="${card.src}" alt="" draggable="false">`
                        : `<div class="arc-card-upload" onclick="ArcBoardEventHandlers.triggerCardImageUpload('${columnId}', '${card.id}'${arcParam})">
                                    <i data-lucide="cloud-upload"></i>
                                    <span>Ajouter une image</span>
                                </div>`
                    }
                    </div>
                `;

            case 'todo':
                const todosHtml = (card.items || []).map((todo, idx) => `
                    <div class="arc-todo-item">
                        <div class="arc-todo-checkbox ${todo.completed ? 'checked' : ''}"
                             onclick="ArcBoardEventHandlers.toggleTodo('${columnId}', '${card.id}', ${idx}${arcParam})">
                            ${todo.completed ? '<i data-lucide="check"></i>' : ''}
                        </div>
                        <input type="text" class="arc-todo-text ${todo.completed ? 'completed' : ''}"
                               value="${todo.text || ''}"
                               onchange="ArcBoardEventHandlers.updateTodoText('${columnId}', '${card.id}', ${idx}, this.value${arcParam})"
                               onclick="event.stopPropagation()">
                    </div>
                `).join('');

                return `
                    <div class="arc-card arc-card-todo" data-card-id="${card.id}" ${arcId ? `data-arc-id="${arcId}"` : ''} onclick="${connectionClick}">
                        ${dragHandle}${deleteBtn}
                        <input type="text" class="arc-card-title" value="${card.title || ''}"
                               placeholder="Titre"
                               onchange="ArcBoardViewModel.updateCard('${columnId}', '${card.id}', { title: this.value }${arcParam})"
                               onclick="event.stopPropagation()">
                        <div class="arc-todo-list">${todosHtml}</div>
                        <div class="arc-todo-add" onclick="ArcBoardEventHandlers.addTodoItem('${columnId}', '${card.id}'${arcParam}); event.stopPropagation();">
                            <i data-lucide="plus"></i> Ajouter une tâche...
                        </div>
                    </div>
                `;

            case 'scene':
                const statusLabels = { 'setup': 'Introduction', 'development': 'Développement', 'climax': 'Point culminant', 'resolution': 'Résolution' };
                return `
                    <div class="arc-card arc-card-scene" data-card-id="${card.id}" data-scene-id="${card.sceneId || ''}" ${arcId ? `data-arc-id="${arcId}"` : ''} onclick="${connectionClick}">
                        ${dragHandle}${deleteBtn}
                        <div class="arc-card-scene-header">
                            <i data-lucide="book-open"></i>
                            <div class="arc-card-scene-title-wrapper">
                                <div class="arc-card-scene-breadcrumb">${card.breadcrumb || ''}</div>
                                <div class="arc-card-scene-title">${card.sceneTitle || 'Scène'}</div>
                            </div>
                        </div>
                        <div class="arc-card-scene-meta">
                            <div class="arc-card-scene-status">
                                <span class="arc-card-scene-label">Statut:</span>
                                <span class="arc-card-scene-value">${statusLabels[card.status] || 'Développement'}</span>
                            </div>
                        </div>
                        <button class="arc-card-scene-open" onclick="ArcBoardEventHandlers.openScene('${card.sceneId}'); event.stopPropagation();">
                            <i data-lucide="external-link"></i> Ouvrir
                        </button>
                    </div>
                `;

            case 'link':
                return `
                    <div class="arc-card arc-card-link" data-card-id="${card.id}" ${arcId ? `data-arc-id="${arcId}"` : ''} onclick="${connectionClick}">
                        ${dragHandle}${deleteBtn}
                        ${card.url ? `
                            <div class="arc-link-preview">
                                ${card.previewImage ? `<div class="arc-link-preview-image" style="background-image:url(${card.previewImage})"></div>` : ''}
                                <div class="arc-link-preview-info">
                                    <div class="arc-link-preview-title">${card.title || card.url}</div>
                                    <div class="arc-link-preview-url">${card.url}</div>
                                </div>
                            </div>
                        ` : `
                            <div class="arc-link-input">
                                <i data-lucide="link"></i>
                                <input type="text" placeholder="Entrer une URL"
                                       onkeypress="ArcBoardEventHandlers.handleCardLinkInput(event, '${columnId}', '${card.id}'${arcParam})"
                                       onclick="event.stopPropagation()">
                            </div>
                        `}
                    </div>
                `;

            case 'comment':
                return `
                    <div class="arc-card arc-card-comment" data-card-id="${card.id}" ${arcId ? `data-arc-id="${arcId}"` : ''} onclick="${connectionClick}">
                        ${dragHandle}${deleteBtn}
                        <div class="arc-card-content" contenteditable="true"
                             onblur="ArcBoardViewModel.updateCard('${columnId}', '${card.id}', { content: this.innerHTML }${arcParam})"
                             onclick="event.stopPropagation()">${card.content || ''}</div>
                    </div>
                `;

            case 'table':
                const rows = card.rows || 3;
                const cols = card.cols || 3;
                const data = card.data || [];
                let tableHtml = '<table>';
                for (let r = 0; r < rows; r++) {
                    tableHtml += '<tr>';
                    for (let c = 0; c < cols; c++) {
                        const cellData = data[r]?.[c] || '';
                        const tag = r === 0 ? 'th' : 'td';
                        tableHtml += `<${tag} contenteditable="true"
                                       onblur="ArcBoardEventHandlers.updateCardTableCell('${columnId}', '${card.id}', ${r}, ${c}, this.textContent${arcParam})"
                                       onclick="event.stopPropagation()">${cellData}</${tag}>`;
                    }
                    // Bouton supprimer ligne (sauf header)
                    if (r > 0) {
                        tableHtml += `<td class="arc-table-action" onclick="ArcBoardEventHandlers.removeCardTableRow('${columnId}', '${card.id}', ${r}${arcParam}); event.stopPropagation();">
                            <i data-lucide="minus"></i>
                        </td>`;
                    } else {
                        tableHtml += '<th class="arc-table-action"></th>';
                    }
                    tableHtml += '</tr>';
                }
                // Ligne pour supprimer colonnes
                tableHtml += '<tr class="arc-table-actions-row">';
                for (let c = 0; c < cols; c++) {
                    if (cols > 1) {
                        tableHtml += `<td class="arc-table-action" onclick="ArcBoardEventHandlers.removeCardTableCol('${columnId}', '${card.id}', ${c}${arcParam}); event.stopPropagation();">
                            <i data-lucide="minus"></i>
                        </td>`;
                    } else {
                        tableHtml += '<td class="arc-table-action"></td>';
                    }
                }
                tableHtml += '<td class="arc-table-action"></td></tr>';
                tableHtml += '</table>';
                return `
                    <div class="arc-card arc-card-table" data-card-id="${card.id}" ${arcId ? `data-arc-id="${arcId}"` : ''}>
                        ${dragHandle}${deleteBtn}
                        ${tableHtml}
                        <div class="arc-table-controls">
                            <button class="arc-table-btn" onclick="ArcBoardEventHandlers.addCardTableRow('${columnId}', '${card.id}'${arcParam}); event.stopPropagation();" title="Ajouter une ligne">
                                <i data-lucide="plus"></i> Ligne
                            </button>
                            <button class="arc-table-btn" onclick="ArcBoardEventHandlers.addCardTableCol('${columnId}', '${card.id}'${arcParam}); event.stopPropagation();" title="Ajouter une colonne">
                                <i data-lucide="plus"></i> Colonne
                            </button>
                        </div>
                    </div>
                `;

            default:
                return `
                    <div class="arc-card arc-card-note" data-card-id="${card.id}" ${arcId ? `data-arc-id="${arcId}"` : ''}>
                        ${dragHandle}${deleteBtn}
                        <div class="arc-card-content">${card.content || ''}</div>
                    </div>
                `;
        }
    },

    _renderNote(item, isSelected, arcId = null, offsetX = 0, offsetY = 0) {
        const isCompareMode = arcId !== null;
        const arcParam = arcId ? `, '${arcId}'` : '';
        const clickHandler = isCompareMode
            ? `ArcBoardViewModel.selectItem('${item.id}', event.ctrlKey || event.metaKey, '${arcId}'); if(InterArcConnectionService.connecting) InterArcConnectionService.handleClick('${arcId}', '${item.id}')`
            : `ArcBoardViewModel.selectItem('${item.id}', event.ctrlKey || event.metaKey)`;
        return `
            <div class="arc-floating-item arc-floating-note ${isSelected ? 'selected' : ''}"
                 id="item-${item.id}"
                 data-item-id="${item.id}"
                 data-item-type="note"
                 ${arcId ? `data-arc-id="${arcId}"` : ''}
                 style="left: ${(item.x || 0) + offsetX}px; top: ${(item.y || 0) + offsetY}px; width: ${item.width || 250}px"
                 onclick="${clickHandler}">
                ${this._renderDragHandle(item.id, true, arcId)}
                <div class="arc-card-content" contenteditable="true"
                     onblur="ArcBoardViewModel.updateItem('${item.id}', { content: this.innerHTML }${arcParam})"
                     onclick="event.stopPropagation()">${item.content || ''}</div>
            </div>
        `;
    },

    _renderImage(item, isSelected, arcId = null, offsetX = 0, offsetY = 0) {
        const isCompareMode = arcId !== null;
        const arcParam = arcId ? `, '${arcId}'` : '';
        const clickHandler = isCompareMode
            ? `ArcBoardViewModel.selectItem('${item.id}', event.ctrlKey || event.metaKey, '${arcId}'); if(InterArcConnectionService.connecting) InterArcConnectionService.handleClick('${arcId}', '${item.id}')`
            : `ArcBoardViewModel.selectItem('${item.id}', event.ctrlKey || event.metaKey)`;
        return `
            <div class="arc-floating-item arc-floating-image ${isSelected ? 'selected' : ''}"
                 id="item-${item.id}"
                 data-item-id="${item.id}"
                 data-item-type="image"
                 ${arcId ? `data-arc-id="${arcId}"` : ''}
                 style="left: ${(item.x || 0) + offsetX}px; top: ${(item.y || 0) + offsetY}px"
                 onclick="${clickHandler}">
                ${this._renderDragHandle(item.id, true, arcId)}
                ${item.src
                ? `<img src="${item.src}" alt="" style="max-width: ${item.width || 300}px" draggable="false">`
                : `<div class="arc-card-upload" style="padding: 40px" onclick="ArcBoardEventHandlers.triggerItemImageUpload('${item.id}'${arcParam})">
                            <i data-lucide="cloud-upload"></i>
                            <span>Ajouter une image</span>
                        </div>`
            }
            </div>
        `;
    },

    _renderLink(item, isSelected, arcId = null, offsetX = 0, offsetY = 0) {
        const isCompareMode = arcId !== null;
        const arcParam = arcId ? `, '${arcId}'` : '';
        const clickHandler = isCompareMode
            ? `ArcBoardViewModel.selectItem('${item.id}', event.ctrlKey || event.metaKey, '${arcId}'); if(InterArcConnectionService.connecting) InterArcConnectionService.handleClick('${arcId}', '${item.id}')`
            : `ArcBoardViewModel.selectItem('${item.id}', event.ctrlKey || event.metaKey)`;
        return `
            <div class="arc-floating-item ${isSelected ? 'selected' : ''}"
                 id="item-${item.id}"
                 data-item-id="${item.id}"
                 data-item-type="link"
                 ${arcId ? `data-arc-id="${arcId}"` : ''}
                 style="left: ${(item.x || 0) + offsetX}px; top: ${(item.y || 0) + offsetY}px; width: 280px"
                 onclick="${clickHandler}">
                ${this._renderDragHandle(item.id, true, arcId)}
                <div class="arc-card arc-card-link" style="margin:0">
                    ${item.url ? `
                        <div class="arc-link-preview">
                            <div class="arc-link-preview-info">
                                <div class="arc-link-preview-title">${item.title || item.url}</div>
                                <div class="arc-link-preview-url">${item.url}</div>
                            </div>
                        </div>
                    ` : `
                        <div class="arc-link-input">
                            <i data-lucide="link"></i>
                            <input type="text" placeholder="Entrer une URL"
                                   onkeypress="ArcBoardEventHandlers.handleLinkInput(event, '${item.id}'${arcParam})"
                                   onclick="event.stopPropagation()">
                        </div>
                    `}
                </div>
            </div>
        `;
    },

    _renderTodo(item, isSelected, arcId = null, offsetX = 0, offsetY = 0) {
        const isCompareMode = arcId !== null;
        const arcParam = arcId ? `, '${arcId}'` : '';
        const clickHandler = isCompareMode
            ? `ArcBoardViewModel.selectItem('${item.id}', event.ctrlKey || event.metaKey, '${arcId}'); if(InterArcConnectionService.connecting) InterArcConnectionService.handleClick('${arcId}', '${item.id}')`
            : `ArcBoardViewModel.selectItem('${item.id}', event.ctrlKey || event.metaKey)`;
        const todosHtml = (item.items || []).map((todo, idx) => `
            <div class="arc-todo-item">
                <div class="arc-todo-checkbox ${todo.completed ? 'checked' : ''}"
                     onclick="ArcBoardEventHandlers.toggleFloatingTodo('${item.id}', ${idx}${arcParam})">
                    ${todo.completed ? '<i data-lucide="check"></i>' : ''}
                </div>
                <input type="text" class="arc-todo-text ${todo.completed ? 'completed' : ''}"
                       value="${todo.text || ''}"
                       onchange="ArcBoardEventHandlers.updateFloatingTodoText('${item.id}', ${idx}, this.value${arcParam})"
                       onclick="event.stopPropagation()">
            </div>
        `).join('');

        return `
            <div class="arc-floating-item ${isSelected ? 'selected' : ''}"
                 id="item-${item.id}"
                 data-item-id="${item.id}"
                 data-item-type="todo"
                 ${arcId ? `data-arc-id="${arcId}"` : ''}
                 style="left: ${(item.x || 0) + offsetX}px; top: ${(item.y || 0) + offsetY}px; width: 260px"
                 onclick="${clickHandler}">
                ${this._renderDragHandle(item.id, true, arcId)}
                <div class="arc-card arc-card-todo" style="margin:0">
                    <input type="text" class="arc-card-title" value="${item.title || ''}"
                           placeholder="Liste de tâches"
                           onchange="ArcBoardViewModel.updateItem('${item.id}', { title: this.value }${arcParam})"
                           onclick="event.stopPropagation()">
                    <div class="arc-todo-list">${todosHtml}</div>
                    <div class="arc-todo-add" onclick="ArcBoardEventHandlers.addFloatingTodoItem('${item.id}'${arcParam}); event.stopPropagation();">
                        <i data-lucide="plus"></i> Ajouter une tâche...
                    </div>
                </div>
            </div>
        `;
    },

    _renderComment(item, isSelected, arcId = null, offsetX = 0, offsetY = 0) {
        const isCompareMode = arcId !== null;
        const arcParam = arcId ? `, '${arcId}'` : '';
        const clickHandler = isCompareMode
            ? `ArcBoardViewModel.selectItem('${item.id}', event.ctrlKey || event.metaKey, '${arcId}'); if(InterArcConnectionService.connecting) InterArcConnectionService.handleClick('${arcId}', '${item.id}')`
            : `ArcBoardViewModel.selectItem('${item.id}', event.ctrlKey || event.metaKey)`;
        return `
            <div class="arc-floating-item ${isSelected ? 'selected' : ''}"
                 id="item-${item.id}"
                 data-item-id="${item.id}"
                 data-item-type="comment"
                 ${arcId ? `data-arc-id="${arcId}"` : ''}
                 style="left: ${(item.x || 0) + offsetX}px; top: ${(item.y || 0) + offsetY}px; width: 220px"
                 onclick="${clickHandler}">
                ${this._renderDragHandle(item.id, true, arcId)}
                <div class="arc-card arc-card-comment" style="margin:0">
                    <div class="arc-card-content" contenteditable="true"
                         onblur="ArcBoardViewModel.updateItem('${item.id}', { content: this.innerHTML }${arcParam})"
                         onclick="event.stopPropagation()">${item.content || ''}</div>
                </div>
            </div>
        `;
    },

    _renderTable(item, isSelected, arcId = null, offsetX = 0, offsetY = 0) {
        const isCompareMode = arcId !== null;
        const arcParam = arcId ? `, '${arcId}'` : '';
        const clickHandler = isCompareMode
            ? `ArcBoardViewModel.selectItem('${item.id}', event.ctrlKey || event.metaKey, '${arcId}'); if(InterArcConnectionService.connecting) InterArcConnectionService.handleClick('${arcId}', '${item.id}')`
            : `ArcBoardViewModel.selectItem('${item.id}', event.ctrlKey || event.metaKey)`;
        const rows = item.rows || 3;
        const cols = item.cols || 3;
        const data = item.data || [];

        let tableHtml = '<table>';
        for (let r = 0; r < rows; r++) {
            tableHtml += '<tr>';
            for (let c = 0; c < cols; c++) {
                const cellData = data[r]?.[c] || '';
                const tag = r === 0 ? 'th' : 'td';
                tableHtml += `<${tag} contenteditable="true"
                               onblur="ArcBoardEventHandlers.updateTableCell('${item.id}', ${r}, ${c}, this.textContent${arcParam})"
                               onclick="event.stopPropagation()">${cellData}</${tag}>`;
            }
            // Bouton supprimer ligne (sauf header)
            if (r > 0) {
                tableHtml += `<td class="arc-table-action" onclick="ArcBoardEventHandlers.removeTableRow('${item.id}', ${r}${arcParam}); event.stopPropagation();">
                    <i data-lucide="minus"></i>
                </td>`;
            } else {
                tableHtml += '<th class="arc-table-action"></th>';
            }
            tableHtml += '</tr>';
        }
        // Ligne pour supprimer colonnes
        tableHtml += '<tr class="arc-table-actions-row">';
        for (let c = 0; c < cols; c++) {
            if (cols > 1) {
                tableHtml += `<td class="arc-table-action" onclick="ArcBoardEventHandlers.removeTableCol('${item.id}', ${c}${arcParam}); event.stopPropagation();">
                    <i data-lucide="minus"></i>
                </td>`;
            } else {
                tableHtml += '<td class="arc-table-action"></td>';
            }
        }
        tableHtml += '<td class="arc-table-action"></td></tr>';
        tableHtml += '</table>';

        return `
            <div class="arc-floating-item ${isSelected ? 'selected' : ''}"
                 id="item-${item.id}"
                 data-item-id="${item.id}"
                 data-item-type="table"
                 ${arcId ? `data-arc-id="${arcId}"` : ''}
                 style="left: ${(item.x || 0) + offsetX}px; top: ${(item.y || 0) + offsetY}px"
                 onclick="${clickHandler}">
                ${this._renderDragHandle(item.id, true, arcId)}
                <div class="arc-card arc-card-table" style="margin:0">
                    ${tableHtml}
                    <div class="arc-table-controls">
                        <button class="arc-table-btn" onclick="ArcBoardEventHandlers.addTableRow('${item.id}'${arcParam}); event.stopPropagation();" title="Ajouter une ligne">
                            <i data-lucide="plus"></i> Ligne
                        </button>
                        <button class="arc-table-btn" onclick="ArcBoardEventHandlers.addTableCol('${item.id}'${arcParam}); event.stopPropagation();" title="Ajouter une colonne">
                            <i data-lucide="plus"></i> Colonne
                        </button>
                    </div>
                </div>
            </div>
        `;
    },

    _renderSceneItem(item, isSelected, arcId = null, offsetX = 0, offsetY = 0) {
        const isCompareMode = arcId !== null;
        const arcParam = arcId ? `, '${arcId}'` : '';
        const clickHandler = isCompareMode
            ? `ArcBoardViewModel.selectItem('${item.id}', event.ctrlKey || event.metaKey, '${arcId}'); if(InterArcConnectionService.connecting) InterArcConnectionService.handleClick('${arcId}', '${item.id}')`
            : `ArcBoardViewModel.selectItem('${item.id}', event.ctrlKey || event.metaKey)`;
        const statusLabels = { 'setup': 'Introduction', 'development': 'Développement', 'climax': 'Point culminant', 'resolution': 'Résolution' };

        return `
            <div class="arc-floating-item ${isSelected ? 'selected' : ''}"
                 id="item-${item.id}"
                 data-item-id="${item.id}"
                 data-item-type="scene"
                 data-scene-id="${item.sceneId || ''}"
                 ${arcId ? `data-arc-id="${arcId}"` : ''}
                 style="left: ${(item.x || 0) + offsetX}px; top: ${(item.y || 0) + offsetY}px; width: ${item.width || 220}px; z-index: ${item.zIndex || 1}"
                 onclick="${clickHandler}">
                ${this._renderDragHandle(item.id, true, arcId)}
                <button class="arc-floating-delete" onclick="event.stopPropagation(); deleteArcItem('${item.id}'${arcParam})" title="Supprimer">
                    <i data-lucide="x"></i>
                </button>
                <div class="arc-card arc-card-scene" style="margin:0">
                    <div class="arc-card-scene-header">
                        <i data-lucide="book-open"></i>
                        <div class="arc-card-scene-title-wrapper">
                            <div class="arc-card-scene-breadcrumb">${item.breadcrumb || ''}</div>
                            <div class="arc-card-scene-title">${item.sceneTitle || 'Scène'}</div>
                        </div>
                    </div>
                    <div class="arc-card-scene-meta">
                        <div class="arc-card-scene-status">
                            <span class="arc-card-scene-label">Statut:</span>
                            <span class="arc-card-scene-value">${statusLabels[item.status] || 'Développement'}</span>
                        </div>
                    </div>
                    <button class="arc-card-scene-open" onclick="ArcBoardEventHandlers.openScene('${item.sceneId}'); event.stopPropagation();">
                        <i data-lucide="external-link"></i> Ouvrir
                    </button>
                </div>
            </div>
        `;
    },

    // ==========================================
    // CONNEXIONS
    // ==========================================

    /**
     * Rendu des connexions SVG
     */
    renderConnections(arc) {
        const svg = document.getElementById('arcConnectionsSvg');
        if (!svg) return;

        const defs = svg.querySelector('defs');
        svg.innerHTML = '';
        if (defs) svg.appendChild(defs);

        if (!arc.board.connections?.length) return;

        arc.board.connections.forEach(conn => {
            // Chercher par item-id OU data-card-id pour supporter les cartes
            const fromEl = document.getElementById(`item-${conn.from}`)
                        || document.querySelector(`[data-card-id="${conn.from}"]`);
            const toEl = document.getElementById(`item-${conn.to}`)
                      || document.querySelector(`[data-card-id="${conn.to}"]`);

            if (!fromEl || !toEl) return;

            const fromPos = this._getElementPosition(fromEl, conn.fromSide);
            const toPos = this._getElementPosition(toEl, conn.toSide);

            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            const d = this._createBezierPath(fromPos, toPos, conn.fromSide, conn.toSide);

            path.setAttribute('d', d);
            path.setAttribute('class', `arc-connection-line ${ArcBoardState.selectedItems.includes(conn.id) ? 'selected' : ''}`);
            path.setAttribute('data-connection-id', conn.id);
            path.setAttribute('marker-end', 'url(#arrowhead)');
            path.style.pointerEvents = 'stroke';
            path.onclick = (e) => {
                e.stopPropagation();
                ArcBoardState.selectedItems = [conn.id];
                ArcBoardViewModel._updateSelectionUI();
            };

            svg.appendChild(path);
        });
    },

    _getElementPosition(element, side) {
        let x, y, w, h;

        // Pour les éléments avec position absolue (colonnes, notes flottantes)
        if (element.style.left && element.style.top) {
            x = parseInt(element.style.left) || 0;
            y = parseInt(element.style.top) || 0;
            w = element.offsetWidth;
            h = element.offsetHeight;
        } else {
            // Pour les cartes (dans le flux du DOM), utiliser getBoundingClientRect
            const content = document.getElementById('arcBoardContent');
            if (!content) return { x: 0, y: 0 };

            const contentRect = content.getBoundingClientRect();
            const rect = element.getBoundingClientRect();

            x = (rect.left - contentRect.left) / ArcBoardState.zoom;
            y = (rect.top - contentRect.top) / ArcBoardState.zoom;
            w = rect.width / ArcBoardState.zoom;
            h = rect.height / ArcBoardState.zoom;
        }

        switch (side) {
            case 'top': return { x: x + w / 2, y: y };
            case 'bottom': return { x: x + w / 2, y: y + h };
            case 'left': return { x: x, y: y + h / 2 };
            case 'right': return { x: x + w, y: y + h / 2 };
            default: return { x: x + w / 2, y: y + h / 2 };
        }
    },

    _createBezierPath(from, to, fromSide, toSide) {
        const dx = to.x - from.x;
        const dy = to.y - from.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const offset = Math.min(80, Math.max(40, dist / 3));

        let cp1 = { x: from.x, y: from.y };
        let cp2 = { x: to.x, y: to.y };

        switch (fromSide) {
            case 'top': cp1.y -= offset; break;
            case 'bottom': cp1.y += offset; break;
            case 'left': cp1.x -= offset; break;
            case 'right': cp1.x += offset; break;
        }

        switch (toSide) {
            case 'top': cp2.y -= offset; break;
            case 'bottom': cp2.y += offset; break;
            case 'left': cp2.x -= offset; break;
            case 'right': cp2.x += offset; break;
        }

        return `M ${from.x} ${from.y} C ${cp1.x} ${cp1.y}, ${cp2.x} ${cp2.y}, ${to.x} ${to.y}`;
    },

    // ==========================================
    // WELCOME & MENUS
    // ==========================================

    renderWelcome() {
        const view = document.getElementById('editorView');
        if (!view) return;

        ArcRepository.init();
        const arcs = ArcRepository.getAll();

        view.innerHTML = `
            <div class="empty-state">
                <div class="empty-state-icon"><i data-lucide="layout-dashboard"></i></div>
                <div class="empty-state-title">${arcs.length === 0 ? 'Gérez vos arcs narratifs' : 'Sélectionnez un arc'}</div>
                <div class="empty-state-text">
                    ${arcs.length === 0
                ? 'Créez des boards visuels pour planifier vos arcs narratifs,<br>organiser vos idées et suivre la progression de votre histoire.'
                : 'Choisissez un arc dans la barre latérale<br>ou créez-en un nouveau.'
            }
                </div>
                <button class="btn btn-primary" onclick="ArcBoardViewModel.showArcForm()">
                    <i data-lucide="${arcs.length === 0 ? 'sparkles' : 'plus'}"></i>
                    ${arcs.length === 0 ? 'Créer votre premier arc' : 'Nouvel arc'}
                </button>
            </div>
        `;

        if (typeof lucide !== 'undefined') lucide.createIcons();
    },

    showArcContextMenu(event, arcId) {
        this._removeContextMenu();

        const menu = document.createElement('div');
        menu.className = 'arc-context-menu';
        menu.id = 'arcContextMenu';
        menu.style.left = `${event.clientX}px`;
        menu.style.top = `${event.clientY}px`;

        menu.innerHTML = `
            <div class="arc-context-menu-item" onclick="ArcBoardViewModel.openArc('${arcId}')">
                <i data-lucide="layout-dashboard"></i> Ouvrir
            </div>
            <div class="arc-context-menu-item" onclick="ArcBoardViewModel.showArcForm('${arcId}')">
                <i data-lucide="settings"></i> Modifier
            </div>
            <div class="arc-context-menu-item" onclick="ArcBoardEventHandlers.duplicateArc('${arcId}')">
                <i data-lucide="copy"></i> Dupliquer
            </div>
            <div class="arc-context-menu-separator"></div>
            <div class="arc-context-menu-item danger" onclick="ArcBoardEventHandlers.deleteArc('${arcId}')">
                <i data-lucide="trash-2"></i> Supprimer
            </div>
        `;

        document.body.appendChild(menu);
        if (typeof lucide !== 'undefined') lucide.createIcons();

        setTimeout(() => {
            document.addEventListener('click', () => this._removeContextMenu(), { once: true });
        }, 10);
    },

    showCanvasContextMenu(event) {
        this._removeContextMenu();

        const menu = document.createElement('div');
        menu.className = 'arc-context-menu';
        menu.id = 'arcContextMenu';
        menu.style.left = `${event.clientX}px`;
        menu.style.top = `${event.clientY}px`;

        menu.innerHTML = `
            <div class="arc-context-menu-item" onclick="ArcBoardViewModel.addItemAt('column', ${event.clientX}, ${event.clientY})">
                <i data-lucide="columns-3"></i> Ajouter une colonne
            </div>
            <div class="arc-context-menu-item" onclick="ArcBoardViewModel.addItemAt('note', ${event.clientX}, ${event.clientY})">
                <i data-lucide="file-text"></i> Ajouter une note
            </div>
            <div class="arc-context-menu-item" onclick="ArcBoardViewModel.addItemAt('image', ${event.clientX}, ${event.clientY})">
                <i data-lucide="image"></i> Ajouter une image
            </div>
            <div class="arc-context-menu-separator"></div>
            <div class="arc-context-menu-item" onclick="ArcBoardViewModel.paste()">
                <i data-lucide="clipboard"></i> Coller
            </div>
            <div class="arc-context-menu-separator"></div>
            <div class="arc-context-menu-item" onclick="ArcBoardViewModel.resetView()">
                <i data-lucide="maximize-2"></i> Réinitialiser le zoom
            </div>
        `;

        document.body.appendChild(menu);
        if (typeof lucide !== 'undefined') lucide.createIcons();

        setTimeout(() => {
            document.addEventListener('click', () => this._removeContextMenu(), { once: true });
        }, 10);
    },

    _removeContextMenu() {
        const menu = document.getElementById('arcContextMenu');
        if (menu) menu.remove();
        const cardMenu = document.getElementById('arcCardTypeMenu');
        if (cardMenu) cardMenu.remove();
    },

    /**
     * Affiche le menu de sélection de type de carte
     * @param {Event} event - L'événement click
     * @param {string} columnId - L'ID de la colonne cible
     * @param {string|null} arcId - L'ID de l'arc (optionnel, pour le mode compare)
     */
    showCardTypeMenu(event, columnId, arcId = null) {
        this._removeContextMenu();

        const menu = document.createElement('div');
        menu.className = 'arc-card-type-menu';
        menu.id = 'arcCardTypeMenu';

        // Positionner près du bouton
        const rect = event.target.closest('.arc-card-add').getBoundingClientRect();
        menu.style.left = `${rect.left}px`;
        menu.style.top = `${rect.bottom + 4}px`;

        // Générer les options de types de cartes
        const cardTypes = Object.entries(CreatableItemTypes)
            .filter(([_, config]) => config.canBeCard);

        const arcParam = arcId ? `, '${arcId}'` : '';
        menu.innerHTML = `
            <div class="arc-card-type-menu-header">
                <span>Type de carte</span>
            </div>
            <div class="arc-card-type-menu-grid">
                ${cardTypes.map(([type, config]) => `
                    <div class="arc-card-type-option" onclick="ArcBoardViewModel.addCard('${columnId}', '${type}'${arcParam}); ArcBoardView._removeContextMenu();">
                        <i data-lucide="${config.icon}"></i>
                        <span>${config.label}</span>
                    </div>
                `).join('')}
            </div>
        `;

        document.body.appendChild(menu);
        if (typeof lucide !== 'undefined') lucide.createIcons();

        // Ajuster la position si le menu dépasse de l'écran
        const menuRect = menu.getBoundingClientRect();
        if (menuRect.right > window.innerWidth) {
            menu.style.left = `${window.innerWidth - menuRect.width - 10}px`;
        }
        if (menuRect.bottom > window.innerHeight) {
            menu.style.top = `${rect.top - menuRect.height - 4}px`;
        }

        // Fermer le menu au clic extérieur
        setTimeout(() => {
            document.addEventListener('click', (e) => {
                if (!menu.contains(e.target)) {
                    this._removeContextMenu();
                }
            }, { once: true });
        }, 10);
    }
};

// ========== js-refactor/arc-board/arc-board.handlers.js ==========
// ============================================
// ARC BOARD - Event Handlers
// ============================================

/**
 * Gestionnaires d'événements centralisés
 */
const ArcBoardEventHandlers = {
    // ==========================================
    // CANVAS EVENTS
    // ==========================================

    onCanvasMouseDown(event) {
        const target = event.target;

        // Clic sur le fond du canvas
        if (target.id === 'arcBoardCanvas' ||
            target.id === 'arcBoardContent' ||
            target.classList.contains('arc-board-content') ||
            target.id === 'arcBoardItems') {

            if (ArcBoardState.activeTool === ToolTypes.PAN || event.button === 1) {
                PanService.start(event);
            } else if (ArcBoardState.activeTool === ToolTypes.CONNECT) {
                ConnectionService.cancel();
            } else {
                ArcBoardViewModel.deselectAll();
            }
        }
    },

    onCanvasMouseMove(event) {
        if (PanService.isActive()) {
            PanService.move(event);
        }

        if (ItemMoveService.isActive()) {
            ItemMoveService.move(event);
        }

        if (ResizeService.isActive()) {
            ResizeService.move(event);
        }
    },

    onCanvasMouseUp(event) {
        if (PanService.isActive()) {
            PanService.end();
        }

        if (ItemMoveService.isActive()) {
            ItemMoveService.end();
        }

        if (ResizeService.isActive()) {
            ResizeService.end();
        }
    },

    onCanvasWheel(event) {
        if (event.ctrlKey || event.metaKey) {
            event.preventDefault();
            ArcBoardViewModel.zoom(event.deltaY > 0 ? -1 : 1);
        }
    },

    onCanvasContextMenu(event) {
        event.preventDefault();
        ArcBoardView.showCanvasContextMenu(event);
    },

    // ==========================================
    // SPLIT CANVAS EVENTS (Mode Split)
    // ==========================================

    // [MVVM : Handler] État du pan pour chaque panneau split
    _splitPanState: {},

    onSplitCanvasMouseDown(event, arcId) {
        event.preventDefault();
        const content = document.getElementById(`splitContent-${arcId}`);
        if (!content) return;

        this._splitPanState[arcId] = {
            isPanning: true,
            startX: event.clientX,
            startY: event.clientY,
            panel: ArcBoardState.splitArcs.find(p => p.id === arcId)
        };
    },

    onSplitCanvasMouseMove(event, arcId) {
        const state = this._splitPanState[arcId];
        if (!state || !state.isPanning) return;

        const dx = event.clientX - state.startX;
        const dy = event.clientY - state.startY;

        const panel = state.panel;
        if (!panel) return;

        const content = document.getElementById(`splitContent-${arcId}`);
        if (!content) return;

        const newPanX = panel.panX + dx / panel.zoom;
        const newPanY = panel.panY + dy / panel.zoom;

        content.style.transform = `scale(${panel.zoom}) translate(${newPanX}px, ${newPanY}px)`;

        state.startX = event.clientX;
        state.startY = event.clientY;
        panel.panX = newPanX;
        panel.panY = newPanY;
    },

    onSplitCanvasMouseUp(event, arcId) {
        if (this._splitPanState[arcId]) {
            this._splitPanState[arcId].isPanning = false;
        }
    },

    onSplitCanvasWheel(event, arcId) {
        if (event.ctrlKey || event.metaKey) {
            event.preventDefault();
            ArcBoardViewModel.zoomSplitPanel(arcId, event.deltaY > 0 ? -1 : 1);
        }
    },

    // ==========================================
    // FORMULAIRES
    // ==========================================

    handleArcFormKeydown(event) {
        if (event.key === 'Enter') {
            this.confirmArcForm();
        } else if (event.key === 'Escape') {
            ArcBoardViewModel.hideArcForm();
        }
    },

    handleCategoryFormKeydown(event) {
        if (event.key === 'Enter') {
            this.confirmCategoryForm();
        } else if (event.key === 'Escape') {
            ArcBoardViewModel.hideCategoryForm();
        }
    },

    confirmArcForm() {
        const arcId = document.getElementById('inlineArcId')?.value;
        const title = document.getElementById('inlineArcTitle')?.value.trim();
        const category = document.getElementById('inlineArcCategory')?.value;
        const color = document.getElementById('inlineArcColor')?.value;

        if (!title) {
            document.getElementById('inlineArcTitle')?.classList.add('error');
            document.getElementById('inlineArcTitle')?.focus();
            return;
        }

        let targetArc;

        if (arcId) {
            // Mode édition
            targetArc = ArcRepository.update(arcId, { title, category, color });
        } else {
            // Mode création
            targetArc = ArcRepository.create({ title, category, color });
        }

        ArcBoardViewModel.hideArcForm();

        if (targetArc) {
            ArcBoardViewModel.openArc(targetArc.id);
        }
    },

    confirmCategoryForm() {
        const name = document.getElementById('inlineCategoryName')?.value.trim();
        const color = document.getElementById('inlineCategoryColor')?.value;

        if (!name) {
            document.getElementById('inlineCategoryName')?.classList.add('error');
            document.getElementById('inlineCategoryName')?.focus();
            return;
        }

        ArcRepository.addCategory(name, color);
        ArcBoardViewModel.hideCategoryForm();
    },

    updateArcFormColor() {
        const category = document.getElementById('inlineArcCategory')?.value;
        const allCategories = ArcRepository.getAllCategories();

        if (allCategories[category]) {
            const colorInput = document.getElementById('inlineArcColor');
            const colorHex = document.getElementById('inlineArcColorHex');

            if (colorInput) colorInput.value = allCategories[category].color;
            if (colorHex) colorHex.textContent = allCategories[category].color;
        }
    },

    // ==========================================
    // ARC ACTIONS
    // ==========================================

    updateArcTitle(title) {
        const arc = ArcBoardViewModel.getCurrentArc();
        if (arc) {
            ArcRepository.update(arc.id, { title });
            ArcBoardView.renderSidebar();
        }
    },

    deleteArc(arcId) {
        ArcBoardView._removeContextMenu();

        const arc = ArcRepository.getById(arcId);
        if (!arc) return;

        if (!confirm(`Voulez-vous vraiment supprimer l'arc "${arc.title}" ?\n\nCette action est irréversible.`)) {
            return;
        }

        ArcRepository.delete(arcId);

        if (ArcBoardState.currentArcId === arcId) {
            ArcBoardState.currentArcId = null;
            ArcBoardView.renderWelcome();
        }

        ArcBoardView.renderSidebar();
    },

    duplicateArc(arcId) {
        ArcBoardView._removeContextMenu();

        const newArc = ArcRepository.duplicate(arcId);
        if (newArc) {
            ArcBoardView.renderSidebar();
            ArcBoardViewModel.openArc(newArc.id);
        }
    },

    // ==========================================
    // TODO ITEMS
    // ==========================================

    addTodoItem(columnId, cardId) {
        const arc = ArcBoardViewModel.getCurrentArc();
        if (!arc) return;

        const card = CardRepository.getById(arc.id, columnId, cardId);
        if (!card) return;

        if (!card.items) card.items = [];
        card.items.push(createTodoItemModel());

        saveProject();
        ArcBoardViewModel.renderItems();
    },

    toggleTodo(columnId, cardId, todoIndex) {
        const arc = ArcBoardViewModel.getCurrentArc();
        if (!arc) return;

        const card = CardRepository.getById(arc.id, columnId, cardId);
        if (!card?.items?.[todoIndex]) return;

        card.items[todoIndex].completed = !card.items[todoIndex].completed;

        saveProject();
        ArcBoardViewModel.renderItems();
    },

    updateTodoText(columnId, cardId, todoIndex, text) {
        const arc = ArcBoardViewModel.getCurrentArc();
        if (!arc) return;

        const card = CardRepository.getById(arc.id, columnId, cardId);
        if (!card?.items?.[todoIndex]) return;

        card.items[todoIndex].text = text;
        saveProject();
    },

    addFloatingTodoItem(itemId) {
        const arc = ArcBoardViewModel.getCurrentArc();
        if (!arc) return;

        const item = BoardItemRepository.getById(arc.id, itemId);
        if (!item) return;

        if (!item.items) item.items = [];
        item.items.push(createTodoItemModel());

        saveProject();
        ArcBoardViewModel.renderItems();
    },

    toggleFloatingTodo(itemId, todoIndex) {
        const arc = ArcBoardViewModel.getCurrentArc();
        if (!arc) return;

        const item = BoardItemRepository.getById(arc.id, itemId);
        if (!item?.items?.[todoIndex]) return;

        item.items[todoIndex].completed = !item.items[todoIndex].completed;

        saveProject();
        ArcBoardViewModel.renderItems();
    },

    updateFloatingTodoText(itemId, todoIndex, text) {
        const arc = ArcBoardViewModel.getCurrentArc();
        if (!arc) return;

        const item = BoardItemRepository.getById(arc.id, itemId);
        if (!item?.items?.[todoIndex]) return;

        item.items[todoIndex].text = text;
        saveProject();
    },

    // ==========================================
    // TABLE
    // ==========================================

    updateTableCell(itemId, row, col, value) {
        const arc = ArcBoardViewModel.getCurrentArc();
        if (!arc) return;

        const item = BoardItemRepository.getById(arc.id, itemId);
        if (!item) return;

        if (!item.data) item.data = [];
        if (!item.data[row]) item.data[row] = [];

        item.data[row][col] = value;
        saveProject();
    },

    updateCardTableCell(columnId, cardId, row, col, value) {
        const arc = ArcBoardViewModel.getCurrentArc();
        if (!arc) return;

        const card = CardRepository.getById(arc.id, columnId, cardId);
        if (!card) return;

        if (!card.data) card.data = [];
        if (!card.data[row]) card.data[row] = [];

        card.data[row][col] = value;
        saveProject();
    },

    // Ajouter/supprimer lignes et colonnes pour tableaux dans cartes
    addCardTableRow(columnId, cardId) {
        const arc = ArcBoardViewModel.getCurrentArc();
        if (!arc) return;

        const card = CardRepository.getById(arc.id, columnId, cardId);
        if (!card) return;

        card.rows = (card.rows || 3) + 1;
        if (!card.data) card.data = [];

        saveProject();
        ArcBoardViewModel.renderItems();
    },

    addCardTableCol(columnId, cardId) {
        const arc = ArcBoardViewModel.getCurrentArc();
        if (!arc) return;

        const card = CardRepository.getById(arc.id, columnId, cardId);
        if (!card) return;

        card.cols = (card.cols || 3) + 1;

        saveProject();
        ArcBoardViewModel.renderItems();
    },

    removeCardTableRow(columnId, cardId, rowIndex) {
        const arc = ArcBoardViewModel.getCurrentArc();
        if (!arc) return;

        const card = CardRepository.getById(arc.id, columnId, cardId);
        if (!card || (card.rows || 3) <= 1) return;

        card.rows = (card.rows || 3) - 1;
        if (card.data && card.data[rowIndex]) {
            card.data.splice(rowIndex, 1);
        }

        saveProject();
        ArcBoardViewModel.renderItems();
    },

    removeCardTableCol(columnId, cardId, colIndex) {
        const arc = ArcBoardViewModel.getCurrentArc();
        if (!arc) return;

        const card = CardRepository.getById(arc.id, columnId, cardId);
        if (!card || (card.cols || 3) <= 1) return;

        card.cols = (card.cols || 3) - 1;
        if (card.data) {
            card.data.forEach(row => {
                if (row && row.length > colIndex) {
                    row.splice(colIndex, 1);
                }
            });
        }

        saveProject();
        ArcBoardViewModel.renderItems();
    },

    // Ajouter/supprimer lignes et colonnes pour tableaux flottants
    addTableRow(itemId) {
        const arc = ArcBoardViewModel.getCurrentArc();
        if (!arc) return;

        const item = BoardItemRepository.getById(arc.id, itemId);
        if (!item) return;

        item.rows = (item.rows || 3) + 1;
        if (!item.data) item.data = [];

        saveProject();
        ArcBoardViewModel.renderItems();
    },

    addTableCol(itemId) {
        const arc = ArcBoardViewModel.getCurrentArc();
        if (!arc) return;

        const item = BoardItemRepository.getById(arc.id, itemId);
        if (!item) return;

        item.cols = (item.cols || 3) + 1;

        saveProject();
        ArcBoardViewModel.renderItems();
    },

    removeTableRow(itemId, rowIndex) {
        const arc = ArcBoardViewModel.getCurrentArc();
        if (!arc) return;

        const item = BoardItemRepository.getById(arc.id, itemId);
        if (!item || (item.rows || 3) <= 1) return;

        item.rows = (item.rows || 3) - 1;
        if (item.data && item.data[rowIndex]) {
            item.data.splice(rowIndex, 1);
        }

        saveProject();
        ArcBoardViewModel.renderItems();
    },

    removeTableCol(itemId, colIndex) {
        const arc = ArcBoardViewModel.getCurrentArc();
        if (!arc) return;

        const item = BoardItemRepository.getById(arc.id, itemId);
        if (!item || (item.cols || 3) <= 1) return;

        item.cols = (item.cols || 3) - 1;
        if (item.data) {
            item.data.forEach(row => {
                if (row && row.length > colIndex) {
                    row.splice(colIndex, 1);
                }
            });
        }

        saveProject();
        ArcBoardViewModel.renderItems();
    },

    // ==========================================
    // LINKS
    // ==========================================

    handleLinkInput(event, itemId) {
        if (event.key !== 'Enter') return;

        const url = event.target.value.trim();
        if (!url) return;

        ArcBoardViewModel.updateItem(itemId, { url, title: url });
        ArcBoardViewModel.renderItems();
    },

    handleCardLinkInput(event, columnId, cardId) {
        if (event.key !== 'Enter') return;

        const url = event.target.value.trim();
        if (!url) return;

        ArcBoardViewModel.updateCard(columnId, cardId, { url, title: url });
        ArcBoardViewModel.renderItems();
    },

    // ==========================================
    // IMAGES
    // ==========================================

    triggerItemImageUpload(itemId) {
        const input = document.getElementById('arcFileInput');
        if (input) {
            input.dataset.targetItem = itemId;
            input.dataset.targetType = 'item';
            input.click();
        }
    },

    triggerCardImageUpload(columnId, cardId) {
        const input = document.getElementById('arcFileInput');
        if (input) {
            input.dataset.targetColumn = columnId;
            input.dataset.targetCard = cardId;
            input.dataset.targetType = 'card';
            input.click();
        }
    },

    onFileUpload(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (e) => {
            const src = e.target.result;
            const input = event.target;

            if (input.dataset.targetType === 'card') {
                const arc = ArcBoardViewModel.getCurrentArc();
                if (arc) {
                    CardRepository.update(arc.id, input.dataset.targetColumn, input.dataset.targetCard, { src });
                    ArcBoardViewModel.renderItems();
                }
            } else if (input.dataset.targetType === 'item') {
                ArcBoardViewModel.updateItem(input.dataset.targetItem, { src });
                ArcBoardViewModel.renderItems();
            } else {
                // Créer un nouvel item image
                const item = ArcBoardViewModel.addItem('image');
                if (item) {
                    setTimeout(() => {
                        ArcBoardViewModel.updateItem(item.id, { src });
                        ArcBoardViewModel.renderItems();
                    }, 100);
                }
            }

            // Reset
            input.value = '';
            delete input.dataset.targetItem;
            delete input.dataset.targetColumn;
            delete input.dataset.targetCard;
            delete input.dataset.targetType;
        };
        reader.readAsDataURL(file);
    },

    // ==========================================
    // SCENES
    // ==========================================

    openScene(sceneId) {
        if (!sceneId) return;

        for (const act of project.acts || []) {
            for (const chapter of act.chapters || []) {
                const scene = chapter.scenes?.find(s => s.id == sceneId);
                if (scene) {
                    if (typeof switchView === 'function') switchView('editor');
                    if (typeof openScene === 'function') openScene(act.id, chapter.id, scene.id);
                    return;
                }
            }
        }
    }
};

// ==========================================
// KEYBOARD SHORTCUTS
// ==========================================

document.addEventListener('keydown', function(event) {
    // Ignorer si on édite du texte
    if (event.target.tagName === 'INPUT' ||
        event.target.tagName === 'TEXTAREA' ||
        event.target.contentEditable === 'true') {
        return;
    }

    // Vérifier qu'on est dans le mode arc board
    if (!ArcBoardState.currentArcId) return;

    // Delete/Backspace - supprimer sélection
    if (event.key === 'Delete' || event.key === 'Backspace') {
        if (ArcBoardState.selectedItems.length > 0) {
            event.preventDefault();
            ArcBoardViewModel.deleteSelected();
        }
    }

    // Escape - annuler action en cours
    if (event.key === 'Escape') {
        if (ArcBoardState.activeTool === ToolTypes.CONNECT) {
            ConnectionService.cancel();
        } else {
            ArcBoardViewModel.deselectAll();
        }
    }

    // Ctrl+A - tout sélectionner
    if ((event.ctrlKey || event.metaKey) && event.key === 'a') {
        event.preventDefault();
        ArcBoardViewModel.selectAll();
    }

    // Ctrl+C - copier
    if ((event.ctrlKey || event.metaKey) && event.key === 'c') {
        if (ArcBoardState.selectedItems.length > 0) {
            event.preventDefault();
            ArcBoardViewModel.copy();
        }
    }

    // Ctrl+V - coller
    if ((event.ctrlKey || event.metaKey) && event.key === 'v') {
        if (ArcBoardState.clipboard) {
            event.preventDefault();
            ArcBoardViewModel.paste();
        }
    }

    // Ctrl+Z - undo
    if ((event.ctrlKey || event.metaKey) && event.key === 'z' && !event.shiftKey) {
        event.preventDefault();
        if (typeof EventBus !== 'undefined') EventBus.emit('history:undo');
        else if (typeof undo === 'function') undo();
    }

    // Ctrl+Y ou Ctrl+Shift+Z - redo
    if ((event.ctrlKey || event.metaKey) && (event.key === 'y' || (event.key === 'z' && event.shiftKey))) {
        event.preventDefault();
        if (typeof EventBus !== 'undefined') EventBus.emit('history:redo');
        else if (typeof redo === 'function') redo();
    }
});

// ========== js-refactor/arc-board/arc-board.main.js ==========
// ============================================
// ARC BOARD - Main Entry Point
// ============================================
// Ce fichier charge tous les modules et expose
// les fonctions globales pour la compatibilité.
// ============================================

/**
 * Initialise le système Arc Board
 */
function initArcBoardSystem() {
    ArcRepository.init();
}

// ============================================
// API PUBLIQUE (Compatibilité avec l'ancien code)
// ============================================

// Initialisation
function initArcBoard() {
    initArcBoardSystem();
}

// Sidebar
function renderArcsBoardSidebar() {
    ArcBoardView.renderSidebar();
}

function renderArcsList() {
    ArcBoardView.renderSidebar();
}

// Welcome
function renderArcsWelcomeBoard() {
    ArcBoardView.renderWelcome();
}

function renderArcsWelcome() {
    ArcBoardView.renderWelcome();
}

// Création
function createNewArcBoard() {
    ArcBoardViewModel.showArcForm();
}

function createNewArc() {
    ArcBoardViewModel.showArcForm();
}

function showInlineArcForm(arcId = null) {
    if (typeof arcId === 'string') {
        arcId = arcId.replace(/['\"]/g, '').trim();
        if (arcId === '') arcId = null;
    }
    ArcBoardViewModel.showArcForm(arcId);
}

function cancelInlineArcForm() {
    ArcBoardViewModel.hideArcForm();
}

function confirmInlineArcForm() {
    ArcBoardEventHandlers.confirmArcForm();
}

function handleInlineArcKeydown(event) {
    ArcBoardEventHandlers.handleArcFormKeydown(event);
}

function updateInlineArcColor() {
    ArcBoardEventHandlers.updateArcFormColor();
}

// Catégories
function showInlineCategoryForm() {
    ArcBoardViewModel.showCategoryForm();
}

function showAddCategoryModal() {
    ArcBoardViewModel.showCategoryForm();
}

function cancelInlineCategoryForm() {
    ArcBoardViewModel.hideCategoryForm();
}

function confirmInlineCategoryForm() {
    ArcBoardEventHandlers.confirmCategoryForm();
}

function handleInlineCategoryKeydown(event) {
    ArcBoardEventHandlers.handleCategoryFormKeydown(event);
}

function toggleArcCategory(categoryKey) {
    ArcRepository.toggleCategoryCollapse(categoryKey);
    ArcBoardView.renderSidebar();
}

// Navigation
function openArcBoard(arcId) {
    ArcBoardViewModel.openArc(arcId);
}

function openArcDetail(arcId) {
    ArcBoardViewModel.openArc(arcId);
}

// Outils
function setArcTool(tool) {
    ArcBoardViewModel.setTool(tool);
}

function toggleConnectionMode() {
    ConnectionService.toggle();
}

function cancelConnectionMode() {
    ConnectionService.cancel();
}

// Zoom
function zoomArcBoard(direction) {
    ArcBoardViewModel.zoom(direction);
}

function resetArcZoom() {
    ArcBoardViewModel.resetView();
}

// Items
function addArcItem(type) {
    ArcBoardViewModel.addItem(type);
}

function addArcItemAtPosition(clientX, clientY, type) {
    ArcBoardView._removeContextMenu();
    ArcBoardViewModel.addItemAt(type, clientX, clientY);
}

function deleteArcItem(itemId) {
    const arc = ArcBoardViewModel.getCurrentArc();
    if (arc) {
        BoardItemRepository.delete(arc.id, itemId);
        ArcBoardState.selectedItems = ArcBoardState.selectedItems.filter(id => id !== itemId);
        ArcBoardViewModel.renderItems();
        ArcBoardViewModel.deselectAll();

        // Mettre à jour le panneau arcScenePanel s'il est visible
        const arcPanel = document.getElementById('arcScenePanel');
        if (arcPanel && !arcPanel.classList.contains('hidden') && typeof renderArcScenePanel === 'function') {
            renderArcScenePanel();
        }
    }
}

function deleteSelectedItems() {
    ArcBoardViewModel.deleteSelected();
}

function selectArcItem(event, itemId) {
    if (event) event.stopPropagation();
    ArcBoardViewModel.selectItem(itemId, event?.ctrlKey || event?.metaKey);
}

function selectArcCard(event, cardId, columnId) {
    if (event) event.stopPropagation();
    ArcBoardViewModel.selectItem(columnId, event?.ctrlKey || event?.metaKey);
}

function deselectAllArcItems() {
    ArcBoardViewModel.deselectAll();
}

// Mise à jour items
function updateArcItemTitle(itemId, title) {
    ArcBoardViewModel.updateItem(itemId, { title });
}

function updateArcItemContent(itemId, content) {
    ArcBoardViewModel.updateItem(itemId, { content });
}

function updateArcItemWidth(itemId, width) {
    ArcBoardViewModel.updateItem(itemId, { width: parseInt(width) });
    ArcBoardViewModel.renderItems();
}

function updateCurrentArcTitle(title) {
    ArcBoardEventHandlers.updateArcTitle(title);
}

// Cartes
function addCardToColumn(columnId, cardType = 'note') {
    ArcBoardViewModel.addCard(columnId, cardType);
}

function deleteArcCard(event, columnId, cardId) {
    if (event) {
        event.stopPropagation();
        event.preventDefault();
    }
    ArcBoardViewModel.deleteCard(columnId, cardId);
}

function updateArcCardContent(columnId, cardId, content) {
    ArcBoardViewModel.updateCard(columnId, cardId, { content });
}

function updateArcCardTitle(columnId, cardId, title) {
    ArcBoardViewModel.updateCard(columnId, cardId, { title });
}

// Todo
function addArcTodoItem(columnId, cardId) {
    ArcBoardEventHandlers.addTodoItem(columnId, cardId);
}

function toggleArcTodo(columnId, cardId, todoIndex) {
    ArcBoardEventHandlers.toggleTodo(columnId, cardId, todoIndex);
}

function updateArcTodoText(columnId, cardId, todoIndex, text) {
    ArcBoardEventHandlers.updateTodoText(columnId, cardId, todoIndex, text);
}

function addFloatingTodoItem(itemId) {
    ArcBoardEventHandlers.addFloatingTodoItem(itemId);
}

function toggleFloatingTodo(itemId, todoIndex) {
    ArcBoardEventHandlers.toggleFloatingTodo(itemId, todoIndex);
}

function updateFloatingTodoText(itemId, todoIndex, text) {
    ArcBoardEventHandlers.updateFloatingTodoText(itemId, todoIndex, text);
}

// Table
function updateArcTableCell(itemId, row, col, value) {
    ArcBoardEventHandlers.updateTableCell(itemId, row, col, value);
}

function updateArcTableSize(itemId, dimension, value) {
    const arc = ArcBoardViewModel.getCurrentArc();
    if (!arc) return;

    const data = {};
    data[dimension] = parseInt(value);
    BoardItemRepository.update(arc.id, itemId, data);
    ArcBoardViewModel.renderItems();
}

// Links
function handleLinkInput(event, columnId, cardId) {
    if (event.key !== 'Enter') return;

    const url = event.target.value.trim();
    if (!url) return;

    ArcBoardViewModel.updateCard(columnId, cardId, { url, title: url });
    ArcBoardViewModel.renderItems();
}

function handleFloatingLinkInput(event, itemId) {
    ArcBoardEventHandlers.handleLinkInput(event, itemId);
}

// Images
function triggerArcUpload() {
    document.getElementById('arcFileInput')?.click();
}

function triggerItemImageUpload(itemId) {
    ArcBoardEventHandlers.triggerItemImageUpload(itemId);
}

function triggerCardImageUpload(columnId, cardId) {
    ArcBoardEventHandlers.triggerCardImageUpload(columnId, cardId);
}

function handleArcFileUpload(event) {
    ArcBoardEventHandlers.onFileUpload(event);
}

function updateItemImage(itemId, src) {
    ArcBoardViewModel.updateItem(itemId, { src });
    ArcBoardViewModel.renderItems();
}

function updateCardImage(columnId, cardId, src) {
    ArcBoardViewModel.updateCard(columnId, cardId, { src });
    ArcBoardViewModel.renderItems();
}

// Arcs
function deleteArc(arcId) {
    ArcBoardEventHandlers.deleteArc(arcId);
}

function duplicateArc(arcId) {
    ArcBoardEventHandlers.duplicateArc(arcId);
}

function renameArc(arcId) {
    ArcBoardView._removeContextMenu();

    const arc = ArcRepository.getById(arcId);
    if (!arc) return;

    const newTitle = prompt("Nouveau nom de l'arc:", arc.title);
    if (newTitle && newTitle.trim()) {
        ArcRepository.update(arcId, { title: newTitle.trim() });
        ArcBoardView.renderSidebar();
    }
}

// Connexions
function selectArcConnection(event, connId) {
    event.stopPropagation();
    ArcBoardState.selectedItems = [connId];
    ArcBoardViewModel._updateSelectionUI();
}

// Canvas handlers
function handleCanvasMouseDown(event) {
    ArcBoardEventHandlers.onCanvasMouseDown(event);
}

function handleCanvasMouseMove(event) {
    ArcBoardEventHandlers.onCanvasMouseMove(event);
}

function handleCanvasMouseUp(event) {
    ArcBoardEventHandlers.onCanvasMouseUp(event);
}

function handleCanvasWheel(event) {
    ArcBoardEventHandlers.onCanvasWheel(event);
}

function handleCanvasContextMenu(event) {
    ArcBoardEventHandlers.onCanvasContextMenu(event);
}

// Drag & Drop
function handleItemMouseDown(event, itemId) {
    // Ne pas intercepter les éléments interactifs
    if (event.target.classList.contains('arc-column-resize')) return;
    if (event.target.closest('.arc-connection-point')) return;
    if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA' || event.target.contentEditable === 'true') return;
    if (event.target.closest('.arc-card-drag-handle') || event.target.closest('.arc-floating-drag-handle')) return;
    if (event.target.closest('.arc-card') && !event.target.closest('.arc-floating-item')) return;

    event.stopPropagation();
    ItemMoveService.start(event, itemId);
}

function handleItemDrag(event) {
    ItemMoveService.move(event);
}

function endItemDrag(event) {
    ItemMoveService.end();
}

function startColumnResize(event, columnId) {
    ResizeService.start(event, columnId);
}

function handleColumnResizeDrag(event) {
    ResizeService.move(event);
}

function endColumnResize(event) {
    ResizeService.end();
}

function handleCardDragStart(event, cardId, columnId) {
    DragDropService.startCardDrag(event, cardId, columnId);
}

function handleCardDragEnd(event) {
    DragDropService.endDrag(event);
}

function handleFloatingDragStart(event, itemId) {
    DragDropService.startFloatingDrag(event, itemId);
}

function handleFloatingDragEnd(event) {
    DragDropService.endDrag(event);
}

function handleCardDragOver(event) {
    DragDropService.handleColumnDragOver(event);
}

function handleCardDragLeave(event) {
    DragDropService.handleColumnDragLeave(event);
}

function handleCardDrop(event, targetColumnId) {
    DragDropService.handleColumnDrop(event, targetColumnId);
}

function handleCanvasDrop(event) {
    DragDropService.handleCanvasDrop(event);
}

function handleCanvasDragOver(event) {
    DragDropService.handleCanvasDragOver(event);
}

function handleCanvasDragLeave(event) {
    DragDropService.handleCanvasDragLeave(event);
}

// Panneau contextuel
function toggleArcContextPanel() {
    ArcBoardViewModel.toggleContextPanel();
}

function renderArcContextForItem(item) {
    ArcBoardView.renderContextPanel(item);
}

// Copy/Paste
function copySelectedItems() {
    ArcBoardViewModel.copy();
}

function pasteArcItem() {
    ArcBoardView._removeContextMenu();
    ArcBoardViewModel.paste();
}

// Menu contextuel
function showCanvasContextMenu(event) {
    ArcBoardView.showCanvasContextMenu(event);
}

function showArcContextMenu(event, arcId) {
    ArcBoardView.showArcContextMenu(event, arcId);
}

function removeContextMenu() {
    ArcBoardView._removeContextMenu();
}

// Scenes
function openSceneFromCard(event, sceneId) {
    if (event) {
        event.stopPropagation();
        event.preventDefault();
    }
    ArcBoardEventHandlers.openScene(sceneId);
}

// Formatage texte
function formatArcText(command) {
    document.execCommand(command, false, null);
}

function insertArcCode() {
    document.execCommand('insertHTML', false, '<code></code>');
}

// État global pour compatibilité
let arcBoardState = ArcBoardState;

// ============================================
// EXPORT (si module)
// ============================================
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        ArcBoardConfig,
        ArcCategories,
        CardTypes,
        BoardItemTypes,
        ToolTypes,
        DragTypes,
        ArcBoardState,
        ArcRepository,
        BoardItemRepository,
        CardRepository,
        ConnectionRepository,
        ArcBoardViewModel,
        ArcBoardView,
        DragDropService,
        ConnectionService,
        PanService,
        ResizeService,
        ItemMoveService,
        ArcBoardEventHandlers
    };
}

// ========== js-refactor/plotgrid/plot-grid.model.js ==========
/**
 * [MVVM : Plot Grid Model]
 * Factories and data structures for the Plot Grid Module.
 */

const PlotGridModel = {
    /**
     * Creates a new Plot Grid state.
     * @returns {Object} Initial state.
     */
    createState: function () {
        return {
            rows: [],      // Ordered list of row objects
            columns: [],   // Ordered list of column objects
            cards: [],     // All cards in the grid
            settings: {
                showStructure: true,
                syncEnabled: true
            }
        };
    },

    /**
     * Creates a Row object.
     * @param {Object} data 
     * @returns {Object}
     */
    createRow: function (data = {}) {
        const now = Date.now();
        return {
            id: data.id || 'pg_row_' + now + '_' + Math.random().toString(36).substr(2, 9),
            type: data.type || 'custom', // 'structure' | 'custom'
            structureId: data.structureId || null, // ID of Act/Chapter/Scene if type is structure
            structureType: data.structureType || null, // 'act' | 'chapter' | 'scene'
            title: data.title || 'New Row',
            order: data.order || 0,
            isCollapsed: false
        };
    },

    /**
     * Creates a Column object.
     * @param {Object} data 
     * @returns {Object}
     */
    createColumn: function (data = {}) {
        const now = Date.now();
        return {
            id: data.id || 'pg_col_' + now + '_' + Math.random().toString(36).substr(2, 9),
            type: data.type || 'custom', // 'structure' | 'custom'
            title: data.title || 'New Column',
            order: data.order || 0,
            width: data.width || 250
        };
    },

    /**
     * Creates a Card object.
     * @param {Object} data 
     * @returns {Object}
     */
    createCard: function (data = {}) {
        const now = Date.now();
        return {
            id: data.id || 'pg_card_' + now + '_' + Math.random().toString(36).substr(2, 9),
            rowId: data.rowId,
            colId: data.colId,
            title: data.title || '',
            content: data.content || '',
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString()
        };
    }
};

// ========== js-refactor/plotgrid/plot-grid.repository.js ==========
/**
 * [MVVM : Plot Grid Repository]
 * Persistence and Structure Synchronization.
 */

const PlotGridRepository = {
    /**
     * Initialize the repository.
     */
    init: function () {
        if (!project.plotGrid) {
            project.plotGrid = PlotGridModel.createState();
        }
        this.ensureStructureColumns();
    },

    /**
     * Ensure the mandatory "Structure" column exists.
     */
    ensureStructureColumns: function () {
        if (!project.plotGrid.columns.find(c => c.type === 'structure')) {
            const structCol = PlotGridModel.createColumn({
                title: 'Structure Narrative',
                type: 'structure',
                order: -1
            });
            project.plotGrid.columns.unshift(structCol);
        }
    },

    /**
     * Sync rows with project Acts/Chapters/Scenes.
     * Preserves existing rows and their IDs to keep card connections stable.
     */
    syncWithStructure: function () {
        if (!project.plotGrid) this.init();

        const structureRows = [];

        // Walk the structure - ONLY Scenes get rows
        project.acts.forEach((act, aIdx) => {
            act.chapters.forEach((chapter, cIdx) => {
                chapter.scenes.forEach((scene, sIdx) => {
                    let row = project.plotGrid.rows.find(r => r.structureId === scene.id && r.structureType === 'scene');
                    if (!row) {
                        row = PlotGridModel.createRow({
                            structureId: scene.id,
                            structureType: 'scene',
                            type: 'structure',
                            title: scene.title
                        });
                    } else {
                        row.title = scene.title;
                    }
                    row.parentActTitle = act.title;
                    row.parentChapterTitle = chapter.title;
                    row.isFirstInAct = (sIdx === 0 && cIdx === 0);
                    row.isFirstInChapter = (sIdx === 0);
                    row.synopsis = scene.synopsis || scene.title;

                    // Force the order based on manuscript position
                    // We'll normalize all orders at the end of this function anyway.
                    structureRows.push(row);
                });
            });
        });

        // Current rows in project.plotGrid.rows that are NOT in the new structureRows list
        // are either custom rows OR deleted scene rows.
        const customRows = project.plotGrid.rows.filter(r => r.type === 'custom');

        // Update structural rows order to match manuscript position.
        // We use a gap of 10 to allow custom rows to exist between them.
        structureRows.forEach((row, idx) => {
            row.order = idx * 10;
        });

        // Combined list
        const allRows = [...structureRows, ...customRows];

        // Sort everything by the updated order. 
        // In case of a tie, structural rows take precedence.
        allRows.sort((a, b) => {
            if (a.order !== b.order) return a.order - b.order;
            if (a.type === 'structure' && b.type !== 'structure') return -1;
            if (a.type !== 'structure' && b.type === 'structure') return 1;
            return 0;
        });

        // Final normalization: ensure orders are strictly 0, 10, 20...
        // This maintains the interleaving but cleans up the values.
        allRows.forEach((r, idx) => {
            r.order = idx * 10;
        });

        project.plotGrid.rows = allRows;
    },

    // --- CRUD Columns ---

    getColumns: function () {
        return project.plotGrid.columns.sort((a, b) => a.order - b.order);
    },

    addColumn: function (column) {
        project.plotGrid.columns.push(column);
        saveProject(); // Global save
        return column;
    },

    removeColumn: function (colId) {
        const idx = project.plotGrid.columns.findIndex(c => c.id === colId);
        if (idx !== -1) {
            project.plotGrid.columns.splice(idx, 1);
            // Also remove cards in this column
            project.plotGrid.cards = project.plotGrid.cards.filter(c => c.colId !== colId);
            saveProject();
        }
    },

    updateColumn: function (colId, updates) {
        const col = project.plotGrid.columns.find(c => c.id === colId);
        if (col) {
            Object.assign(col, updates);
            saveProject();
        }
        return col;
    },

    // --- CRUD Rows (Custom) ---

    getRows: function () {
        return project.plotGrid.rows.sort((a, b) => a.order - b.order);
    },

    addCustomRow: function (row) {
        project.plotGrid.rows.push(row);
        saveProject();
        return row;
    },

    removeRow: function (rowId) {
        const idx = project.plotGrid.rows.findIndex(r => r.id === rowId);
        if (idx !== -1) {
            project.plotGrid.rows.splice(idx, 1);
            // Also remove cards in this row
            project.plotGrid.cards = project.plotGrid.cards.filter(c => c.rowId !== rowId);
            saveProject();
        }
    },

    // --- CRUD Cards ---

    getCards: function () {
        return project.plotGrid.cards;
    },

    getCardsByRow: function (rowId) {
        return project.plotGrid.cards.filter(c => c.rowId === rowId);
    },

    /**
     * Ensure columns exist up to a certain count/index.
     */
    ensureColumnsUntil: function (count) {
        const currentCount = project.plotGrid.columns.length;
        if (currentCount >= count) return;

        for (let i = currentCount; i < count; i++) {
            this.addColumn(PlotGridModel.createColumn({
                title: 'Ligne sans titre',
                type: 'custom',
                order: i
            }));
        }
    },

    addCard: function (card) {
        // Find or create column if needed (if colId is an index)
        // Note: For simplicity, if colId is not found, we might need a way to target by index.
        // I'll adjust the view to pass both if available or use a better strategy.
        project.plotGrid.cards.push(card);
        saveProject();
        return card;
    },

    updateCard: function (cardId, updates) {
        const card = project.plotGrid.cards.find(c => c.id === cardId);
        if (card) {
            Object.assign(card, updates);
            card.updatedAt = new Date().toISOString();
            saveProject();
        }
        return card;
    },

    removeCard: function (cardId) {
        const idx = project.plotGrid.cards.findIndex(c => c.id === cardId);
        if (idx !== -1) {
            project.plotGrid.cards.splice(idx, 1);
            saveProject();
        }
    },

    /**
     * Special delete for Structure Rows: Only delete cards, do NOT delete the row itself (it's managed by sync).
     */
    clearRowCards: function (rowId) {
        const row = project.plotGrid.rows.find(r => r.id === rowId);
        if (!row) return;

        // Keep cards in the first column (structure column) ?? 
        // Actually, structure col usually doesn't have "Cards", it displays the scene.
        // But if we allowed cards there, we should be careful.
        // For now, let's assume cards are only in other columns.

        project.plotGrid.cards = project.plotGrid.cards.filter(c => c.rowId !== rowId);
        saveProject();
    }
};

// ========== js-refactor/plotgrid/plot-grid.viewmodel.js ==========
/**
 * [MVVM : Plot Grid ViewModel]
 * Business Logic for the Plot Grid View.
 */

const PlotGridViewModel = {
    init: function () {
        PlotGridRepository.init();
        // Always sync on init to catch up with structure changes
        PlotGridRepository.syncWithStructure();
    },

    getGridData: function () {
        return {
            columns: PlotGridRepository.getColumns(),
            rows: PlotGridRepository.getRows(),
            cards: PlotGridRepository.getCards()
        };
    },

    getCardsByRow: function (rowId) {
        return PlotGridRepository.getCardsByRow(rowId);
    },

    // --- Column Actions ---

    addNewColumn: function (title) {
        const col = PlotGridModel.createColumn({
            title: title || 'Nouvelle colonne',
            order: PlotGridRepository.getColumns().length
        });
        PlotGridRepository.addColumn(col);
        return col;
    },

    deleteColumn: function (colId) {
        const col = PlotGridRepository.getColumns().find(c => c.id === colId);
        if (!col) return;
        if (col.type === 'structure') {
            alert("Impossible de supprimer la colonne de structure.");
            return;
        }
        if (confirm(`Supprimer la colonne "${col.title}" et toutes ses cartes ?`)) {
            PlotGridRepository.removeColumn(colId);
            return true;
        }
        return false;
    },

    // --- Row Actions ---

    addNewCustomRow: function () {
        const rows = PlotGridRepository.getRows();
        const maxOrder = rows.length > 0 ? Math.max(...rows.map(r => r.order)) : -10;
        const row = PlotGridModel.createRow({
            title: 'Nouvelle ligne',
            type: 'custom',
            order: maxOrder + 10
        });
        PlotGridRepository.addCustomRow(row);
        return row;
    },

    /**
     * Handles the "Delete Row" action with the specific Guard Logic.
     */
    deleteRow: function (rowId) {
        const row = PlotGridRepository.getRows().find(r => r.id === rowId);
        if (!row) return;

        if (row.type === 'structure') {
            // Guard: Only clear cards, keep row (because it's tied to structure)
            if (confirm(`Cette ligne est liée à la scène/chapitre "${row.title}".\n\nVoulez-vous effacer toutes les cartes de cette ligne ?\n(La scène ne sera pas supprimée du manuscrit)`)) {
                PlotGridRepository.clearRowCards(rowId);
                return { action: 'cleared' };
            }
        } else {
            // Custom row: Full delete
            if (confirm(`Supprimer la ligne personnalisée "${row.title}" et ses cartes ?`)) {
                PlotGridRepository.removeRow(rowId);
                return { action: 'deleted' };
            }
        }
        return { action: 'cancelled' };
    },

    // --- Card Actions ---

    addCard: function (rowId, colIdOrIndex, title, content) {
        let colId = colIdOrIndex;

        // Check if colIdOrIndex is actually a numeric index (ghost column)
        if (typeof colIdOrIndex === 'number' || !isNaN(Number(colIdOrIndex))) {
            const index = Number(colIdOrIndex);
            PlotGridRepository.ensureColumnsUntil(index + 1);
            const cols = PlotGridRepository.getColumns();
            colId = cols[index].id;
        }

        const card = PlotGridModel.createCard({
            rowId,
            colId,
            title: title || "Élément sans titre",
            content
        });
        PlotGridRepository.addCard(card);
        return card;
    },

    updateColumnTitle: function (colId, newTitle) {
        PlotGridRepository.updateColumn(colId, { title: newTitle });
    },

    updateCard: function (cardId, data) {
        return PlotGridRepository.updateCard(cardId, data);
    },

    updateSceneSynopsis: function (sceneId, synopsis) {
        // Find scene in global project structure
        let found = false;
        project.acts.forEach(act => {
            act.chapters.forEach(chapter => {
                const scene = chapter.scenes.find(s => s.id === sceneId);
                if (scene) {
                    scene.synopsis = synopsis;
                    found = true;
                }
            });
        });
        if (found) {
            saveProject();
            PlotGridRepository.syncWithStructure(); // Update cache in repo
        }
    },

    updateCardPosition: function (cardId, newRowId, newColIndex) {
        // Ensure columns exist up to target
        PlotGridRepository.ensureColumnsUntil(newColIndex + 1);
        const cols = PlotGridRepository.getColumns();
        const newColId = cols[newColIndex].id;

        PlotGridRepository.updateCard(cardId, { rowId: newRowId, colId: newColId });
    },

    deleteCard: function (cardId) {
        if (confirm("Supprimer cette carte ?")) {
            PlotGridRepository.removeCard(cardId);
            return true;
        }
        return false;
    },

    insertRowAfter: function (rowId) {
        const rows = this.getGridData().rows;
        const index = rows.findIndex(r => r.id === rowId);
        if (index === -1) return;

        const currentRow = rows[index];
        const nextRow = rows[index + 1];

        let newOrder;
        if (nextRow) {
            newOrder = (currentRow.order + nextRow.order) / 2;
        } else {
            newOrder = currentRow.order + 10;
        }

        const newRow = PlotGridModel.createRow({
            title: 'Nouvelle ligne',
            type: 'custom',
            order: newOrder
        });
        PlotGridRepository.addCustomRow(newRow);
        return newRow;
    },

    /**
     * Converts a custom row into a real manuscript scene.
     */
    convertRowToScene: function (rowId) {
        const rows = this.getGridData().rows;
        const rowIdx = rows.findIndex(r => r.id === rowId);
        if (rowIdx === -1) return;

        const targetRow = rows[rowIdx];
        if (targetRow.type !== 'custom') return;

        // 1. Find the nearest preceding structural row to know where to insert in the manuscript
        let precedingSceneId = null;
        for (let i = rowIdx - 1; i >= 0; i--) {
            if (rows[i].type === 'structure' && rows[i].structureType === 'scene') {
                precedingSceneId = rows[i].structureId;
                break;
            }
        }

        // 2. Insert scene into project structure
        let newScene = null;
        if (!precedingSceneId) {
            // No preceding scene? Add to first chapter of first act
            const firstChapter = project.acts[0]?.chapters[0];
            if (firstChapter) {
                newScene = createScene('Scène sans titre');
                firstChapter.scenes.unshift(newScene);
            }
        } else {
            // Find preceding scene location
            project.acts.forEach(act => {
                act.chapters.forEach(chapter => {
                    const sIdx = chapter.scenes.findIndex(s => s.id === precedingSceneId);
                    if (sIdx !== -1) {
                        newScene = createScene('Scène sans titre');
                        chapter.scenes.splice(sIdx + 1, 0, newScene);
                    }
                });
            });
        }

        if (newScene) {
            // 3. Link the row to the new scene and change its type
            targetRow.type = 'structure';
            targetRow.structureType = 'scene';
            targetRow.structureId = newScene.id;
            targetRow.title = newScene.title;

            saveProject();
            PlotGridRepository.syncWithStructure();
            return newScene;
        }
    }
};

// ========== js-refactor/plotgrid/plot-grid.import-export.js ==========
/**
 * [MVVM : Plot Grid Import/Export]
 * Handles Excel export and import for the Plot Grid.
 */

const PlotGridImportExport = {
    /**
     * Exports the Plot Grid to an Excel file.
     */
    exportToExcel: function () {
        const data = PlotGridViewModel.getGridData();
        const columns = data.columns;
        const rows = data.rows;
        const cards = data.cards;

        // 1. Prepare Headers
        // We'll have: Act, Chapter, Scene, Synopsis, then each custom column
        const headers = ["Acte", "Chapitre", "Scène", "Résumé"];
        const customColumns = columns.filter(c => c.type !== 'structure');
        customColumns.forEach(col => headers.push(col.titulo || col.title));

        const excelData = [headers];

        // 2. Prepare Rows
        rows.forEach(row => {
            const excelRow = [];

            if (row.type === 'structure') {
                excelRow.push(row.parentActTitle || "");
                excelRow.push(row.parentChapterTitle || "");
                excelRow.push(row.title || "");
                excelRow.push(row.synopsis || "");
            } else {
                excelRow.push("");
                excelRow.push("");
                excelRow.push(row.title || "Ligne personnalisée");
                excelRow.push("");
            }

            // Cards for custom columns
            customColumns.forEach(col => {
                const card = cards.find(c => c.rowId === row.id && c.colId === col.id);
                if (card) {
                    const cellTitle = card.title || "Sans titre";
                    const cellContent = card.content || "";
                    excelRow.push(cellContent ? `${cellTitle}\n${cellContent}` : cellTitle);
                } else {
                    excelRow.push("");
                }
            });

            excelData.push(excelRow);
        });

        // 3. Create XLSX
        const wb = XLSX.utils.book_new();
        const ws = XLSX.utils.aoa_to_sheet(excelData);

        // Auto-width (simple)
        const wscols = headers.map(h => ({ wch: Math.max(h.length, 15) }));
        ws['!cols'] = wscols;

        XLSX.utils.book_append_sheet(wb, ws, "Grille d'intrigue");

        // 4. Download
        const fileName = `Grille_Intrigue_${project.title || 'Export'}_${new Date().toISOString().slice(0, 10)}.xlsx`;
        XLSX.writeFile(wb, fileName);
    },

    /**
     * Triggers the Excel import process.
     */
    importFromExcel: function (file) {
        const reader = new FileReader();
        reader.onload = (e) => {
            const data = new Uint8Array(e.target.result);
            const workbook = XLSX.read(data, { type: 'array' });
            const sheetName = workbook.SheetNames[0];
            const worksheet = workbook.Sheets[sheetName];
            const json = XLSX.utils.sheet_to_json(worksheet, { header: 1 });

            if (json.length < 1) {
                alert("Le fichier semble vide.");
                return;
            }

            this.processImportData(json);
        };
        reader.readAsArrayBuffer(file);
    },

    /**
     * Processes the JSON data from Excel and updates the Plot Grid.
     * @param {Array[]} data 2D array from Excel
     */
    processImportData: function (data) {
        const headers = data[0];
        const rowsData = data.slice(1);

        // Map standard columns
        const actIdx = headers.indexOf("Acte");
        const chapIdx = headers.indexOf("Chapitre");
        const sceneIdx = headers.indexOf("Scène");
        const synIdx = headers.indexOf("Résumé");

        if (sceneIdx === -1) {
            alert("Erreur : Impossible de trouver la colonne 'Scène' dans le fichier Excel.");
            return;
        }

        // Identify custom columns (starting from index 4 or based on headers not in standard list)
        const standardHeaders = ["Acte", "Chapitre", "Scène", "Résumé"];
        const customColMappings = []; // { title, index, colId }

        headers.forEach((h, idx) => {
            if (!standardHeaders.includes(h) && h) {
                // Check if column already exists in Plot Grid, or create it
                let col = project.plotGrid.columns.find(c => c.title === h || c.titulo === h);
                if (!col) {
                    col = PlotGridViewModel.addNewColumn(h);
                }
                customColMappings.push({ title: h, index: idx, colId: col.id });
            }
        });

        let updatedCount = 0;
        let createdCards = 0;

        // Process rows
        rowsData.forEach(rowData => {
            const sceneTitle = rowData[sceneIdx];
            if (!sceneTitle) return;

            // Find matching row in Plot Grid
            // Priority: Match by Scene title, but also check Act and Chapter to be sure
            let targetRow = project.plotGrid.rows.find(r => {
                const matchScene = r.title === sceneTitle;
                if (!matchScene) return false;

                if (r.type === 'structure') {
                    const matchAct = actIdx !== -1 ? (r.parentActTitle === rowData[actIdx]) : true;
                    const matchChap = chapIdx !== -1 ? (r.parentChapterTitle === rowData[chapIdx]) : true;
                    return matchAct && matchChap;
                }
                return true;
            });

            if (!targetRow) {
                // If not found, we could potentially create a custom row, but maybe it's better to stay safe
                return;
            }

            // Update Synopsis if structural
            if (targetRow.type === 'structure' && synIdx !== -1 && rowData[synIdx]) {
                PlotGridViewModel.updateSceneSynopsis(targetRow.structureId, rowData[synIdx]);
            }

            // Update/Create Cards for custom columns
            customColMappings.forEach(mapping => {
                const content = rowData[mapping.index];
                if (content === undefined || content === null) return;

                const existingCard = project.plotGrid.cards.find(c => c.rowId === targetRow.id && c.colId === mapping.colId);

                // Logic to split title and content from the Excel cell
                const cellText = String(content).trim();
                if (cellText === "") return;

                const lines = cellText.split('\n');
                const newTitle = lines[0].trim();
                const newContent = lines.slice(1).join('\n').trim();

                if (existingCard) {
                    if (existingCard.content !== newContent || existingCard.title !== newTitle) {
                        PlotGridViewModel.updateCard(existingCard.id, {
                            title: newTitle || "Note",
                            content: newContent
                        });
                        updatedCount++;
                    }
                } else {
                    PlotGridViewModel.addCard(targetRow.id, mapping.colId, newTitle || "Note", newContent);
                    createdCards++;
                }
            });
        });

        alert(`Importation terminée !\nCartes mises à jour : ${updatedCount}\nNouvelles cartes : ${createdCards}`);

        // Refresh UI
        if (typeof PlotGridUI !== 'undefined') {
            PlotGridUI.conditionalRender();
        }
    }
};

// ========== js-refactor/plotgrid/plot-grid.view.js ==========
/**
 * [MVVM : Plot Grid View]
 * DOM Rendering for the Plot Grid.
 */

const PlotGridUI = {
    activeModalCardId: null,
    activeModalSceneId: null,
    draggedCardId: null,

    /**
     * Helper to rerender the Plot Grid ONLY if it's currently visible.
     * Also refreshes the sidebar if it's open.
     */
    conditionalRender: function () {
        const isPlotGridView = (typeof currentView !== 'undefined' && (currentView === 'plotgrid' || currentView === 'plot-grid' || currentView === 'plot'));
        const isSplitPlotGrid = (typeof splitViewActive !== 'undefined' && splitViewActive &&
            (splitViewState.left.view === 'plotgrid' || splitViewState.left.view === 'plot' ||
                splitViewState.right.view === 'plotgrid' || splitViewState.right.view === 'plot'));

        if (isPlotGridView || isSplitPlotGrid) {
            this.render();
        }

        // Always refresh sidebar if it's open
        const sidebar = document.getElementById('sidebarPlot');
        if (sidebar && !sidebar.classList.contains('hidden')) {
            this.renderSidebar(typeof currentSceneId !== 'undefined' ? currentSceneId : null);
        }
    },

    render: function () {
        const container = document.getElementById('editorView');
        if (!container) return;

        PlotGridViewModel.init();
        const data = PlotGridViewModel.getGridData();

        // Ensure we always have at least some columns/rows for the "Ghost" effect
        const ghostColumnCount = Math.max(data.columns.length + 5, 10);

        container.innerHTML = `
            <div class="plot-grid-container">
                <style>
                    .plot-grid-container {
                        display: flex;
                        flex-direction: column;
                        height: 100%;
                        background: var(--bg-tertiary);
                        overflow: hidden;
                        position: relative;
                    }
                    .plot-grid-toolbar {
                        padding: 10px 20px;
                        background: var(--bg-secondary);
                        display: flex;
                        gap: 15px;
                        border-bottom: 1px solid var(--border-color);
                        align-items: center;
                    }
                    .plot-grid-wrapper {
                        flex: 1;
                        overflow: auto;
                        display: grid;
                        grid-template-columns: 30px 200px repeat(${ghostColumnCount - 1}, 180px); 
                        padding: 20px 40px;
                        gap: 20px 30px; /* Dabble spacing */
                    }
                    
                    /* Headers */
                    .pg-header-cell {
                        background: transparent;
                        padding: 10px;
                        font-size: 1.1rem;
                        font-weight: bolder;
                        color: var(--text-muted);
                        text-align: center;
                        position: sticky;
                        top: 0;
                        z-index: 10;
                    }
                    .pg-col-header-container {
                        display: flex;
                        align-items: center;
                        gap: 5px;
                        justify-content: center;
                    }
                    .pg-header-input {
                        background: transparent;
                        border: none;
                        border-bottom: 1px solid transparent;
                        color: inherit;
                        text-align: center;
                        width: 100%;
                        font-family: inherit;
                        font-size: 1.1rem;
                        font-weight: bolder;
                    }
                    .pg-header-input:hover, .pg-header-input:focus {
                        border-bottom-color: var(--primary-color);
                        outline: none;
                    }
                    .pg-ghost-header::placeholder {
                        font-style: italic;
                        color: var(--text-muted);
                        opacity: 0.7;
                    }
                    .pg-ghost-header {
                        opacity: 0.6;
                    }
                    .pg-ghost-header:hover, .pg-ghost-header:focus, .pg-ghost-header.editing {
                        opacity: 1;
                    }
                    .pg-col-delete-btn {
                        opacity: 0;
                        cursor: pointer;
                        color: var(--text-muted);
                        transition: opacity 0.2s, color 0.2s;
                        font-size: 0.8rem;
                        display: flex;
                        align-items: center;
                    }
                    .pg-header-cell:hover .pg-col-delete-btn {
                        opacity: 1;
                    }
                    .pg-col-delete-btn:hover {
                        color: var(--accent-red);
                    }
                    .pg-gutter-cell {
                        width: 30px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        position: relative;
                    }

                    /* Cards */
                    .pg-cell {
                        min-height: 110px;
                        position: relative;
                    }
                    .dabble-act-label {
                        font-size: 0.75rem;
                        font-weight: bold;
                        color: white;
                        background: var(--bg-accent);
                        padding: 4px 12px;
                        display: inline-block;
                        border-radius: 4px;
                        position: absolute;
                        top: -55px;
                        left: -90px;
                        text-transform: uppercase;
                        letter-spacing: 0.5px;
                        z-index: 5;
                        white-space: nowrap;
                    }
                    .dabble-chapter-label {
                        font-size: 0.7rem;
                        font-weight: bold;
                        color: var(--text-primary);
                        background: var(--bg-primary);
                        border: 1px solid var(--border-color);
                        padding: 3px 10px;
                        display: inline-block;
                        border-radius: 4px;
                        position: absolute;
                        top: -25px;
                        left: -50px;
                        white-space: nowrap;
                    }

                    .pg-card {
                        background: var(--bg-primary);
                        border: 1px solid var(--border-color);
                        border-radius: 2px;
                        padding: 12px;
                        height: 90px; /* Fixed height for all cards */
                        box-shadow: 0 2px 4px var(--shadow);
                        cursor: pointer;
                        display: flex;
                        flex-direction: column;
                        justify-content: flex-start;
                        text-align: left;
                        font-size: 0.85rem;
                        color: var(--text-primary);
                        position: relative;
                        transition: transform 0.2s, box-shadow 0.2s;
                        overflow: hidden;
                    }
                    .pg-card:hover {
                        box-shadow: 0 4px 8px rgba(0,0,0,0.15);
                        transform: translateY(-2px);
                    }
                    .pg-card.structure-card {
                        font-style: italic;
                        color: var(--text-secondary);
                        border-top: 5px solid var(--accent-gold);
                    }
                    .pg-card-title {
                        font-weight: bold;
                        margin-bottom: 4px;
                        padding-right: 15px; /* Space for X */
                        display: -webkit-box;
                        -webkit-line-clamp: 2;
                        -webkit-box-orient: vertical;
                        overflow: hidden;
                    }
                    .pg-card-delete {
                        position: absolute;
                        top: 5px;
                        right: 5px;
                        width: 16px;
                        height: 16px;
                        background: rgba(var(--bg-accent-rgb), 0.05);
                        border-radius: 50%;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-size: 10px;
                        color: var(--text-muted);
                        opacity: 0;
                        transition: opacity 0.2s, background 0.2s;
                        cursor: pointer;
                        z-index: 5;
                    }
                    .pg-card:hover .pg-card-delete {
                        opacity: 1;
                    }
                    .pg-card-delete:hover {
                        background: var(--accent-red);
                        color: white;
                    }
                    .pg-card-content {
                        font-size: 0.8rem;
                        color: var(--text-muted);
                        display: -webkit-box;
                        -webkit-line-clamp: 2;
                        -webkit-box-orient: vertical;
                        overflow: hidden;
                    }
                    
                    .pg-add-btn:hover { color: #666; }
                    
                    /* Cell addition button - BOXED STYLE */
                    .pg-cell.ghost { background: transparent; }
                    .pg-add-btn {
                        position: absolute;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        width: 18px;
                        height: 18px;
                        border: 1px solid var(--border-color);
                        border-radius: 2px;
                        background: var(--bg-primary);
                        color: var(--text-muted);
                        font-size: 14px;
                        cursor: pointer;
                        opacity: 0;
                        transition: all 0.2s;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        z-index: 2;
                    }
                    .pg-cell:hover .pg-add-btn { opacity: 1; }
                    .pg-add-btn:hover {
                        border-color: var(--text-muted);
                        color: var(--text-primary);
                        box-shadow: 0 1px 3px var(--shadow);
                    }

                    /* Row Insertion Handle - GUTTER STYLE */
                    .pg-row-divider {
                        grid-column: 1; /* Only in gutter */
                        width: 30px;
                        height: 100%;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        position: relative;
                    }
                    .pg-row-insert-btn {
                        width: 18px;
                        height: 18px;
                        background: var(--bg-primary);
                        border: 1px solid var(--border-color);
                        border-radius: 2px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        color: var(--text-muted);
                        cursor: pointer;
                        opacity: 0;
                        transition: all 0.2s;
                        font-size: 14px;
                        font-weight: bold;
                        z-index: 21;
                    }
                    .pg-gutter-cell:hover .pg-row-insert-btn,
                    .pg-row-divider:hover .pg-row-insert-btn {
                        opacity: 1;
                    }
                    .pg-row-insert-btn:hover {
                        border-color: var(--text-muted);
                        color: var(--text-primary);
                        transform: scale(1.1);
                        box-shadow: 0 1px 3px var(--shadow);
                    }

                    /* Scene Ghost */
                    .pg-scene-ghost {
                        border: 2px dashed var(--border-color) !important;
                        background: rgba(var(--bg-primary-rgb), 0.5) !important;
                        justify-content: center !important;
                        align-items: center !important;
                        color: var(--text-muted) !important;
                        font-style: italic;
                    }

                    /* MODAL Dabble Style */

                    /* MODAL Dabble Style */
                    #pgModalOverlay {
                        position: fixed;
                        top: 0; left: 0; right: 0; bottom: 0;
                        background: rgba(var(--bg-accent-rgb), 0.4);
                        z-index: 1000;
                        display: none;
                        align-items: center;
                        justify-content: center;
                        backdrop-filter: blur(2px);
                    }
                    #pgModal {
                        background: var(--bg-primary);
                        width: 500px;
                        height: 600px;
                        box-shadow: 0 10px 40px var(--shadow);
                        display: flex;
                        flex-direction: column;
                        padding: 40px;
                        border-radius: 4px;
                        position: relative;
                        transform: scale(0.5);
                        opacity: 0;
                        transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
                    }
                    #pgModal.open {
                        transform: scale(1);
                        opacity: 1;
                    }
                    .pg-modal-title {
                        font-size: 1.5rem;
                        font-weight: bold;
                        border: none;
                        border-bottom: 2px solid var(--accent-gold);
                        outline: none;
                        width: 100%;
                        margin-bottom: 20px;
                        background: transparent;
                        line-height: 1.2;
                        color: var(--text-primary);
                    }
                    .pg-modal-content {
                        flex: 1;
                        border: none;
                        outline: none;
                        width: 100%;
                        resize: none;
                        background: transparent;
                        font-family: inherit;
                        font-size: 1rem;
                        color: var(--text-secondary);
                    }
                    .pg-modal-footer {
                        display: flex;
                        justify-content: flex-end;
                        padding-top: 10px;
                        gap: 10px;
                    }
                    .pg-modal-close {
                        position: absolute;
                        top: 10px; right: 10px;
                        cursor: pointer;
                        font-size: 24px;
                        color: var(--text-muted);
                    }
                </style>

                <div class="plot-grid-toolbar">
                    <h2 style="margin: 0; font-size: 1.2rem; color: var(--text-primary); flex: 1;">Grille d'intrigue pour ${project.title || 'Livre sans titre'}</h2>
                    
                    <button class="btn btn-secondary" onclick="renderPlotGridView()"><i data-lucide="refresh-cw" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Rafraîchir</button>
                    
                    <div style="display: flex; gap: 5px; border-left: 1px solid var(--border-color); padding-left: 15px; margin-left: 5px;">
                        <button class="btn btn-secondary" onclick="PlotGridImportExport.exportToExcel()" title="Exporter vers Excel">
                            <i data-lucide="download" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Exporter
                        </button>
                        
                        <button class="btn btn-secondary" onclick="document.getElementById('pgImportFile').click()" title="Importer depuis Excel">
                            <i data-lucide="upload" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Importer
                        </button>
                        <input type="file" id="pgImportFile" style="display: none;" accept=".xlsx, .xls" onchange="PlotGridImportExport.importFromExcel(this.files[0])">
                    </div>

                    ${typeof lucide !== 'undefined' ? '<i data-lucide="help-circle" title="Faites glisser les cartes (col 2+); Cliquez pour éditer; Les scènes éditent le résumé."></i>' : ''}
                </div>

                <div class="plot-grid-wrapper" id="pgWrapper">
                    ${this.generateGridHTML(data, ghostColumnCount)}
                </div>

                <div id="pgModalOverlay" onclick="PlotGridUI.closeCardModal(event)">
                    <div id="pgModal" onclick="event.stopPropagation()">
                        <span class="pg-modal-close" onclick="PlotGridUI.closeCardModal()"><i data-lucide="x" style="width:20px;height:20px;"></i></span>
                        <input type="text" id="pgModalTitleInput" class="pg-modal-title" placeholder="Titre">
                        <textarea id="pgModalContentInput" class="pg-modal-content" placeholder="Zone d'écriture..."></textarea>
                        <div class="pg-modal-footer">
                            <button id="pgModalDeleteBtn" class="btn btn-danger btn-sm" style="display:none;" onclick="PlotGridUI.deleteActiveCard()">Supprimer la Carte</button>
                            <button class="btn btn-primary btn-sm" onclick="PlotGridUI.closeCardModal(null, true)">Enregistrer & Fermer</button>
                        </div>
                    </div>
                </div>
            </div>
        `;

        if (typeof lucide !== 'undefined') lucide.createIcons();
    },

    /**
     * Ensures the plot modal HTML exists in the DOM.
     * Needed when opening cards from the sidebar outside the Plot Grid view.
     */
    ensureModalExists: function () {
        if (document.getElementById('pgModalOverlay')) return;

        const modalHTML = `
            <div id="pgModalOverlay" onclick="PlotGridUI.closeCardModal(event)">
                <div id="pgModal" onclick="event.stopPropagation()">
                    <span class="pg-modal-close" onclick="PlotGridUI.closeCardModal()"><i data-lucide="x" style="width:20px;height:20px;"></i></span>
                    <input type="text" id="pgModalTitleInput" class="pg-modal-title" placeholder="Titre">
                    <textarea id="pgModalContentInput" class="pg-modal-content" placeholder="Zone d'écriture..."></textarea>
                    <div class="pg-modal-footer">
                        <button id="pgModalDeleteBtn" class="btn btn-danger btn-sm" style="display:none;" onclick="PlotGridUI.deleteActiveCard()">Supprimer la Carte</button>
                        <button class="btn btn-primary btn-sm" onclick="PlotGridUI.closeCardModal(null, true)">Enregistrer & Fermer</button>
                    </div>
                </div>
            </div>
        `;
        document.body.insertAdjacentHTML('beforeend', modalHTML);

        // Inject styles if they don't exist
        if (!document.getElementById('pgModalStyles')) {
            const style = document.createElement('style');
            style.id = 'pgModalStyles';
            style.textContent = `
                #pgModalOverlay {
                    position: fixed;
                    top: 0; left: 0; right: 0; bottom: 0;
                    background: rgba(var(--bg-accent-rgb), 0.4);
                    z-index: 10000;
                    display: none;
                    align-items: center;
                    justify-content: center;
                    backdrop-filter: blur(2px);
                }
                #pgModal {
                    background: var(--bg-primary);
                    width: 500px;
                    max-height: 90vh;
                    box-shadow: 0 10px 40px var(--shadow);
                    display: flex;
                    flex-direction: column;
                    padding: 40px;
                    border-radius: 4px;
                    position: relative;
                    transform: scale(0.5);
                    opacity: 0;
                    transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
                }
                #pgModal.open {
                    transform: scale(1);
                    opacity: 1;
                }
                .pg-modal-title {
                    font-size: 1.5rem;
                    font-weight: bold;
                    border: none;
                    border-bottom: 2px solid var(--accent-gold);
                    outline: none;
                    width: 100%;
                    margin-bottom: 20px;
                    background: transparent;
                    line-height: 1.2;
                    color: var(--text-primary);
                }
                .pg-modal-content {
                    flex: 1;
                    border: none;
                    outline: none;
                    width: 100%;
                    min-height: 300px;
                    resize: none;
                    background: transparent;
                    font-family: inherit;
                    font-size: 1rem;
                    color: var(--text-secondary);
                }
                .pg-modal-footer {
                    display: flex;
                    justify-content: flex-end;
                    padding-top: 20px;
                    gap: 10px;
                }
                .pg-modal-close {
                    position: absolute;
                    top: 10px; right: 10px;
                    cursor: pointer;
                    font-size: 24px;
                    color: var(--text-muted);
                    line-height: 1;
                }
            `;
            document.head.appendChild(style);
        }
    },

    generateGridHTML: function (data, ghostColumnCount) {
        let html = '';

        // Headers
        html += `<div class="pg-header-cell pg-gutter-cell"></div>`;
        for (let i = 0; i < ghostColumnCount; i++) {
            const col = data.columns[i];
            let content = '';
            if (col) {
                const title = col.type === 'structure' ? 'Scènes' : col.title;
                const editable = col.type !== 'structure';
                content = `
                    <div class="pg-col-header-container">
                        ${editable ? `<input class="pg-header-input" value="${title}" onblur="PlotGridUI.updateColTitle('${col.id}', this.value)">` : `<span>${title}</span>`}
                        ${editable ? `<span class="pg-col-delete-btn" onclick="PlotGridUI.deleteColumn('${col.id}')" title="Supprimer la ligne d'intrigue"><i data-lucide="trash-2"></i></span>` : ''}
                    </div>
                `;
            } else {
                // Ghost column - editable to create a new column with custom title
                content = `
                    <div class="pg-col-header-container">
                        <input class="pg-header-input pg-ghost-header"
                               value=""
                               placeholder="Ligne sans titre"
                               onfocus="this.classList.add('editing')"
                               onblur="PlotGridUI.createColumnFromGhost(${i}, this.value); this.classList.remove('editing')">
                    </div>
                `;
            }
            html += `<div class="pg-header-cell ${col?.type === 'structure' ? 'structure' : ''}">${content}</div>`;
        }

        // Rows
        data.rows.forEach((row, rIdx) => {
            // Column 0 : Gutter
            html += `
                <div class="pg-gutter-cell">
                    <div class="pg-row-insert-btn" style="position: absolute; top: -10px;" onclick="PlotGridUI.insertRowBefore('${row.id}')" title="Insérer une ligne au-dessus">+</div>
                    ${rIdx === data.rows.length - 1 ? `<div class="pg-row-insert-btn" style="position: absolute; bottom: -10px;" onclick="PlotGridUI.insertRowAfter('${row.id}')" title="Insérer une ligne en dessous">+</div>` : ''}
                </div>
            `;

            for (let i = 0; i < ghostColumnCount; i++) {
                const col = data.columns[i];
                if (i === 0) {
                    // STRUCTURE Column
                    if (row.type === 'structure') {
                        html += `
                            <div class="pg-cell" ondragover="event.preventDefault()">
                                ${row.isFirstInAct ? `<div class="dabble-act-label">${row.parentActTitle}</div>` : ''}
                                ${row.isFirstInChapter ? `<div class="dabble-chapter-label">${row.parentChapterTitle}</div>` : ''}
                                <div class="pg-card structure-card" onclick="PlotGridUI.openSceneModal('${row.structureId}', this)">
                                    <div class="pg-card-title">${row.title}</div>
                                    <div class="pg-card-content">${row.synopsis || "Pas de résumé."}</div>
                                </div>
                            </div>
                        `;
                    } else {
                        // Custom Row Structural Column -> GHOST SCENE
                        html += `
                            <div class="pg-cell">
                                <div class="pg-card structure-card pg-scene-ghost" onclick="PlotGridUI.createSceneFromRow('${row.id}')">
                                    <span class="pg-card-delete" onclick="event.stopPropagation(); PlotGridUI.deleteCustomRow('${row.id}')" title="Supprimer la ligne"><i data-lucide="x" style="width:12px;height:12px;"></i></span>
                                    <div style="font-size: 18px; margin-bottom: 5px;">+</div>
                                    <div style="font-size: 0.8rem;">Scène sans titre</div>
                                </div>
                            </div>
                        `;
                    }
                } else {
                    // DATA or GHOST
                    const cellCards = col ? data.cards.filter(c => c.rowId === row.id && c.colId === col.id) : [];
                    html += `
                        <div class="pg-cell ${!col ? 'ghost' : ''}" 
                             ondragover="PlotGridUI.handleDragOver(event)" 
                             ondragleave="PlotGridUI.handleDragLeave(event)"
                             ondrop="PlotGridUI.handleDrop(event, '${row.id}', ${i})">
                            ${cellCards.map(card => `
                                <div class="pg-card" 
                                    draggable="true" 
                                    ondragstart="PlotGridUI.handleDragStart(event, '${card.id}')"
                                    onclick="PlotGridUI.openCardModal('${card.id}', this)">
                                    <span class="pg-card-delete" onclick="event.stopPropagation(); PlotGridUI.deleteCardQuickly('${card.id}')" title="Supprimer la carte"><i data-lucide="x" style="width:12px;height:12px;"></i></span>
                                    <div class="pg-card-title">${card.title}</div>
                                    <div class="pg-card-content">${card.content || ""}</div>
                                </div>
                            `).join('')}
                            ${cellCards.length === 0 ? `<button class="pg-add-btn" onclick="PlotGridUI.addCardAt('${row.id}', ${i})">+</button>` : ''}
                        </div>
                    `;
                }
            }
        });

        return html;
    },

    // --- Actions ---

    updateColTitle: function (colId, newTitle) {
        if (PlotGridViewModel.updateColumnTitle(colId, newTitle)) {
            this.conditionalRender();
        }
    },

    /**
     * Creates a new column from a ghost header when user types a custom title.
     * @param {number} colIndex - The visual column index
     * @param {string} title - The title entered by the user
     */
    createColumnFromGhost: function (colIndex, title) {
        // Only create if user entered a non-empty title
        if (!title || !title.trim()) return;

        // Get current columns to check if we need to fill gaps
        const columns = PlotGridViewModel.getGridData().columns;

        // Ensure all columns up to colIndex exist
        PlotGridRepository.ensureColumnsUntil(colIndex + 1);

        // Get the newly created column and update its title
        const updatedColumns = PlotGridViewModel.getGridData().columns;
        const targetCol = updatedColumns[colIndex];
        if (targetCol) {
            PlotGridViewModel.updateColumnTitle(targetCol.id, title.trim());
        }

        this.conditionalRender();
    },

    addCardAt: function (rowId, colIndex) {
        // Will create columns if necessary thanks to ViewModel update
        const title = "Sans titre";
        const card = PlotGridViewModel.addCard(rowId, colIndex, title, "");
        this.conditionalRender(); // Rerender
        // Optionnal: open modal immediately
        this.openCardModal(card.id);
    },

    insertRowBefore: function (rowId) {
        const rows = PlotGridViewModel.getGridData().rows;
        const idx = rows.findIndex(r => r.id === rowId);
        if (idx === -1) return;

        let newOrder;
        if (idx === 0) {
            newOrder = rows[0].order - 10;
        } else {
            newOrder = (rows[idx - 1].order + rows[idx].order) / 2;
        }

        const newRow = PlotGridModel.createRow({
            title: 'Nouvelle ligne',
            type: 'custom',
            order: newOrder
        });
        PlotGridRepository.addCustomRow(newRow);
        this.conditionalRender();
    },

    insertRowAfter: function (rowId) {
        PlotGridViewModel.insertRowAfter(rowId);
        this.conditionalRender();
    },

    createSceneFromRow: function (rowId) {
        if (PlotGridViewModel.convertRowToScene(rowId)) {
            this.conditionalRender();
        }
    },

    deleteCustomRow: function (rowId) {
        if (PlotGridViewModel.deleteRow(rowId).action === 'deleted') {
            this.conditionalRender();
        }
    },

    openCardModal: function (cardId, element) {
        const card = PlotGridViewModel.getGridData().cards.find(c => c.id === cardId);
        if (!card) return;

        this.activeModalCardId = cardId;
        this.activeModalSceneId = null;
        this.showModal(card.title, card.content, element);
    },

    openSceneModal: function (sceneId, element) {
        let foundScene = null;
        project.acts.forEach(a => { a.chapters.forEach(c => { const s = c.scenes.find(sc => sc.id === sceneId); if (s) foundScene = s; }); });
        if (!foundScene) return;

        this.activeModalSceneId = sceneId;
        this.activeModalCardId = null;
        this.showModal(foundScene.title, foundScene.synopsis || "", element);

        // Disable title editing for scenes, they are structural.
        document.getElementById('pgModalTitleInput').readOnly = true;
        document.getElementById('pgModalDeleteBtn').style.display = 'none';
    },

    showModal: function (title, content, element) {
        const overlay = document.getElementById('pgModalOverlay');
        const modal = document.getElementById('pgModal');
        const titleInput = document.getElementById('pgModalTitleInput');
        const contentInput = document.getElementById('pgModalContentInput');
        const delBtn = document.getElementById('pgModalDeleteBtn');

        titleInput.value = title;
        titleInput.readOnly = false;
        contentInput.value = content;
        delBtn.style.display = this.activeModalCardId ? 'block' : 'none';

        if (element) {
            const rect = element.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            modal.style.transformOrigin = `${centerX}px ${centerY}px`;
        } else {
            modal.style.transformOrigin = 'center center';
        }

        overlay.style.display = "flex";
        setTimeout(() => modal.classList.add('open'), 10);
    },

    closeCardModal: function (event, forceSave = false) {
        if (!forceSave && event && event.target !== document.getElementById('pgModalOverlay') && event.target.className !== 'pg-modal-close') return;

        const modal = document.getElementById('pgModal');
        const overlay = document.getElementById('pgModalOverlay');
        const newTitle = document.getElementById('pgModalTitleInput').value;
        const newContent = document.getElementById('pgModalContentInput').value;

        if (this.activeModalCardId) {
            PlotGridViewModel.updateCard(this.activeModalCardId, { title: newTitle, content: newContent });
        } else if (this.activeModalSceneId) {
            PlotGridViewModel.updateSceneSynopsis(this.activeModalSceneId, newContent);
        }

        modal.classList.remove('open');
        setTimeout(() => {
            overlay.style.display = "none";
            this.activeModalCardId = null;
            this.activeModalSceneId = null;
            this.conditionalRender();
        }, 300);
    },

    deleteActiveCard: function () {
        if (this.activeModalCardId && PlotGridViewModel.deleteCard(this.activeModalCardId)) {
            this.activeModalCardId = null;
            this.closeCardModal(null, true);
        }
    },

    deleteCardQuickly: function (cardId) {
        if (PlotGridViewModel.deleteCard(cardId)) {
            this.conditionalRender();
        }
    },

    deleteColumn: function (colId) {
        if (PlotGridViewModel.deleteColumn(colId)) {
            this.conditionalRender();
        }
    },

    // --- Sidebar Integration ---
    toggleSidebar: function () {
        const sidebar = document.getElementById('sidebarPlot');
        const toolBtn = document.getElementById('toolPlotBtn');
        const sidebarBtn = document.getElementById('sidebarPlotBtn');
        if (!sidebar) return;

        const isHidden = sidebar.classList.toggle('hidden');
        if (!isHidden && currentSceneId) {
            this.renderSidebar(currentSceneId);
            if (toolBtn) toolBtn.classList.add('active');
            if (sidebarBtn) sidebarBtn.classList.add('active');
        } else {
            if (toolBtn) toolBtn.classList.remove('active');
            if (sidebarBtn) sidebarBtn.classList.remove('active');
        }

        // Refresh icons
        if (typeof lucide !== 'undefined') lucide.createIcons();
    },

    renderSidebar: function (sceneId) {
        const container = document.getElementById('plotSidebarList');
        const sceneNameEl = document.getElementById('plotSidebarSceneName');
        if (!container) return;

        // Ensure data is synced and initialized
        PlotGridViewModel.init();

        // Ensure modal HTML and styles are available for sidebar interactions
        this.ensureModalExists();

        // Update scene name in header
        const act = project.acts.find(a => a.id === currentActId);
        const chapter = act?.chapters.find(c => c.id === currentChapterId);
        const scene = chapter?.scenes.find(s => s.id == sceneId);
        if (sceneNameEl) {
            sceneNameEl.textContent = scene ? scene.title : 'Aucune scène sélectionnée';
        }

        if (!sceneId) {
            container.innerHTML = '<div class="empty-state">Sélectionnez une scène pour voir son intrigue.</div>';
            return;
        }

        // Map sceneId to PlotGrid rowId
        const rows = PlotGridViewModel.getGridData().rows;
        const structuralRow = rows.find(r => r.type === 'structure' && r.structureId == sceneId);

        if (!structuralRow) {
            container.innerHTML = '<div class="empty-state">Cette scène n’est pas encore synchronisée avec la grille d’intrigue.</div>';
            return;
        }

        const cards = PlotGridViewModel.getCardsByRow(structuralRow.id);
        const columns = PlotGridViewModel.getGridData().columns;

        if (cards.length === 0) {
            container.innerHTML = '<div class="empty-state">Aucun élément d’intrigue lié à cette scène.</div>';
            return;
        }

        container.innerHTML = cards.map(card => {
            const col = columns.find(c => c.id === card.colId);
            const lineTitle = col ? col.title : 'Ligne inconnue';

            return `
                <div class="sidebar-plot-card" onclick="PlotGridUI.openCardModal('${card.id}')">
                    <div class="sidebar-plot-card-line">${lineTitle}</div>
                    <div class="sidebar-plot-card-title">${card.title}</div>
                    <div class="sidebar-plot-card-content">${card.content || ''}</div>
                </div>
            `;
        }).join('');
    },

    // --- Drag & Drop ---
    handleDragStart: function (e, cardId) {
        this.draggedCardId = cardId;
        e.dataTransfer.setData('text/plain', cardId);
        e.dataTransfer.effectAllowed = 'move';
        setTimeout(() => {
            const cards = document.querySelectorAll(`[draggable="true"]`);
            cards.forEach(card => {
                if (card.outerHTML.includes(cardId)) card.style.opacity = '0.4';
            });
        }, 0);
    },

    handleDragOver: function (e) {
        e.preventDefault();
        e.currentTarget.classList.add('drag-over');
    },

    handleDragLeave: function (e) {
        e.currentTarget.classList.remove('drag-over');
    },

    handleDrop: function (e, rowId, colIndex) {
        e.preventDefault();
        e.currentTarget.classList.remove('drag-over');
        if (this.draggedCardId) {
            PlotGridViewModel.updateCardPosition(this.draggedCardId, rowId, colIndex);
            this.conditionalRender();
        }
        this.draggedCardId = null;
    }
};

function renderPlotGridView() {
    console.log('=== RENDER PLOT GRID VIEW (DABBLE MODE) ===');
    PlotGridUI.render();
}

// --- Menu Integration ---

function initPlotGridMenu() {
    // 1. Check if button already exists
    if (document.getElementById('header-tab-plotgrid')) return;

    // 2. Find the target group (Writing group)
    const writingGroup = document.querySelector('.nav-group');
    if (!writingGroup) return;

    // 3. Create the desktop button
    const btn = document.createElement('button');
    btn.id = 'header-tab-plotgrid';
    btn.className = 'nav-btn';

    btn.innerHTML = `
        <span class="nav-btn-icon"><i data-lucide="layout-grid"></i></span>
        <span class="nav-btn-text">Plot Grid</span>
    `;
    btn.onclick = () => switchView('plotgrid');

    // 4. Insert it after the 'Intrigue' button if possible
    // Note: There's a duplicate ID header-tab-plot in the HTML,
    // but getElementById usually returns the first one (Intrigue).
    const plotBtn = document.getElementById('header-tab-plot');
    if (plotBtn) {
        plotBtn.parentNode.insertBefore(btn, plotBtn.nextSibling);
    } else {
        writingGroup.appendChild(btn);
    }

    // 5. Add to mobile menu as well
    const mobileNavPlotBtn = document.querySelector('.mobile-nav-item[data-view="plot"]');
    if (mobileNavPlotBtn && !document.querySelector('.mobile-nav-item[data-view="plotgrid"]')) {
        const mobileBtn = document.createElement('button');
        mobileBtn.className = 'mobile-nav-item';
        mobileBtn.setAttribute('data-view', 'plotgrid');
        mobileBtn.onclick = () => switchViewMobile('plotgrid');
        mobileBtn.innerHTML = `
            <span class="mobile-nav-item-icon"><i data-lucide="layout-grid"></i></span>
            <span>Plot Grid</span>
        `;
        mobileNavPlotBtn.parentNode.insertBefore(mobileBtn, mobileNavPlotBtn.nextSibling);
    }

    if (typeof lucide !== 'undefined') lucide.createIcons();
}

// --- Initialization ---

// Initialize Menu integration on load
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initPlotGridMenu);
} else {
    initPlotGridMenu();
}

// Hook into the global switchView if possible, or ensure it's handled.
// The default switchView in 00.app.view.js handles 'plot' but not 'plotgrid'.
// We monkey-patch renderViewContent to add our new view case.

if (typeof renderViewContent === 'function') {
    const originalRender = renderViewContent;
    renderViewContent = function (view, containerId) {
        if (view === 'plotgrid' || view === 'plot-grid') {
            renderPlotGridView();
        } else {
            originalRender(view, containerId);
        }
    };
} else {
    // If renderViewContent is not yet defined, wait for it or use an alternative hook
    window.addEventListener('load', () => {
        if (typeof renderViewContent === 'function') {
            const originalRender = renderViewContent;
            renderViewContent = function (view, containerId) {
                if (view === 'plotgrid' || view === 'plot-grid') {
                    renderPlotGridView();
                } else {
                    originalRender(view, containerId);
                }
            };
        }
    });
}

// Fallback for switchView which updates button states
if (typeof switchView === 'function') {
    const originalSwitchView = switchView;
    switchView = function (view) {
        originalSwitchView(view);

        // Handle button active state if it's our view
        if (view === 'plotgrid') {
            document.querySelectorAll('.nav-btn').forEach(btn => btn.classList.remove('active'));
            const pgBtn = document.getElementById('header-tab-plotgrid');
            if (pgBtn) pgBtn.classList.add('active');
        }
    };
}

// ========== js-refactor/28.sceneNavigation.js ==========
/**
 * [MVVM : Scene Navigation]
 * Barre de navigation flottante permettant de déplacer du texte entre scènes
 * lors de l'écriture.
 */

// État de la barre de navigation
let sceneNavToolbar = null;
let sceneNavUpdateTimeout = null;
let lastCursorRect = null;
let savedSelection = null;
let activeSceneContext = null; // Contexte de la scène active (pour modes chapitre/acte)

/**
 * Sauvegarde la sélection actuelle.
 */
function saveSelection() {
    const selection = window.getSelection();
    if (selection && selection.rangeCount > 0) {
        return selection.getRangeAt(0).cloneRange();
    }
    return null;
}

/**
 * Restaure une sélection sauvegardée.
 */
function restoreSelection(range) {
    if (range) {
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
    }
}

/**
 * Initialise la barre de navigation entre scènes.
 * Doit être appelée après le rendu de l'éditeur.
 */
function initSceneNavigation() {
    // Créer la barre si elle n'existe pas
    if (!sceneNavToolbar) {
        createSceneNavToolbar();
    }

    // Attacher les événements à tous les éditeurs (mode scène, chapitre, acte)
    const editors = document.querySelectorAll('.editor-textarea[contenteditable="true"]');
    editors.forEach(editor => {
        if (!editor.hasAttribute('data-scene-nav-init')) {
            editor.setAttribute('data-scene-nav-init', 'true');

            // Écouter les événements de sélection et de clic
            editor.addEventListener('mouseup', handleCursorChange);
            editor.addEventListener('keyup', handleCursorChange);
            editor.addEventListener('focus', handleCursorChange);
            editor.addEventListener('blur', hideSceneNavToolbar);
        }
    });

    // Écouter le scroll pour mettre à jour la position
    const workspace = document.querySelector('.editor-workspace');
    if (workspace && !workspace.hasAttribute('data-scene-nav-scroll')) {
        workspace.setAttribute('data-scene-nav-scroll', 'true');
        workspace.addEventListener('scroll', debounceUpdateToolbarPosition);
    }
}

/**
 * Crée la barre d'outils de navigation entre scènes.
 */
function createSceneNavToolbar() {
    // Supprimer l'ancienne toolbar si elle existe
    const existing = document.getElementById('sceneNavToolbar');
    if (existing) existing.remove();

    sceneNavToolbar = document.createElement('div');
    sceneNavToolbar.id = 'sceneNavToolbar';
    sceneNavToolbar.className = 'scene-nav-toolbar';
    sceneNavToolbar.innerHTML = `
        <div class="scene-nav-buttons">
            <button class="scene-nav-btn scene-nav-prev" title="Déplacer vers la scène précédente (tout le texte avant le curseur)">
                <i data-lucide="chevron-left" style="width:16px;height:16px;"></i>
            </button>
            <button class="scene-nav-btn scene-nav-next" title="Déplacer vers la scène suivante (tout le texte après le curseur)">
                <i data-lucide="chevron-right" style="width:16px;height:16px;"></i>
            </button>
        </div>
        <div class="scene-nav-line"></div>
        <div class="scene-nav-word-counts">
            <span class="scene-nav-words-before" title="Mots avant le curseur">0 mots</span>
            <span class="scene-nav-words-after" title="Mots après le curseur">0 mots</span>
        </div>
    `;

    document.body.appendChild(sceneNavToolbar);

    // Attacher les événements avec mousedown + preventDefault pour conserver la sélection
    const prevBtn = sceneNavToolbar.querySelector('.scene-nav-prev');
    const nextBtn = sceneNavToolbar.querySelector('.scene-nav-next');

    prevBtn.addEventListener('mousedown', (e) => {
        e.preventDefault(); // Empêche la perte de focus/sélection
        e.stopPropagation();
        // Sauvegarder la sélection avant l'action
        savedSelection = saveSelection();
        moveTextToPreviousScene();
    });

    nextBtn.addEventListener('mousedown', (e) => {
        e.preventDefault(); // Empêche la perte de focus/sélection
        e.stopPropagation();
        // Sauvegarder la sélection avant l'action
        savedSelection = saveSelection();
        moveTextToNextScene();
    });
}

/**
 * Gère le changement de position du curseur.
 */
function handleCursorChange(event) {
    // Attendre un peu pour être sûr que la sélection est stable
    clearTimeout(sceneNavUpdateTimeout);
    sceneNavUpdateTimeout = setTimeout(() => {
        updateSceneNavToolbarPosition();
    }, 100);
}

/**
 * Mise à jour debounced de la position de la toolbar lors du scroll.
 */
let scrollDebounceTimeout = null;
function debounceUpdateToolbarPosition() {
    clearTimeout(scrollDebounceTimeout);
    scrollDebounceTimeout = setTimeout(() => {
        if (sceneNavToolbar && sceneNavToolbar.classList.contains('visible')) {
            updateSceneNavToolbarPosition();
        }
    }, 50);
}

/**
 * Détecte le contexte de la scène à partir de l'éditeur actif.
 * Fonctionne en mode scène unique, chapitre ou acte.
 */
function detectSceneContext(editor) {
    // Mode scène unique : utiliser les variables globales
    if (currentSceneId && currentChapterId && currentActId) {
        return {
            sceneId: currentSceneId,
            chapterId: currentChapterId,
            actId: currentActId
        };
    }

    // Mode chapitre ou acte : récupérer depuis les attributs data-*
    const sceneId = editor.getAttribute('data-scene-id');
    const chapterId = editor.getAttribute('data-chapter-id') || currentChapterId;
    const actId = editor.getAttribute('data-act-id') || currentActId;

    if (sceneId && chapterId && actId) {
        return {
            sceneId: parseInt(sceneId, 10),
            chapterId: parseInt(chapterId, 10),
            actId: parseInt(actId, 10)
        };
    }

    // Essayer de trouver via le parent (chapter-scene-block ou act-scene-block)
    const sceneBlock = editor.closest('[data-scene-id]');
    if (sceneBlock) {
        const blockSceneId = sceneBlock.getAttribute('data-scene-id');
        const blockChapterId = sceneBlock.getAttribute('data-chapter-id') || currentChapterId;
        const blockActId = sceneBlock.getAttribute('data-act-id') || currentActId;

        if (blockSceneId && blockChapterId && blockActId) {
            return {
                sceneId: parseInt(blockSceneId, 10),
                chapterId: parseInt(blockChapterId, 10),
                actId: parseInt(blockActId, 10)
            };
        }
    }

    return null;
}

/**
 * Met à jour la position de la barre de navigation.
 */
function updateSceneNavToolbarPosition() {
    if (!sceneNavToolbar) return;

    // Trouver l'éditeur actif (celui qui a le focus)
    const activeElement = document.activeElement;
    if (!activeElement || !activeElement.classList.contains('editor-textarea')) {
        hideSceneNavToolbar();
        return;
    }
    const editor = activeElement;

    // Détecter le contexte de la scène (mode scène unique ou chapitre/acte)
    activeSceneContext = detectSceneContext(editor);
    if (!activeSceneContext) {
        hideSceneNavToolbar();
        return;
    }

    // Obtenir la position du curseur
    const selection = window.getSelection();
    if (!selection || selection.rangeCount === 0) {
        hideSceneNavToolbar();
        return;
    }

    const range = selection.getRangeAt(0);

    // Vérifier que le curseur est bien dans l'éditeur
    if (!editor.contains(range.commonAncestorContainer)) {
        hideSceneNavToolbar();
        return;
    }

    // Obtenir le rect de la ligne courante
    const rects = range.getClientRects();
    let rect;

    if (rects.length > 0) {
        rect = rects[rects.length - 1]; // Prendre le dernier rect (position du curseur)
    } else {
        // Si pas de rect (curseur au début), utiliser le rect du range collapsed
        const tempRange = range.cloneRange();
        tempRange.collapse(true);
        const span = document.createElement('span');
        span.textContent = '\u200b'; // Zero-width space
        tempRange.insertNode(span);
        rect = span.getBoundingClientRect();
        span.remove();
    }

    if (!rect || rect.width === 0 && rect.height === 0) {
        hideSceneNavToolbar();
        return;
    }

    // Calculer la position - aligné avec la ligne du curseur
    const editorRect = editor.getBoundingClientRect();
    const lineHeight = rect.height || 24;
    const verticalCenter = rect.top + (lineHeight / 2);

    // Vérifier que la position est visible dans la fenêtre
    if (verticalCenter < editorRect.top || verticalCenter > window.innerHeight) {
        hideSceneNavToolbar();
        return;
    }

    // Positionner les boutons dans la marge gauche
    const buttonsEl = sceneNavToolbar.querySelector('.scene-nav-buttons');
    if (buttonsEl) {
        buttonsEl.style.left = `${editorRect.left - 70}px`; // 70px avant le texte
        buttonsEl.style.top = `${verticalCenter - 14}px`; // Centré verticalement (boutons de 28px)
    }

    // Positionner les compteurs dans la marge droite
    const wordCountsEl = sceneNavToolbar.querySelector('.scene-nav-word-counts');
    if (wordCountsEl) {
        wordCountsEl.style.left = `${editorRect.right + 15}px`; // 15px après le texte
        wordCountsEl.style.top = `${verticalCenter - 16}px`; // Centré verticalement
    }

    // Vérifier si des scènes adjacentes existent
    const adjacentScenes = getAdjacentScenes();
    const hasPrev = adjacentScenes.previous !== null;
    const hasNext = adjacentScenes.next !== null;

    if (!hasPrev && !hasNext) {
        hideSceneNavToolbar();
        return;
    }

    // Mettre à jour les boutons
    const prevBtn = sceneNavToolbar.querySelector('.scene-nav-prev');
    const nextBtn = sceneNavToolbar.querySelector('.scene-nav-next');

    if (prevBtn) {
        prevBtn.style.display = hasPrev ? '' : 'none';
        if (hasPrev) {
            prevBtn.title = `Déplacer vers "${adjacentScenes.previous.title}" (texte avant le curseur)`;
        }
    }
    if (nextBtn) {
        nextBtn.style.display = hasNext ? '' : 'none';
        if (hasNext) {
            nextBtn.title = `Déplacer vers "${adjacentScenes.next.title}" (texte après le curseur)`;
        }
    }

    // Calculer et afficher le nombre de mots avant/après le curseur
    updateWordCountsDisplay(editor, range);

    sceneNavToolbar.classList.add('visible');

    lastCursorRect = rect;
}

/**
 * Calcule et met à jour l'affichage du nombre de mots avant et après le curseur.
 */
function updateWordCountsDisplay(editor, range) {
    if (!sceneNavToolbar) return;

    const wordsBeforeEl = sceneNavToolbar.querySelector('.scene-nav-words-before');
    const wordsAfterEl = sceneNavToolbar.querySelector('.scene-nav-words-after');

    if (!wordsBeforeEl || !wordsAfterEl) return;

    try {
        // Créer un range du début de l'éditeur jusqu'au curseur
        const beforeRange = document.createRange();
        beforeRange.setStart(editor, 0);
        beforeRange.setEnd(range.startContainer, range.startOffset);

        // Extraire le texte avant le curseur
        const beforeFragment = beforeRange.cloneContents();
        const beforeDiv = document.createElement('div');
        beforeDiv.appendChild(beforeFragment);
        const textBefore = beforeDiv.textContent || '';

        // Créer un range du curseur jusqu'à la fin de l'éditeur
        const afterRange = document.createRange();
        afterRange.setStart(range.endContainer, range.endOffset);
        if (editor.lastChild) {
            afterRange.setEndAfter(editor.lastChild);
        } else {
            afterRange.setEnd(editor, editor.childNodes.length);
        }

        // Extraire le texte après le curseur
        const afterFragment = afterRange.cloneContents();
        const afterDiv = document.createElement('div');
        afterDiv.appendChild(afterFragment);
        const textAfter = afterDiv.textContent || '';

        // Compter les mots
        const wordsBefore = countWords(textBefore);
        const wordsAfter = countWords(textAfter);

        // Mettre à jour l'affichage
        wordsBeforeEl.textContent = `${wordsBefore} mots`;
        wordsAfterEl.textContent = `${wordsAfter} mots`;
    } catch (e) {
        // En cas d'erreur, ne pas bloquer
        wordsBeforeEl.textContent = '- mots';
        wordsAfterEl.textContent = '- mots';
    }
}

/**
 * Compte le nombre de mots dans un texte.
 */
function countWords(text) {
    if (!text || typeof text !== 'string') return 0;
    // Supprimer les espaces multiples et compter les mots
    const trimmed = text.trim();
    if (trimmed === '') return 0;
    return trimmed.split(/\s+/).filter(word => word.length > 0).length;
}

/**
 * Cache la barre de navigation.
 */
function hideSceneNavToolbar() {
    if (sceneNavToolbar) {
        sceneNavToolbar.classList.remove('visible');
    }
}

/**
 * Obtient les scènes adjacentes (précédente et suivante) à la scène actuelle.
 * @returns {Object} { previous: scene|null, next: scene|null, prevLocation: {actId, chapterId}, nextLocation: {actId, chapterId} }
 */
function getAdjacentScenes() {
    const result = {
        previous: null,
        next: null,
        prevLocation: null,
        nextLocation: null
    };

    // Utiliser le contexte actif détecté
    const ctx = activeSceneContext;
    if (!ctx || !ctx.actId || !ctx.chapterId || !ctx.sceneId) return result;

    // Construire une liste plate de toutes les scènes avec leurs emplacements
    const allScenes = [];
    for (const act of project.acts) {
        for (const chapter of (act.chapters || [])) {
            for (const scene of (chapter.scenes || [])) {
                allScenes.push({
                    scene,
                    actId: act.id,
                    chapterId: chapter.id
                });
            }
        }
    }

    // Trouver l'index de la scène actuelle
    const currentIndex = allScenes.findIndex(
        s => s.actId === ctx.actId &&
            s.chapterId === ctx.chapterId &&
            s.scene.id === ctx.sceneId
    );

    if (currentIndex === -1) return result;

    // Scène précédente
    if (currentIndex > 0) {
        const prev = allScenes[currentIndex - 1];
        result.previous = prev.scene;
        result.prevLocation = {
            actId: prev.actId,
            chapterId: prev.chapterId
        };
    }

    // Scène suivante
    if (currentIndex < allScenes.length - 1) {
        const next = allScenes[currentIndex + 1];
        result.next = next.scene;
        result.nextLocation = {
            actId: next.actId,
            chapterId: next.chapterId
        };
    }

    return result;
}

/**
 * Déplace le texte avant le curseur vers la fin de la scène précédente.
 */
function moveTextToPreviousScene() {
    const editor = getActiveEditor();
    if (!editor) return;

    // S'assurer que le contexte est à jour
    if (!activeSceneContext) {
        activeSceneContext = detectSceneContext(editor);
    }
    if (!activeSceneContext) return;

    const adjacentScenes = getAdjacentScenes();
    if (!adjacentScenes.previous) {
        showNotification('Aucune scène précédente disponible', 'warning');
        return;
    }

    // Utiliser la sélection sauvegardée ou la sélection courante
    let range = savedSelection;
    if (!range) {
        const selection = window.getSelection();
        if (!selection || selection.rangeCount === 0) {
            showNotification('Placez votre curseur dans le texte', 'warning');
            return;
        }
        range = selection.getRangeAt(0);
    }

    // Sauvegarder l'état pour undo
    if (typeof saveToHistoryImmediate === 'function') saveToHistoryImmediate();

    // Créer un range du début de l'éditeur jusqu'au curseur
    const beforeRange = document.createRange();
    beforeRange.setStart(editor, 0);
    beforeRange.setEnd(range.startContainer, range.startOffset);

    // Extraire le contenu HTML avant le curseur
    const fragment = beforeRange.cloneContents();
    const tempDiv = document.createElement('div');
    tempDiv.appendChild(fragment);
    const textToMove = tempDiv.innerHTML.trim();

    if (!textToMove || textToMove === '<br>' || textToMove === '') {
        showNotification('Aucun texte à déplacer avant le curseur', 'info');
        return;
    }

    // Supprimer le texte de la scène actuelle
    beforeRange.deleteContents();

    // Nettoyer le contenu restant (supprimer les br/espaces vides au début)
    cleanEditorStart(editor);

    // Ajouter le texte à la fin de la scène précédente
    const prevScene = adjacentScenes.previous;
    const currentContent = prevScene.content || '';

    // Ajouter un séparateur si nécessaire
    let separator = '';
    if (currentContent && !currentContent.endsWith('<br>') && !currentContent.endsWith('</p>') && !currentContent.endsWith('</div>')) {
        separator = '<br><br>';
    } else if (currentContent && !currentContent.endsWith('<br>')) {
        separator = '<br>';
    }

    prevScene.content = currentContent + separator + textToMove;

    // Mettre à jour la scène actuelle
    const currentScene = getCurrentScene();
    if (currentScene) {
        currentScene.content = editor.innerHTML;
        currentScene.wordCount = typeof getWordCount === 'function' ? getWordCount(editor.innerHTML) : 0;
    }

    // Mettre à jour le compteur de mots de la scène précédente
    prevScene.wordCount = typeof getWordCount === 'function' ? getWordCount(prevScene.content) : 0;

    // Mettre à jour l'éditeur de la scène précédente dans le DOM (mode chapitre/acte)
    updateAdjacentEditorInDOM(prevScene.id, prevScene.content);

    // Sauvegarder et rafraîchir
    if (typeof saveProject === 'function') saveProject();
    if (typeof updateStats === 'function') updateStats();
    if (typeof renderActsList === 'function') renderActsList();

    // Placer le curseur au début de l'éditeur
    const newSelection = window.getSelection();
    const newRange = document.createRange();
    if (editor.firstChild) {
        newRange.setStart(editor.firstChild, 0);
    } else {
        newRange.setStart(editor, 0);
    }
    newRange.collapse(true);
    newSelection.removeAllRanges();
    newSelection.addRange(newRange);

    // Nettoyer la sélection sauvegardée
    savedSelection = null;

    showNotification(`Texte déplacé vers "${prevScene.title}"`, 'success');
    hideSceneNavToolbar();
}

/**
 * Met à jour le contenu d'un éditeur adjacent dans le DOM (pour mode chapitre/acte).
 */
function updateAdjacentEditorInDOM(sceneId, content) {
    const adjacentEditor = document.querySelector(`.editor-textarea[data-scene-id="${sceneId}"]`);
    if (adjacentEditor && adjacentEditor !== document.activeElement) {
        adjacentEditor.innerHTML = content;
    }
}

/**
 * Déplace le texte après le curseur vers le début de la scène suivante.
 */
function moveTextToNextScene() {
    const editor = getActiveEditor();
    if (!editor) return;

    // S'assurer que le contexte est à jour
    if (!activeSceneContext) {
        activeSceneContext = detectSceneContext(editor);
    }
    if (!activeSceneContext) return;

    const adjacentScenes = getAdjacentScenes();
    if (!adjacentScenes.next) {
        showNotification('Aucune scène suivante disponible', 'warning');
        return;
    }

    // Utiliser la sélection sauvegardée ou la sélection courante
    let range = savedSelection;
    if (!range) {
        const selection = window.getSelection();
        if (!selection || selection.rangeCount === 0) {
            showNotification('Placez votre curseur dans le texte', 'warning');
            return;
        }
        range = selection.getRangeAt(0);
    }

    // Sauvegarder l'état pour undo
    if (typeof saveToHistoryImmediate === 'function') saveToHistoryImmediate();

    // Créer un range du curseur jusqu'à la fin de l'éditeur
    const afterRange = document.createRange();
    afterRange.setStart(range.endContainer, range.endOffset);

    // Gérer le cas où l'éditeur est vide ou le lastChild n'existe pas
    if (editor.lastChild) {
        afterRange.setEndAfter(editor.lastChild);
    } else {
        afterRange.setEnd(editor, editor.childNodes.length);
    }

    // Extraire le contenu HTML après le curseur
    const fragment = afterRange.cloneContents();
    const tempDiv = document.createElement('div');
    tempDiv.appendChild(fragment);
    const textToMove = tempDiv.innerHTML.trim();

    if (!textToMove || textToMove === '<br>' || textToMove === '') {
        showNotification('Aucun texte à déplacer après le curseur', 'info');
        return;
    }

    // Supprimer le texte de la scène actuelle
    afterRange.deleteContents();

    // Nettoyer le contenu restant (supprimer les br/espaces vides à la fin)
    cleanEditorEnd(editor);

    // Ajouter le texte au début de la scène suivante
    const nextScene = adjacentScenes.next;
    const currentContent = nextScene.content || '';

    // Ajouter un séparateur si nécessaire
    let separator = '';
    if (currentContent && !currentContent.startsWith('<br>') && !currentContent.startsWith('<p>') && !currentContent.startsWith('<div>')) {
        separator = '<br><br>';
    } else if (currentContent && !currentContent.startsWith('<br>')) {
        separator = '<br>';
    }

    nextScene.content = textToMove + separator + currentContent;

    // Mettre à jour la scène actuelle
    const currentScene = getCurrentScene();
    if (currentScene) {
        currentScene.content = editor.innerHTML;
        currentScene.wordCount = typeof getWordCount === 'function' ? getWordCount(editor.innerHTML) : 0;
    }

    // Mettre à jour le compteur de mots de la scène suivante
    nextScene.wordCount = typeof getWordCount === 'function' ? getWordCount(nextScene.content) : 0;

    // Mettre à jour l'éditeur de la scène suivante dans le DOM (mode chapitre/acte)
    updateAdjacentEditorInDOM(nextScene.id, nextScene.content);

    // Sauvegarder et rafraîchir
    if (typeof saveProject === 'function') saveProject();
    if (typeof updateStats === 'function') updateStats();
    if (typeof renderActsList === 'function') renderActsList();

    // Nettoyer la sélection sauvegardée
    savedSelection = null;

    showNotification(`Texte déplacé vers "${nextScene.title}"`, 'success');
    hideSceneNavToolbar();
}

/**
 * Obtient la scène actuellement ouverte (basée sur activeSceneContext).
 */
function getCurrentScene() {
    const ctx = activeSceneContext;
    if (!ctx || !ctx.actId || !ctx.chapterId || !ctx.sceneId) return null;

    const act = project.acts.find(a => a.id === ctx.actId);
    if (!act) return null;

    const chapter = act.chapters.find(c => c.id === ctx.chapterId);
    if (!chapter) return null;

    return chapter.scenes.find(s => s.id === ctx.sceneId) || null;
}

/**
 * Trouve l'éditeur actif basé sur le contexte de scène.
 */
function getActiveEditor() {
    // D'abord essayer l'élément actif
    const activeElement = document.activeElement;
    if (activeElement && activeElement.classList.contains('editor-textarea')) {
        return activeElement;
    }

    // Sinon chercher par data-scene-id si on a un contexte
    if (activeSceneContext && activeSceneContext.sceneId) {
        const editor = document.querySelector(`.editor-textarea[data-scene-id="${activeSceneContext.sceneId}"]`);
        if (editor) return editor;
    }

    // Fallback : premier éditeur trouvé
    return document.querySelector('.editor-textarea[contenteditable="true"]');
}

/**
 * Nettoie le début de l'éditeur (supprime les br et espaces vides).
 */
function cleanEditorStart(editor) {
    while (editor.firstChild) {
        const node = editor.firstChild;
        if (node.nodeType === Node.TEXT_NODE) {
            if (node.textContent.trim() === '') {
                node.remove();
                continue;
            }
            node.textContent = node.textContent.trimStart();
            break;
        } else if (node.nodeName === 'BR') {
            node.remove();
            continue;
        } else if (node.innerHTML !== undefined && node.innerHTML.trim() === '') {
            node.remove();
            continue;
        }
        break;
    }
}

/**
 * Nettoie la fin de l'éditeur (supprime les br et espaces vides).
 */
function cleanEditorEnd(editor) {
    while (editor.lastChild) {
        const node = editor.lastChild;
        if (node.nodeType === Node.TEXT_NODE) {
            if (node.textContent.trim() === '') {
                node.remove();
                continue;
            }
            node.textContent = node.textContent.trimEnd();
            break;
        } else if (node.nodeName === 'BR') {
            node.remove();
            continue;
        } else if (node.innerHTML !== undefined && node.innerHTML.trim() === '') {
            node.remove();
            continue;
        }
        break;
    }
}

/**
 * Affiche une notification temporaire.
 */
function showNotification(message, type = 'info') {
    // Utiliser la fonction de notification existante si disponible
    if (typeof showToast === 'function') {
        showToast(message, type);
        return;
    }

    // Créer une notification simple
    const notification = document.createElement('div');
    notification.className = `scene-nav-notification scene-nav-notification-${type}`;
    notification.textContent = message;
    notification.style.cssText = `
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        padding: 12px 24px;
        border-radius: 8px;
        font-size: 0.9rem;
        font-weight: 500;
        z-index: 10000;
        animation: slideUp 0.3s ease;
        background: ${type === 'success' ? '#2ecc71' : type === 'warning' ? '#f39c12' : type === 'error' ? '#e74c3c' : '#3498db'};
        color: white;
        box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    `;

    document.body.appendChild(notification);

    setTimeout(() => {
        notification.style.animation = 'slideDown 0.3s ease';
        setTimeout(() => notification.remove(), 300);
    }, 2500);
}

/**
 * Nettoie la barre de navigation (à appeler lors du changement de vue).
 */
function cleanupSceneNavigation() {
    hideSceneNavToolbar();
    activeSceneContext = null;

    const editors = document.querySelectorAll('.editor-textarea[data-scene-nav-init]');
    editors.forEach(editor => {
        editor.removeAttribute('data-scene-nav-init');
        editor.removeEventListener('mouseup', handleCursorChange);
        editor.removeEventListener('keyup', handleCursorChange);
        editor.removeEventListener('focus', handleCursorChange);
        editor.removeEventListener('blur', hideSceneNavToolbar);
    });

    const workspace = document.querySelector('.editor-workspace[data-scene-nav-scroll]');
    if (workspace) {
        workspace.removeAttribute('data-scene-nav-scroll');
    }
}

// Exposer les fonctions globalement
window.initSceneNavigation = initSceneNavigation;
window.cleanupSceneNavigation = cleanupSceneNavigation;
window.moveTextToPreviousScene = moveTextToPreviousScene;
window.moveTextToNextScene = moveTextToNextScene;

// ========== js-refactor/synonyms/synonyms.config.js ==========
// ============================================================
// synonyms.config.js - Configuration du module Synonymes
// ============================================================
// [MVVM : Config] - Constantes et paramètres du service de synonymes

const SynonymsConfig = {
    // APIs disponibles
    apis: {
        datamuse: {
            name: 'Datamuse',
            baseUrl: 'https://api.datamuse.com/words',
            // Pour les synonymes français, on utilise le paramètre v=fr
            synonymsEndpoint: (word) => `?rel_syn=${encodeURIComponent(word)}&v=fr&max=20`,
            // Mots similaires (son/orthographe)
            similarEndpoint: (word) => `?sl=${encodeURIComponent(word)}&v=fr&max=10`,
            // Mots qui riment
            rhymesEndpoint: (word) => `?rel_rhy=${encodeURIComponent(word)}&v=fr&max=15`,
            // Antonymes (mots opposés)
            antonymsEndpoint: (word) => `?rel_ant=${encodeURIComponent(word)}&v=fr&max=10`,
            timeout: 5000,
            enabled: true
        },
        // Configuration pour une future API alternative
        openThesaurus: {
            name: 'OpenThesaurus',
            baseUrl: 'https://www.openthesaurus.de/synonyme/search',
            // Note: OpenThesaurus est principalement allemand, mais peut être adapté
            enabled: false
        }
    },

    // Configuration du cache
    cache: {
        enabled: true,
        maxEntries: 500,           // Nombre max de mots en cache
        expirationDays: 30,        // Durée de vie du cache en jours
        storageKey: 'plume_synonyms_cache'
    },

    // Configuration de l'interface utilisateur
    ui: {
        maxDisplayResults: 15,     // Nombre max de synonymes affichés
        debounceDelay: 300,        // Délai avant recherche (ms)
        showScores: false,         // Afficher les scores de pertinence
        groupByCategory: true,     // Grouper par catégorie grammaticale
        modalId: 'synonyms-modal',
        inputId: 'synonyms-search-input',
        resultsId: 'synonyms-results'
    },

    // Messages d'erreur et labels
    messages: {
        fr: {
            title: 'Dictionnaire de Synonymes',
            placeholder: 'Entrez un mot...',
            searching: 'Recherche en cours...',
            noResults: 'Aucun synonyme trouvé',
            error: 'Erreur de connexion au service',
            offline: 'Mode hors-ligne : résultats depuis le cache',
            synonyms: 'Synonymes',
            similar: 'Mots similaires',
            rhymes: 'Rimes',
            antonyms: 'Antonymes',
            copy: 'Copier',
            insert: 'Insérer',
            close: 'Fermer',
            cached: '(en cache)'
        }
    },

    // Types de recherche disponibles
    searchTypes: {
        SYNONYMS: 'synonyms',
        SIMILAR: 'similar',
        RHYMES: 'rhymes',
        ANTONYMS: 'antonyms'
    }
};

// Fonction utilitaire pour obtenir un message localisé
// [MVVM : Config]
function getSynonymsMessage(key, lang = 'fr') {
    return SynonymsConfig.messages[lang]?.[key] || SynonymsConfig.messages.fr[key] || key;
}

// Export pour utilisation dans d'autres modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { SynonymsConfig, getSynonymsMessage };
}

// ========== js-refactor/synonyms/synonyms.model.js ==========
// ============================================================
// synonyms.model.js - Modèle de données pour les synonymes
// ============================================================
// [MVVM : Model] - Structures de données et factories

/**
 * Modèle représentant un résultat de synonyme
 * [MVVM : Model]
 */
const SynonymResult = {
    /**
     * Crée un nouveau résultat de synonyme
     * @param {Object} data - Données brutes de l'API
     * @returns {Object} Résultat formaté
     */
    create(data = {}) {
        return {
            word: data.word || '',
            score: data.score || 0,
            tags: data.tags || [],
            numSyllables: data.numSyllables || null,
            // Métadonnées ajoutées localement
            category: this.extractCategory(data.tags),
            isVerb: this.isVerb(data.tags),
            isNoun: this.isNoun(data.tags),
            isAdjective: this.isAdjective(data.tags)
        };
    },

    /**
     * Extrait la catégorie grammaticale des tags
     * [MVVM : Model]
     */
    extractCategory(tags = []) {
        if (tags.includes('n')) return 'nom';
        if (tags.includes('v')) return 'verbe';
        if (tags.includes('adj')) return 'adjectif';
        if (tags.includes('adv')) return 'adverbe';
        return 'autre';
    },

    isVerb(tags = []) {
        return tags.includes('v');
    },

    isNoun(tags = []) {
        return tags.includes('n');
    },

    isAdjective(tags = []) {
        return tags.includes('adj');
    }
};

/**
 * Modèle représentant une recherche de synonymes
 * [MVVM : Model]
 */
const SynonymsSearch = {
    /**
     * Crée une nouvelle recherche
     * @param {string} word - Mot recherché
     * @param {string} type - Type de recherche (synonyms, similar, rhymes, antonyms)
     * @returns {Object} Objet recherche
     */
    create(word, type = 'synonyms') {
        return {
            id: this.generateId(word, type),
            word: word.toLowerCase().trim(),
            type: type,
            timestamp: Date.now(),
            results: [],
            fromCache: false,
            error: null
        };
    },

    /**
     * Génère un ID unique pour la recherche (utilisé pour le cache)
     * [MVVM : Model]
     */
    generateId(word, type) {
        return `${type}_${word.toLowerCase().trim()}`;
    }
};

/**
 * Modèle représentant une entrée en cache
 * [MVVM : Model]
 */
const CacheEntry = {
    /**
     * Crée une nouvelle entrée de cache
     * @param {Object} search - Objet recherche
     * @returns {Object} Entrée de cache
     */
    create(search) {
        return {
            id: search.id,
            word: search.word,
            type: search.type,
            results: search.results,
            cachedAt: Date.now(),
            expiresAt: Date.now() + (SynonymsConfig.cache.expirationDays * 24 * 60 * 60 * 1000)
        };
    },

    /**
     * Vérifie si une entrée de cache est expirée
     * [MVVM : Model]
     */
    isExpired(entry) {
        return Date.now() > entry.expiresAt;
    }
};

/**
 * Modèle d'état de l'interface synonymes
 * [MVVM : Model]
 */
const SynonymsUIState = {
    /**
     * Crée l'état initial de l'interface
     * [MVVM : Model]
     */
    createInitialState() {
        return {
            isOpen: false,
            isLoading: false,
            currentWord: '',
            currentType: SynonymsConfig.searchTypes.SYNONYMS,
            results: [],
            error: null,
            isOffline: !navigator.onLine,
            selectedIndex: -1,
            history: []
        };
    }
};

// Export pour utilisation dans d'autres modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { SynonymResult, SynonymsSearch, CacheEntry, SynonymsUIState };
}

// ========== js-refactor/synonyms/synonyms.dictionary.js ==========
// ============================================================
// synonyms.dictionary.js - Dictionnaire local de synonymes français
// ============================================================
// [MVVM : Data] - Base de données locale de synonymes français

/**
 * Dictionnaire de synonymes français
 * Structure : mot -> { synonymes: [], antonymes: [], similaires: [] }
 * [MVVM : Data]
 */
const FrenchSynonymsDictionary = {
    // ===== A =====
    "abandonner": {
        synonymes: ["délaisser", "quitter", "lâcher", "renoncer", "céder", "laisser", "déserter", "négliger"],
        antonymes: ["persévérer", "continuer", "maintenir", "garder"]
    },
    "abîmer": {
        synonymes: ["endommager", "détériorer", "dégrader", "gâter", "détruire", "esquinter", "bousiller"],
        antonymes: ["réparer", "restaurer", "arranger"]
    },
    "absence": {
        synonymes: ["manque", "défaut", "carence", "privation", "vide", "lacune"],
        antonymes: ["présence", "existence"]
    },
    "absolu": {
        synonymes: ["total", "complet", "entier", "parfait", "intégral", "inconditionnel"],
        antonymes: ["relatif", "partiel", "limité"]
    },
    "accepter": {
        synonymes: ["admettre", "agréer", "consentir", "accueillir", "approuver", "acquiescer", "tolérer"],
        antonymes: ["refuser", "rejeter", "décliner"]
    },
    "accompagner": {
        synonymes: ["escorter", "suivre", "conduire", "guider", "assister", "seconder"],
        antonymes: ["abandonner", "délaisser"]
    },
    "accord": {
        synonymes: ["entente", "harmonie", "pacte", "alliance", "convention", "traité", "consensus"],
        antonymes: ["désaccord", "conflit", "discorde"]
    },
    "acheter": {
        synonymes: ["acquérir", "procurer", "obtenir", "payer"],
        antonymes: ["vendre", "céder"]
    },
    "adorer": {
        synonymes: ["aimer", "vénérer", "idolâtrer", "chérir", "raffoler", "affectionner"],
        antonymes: ["détester", "haïr", "abhorrer"]
    },
    "agréable": {
        synonymes: ["plaisant", "charmant", "délicieux", "doux", "aimable", "sympathique", "attrayant"],
        antonymes: ["désagréable", "déplaisant", "pénible"]
    },
    "aide": {
        synonymes: ["assistance", "secours", "soutien", "appui", "renfort", "collaboration"],
        antonymes: ["obstacle", "entrave"]
    },
    "aider": {
        synonymes: ["assister", "secourir", "soutenir", "épauler", "appuyer", "collaborer"],
        antonymes: ["gêner", "entraver", "nuire"]
    },
    "aimer": {
        synonymes: ["adorer", "chérir", "affectionner", "apprécier", "estimer", "préférer"],
        antonymes: ["détester", "haïr", "mépriser"]
    },
    "aller": {
        synonymes: ["partir", "se rendre", "marcher", "avancer", "progresser", "fonctionner"],
        antonymes: ["venir", "rester", "revenir"]
    },
    "amour": {
        synonymes: ["affection", "tendresse", "passion", "attachement", "adoration", "sentiment"],
        antonymes: ["haine", "aversion", "dégoût"]
    },
    "ancien": {
        synonymes: ["vieux", "antique", "archaïque", "passé", "révolu", "désuet"],
        antonymes: ["nouveau", "moderne", "récent"]
    },
    "angoisse": {
        synonymes: ["anxiété", "inquiétude", "peur", "crainte", "effroi", "tourment", "stress"],
        antonymes: ["sérénité", "calme", "tranquillité"]
    },
    "apparaître": {
        synonymes: ["surgir", "émerger", "paraître", "se montrer", "se manifester", "naître"],
        antonymes: ["disparaître", "s'évanouir"]
    },
    "apprendre": {
        synonymes: ["étudier", "s'instruire", "assimiler", "découvrir", "enseigner", "informer"],
        antonymes: ["oublier", "ignorer"]
    },
    "argent": {
        synonymes: ["monnaie", "fortune", "richesse", "fonds", "capital", "finances", "sous"],
        antonymes: ["pauvreté", "misère"]
    },
    "arrêter": {
        synonymes: ["stopper", "cesser", "interrompre", "suspendre", "bloquer", "immobiliser"],
        antonymes: ["continuer", "poursuivre", "démarrer"]
    },
    "arriver": {
        synonymes: ["parvenir", "atteindre", "survenir", "advenir", "se produire", "venir"],
        antonymes: ["partir", "échouer"]
    },
    "attendre": {
        synonymes: ["patienter", "espérer", "guetter", "compter sur", "escompter"],
        antonymes: ["agir", "devancer"]
    },
    "attention": {
        synonymes: ["vigilance", "concentration", "soin", "prudence", "intérêt", "considération"],
        antonymes: ["distraction", "inattention", "négligence"]
    },
    "aujourd'hui": {
        synonymes: ["maintenant", "actuellement", "présentement", "à présent", "de nos jours"],
        antonymes: ["hier", "demain", "autrefois"]
    },
    "aussi": {
        synonymes: ["également", "pareillement", "de même", "en outre", "de plus"],
        antonymes: ["non plus"]
    },
    "avant": {
        synonymes: ["auparavant", "précédemment", "antérieurement", "jadis", "autrefois"],
        antonymes: ["après", "ensuite", "plus tard"]
    },
    "avenir": {
        synonymes: ["futur", "lendemain", "destinée", "perspective", "horizon"],
        antonymes: ["passé", "histoire"]
    },
    "avis": {
        synonymes: ["opinion", "point de vue", "jugement", "sentiment", "pensée", "conseil"],
        antonymes: []
    },

    // ===== B =====
    "beau": {
        synonymes: ["joli", "magnifique", "superbe", "splendide", "ravissant", "charmant", "élégant"],
        antonymes: ["laid", "moche", "vilain", "affreux"]
    },
    "beaucoup": {
        synonymes: ["énormément", "considérablement", "abondamment", "amplement", "fortement"],
        antonymes: ["peu", "guère", "rarement"]
    },
    "besoin": {
        synonymes: ["nécessité", "exigence", "envie", "désir", "manque", "demande"],
        antonymes: ["superflu", "luxe"]
    },
    "bien": {
        synonymes: ["correctement", "convenablement", "parfaitement", "admirablement", "avantage"],
        antonymes: ["mal", "incorrectement"]
    },
    "bizarre": {
        synonymes: ["étrange", "curieux", "singulier", "insolite", "inhabituel", "surprenant"],
        antonymes: ["normal", "ordinaire", "banal"]
    },
    "blanc": {
        synonymes: ["immaculé", "pur", "pâle", "clair", "neigeux", "laiteux"],
        antonymes: ["noir", "sombre", "foncé"]
    },
    "blesser": {
        synonymes: ["meurtrir", "léser", "offenser", "vexer", "froisser", "atteindre"],
        antonymes: ["soigner", "guérir", "réconforter"]
    },
    "bonheur": {
        synonymes: ["joie", "félicité", "béatitude", "contentement", "satisfaction", "plaisir"],
        antonymes: ["malheur", "tristesse", "chagrin"]
    },
    "bon": {
        synonymes: ["excellent", "agréable", "délicieux", "généreux", "bienveillant", "valable"],
        antonymes: ["mauvais", "méchant", "néfaste"]
    },
    "bruit": {
        synonymes: ["son", "vacarme", "tapage", "fracas", "tumulte", "brouhaha", "rumeur"],
        antonymes: ["silence", "calme", "tranquillité"]
    },

    // ===== C =====
    "cacher": {
        synonymes: ["dissimuler", "masquer", "camoufler", "occulter", "voiler", "dérober"],
        antonymes: ["montrer", "révéler", "exposer"]
    },
    "calme": {
        synonymes: ["serein", "paisible", "tranquille", "placide", "posé", "silencieux"],
        antonymes: ["agité", "nerveux", "turbulent"]
    },
    "capable": {
        synonymes: ["apte", "compétent", "qualifié", "habile", "doué", "talentueux"],
        antonymes: ["incapable", "inapte", "incompétent"]
    },
    "certain": {
        synonymes: ["sûr", "assuré", "convaincu", "indubitable", "évident", "incontestable"],
        antonymes: ["incertain", "douteux", "hésitant"]
    },
    "changer": {
        synonymes: ["modifier", "transformer", "altérer", "varier", "évoluer", "remplacer"],
        antonymes: ["conserver", "maintenir", "garder"]
    },
    "chercher": {
        synonymes: ["rechercher", "quêter", "fouiller", "explorer", "tenter", "essayer"],
        antonymes: ["trouver", "abandonner"]
    },
    "choisir": {
        synonymes: ["sélectionner", "élire", "opter", "préférer", "désigner", "adopter"],
        antonymes: ["rejeter", "refuser"]
    },
    "clair": {
        synonymes: ["lumineux", "brillant", "limpide", "évident", "net", "distinct"],
        antonymes: ["sombre", "obscur", "confus"]
    },
    "colère": {
        synonymes: ["fureur", "rage", "courroux", "irritation", "emportement", "indignation"],
        antonymes: ["calme", "sérénité", "patience"]
    },
    "commencer": {
        synonymes: ["débuter", "entamer", "amorcer", "initier", "entreprendre", "inaugurer"],
        antonymes: ["finir", "terminer", "achever"]
    },
    "comprendre": {
        synonymes: ["saisir", "concevoir", "assimiler", "percevoir", "interpréter", "entendre"],
        antonymes: ["ignorer", "méconnaître"]
    },
    "confiance": {
        synonymes: ["foi", "crédit", "assurance", "espoir", "certitude", "sécurité"],
        antonymes: ["méfiance", "défiance", "doute"]
    },
    "connaître": {
        synonymes: ["savoir", "maîtriser", "posséder", "fréquenter", "expérimenter"],
        antonymes: ["ignorer", "méconnaître"]
    },
    "content": {
        synonymes: ["heureux", "satisfait", "ravi", "enchanté", "joyeux", "comblé"],
        antonymes: ["mécontent", "triste", "déçu"]
    },
    "continuer": {
        synonymes: ["poursuivre", "persévérer", "prolonger", "maintenir", "persister"],
        antonymes: ["arrêter", "cesser", "interrompre"]
    },
    "courageux": {
        synonymes: ["brave", "vaillant", "intrépide", "audacieux", "héroïque", "téméraire"],
        antonymes: ["lâche", "peureux", "craintif"]
    },
    "créer": {
        synonymes: ["inventer", "concevoir", "produire", "fabriquer", "engendrer", "fonder"],
        antonymes: ["détruire", "supprimer", "abolir"]
    },
    "croire": {
        synonymes: ["penser", "estimer", "supposer", "imaginer", "présumer", "admettre"],
        antonymes: ["douter", "nier"]
    },

    // ===== D =====
    "danger": {
        synonymes: ["péril", "risque", "menace", "hasard", "écueil", "piège"],
        antonymes: ["sécurité", "sûreté", "protection"]
    },
    "décider": {
        synonymes: ["résoudre", "trancher", "déterminer", "choisir", "arrêter", "statuer"],
        antonymes: ["hésiter", "tergiverser"]
    },
    "découvrir": {
        synonymes: ["trouver", "déceler", "révéler", "dévoiler", "explorer", "constater"],
        antonymes: ["cacher", "dissimuler"]
    },
    "demander": {
        synonymes: ["solliciter", "réclamer", "prier", "exiger", "requérir", "interroger"],
        antonymes: ["offrir", "donner", "répondre"]
    },
    "dernier": {
        synonymes: ["ultime", "final", "terminal", "suprême", "extrême", "récent"],
        antonymes: ["premier", "initial", "ancien"]
    },
    "désir": {
        synonymes: ["envie", "souhait", "aspiration", "ambition", "convoitise", "appétit"],
        antonymes: ["dégoût", "aversion", "répulsion"]
    },
    "détester": {
        synonymes: ["haïr", "abhorrer", "exécrer", "abominer", "mépriser", "honnir"],
        antonymes: ["aimer", "adorer", "chérir"]
    },
    "détruire": {
        synonymes: ["anéantir", "démolir", "ruiner", "dévaster", "ravager", "saccager"],
        antonymes: ["construire", "créer", "bâtir"]
    },
    "devenir": {
        synonymes: ["se transformer", "évoluer", "se changer", "passer", "tourner"],
        antonymes: ["rester", "demeurer"]
    },
    "difficile": {
        synonymes: ["ardu", "compliqué", "malaisé", "pénible", "laborieux", "épineux"],
        antonymes: ["facile", "simple", "aisé"]
    },
    "dire": {
        synonymes: ["parler", "énoncer", "exprimer", "affirmer", "déclarer", "raconter"],
        antonymes: ["taire", "cacher"]
    },
    "donner": {
        synonymes: ["offrir", "céder", "accorder", "fournir", "procurer", "remettre"],
        antonymes: ["prendre", "recevoir", "garder"]
    },
    "doute": {
        synonymes: ["incertitude", "hésitation", "scepticisme", "méfiance", "perplexité"],
        antonymes: ["certitude", "assurance", "conviction"]
    },
    "doux": {
        synonymes: ["tendre", "suave", "moelleux", "délicat", "agréable", "clément"],
        antonymes: ["dur", "rude", "âpre"]
    },
    "droit": {
        synonymes: ["rectiligne", "direct", "juste", "légitime", "honnête", "loyal"],
        antonymes: ["courbe", "tordu", "injuste"]
    },
    "dur": {
        synonymes: ["rigide", "solide", "ferme", "sévère", "difficile", "pénible"],
        antonymes: ["mou", "tendre", "doux"]
    },

    // ===== E =====
    "écrire": {
        synonymes: ["rédiger", "composer", "consigner", "noter", "transcrire", "griffonner"],
        antonymes: ["effacer", "supprimer"]
    },
    "effort": {
        synonymes: ["peine", "travail", "labeur", "tentative", "énergie", "application"],
        antonymes: ["repos", "facilité", "aisance"]
    },
    "émotion": {
        synonymes: ["sentiment", "sensation", "trouble", "émoi", "affect", "ressenti"],
        antonymes: ["indifférence", "froideur"]
    },
    "enfant": {
        synonymes: ["petit", "gamin", "gosse", "môme", "bambin", "rejeton", "descendant"],
        antonymes: ["adulte", "parent"]
    },
    "ennui": {
        synonymes: ["lassitude", "monotonie", "désoeuvrement", "souci", "problème", "tracas"],
        antonymes: ["plaisir", "divertissement", "joie"]
    },
    "énorme": {
        synonymes: ["immense", "gigantesque", "colossal", "monumental", "considérable", "massif"],
        antonymes: ["minuscule", "petit", "infime"]
    },
    "ensemble": {
        synonymes: ["collectivement", "conjointement", "simultanément", "unanimement", "globalité"],
        antonymes: ["séparément", "individuellement"]
    },
    "entendre": {
        synonymes: ["ouïr", "écouter", "percevoir", "comprendre", "saisir"],
        antonymes: ["ignorer"]
    },
    "entrer": {
        synonymes: ["pénétrer", "accéder", "s'introduire", "s'engager", "franchir"],
        antonymes: ["sortir", "quitter"]
    },
    "envie": {
        synonymes: ["désir", "souhait", "convoitise", "jalousie", "besoin", "appétit"],
        antonymes: ["dégoût", "répulsion"]
    },
    "erreur": {
        synonymes: ["faute", "méprise", "bévue", "inexactitude", "maladresse", "gaffe"],
        antonymes: ["exactitude", "justesse", "vérité"]
    },
    "espoir": {
        synonymes: ["espérance", "attente", "confiance", "optimisme", "aspiration", "foi"],
        antonymes: ["désespoir", "pessimisme"]
    },
    "essayer": {
        synonymes: ["tenter", "expérimenter", "éprouver", "s'efforcer", "chercher"],
        antonymes: ["réussir", "abandonner"]
    },
    "étrange": {
        synonymes: ["bizarre", "curieux", "singulier", "insolite", "inhabituel", "surprenant"],
        antonymes: ["normal", "ordinaire", "banal"]
    },
    "être": {
        synonymes: ["exister", "vivre", "se trouver", "demeurer", "rester", "subsister"],
        antonymes: ["disparaître", "mourir"]
    },
    "évident": {
        synonymes: ["clair", "manifeste", "flagrant", "patent", "incontestable", "certain"],
        antonymes: ["douteux", "incertain", "obscur"]
    },

    // ===== F =====
    "facile": {
        synonymes: ["simple", "aisé", "élémentaire", "commode", "accessible", "enfantin"],
        antonymes: ["difficile", "ardu", "compliqué"]
    },
    "faible": {
        synonymes: ["fragile", "frêle", "débile", "chétif", "vulnérable", "impuissant"],
        antonymes: ["fort", "puissant", "robuste"]
    },
    "faire": {
        synonymes: ["réaliser", "effectuer", "accomplir", "exécuter", "fabriquer", "créer"],
        antonymes: ["défaire", "détruire"]
    },
    "famille": {
        synonymes: ["parenté", "lignée", "clan", "foyer", "maisonnée", "tribu"],
        antonymes: []
    },
    "fatigue": {
        synonymes: ["lassitude", "épuisement", "usure", "harassement", "abattement"],
        antonymes: ["énergie", "vigueur", "forme"]
    },
    "faux": {
        synonymes: ["inexact", "erroné", "mensonger", "fictif", "artificiel", "contrefait"],
        antonymes: ["vrai", "authentique", "réel"]
    },
    "femme": {
        synonymes: ["dame", "épouse", "compagne", "fille", "demoiselle"],
        antonymes: ["homme"]
    },
    "fermer": {
        synonymes: ["clore", "verrouiller", "barrer", "boucher", "obstruer", "sceller"],
        antonymes: ["ouvrir", "débloquer"]
    },
    "fête": {
        synonymes: ["célébration", "festivité", "réjouissance", "cérémonie", "gala", "soirée"],
        antonymes: ["deuil", "enterrement"]
    },
    "fier": {
        synonymes: ["orgueilleux", "hautain", "digne", "noble", "altier", "satisfait"],
        antonymes: ["humble", "modeste", "honteux"]
    },
    "fin": {
        synonymes: ["terme", "conclusion", "achèvement", "dénouement", "aboutissement", "issue"],
        antonymes: ["début", "commencement", "origine"]
    },
    "finir": {
        synonymes: ["terminer", "achever", "conclure", "accomplir", "clore", "compléter"],
        antonymes: ["commencer", "débuter", "entamer"]
    },
    "force": {
        synonymes: ["puissance", "vigueur", "énergie", "robustesse", "pouvoir", "intensité"],
        antonymes: ["faiblesse", "fragilité"]
    },
    "fort": {
        synonymes: ["puissant", "robuste", "vigoureux", "solide", "résistant", "costaud"],
        antonymes: ["faible", "fragile", "chétif"]
    },
    "fou": {
        synonymes: ["dément", "insensé", "dingue", "cinglé", "toqué", "dérangé"],
        antonymes: ["sain", "sensé", "raisonnable"]
    },
    "froid": {
        synonymes: ["glacé", "glacial", "gelé", "frais", "frigide", "distant"],
        antonymes: ["chaud", "tiède", "chaleureux"]
    },

    // ===== G =====
    "gagner": {
        synonymes: ["remporter", "obtenir", "vaincre", "triompher", "conquérir", "mériter"],
        antonymes: ["perdre", "échouer"]
    },
    "garder": {
        synonymes: ["conserver", "préserver", "maintenir", "retenir", "surveiller", "protéger"],
        antonymes: ["perdre", "abandonner", "donner"]
    },
    "gentil": {
        synonymes: ["aimable", "sympathique", "agréable", "bienveillant", "affable", "doux"],
        antonymes: ["méchant", "désagréable", "hostile"]
    },
    "grand": {
        synonymes: ["immense", "vaste", "énorme", "gigantesque", "important", "majeur"],
        antonymes: ["petit", "minuscule", "insignifiant"]
    },
    "grave": {
        synonymes: ["sérieux", "important", "critique", "préoccupant", "dramatique", "solennel"],
        antonymes: ["léger", "bénin", "insignifiant"]
    },
    "groupe": {
        synonymes: ["ensemble", "équipe", "collectif", "bande", "troupe", "assemblée"],
        antonymes: ["individu", "solitaire"]
    },
    "guerre": {
        synonymes: ["conflit", "combat", "bataille", "hostilités", "affrontement", "lutte"],
        antonymes: ["paix", "harmonie", "concorde"]
    },

    // ===== H =====
    "habiter": {
        synonymes: ["résider", "demeurer", "loger", "vivre", "occuper", "séjourner"],
        antonymes: ["quitter", "partir"]
    },
    "haine": {
        synonymes: ["aversion", "hostilité", "animosité", "répulsion", "exécration", "détestation"],
        antonymes: ["amour", "affection", "sympathie"]
    },
    "hasard": {
        synonymes: ["chance", "fortune", "coïncidence", "aléa", "destin", "sort"],
        antonymes: ["certitude", "préméditation"]
    },
    "heureux": {
        synonymes: ["content", "joyeux", "ravi", "enchanté", "satisfait", "comblé", "béat"],
        antonymes: ["malheureux", "triste", "mécontent"]
    },
    "histoire": {
        synonymes: ["récit", "conte", "narration", "chronique", "anecdote", "passé"],
        antonymes: ["avenir", "futur"]
    },
    "homme": {
        synonymes: ["individu", "personne", "être", "gars", "type", "mâle"],
        antonymes: ["femme"]
    },
    "honte": {
        synonymes: ["humiliation", "déshonneur", "opprobre", "confusion", "embarras", "gêne"],
        antonymes: ["fierté", "honneur", "gloire"]
    },
    "horrible": {
        synonymes: ["affreux", "épouvantable", "effroyable", "atroce", "terrible", "abominable"],
        antonymes: ["magnifique", "merveilleux", "splendide"]
    },

    // ===== I =====
    "idée": {
        synonymes: ["pensée", "concept", "notion", "opinion", "projet", "intention"],
        antonymes: []
    },
    "imaginer": {
        synonymes: ["concevoir", "inventer", "créer", "rêver", "supposer", "envisager"],
        antonymes: ["constater", "observer"]
    },
    "immense": {
        synonymes: ["énorme", "gigantesque", "vaste", "colossal", "infini", "illimité"],
        antonymes: ["minuscule", "petit", "étroit"]
    },
    "important": {
        synonymes: ["considérable", "majeur", "capital", "essentiel", "crucial", "primordial"],
        antonymes: ["insignifiant", "mineur", "négligeable"]
    },
    "impossible": {
        synonymes: ["irréalisable", "impensable", "inconcevable", "inimaginable", "utopique"],
        antonymes: ["possible", "réalisable", "faisable"]
    },
    "inquiet": {
        synonymes: ["anxieux", "soucieux", "préoccupé", "tourmenté", "nerveux", "angoissé"],
        antonymes: ["serein", "calme", "tranquille"]
    },
    "intelligent": {
        synonymes: ["brillant", "astucieux", "malin", "perspicace", "vif", "ingénieux"],
        antonymes: ["stupide", "bête", "idiot"]
    },
    "intéressant": {
        synonymes: ["captivant", "passionnant", "attrayant", "fascinant", "curieux"],
        antonymes: ["ennuyeux", "inintéressant", "banal"]
    },

    // ===== J =====
    "jamais": {
        synonymes: ["aucunement", "nullement", "en aucun cas"],
        antonymes: ["toujours", "souvent", "parfois"]
    },
    "jeter": {
        synonymes: ["lancer", "projeter", "balancer", "abandonner", "se débarrasser"],
        antonymes: ["garder", "conserver", "ramasser"]
    },
    "jeune": {
        synonymes: ["juvénile", "adolescent", "nouveau", "récent", "frais", "novice"],
        antonymes: ["vieux", "âgé", "ancien"]
    },
    "joie": {
        synonymes: ["bonheur", "allégresse", "gaieté", "contentement", "euphorie", "félicité"],
        antonymes: ["tristesse", "chagrin", "peine"]
    },
    "joli": {
        synonymes: ["beau", "mignon", "charmant", "ravissant", "gracieux", "élégant"],
        antonymes: ["laid", "moche", "vilain"]
    },
    "jouer": {
        synonymes: ["s'amuser", "se divertir", "interpréter", "parier", "miser"],
        antonymes: ["travailler", "s'ennuyer"]
    },
    "jour": {
        synonymes: ["journée", "date", "lumière", "clarté"],
        antonymes: ["nuit", "obscurité"]
    },
    "juste": {
        synonymes: ["équitable", "exact", "précis", "correct", "légitime", "honnête"],
        antonymes: ["injuste", "faux", "inexact"]
    },

    // ===== L =====
    "laisser": {
        synonymes: ["abandonner", "quitter", "permettre", "autoriser", "léguer", "confier"],
        antonymes: ["prendre", "garder", "retenir"]
    },
    "large": {
        synonymes: ["ample", "vaste", "spacieux", "étendu", "grand", "généreux"],
        antonymes: ["étroit", "serré", "exigu"]
    },
    "léger": {
        synonymes: ["aérien", "fin", "délicat", "superficiel", "insignifiant", "agile"],
        antonymes: ["lourd", "pesant", "grave"]
    },
    "lent": {
        synonymes: ["lentement", "posé", "graduel", "progressif", "paresseux", "traînant"],
        antonymes: ["rapide", "vif", "prompt"]
    },
    "liberté": {
        synonymes: ["indépendance", "autonomie", "émancipation", "affranchissement", "latitude"],
        antonymes: ["captivité", "esclavage", "servitude"]
    },
    "lire": {
        synonymes: ["parcourir", "déchiffrer", "consulter", "étudier", "bouquiner"],
        antonymes: ["écrire"]
    },
    "loin": {
        synonymes: ["distant", "éloigné", "reculé", "écarté"],
        antonymes: ["près", "proche", "adjacent"]
    },
    "long": {
        synonymes: ["allongé", "étendu", "prolongé", "interminable", "durable"],
        antonymes: ["court", "bref", "succinct"]
    },
    "lourd": {
        synonymes: ["pesant", "massif", "épais", "accablant", "pénible", "oppressant"],
        antonymes: ["léger", "aérien"]
    },
    "lumière": {
        synonymes: ["clarté", "éclat", "lueur", "rayonnement", "brillance", "jour"],
        antonymes: ["obscurité", "ténèbres", "ombre"]
    },

    // ===== M =====
    "magnifique": {
        synonymes: ["splendide", "superbe", "grandiose", "somptueux", "merveilleux", "sublime"],
        antonymes: ["affreux", "horrible", "laid"]
    },
    "maintenant": {
        synonymes: ["actuellement", "présentement", "à présent", "désormais", "aujourd'hui"],
        antonymes: ["autrefois", "jadis", "plus tard"]
    },
    "maison": {
        synonymes: ["demeure", "domicile", "logis", "habitation", "résidence", "foyer"],
        antonymes: []
    },
    "mal": {
        synonymes: ["douleur", "souffrance", "tort", "dommage", "malheur", "difficulté"],
        antonymes: ["bien", "bonheur", "plaisir"]
    },
    "malheur": {
        synonymes: ["infortune", "adversité", "calamité", "tragédie", "catastrophe", "drame"],
        antonymes: ["bonheur", "chance", "joie"]
    },
    "manger": {
        synonymes: ["se nourrir", "consommer", "dévorer", "avaler", "ingérer", "déguster"],
        antonymes: ["jeûner", "vomir"]
    },
    "marcher": {
        synonymes: ["avancer", "déambuler", "cheminer", "progresser", "fonctionner"],
        antonymes: ["s'arrêter", "courir"]
    },
    "mauvais": {
        synonymes: ["méchant", "néfaste", "nuisible", "nocif", "détestable", "défavorable"],
        antonymes: ["bon", "excellent", "favorable"]
    },
    "méchant": {
        synonymes: ["mauvais", "cruel", "malveillant", "vilain", "malicieux", "hostile"],
        antonymes: ["gentil", "bon", "bienveillant"]
    },
    "meilleur": {
        synonymes: ["supérieur", "excellent", "optimal", "idéal", "préférable"],
        antonymes: ["pire", "inférieur"]
    },
    "même": {
        synonymes: ["identique", "semblable", "pareil", "égal", "analogue"],
        antonymes: ["différent", "autre", "distinct"]
    },
    "mentir": {
        synonymes: ["tromper", "duper", "mystifier", "abuser", "falsifier"],
        antonymes: ["dire la vérité", "avouer"]
    },
    "mettre": {
        synonymes: ["placer", "poser", "disposer", "installer", "ranger", "enfiler"],
        antonymes: ["enlever", "retirer", "ôter"]
    },
    "monde": {
        synonymes: ["univers", "terre", "humanité", "société", "gens", "foule"],
        antonymes: []
    },
    "montrer": {
        synonymes: ["indiquer", "présenter", "exhiber", "exposer", "révéler", "démontrer"],
        antonymes: ["cacher", "dissimuler"]
    },
    "mort": {
        synonymes: ["décès", "trépas", "fin", "disparition", "perte"],
        antonymes: ["vie", "naissance"]
    },
    "mourir": {
        synonymes: ["décéder", "périr", "trépasser", "s'éteindre", "succomber", "expirer"],
        antonymes: ["naître", "vivre", "survivre"]
    },
    "mystère": {
        synonymes: ["énigme", "secret", "mystification", "inconnu", "ombre"],
        antonymes: ["évidence", "clarté", "certitude"]
    },

    // ===== N =====
    "naître": {
        synonymes: ["voir le jour", "apparaître", "émerger", "surgir", "commencer"],
        antonymes: ["mourir", "disparaître"]
    },
    "naturel": {
        synonymes: ["authentique", "spontané", "normal", "inné", "simple", "pur"],
        antonymes: ["artificiel", "forcé", "affecté"]
    },
    "nécessaire": {
        synonymes: ["indispensable", "essentiel", "obligatoire", "requis", "vital", "inévitable"],
        antonymes: ["superflu", "inutile", "facultatif"]
    },
    "neuf": {
        synonymes: ["nouveau", "récent", "frais", "moderne", "inédit", "original"],
        antonymes: ["vieux", "ancien", "usé"]
    },
    "noir": {
        synonymes: ["sombre", "obscur", "ténébreux", "foncé", "sinistre"],
        antonymes: ["blanc", "clair", "lumineux"]
    },
    "nom": {
        synonymes: ["appellation", "dénomination", "désignation", "titre", "surnom"],
        antonymes: []
    },
    "normal": {
        synonymes: ["habituel", "ordinaire", "courant", "régulier", "naturel", "usuel"],
        antonymes: ["anormal", "exceptionnel", "bizarre"]
    },
    "nouveau": {
        synonymes: ["neuf", "récent", "moderne", "inédit", "original", "frais"],
        antonymes: ["ancien", "vieux", "usé"]
    },
    "nuit": {
        synonymes: ["obscurité", "ténèbres", "soir", "crépuscule", "noirceur"],
        antonymes: ["jour", "lumière", "clarté"]
    },

    // ===== O =====
    "obscur": {
        synonymes: ["sombre", "ténébreux", "noir", "confus", "incompréhensible", "mystérieux"],
        antonymes: ["clair", "lumineux", "limpide"]
    },
    "obtenir": {
        synonymes: ["acquérir", "gagner", "recevoir", "décrocher", "remporter", "atteindre"],
        antonymes: ["perdre", "manquer"]
    },
    "offrir": {
        synonymes: ["donner", "présenter", "proposer", "accorder", "fournir"],
        antonymes: ["prendre", "refuser", "recevoir"]
    },
    "opinion": {
        synonymes: ["avis", "point de vue", "sentiment", "jugement", "pensée", "conviction"],
        antonymes: []
    },
    "ordre": {
        synonymes: ["commandement", "instruction", "directive", "organisation", "rangement"],
        antonymes: ["désordre", "chaos"]
    },
    "oublier": {
        synonymes: ["omettre", "négliger", "ignorer", "délaisser", "manquer"],
        antonymes: ["se souvenir", "retenir", "mémoriser"]
    },
    "ouvrir": {
        synonymes: ["déboucher", "déverrouiller", "entrouvrir", "inaugurer", "commencer"],
        antonymes: ["fermer", "clore", "verrouiller"]
    },

    // ===== P =====
    "paix": {
        synonymes: ["calme", "tranquillité", "sérénité", "harmonie", "concorde", "quiétude"],
        antonymes: ["guerre", "conflit", "agitation"]
    },
    "parler": {
        synonymes: ["dire", "s'exprimer", "converser", "discuter", "bavarder", "causer"],
        antonymes: ["se taire", "écouter"]
    },
    "partir": {
        synonymes: ["s'en aller", "quitter", "décamper", "filer", "déguerpir", "s'éclipser"],
        antonymes: ["arriver", "rester", "venir"]
    },
    "passer": {
        synonymes: ["traverser", "franchir", "dépasser", "circuler", "s'écouler"],
        antonymes: ["rester", "demeurer"]
    },
    "pauvre": {
        synonymes: ["misérable", "démuni", "indigent", "nécessiteux", "malheureux"],
        antonymes: ["riche", "fortuné", "aisé"]
    },
    "pays": {
        synonymes: ["nation", "état", "patrie", "territoire", "contrée", "région"],
        antonymes: []
    },
    "peine": {
        synonymes: ["chagrin", "tristesse", "douleur", "souffrance", "difficulté", "effort"],
        antonymes: ["joie", "plaisir", "bonheur"]
    },
    "penser": {
        synonymes: ["réfléchir", "songer", "méditer", "croire", "estimer", "juger"],
        antonymes: []
    },
    "perdre": {
        synonymes: ["égarer", "manquer", "gaspiller", "échouer"],
        antonymes: ["gagner", "trouver", "retrouver"]
    },
    "permettre": {
        synonymes: ["autoriser", "laisser", "tolérer", "accepter", "accorder", "consentir"],
        antonymes: ["interdire", "défendre", "empêcher"]
    },
    "personnage": {
        synonymes: ["personne", "individu", "figure", "héros", "protagoniste", "caractère"],
        antonymes: []
    },
    "petit": {
        synonymes: ["minuscule", "menu", "mince", "modeste", "réduit", "court"],
        antonymes: ["grand", "immense", "énorme"]
    },
    "peur": {
        synonymes: ["crainte", "frayeur", "terreur", "angoisse", "effroi", "épouvante"],
        antonymes: ["courage", "audace", "bravoure"]
    },
    "plaisir": {
        synonymes: ["joie", "bonheur", "satisfaction", "contentement", "délice", "agrément"],
        antonymes: ["déplaisir", "peine", "souffrance"]
    },
    "pleurer": {
        synonymes: ["sangloter", "larmoyer", "gémir", "se lamenter", "chialer"],
        antonymes: ["rire", "sourire"]
    },
    "pouvoir": {
        synonymes: ["être capable", "avoir la possibilité", "autorité", "puissance", "force"],
        antonymes: ["impuissance", "incapacité"]
    },
    "premier": {
        synonymes: ["initial", "principal", "primordial", "originel", "antérieur"],
        antonymes: ["dernier", "final"]
    },
    "prendre": {
        synonymes: ["saisir", "attraper", "emporter", "capturer", "s'emparer"],
        antonymes: ["donner", "lâcher", "rendre"]
    },
    "présent": {
        synonymes: ["actuel", "contemporain", "cadeau", "don", "maintenant"],
        antonymes: ["absent", "passé", "futur"]
    },
    "problème": {
        synonymes: ["difficulté", "souci", "ennui", "complication", "obstacle", "question"],
        antonymes: ["solution", "réponse"]
    },
    "proche": {
        synonymes: ["près", "voisin", "adjacent", "imminent", "intime", "similaire"],
        antonymes: ["loin", "éloigné", "distant"]
    },
    "profond": {
        synonymes: ["abyssal", "intense", "sérieux", "grave", "intime", "ancré"],
        antonymes: ["superficiel", "léger"]
    },
    "projet": {
        synonymes: ["plan", "programme", "intention", "dessein", "entreprise", "objectif"],
        antonymes: []
    },
    "proposer": {
        synonymes: ["suggérer", "offrir", "soumettre", "présenter", "recommander"],
        antonymes: ["refuser", "imposer"]
    },
    "protéger": {
        synonymes: ["défendre", "préserver", "sauvegarder", "abriter", "garantir", "couvrir"],
        antonymes: ["exposer", "menacer", "attaquer"]
    },
    "puissant": {
        synonymes: ["fort", "robuste", "vigoureux", "influent", "imposant", "efficace"],
        antonymes: ["faible", "impuissant"]
    },

    // ===== Q =====
    "question": {
        synonymes: ["interrogation", "demande", "problème", "sujet", "affaire", "point"],
        antonymes: ["réponse", "solution"]
    },
    "quitter": {
        synonymes: ["partir", "abandonner", "laisser", "délaisser", "s'en aller"],
        antonymes: ["rester", "demeurer", "rejoindre"]
    },

    // ===== R =====
    "rapide": {
        synonymes: ["vite", "prompt", "véloce", "express", "fulgurant", "instantané"],
        antonymes: ["lent", "lentement"]
    },
    "raison": {
        synonymes: ["motif", "cause", "logique", "jugement", "bon sens", "argument"],
        antonymes: ["tort", "folie"]
    },
    "recevoir": {
        synonymes: ["obtenir", "accueillir", "percevoir", "accepter", "toucher"],
        antonymes: ["donner", "envoyer", "refuser"]
    },
    "rechercher": {
        synonymes: ["chercher", "quêter", "explorer", "poursuivre", "traquer"],
        antonymes: ["trouver", "abandonner"]
    },
    "refuser": {
        synonymes: ["rejeter", "décliner", "repousser", "nier", "récuser"],
        antonymes: ["accepter", "admettre", "consentir"]
    },
    "regarder": {
        synonymes: ["observer", "voir", "contempler", "examiner", "fixer", "scruter"],
        antonymes: ["ignorer", "détourner"]
    },
    "rendre": {
        synonymes: ["restituer", "retourner", "remettre", "faire", "transformer"],
        antonymes: ["garder", "prendre", "conserver"]
    },
    "répondre": {
        synonymes: ["répliquer", "rétorquer", "réagir", "satisfaire", "correspondre"],
        antonymes: ["demander", "questionner"]
    },
    "repos": {
        synonymes: ["détente", "relaxation", "pause", "sommeil", "tranquillité", "calme"],
        antonymes: ["travail", "activité", "fatigue"]
    },
    "résultat": {
        synonymes: ["conséquence", "effet", "aboutissement", "issue", "fruit", "bilan"],
        antonymes: ["cause", "origine"]
    },
    "rêve": {
        synonymes: ["songe", "illusion", "utopie", "chimère", "fantaisie", "aspiration"],
        antonymes: ["réalité", "cauchemar"]
    },
    "riche": {
        synonymes: ["fortuné", "aisé", "opulent", "nanti", "prospère", "cossu"],
        antonymes: ["pauvre", "démuni", "misérable"]
    },
    "rire": {
        synonymes: ["s'esclaffer", "ricaner", "glousser", "pouffer", "se marrer"],
        antonymes: ["pleurer", "sangloter"]
    },
    "rouge": {
        synonymes: ["vermeil", "écarlate", "pourpre", "cramoisi", "rubis", "carmin"],
        antonymes: []
    },
    "route": {
        synonymes: ["chemin", "voie", "trajet", "parcours", "itinéraire", "rue"],
        antonymes: []
    },

    // ===== S =====
    "sage": {
        synonymes: ["prudent", "raisonnable", "sensé", "avisé", "calme", "obéissant"],
        antonymes: ["fou", "turbulent", "imprudent"]
    },
    "savoir": {
        synonymes: ["connaître", "maîtriser", "apprendre", "comprendre", "connaissance"],
        antonymes: ["ignorer", "méconnaître"]
    },
    "secret": {
        synonymes: ["mystère", "confidence", "énigme", "discret", "caché", "intime"],
        antonymes: ["public", "ouvert", "évident"]
    },
    "sentir": {
        synonymes: ["ressentir", "éprouver", "percevoir", "flairer", "humer"],
        antonymes: []
    },
    "sérieux": {
        synonymes: ["grave", "important", "rigoureux", "consciencieux", "appliqué"],
        antonymes: ["léger", "frivole", "amusant"]
    },
    "seul": {
        synonymes: ["unique", "solitaire", "isolé", "abandonné", "esseulé"],
        antonymes: ["accompagné", "ensemble"]
    },
    "silence": {
        synonymes: ["calme", "tranquillité", "mutisme", "paix", "quiétude"],
        antonymes: ["bruit", "vacarme", "tapage"]
    },
    "simple": {
        synonymes: ["facile", "aisé", "élémentaire", "modeste", "naturel", "humble"],
        antonymes: ["compliqué", "complexe", "difficile"]
    },
    "sombre": {
        synonymes: ["obscur", "ténébreux", "noir", "triste", "mélancolique", "lugubre"],
        antonymes: ["clair", "lumineux", "gai"]
    },
    "sortir": {
        synonymes: ["quitter", "partir", "s'échapper", "émerger", "apparaître"],
        antonymes: ["entrer", "rester"]
    },
    "souffrir": {
        synonymes: ["pâtir", "endurer", "subir", "supporter", "peiner"],
        antonymes: ["jouir", "profiter"]
    },
    "soudain": {
        synonymes: ["brusque", "subit", "inattendu", "brutal", "imprévu", "soudainement"],
        antonymes: ["progressif", "graduel", "lent"]
    },
    "souvenir": {
        synonymes: ["mémoire", "réminiscence", "rappel", "évocation", "nostalgie"],
        antonymes: ["oubli"]
    },
    "suivre": {
        synonymes: ["accompagner", "poursuivre", "succéder", "observer", "obéir"],
        antonymes: ["précéder", "fuir", "devancer"]
    },
    "surprendre": {
        synonymes: ["étonner", "stupéfier", "ébahir", "déconcerter", "prendre au dépourvu"],
        antonymes: ["attendre", "prévoir"]
    },

    // ===== T =====
    "temps": {
        synonymes: ["durée", "époque", "moment", "période", "instant", "ère"],
        antonymes: []
    },
    "terminer": {
        synonymes: ["finir", "achever", "conclure", "clore", "accomplir", "compléter"],
        antonymes: ["commencer", "débuter", "entamer"]
    },
    "terre": {
        synonymes: ["sol", "monde", "planète", "terrain", "territoire", "pays"],
        antonymes: ["ciel", "mer"]
    },
    "terrible": {
        synonymes: ["effroyable", "épouvantable", "affreux", "horrible", "redoutable"],
        antonymes: ["merveilleux", "magnifique"]
    },
    "tomber": {
        synonymes: ["chuter", "s'effondrer", "dégringoler", "s'écrouler", "baisser"],
        antonymes: ["monter", "se lever", "grimper"]
    },
    "toucher": {
        synonymes: ["atteindre", "effleurer", "palper", "tâter", "émouvoir", "affecter"],
        antonymes: ["éviter", "manquer"]
    },
    "toujours": {
        synonymes: ["constamment", "perpétuellement", "éternellement", "sans cesse", "encore"],
        antonymes: ["jamais", "parfois"]
    },
    "tourner": {
        synonymes: ["pivoter", "virer", "orienter", "diriger", "changer"],
        antonymes: ["fixer", "immobiliser"]
    },
    "travail": {
        synonymes: ["labeur", "ouvrage", "tâche", "emploi", "métier", "besogne", "effort"],
        antonymes: ["repos", "loisir", "chômage"]
    },
    "travailler": {
        synonymes: ["oeuvrer", "bosser", "besogner", "exercer", "opérer"],
        antonymes: ["se reposer", "chômer"]
    },
    "triste": {
        synonymes: ["malheureux", "mélancolique", "chagriné", "affligé", "morose", "abattu"],
        antonymes: ["joyeux", "heureux", "gai"]
    },
    "trouver": {
        synonymes: ["découvrir", "dénicher", "rencontrer", "localiser", "estimer", "juger"],
        antonymes: ["perdre", "chercher", "égarer"]
    },

    // ===== U =====
    "unique": {
        synonymes: ["seul", "exclusif", "singulier", "rare", "exceptionnel", "incomparable"],
        antonymes: ["multiple", "commun", "ordinaire"]
    },
    "utile": {
        synonymes: ["pratique", "nécessaire", "bénéfique", "profitable", "avantageux"],
        antonymes: ["inutile", "superflu"]
    },

    // ===== V =====
    "venir": {
        synonymes: ["arriver", "se rendre", "approcher", "survenir", "provenir"],
        antonymes: ["partir", "s'en aller"]
    },
    "vérité": {
        synonymes: ["exactitude", "réalité", "authenticité", "sincérité", "justesse"],
        antonymes: ["mensonge", "fausseté", "erreur"]
    },
    "vie": {
        synonymes: ["existence", "vivant", "vitalité", "animation", "biographie"],
        antonymes: ["mort", "décès", "trépas"]
    },
    "vieux": {
        synonymes: ["âgé", "ancien", "antique", "vétuste", "usé", "désuet"],
        antonymes: ["jeune", "neuf", "nouveau"]
    },
    "ville": {
        synonymes: ["cité", "agglomération", "métropole", "commune", "localité"],
        antonymes: ["campagne", "village"]
    },
    "violence": {
        synonymes: ["brutalité", "agressivité", "force", "fureur", "férocité"],
        antonymes: ["douceur", "calme", "paix"]
    },
    "visage": {
        synonymes: ["figure", "face", "traits", "mine", "physionomie", "faciès"],
        antonymes: []
    },
    "vite": {
        synonymes: ["rapidement", "promptement", "prestement", "vélocement", "aussitôt"],
        antonymes: ["lentement", "doucement"]
    },
    "vivre": {
        synonymes: ["exister", "habiter", "résider", "subsister", "durer"],
        antonymes: ["mourir", "périr"]
    },
    "voir": {
        synonymes: ["apercevoir", "regarder", "observer", "contempler", "distinguer", "percevoir"],
        antonymes: ["ignorer", "manquer"]
    },
    "voix": {
        synonymes: ["son", "parole", "ton", "timbre", "organe"],
        antonymes: ["silence"]
    },
    "vouloir": {
        synonymes: ["désirer", "souhaiter", "aspirer", "ambitionner", "exiger"],
        antonymes: ["refuser", "rejeter"]
    },
    "voyage": {
        synonymes: ["trajet", "périple", "expédition", "excursion", "parcours", "déplacement"],
        antonymes: ["séjour", "immobilité"]
    },
    "vrai": {
        synonymes: ["authentique", "véridique", "réel", "sincère", "exact", "juste"],
        antonymes: ["faux", "mensonger", "fictif"]
    },

    // ===== Y =====
    "yeux": {
        synonymes: ["regard", "vue", "prunelles", "orbites"],
        antonymes: []
    }
};

/**
 * Recherche des synonymes dans le dictionnaire local
 * @param {string} word - Mot à rechercher
 * @returns {Array} Liste de synonymes formatés
 * [MVVM : Data]
 */
function searchLocalSynonyms(word) {
    const cleanWord = word.toLowerCase().trim();
    const entry = FrenchSynonymsDictionary[cleanWord];

    if (!entry) {
        // Recherche partielle (mots qui commencent par...)
        const partialMatches = [];
        for (const [key, value] of Object.entries(FrenchSynonymsDictionary)) {
            if (key.startsWith(cleanWord) && value.synonymes) {
                partialMatches.push(...value.synonymes.slice(0, 3));
            }
        }
        if (partialMatches.length > 0) {
            return [...new Set(partialMatches)].slice(0, 10).map((syn, index) => ({
                word: syn,
                score: 100 - index * 5,
                tags: [],
                category: 'autre'
            }));
        }
        return [];
    }

    return (entry.synonymes || []).map((syn, index) => ({
        word: syn,
        score: 100 - index * 5,
        tags: [],
        category: 'autre'
    }));
}

/**
 * Recherche des antonymes dans le dictionnaire local
 * @param {string} word - Mot à rechercher
 * @returns {Array} Liste d'antonymes formatés
 * [MVVM : Data]
 */
function searchLocalAntonyms(word) {
    const cleanWord = word.toLowerCase().trim();
    const entry = FrenchSynonymsDictionary[cleanWord];

    if (!entry || !entry.antonymes) {
        return [];
    }

    return entry.antonymes.map((ant, index) => ({
        word: ant,
        score: 100 - index * 5,
        tags: [],
        category: 'autre'
    }));
}

/**
 * Recherche des mots similaires (qui contiennent le mot recherché)
 * @param {string} word - Mot à rechercher
 * @returns {Array} Liste de mots similaires
 * [MVVM : Data]
 */
function searchLocalSimilar(word) {
    const cleanWord = word.toLowerCase().trim();
    const similar = [];

    for (const key of Object.keys(FrenchSynonymsDictionary)) {
        if (key.includes(cleanWord) && key !== cleanWord) {
            similar.push({
                word: key,
                score: 80,
                tags: [],
                category: 'autre'
            });
        }
    }

    return similar.slice(0, 10);
}

// Export pour utilisation dans d'autres modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        FrenchSynonymsDictionary,
        searchLocalSynonyms,
        searchLocalAntonyms,
        searchLocalSimilar
    };
}

// ========== js-refactor/synonyms/synonyms.service.js ==========
// ============================================================
// synonyms.service.js - Service pour les synonymes français
// ============================================================
// [MVVM : Service] - Utilise le dictionnaire local français

/**
 * Service de synonymes - Utilise le dictionnaire local français
 * [MVVM : Service]
 */
const SynonymsService = {
    /**
     * Recherche des synonymes pour un mot (dictionnaire local)
     * @param {string} word - Mot à rechercher
     * @returns {Promise<Array>} Liste de synonymes
     * [MVVM : Service]
     */
    async fetchSynonyms(word) {
        const cleanWord = word.toLowerCase().trim();
        if (!cleanWord) {
            return [];
        }

        // Utiliser le dictionnaire local français
        const results = searchLocalSynonyms(cleanWord);

        // Si pas de résultats, chercher dans les synonymes existants
        if (results.length === 0) {
            return this._searchInAllSynonyms(cleanWord);
        }

        return results;
    },

    /**
     * Recherche des mots similaires
     * @param {string} word - Mot à rechercher
     * @returns {Promise<Array>} Liste de mots similaires
     * [MVVM : Service]
     */
    async fetchSimilar(word) {
        const cleanWord = word.toLowerCase().trim();
        if (!cleanWord) {
            return [];
        }

        return searchLocalSimilar(cleanWord);
    },

    /**
     * Recherche des rimes (basé sur la terminaison)
     * @param {string} word - Mot à rechercher
     * @returns {Promise<Array>} Liste de rimes
     * [MVVM : Service]
     */
    async fetchRhymes(word) {
        const cleanWord = word.toLowerCase().trim();
        if (!cleanWord || cleanWord.length < 2) {
            return [];
        }

        // Trouver les mots qui riment (même terminaison)
        const ending = cleanWord.slice(-3);
        const ending2 = cleanWord.slice(-2);
        const rhymes = [];

        for (const key of Object.keys(FrenchSynonymsDictionary)) {
            if (key !== cleanWord) {
                if (key.endsWith(ending)) {
                    rhymes.push({ word: key, score: 100, tags: [], category: 'rime riche' });
                } else if (key.endsWith(ending2)) {
                    rhymes.push({ word: key, score: 70, tags: [], category: 'rime suffisante' });
                }
            }
        }

        // Trier par score et limiter
        return rhymes.sort((a, b) => b.score - a.score).slice(0, 15);
    },

    /**
     * Recherche des antonymes
     * @param {string} word - Mot à rechercher
     * @returns {Promise<Array>} Liste d'antonymes
     * [MVVM : Service]
     */
    async fetchAntonyms(word) {
        const cleanWord = word.toLowerCase().trim();
        if (!cleanWord) {
            return [];
        }

        return searchLocalAntonyms(cleanWord);
    },

    /**
     * Recherche générique selon le type
     * @param {string} word - Mot à rechercher
     * @param {string} type - Type de recherche
     * @returns {Promise<Array>} Résultats
     * [MVVM : Service]
     */
    async fetch(word, type = SynonymsConfig.searchTypes.SYNONYMS) {
        switch (type) {
            case SynonymsConfig.searchTypes.SYNONYMS:
                return this.fetchSynonyms(word);
            case SynonymsConfig.searchTypes.SIMILAR:
                return this.fetchSimilar(word);
            case SynonymsConfig.searchTypes.RHYMES:
                return this.fetchRhymes(word);
            case SynonymsConfig.searchTypes.ANTONYMS:
                return this.fetchAntonyms(word);
            default:
                return this.fetchSynonyms(word);
        }
    },

    /**
     * Recherche un mot dans tous les synonymes du dictionnaire
     * @param {string} word - Mot à rechercher
     * @returns {Array} Mots dont le mot recherché est un synonyme
     * [MVVM : Service]
     */
    _searchInAllSynonyms(word) {
        const results = [];

        for (const [key, entry] of Object.entries(FrenchSynonymsDictionary)) {
            if (entry.synonymes && entry.synonymes.includes(word)) {
                // Le mot recherché est un synonyme de 'key'
                // Donc on retourne les autres synonymes de 'key'
                results.push({ word: key, score: 100, tags: [], category: 'autre' });
                entry.synonymes.forEach((syn, index) => {
                    if (syn !== word && !results.find(r => r.word === syn)) {
                        results.push({ word: syn, score: 90 - index, tags: [], category: 'autre' });
                    }
                });
            }
        }

        return results.slice(0, 15);
    },

    /**
     * Vérifie si le service est disponible
     * @returns {boolean}
     * [MVVM : Service]
     */
    isOnline() {
        // Le dictionnaire local est toujours disponible
        return true;
    },

    /**
     * Teste le service
     * @returns {Promise<boolean>}
     * [MVVM : Service]
     */
    async testConnection() {
        try {
            const results = await this.fetchSynonyms('bonheur');
            return results.length > 0;
        } catch (error) {
            console.warn('[SynonymsService] Test échoué:', error.message);
            return false;
        }
    },

    /**
     * Retourne des statistiques sur le dictionnaire
     * @returns {Object}
     * [MVVM : Service]
     */
    getStats() {
        const entries = Object.keys(FrenchSynonymsDictionary).length;
        let totalSynonyms = 0;
        let totalAntonyms = 0;

        for (const entry of Object.values(FrenchSynonymsDictionary)) {
            totalSynonyms += (entry.synonymes || []).length;
            totalAntonyms += (entry.antonymes || []).length;
        }

        return {
            entries,
            totalSynonyms,
            totalAntonyms,
            avgSynonymsPerWord: Math.round(totalSynonyms / entries * 10) / 10
        };
    }
};

// Export pour utilisation dans d'autres modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { SynonymsService };
}

// ========== js-refactor/synonyms/synonyms.repository.js ==========
// ============================================================
// synonyms.repository.js - Repository pour le cache des synonymes
// ============================================================
// [MVVM : Repository] - Gestion du cache local (localStorage)

/**
 * Repository pour le cache des synonymes
 * [MVVM : Repository]
 */
const SynonymsRepository = {
    _cache: null,

    /**
     * Initialise le repository et charge le cache
     * [MVVM : Repository]
     */
    init() {
        this._loadCache();
        this._cleanExpiredEntries();
        return this;
    },

    /**
     * Charge le cache depuis localStorage
     * [MVVM : Repository]
     */
    _loadCache() {
        try {
            const stored = localStorage.getItem(SynonymsConfig.cache.storageKey);
            this._cache = stored ? JSON.parse(stored) : {};
        } catch (error) {
            console.warn('[SynonymsRepository] Erreur chargement cache:', error);
            this._cache = {};
        }
    },

    /**
     * Sauvegarde le cache dans localStorage
     * [MVVM : Repository]
     */
    _saveCache() {
        try {
            localStorage.setItem(SynonymsConfig.cache.storageKey, JSON.stringify(this._cache));
        } catch (error) {
            console.warn('[SynonymsRepository] Erreur sauvegarde cache:', error);
            // Si quota dépassé, nettoyer les anciennes entrées
            if (error.name === 'QuotaExceededError') {
                this._evictOldestEntries(50);
                this._saveCache();
            }
        }
    },

    /**
     * Nettoie les entrées expirées du cache
     * [MVVM : Repository]
     */
    _cleanExpiredEntries() {
        let hasChanges = false;
        for (const key of Object.keys(this._cache)) {
            if (CacheEntry.isExpired(this._cache[key])) {
                delete this._cache[key];
                hasChanges = true;
            }
        }
        if (hasChanges) {
            this._saveCache();
        }
    },

    /**
     * Supprime les N entrées les plus anciennes
     * [MVVM : Repository]
     */
    _evictOldestEntries(count) {
        const entries = Object.entries(this._cache)
            .sort((a, b) => a[1].cachedAt - b[1].cachedAt);

        for (let i = 0; i < Math.min(count, entries.length); i++) {
            delete this._cache[entries[i][0]];
        }
    },

    /**
     * Récupère une entrée du cache
     * @param {string} word - Mot recherché
     * @param {string} type - Type de recherche
     * @returns {Object|null} Entrée de cache ou null
     * [MVVM : Repository]
     */
    get(word, type = SynonymsConfig.searchTypes.SYNONYMS) {
        if (!SynonymsConfig.cache.enabled) {
            return null;
        }

        const id = SynonymsSearch.generateId(word, type);
        const entry = this._cache[id];

        if (!entry) {
            return null;
        }

        // Vérifier si l'entrée est expirée
        if (CacheEntry.isExpired(entry)) {
            delete this._cache[id];
            this._saveCache();
            return null;
        }

        return entry;
    },

    /**
     * Ajoute une entrée au cache
     * @param {Object} search - Objet recherche avec résultats
     * @returns {Object} Entrée de cache créée
     * [MVVM : Repository]
     */
    set(search) {
        if (!SynonymsConfig.cache.enabled) {
            return null;
        }

        // Limiter le nombre d'entrées
        if (Object.keys(this._cache).length >= SynonymsConfig.cache.maxEntries) {
            this._evictOldestEntries(50);
        }

        const entry = CacheEntry.create(search);
        this._cache[entry.id] = entry;
        this._saveCache();

        return entry;
    },

    /**
     * Supprime une entrée du cache
     * @param {string} word - Mot recherché
     * @param {string} type - Type de recherche
     * [MVVM : Repository]
     */
    remove(word, type = SynonymsConfig.searchTypes.SYNONYMS) {
        const id = SynonymsSearch.generateId(word, type);
        if (this._cache[id]) {
            delete this._cache[id];
            this._saveCache();
        }
    },

    /**
     * Vide entièrement le cache
     * [MVVM : Repository]
     */
    clear() {
        this._cache = {};
        this._saveCache();
    },

    /**
     * Retourne les statistiques du cache
     * @returns {Object} Stats du cache
     * [MVVM : Repository]
     */
    getStats() {
        const entries = Object.values(this._cache);
        return {
            totalEntries: entries.length,
            maxEntries: SynonymsConfig.cache.maxEntries,
            oldestEntry: entries.length > 0
                ? new Date(Math.min(...entries.map(e => e.cachedAt)))
                : null,
            newestEntry: entries.length > 0
                ? new Date(Math.max(...entries.map(e => e.cachedAt)))
                : null
        };
    },

    /**
     * Récupère l'historique des recherches récentes
     * @param {number} limit - Nombre max de résultats
     * @returns {Array} Liste des mots recherchés récemment
     * [MVVM : Repository]
     */
    getRecentSearches(limit = 10) {
        return Object.values(this._cache)
            .sort((a, b) => b.cachedAt - a.cachedAt)
            .slice(0, limit)
            .map(entry => ({
                word: entry.word,
                type: entry.type,
                date: new Date(entry.cachedAt)
            }));
    }
};

// Auto-initialisation
SynonymsRepository.init();

// Export pour utilisation dans d'autres modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { SynonymsRepository };
}

// ========== js-refactor/synonyms/synonyms.viewmodel.js ==========
// ============================================================
// synonyms.viewmodel.js - ViewModel pour les synonymes
// ============================================================
// [MVVM : ViewModel] - Logique métier et orchestration

/**
 * État global de l'interface synonymes
 * [MVVM : ViewModel]
 */
let synonymsState = SynonymsUIState.createInitialState();

/**
 * ViewModel pour les synonymes
 * [MVVM : ViewModel]
 */
const SynonymsViewModel = {
    /**
     * Recherche des synonymes pour un mot
     * @param {string} word - Mot à rechercher
     * @param {string} type - Type de recherche
     * @returns {Promise<Object>} Résultat de la recherche
     * [MVVM : ViewModel]
     */
    async searchWord(word, type = SynonymsConfig.searchTypes.SYNONYMS) {
        const cleanWord = word.toLowerCase().trim();

        if (!cleanWord) {
            return {
                success: false,
                error: 'Mot vide',
                results: [],
                fromCache: false
            };
        }

        // Mettre à jour l'état
        synonymsState.isLoading = true;
        synonymsState.currentWord = cleanWord;
        synonymsState.currentType = type;
        synonymsState.error = null;

        // Vérifier d'abord le cache
        const cachedEntry = SynonymsRepository.get(cleanWord, type);
        if (cachedEntry) {
            synonymsState.isLoading = false;
            synonymsState.results = cachedEntry.results;

            return {
                success: true,
                results: cachedEntry.results,
                fromCache: true,
                word: cleanWord,
                type: type
            };
        }

        // Si pas en cache, appeler l'API
        try {
            const results = await SynonymsService.fetch(cleanWord, type);

            // Créer l'objet recherche et le mettre en cache
            const search = SynonymsSearch.create(cleanWord, type);
            search.results = results;
            SynonymsRepository.set(search);

            // Mettre à jour l'état
            synonymsState.isLoading = false;
            synonymsState.results = results;

            // Ajouter à l'historique
            this._addToHistory(cleanWord, type);

            return {
                success: true,
                results: results,
                fromCache: false,
                word: cleanWord,
                type: type
            };

        } catch (error) {
            synonymsState.isLoading = false;
            synonymsState.error = error.message;
            synonymsState.results = [];

            return {
                success: false,
                error: error.message,
                results: [],
                fromCache: false,
                isOffline: !SynonymsService.isOnline()
            };
        }
    },

    /**
     * Recherche de synonymes
     * [MVVM : ViewModel]
     */
    async searchSynonyms(word) {
        return this.searchWord(word, SynonymsConfig.searchTypes.SYNONYMS);
    },

    /**
     * Recherche de mots similaires
     * [MVVM : ViewModel]
     */
    async searchSimilar(word) {
        return this.searchWord(word, SynonymsConfig.searchTypes.SIMILAR);
    },

    /**
     * Recherche de rimes
     * [MVVM : ViewModel]
     */
    async searchRhymes(word) {
        return this.searchWord(word, SynonymsConfig.searchTypes.RHYMES);
    },

    /**
     * Recherche d'antonymes
     * [MVVM : ViewModel]
     */
    async searchAntonyms(word) {
        return this.searchWord(word, SynonymsConfig.searchTypes.ANTONYMS);
    },

    /**
     * Retourne l'état actuel
     * @returns {Object} État de l'interface
     * [MVVM : ViewModel]
     */
    getState() {
        return { ...synonymsState };
    },

    /**
     * Ouvre la modal synonymes
     * @param {string} initialWord - Mot initial (optionnel)
     * @returns {Object} Résultat de l'opération
     * [MVVM : ViewModel]
     */
    openModal(initialWord = '') {
        synonymsState.isOpen = true;
        synonymsState.currentWord = initialWord;
        synonymsState.results = [];
        synonymsState.error = null;

        return {
            success: true,
            sideEffects: ['RENDER_MODAL']
        };
    },

    /**
     * Ferme la modal synonymes
     * @returns {Object} Résultat de l'opération
     * [MVVM : ViewModel]
     */
    closeModal() {
        synonymsState.isOpen = false;
        synonymsState.isLoading = false;

        return {
            success: true,
            sideEffects: ['CLOSE_MODAL']
        };
    },

    /**
     * Réinitialise l'état
     * [MVVM : ViewModel]
     */
    reset() {
        synonymsState = SynonymsUIState.createInitialState();
        return { success: true };
    },

    /**
     * Ajoute un mot à l'historique de recherche
     * @param {string} word - Mot recherché
     * @param {string} type - Type de recherche
     * [MVVM : ViewModel]
     */
    _addToHistory(word, type) {
        // Éviter les doublons consécutifs
        const lastSearch = synonymsState.history[0];
        if (lastSearch && lastSearch.word === word && lastSearch.type === type) {
            return;
        }

        synonymsState.history.unshift({ word, type, timestamp: Date.now() });

        // Limiter l'historique à 20 entrées
        if (synonymsState.history.length > 20) {
            synonymsState.history = synonymsState.history.slice(0, 20);
        }
    },

    /**
     * Retourne l'historique des recherches
     * @returns {Array} Historique
     * [MVVM : ViewModel]
     */
    getHistory() {
        return [...synonymsState.history];
    },

    /**
     * Retourne les recherches récentes depuis le cache
     * @param {number} limit - Nombre max
     * @returns {Array} Recherches récentes
     * [MVVM : ViewModel]
     */
    getRecentSearches(limit = 10) {
        return SynonymsRepository.getRecentSearches(limit);
    },

    /**
     * Vide le cache
     * @returns {Object} Résultat
     * [MVVM : ViewModel]
     */
    clearCache() {
        SynonymsRepository.clear();
        return {
            success: true,
            message: 'Cache vidé'
        };
    },

    /**
     * Retourne les stats du cache
     * @returns {Object} Statistiques
     * [MVVM : ViewModel]
     */
    getCacheStats() {
        return SynonymsRepository.getStats();
    },

    /**
     * Copie un mot dans le presse-papiers
     * @param {string} word - Mot à copier
     * @returns {Promise<Object>} Résultat
     * [MVVM : ViewModel]
     */
    async copyToClipboard(word) {
        try {
            await navigator.clipboard.writeText(word);
            return { success: true, word };
        } catch (error) {
            return { success: false, error: error.message };
        }
    },

    /**
     * Groupe les résultats par catégorie grammaticale
     * @param {Array} results - Résultats à grouper
     * @returns {Object} Résultats groupés
     * [MVVM : ViewModel]
     */
    groupResultsByCategory(results) {
        const groups = {
            nom: [],
            verbe: [],
            adjectif: [],
            adverbe: [],
            autre: []
        };

        results.forEach(result => {
            const category = result.category || 'autre';
            if (groups[category]) {
                groups[category].push(result);
            } else {
                groups.autre.push(result);
            }
        });

        // Filtrer les groupes vides
        return Object.fromEntries(
            Object.entries(groups).filter(([_, items]) => items.length > 0)
        );
    }
};

// Export pour utilisation dans d'autres modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { SynonymsViewModel, synonymsState };
}

// ========== js-refactor/synonyms/synonyms.view.js ==========
// ============================================================
// synonyms.view.js - Vue pour l'interface synonymes
// ============================================================
// [MVVM : View] - Rendu DOM et gestion des événements

/**
 * Vue pour le dictionnaire de synonymes
 * [MVVM : View]
 */
const SynonymsView = {
    _debounceTimer: null,
    _modal: null,
    _onInsertCallback: null,

    /**
     * Initialise la vue et crée la modal
     * [MVVM : View]
     */
    init() {
        this._createModal();
        this._bindGlobalEvents();
        return this;
    },

    /**
     * Crée la structure HTML de la modal
     * [MVVM : View]
     */
    _createModal() {
        // Vérifier si la modal existe déjà
        if (document.getElementById(SynonymsConfig.ui.modalId)) {
            this._modal = document.getElementById(SynonymsConfig.ui.modalId);
            return;
        }

        const modal = document.createElement('div');
        modal.id = SynonymsConfig.ui.modalId;
        modal.className = 'synonyms-modal';
        modal.innerHTML = `
            <div class="synonyms-modal-content">
                <div class="synonyms-header">
                    <h3>${getSynonymsMessage('title')}</h3>
                    <button class="synonyms-close-btn" title="${getSynonymsMessage('close')}">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <line x1="18" y1="6" x2="6" y2="18"></line>
                            <line x1="6" y1="6" x2="18" y2="18"></line>
                        </svg>
                    </button>
                </div>

                <div class="synonyms-search-box">
                    <input
                        type="text"
                        id="${SynonymsConfig.ui.inputId}"
                        placeholder="${getSynonymsMessage('placeholder')}"
                        autocomplete="off"
                    />
                    <div class="synonyms-search-icon">
                        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="11" cy="11" r="8"></circle>
                            <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                        </svg>
                    </div>
                </div>

                <div class="synonyms-tabs">
                    <button class="synonyms-tab active" data-type="synonyms">${getSynonymsMessage('synonyms')}</button>
                    <button class="synonyms-tab" data-type="similar">${getSynonymsMessage('similar')}</button>
                    <button class="synonyms-tab" data-type="rhymes">${getSynonymsMessage('rhymes')}</button>
                    <button class="synonyms-tab" data-type="antonyms">${getSynonymsMessage('antonyms')}</button>
                </div>

                <div class="synonyms-status"></div>

                <div id="${SynonymsConfig.ui.resultsId}" class="synonyms-results"></div>

                <div class="synonyms-recent">
                    <span class="synonyms-recent-label">Récents:</span>
                    <div class="synonyms-recent-list"></div>
                </div>
            </div>
        `;

        document.body.appendChild(modal);
        this._modal = modal;
        this._bindModalEvents();
    },

    /**
     * Lie les événements de la modal
     * [MVVM : View]
     */
    _bindModalEvents() {
        const modal = this._modal;
        const input = modal.querySelector(`#${SynonymsConfig.ui.inputId}`);
        const closeBtn = modal.querySelector('.synonyms-close-btn');
        const tabs = modal.querySelectorAll('.synonyms-tab');

        // Fermer la modal
        closeBtn.addEventListener('click', () => this.close());

        // Fermer en cliquant sur le fond
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                this.close();
            }
        });

        // Recherche avec debounce
        input.addEventListener('input', (e) => {
            clearTimeout(this._debounceTimer);
            this._debounceTimer = setTimeout(() => {
                this._performSearch(e.target.value);
            }, SynonymsConfig.ui.debounceDelay);
        });

        // Recherche sur Enter
        input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                clearTimeout(this._debounceTimer);
                this._performSearch(e.target.value);
            } else if (e.key === 'Escape') {
                this.close();
            }
        });

        // Changement d'onglet
        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                tabs.forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                const word = input.value.trim();
                if (word) {
                    this._performSearch(word, tab.dataset.type);
                }
            });
        });
    },

    /**
     * Lie les événements globaux (raccourcis clavier)
     * [MVVM : View]
     */
    _bindGlobalEvents() {
        // Raccourci Ctrl+Shift+S pour ouvrir le dictionnaire
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.shiftKey && e.key === 'S') {
                e.preventDefault();
                this.toggle();
            }
        });
    },

    /**
     * Effectue une recherche
     * @param {string} word - Mot à rechercher
     * @param {string} type - Type de recherche
     * [MVVM : View]
     */
    async _performSearch(word, type = null) {
        if (!word.trim()) {
            this._renderResults([]);
            return;
        }

        // Récupérer le type actif si non spécifié
        if (!type) {
            const activeTab = this._modal.querySelector('.synonyms-tab.active');
            type = activeTab ? activeTab.dataset.type : SynonymsConfig.searchTypes.SYNONYMS;
        }

        this._showStatus(getSynonymsMessage('searching'), 'loading');

        const result = await SynonymsViewModel.searchWord(word, type);

        if (result.success) {
            this._renderResults(result.results, result.fromCache);
            if (result.results.length === 0) {
                this._showStatus(getSynonymsMessage('noResults'), 'empty');
            } else {
                this._hideStatus();
            }
        } else {
            this._renderResults([]);
            const message = result.isOffline
                ? getSynonymsMessage('offline')
                : getSynonymsMessage('error');
            this._showStatus(message, 'error');
        }

        this._updateRecentSearches();
    },

    /**
     * Affiche les résultats
     * @param {Array} results - Résultats à afficher
     * @param {boolean} fromCache - Si les résultats viennent du cache
     * [MVVM : View]
     */
    _renderResults(results, fromCache = false) {
        const container = this._modal.querySelector(`#${SynonymsConfig.ui.resultsId}`);

        if (results.length === 0) {
            container.innerHTML = '';
            return;
        }

        // Limiter le nombre de résultats affichés
        const limitedResults = results.slice(0, SynonymsConfig.ui.maxDisplayResults);

        // Grouper par catégorie si activé
        if (SynonymsConfig.ui.groupByCategory) {
            const groups = SynonymsViewModel.groupResultsByCategory(limitedResults);
            container.innerHTML = this._renderGroupedResults(groups, fromCache);
        } else {
            container.innerHTML = this._renderFlatResults(limitedResults, fromCache);
        }

        // Lier les événements des boutons
        this._bindResultEvents();
    },

    /**
     * Rendu des résultats groupés par catégorie
     * [MVVM : View]
     */
    _renderGroupedResults(groups, fromCache) {
        const categoryLabels = {
            nom: 'Noms',
            verbe: 'Verbes',
            adjectif: 'Adjectifs',
            adverbe: 'Adverbes',
            autre: 'Autres'
        };

        let html = '';
        for (const [category, items] of Object.entries(groups)) {
            html += `
                <div class="synonyms-category">
                    <div class="synonyms-category-label">${categoryLabels[category] || category}</div>
                    <div class="synonyms-words">
                        ${items.map(item => this._renderWordItem(item, fromCache)).join('')}
                    </div>
                </div>
            `;
        }
        return html;
    },

    /**
     * Rendu des résultats en liste plate
     * [MVVM : View]
     */
    _renderFlatResults(results, fromCache) {
        return `
            <div class="synonyms-words">
                ${results.map(item => this._renderWordItem(item, fromCache)).join('')}
            </div>
        `;
    },

    /**
     * Rendu d'un mot individuel
     * [MVVM : View]
     */
    _renderWordItem(item, fromCache) {
        const scoreDisplay = SynonymsConfig.ui.showScores && item.score
            ? `<span class="synonyms-score">${item.score}</span>`
            : '';

        return `
            <div class="synonyms-word-item" data-word="${item.word}">
                <span class="synonyms-word">${item.word}</span>
                ${scoreDisplay}
                <div class="synonyms-word-actions">
                    <button class="synonyms-action-btn synonyms-copy-btn" title="${getSynonymsMessage('copy')}">
                        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                        </svg>
                    </button>
                    <button class="synonyms-action-btn synonyms-insert-btn" title="${getSynonymsMessage('insert')}">
                        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <line x1="12" y1="5" x2="12" y2="19"></line>
                            <line x1="5" y1="12" x2="19" y2="12"></line>
                        </svg>
                    </button>
                </div>
            </div>
        `;
    },

    /**
     * Lie les événements des résultats
     * [MVVM : View]
     */
    _bindResultEvents() {
        const container = this._modal.querySelector(`#${SynonymsConfig.ui.resultsId}`);

        // Copier
        container.querySelectorAll('.synonyms-copy-btn').forEach(btn => {
            btn.addEventListener('click', async (e) => {
                e.stopPropagation();
                const word = btn.closest('.synonyms-word-item').dataset.word;
                const result = await SynonymsViewModel.copyToClipboard(word);
                if (result.success) {
                    this._showToast('Copié !');
                }
            });
        });

        // Insérer
        container.querySelectorAll('.synonyms-insert-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                const word = btn.closest('.synonyms-word-item').dataset.word;
                this._insertWord(word);
            });
        });

        // Double-clic pour insérer
        container.querySelectorAll('.synonyms-word-item').forEach(item => {
            item.addEventListener('dblclick', () => {
                this._insertWord(item.dataset.word);
            });
        });
    },

    /**
     * Insère un mot (callback personnalisable)
     * @param {string} word - Mot à insérer
     * [MVVM : View]
     */
    _insertWord(word) {
        if (this._onInsertCallback) {
            this._onInsertCallback(word);
            this.close();
        } else {
            // Comportement par défaut: copier dans le presse-papiers
            SynonymsViewModel.copyToClipboard(word);
            this._showToast('Copié !');
        }
    },

    /**
     * Affiche un message de statut
     * [MVVM : View]
     */
    _showStatus(message, type = 'info') {
        const status = this._modal.querySelector('.synonyms-status');
        status.textContent = message;
        status.className = `synonyms-status synonyms-status-${type}`;
        status.style.display = 'block';
    },

    /**
     * Cache le message de statut
     * [MVVM : View]
     */
    _hideStatus() {
        const status = this._modal.querySelector('.synonyms-status');
        status.style.display = 'none';
    },

    /**
     * Met à jour la liste des recherches récentes
     * [MVVM : View]
     */
    _updateRecentSearches() {
        const recentList = this._modal.querySelector('.synonyms-recent-list');
        const recent = SynonymsViewModel.getRecentSearches(5);

        if (recent.length === 0) {
            recentList.innerHTML = '<span class="synonyms-recent-empty">Aucune recherche récente</span>';
            return;
        }

        recentList.innerHTML = recent.map(item => `
            <button class="synonyms-recent-item" data-word="${item.word}">${item.word}</button>
        `).join('');

        // Lier les événements
        recentList.querySelectorAll('.synonyms-recent-item').forEach(btn => {
            btn.addEventListener('click', () => {
                const input = this._modal.querySelector(`#${SynonymsConfig.ui.inputId}`);
                input.value = btn.dataset.word;
                this._performSearch(btn.dataset.word);
            });
        });
    },

    /**
     * Affiche un toast temporaire
     * @param {string} message - Message à afficher
     * [MVVM : View]
     */
    _showToast(message) {
        // Supprimer l'ancien toast s'il existe
        const existingToast = document.querySelector('.synonyms-toast');
        if (existingToast) {
            existingToast.remove();
        }

        const toast = document.createElement('div');
        toast.className = 'synonyms-toast';
        toast.textContent = message;
        document.body.appendChild(toast);

        setTimeout(() => {
            toast.classList.add('synonyms-toast-fade');
            setTimeout(() => toast.remove(), 300);
        }, 1500);
    },

    /**
     * Ouvre la modal
     * @param {string} initialWord - Mot initial (optionnel)
     * @param {Function} onInsert - Callback lors de l'insertion
     * [MVVM : View]
     */
    open(initialWord = '', onInsert = null) {
        this._onInsertCallback = onInsert;
        SynonymsViewModel.openModal(initialWord);

        this._modal.classList.add('synonyms-modal-open');
        this._updateRecentSearches();

        const input = this._modal.querySelector(`#${SynonymsConfig.ui.inputId}`);
        input.value = initialWord;

        setTimeout(() => {
            input.focus();
            if (initialWord) {
                this._performSearch(initialWord);
            }
        }, 100);
    },

    /**
     * Ferme la modal
     * [MVVM : View]
     */
    close() {
        SynonymsViewModel.closeModal();
        this._modal.classList.remove('synonyms-modal-open');
        this._onInsertCallback = null;
    },

    /**
     * Bascule l'état de la modal
     * [MVVM : View]
     */
    toggle() {
        if (this._modal.classList.contains('synonyms-modal-open')) {
            this.close();
        } else {
            this.open();
        }
    },

    /**
     * Ouvre la modal avec le texte sélectionné
     * @param {Function} onInsert - Callback lors de l'insertion
     * [MVVM : View]
     */
    openWithSelection(onInsert = null) {
        const selection = window.getSelection().toString().trim();
        this.open(selection, onInsert);
    }
};

// Auto-initialisation au chargement du DOM
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => SynonymsView.init());
} else {
    SynonymsView.init();
}

// Export pour utilisation dans d'autres modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { SynonymsView };
}

// ========== js-refactor/import-chapter/import-chapter.model.js ==========
/**
 * [MVVM : Model]
 * Import Chapter Model - Gestion du parsing et de la détection des chapitres
 * depuis différents formats : .docx, .txt, .md, .epub, .pages
 */

const ImportChapterModel = {
    /**
     * Formats supportés
     */
    supportedFormats: ['.docx', '.txt', '.md', '.epub', '.pages'],

    /**
     * Patterns de détection des chapitres (ordre de priorité)
     */
    chapterPatterns: [
        // Titres avec numéros (ajout de \b pour éviter de couper "Chapitre" en "Chap" + "i")
        /^chapitre[\s:.\-–—]*(\d+|[ivxlcdm]+)\b[\s:.\-–—]*(.*)$/i,
        /^chapter[\s:.\-–—]*(\d+|[ivxlcdm]+)\b[\s:.\-–—]*(.*)$/i,
        /^chap\.?[\s:.\-–—]*(\d+|[ivxlcdm]+)\b[\s:.\-–—]*(.*)$/i,
        // Titres avec mots (Chapitre Un, Chapitre Premier)
        /^chapitre\s+(un|deux|trois|quatre|cinq|six|sept|huit|neuf|dix|onze|douze|treize|quatorze|quinze|seize|premier|deuxième|troisième|second)\b[\s:.\-–—]*(.*)$/i,
        // Format numéroté simple
        /^(\d+)[\s:.\-–—]+(.+)$/,
        // Format avec tiret ou point
        /^(\d+)\.\s*(.+)$/,
        // Partie/Part
        /^partie[\s:.\-–—]*(\d+|[ivxlcdm]+)\b[\s:.\-–—]*(.*)$/i,
        /^part[\s:.\-–—]*(\d+|[ivxlcdm]+)\b[\s:.\-–—]*(.*)$/i
    ],

    /**
     * Patterns de détection de dates (pour exclusion)
     */
    datePatterns: [
        // JJ/MM/AAAA ou JJ-MM-AAAA ou JJ.MM.AAAA (ex: 12/05/2024)
        /^\d{1,2}[./-]\d{1,2}[./-]\d{2,4}/,
        // Dates complètes: 12 janvier 2024 ou 1er janvier
        /^\d{1,2}(er)?\s+(janvier|février|fevrier|mars|avril|mai|juin|juillet|aout|août|septembre|octobre|novembre|décembre|decembre|janv|fév|déc|oct|nov|sept)[\s\d]*$/i,
        // AAAA-MM-JJ
        /^\d{4}[./-]\d{1,2}[./-]\d{1,2}/
    ],

    /**
     * Détecte le format du fichier
     * @param {File} file
     * @returns {string} - Extension du fichier
     */
    getFileFormat(file) {
        const name = file.name.toLowerCase();
        for (const format of this.supportedFormats) {
            if (name.endsWith(format)) return format;
        }
        return null;
    },

    /**
     * Point d'entrée principal - convertit n'importe quel format supporté
     * @param {File} file
     * @returns {Promise<{html: string, messages: Array}>}
     */
    async convertToHtml(file) {
        const format = this.getFileFormat(file);

        switch (format) {
            case '.docx':
                return this.convertDocxToHtml(file);
            case '.txt':
                return this.convertTxtToHtml(file);
            case '.md':
                return this.convertMarkdownToHtml(file);
            case '.epub':
                return this.convertEpubToHtml(file);
            case '.pages':
                return this.convertPagesToHtml(file);
            default:
                throw new Error(`Format non supporté: ${file.name}`);
        }
    },

    /**
     * Convertit un fichier DOCX en HTML via Mammoth.js
     * @param {File} file - Fichier .docx
     * @returns {Promise<{html: string, messages: Array}>}
     */
    async convertDocxToHtml(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const arrayBuffer = e.target.result;
                    const result = await mammoth.convertToHtml(
                        { arrayBuffer },
                        {
                            styleMap: [
                                "p[style-name='Heading 1'] => h1:fresh",
                                "p[style-name='Heading 2'] => h2:fresh",
                                "p[style-name='Titre 1'] => h1:fresh",
                                "p[style-name='Titre 2'] => h2:fresh",
                                "p[style-name='Title'] => h1:fresh",
                                "p[style-name='Titre'] => h1:fresh"
                            ]
                        }
                    );
                    resolve({
                        html: result.value,
                        messages: result.messages
                    });
                } catch (error) {
                    reject(error);
                }
            };
            reader.onerror = () => reject(new Error('Erreur de lecture du fichier'));
            reader.readAsArrayBuffer(file);
        });
    },

    /**
     * Convertit un fichier TXT en HTML
     * @param {File} file - Fichier .txt
     * @returns {Promise<{html: string, messages: Array}>}
     */
    async convertTxtToHtml(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const text = e.target.result;
                    const html = this.textToHtml(text);
                    resolve({ html, messages: [] });
                } catch (error) {
                    reject(error);
                }
            };
            reader.onerror = () => reject(new Error('Erreur de lecture du fichier'));
            reader.readAsText(file, 'UTF-8');
        });
    },

    /**
     * Convertit du texte brut en HTML avec détection des chapitres
     * @param {string} text - Texte brut
     * @returns {string} - HTML
     */
    textToHtml(text) {
        const lines = text.split(/\r?\n/);
        let html = '';
        let inParagraph = false;
        let paragraphContent = '';

        const flushParagraph = () => {
            if (paragraphContent.trim()) {
                html += `<p>${this.escapeHtml(paragraphContent.trim())}</p>\n`;
            }
            paragraphContent = '';
            inParagraph = false;
        };

        lines.forEach(line => {
            const trimmed = line.trim();

            // Ligne vide = fin de paragraphe
            if (!trimmed) {
                flushParagraph();
                return;
            }

            // Détection de titre de chapitre
            const isChapterTitle = this.matchChapterPattern(trimmed);
            if (isChapterTitle) {
                flushParagraph();
                html += `<h1>${this.escapeHtml(trimmed)}</h1>\n`;
                return;
            }

            // Ligne de séparation (---, ***, ===)
            if (/^[-*=]{3,}$/.test(trimmed)) {
                flushParagraph();
                html += '<hr>\n';
                return;
            }

            // Ajouter au paragraphe courant
            if (paragraphContent) {
                paragraphContent += ' ' + trimmed;
            } else {
                paragraphContent = trimmed;
            }
        });

        flushParagraph();
        return html;
    },

    /**
     * Convertit un fichier Markdown en HTML
     * @param {File} file - Fichier .md
     * @returns {Promise<{html: string, messages: Array}>}
     */
    async convertMarkdownToHtml(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const markdown = e.target.result;
                    const html = this.markdownToHtml(markdown);
                    resolve({ html, messages: [] });
                } catch (error) {
                    reject(error);
                }
            };
            reader.onerror = () => reject(new Error('Erreur de lecture du fichier'));
            reader.readAsText(file, 'UTF-8');
        });
    },

    /**
     * Convertit du Markdown en HTML (parser simple)
     * @param {string} markdown - Contenu Markdown
     * @returns {string} - HTML
     */
    markdownToHtml(markdown) {
        let html = markdown;

        // Titres (# à ######)
        html = html.replace(/^######\s+(.+)$/gm, '<h6>$1</h6>');
        html = html.replace(/^#####\s+(.+)$/gm, '<h5>$1</h5>');
        html = html.replace(/^####\s+(.+)$/gm, '<h4>$1</h4>');
        html = html.replace(/^###\s+(.+)$/gm, '<h3>$1</h3>');
        html = html.replace(/^##\s+(.+)$/gm, '<h2>$1</h2>');
        html = html.replace(/^#\s+(.+)$/gm, '<h1>$1</h1>');

        // Gras et italique
        html = html.replace(/\*\*\*(.+?)\*\*\*/g, '<strong><em>$1</em></strong>');
        html = html.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
        html = html.replace(/\*(.+?)\*/g, '<em>$1</em>');
        html = html.replace(/___(.+?)___/g, '<strong><em>$1</em></strong>');
        html = html.replace(/__(.+?)__/g, '<strong>$1</strong>');
        html = html.replace(/_(.+?)_/g, '<em>$1</em>');

        // Séparateurs
        html = html.replace(/^[-*_]{3,}$/gm, '<hr>');

        // Paragraphes (lignes non vides qui ne sont pas déjà des balises)
        const lines = html.split(/\n/);
        let result = '';
        let inParagraph = false;
        let paragraphContent = '';

        const flushParagraph = () => {
            if (paragraphContent.trim()) {
                result += `<p>${paragraphContent.trim()}</p>\n`;
            }
            paragraphContent = '';
        };

        lines.forEach(line => {
            const trimmed = line.trim();

            // Ligne vide ou balise block
            if (!trimmed || /^<(h[1-6]|hr|p|div|blockquote)/.test(trimmed)) {
                flushParagraph();
                if (trimmed) result += trimmed + '\n';
                return;
            }

            // Ajouter au paragraphe
            if (paragraphContent) {
                paragraphContent += ' ' + trimmed;
            } else {
                paragraphContent = trimmed;
            }
        });

        flushParagraph();
        return result;
    },

    /**
     * Convertit un fichier EPUB en HTML
     * @param {File} file - Fichier .epub
     * @returns {Promise<{html: string, messages: Array}>}
     */
    async convertEpubToHtml(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const arrayBuffer = e.target.result;
                    const zip = await JSZip.loadAsync(arrayBuffer);

                    // Trouver et parser le fichier content.opf pour l'ordre des chapitres
                    let contentOpf = null;
                    let opfPath = '';

                    // Chercher le fichier container.xml pour trouver le chemin du OPF
                    const containerXml = await zip.file('META-INF/container.xml')?.async('string');
                    if (containerXml) {
                        const match = containerXml.match(/full-path="([^"]+\.opf)"/);
                        if (match) {
                            opfPath = match[1];
                            const opfDir = opfPath.substring(0, opfPath.lastIndexOf('/') + 1);
                            contentOpf = await zip.file(opfPath)?.async('string');
                        }
                    }

                    // Collecter tous les fichiers HTML/XHTML
                    const htmlFiles = [];
                    const promises = [];

                    zip.forEach((relativePath, zipEntry) => {
                        if (/\.(x?html?)$/i.test(relativePath) && !relativePath.includes('nav')) {
                            promises.push(
                                zipEntry.async('string').then(content => {
                                    htmlFiles.push({
                                        path: relativePath,
                                        content: content
                                    });
                                })
                            );
                        }
                    });

                    await Promise.all(promises);

                    // Trier par ordre si possible (basé sur l'OPF ou alphabétique)
                    htmlFiles.sort((a, b) => a.path.localeCompare(b.path));

                    // Extraire le contenu de chaque fichier HTML
                    let combinedHtml = '';
                    const messages = [];

                    htmlFiles.forEach(file => {
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(file.content, 'text/html');
                        const body = doc.body;

                        if (body) {
                            // Chercher un titre dans ce fichier
                            const title = doc.querySelector('h1, h2, title');
                            if (title && title.textContent.trim()) {
                                combinedHtml += `<h1>${title.textContent.trim()}</h1>\n`;
                            }

                            // Ajouter le contenu du body
                            combinedHtml += body.innerHTML + '\n';
                        }
                    });

                    if (!combinedHtml.trim()) {
                        throw new Error('Aucun contenu trouvé dans l\'EPUB');
                    }

                    resolve({ html: combinedHtml, messages });
                } catch (error) {
                    reject(new Error('Erreur lors de la lecture de l\'EPUB: ' + error.message));
                }
            };
            reader.onerror = () => reject(new Error('Erreur de lecture du fichier'));
            reader.readAsArrayBuffer(file);
        });
    },

    /**
     * Convertit un fichier Apple Pages en HTML
     * @param {File} file - Fichier .pages
     * @returns {Promise<{html: string, messages: Array}>}
     */
    async convertPagesToHtml(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const arrayBuffer = e.target.result;
                    const zip = await JSZip.loadAsync(arrayBuffer);

                    let textContent = '';
                    const messages = [{ type: 'warning', message: 'Le format .pages peut perdre une partie du formatage' }];

                    // Pages utilise un format protobuf dans index.zip ou Document.iwa
                    // On va essayer d'extraire le texte du preview ou des fichiers texte

                    // Méthode 1: Chercher preview.pdf ou QuickLook/Preview.pdf (pas de texte)
                    // Méthode 2: Chercher des fichiers texte dans le package

                    // Essayer de lire le fichier Index/Document.iwa (format binaire protobuf)
                    // C'est complexe, on va plutôt chercher des alternatives

                    // Chercher buildVersionHistory.plist pour des infos
                    const plistContent = await zip.file('buildVersionHistory.plist')?.async('string');

                    // Chercher tout fichier texte lisible
                    const textPromises = [];
                    zip.forEach((relativePath, zipEntry) => {
                        // Chercher des fichiers qui pourraient contenir du texte
                        if (/\.(txt|xml|html?)$/i.test(relativePath)) {
                            textPromises.push(
                                zipEntry.async('string').then(content => ({
                                    path: relativePath,
                                    content
                                })).catch(() => null)
                            );
                        }
                    });

                    const textFiles = (await Promise.all(textPromises)).filter(f => f);

                    // Si on trouve des fichiers XML, essayer d'en extraire du texte
                    for (const file of textFiles) {
                        if (file.content && file.content.length > 100) {
                            // Essayer d'extraire le texte des balises XML
                            const textOnly = file.content.replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ').trim();
                            if (textOnly.length > textContent.length) {
                                textContent = textOnly;
                            }
                        }
                    }

                    // Si toujours rien, chercher dans les données brutes (peu probable de fonctionner)
                    if (!textContent) {
                        // Essayer de lire le contenu comme s'il était un ancien format Pages (pre-2013)
                        const indexXml = await zip.file('index.xml')?.async('string');
                        if (indexXml) {
                            const parser = new DOMParser();
                            const doc = parser.parseFromString(indexXml, 'text/xml');
                            const textNodes = doc.evaluate('//text()', doc, null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
                            for (let i = 0; i < textNodes.snapshotLength; i++) {
                                const node = textNodes.snapshotItem(i);
                                if (node.textContent.trim()) {
                                    textContent += node.textContent + ' ';
                                }
                            }
                        }
                    }

                    if (!textContent.trim()) {
                        throw new Error('Impossible d\'extraire le texte du fichier .pages. Essayez d\'exporter en .docx depuis Pages.');
                    }

                    // Convertir le texte extrait en HTML
                    const html = this.textToHtml(textContent);
                    resolve({ html, messages });

                } catch (error) {
                    reject(new Error('Erreur lors de la lecture du fichier .pages: ' + error.message + '. Essayez d\'exporter en .docx depuis Pages.'));
                }
            };
            reader.onerror = () => reject(new Error('Erreur de lecture du fichier'));
            reader.readAsArrayBuffer(file);
        });
    },

    /**
     * Échappe les caractères HTML
     * @param {string} text
     * @returns {string}
     */
    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    },

    /**
     * Parse le HTML et détecte les chapitres automatiquement
     * @param {string} html - HTML converti depuis le fichier source
     * @returns {Array<{title: string, content: string}>}
     */
    parseChaptersFromHtml(html) {
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');
        const chapters = [];

        // Stratégie 1: Détection via les titres H1/H2
        const headings = doc.querySelectorAll('h1, h2');
        if (headings.length > 0) {
            return this.parseByHeadings(doc, headings);
        }

        // Stratégie 2: Détection via patterns textuels dans les paragraphes
        const paragraphs = doc.querySelectorAll('p');
        const patternChapters = this.parseByPatterns(paragraphs);
        if (patternChapters.length > 0) {
            return patternChapters;
        }

        // Stratégie 3: Si aucun chapitre détecté, créer un chapitre unique
        const fullContent = doc.body.innerHTML;
        if (fullContent.trim()) {
            chapters.push({
                title: 'Chapitre 1',
                content: this.cleanHtml(fullContent)
            });
        }

        return chapters;
    },

    /**
     * Parse les chapitres en utilisant les balises H1/H2
     * @param {Document} doc - Document HTML parsé
     * @param {NodeList} headings - Liste des titres H1/H2
     * @returns {Array<{title: string, content: string}>}
     */
    parseByHeadings(doc, headings) {
        const chapters = [];
        const body = doc.body;

        headings.forEach((heading, index) => {
            const title = heading.textContent.trim();
            if (!title) return;

            // Collecter tout le contenu jusqu'au prochain heading
            let content = '';
            let sibling = heading.nextElementSibling;

            while (sibling && !['H1', 'H2'].includes(sibling.tagName)) {
                content += sibling.outerHTML;
                sibling = sibling.nextElementSibling;
            }

            // Nettoyer le titre des numéros de chapitre si présent
            const cleanTitle = this.cleanChapterTitle(title);

            chapters.push({
                title: cleanTitle || `Chapitre ${index + 1}`,
                content: this.cleanHtml(content)
            });
        });

        // Si du contenu existe avant le premier heading, l'ajouter comme prologue
        const firstHeading = headings[0];
        let prologueContent = '';
        let sibling = body.firstElementChild;

        while (sibling && sibling !== firstHeading) {
            if (sibling.textContent.trim()) {
                prologueContent += sibling.outerHTML;
            }
            sibling = sibling.nextElementSibling;
        }

        if (prologueContent.trim()) {
            chapters.unshift({
                title: 'Prologue',
                content: this.cleanHtml(prologueContent)
            });
        }

        return chapters;
    },

    /**
     * Parse les chapitres via patterns textuels
     * @param {NodeList} paragraphs - Paragraphes du document
     * @returns {Array<{title: string, content: string}>}
     */
    parseByPatterns(paragraphs) {
        const chapters = [];
        let currentChapter = null;
        let prologueContent = '';

        paragraphs.forEach(p => {
            const text = p.textContent.trim();
            const matchedPattern = this.matchChapterPattern(text);

            if (matchedPattern) {
                // Sauvegarder le chapitre précédent
                if (currentChapter) {
                    chapters.push(currentChapter);
                } else if (prologueContent.trim()) {
                    // Contenu avant le premier chapitre = prologue
                    chapters.push({
                        title: 'Prologue',
                        content: this.cleanHtml(prologueContent)
                    });
                }

                // Nouveau chapitre
                currentChapter = {
                    title: matchedPattern.title,
                    content: ''
                };
            } else if (currentChapter) {
                // Ajouter au chapitre en cours
                currentChapter.content += p.outerHTML;
            } else {
                // Avant le premier chapitre
                prologueContent += p.outerHTML;
            }
        });

        // Ajouter le dernier chapitre
        if (currentChapter) {
            currentChapter.content = this.cleanHtml(currentChapter.content);
            chapters.push(currentChapter);
        }

        return chapters;
    },

    /**
     * Teste si un texte correspond à un pattern de chapitre
     * @param {string} text - Texte à tester
     * @returns {Object|null} - {title, number} ou null
     */
    matchChapterPattern(text) {
        if (!text || text.length > 100) return null; // Trop long pour être un titre

        // Vérifier si c'est une date (pour éviter les faux positifs type journal)
        const isDate = this.datePatterns.some(pattern => pattern.test(text));
        if (isDate) return null;

        for (const pattern of this.chapterPatterns) {
            const match = text.match(pattern);
            if (match) {
                // Extraire le titre propre
                const number = match[1];
                const subtitle = match[2] ? match[2].trim() : '';

                let title;
                if (subtitle) {
                    title = subtitle;
                } else if (/^\d+$/.test(number)) {
                    title = `Chapitre ${number}`;
                } else {
                    title = `Chapitre ${this.romanToArabic(number) || number}`;
                }

                return { title, number };
            }
        }

        return null;
    },

    /**
     * Nettoie un titre de chapitre
     * @param {string} title - Titre brut
     * @returns {string} - Titre nettoyé
     */
    cleanChapterTitle(title) {
        // Supprimer les préfixes "Chapitre X -" etc.
        let clean = title;

        for (const pattern of this.chapterPatterns) {
            const match = clean.match(pattern);
            if (match && match[2]) {
                return match[2].trim() || clean;
            }
        }

        return clean;
    },

    /**
     * Convertit un nombre romain en arabe
     * @param {string} roman - Nombre romain
     * @returns {number|null}
     */
    romanToArabic(roman) {
        if (!roman || typeof roman !== 'string') return null;

        const romanNumerals = {
            'i': 1, 'v': 5, 'x': 10, 'l': 50,
            'c': 100, 'd': 500, 'm': 1000
        };

        const str = roman.toLowerCase();
        let result = 0;
        let prev = 0;

        for (let i = str.length - 1; i >= 0; i--) {
            const current = romanNumerals[str[i]];
            if (!current) return null;

            if (current < prev) {
                result -= current;
            } else {
                result += current;
            }
            prev = current;
        }

        return result > 0 ? result : null;
    },

    /**
     * Nettoie le HTML pour Plume
     * @param {string} html - HTML brut
     * @returns {string} - HTML nettoyé
     */
    cleanHtml(html) {
        if (!html) return '';

        // Créer un élément temporaire pour manipuler le HTML
        const temp = document.createElement('div');
        temp.innerHTML = html;

        // Supprimer les styles inline inutiles
        const allElements = temp.querySelectorAll('*');
        allElements.forEach(el => {
            // Garder seulement certains styles (bold, italic)
            const style = el.getAttribute('style');
            if (style) {
                const keepStyles = [];
                if (style.includes('font-weight') && style.includes('bold')) {
                    keepStyles.push('font-weight: bold');
                }
                if (style.includes('font-style') && style.includes('italic')) {
                    keepStyles.push('font-style: italic');
                }
                if (keepStyles.length > 0) {
                    el.setAttribute('style', keepStyles.join('; '));
                } else {
                    el.removeAttribute('style');
                }
            }

            // Supprimer les classes inutiles
            el.removeAttribute('class');
        });

        // Convertir les <strong> et <em> pour uniformité
        return temp.innerHTML;
    },

    /**
     * Crée la structure Plume à partir des chapitres détectés
     * @param {Array} chapters - Chapitres détectés
     * @param {string} actTitle - Titre de l'acte à créer
     * @returns {Object} - Structure d'acte Plume
     */
    createPlumeStructure(chapters, actTitle = 'Import') {
        const now = new Date().toISOString();

        const act = createAct(actTitle, {
            description: `Importé le ${new Date().toLocaleDateString('fr-FR')}`
        });

        chapters.forEach((chapter, index) => {
            const plumeChapter = createChapter(chapter.title || `Chapitre ${index + 1}`);

            // Créer une scène avec le contenu du chapitre
            const scene = createScene('Contenu', {
                content: chapter.content,
                wordCount: this.countWords(chapter.content)
            });

            plumeChapter.scenes.push(scene);
            act.chapters.push(plumeChapter);
        });

        return act;
    },

    /**
     * Compte les mots dans un contenu HTML
     * @param {string} html - Contenu HTML
     * @returns {number}
     */
    countWords(html) {
        if (!html) return 0;
        const temp = document.createElement('div');
        temp.innerHTML = html;
        const text = temp.textContent || temp.innerText || '';
        const words = text.trim().match(/[\p{L}]+/gu);
        return words ? words.length : 0;
    }
};

// ========== js-refactor/import-chapter/import-chapter.viewmodel.js ==========
/**
 * [MVVM : ViewModel]
 * Import Chapter ViewModel - Coordination entre Model et View
 * Gère la logique métier de l'import de fichiers (.docx, .txt, .md, .epub, .pages)
 */

const ImportChapterViewModel = {
    /**
     * État de l'import en cours
     */
    state: {
        isProcessing: false,
        previewData: null,
        selectedFile: null,
        error: null
    },

    /**
     * Reset l'état
     */
    reset() {
        this.state = {
            isProcessing: false,
            previewData: null,
            selectedFile: null,
            error: null
        };
    },

    /**
     * Traite un fichier et génère un aperçu
     * @param {File} file - Fichier sélectionné
     * @returns {Promise<Object>} - Résultat avec aperçu des chapitres
     */
    async processFile(file) {
        this.state.isProcessing = true;
        this.state.error = null;
        this.state.selectedFile = file;

        try {
            // Validation du format
            const format = ImportChapterModel.getFileFormat(file);
            if (!format) {
                const supported = ImportChapterModel.supportedFormats.join(', ');
                throw new Error(`Format non supporté. Formats acceptés : ${supported}`);
            }

            // Validation de la taille
            if (file.size > 50 * 1024 * 1024) { // 50MB max
                throw new Error('Le fichier est trop volumineux (max 50MB)');
            }

            // Vérification des dépendances pour DOCX
            if (format === '.docx' && !this.isMammothAvailable()) {
                throw new Error('La bibliothèque de lecture DOCX n\'est pas chargée. Rafraîchissez la page.');
            }

            // Vérification des dépendances pour EPUB et PAGES
            if ((format === '.epub' || format === '.pages') && typeof JSZip === 'undefined') {
                throw new Error('La bibliothèque de lecture des archives n\'est pas chargée. Rafraîchissez la page.');
            }

            // Conversion vers HTML (méthode unifiée)
            const result = await ImportChapterModel.convertToHtml(file);

            if (!result.html || result.html.trim().length === 0) {
                throw new Error('Le document semble vide');
            }

            // Parsing des chapitres
            const chapters = ImportChapterModel.parseChaptersFromHtml(result.html);

            if (chapters.length === 0) {
                throw new Error('Aucun chapitre détecté dans le document');
            }

            // Calculer les statistiques
            const stats = this.calculateStats(chapters);

            this.state.previewData = {
                fileName: file.name,
                fileFormat: format,
                chapters: chapters,
                stats: stats,
                warnings: result.messages || []
            };

            this.state.isProcessing = false;

            return {
                success: true,
                data: this.state.previewData
            };

        } catch (error) {
            this.state.isProcessing = false;
            this.state.error = error.message;

            return {
                success: false,
                error: error.message
            };
        }
    },

    /**
     * Calcule les statistiques des chapitres détectés
     * @param {Array} chapters - Chapitres détectés
     * @returns {Object} - Statistiques
     */
    calculateStats(chapters) {
        let totalWords = 0;
        const chapterStats = chapters.map((ch, index) => {
            const wordCount = ImportChapterModel.countWords(ch.content);
            totalWords += wordCount;
            return {
                index: index + 1,
                title: ch.title,
                wordCount: wordCount
            };
        });

        return {
            totalChapters: chapters.length,
            totalWords: totalWords,
            averageWordsPerChapter: Math.round(totalWords / chapters.length),
            chapters: chapterStats
        };
    },

    /**
     * Confirme l'import et crée la structure dans Plume
     * @param {string} actTitle - Titre de l'acte (optionnel)
     * @returns {Object} - Résultat de l'import
     */
    confirmImport(actTitle = null) {
        if (!this.state.previewData) {
            return {
                success: false,
                error: 'Aucune donnée à importer'
            };
        }

        try {
            const chapters = this.state.previewData.chapters;

            // Déterminer le titre de l'acte (supprimer l'extension du fichier)
            let finalActTitle = actTitle;
            if (!finalActTitle && this.state.selectedFile) {
                finalActTitle = this.state.selectedFile.name
                    .replace(/\.(docx|txt|md|epub|pages)$/i, '')
                    .replace(/[-_]/g, ' ');
            }
            finalActTitle = finalActTitle || 'Import';

            // Créer la structure Plume
            const newAct = ImportChapterModel.createPlumeStructure(chapters, finalActTitle);

            // Ajouter à la structure du projet
            if (!project.acts) {
                project.acts = [];
            }

            project.acts.push(newAct);

            // Sauvegarder
            if (typeof saveProject === 'function') {
                saveProject();
            }

            // Rafraîchir l'UI
            if (typeof renderActsList === 'function') {
                renderActsList();
            }

            const result = {
                success: true,
                data: {
                    actId: newAct.id,
                    actTitle: newAct.title,
                    chaptersImported: chapters.length,
                    totalWords: this.state.previewData.stats.totalWords
                }
            };

            // Reset l'état
            this.reset();

            return result;

        } catch (error) {
            return {
                success: false,
                error: error.message
            };
        }
    },

    /**
     * Annule l'import en cours
     */
    cancelImport() {
        this.reset();
    },

    /**
     * Obtient l'état actuel
     * @returns {Object}
     */
    getState() {
        return { ...this.state };
    },

    /**
     * Vérifie si mammoth.js est disponible
     * @returns {boolean}
     */
    isMammothAvailable() {
        return typeof mammoth !== 'undefined' && typeof mammoth.convertToHtml === 'function';
    },

    /**
     * Retourne les formats supportés pour l'affichage
     * @returns {Array<string>}
     */
    getSupportedFormats() {
        return ImportChapterModel.supportedFormats;
    },

    /**
     * Retourne la chaîne accept pour l'input file
     * @returns {string}
     */
    getAcceptString() {
        return ImportChapterModel.supportedFormats.join(',');
    }
};

// ========== js-refactor/import-chapter/import-chapter.view.js ==========
/**
 * [MVVM : View]
 * Import Chapter View - Interface utilisateur pour l'import de fichiers
 * Supporte : .docx, .txt, .md, .epub, .pages
 */

const ImportChapterView = {
    /**
     * ID du modal
     */
    modalId: 'importChapterModal',

    /**
     * Formats supportés (hardcoded pour éviter les dépendances)
     */
    supportedFormats: ['.docx', '.txt', '.md', '.epub', '.pages'],

    /**
     * Ouvre le modal d'import
     */
    open() {
        try {
            // Reset l'état si possible
            if (typeof ImportChapterViewModel !== 'undefined') {
                ImportChapterViewModel.reset();
            }

            // Afficher le modal
            const modal = document.getElementById(this.modalId);
            if (modal) {
                modal.classList.add('active');
                this.renderInitialState();
            }
        } catch (e) {
            console.error('Erreur ouverture modal import:', e);
        }
    },

    /**
     * Ferme le modal
     */
    close() {
        const modal = document.getElementById(this.modalId);
        if (modal) {
            modal.classList.remove('active');
        }
        if (typeof ImportChapterViewModel !== 'undefined') {
            ImportChapterViewModel.cancelImport();
        }
    },

    /**
     * Affiche l'état initial (sélection de fichier)
     */
    renderInitialState() {
        const content = document.getElementById('importChapterContent');
        if (!content) {
            console.error('Element importChapterContent non trouve');
            return;
        }

        const formats = this.supportedFormats;
        const acceptString = formats.join(',');

        content.innerHTML = `
            <div class="import-chapter-upload">
                <div class="import-chapter-dropzone" id="importDropzone">
                    <i data-lucide="file-up" style="width: 48px; height: 48px; color: var(--accent-gold); margin-bottom: 1rem;"></i>
                    <p style="font-size: 1.1rem; font-weight: 600; margin-bottom: 0.5rem;">
                        Glissez votre fichier ici
                    </p>
                    <p style="color: var(--text-muted); margin-bottom: 1rem;">
                        ou cliquez pour selectionner
                    </p>
                    <div style="display: flex; flex-wrap: wrap; gap: 0.5rem; justify-content: center; margin-bottom: 1rem;">
                        ${formats.map(f => `<span style="padding: 0.25rem 0.5rem; background: var(--bg-tertiary); border-radius: 4px; font-size: 0.8rem; font-weight: 600;">${f}</span>`).join('')}
                    </div>
                    <input type="file" id="importChapterFileInput" accept="${acceptString}" style="display: none;">
                    <button class="btn btn-primary" onclick="document.getElementById('importChapterFileInput').click()">
                        <i data-lucide="folder-open" style="width: 16px; height: 16px; margin-right: 8px;"></i>
                        Parcourir
                    </button>
                </div>

                <div style="margin-top: 1.5rem; padding: 1rem; background: var(--bg-secondary); border-radius: 8px; font-size: 0.85rem;">
                    <div style="font-weight: 600; margin-bottom: 0.5rem; color: var(--accent-gold);">
                        <i data-lucide="info" style="width: 14px; height: 14px; vertical-align: middle; margin-right: 6px;"></i>
                        Formats de chapitres reconnus :
                    </div>
                    <ul style="margin: 0; padding-left: 1.5rem; color: var(--text-muted); line-height: 1.6;">
                        <li><strong>.docx / .pages</strong> : Titres avec style "Titre 1" ou "Heading 1"</li>
                        <li><strong>.md</strong> : Titres Markdown (# Titre)</li>
                        <li><strong>.txt / .epub</strong> : "Chapitre 1", "Chapter I", "Partie 1"</li>
                        <li>Formats numerotes : "1. Titre", "1 - Titre"</li>
                    </ul>
                </div>

                <div style="margin-top: 1rem; padding: 0.75rem 1rem; background: rgba(212, 175, 55, 0.1); border-radius: 8px; font-size: 0.8rem; color: var(--text-secondary);">
                    <i data-lucide="lightbulb" style="width: 14px; height: 14px; vertical-align: middle; margin-right: 6px; color: var(--accent-gold);"></i>
                    <strong>Astuce :</strong> Pour les fichiers .pages, exportez en .docx depuis Pages pour un meilleur resultat.
                </div>
            </div>
        `;

        // Initialiser les événements
        this.initDropzone();
        this.initFileInput();

        // Rafraîchir les icônes Lucide
        if (typeof lucide !== 'undefined' && lucide.createIcons) {
            lucide.createIcons();
        }
    },

    /**
     * Initialise la zone de drop
     */
    initDropzone() {
        const dropzone = document.getElementById('importDropzone');
        if (!dropzone) return;

        dropzone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropzone.classList.add('dragover');
        });

        dropzone.addEventListener('dragleave', () => {
            dropzone.classList.remove('dragover');
        });

        dropzone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropzone.classList.remove('dragover');

            const files = e.dataTransfer.files;
            if (files.length > 0) {
                this.handleFileSelect(files[0]);
            }
        });

        dropzone.addEventListener('click', (e) => {
            if (e.target.tagName !== 'BUTTON' && e.target.tagName !== 'INPUT') {
                document.getElementById('importChapterFileInput')?.click();
            }
        });
    },

    /**
     * Initialise l'input file
     */
    initFileInput() {
        const input = document.getElementById('importChapterFileInput');
        if (!input) return;

        input.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                this.handleFileSelect(e.target.files[0]);
            }
        });
    },

    /**
     * Gère la sélection d'un fichier
     * @param {File} file
     */
    async handleFileSelect(file) {
        this.renderProcessing(file.name);

        try {
            const result = await ImportChapterViewModel.processFile(file);

            if (result.success) {
                this.renderPreview(result.data);
            } else {
                this.renderError(result.error);
            }
        } catch (e) {
            console.error('Erreur traitement fichier:', e);
            this.renderError(e.message || 'Erreur lors du traitement du fichier');
        }
    },

    /**
     * Affiche l'état de traitement
     * @param {string} fileName
     */
    renderProcessing(fileName) {
        const content = document.getElementById('importChapterContent');
        if (!content) return;

        content.innerHTML = `
            <div style="text-align: center; padding: 3rem;">
                <div class="import-chapter-spinner"></div>
                <p style="margin-top: 1.5rem; font-size: 1.1rem;">
                    Analyse de <strong>${fileName}</strong>...
                </p>
                <p style="color: var(--text-muted); margin-top: 0.5rem;">
                    Detection des chapitres en cours
                </p>
            </div>
        `;
    },

    /**
     * Affiche l'aperçu des chapitres détectés
     * @param {Object} data
     */
    renderPreview(data) {
        const content = document.getElementById('importChapterContent');
        if (!content) return;

        const { fileName, fileFormat, chapters, stats, warnings } = data;

        // Générer le titre par défaut (sans extension)
        const defaultTitle = fileName.replace(/\.(docx|txt|md|epub|pages)$/i, '').replace(/[-_]/g, ' ');

        // Afficher les warnings s'il y en a
        const warningsHtml = warnings && warnings.length > 0 ? `
            <div style="background: rgba(255, 193, 7, 0.1); border: 1px solid #ffc107; padding: 0.75rem 1rem; border-radius: 8px; margin-bottom: 1rem; font-size: 0.85rem;">
                <i data-lucide="alert-triangle" style="width: 14px; height: 14px; vertical-align: middle; margin-right: 6px; color: #ffc107;"></i>
                ${warnings.map(w => w.message || w).join('<br>')}
            </div>
        ` : '';

        content.innerHTML = `
            <div class="import-chapter-preview">
                ${warningsHtml}

                <!-- En-tête avec statistiques -->
                <div style="background: var(--bg-secondary); padding: 1rem; border-radius: 8px; margin-bottom: 1.5rem;">
                    <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 1rem;">
                        <div>
                            <div style="font-weight: 600; font-size: 1rem;">
                                <i data-lucide="file-text" style="width: 16px; height: 16px; vertical-align: middle; margin-right: 6px; color: var(--accent-gold);"></i>
                                ${fileName}
                                <span style="font-size: 0.75rem; background: var(--bg-tertiary); padding: 0.15rem 0.4rem; border-radius: 3px; margin-left: 0.5rem;">${fileFormat || ''}</span>
                            </div>
                        </div>
                        <div style="display: flex; gap: 1.5rem; font-size: 0.9rem;">
                            <div>
                                <span style="color: var(--text-muted);">Chapitres :</span>
                                <strong style="color: var(--accent-gold);">${stats.totalChapters}</strong>
                            </div>
                            <div>
                                <span style="color: var(--text-muted);">Mots :</span>
                                <strong>${stats.totalWords.toLocaleString('fr-FR')}</strong>
                            </div>
                            <div>
                                <span style="color: var(--text-muted);">Moy./chap :</span>
                                <strong>${stats.averageWordsPerChapter.toLocaleString('fr-FR')}</strong>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Titre de l'acte -->
                <div style="margin-bottom: 1.5rem;">
                    <label style="display: block; font-weight: 600; margin-bottom: 0.5rem;">
                        Titre de l'acte dans Plume :
                    </label>
                    <input type="text"
                           id="importActTitle"
                           class="form-input"
                           value="${defaultTitle}"
                           placeholder="Nom de l'acte"
                           style="width: 100%;">
                </div>

                <!-- Liste des chapitres -->
                <div style="margin-bottom: 1.5rem;">
                    <div style="font-weight: 600; margin-bottom: 0.75rem;">
                        <i data-lucide="list" style="width: 14px; height: 14px; vertical-align: middle; margin-right: 6px;"></i>
                        Chapitres detectes :
                    </div>
                    <div class="import-chapter-list" style="max-height: 300px; overflow-y: auto; border: 1px solid var(--border-color); border-radius: 8px;">
                        ${chapters.map((ch, i) => `
                            <div class="import-chapter-item" style="padding: 0.75rem 1rem; border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center;">
                                <div style="display: flex; align-items: center; gap: 0.75rem;">
                                    <span style="color: var(--text-muted); font-size: 0.8rem; min-width: 24px;">${i + 1}.</span>
                                    <span style="font-weight: 500;">${ch.title}</span>
                                </div>
                                <span style="color: var(--text-muted); font-size: 0.85rem;">
                                    ${stats.chapters[i].wordCount.toLocaleString('fr-FR')} mots
                                </span>
                            </div>
                        `).join('')}
                    </div>
                </div>

                <!-- Boutons d'action -->
                <div style="display: flex; gap: 1rem; justify-content: flex-end;">
                    <button class="btn btn-secondary" onclick="ImportChapterView.renderInitialState()">
                        <i data-lucide="arrow-left" style="width: 14px; height: 14px; margin-right: 6px;"></i>
                        Choisir un autre fichier
                    </button>
                    <button class="btn btn-primary" onclick="ImportChapterView.confirmImport()">
                        <i data-lucide="check" style="width: 14px; height: 14px; margin-right: 6px;"></i>
                        Importer ${stats.totalChapters} chapitres
                    </button>
                </div>
            </div>
        `;

        // Rafraîchir les icônes
        if (typeof lucide !== 'undefined' && lucide.createIcons) {
            lucide.createIcons();
        }
    },

    /**
     * Affiche une erreur
     * @param {string} message
     */
    renderError(message) {
        const content = document.getElementById('importChapterContent');
        if (!content) return;

        content.innerHTML = `
            <div style="text-align: center; padding: 2rem;">
                <i data-lucide="alert-circle" style="width: 48px; height: 48px; color: var(--accent-red); margin-bottom: 1rem;"></i>
                <p style="font-size: 1.1rem; font-weight: 600; color: var(--accent-red); margin-bottom: 0.5rem;">
                    Erreur lors de l'import
                </p>
                <p style="color: var(--text-muted); margin-bottom: 1.5rem; max-width: 400px; margin-left: auto; margin-right: auto;">
                    ${message}
                </p>
                <button class="btn btn-primary" onclick="ImportChapterView.renderInitialState()">
                    <i data-lucide="refresh-cw" style="width: 14px; height: 14px; margin-right: 6px;"></i>
                    Reessayer
                </button>
            </div>
        `;

        // Rafraîchir les icônes
        if (typeof lucide !== 'undefined' && lucide.createIcons) {
            lucide.createIcons();
        }
    },

    /**
     * Confirme et exécute l'import
     */
    confirmImport() {
        const actTitleInput = document.getElementById('importActTitle');
        const actTitle = actTitleInput ? actTitleInput.value.trim() : null;

        try {
            const result = ImportChapterViewModel.confirmImport(actTitle);

            if (result.success) {
                this.renderSuccess(result.data);
            } else {
                this.renderError(result.error);
            }
        } catch (e) {
            console.error('Erreur confirmation import:', e);
            this.renderError(e.message || 'Erreur lors de l\'import');
        }
    },

    /**
     * Affiche le succès de l'import
     * @param {Object} data
     */
    renderSuccess(data) {
        const content = document.getElementById('importChapterContent');
        if (!content) return;

        content.innerHTML = `
            <div style="text-align: center; padding: 2rem;">
                <i data-lucide="check-circle" style="width: 64px; height: 64px; color: #4CAF50; margin-bottom: 1rem;"></i>
                <p style="font-size: 1.3rem; font-weight: 600; margin-bottom: 0.5rem;">
                    Import reussi !
                </p>
                <p style="color: var(--text-muted); margin-bottom: 1.5rem;">
                    <strong>${data.chaptersImported}</strong> chapitres importes dans l'acte "<strong>${data.actTitle}</strong>"
                    <br>
                    <span style="font-size: 0.9rem;">${data.totalWords.toLocaleString('fr-FR')} mots au total</span>
                </p>
                <button class="btn btn-primary" onclick="ImportChapterView.close()">
                    <i data-lucide="edit-3" style="width: 14px; height: 14px; margin-right: 6px;"></i>
                    Commencer a editer
                </button>
            </div>
        `;

        // Rafraîchir les icônes
        if (typeof lucide !== 'undefined' && lucide.createIcons) {
            lucide.createIcons();
        }
    }
};

/**
 * Fonction globale pour ouvrir le modal d'import
 */
function openImportChapterModal() {
    ImportChapterView.open();
}

/**
 * Fonction globale pour fermer le modal d'import
 */
function closeImportChapterModal() {
    ImportChapterView.close();
}

// ========== js-refactor/word-repetition/word-repetition.model.js ==========
// ============================================================
// word-repetition.model.js - Modèle de données pour l'analyse de répétitions
// ============================================================

/**
 * [MVVM : Model]
 * Configuration et constantes pour l'analyseur de répétitions
 */
const WordRepetitionConfig = {
    // Seuils de détection
    thresholds: {
        minWordLength: 4,           // Longueur minimale des mots analysés
        minOccurrences: 3,          // Nombre min d'occurrences pour signaler
        proximityWindow: 150,       // Fenêtre de proximité en caractères
        proximityMinOccurrences: 2, // Occurrences dans la fenêtre de proximité
        densityWarning: 0.02,       // Densité d'alerte (2%)
        densityCritical: 0.04       // Densité critique (4%)
    },

    // Catégories de sévérité
    severity: {
        LOW: 'low',
        MEDIUM: 'medium',
        HIGH: 'high',
        CRITICAL: 'critical'
    },

    // Types d'analyse
    scope: {
        PROJECT: 'project',
        ACT: 'act',
        CHAPTER: 'chapter',
        SCENE: 'scene'
    },

    // Mots à ignorer par défaut (mots-outils français)
    defaultIgnoredWords: new Set([
        // Articles
        'le', 'la', 'les', 'un', 'une', 'des', 'du', 'de', 'au', 'aux',
        // Pronoms
        'je', 'tu', 'il', 'elle', 'on', 'nous', 'vous', 'ils', 'elles',
        'me', 'te', 'se', 'lui', 'leur', 'en', 'y',
        'ce', 'cet', 'cette', 'ces', 'celui', 'celle', 'ceux', 'celles',
        'qui', 'que', 'quoi', 'dont', 'où',
        'mon', 'ton', 'son', 'ma', 'ta', 'sa', 'mes', 'tes', 'ses',
        'notre', 'votre', 'nos', 'vos', 'leur', 'leurs',
        // Prépositions
        'à', 'de', 'en', 'par', 'pour', 'sur', 'sous', 'dans', 'avec', 'sans',
        'entre', 'vers', 'chez', 'contre', 'depuis', 'pendant', 'avant', 'après',
        // Conjonctions
        'et', 'ou', 'mais', 'donc', 'or', 'ni', 'car', 'que', 'si', 'comme',
        'quand', 'lorsque', 'puisque', 'parce',
        // Adverbes courants
        'ne', 'pas', 'plus', 'moins', 'très', 'bien', 'mal', 'peu', 'trop',
        'aussi', 'encore', 'toujours', 'jamais', 'déjà', 'alors', 'ainsi',
        // Verbes auxiliaires/courants
        'être', 'avoir', 'faire', 'aller', 'pouvoir', 'vouloir', 'devoir',
        'est', 'sont', 'était', 'fut', 'sera', 'serait', 'soit',
        'a', 'ai', 'as', 'avait', 'avaient', 'ont', 'aura', 'aurait',
        'fait', 'fais', 'font', 'va', 'vont', 'peut', 'veut', 'doit',
        // Autres mots fréquents
        'tout', 'tous', 'toute', 'toutes', 'rien', 'même', 'autre', 'autres',
        'quelque', 'chaque', 'aucun', 'aucune', 'plusieurs',
        'cela', 'ça', 'là', 'ici', 'voilà', 'voici',
        // Mots courts communs
        'dit', 'dis', 'mis', 'pris', 'vu', 'su', 'pu', 'dû', 'eu', 'été'
    ])
};

/**
 * [MVVM : Model]
 * Factory pour créer un résultat d'occurrence de mot
 * @param {string} word - Le mot trouvé
 * @param {number} position - Position dans le texte
 * @param {string} context - Contexte autour du mot
 * @param {Object} location - Localisation (acte, chapitre, scène)
 * @returns {Object} Occurrence formatée
 */
function createWordOccurrence(word, position, context, location) {
    return {
        word: word,
        position: position,
        context: context,
        location: {
            actId: location.actId || null,
            actTitle: location.actTitle || '',
            chapterId: location.chapterId || null,
            chapterTitle: location.chapterTitle || '',
            sceneId: location.sceneId || null,
            sceneTitle: location.sceneTitle || ''
        }
    };
}

/**
 * [MVVM : Model]
 * Factory pour créer un résultat d'analyse de répétition
 * @param {string} word - Le mot répété
 * @param {number} count - Nombre total d'occurrences
 * @param {Array} occurrences - Liste des occurrences
 * @param {Object} stats - Statistiques additionnelles
 * @returns {Object} Résultat de répétition
 */
function createRepetitionResult(word, count, occurrences, stats = {}) {
    const density = stats.totalWords ? (count / stats.totalWords) : 0;

    // Calculer la sévérité
    let severity = WordRepetitionConfig.severity.LOW;
    if (density >= WordRepetitionConfig.thresholds.densityCritical) {
        severity = WordRepetitionConfig.severity.CRITICAL;
    } else if (density >= WordRepetitionConfig.thresholds.densityWarning) {
        severity = WordRepetitionConfig.severity.HIGH;
    } else if (count >= 10 || stats.proximityCount >= 3) {
        severity = WordRepetitionConfig.severity.MEDIUM;
    }

    return {
        id: `rep_${word}_${Date.now()}`,
        word: word,
        count: count,
        density: density,
        densityPercent: (density * 100).toFixed(2),
        severity: severity,
        occurrences: occurrences,
        proximityCount: stats.proximityCount || 0,
        suggestions: [],
        isIgnored: false
    };
}

/**
 * [MVVM : Model]
 * Factory pour créer un contexte d'analyse
 * @param {string} scope - Portée de l'analyse
 * @param {Object} target - Cible (projet, acte, chapitre, scène)
 * @returns {Object} Contexte d'analyse
 */
function createAnalysisContext(scope, target = {}) {
    return {
        scope: scope,
        actId: target.actId || null,
        chapterId: target.chapterId || null,
        sceneId: target.sceneId || null,
        timestamp: Date.now()
    };
}

/**
 * [MVVM : Model]
 * Factory pour créer un rapport d'analyse complet
 * @param {Object} context - Contexte d'analyse
 * @param {Array} repetitions - Liste des répétitions détectées
 * @param {Object} stats - Statistiques globales
 * @returns {Object} Rapport complet
 */
function createAnalysisReport(context, repetitions, stats) {
    return {
        id: `report_${Date.now()}`,
        context: context,
        repetitions: repetitions,
        stats: {
            totalWords: stats.totalWords || 0,
            uniqueWords: stats.uniqueWords || 0,
            repetitionsCount: repetitions.length,
            criticalCount: repetitions.filter(r => r.severity === WordRepetitionConfig.severity.CRITICAL).length,
            highCount: repetitions.filter(r => r.severity === WordRepetitionConfig.severity.HIGH).length,
            mediumCount: repetitions.filter(r => r.severity === WordRepetitionConfig.severity.MEDIUM).length,
            lowCount: repetitions.filter(r => r.severity === WordRepetitionConfig.severity.LOW).length,
            analyzedAt: new Date().toISOString()
        },
        suggestions: []
    };
}

/**
 * [MVVM : Model]
 * Factory pour créer une suggestion de remplacement
 * @param {string} originalWord - Mot original
 * @param {string} suggestion - Mot suggéré
 * @param {Object} metadata - Métadonnées (source, score, etc.)
 * @returns {Object} Suggestion formatée
 */
function createReplacementSuggestion(originalWord, suggestion, metadata = {}) {
    return {
        original: originalWord,
        suggestion: suggestion,
        score: metadata.score || 0,
        source: metadata.source || 'dictionary',
        category: metadata.category || '',
        applied: false
    };
}

/**
 * [MVVM : Model]
 * Valide les préférences utilisateur
 * @param {Object} prefs - Préférences à valider
 * @returns {Object} Résultat de validation
 */
function validateRepetitionPreferences(prefs) {
    const errors = [];

    if (prefs.minWordLength !== undefined) {
        if (typeof prefs.minWordLength !== 'number' || prefs.minWordLength < 2 || prefs.minWordLength > 10) {
            errors.push('minWordLength doit être entre 2 et 10');
        }
    }

    if (prefs.minOccurrences !== undefined) {
        if (typeof prefs.minOccurrences !== 'number' || prefs.minOccurrences < 2 || prefs.minOccurrences > 20) {
            errors.push('minOccurrences doit être entre 2 et 20');
        }
    }

    if (prefs.customIgnoredWords !== undefined) {
        if (!Array.isArray(prefs.customIgnoredWords)) {
            errors.push('customIgnoredWords doit être un tableau');
        }
    }

    return {
        isValid: errors.length === 0,
        errors: errors
    };
}

// Export pour utilisation dans d'autres modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        WordRepetitionConfig,
        createWordOccurrence,
        createRepetitionResult,
        createAnalysisContext,
        createAnalysisReport,
        createReplacementSuggestion,
        validateRepetitionPreferences
    };
}

// ========== js-refactor/word-repetition/word-repetition.repository.js ==========
// ============================================================
// word-repetition.repository.js - Repository pour les préférences de répétitions
// ============================================================

/**
 * [MVVM : Repository]
 * Gestion CRUD des préférences utilisateur pour l'analyse de répétitions
 */
const WordRepetitionRepository = {
    // Clé de stockage
    STORAGE_KEY: 'plume_word_repetition_prefs',

    /**
     * [MVVM : Repository]
     * Récupère les préférences utilisateur
     * @returns {Object} Préférences
     */
    getPreferences() {
        try {
            const stored = localStorage.getItem(this.STORAGE_KEY);
            if (stored) {
                const prefs = JSON.parse(stored);
                return this._mergeWithDefaults(prefs);
            }
        } catch (e) {
            console.warn('[WordRepetitionRepository] Erreur lecture préférences:', e);
        }
        return this._getDefaults();
    },

    /**
     * [MVVM : Repository]
     * Sauvegarde les préférences utilisateur
     * @param {Object} prefs - Préférences à sauvegarder
     * @returns {boolean} Succès
     */
    savePreferences(prefs) {
        try {
            const validation = validateRepetitionPreferences(prefs);
            if (!validation.isValid) {
                console.warn('[WordRepetitionRepository] Préférences invalides:', validation.errors);
                return false;
            }
            localStorage.setItem(this.STORAGE_KEY, JSON.stringify(prefs));
            return true;
        } catch (e) {
            console.error('[WordRepetitionRepository] Erreur sauvegarde préférences:', e);
            return false;
        }
    },

    /**
     * [MVVM : Repository]
     * Met à jour une préférence spécifique
     * @param {string} key - Clé de la préférence
     * @param {*} value - Nouvelle valeur
     * @returns {boolean} Succès
     */
    updatePreference(key, value) {
        const prefs = this.getPreferences();
        prefs[key] = value;
        prefs.updatedAt = new Date().toISOString();
        return this.savePreferences(prefs);
    },

    /**
     * [MVVM : Repository]
     * Récupère la liste des mots ignorés personnalisés
     * @returns {Array} Liste des mots ignorés
     */
    getCustomIgnoredWords() {
        const prefs = this.getPreferences();
        return prefs.customIgnoredWords || [];
    },

    /**
     * [MVVM : Repository]
     * Ajoute un mot à la liste des ignorés
     * @param {string} word - Mot à ignorer
     * @returns {boolean} Succès
     */
    addIgnoredWord(word) {
        const prefs = this.getPreferences();
        const normalizedWord = word.toLowerCase().trim();

        if (!normalizedWord || prefs.customIgnoredWords.includes(normalizedWord)) {
            return false;
        }

        prefs.customIgnoredWords.push(normalizedWord);
        prefs.updatedAt = new Date().toISOString();
        return this.savePreferences(prefs);
    },

    /**
     * [MVVM : Repository]
     * Retire un mot de la liste des ignorés
     * @param {string} word - Mot à retirer
     * @returns {boolean} Succès
     */
    removeIgnoredWord(word) {
        const prefs = this.getPreferences();
        const normalizedWord = word.toLowerCase().trim();
        const index = prefs.customIgnoredWords.indexOf(normalizedWord);

        if (index === -1) {
            return false;
        }

        prefs.customIgnoredWords.splice(index, 1);
        prefs.updatedAt = new Date().toISOString();
        return this.savePreferences(prefs);
    },

    /**
     * [MVVM : Repository]
     * Récupère l'ensemble complet des mots à ignorer (défaut + personnalisés)
     * @returns {Set} Ensemble des mots ignorés
     */
    getAllIgnoredWords() {
        const prefs = this.getPreferences();
        const combined = new Set(WordRepetitionConfig.defaultIgnoredWords);

        prefs.customIgnoredWords.forEach(word => combined.add(word));

        // Ajouter les noms de personnages du projet si disponibles
        if (typeof project !== 'undefined' && project.characters) {
            project.characters.forEach(char => {
                if (char.firstName) combined.add(char.firstName.toLowerCase());
                if (char.lastName) combined.add(char.lastName.toLowerCase());
                if (char.nickname) combined.add(char.nickname.toLowerCase());
            });
        }

        return combined;
    },

    /**
     * [MVVM : Repository]
     * Récupère le dernier rapport d'analyse
     * @returns {Object|null} Dernier rapport
     */
    getLastReport() {
        try {
            const stored = localStorage.getItem(this.STORAGE_KEY + '_last_report');
            return stored ? JSON.parse(stored) : null;
        } catch (e) {
            return null;
        }
    },

    /**
     * [MVVM : Repository]
     * Sauvegarde le dernier rapport d'analyse
     * @param {Object} report - Rapport à sauvegarder
     * @returns {boolean} Succès
     */
    saveLastReport(report) {
        try {
            localStorage.setItem(this.STORAGE_KEY + '_last_report', JSON.stringify(report));
            return true;
        } catch (e) {
            console.error('[WordRepetitionRepository] Erreur sauvegarde rapport:', e);
            return false;
        }
    },

    /**
     * [MVVM : Repository]
     * Réinitialise les préférences par défaut
     * @returns {boolean} Succès
     */
    resetToDefaults() {
        return this.savePreferences(this._getDefaults());
    },

    /**
     * [MVVM : Repository]
     * Retourne les préférences par défaut
     * @returns {Object} Préférences par défaut
     * @private
     */
    _getDefaults() {
        return {
            minWordLength: WordRepetitionConfig.thresholds.minWordLength,
            minOccurrences: WordRepetitionConfig.thresholds.minOccurrences,
            proximityWindow: WordRepetitionConfig.thresholds.proximityWindow,
            customIgnoredWords: [],
            ignoreCharacterNames: true,
            showLowSeverity: false,
            autoAnalyze: false,
            highlightInEditor: true,
            panelCollapsed: false,
            lastScope: WordRepetitionConfig.scope.SCENE,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString()
        };
    },

    /**
     * [MVVM : Repository]
     * Fusionne les préférences stockées avec les défauts
     * @param {Object} stored - Préférences stockées
     * @returns {Object} Préférences fusionnées
     * @private
     */
    _mergeWithDefaults(stored) {
        const defaults = this._getDefaults();
        return { ...defaults, ...stored };
    }
};

// Export pour utilisation dans d'autres modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { WordRepetitionRepository };
}

// ========== js-refactor/word-repetition/word-repetition.viewmodel.js ==========
// ============================================================
// word-repetition.viewmodel.js - Logique métier de l'analyse de répétitions
// ============================================================

/**
 * [MVVM : ViewModel]
 * État de l'analyseur de répétitions
 */
const WordRepetitionState = {
    currentReport: null,
    isAnalyzing: false,
    selectedRepetition: null,
    currentScope: WordRepetitionConfig.scope.SCENE,
    panelVisible: false
};

/**
 * [MVVM : ViewModel]
 * ViewModel principal pour l'analyse de répétitions
 */
const WordRepetitionViewModel = {
    /**
     * [MVVM : ViewModel]
     * Analyse les répétitions selon le scope défini
     * @param {string} scope - Portée de l'analyse (project, act, chapter, scene)
     * @param {Object} target - Cible optionnelle (actId, chapterId, sceneId)
     * @returns {Object} Rapport d'analyse
     */
    analyze(scope = WordRepetitionConfig.scope.SCENE, target = {}) {
        WordRepetitionState.isAnalyzing = true;
        WordRepetitionState.currentScope = scope;

        try {
            // Récupérer le texte selon le scope
            const textData = this._getTextForScope(scope, target);
            if (!textData || !textData.text) {
                WordRepetitionState.isAnalyzing = false;
                return {
                    success: false,
                    message: 'Aucun texte à analyser'
                };
            }

            // Analyser le texte
            const analysisResult = this._analyzeText(textData.text, textData.locations);

            // Créer le rapport
            const context = createAnalysisContext(scope, target);
            const report = createAnalysisReport(context, analysisResult.repetitions, {
                totalWords: analysisResult.totalWords,
                uniqueWords: analysisResult.uniqueWords
            });

            // Enrichir avec les suggestions de synonymes
            this._enrichWithSuggestions(report);

            // Sauvegarder le rapport
            WordRepetitionState.currentReport = report;
            WordRepetitionRepository.saveLastReport(report);
            WordRepetitionRepository.updatePreference('lastScope', scope);

            WordRepetitionState.isAnalyzing = false;

            return {
                success: true,
                report: report,
                message: `${report.stats.repetitionsCount} répétition(s) détectée(s)`
            };
        } catch (error) {
            console.error('[WordRepetitionViewModel] Erreur analyse:', error);
            WordRepetitionState.isAnalyzing = false;
            return {
                success: false,
                message: 'Erreur lors de l\'analyse'
            };
        }
    },

    /**
     * [MVVM : ViewModel]
     * Récupère le texte selon le scope
     * @param {string} scope - Portée
     * @param {Object} target - Cible
     * @returns {Object} Texte et localisations
     * @private
     */
    _getTextForScope(scope, target) {
        if (typeof project === 'undefined' || !project.acts) {
            return null;
        }

        let text = '';
        const locations = [];

        const extractSceneText = (scene, actId, actTitle, chapterId, chapterTitle) => {
            if (scene.content) {
                // Extraire le texte brut du HTML
                const temp = document.createElement('div');
                temp.innerHTML = scene.content;
                const sceneText = temp.textContent || temp.innerText || '';

                if (sceneText.trim()) {
                    locations.push({
                        startIndex: text.length,
                        endIndex: text.length + sceneText.length,
                        actId: actId,
                        actTitle: actTitle,
                        chapterId: chapterId,
                        chapterTitle: chapterTitle,
                        sceneId: scene.id,
                        sceneTitle: scene.title
                    });
                    text += sceneText + ' ';
                }
            }
        };

        switch (scope) {
            case WordRepetitionConfig.scope.PROJECT:
                project.acts.forEach(act => {
                    act.chapters.forEach(chapter => {
                        chapter.scenes.forEach(scene => {
                            extractSceneText(scene, act.id, act.title, chapter.id, chapter.title);
                        });
                    });
                });
                break;

            case WordRepetitionConfig.scope.ACT:
                const act = project.acts.find(a => a.id === (target.actId || currentActId));
                if (act) {
                    act.chapters.forEach(chapter => {
                        chapter.scenes.forEach(scene => {
                            extractSceneText(scene, act.id, act.title, chapter.id, chapter.title);
                        });
                    });
                }
                break;

            case WordRepetitionConfig.scope.CHAPTER:
                const actForChapter = project.acts.find(a => a.id === (target.actId || currentActId));
                if (actForChapter) {
                    const chapter = actForChapter.chapters.find(c => c.id === (target.chapterId || currentChapterId));
                    if (chapter) {
                        chapter.scenes.forEach(scene => {
                            extractSceneText(scene, actForChapter.id, actForChapter.title, chapter.id, chapter.title);
                        });
                    }
                }
                break;

            case WordRepetitionConfig.scope.SCENE:
            default:
                const actForScene = project.acts.find(a => a.id === (target.actId || currentActId));
                if (actForScene) {
                    const chapterForScene = actForScene.chapters.find(c => c.id === (target.chapterId || currentChapterId));
                    if (chapterForScene) {
                        const scene = chapterForScene.scenes.find(s => s.id === (target.sceneId || currentSceneId));
                        if (scene) {
                            extractSceneText(scene, actForScene.id, actForScene.title,
                                           chapterForScene.id, chapterForScene.title);
                        }
                    }
                }
                break;
        }

        return { text: text.trim(), locations };
    },

    /**
     * [MVVM : ViewModel]
     * Analyse le texte pour trouver les répétitions
     * @param {string} text - Texte à analyser
     * @param {Array} locations - Localisations des scènes
     * @returns {Object} Résultat d'analyse
     * @private
     */
    _analyzeText(text, locations) {
        const prefs = WordRepetitionRepository.getPreferences();
        const ignoredWords = WordRepetitionRepository.getAllIgnoredWords();

        // Normaliser le texte
        const normalizedText = text.toLowerCase();

        // Extraire les mots
        const wordRegex = /[a-zàâäéèêëïîôùûüÿœæç]+/gi;
        const words = normalizedText.match(wordRegex) || [];

        // Compter les occurrences
        const wordCounts = new Map();
        const wordPositions = new Map();

        let match;
        const regex = new RegExp(wordRegex.source, 'gi');
        while ((match = regex.exec(normalizedText)) !== null) {
            const word = match[0].toLowerCase();

            // Filtrer les mots courts et ignorés
            if (word.length < prefs.minWordLength || ignoredWords.has(word)) {
                continue;
            }

            wordCounts.set(word, (wordCounts.get(word) || 0) + 1);

            if (!wordPositions.has(word)) {
                wordPositions.set(word, []);
            }
            wordPositions.get(word).push({
                position: match.index,
                context: this._extractContext(text, match.index, word.length)
            });
        }

        // Créer les résultats de répétition
        const repetitions = [];
        const totalWords = words.filter(w => w.length >= prefs.minWordLength && !ignoredWords.has(w.toLowerCase())).length;

        for (const [word, count] of wordCounts) {
            if (count >= prefs.minOccurrences) {
                const positions = wordPositions.get(word);

                // Calculer les répétitions de proximité
                const proximityCount = this._countProximityRepetitions(positions, prefs.proximityWindow);

                // Créer les occurrences avec localisation
                const occurrences = positions.map(pos => {
                    const location = this._findLocation(pos.position, locations);
                    return createWordOccurrence(word, pos.position, pos.context, location);
                });

                const result = createRepetitionResult(word, count, occurrences, {
                    totalWords,
                    proximityCount
                });

                repetitions.push(result);
            }
        }

        // Trier par sévérité puis par nombre d'occurrences
        repetitions.sort((a, b) => {
            const severityOrder = { critical: 0, high: 1, medium: 2, low: 3 };
            const sevDiff = severityOrder[a.severity] - severityOrder[b.severity];
            if (sevDiff !== 0) return sevDiff;
            return b.count - a.count;
        });

        // Filtrer les low severity si préférence
        const filteredRepetitions = prefs.showLowSeverity
            ? repetitions
            : repetitions.filter(r => r.severity !== WordRepetitionConfig.severity.LOW);

        return {
            repetitions: filteredRepetitions,
            totalWords: totalWords,
            uniqueWords: wordCounts.size
        };
    },

    /**
     * [MVVM : ViewModel]
     * Extrait le contexte autour d'un mot
     * @param {string} text - Texte complet
     * @param {number} position - Position du mot
     * @param {number} wordLength - Longueur du mot
     * @returns {string} Contexte
     * @private
     */
    _extractContext(text, position, wordLength) {
        const contextRadius = 40;
        const start = Math.max(0, position - contextRadius);
        const end = Math.min(text.length, position + wordLength + contextRadius);

        let context = text.substring(start, end);
        if (start > 0) context = '...' + context;
        if (end < text.length) context = context + '...';

        return context;
    },

    /**
     * [MVVM : ViewModel]
     * Compte les répétitions dans une fenêtre de proximité
     * @param {Array} positions - Positions du mot
     * @param {number} window - Taille de la fenêtre
     * @returns {number} Nombre de répétitions proches
     * @private
     */
    _countProximityRepetitions(positions, window) {
        let count = 0;
        for (let i = 0; i < positions.length - 1; i++) {
            if (positions[i + 1].position - positions[i].position < window) {
                count++;
            }
        }
        return count;
    },

    /**
     * [MVVM : ViewModel]
     * Trouve la localisation d'une position dans le texte
     * @param {number} position - Position dans le texte
     * @param {Array} locations - Localisations des scènes
     * @returns {Object} Localisation
     * @private
     */
    _findLocation(position, locations) {
        for (const loc of locations) {
            if (position >= loc.startIndex && position < loc.endIndex) {
                return {
                    actId: loc.actId,
                    actTitle: loc.actTitle,
                    chapterId: loc.chapterId,
                    chapterTitle: loc.chapterTitle,
                    sceneId: loc.sceneId,
                    sceneTitle: loc.sceneTitle
                };
            }
        }
        return {};
    },

    /**
     * [MVVM : ViewModel]
     * Enrichit le rapport avec des suggestions de synonymes
     * @param {Object} report - Rapport à enrichir
     * @private
     */
    async _enrichWithSuggestions(report) {
        if (typeof SynonymsService === 'undefined') {
            return;
        }

        // Limiter à 10 mots les plus répétés pour éviter trop de requêtes
        const topRepetitions = report.repetitions.slice(0, 10);

        for (const rep of topRepetitions) {
            try {
                const synonyms = await SynonymsService.fetchSynonyms(rep.word);
                rep.suggestions = synonyms.slice(0, 5).map(syn =>
                    createReplacementSuggestion(rep.word, syn.word, {
                        score: syn.score,
                        source: 'synonyms',
                        category: syn.category
                    })
                );
            } catch (e) {
                // Ignorer les erreurs silencieusement
            }
        }
    },

    /**
     * [MVVM : ViewModel]
     * Sélectionne une répétition pour affichage détaillé
     * @param {string} repetitionId - ID de la répétition
     * @returns {Object} Répétition sélectionnée
     */
    selectRepetition(repetitionId) {
        if (!WordRepetitionState.currentReport) {
            return null;
        }

        const rep = WordRepetitionState.currentReport.repetitions.find(r => r.id === repetitionId);
        WordRepetitionState.selectedRepetition = rep;
        return rep;
    },

    /**
     * [MVVM : ViewModel]
     * Ignore un mot (l'ajoute à la liste des ignorés)
     * @param {string} word - Mot à ignorer
     * @returns {Object} Résultat
     */
    ignoreWord(word) {
        const success = WordRepetitionRepository.addIgnoredWord(word);

        if (success && WordRepetitionState.currentReport) {
            // Marquer comme ignoré dans le rapport actuel
            const rep = WordRepetitionState.currentReport.repetitions.find(r => r.word === word);
            if (rep) {
                rep.isIgnored = true;
            }
        }

        return {
            success,
            message: success ? `"${word}" sera ignoré dans les prochaines analyses` : 'Erreur'
        };
    },

    /**
     * [MVVM : ViewModel]
     * Retire un mot de la liste des ignorés
     * @param {string} word - Mot à retirer
     * @returns {Object} Résultat
     */
    unignoreWord(word) {
        const success = WordRepetitionRepository.removeIgnoredWord(word);
        return {
            success,
            message: success ? `"${word}" sera analysé à nouveau` : 'Erreur'
        };
    },

    /**
     * [MVVM : ViewModel]
     * Récupère les suggestions de synonymes pour un mot
     * @param {string} word - Mot à rechercher
     * @returns {Promise<Array>} Suggestions
     */
    async getSuggestions(word) {
        if (typeof SynonymsService === 'undefined') {
            return [];
        }

        try {
            const synonyms = await SynonymsService.fetchSynonyms(word);
            return synonyms.map(syn => createReplacementSuggestion(word, syn.word, {
                score: syn.score,
                source: 'synonyms',
                category: syn.category
            }));
        } catch (e) {
            return [];
        }
    },

    /**
     * [MVVM : ViewModel]
     * Navigue vers une occurrence spécifique
     * @param {Object} occurrence - Occurrence à afficher
     * @returns {Object} Instructions de navigation
     */
    navigateToOccurrence(occurrence) {
        if (!occurrence || !occurrence.location) {
            return { success: false };
        }

        const loc = occurrence.location;

        return {
            success: true,
            action: 'openScene',
            params: {
                actId: loc.actId,
                chapterId: loc.chapterId,
                sceneId: loc.sceneId,
                highlightWord: occurrence.word,
                highlightPosition: occurrence.position
            }
        };
    },

    /**
     * [MVVM : ViewModel]
     * Récupère l'état actuel
     * @returns {Object} État
     */
    getState() {
        return { ...WordRepetitionState };
    },

    /**
     * [MVVM : ViewModel]
     * Récupère le rapport actuel
     * @returns {Object|null} Rapport
     */
    getCurrentReport() {
        return WordRepetitionState.currentReport;
    },

    /**
     * [MVVM : ViewModel]
     * Toggle la visibilité du panneau
     * @returns {boolean} Nouvelle visibilité
     */
    togglePanel() {
        WordRepetitionState.panelVisible = !WordRepetitionState.panelVisible;
        WordRepetitionRepository.updatePreference('panelCollapsed', !WordRepetitionState.panelVisible);
        return WordRepetitionState.panelVisible;
    },

    /**
     * [MVVM : ViewModel]
     * Efface le rapport actuel
     */
    clearReport() {
        WordRepetitionState.currentReport = null;
        WordRepetitionState.selectedRepetition = null;
    }
};

// Export pour utilisation dans d'autres modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { WordRepetitionViewModel, WordRepetitionState };
}

// ========== js-refactor/word-repetition/word-repetition.view.js ==========
// ============================================================
// word-repetition.view.js - Vue de l'analyseur de répétitions
// ============================================================

/**
 * [MVVM : View]
 * Gestion de l'affichage de l'analyseur de répétitions
 */
const WordRepetitionView = {
    /**
     * [MVVM : View]
     * Rend le panneau complet de l'analyseur
     * @param {HTMLElement} container - Conteneur cible
     */
    renderPanel(container) {
        if (!container) return;

        const report = WordRepetitionViewModel.getCurrentReport();
        const prefs = WordRepetitionRepository.getPreferences();
        const state = WordRepetitionViewModel.getState();

        let html = `
            <div class="word-repetition-panel" id="wordRepetitionPanel">
                ${this._renderScopeSelector(state.currentScope)}
                ${this._renderSettingsPanel(prefs)}
                ${state.isAnalyzing ? this._renderLoading() : ''}
                ${report ? this._renderReport(report) : this._renderEmptyState()}
            </div>
        `;

        container.innerHTML = html;

        // Initialiser les icônes Lucide
        if (typeof lucide !== 'undefined') {
            setTimeout(() => lucide.createIcons(), 10);
        }
    },

    /**
     * [MVVM : View]
     * Rend le sélecteur de scope
     * @param {string} currentScope - Scope actuel
     * @returns {string} HTML
     * @private
     */
    _renderScopeSelector(currentScope) {
        const scopes = [
            { value: 'scene', label: 'Scène', icon: 'file-text' },
            { value: 'chapter', label: 'Chapitre', icon: 'book-open' },
            { value: 'act', label: 'Acte', icon: 'layers' },
            { value: 'project', label: 'Projet', icon: 'folder' }
        ];

        return `
            <div class="word-rep-scope-selector">
                ${scopes.map(scope => `
                    <button class="scope-btn ${currentScope === scope.value ? 'active' : ''}"
                            onclick="WordRepetitionHandlers.onScopeChange('${scope.value}')"
                            title="Analyser ${scope.label.toLowerCase()}">
                        <i data-lucide="${scope.icon}" style="width: 12px; height: 12px;"></i>
                        <span>${scope.label}</span>
                    </button>
                `).join('')}
            </div>
        `;
    },

    /**
     * [MVVM : View]
     * Rend le panneau de paramètres
     * @param {Object} prefs - Préférences
     * @returns {string} HTML
     * @private
     */
    _renderSettingsPanel(prefs) {
        return `
            <div class="word-rep-settings" id="wordRepSettings" style="display: none;">
                <div class="settings-row">
                    <label>Longueur min. des mots</label>
                    <input type="number" id="prefMinWordLength" value="${prefs.minWordLength}" min="2" max="10"
                           onchange="WordRepetitionHandlers.onPrefChange('minWordLength', parseInt(this.value))">
                </div>
                <div class="settings-row">
                    <label>Occurrences min.</label>
                    <input type="number" id="prefMinOccurrences" value="${prefs.minOccurrences}" min="2" max="20"
                           onchange="WordRepetitionHandlers.onPrefChange('minOccurrences', parseInt(this.value))">
                </div>
                <div class="settings-row">
                    <label>
                        <input type="checkbox" id="prefShowLow" ${prefs.showLowSeverity ? 'checked' : ''}
                               onchange="WordRepetitionHandlers.onPrefChange('showLowSeverity', this.checked)">
                        Afficher faible sévérité
                    </label>
                </div>
                <div class="settings-row">
                    <label>
                        <input type="checkbox" id="prefIgnoreNames" ${prefs.ignoreCharacterNames ? 'checked' : ''}
                               onchange="WordRepetitionHandlers.onPrefChange('ignoreCharacterNames', this.checked)">
                        Ignorer noms de personnages
                    </label>
                </div>
                ${this._renderIgnoredWordsList(prefs.customIgnoredWords)}
            </div>
        `;
    },

    /**
     * [MVVM : View]
     * Rend la liste des mots ignorés personnalisés
     * @param {Array} words - Mots ignorés
     * @returns {string} HTML
     * @private
     */
    _renderIgnoredWordsList(words) {
        return `
            <div class="ignored-words-section">
                <div class="ignored-words-header">
                    <span>Mots ignorés (${words.length})</span>
                    <button class="btn btn-icon btn-small" onclick="WordRepetitionHandlers.onAddIgnoredWord()" title="Ajouter">
                        <i data-lucide="plus" style="width: 12px; height: 12px;"></i>
                    </button>
                </div>
                <div class="ignored-words-list">
                    ${words.length > 0 ? words.map(word => `
                        <span class="ignored-word-tag">
                            ${word}
                            <i data-lucide="x" style="width: 10px; height: 10px; cursor: pointer;"
                               onclick="WordRepetitionHandlers.onRemoveIgnoredWord('${word}')"></i>
                        </span>
                    `).join('') : '<span class="text-muted" style="font-size: 0.75rem;">Aucun mot personnalisé</span>'}
                </div>
            </div>
        `;
    },

    /**
     * [MVVM : View]
     * Rend l'indicateur de chargement
     * @returns {string} HTML
     * @private
     */
    _renderLoading() {
        return `
            <div class="word-rep-loading">
                <div class="loading-spinner"></div>
                <span>Analyse en cours...</span>
            </div>
        `;
    },

    /**
     * [MVVM : View]
     * Rend l'état vide
     * @returns {string} HTML
     * @private
     */
    _renderEmptyState() {
        return `
            <div class="word-rep-empty">
                <i data-lucide="search" style="width: 32px; height: 32px; opacity: 0.3;"></i>
                <p>Cliquez sur <i data-lucide="refresh-cw" style="width: 12px; height: 12px; vertical-align: middle;"></i> pour analyser les répétitions</p>
            </div>
        `;
    },

    /**
     * [MVVM : View]
     * Rend le rapport d'analyse
     * @param {Object} report - Rapport d'analyse
     * @returns {string} HTML
     * @private
     */
    _renderReport(report) {
        return `
            <div class="word-rep-report">
                ${this._renderStats(report.stats)}
                ${this._renderRepetitionsList(report.repetitions)}
            </div>
        `;
    },

    /**
     * [MVVM : View]
     * Rend les statistiques
     * @param {Object} stats - Statistiques
     * @returns {string} HTML
     * @private
     */
    _renderStats(stats) {
        return `
            <div class="word-rep-stats">
                <div class="stat-item">
                    <span class="stat-value">${stats.totalWords.toLocaleString()}</span>
                    <span class="stat-label">mots</span>
                </div>
                <div class="stat-item">
                    <span class="stat-value">${stats.repetitionsCount}</span>
                    <span class="stat-label">répétitions</span>
                </div>
                <div class="stat-badges">
                    ${stats.criticalCount > 0 ? `<span class="severity-badge critical">${stats.criticalCount}</span>` : ''}
                    ${stats.highCount > 0 ? `<span class="severity-badge high">${stats.highCount}</span>` : ''}
                    ${stats.mediumCount > 0 ? `<span class="severity-badge medium">${stats.mediumCount}</span>` : ''}
                </div>
            </div>
        `;
    },

    /**
     * [MVVM : View]
     * Rend la liste des répétitions
     * @param {Array} repetitions - Liste des répétitions
     * @returns {string} HTML
     * @private
     */
    _renderRepetitionsList(repetitions) {
        if (repetitions.length === 0) {
            return `
                <div class="word-rep-success">
                    <i data-lucide="check-circle" style="width: 24px; height: 24px; color: var(--accent-green);"></i>
                    <p>Aucune répétition excessive détectée !</p>
                </div>
            `;
        }

        return `
            <div class="word-rep-list">
                ${repetitions.filter(r => !r.isIgnored).map(rep => this._renderRepetitionItem(rep)).join('')}
            </div>
        `;
    },

    /**
     * [MVVM : View]
     * Rend un élément de répétition
     * @param {Object} rep - Répétition
     * @returns {string} HTML
     * @private
     */
    _renderRepetitionItem(rep) {
        const severityColors = {
            critical: 'var(--accent-red)',
            high: 'var(--accent-gold)',
            medium: 'var(--accent-blue)',
            low: 'var(--text-muted)'
        };

        const severityLabels = {
            critical: 'Critique',
            high: 'Élevée',
            medium: 'Moyenne',
            low: 'Faible'
        };

        return `
            <div class="word-rep-item ${rep.severity}" data-rep-id="${rep.id}" onclick="WordRepetitionHandlers.onSelectRepetition('${rep.id}')">
                <div class="rep-item-header">
                    <span class="rep-word">${rep.word}</span>
                    <span class="rep-count" style="color: ${severityColors[rep.severity]};">${rep.count}x</span>
                </div>
                <div class="rep-item-meta">
                    <span class="rep-density">${rep.densityPercent}%</span>
                    <span class="rep-severity" style="background: ${severityColors[rep.severity]};">${severityLabels[rep.severity]}</span>
                    ${rep.proximityCount > 0 ? `<span class="rep-proximity" title="Répétitions proches"><i data-lucide="alert-triangle" style="width: 10px; height: 10px;"></i> ${rep.proximityCount}</span>` : ''}
                </div>
                <div class="rep-item-actions">
                    ${rep.suggestions.length > 0 ? `
                        <button class="btn btn-icon btn-tiny" onclick="event.stopPropagation(); WordRepetitionHandlers.onShowSuggestions('${rep.id}')" title="Voir suggestions">
                            <i data-lucide="lightbulb" style="width: 12px; height: 12px;"></i>
                        </button>
                    ` : ''}
                    <button class="btn btn-icon btn-tiny" onclick="event.stopPropagation(); WordRepetitionHandlers.onIgnoreWord('${rep.word}')" title="Ignorer ce mot">
                        <i data-lucide="eye-off" style="width: 12px; height: 12px;"></i>
                    </button>
                    <button class="btn btn-icon btn-tiny" onclick="event.stopPropagation(); WordRepetitionHandlers.onShowOccurrences('${rep.id}')" title="Voir occurrences">
                        <i data-lucide="list" style="width: 12px; height: 12px;"></i>
                    </button>
                </div>
            </div>
        `;
    },

    /**
     * [MVVM : View]
     * Rend le panneau de détail d'une répétition
     * @param {Object} rep - Répétition sélectionnée
     * @returns {string} HTML
     */
    renderDetailPanel(rep) {
        if (!rep) return '';

        return `
            <div class="word-rep-detail" id="wordRepDetail">
                <div class="detail-header">
                    <button class="btn btn-icon btn-small" onclick="WordRepetitionHandlers.onCloseDetail()">
                        <i data-lucide="arrow-left" style="width: 14px; height: 14px;"></i>
                    </button>
                    <span class="detail-word">"${rep.word}"</span>
                    <span class="detail-count">${rep.count} occurrences</span>
                </div>

                ${rep.suggestions.length > 0 ? this._renderSuggestions(rep) : ''}

                <div class="detail-occurrences">
                    <h4>Occurrences <span class="occ-count">(${rep.occurrences.length})</span></h4>
                    <div class="occurrences-list">
                        ${rep.occurrences.map((occ, idx) => this._renderOccurrence(occ, idx)).join('')}
                    </div>
                </div>
            </div>
        `;
    },

    /**
     * [MVVM : View]
     * Rend les suggestions de synonymes
     * @param {Object} rep - Répétition
     * @returns {string} HTML
     * @private
     */
    _renderSuggestions(rep) {
        return `
            <div class="detail-suggestions">
                <h4><i data-lucide="lightbulb" style="width: 14px; height: 14px;"></i> Suggestions</h4>
                <div class="suggestions-list">
                    ${rep.suggestions.map(sug => `
                        <span class="suggestion-tag" onclick="WordRepetitionHandlers.onCopySuggestion('${sug.suggestion}')" title="Cliquer pour copier">
                            ${sug.suggestion}
                        </span>
                    `).join('')}
                </div>
                <button class="btn btn-small btn-secondary" onclick="WordRepetitionHandlers.onLoadMoreSuggestions('${rep.word}')" style="margin-top: 0.5rem; width: 100%;">
                    <i data-lucide="plus" style="width: 12px; height: 12px;"></i> Plus de synonymes
                </button>
            </div>
        `;
    },

    /**
     * [MVVM : View]
     * Rend une occurrence
     * @param {Object} occ - Occurrence
     * @param {number} idx - Index
     * @returns {string} HTML
     * @private
     */
    _renderOccurrence(occ, idx) {
        const loc = occ.location;
        const locationText = loc.sceneTitle
            ? `${loc.actTitle} > ${loc.chapterTitle} > ${loc.sceneTitle}`
            : 'Position non localisée';

        // Mettre en évidence le mot dans le contexte
        const highlightedContext = occ.context.replace(
            new RegExp(`(${this._escapeHtml(occ.word)})`, 'gi'),
            '<mark>$1</mark>'
        );

        // Préparer les données de l'occurrence pour le click
        const occData = {
            word: occ.word,
            position: occ.position,
            location: occ.location,
            idx: idx
        };

        return `
            <div class="occurrence-item" data-occ-idx="${idx}" onclick="WordRepetitionHandlers.onNavigateToOccurrence(${idx})">
                <div class="occurrence-location">
                    <i data-lucide="map-pin" style="width: 10px; height: 10px;"></i>
                    <span>${locationText}</span>
                </div>
                <div class="occurrence-context">${highlightedContext}</div>
            </div>
        `;
    },

    /**
     * [MVVM : View]
     * Échappe les caractères HTML
     * @param {string} str - Chaîne à échapper
     * @returns {string} Chaîne échappée
     * @private
     */
    _escapeHtml(str) {
        const div = document.createElement('div');
        div.textContent = str;
        return div.innerHTML;
    },

    /**
     * [MVVM : View]
     * Affiche le panneau de détail
     * @param {Object} rep - Répétition
     */
    showDetail(rep) {
        const panel = document.getElementById('wordRepetitionPanel');
        if (!panel) return;

        // Masquer la liste
        const list = panel.querySelector('.word-rep-list');
        if (list) list.style.display = 'none';

        // Afficher le détail
        let detailContainer = panel.querySelector('#wordRepDetail');
        if (!detailContainer) {
            detailContainer = document.createElement('div');
            panel.querySelector('.word-rep-report').appendChild(detailContainer);
        }
        detailContainer.outerHTML = this.renderDetailPanel(rep);

        if (typeof lucide !== 'undefined') {
            setTimeout(() => lucide.createIcons(), 10);
        }
    },

    /**
     * [MVVM : View]
     * Ferme le panneau de détail
     */
    closeDetail() {
        const panel = document.getElementById('wordRepetitionPanel');
        if (!panel) return;

        const detail = panel.querySelector('#wordRepDetail');
        if (detail) detail.remove();

        const list = panel.querySelector('.word-rep-list');
        if (list) list.style.display = '';
    },

    /**
     * [MVVM : View]
     * Toggle les paramètres
     */
    toggleSettings() {
        const settings = document.getElementById('wordRepSettings');
        if (settings) {
            settings.style.display = settings.style.display === 'none' ? 'block' : 'none';
        }
    },

    /**
     * [MVVM : View]
     * Met à jour un élément de répétition comme ignoré
     * @param {string} word - Mot ignoré
     */
    markAsIgnored(word) {
        const items = document.querySelectorAll('.word-rep-item');
        items.forEach(item => {
            const wordEl = item.querySelector('.rep-word');
            if (wordEl && wordEl.textContent === word) {
                item.style.display = 'none';
            }
        });
    },

    /**
     * [MVVM : View]
     * Affiche une notification
     * @param {string} message - Message
     * @param {string} type - Type (success, error, info)
     */
    notify(message, type = 'info') {
        if (typeof showNotification === 'function') {
            showNotification(message, type);
        }
    }
};

// Export pour utilisation dans d'autres modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { WordRepetitionView };
}

// ========== js-refactor/word-repetition/word-repetition.handlers.js ==========
// ============================================================
// word-repetition.handlers.js - Gestionnaires d'événements
// ============================================================

/**
 * [MVVM : Handlers]
 * Gestionnaires d'événements pour l'analyseur de répétitions
 */
const WordRepetitionHandlers = {
    /**
     * [MVVM : Handlers]
     * Gestionnaire de rafraîchissement/analyse
     */
    onRefresh() {
        const state = WordRepetitionViewModel.getState();
        const result = WordRepetitionViewModel.analyze(state.currentScope);

        this._refreshPanel();

        if (result.success) {
            WordRepetitionView.notify(result.message, 'success');
        } else {
            WordRepetitionView.notify(result.message, 'error');
        }
    },

    /**
     * [MVVM : Handlers]
     * Gestionnaire de changement de scope
     * @param {string} scope - Nouveau scope
     */
    onScopeChange(scope) {
        WordRepetitionState.currentScope = scope;
        const result = WordRepetitionViewModel.analyze(scope);

        this._refreshPanel();

        if (result.success) {
            WordRepetitionView.notify(result.message, 'info');
        }
    },

    /**
     * [MVVM : Handlers]
     * Gestionnaire d'ouverture/fermeture des paramètres
     */
    onToggleSettings() {
        WordRepetitionView.toggleSettings();
    },

    /**
     * [MVVM : Handlers]
     * Gestionnaire de changement de préférence
     * @param {string} key - Clé de préférence
     * @param {*} value - Nouvelle valeur
     */
    onPrefChange(key, value) {
        WordRepetitionRepository.updatePreference(key, value);
        WordRepetitionView.notify('Préférence mise à jour', 'info');
    },

    /**
     * [MVVM : Handlers]
     * Gestionnaire de sélection d'une répétition
     * @param {string} repId - ID de la répétition
     */
    onSelectRepetition(repId) {
        const rep = WordRepetitionViewModel.selectRepetition(repId);
        if (rep) {
            // Surligner toutes les occurrences dans l'éditeur
            this._highlightAllOccurrences(rep.word);

            // Marquer visuellement l'item sélectionné
            document.querySelectorAll('.word-rep-item').forEach(el => el.classList.remove('selected'));
            const selectedItem = document.querySelector(`[data-rep-id="${repId}"]`);
            if (selectedItem) selectedItem.classList.add('selected');
        }
    },

    /**
     * [MVVM : Handlers]
     * Gestionnaire de fermeture du détail
     */
    onCloseDetail() {
        WordRepetitionState.selectedRepetition = null;
        WordRepetitionView.closeDetail();
    },

    /**
     * [MVVM : Handlers]
     * Gestionnaire d'affichage des suggestions
     * @param {string} repId - ID de la répétition
     */
    onShowSuggestions(repId) {
        const rep = WordRepetitionViewModel.selectRepetition(repId);
        if (rep) {
            WordRepetitionView.showDetail(rep);
        }
    },

    /**
     * [MVVM : Handlers]
     * Gestionnaire d'affichage des occurrences
     * @param {string} repId - ID de la répétition
     */
    onShowOccurrences(repId) {
        const rep = WordRepetitionViewModel.selectRepetition(repId);
        if (rep) {
            WordRepetitionView.showDetail(rep);
        }
    },

    /**
     * [MVVM : Handlers]
     * Gestionnaire d'ignorance d'un mot
     * @param {string} word - Mot à ignorer
     */
    onIgnoreWord(word) {
        const result = WordRepetitionViewModel.ignoreWord(word);
        if (result.success) {
            WordRepetitionView.markAsIgnored(word);
            WordRepetitionView.notify(result.message, 'success');
        }
    },

    /**
     * [MVVM : Handlers]
     * Gestionnaire de copie d'une suggestion
     * @param {string} suggestion - Mot suggéré
     */
    onCopySuggestion(suggestion) {
        if (navigator.clipboard) {
            navigator.clipboard.writeText(suggestion).then(() => {
                WordRepetitionView.notify(`"${suggestion}" copié !`, 'success');
            });
        } else {
            // Fallback
            const textarea = document.createElement('textarea');
            textarea.value = suggestion;
            document.body.appendChild(textarea);
            textarea.select();
            document.execCommand('copy');
            document.body.removeChild(textarea);
            WordRepetitionView.notify(`"${suggestion}" copié !`, 'success');
        }
    },

    /**
     * [MVVM : Handlers]
     * Gestionnaire de chargement de plus de suggestions
     * @param {string} word - Mot à rechercher
     */
    async onLoadMoreSuggestions(word) {
        const suggestions = await WordRepetitionViewModel.getSuggestions(word);

        if (suggestions.length > 0) {
            // Mettre à jour la répétition avec les nouvelles suggestions
            const report = WordRepetitionViewModel.getCurrentReport();
            if (report) {
                const rep = report.repetitions.find(r => r.word === word);
                if (rep) {
                    rep.suggestions = suggestions;
                    WordRepetitionView.showDetail(rep);
                }
            }
        } else {
            WordRepetitionView.notify('Aucune suggestion supplémentaire', 'info');
        }
    },

    /**
     * [MVVM : Handlers]
     * Gestionnaire de navigation vers une occurrence
     * @param {number} occIdx - Index de l'occurrence
     */
    onNavigateToOccurrence(occIdx) {
        const rep = WordRepetitionState.selectedRepetition;
        if (!rep || !rep.occurrences || !rep.occurrences[occIdx]) {
            console.warn('[WordRepetition] Occurrence non trouvée:', occIdx);
            return;
        }

        const occurrence = rep.occurrences[occIdx];
        const loc = occurrence.location;

        // Marquer l'occurrence comme active
        document.querySelectorAll('.occurrence-item').forEach(el => el.classList.remove('active'));
        const activeItem = document.querySelector(`[data-occ-idx="${occIdx}"]`);
        if (activeItem) activeItem.classList.add('active');

        // Vérifier si on doit changer de scène
        const needSceneChange = loc.sceneId && (
            loc.actId !== currentActId ||
            loc.chapterId !== currentChapterId ||
            loc.sceneId !== currentSceneId
        );

        if (needSceneChange && typeof openScene === 'function') {
            // Ouvrir la scène puis naviguer vers l'occurrence
            openScene(loc.actId, loc.chapterId, loc.sceneId);

            // Attendre que la scène soit chargée puis naviguer
            setTimeout(() => {
                this._scrollToWordOccurrence(occurrence.word, occurrence.position);
            }, 400);
        } else {
            // Scène déjà ouverte, naviguer directement
            this._scrollToWordOccurrence(occurrence.word, occurrence.position);
        }
    },

    /**
     * [MVVM : Handlers]
     * Scroll vers une occurrence spécifique du mot dans l'éditeur
     * @param {string} word - Mot à trouver
     * @param {number} targetPosition - Position approximative dans le texte
     * @private
     */
    _scrollToWordOccurrence(word, targetPosition) {
        const editors = document.querySelectorAll('.editor-textarea[contenteditable="true"]');
        if (editors.length === 0) return;

        // Trouver tous les highlights du mot
        const highlights = document.querySelectorAll('.word-rep-highlight');
        if (highlights.length === 0) {
            // Si pas de highlights, les créer d'abord
            this._highlightAllOccurrences(word);
            setTimeout(() => this._scrollToWordOccurrence(word, targetPosition), 100);
            return;
        }

        // Trouver le highlight le plus proche de la position cible
        let bestMatch = null;
        let bestDistance = Infinity;

        highlights.forEach((mark, idx) => {
            // Calculer la position approximative du highlight
            const textBefore = this._getTextBeforeElement(mark);
            const distance = Math.abs(textBefore.length - targetPosition);

            if (distance < bestDistance) {
                bestDistance = distance;
                bestMatch = mark;
            }
        });

        if (bestMatch) {
            // Scroll vers le highlight trouvé
            bestMatch.scrollIntoView({ behavior: 'smooth', block: 'center' });

            // Ajouter une animation pour attirer l'attention
            bestMatch.classList.add('word-rep-highlight-focus');
            setTimeout(() => {
                bestMatch.classList.remove('word-rep-highlight-focus');
            }, 2000);
        }
    },

    /**
     * [MVVM : Handlers]
     * Obtient le texte avant un élément dans l'éditeur
     * @param {HTMLElement} element - Élément cible
     * @returns {string} Texte avant l'élément
     * @private
     */
    _getTextBeforeElement(element) {
        const editor = element.closest('.editor-textarea');
        if (!editor) return '';

        let text = '';
        const walker = document.createTreeWalker(editor, NodeFilter.SHOW_TEXT, null, false);
        let node;

        while (node = walker.nextNode()) {
            if (element.contains(node) || element === node.parentElement) {
                break;
            }
            text += node.textContent;
        }

        return text;
    },

    /**
     * [MVVM : Handlers]
     * Gestionnaire d'ajout de mot ignoré
     */
    onAddIgnoredWord() {
        const word = prompt('Mot à ignorer :');
        if (word && word.trim()) {
            const success = WordRepetitionRepository.addIgnoredWord(word.trim());
            if (success) {
                WordRepetitionView.notify(`"${word.trim()}" ajouté aux mots ignorés`, 'success');
                this._refreshPanel();
            }
        }
    },

    /**
     * [MVVM : Handlers]
     * Gestionnaire de suppression de mot ignoré
     * @param {string} word - Mot à retirer
     */
    onRemoveIgnoredWord(word) {
        const success = WordRepetitionRepository.removeIgnoredWord(word);
        if (success) {
            WordRepetitionView.notify(`"${word}" retiré des mots ignorés`, 'success');
            this._refreshPanel();
        }
    },

    /**
     * [MVVM : Handlers]
     * Surligne toutes les occurrences d'un mot dans les éditeurs selon le scope
     * @param {string} word - Mot à surligner
     * @private
     */
    _highlightAllOccurrences(word) {
        // D'abord, nettoyer les surlignages précédents
        this._clearAllHighlights();

        // Trouver tous les éditeurs visibles
        const editors = document.querySelectorAll('.editor-textarea[contenteditable="true"]');
        if (editors.length === 0) return;

        const regex = new RegExp(`\\b(${this._escapeRegex(word)})\\b`, 'gi');
        let firstHighlight = null;
        let highlightCount = 0;

        editors.forEach(editor => {
            // Utiliser TreeWalker pour parcourir les noeuds texte
            const walker = document.createTreeWalker(
                editor,
                NodeFilter.SHOW_TEXT,
                {
                    acceptNode: function(node) {
                        // Ignorer les noeuds déjà dans un mark
                        if (node.parentElement && node.parentElement.classList.contains('word-rep-highlight')) {
                            return NodeFilter.FILTER_REJECT;
                        }
                        return NodeFilter.FILTER_ACCEPT;
                    }
                },
                false
            );

            const nodesToProcess = [];
            let node;
            while (node = walker.nextNode()) {
                if (regex.test(node.textContent)) {
                    nodesToProcess.push(node);
                }
                regex.lastIndex = 0; // Reset regex
            }

            // Traiter les noeuds en ordre inverse pour ne pas invalider les positions
            nodesToProcess.reverse().forEach(textNode => {
                const text = textNode.textContent;
                const fragment = document.createDocumentFragment();
                let lastIndex = 0;
                let match;

                regex.lastIndex = 0;
                while ((match = regex.exec(text)) !== null) {
                    // Texte avant le match
                    if (match.index > lastIndex) {
                        fragment.appendChild(document.createTextNode(text.slice(lastIndex, match.index)));
                    }

                    // Créer le mark
                    const mark = document.createElement('mark');
                    mark.className = 'word-rep-highlight';
                    mark.textContent = match[0];
                    fragment.appendChild(mark);

                    if (!firstHighlight) {
                        firstHighlight = mark;
                    }
                    highlightCount++;

                    lastIndex = regex.lastIndex;
                }

                // Texte restant après le dernier match
                if (lastIndex < text.length) {
                    fragment.appendChild(document.createTextNode(text.slice(lastIndex)));
                }

                // Remplacer le noeud texte original
                if (fragment.childNodes.length > 0) {
                    textNode.parentNode.replaceChild(fragment, textNode);
                }
            });
        });

        // Scroll vers la première occurrence
        if (firstHighlight) {
            firstHighlight.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }

        // Afficher le nombre de surlignages
        if (highlightCount > 0) {
            WordRepetitionView.notify(`${highlightCount} occurrence(s) surlignée(s)`, 'info');
        }
    },

    /**
     * [MVVM : Handlers]
     * Nettoie tous les surlignages de répétition
     * @private
     */
    _clearAllHighlights() {
        const highlights = document.querySelectorAll('.word-rep-highlight');
        highlights.forEach(mark => {
            const parent = mark.parentNode;
            // Remplacer le mark par son contenu texte
            const textNode = document.createTextNode(mark.textContent);
            parent.replaceChild(textNode, mark);
            // Normaliser pour fusionner les noeuds texte adjacents
            parent.normalize();
        });
    },

    /**
     * [MVVM : Handlers]
     * Échappe les caractères spéciaux regex
     * @param {string} str - Chaîne à échapper
     * @returns {string} Chaîne échappée
     * @private
     */
    _escapeRegex(str) {
        return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    },

    /**
     * [MVVM : Handlers]
     * Surligne un mot dans l'éditeur (navigation vers première occurrence)
     * @param {string} word - Mot à surligner
     * @private
     */
    _highlightWordInEditor(word) {
        const editor = document.querySelector('.editor-textarea');
        if (!editor) return;

        // Utiliser l'API de sélection
        const selection = window.getSelection();
        const range = document.createRange();

        // Trouver le premier mot correspondant
        const walker = document.createTreeWalker(
            editor,
            NodeFilter.SHOW_TEXT,
            null,
            false
        );

        const regex = new RegExp(`\\b${word}\\b`, 'i');
        let node;
        while (node = walker.nextNode()) {
            const match = node.textContent.match(regex);
            if (match) {
                const startIndex = node.textContent.indexOf(match[0]);
                range.setStart(node, startIndex);
                range.setEnd(node, startIndex + match[0].length);
                selection.removeAllRanges();
                selection.addRange(range);

                // Scroll vers la sélection
                const rect = range.getBoundingClientRect();
                editor.scrollTop = rect.top - editor.getBoundingClientRect().top - 100;

                break;
            }
        }
    },

    /**
     * [MVVM : Handlers]
     * Rafraîchit le panneau
     * @private
     */
    _refreshPanel() {
        const container = document.getElementById('wordRepetitionContainer');
        if (container) {
            WordRepetitionView.renderPanel(container);
        }
    }
};

/**
 * [MVVM : Handlers]
 * Initialise le panneau de répétitions
 * @param {string} containerId - ID du conteneur
 */
function initWordRepetitionPanel(containerId = 'wordRepetitionContainer') {
    const container = document.getElementById(containerId);
    if (container) {
        WordRepetitionView.renderPanel(container);
    }
}

/**
 * [MVVM : Handlers]
 * Rafraîchit le panneau de répétitions si une scène change
 */
function refreshWordRepetitionOnSceneChange() {
    const state = WordRepetitionViewModel.getState();
    if (state.currentScope === WordRepetitionConfig.scope.SCENE) {
        // Clear le rapport pour forcer une nouvelle analyse
        WordRepetitionViewModel.clearReport();
        const container = document.getElementById('wordRepetitionContainer');
        if (container) {
            WordRepetitionView.renderPanel(container);
        }
    }
}

// Export pour utilisation dans d'autres modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        WordRepetitionHandlers,
        initWordRepetitionPanel,
        refreshWordRepetitionOnSceneChange
    };
}

// ========== js-refactor/word-repetition/word-repetition.main.js ==========
// ============================================================
// word-repetition.main.js - Point d'entrée et initialisation
// ============================================================

/**
 * [MVVM : Other]
 * Toggle l'affichage du panneau de répétitions de mots
 */
function toggleWordRepetitionPanel() {
    const sidebar = document.getElementById('wordRepetitionSidebar');
    const btn = document.getElementById('toolRepetitionBtn');

    if (!sidebar) return;

    const isVisible = !sidebar.classList.contains('hidden');

    if (isVisible) {
        sidebar.classList.add('hidden');
        if (btn) btn.classList.remove('active');
        WordRepetitionState.panelVisible = false;
        // Nettoyer les surlignages quand on ferme le panneau
        clearWordRepetitionHighlights();
    } else {
        sidebar.classList.remove('hidden');
        if (btn) btn.classList.add('active');
        WordRepetitionState.panelVisible = true;

        // Initialiser le panneau si nécessaire
        initWordRepetitionPanel();

        // Initialiser les icônes Lucide
        if (typeof lucide !== 'undefined') {
            setTimeout(() => lucide.createIcons(), 50);
        }
    }
}

/**
 * [MVVM : Other]
 * Affiche le panneau de répétitions (utile pour affichage programmatique)
 */
function showWordRepetitionPanel() {
    const sidebar = document.getElementById('wordRepetitionSidebar');
    const btn = document.getElementById('toolRepetitionBtn');

    if (!sidebar) return;

    sidebar.classList.remove('hidden');
    if (btn) btn.classList.add('active');
    WordRepetitionState.panelVisible = true;

    initWordRepetitionPanel();

    if (typeof lucide !== 'undefined') {
        setTimeout(() => lucide.createIcons(), 50);
    }
}

/**
 * [MVVM : Other]
 * Cache le panneau de répétitions
 */
function hideWordRepetitionPanel() {
    const sidebar = document.getElementById('wordRepetitionSidebar');
    const btn = document.getElementById('toolRepetitionBtn');

    if (!sidebar) return;

    sidebar.classList.add('hidden');
    if (btn) btn.classList.remove('active');
    WordRepetitionState.panelVisible = false;
    // Nettoyer les surlignages
    clearWordRepetitionHighlights();
}

/**
 * [MVVM : Other]
 * Nettoie tous les surlignages de répétition dans l'éditeur
 */
function clearWordRepetitionHighlights() {
    if (typeof WordRepetitionHandlers !== 'undefined' && WordRepetitionHandlers._clearAllHighlights) {
        WordRepetitionHandlers._clearAllHighlights();
    }
}

/**
 * [MVVM : Other]
 * Lance une analyse rapide pour la scène courante et affiche le résultat
 */
function analyzeCurrentSceneRepetitions() {
    showWordRepetitionPanel();

    // Lancer l'analyse après un court délai pour laisser le panneau s'afficher
    setTimeout(() => {
        WordRepetitionHandlers.onRefresh();
    }, 100);
}

/**
 * [MVVM : Other]
 * Intégration avec l'ouverture de scène
 * Appelé automatiquement quand une scène est ouverte
 */
function onSceneOpenedForRepetition() {
    if (WordRepetitionState.panelVisible) {
        // Effacer le rapport précédent car la scène a changé
        WordRepetitionViewModel.clearReport();

        // Re-rendre le panneau pour afficher l'état vide
        const container = document.getElementById('wordRepetitionContainer');
        if (container) {
            WordRepetitionView.renderPanel(container);
        }
    }
}

/**
 * [MVVM : Other]
 * Raccourci clavier pour analyser les répétitions
 * Ctrl+Shift+R
 */
function setupWordRepetitionKeyboardShortcuts() {
    document.addEventListener('keydown', function(e) {
        // Ctrl+Shift+R : Analyser les répétitions
        if (e.ctrlKey && e.shiftKey && e.key === 'R') {
            e.preventDefault();
            analyzeCurrentSceneRepetitions();
        }
    });
}

/**
 * [MVVM : Other]
 * Configure le redimensionnement de la sidebar
 */
function setupWordRepetitionSidebarResize() {
    const sidebar = document.getElementById('wordRepetitionSidebar');
    const resizeHandle = document.getElementById('wordRepSidebarResize');

    if (!sidebar || !resizeHandle) return;

    let isResizing = false;
    let startX = 0;
    let startWidth = 0;

    resizeHandle.addEventListener('mousedown', (e) => {
        isResizing = true;
        startX = e.clientX;
        startWidth = sidebar.offsetWidth;
        resizeHandle.classList.add('active');
        document.body.style.cursor = 'ew-resize';
        document.body.style.userSelect = 'none';
        e.preventDefault();
    });

    document.addEventListener('mousemove', (e) => {
        if (!isResizing) return;

        const diff = startX - e.clientX;
        const newWidth = Math.max(280, Math.min(600, startWidth + diff));
        sidebar.style.width = newWidth + 'px';

        // Sauvegarder la largeur
        WordRepetitionRepository.updatePreference('sidebarWidth', newWidth);
    });

    document.addEventListener('mouseup', () => {
        if (isResizing) {
            isResizing = false;
            resizeHandle.classList.remove('active');
            document.body.style.cursor = '';
            document.body.style.userSelect = '';
        }
    });

    // Restaurer la largeur sauvegardée
    const prefs = WordRepetitionRepository.getPreferences();
    if (prefs.sidebarWidth) {
        sidebar.style.width = prefs.sidebarWidth + 'px';
    }
}

/**
 * [MVVM : Other]
 * Initialisation au chargement de l'application
 */
function initWordRepetitionModule() {
    // Configurer les raccourcis clavier
    setupWordRepetitionKeyboardShortcuts();

    // Configurer le redimensionnement
    setupWordRepetitionSidebarResize();

    // Restaurer l'état du panneau si il était ouvert
    const prefs = WordRepetitionRepository.getPreferences();
    if (!prefs.panelCollapsed && WordRepetitionState.panelVisible) {
        showWordRepetitionPanel();
    }

    console.log('[WordRepetition] Module initialisé');
}

// Auto-initialisation lorsque le DOM est prêt
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initWordRepetitionModule);
} else {
    // DOM déjà prêt
    setTimeout(initWordRepetitionModule, 100);
}

// Export pour utilisation dans d'autres modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        toggleWordRepetitionPanel,
        showWordRepetitionPanel,
        hideWordRepetitionPanel,
        clearWordRepetitionHighlights,
        analyzeCurrentSceneRepetitions,
        onSceneOpenedForRepetition,
        initWordRepetitionModule
    };
}

// ========== js-refactor/48.product-tour.model.js ==========
/**
 * [MVVM : Product Tour Model]
 * Factories et structures de données pour le système de visite guidée.
 */

console.log('🎓 Product Tour Model loaded');

// ============================================
// TOUR STATE MODEL
// ============================================

const ProductTourStateModel = {
    /**
     * Crée un état initial pour le tour.
     * @returns {Object} État initial du tour.
     */
    createInitial: function () {
        return {
            completed: false,
            skipped: false,
            currentStep: 0,
            lastShown: null,
            version: '1.0',
            preferences: {
                showOnStartup: true,
                autoAdvance: false
            }
        };
    },

    /**
     * Valide et normalise un état de tour.
     * @param {Object} state - État à valider.
     * @returns {Object} État validé.
     */
    validate: function (state) {
        if (!state || typeof state !== 'object') {
            return this.createInitial();
        }

        return {
            completed: Boolean(state.completed),
            skipped: Boolean(state.skipped),
            currentStep: Number(state.currentStep) || 0,
            lastShown: state.lastShown || null,
            version: state.version || '1.0',
            preferences: {
                showOnStartup: state.preferences?.showOnStartup !== false,
                autoAdvance: Boolean(state.preferences?.autoAdvance)
            }
        };
    },

    /**
     * Migre un état legacy si nécessaire.
     * @param {Object} raw - Données brutes.
     * @returns {Object} État migré.
     */
    migrate: function (raw) {
        if (!raw) return this.createInitial();
        
        // Migration v1.0 -> v1.1 (exemple pour futures versions)
        if (raw.version === '1.0') {
            return this.validate(raw);
        }
        
        return this.validate(raw);
    }
};

// ============================================
// TOUR STEP MODEL
// ============================================

const ProductTourStepModel = {
    /**
     * Crée une définition de step de tour.
     * @param {Object} data - Données du step.
     * @returns {Object} Step validé.
     */
    create: function (data = {}) {
        return {
            element: data.element || null,
            popover: {
                title: data.popover?.title || '',
                description: data.popover?.description || '',
                side: data.popover?.side || 'bottom',
                align: data.popover?.align || 'start'
            },
            onHighlightStarted: data.onHighlightStarted || null,
            onHighlighted: data.onHighlighted || null,
            onDeselected: data.onDeselected || null,
            onNext: data.onNext || null,
            onPrevious: data.onPrevious || null
        };
    },

    /**
     * Valide qu'un élément existe dans le DOM.
     * @param {string} selector - Sélecteur CSS.
     * @returns {boolean} True si l'élément existe.
     */
    validateElement: function (selector) {
        if (!selector) return false;
        try {
            return document.querySelector(selector) !== null;
        } catch (e) {
            console.warn(`Invalid selector: ${selector}`, e);
            return false;
        }
    }
};

// ============================================
// TOUR CONFIG MODEL
// ============================================

const ProductTourConfigModel = {
    /**
     * Crée la configuration Driver.js pour le tour.
     * @returns {Object} Configuration Driver.js.
     */
    createDriverConfig: function () {
        return {
            animate: true,
            opacity: 0.75,
            padding: 10,
            allowClose: true,
            overlayClickNext: false,
            doneBtnText: 'Terminer',
            closeBtnText: 'Fermer',
            nextBtnText: 'Suivant',
            prevBtnText: 'Précédent',
            showProgress: true,
            progressText: 'Étape {{current}} sur {{total}}',
            showButtons: ['next', 'previous', 'close'],
            disableActiveInteraction: false,
            onDestroyStarted: () => {
                console.log('🎓 Tour destroy started');
                // Sera géré par le ViewModel
                if (typeof onTourCompleteVM === 'function') {
                    onTourCompleteVM();
                }
            },
            onDestroyed: () => {
                console.log('🎓 Tour destroyed');
                // Cleanup après fermeture
                if (typeof onTourDestroyedVM === 'function') {
                    onTourDestroyedVM();
                }
            }
        };
    },

    /**
     * Crée la configuration pour mobile.
     * @returns {Object} Configuration mobile.
     */
    createMobileConfig: function () {
        const config = this.createDriverConfig();
        return {
            ...config,
            padding: 5,
            progressText: '{{current}}/{{total}}'
        };
    }
};

// ============================================
// TOUR STEPS DEFINITIONS
// ============================================

const ProductTourStepsModel = {
    /**
     * Retourne tous les steps du tour selon le contexte.
     * @returns {Array} Liste des steps.
     */
    getAllSteps: function () {
        const isMobile = window.innerWidth < 768;
        return isMobile ? this.getMobileSteps() : this.getDesktopSteps();
    },

    /**
     * Steps pour desktop (tour complet).
     * @returns {Array} Steps desktop.
     */
    getDesktopSteps: function () {
        return [
            // Stage 1: Welcome & Orientation
            {
                element: '#headerProjectTitle',
                popover: {
                    title: '🪶 Bienvenue dans Plume',
                    description: `
                        <p>Plume est votre espace d'écriture complet pour créer des histoires captivantes.</p>
                        <p>Cette visite guidée vous présentera les fonctionnalités principales en quelques minutes.</p>
                        <p><strong>Vous pouvez quitter à tout moment en appuyant sur Échap.</strong></p>
                    `,
                    side: 'bottom',
                    align: 'start'
                },
                onHighlightStarted: () => {
                    // Ensure we're on the editor view
                    if (typeof currentView !== 'undefined' && currentView !== 'editor') {
                        if (typeof switchView === 'function') {
                            switchView('editor');
                        }
                    }
                }
            },
            {
                element: '#headerProjectTitle',
                popover: {
                    title: 'Titre du Projet',
                    description: `
                        <p>Cliquez sur le titre pour renommer votre projet.</p>
                        <p>Chaque projet est sauvegardé automatiquement dans votre navigateur.</p>
                    `,
                    side: 'bottom',
                    align: 'start'
                }
            },
            // Navigation - Groupe 1: Écriture
            {
                element: '.header-nav .nav-group:nth-child(1)',
                popover: {
                    title: '📝 Outils d\'Écriture',
                    description: `
                        <p>Organisez et visualisez votre histoire de différentes manières :</p>
                        <ul>
                            <li><strong>Structure</strong> : Vue hiérarchique (Actes → Chapitres → Scènes)</li>
                            <li><strong>Tableau</strong> : Vue en cartes (Corkboard)</li>
                            <li><strong>Intrigue</strong> : Graphique de tension narrative</li>
                            <li><strong>Arcs</strong> : Suivi des arcs narratifs</li>
                        </ul>
                    `,
                    side: 'bottom',
                    align: 'start'
                }
            },
            // Navigation - Groupe 2: Base de données
            {
                element: '.header-nav .nav-group:nth-child(2)',
                popover: {
                    title: '📚 Base de Données',
                    description: `
                        <p>Gérez tous les éléments de votre univers :</p>
                        <ul>
                            <li><strong>Personnages</strong> : Fiches détaillées avec relations</li>
                            <li><strong>Univers</strong> : Lieux, objets, concepts</li>
                            <li><strong>Codex</strong> : Encyclopédie de votre monde</li>
                            <li><strong>Notes</strong> : Notes libres et idées</li>
                        </ul>
                    `,
                    side: 'bottom',
                    align: 'start'
                }
            },
            // Navigation - Groupe 3: Visualisations
            {
                element: '.header-nav .nav-group:nth-child(3)',
                popover: {
                    title: '🗺️ Visualisations',
                    description: `
                        <p>Explorez votre histoire visuellement :</p>
                        <ul>
                            <li><strong>Mindmap</strong> : Carte mentale de votre histoire</li>
                            <li><strong>Relations</strong> : Graphe des relations entre personnages</li>
                            <li><strong>Carte</strong> : Carte géographique de votre monde</li>
                            <li><strong>Timeline</strong> : Chronologie des événements</li>
                        </ul>
                    `,
                    side: 'bottom',
                    align: 'center'
                }
            },
            // Navigation - Groupe 4: Analyse
            {
                element: '.header-nav .nav-group:nth-child(4)',
                popover: {
                    title: '📊 Analyse & Statistiques',
                    description: `
                        <p>Analysez votre texte en profondeur :</p>
                        <ul>
                            <li><strong>Stats</strong> : Nombre de mots, chapitres, scènes</li>
                            <li><strong>Analyse</strong> : Répétitions, lisibilité, style</li>
                        </ul>
                    `,
                    side: 'bottom',
                    align: 'center'
                }
            },
            // Navigation - Groupe 5: Historique
            {
                element: '.header-nav .nav-group:nth-child(5)',
                popover: {
                    title: '💾 Snapshots',
                    description: `
                        <p>Sauvegardez des versions de votre travail :</p>
                        <ul>
                            <li>Créez des snapshots à tout moment</li>
                            <li>Comparez différentes versions</li>
                            <li>Restaurez une version antérieure</li>
                        </ul>
                    `,
                    side: 'bottom',
                    align: 'center'
                }
            },
            
            // Actions Header - Stats
            {
                element: '#headerStatsContainer',
                popover: {
                    title: '📈 Statistiques Rapides',
                    description: `
                        <p>Suivez votre progression en temps réel :</p>
                        <ul>
                            <li>Nombre total de mots</li>
                            <li>Nombre de chapitres</li>
                            <li>Mise à jour automatique</li>
                        </ul>
                    `,
                    side: 'bottom',
                    align: 'end'
                }
            },
            // Actions Header - Split View
            {
                element: '#splitModeToggle',
                popover: {
                    title: '⚡ Mode Split',
                    description: `
                        <p>Travaillez sur deux scènes simultanément :</p>
                        <ul>
                            <li>Vue côte à côte</li>
                            <li>Parfait pour comparer ou référencer</li>
                            <li>Synchronisation du scroll optionnelle</li>
                        </ul>
                    `,
                    side: 'bottom',
                    align: 'end'
                }
            },
            // Actions Header - Storage
            {
                element: '#storage-badge',
                popover: {
                    title: '💾 Espace de Stockage',
                    description: `
                        <p>Surveillez l'utilisation de votre stockage local :</p>
                        <ul>
                            <li>Indicateur visuel (vert/orange/rouge)</li>
                            <li>Cliquez pour voir les détails</li>
                            <li>Gérez vos projets pour libérer de l'espace</li>
                        </ul>
                    `,
                    side: 'bottom',
                    align: 'end'
                }
            },
            // Actions Header - Undo/Redo
            {
                element: '#headerUndoBtn',
                popover: {
                    title: '↩️ Annuler / Rétablir',
                    description: `
                        <p>Historique complet de vos modifications :</p>
                        <ul>
                            <li><strong>Annuler</strong> : Ctrl+Z</li>
                            <li><strong>Rétablir</strong> : Ctrl+Y</li>
                            <li>Historique illimité pendant la session</li>
                        </ul>
                    `,
                    side: 'bottom',
                    align: 'end'
                }
            },
            // Actions Header - Pomodoro
            {
                element: '#pomodoroHeaderBtn',
                popover: {
                    title: '⏱️ Timer Pomodoro',
                    description: `
                        <p>Gérez votre temps d'écriture efficacement :</p>
                        <ul>
                            <li>Sessions de 25 minutes</li>
                            <li>Pauses de 5 minutes</li>
                            <li>Notifications sonores</li>
                        </ul>
                    `,
                    side: 'bottom',
                    align: 'end'
                }
            },
            // Actions Header - Import
            {
                element: '.header-action-btn[onclick="openImportChapterModal()"]',
                popover: {
                    title: '📥 Importer du Texte',
                    description: `
                        <p>Importez vos textes existants :</p>
                        <ul>
                            <li>Formats : .docx, .txt, .md, .epub</li>
                            <li>Détection automatique de la structure</li>
                            <li>Préservation de la mise en forme</li>
                        </ul>
                    `,
                    side: 'bottom',
                    align: 'end'
                }
            },
            // Actions Header - Export
            {
                element: '.header-action-btn[onclick="showBackupMenu()"]',
                popover: {
                    title: '📤 Sauvegardes & Exports',
                    description: `
                        <p>Exportez votre travail dans différents formats :</p>
                        <ul>
                            <li><strong>DOCX</strong> : Microsoft Word</li>
                            <li><strong>PDF</strong> : Document portable</li>
                            <li><strong>JSON</strong> : Sauvegarde complète</li>
                            <li><strong>TXT</strong> : Texte brut</li>
                        </ul>
                    `,
                    side: 'bottom',
                    align: 'end'
                }
            },
            // Actions Header - Themes
            {
                element: '.header-action-btn[onclick="openThemeManager()"]',
                popover: {
                    title: '🎨 Gestionnaire de Thèmes',
                    description: `
                        <p>Personnalisez l'apparence de Plume :</p>
                        <ul>
                            <li>Thèmes clairs et sombres</li>
                            <li>Couleurs personnalisables</li>
                            <li>Polices d'écriture variées</li>
                            <li>Sauvegarde de vos préférences</li>
                        </ul>
                    `,
                    side: 'bottom',
                    align: 'end'
                }
            },
            // Actions Header - Projects
            {
                element: '.header-action-btn[onclick="openProjectsModal()"]',
                popover: {
                    title: '📁 Gestionnaire de Projets',
                    description: `
                        <p>Gérez tous vos projets d'écriture :</p>
                        <ul>
                            <li>Créer de nouveaux projets</li>
                            <li>Basculer entre projets</li>
                            <li>Dupliquer ou supprimer</li>
                            <li>Stockage local sécurisé</li>
                        </ul>
                    `,
                    side: 'bottom',
                    align: 'end'
                }
            },

            // Stage 2: Core Writing Features
            {
                element: '.sidebar',
                popover: {
                    title: 'Structure du Projet',
                    description: `
                        <p>La barre latérale affiche la structure de votre histoire :</p>
                        <ul>
                            <li><strong>Actes</strong> : Grandes parties de votre récit</li>
                            <li><strong>Chapitres</strong> : Subdivisions des actes</li>
                            <li><strong>Scènes</strong> : Unités d'écriture individuelles</li>
                        </ul>
                        <p>Cliquez sur une scène pour l'éditer.</p>
                    `,
                    side: 'right',
                    align: 'start'
                }
            },
            {
                element: '#sceneEditor',
                popover: {
                    title: 'Éditeur de Scène',
                    description: `
                        <p>L'éditeur principal pour écrire vos scènes.</p>
                        <p>Fonctionnalités disponibles :</p>
                        <ul>
                            <li>Formatage de texte riche</li>
                            <li>Détection automatique des personnages</li>
                            <li>Compteur de mots en temps réel</li>
                            <li>Sauvegarde automatique</li>
                        </ul>
                    `,
                    side: 'left',
                    align: 'start'
                }
            },

            // Stage 3: Completion
            {
                element: '#headerProjectTitle',
                popover: {
                    title: '🎉 Visite Terminée !',
                    description: `
                        <p>Vous connaissez maintenant les bases de Plume !</p>
                        <p>Explorez les autres sections pour découvrir encore plus de fonctionnalités :</p>
                        <ul>
                            <li>Personnages et Univers</li>
                            <li>Visualisations et graphiques</li>
                            <li>Outils d'analyse et statistiques</li>
                        </ul>
                        <p><strong>Bon courage pour votre écriture ! ✍️</strong></p>
                    `,
                    side: 'bottom',
                    align: 'start'
                }
            }
        ];
    },

    /**
     * Steps pour mobile (tour simplifié).
     * @returns {Array} Steps mobile.
     */
    getMobileSteps: function () {
        return [
            {
                element: '#headerProjectTitle',
                popover: {
                    title: '🪶 Bienvenue',
                    description: `
                        <p>Plume est votre espace d'écriture complet.</p>
                        <p>Découvrez les fonctionnalités principales.</p>
                    `,
                    side: 'bottom',
                    align: 'start'
                }
            },
            {
                element: '.sidebar',
                popover: {
                    title: 'Structure',
                    description: `
                        <p>Organisez votre histoire en actes, chapitres et scènes.</p>
                    `,
                    side: 'right',
                    align: 'start'
                }
            },
            {
                element: '#sceneEditor',
                popover: {
                    title: 'Éditeur',
                    description: `
                        <p>Écrivez vos scènes avec sauvegarde automatique.</p>
                    `,
                    side: 'left',
                    align: 'start'
                }
            },
            {
                element: '#headerProjectTitle',
                popover: {
                    title: '🎉 C\'est parti !',
                    description: `
                        <p>Vous êtes prêt à écrire votre histoire !</p>
                    `,
                    side: 'bottom',
                    align: 'start'
                }
            }
        ];
    },

    /**
     * Filtre les steps pour ne garder que ceux dont les éléments existent.
     * @param {Array} steps - Steps à filtrer.
     * @returns {Array} Steps filtrés.
     */
    filterValidSteps: function (steps) {
        return steps.filter(step => {
            if (!step.element) return true; // Steps sans élément (modals, etc.)
            return ProductTourStepModel.validateElement(step.element);
        });
    }
};

// ========== js-refactor/48.product-tour.repository.js ==========
/**
 * [MVVM : Product Tour Repository]
 * Couche d'accès aux données pour le système de visite guidée.
 */

console.log('🎓 Product Tour Repository loaded');

// ============================================
// GLOBAL STATE
// ============================================

let productTourState = ProductTourStateModel.createInitial();
let driverInstance = null;

// ============================================
// STATE REPOSITORY
// ============================================

const ProductTourStateRepository = {
    /**
     * Charge l'état du tour depuis le storage.
     * @returns {Promise<Object>} État du tour.
     */
    loadState: async function () {
        try {
            const saved = await loadSetting('productTourState');
            if (saved) {
                productTourState = ProductTourStateModel.migrate(saved);
            } else {
                productTourState = ProductTourStateModel.createInitial();
            }
            return productTourState;
        } catch (error) {
            console.error('Error loading tour state:', error);
            productTourState = ProductTourStateModel.createInitial();
            return productTourState;
        }
    },

    /**
     * Sauvegarde l'état du tour.
     * @param {Object} state - État à sauvegarder.
     * @returns {Promise<boolean>} Succès de la sauvegarde.
     */
    saveState: async function (state) {
        try {
            productTourState = ProductTourStateModel.validate(state);
            await saveSetting('productTourState', productTourState);
            return true;
        } catch (error) {
            console.error('Error saving tour state:', error);
            return false;
        }
    },

    /**
     * Récupère l'état actuel du tour.
     * @returns {Object} État actuel.
     */
    getState: function () {
        return { ...productTourState };
    },

    /**
     * Marque le tour comme complété.
     * @returns {Promise<boolean>} Succès de l'opération.
     */
    markCompleted: async function () {
        productTourState.completed = true;
        productTourState.lastShown = new Date().toISOString();
        return await this.saveState(productTourState);
    },

    /**
     * Marque le tour comme ignoré.
     * @returns {Promise<boolean>} Succès de l'opération.
     */
    markSkipped: async function () {
        productTourState.skipped = true;
        productTourState.lastShown = new Date().toISOString();
        return await this.saveState(productTourState);
    },

    /**
     * Réinitialise l'état du tour.
     * @returns {Promise<boolean>} Succès de l'opération.
     */
    reset: async function () {
        productTourState = ProductTourStateModel.createInitial();
        return await this.saveState(productTourState);
    },

    /**
     * Met à jour le step actuel.
     * @param {number} stepIndex - Index du step.
     * @returns {Promise<boolean>} Succès de l'opération.
     */
    updateCurrentStep: async function (stepIndex) {
        productTourState.currentStep = stepIndex;
        return await this.saveState(productTourState);
    },

    /**
     * Met à jour les préférences.
     * @param {Object} preferences - Nouvelles préférences.
     * @returns {Promise<boolean>} Succès de l'opération.
     */
    updatePreferences: async function (preferences) {
        productTourState.preferences = {
            ...productTourState.preferences,
            ...preferences
        };
        return await this.saveState(productTourState);
    },

    /**
     * Vérifie si c'est la première visite.
     * @returns {boolean} True si première visite.
     */
    isFirstVisit: function () {
        return !productTourState.completed && !productTourState.skipped;
    },

    /**
     * Vérifie si le tour doit être affiché au démarrage.
     * @returns {boolean} True si doit être affiché.
     */
    shouldShowOnStartup: function () {
        return this.isFirstVisit() && productTourState.preferences.showOnStartup;
    }
};

// ============================================
// DRIVER REPOSITORY
// ============================================

const ProductTourDriverRepository = {
    /**
     * Attend que Driver.js soit chargé.
     * @param {number} timeout - Timeout en ms (défaut: 5000).
     * @returns {Promise<boolean>} True si chargé, false sinon.
     */
    waitForDriver: function (timeout = 10000) {
        return new Promise((resolve) => {
            const startTime = Date.now();
            let checkCount = 0;
            
            const checkDriver = () => {
                checkCount++;
                const elapsed = Date.now() - startTime;
                
                // Check for driver.js IIFE bundle export: window.driver.js.driver
                const driverFn = window.driver?.js?.driver || window.driver?.driver || window.driver;
                
                if (typeof driverFn === 'function') {
                    console.log(`✅ Driver.js loaded after ${elapsed}ms (${checkCount} checks)`);
                    resolve(true);
                    return;
                }
                
                if (elapsed > timeout) {
                    console.error(`❌ Driver.js library loading timeout after ${elapsed}ms (${checkCount} checks)`);
                    console.error('window.driver:', window.driver);
                    console.error('window.driver.js:', window.driver?.js);
                    console.error('window.driver.js.driver:', window.driver?.js?.driver);
                    resolve(false);
                    return;
                }
                
                // Log every second
                if (checkCount % 10 === 0) {
                    console.log(`⏳ Waiting for Driver.js... ${elapsed}ms elapsed`);
                }
                
                setTimeout(checkDriver, 100);
            };
            
            checkDriver();
        });
    },

    /**
     * Initialise une instance Driver.js.
     * @param {Object} config - Configuration Driver.js.
     * @param {Array} steps - Steps du tour.
     * @returns {Promise<Object|null>} Instance Driver.js ou null.
     */
    createDriver: async function (config, steps) {
        try {
            // Attendre que Driver.js soit chargé
            const isLoaded = await this.waitForDriver();
            if (!isLoaded) {
                console.error('Driver.js library not loaded');
                return null;
            }
            
            // Get the driver function from the IIFE bundle
            // The bundle exports to window.driver.js.driver
            const driverFn = window.driver?.js?.driver || window.driver?.driver || window.driver;
            
            if (typeof driverFn !== 'function') {
                console.error('Driver function not found or not a function:', typeof driverFn);
                return null;
            }

            // Filtrer les steps valides
            const validSteps = ProductTourStepsModel.filterValidSteps(steps);
            
            if (validSteps.length === 0) {
                console.warn('No valid steps found for tour');
                return null;
            }

            driverInstance = driverFn({
                ...config,
                steps: validSteps
            });

            return driverInstance;
        } catch (error) {
            console.error('Error creating driver instance:', error);
            return null;
        }
    },

    /**
     * Récupère l'instance Driver.js actuelle.
     * @returns {Object|null} Instance Driver.js.
     */
    getDriver: function () {
        return driverInstance;
    },

    /**
     * Démarre le tour.
     * @returns {boolean} Succès du démarrage.
     */
    startTour: function () {
        if (!driverInstance) {
            console.error('Driver instance not initialized');
            return false;
        }

        try {
            driverInstance.drive();
            return true;
        } catch (error) {
            console.error('Error starting tour:', error);
            return false;
        }
    },

    /**
     * Arrête le tour.
     * @returns {boolean} Succès de l'arrêt.
     */
    stopTour: function () {
        if (!driverInstance) {
            return true;
        }

        try {
            driverInstance.destroy();
            driverInstance = null;
            return true;
        } catch (error) {
            console.error('Error stopping tour:', error);
            return false;
        }
    },

    /**
     * Passe au step suivant.
     * @returns {boolean} Succès de l'opération.
     */
    moveNext: function () {
        if (!driverInstance) {
            return false;
        }

        try {
            driverInstance.moveNext();
            return true;
        } catch (error) {
            console.error('Error moving to next step:', error);
            return false;
        }
    },

    /**
     * Revient au step précédent.
     * @returns {boolean} Succès de l'opération.
     */
    movePrevious: function () {
        if (!driverInstance) {
            return false;
        }

        try {
            driverInstance.movePrevious();
            return true;
        } catch (error) {
            console.error('Error moving to previous step:', error);
            return false;
        }
    },

    /**
     * Va à un step spécifique.
     * @param {number} index - Index du step.
     * @returns {boolean} Succès de l'opération.
     */
    moveTo: function (index) {
        if (!driverInstance) {
            return false;
        }

        try {
            driverInstance.moveTo(index);
            return true;
        } catch (error) {
            console.error('Error moving to step:', error);
            return false;
        }
    },

    /**
     * Récupère l'index du step actuel.
     * @returns {number} Index du step actuel.
     */
    getCurrentStepIndex: function () {
        if (!driverInstance) {
            return 0;
        }

        try {
            return driverInstance.getActiveIndex() || 0;
        } catch (error) {
            console.error('Error getting current step:', error);
            return 0;
        }
    },

    /**
     * Vérifie si le tour est actif.
     * @returns {boolean} True si actif.
     */
    isActive: function () {
        return driverInstance !== null && driverInstance.isActive();
    },

    /**
     * Nettoie l'instance Driver.js.
     */
    cleanup: function () {
        if (driverInstance) {
            try {
                driverInstance.destroy();
            } catch (error) {
                console.error('Error cleaning up driver:', error);
            }
            driverInstance = null;
        }
    }
};

// ============================================
// STEPS REPOSITORY
// ============================================

const ProductTourStepsRepository = {
    /**
     * Récupère tous les steps du tour.
     * @returns {Array} Liste des steps.
     */
    getAllSteps: function () {
        return ProductTourStepsModel.getAllSteps();
    },

    /**
     * Récupère les steps desktop.
     * @returns {Array} Steps desktop.
     */
    getDesktopSteps: function () {
        return ProductTourStepsModel.getDesktopSteps();
    },

    /**
     * Récupère les steps mobile.
     * @returns {Array} Steps mobile.
     */
    getMobileSteps: function () {
        return ProductTourStepsModel.getMobileSteps();
    },

    /**
     * Filtre les steps valides.
     * @param {Array} steps - Steps à filtrer.
     * @returns {Array} Steps valides.
     */
    filterValidSteps: function (steps) {
        return ProductTourStepsModel.filterValidSteps(steps);
    }
};

// ========== js-refactor/48.product-tour.viewmodel.js ==========
/**
 * [MVVM : Product Tour ViewModel]
 * Logique métier et coordination entre Repository et View.
 */

console.log('🎓 Product Tour ViewModel loaded');

// ============================================
// INITIALIZATION
// ============================================

/**
 * Initialise le système de visite guidée.
 * @returns {Promise<Object>} Résultat de l'initialisation.
 */
async function initProductTourVM() {
    console.log('Initializing Product Tour...');

    try {
        // Charger l'état du tour
        await ProductTourStateRepository.loadState();

        // Créer le bouton de tour dans le header
        ProductTourButtonView.create(() => {
            startProductTourVM();
        });

        // Vérifier si on doit afficher le modal de bienvenue
        if (ProductTourStateRepository.shouldShowOnStartup()) {
            // Attendre que la page soit complètement chargée (y compris les scripts externes)
            const waitForPageLoad = () => {
                if (document.readyState === 'complete') {
                    setTimeout(() => {
                        showWelcomeModalVM();
                    }, 1000);
                } else {
                    window.addEventListener('load', () => {
                        setTimeout(() => {
                            showWelcomeModalVM();
                        }, 1000);
                    });
                }
            };
            
            waitForPageLoad();
        }

        return {
            success: true,
            message: 'Product tour initialized'
        };
    } catch (error) {
        console.error('Error initializing product tour:', error);
        return {
            success: false,
            error: error.message
        };
    }
}

// ============================================
// WELCOME MODAL
// ============================================

/**
 * Affiche le modal de bienvenue.
 * @returns {Object} Résultat de l'opération.
 */
function showWelcomeModalVM() {
    try {
        ProductTourWelcomeView.show(
            // onStart
            () => {
                startProductTourVM();
            },
            // onSkip
            async () => {
                await ProductTourStateRepository.markSkipped();
                ProductTourNotificationView.showInfo('Vous pouvez démarrer la visite à tout moment depuis le bouton d\'aide');
            },
            // onDontShowAgain
            async () => {
                await ProductTourStateRepository.updatePreferences({
                    showOnStartup: false
                });
            }
        );

        return {
            success: true,
            message: 'Welcome modal shown'
        };
    } catch (error) {
        console.error('Error showing welcome modal:', error);
        return {
            success: false,
            error: error.message
        };
    }
}

/**
 * Cache le modal de bienvenue.
 * @returns {Object} Résultat de l'opération.
 */
function hideWelcomeModalVM() {
    try {
        ProductTourWelcomeView.hide();
        return {
            success: true,
            message: 'Welcome modal hidden'
        };
    } catch (error) {
        console.error('Error hiding welcome modal:', error);
        return {
            success: false,
            error: error.message
        };
    }
}

// ============================================
// TOUR CONTROL
// ============================================

/**
 * Démarre la visite guidée.
 * @returns {Promise<Object>} Résultat de l'opération.
 */
async function startProductTourVM() {
    console.log('Starting product tour...');

    try {
        // Fermer le modal de bienvenue s'il est ouvert
        if (ProductTourWelcomeView.isVisible()) {
            ProductTourWelcomeView.hide();
        }

        // Récupérer les steps
        const steps = ProductTourStepsRepository.getAllSteps();
        if (steps.length === 0) {
            ProductTourNotificationView.showError('Aucune étape de visite disponible');
            return {
                success: false,
                error: 'No tour steps available'
            };
        }

        // Créer la configuration Driver.js
        const isMobile = window.innerWidth < 768;
        const config = isMobile
            ? ProductTourConfigModel.createMobileConfig()
            : ProductTourConfigModel.createDriverConfig();

        // Créer l'instance Driver.js (async)
        const driverInstance = await ProductTourDriverRepository.createDriver(config, steps);
        if (!driverInstance) {
            ProductTourNotificationView.showError('Impossible de démarrer la visite');
            return {
                success: false,
                error: 'Failed to create driver instance'
            };
        }

        // Démarrer le tour
        const started = ProductTourDriverRepository.startTour();
        if (!started) {
            ProductTourNotificationView.showError('Erreur lors du démarrage de la visite');
            return {
                success: false,
                error: 'Failed to start tour'
            };
        }

        return {
            success: true,
            message: 'Tour started',
            stepCount: steps.length
        };
    } catch (error) {
        console.error('Error starting tour:', error);
        ProductTourNotificationView.showError('Erreur lors du démarrage de la visite');
        return {
            success: false,
            error: error.message
        };
    }
}

/**
 * Arrête la visite guidée.
 * @returns {Object} Résultat de l'opération.
 */
function stopProductTourVM() {
    try {
        ProductTourDriverRepository.stopTour();
        ProductTourDriverView.cleanup();

        return {
            success: true,
            message: 'Tour stopped'
        };
    } catch (error) {
        console.error('Error stopping tour:', error);
        return {
            success: false,
            error: error.message
        };
    }
}

/**
 * Réinitialise la visite guidée.
 * @returns {Promise<Object>} Résultat de l'opération.
 */
async function resetProductTourVM() {
    try {
        // Arrêter le tour s'il est actif
        if (ProductTourDriverRepository.isActive()) {
            stopProductTourVM();
        }

        // Réinitialiser l'état
        await ProductTourStateRepository.reset();

        ProductTourNotificationView.showSuccess('La visite guidée a été réinitialisée');

        return {
            success: true,
            message: 'Tour reset'
        };
    } catch (error) {
        console.error('Error resetting tour:', error);
        ProductTourNotificationView.showError('Erreur lors de la réinitialisation');
        return {
            success: false,
            error: error.message
        };
    }
}

// ============================================
// TOUR CALLBACKS
// ============================================

/**
 * Callback appelé quand le tour est complété.
 * @returns {Promise<void>}
 */
async function onTourCompleteVM() {
    console.log('Tour completed');

    try {
        // Marquer comme complété
        await ProductTourStateRepository.markCompleted();

        // Afficher un message de succès
        ProductTourNotificationView.showSuccess('🎉 Visite terminée ! Bon courage pour votre écriture !');

        // Nettoyer
        ProductTourDriverView.cleanup();
    } catch (error) {
        console.error('Error completing tour:', error);
    }
}

/**
 * Callback appelé quand le tour est détruit.
 */
function onTourDestroyedVM() {
    console.log('Tour destroyed');

    try {
        // Nettoyer les ressources
        ProductTourDriverView.cleanup();
    } catch (error) {
        console.error('Error in tour destroyed callback:', error);
    }
}

/**
 * Callback appelé quand un step change.
 * @param {Object} element - Élément du step.
 * @param {Object} step - Définition du step.
 * @param {Object} options - Options du step.
 */
function onTourStepChangeVM(element, step, options) {
    try {
        // Sauvegarder le step actuel
        const currentIndex = ProductTourDriverRepository.getCurrentStepIndex();
        ProductTourStateRepository.updateCurrentStep(currentIndex);

        // Préparer la vue pour le step
        ProductTourDriverView.prepareForStep(step);
    } catch (error) {
        console.error('Error in step change callback:', error);
    }
}

// ============================================
// TOUR STATE QUERIES
// ============================================

/**
 * Vérifie si le tour est actif.
 * @returns {boolean} True si actif.
 */
function isProductTourActiveVM() {
    return ProductTourDriverRepository.isActive();
}

/**
 * Récupère l'état du tour.
 * @returns {Object} État du tour.
 */
function getProductTourStateVM() {
    return ProductTourStateRepository.getState();
}

/**
 * Vérifie si c'est la première visite.
 * @returns {boolean} True si première visite.
 */
function isFirstVisitVM() {
    return ProductTourStateRepository.isFirstVisit();
}

// ============================================
// TOUR NAVIGATION
// ============================================

/**
 * Passe au step suivant.
 * @returns {Object} Résultat de l'opération.
 */
function nextTourStepVM() {
    try {
        const success = ProductTourDriverRepository.moveNext();
        return {
            success,
            message: success ? 'Moved to next step' : 'Failed to move to next step'
        };
    } catch (error) {
        console.error('Error moving to next step:', error);
        return {
            success: false,
            error: error.message
        };
    }
}

/**
 * Revient au step précédent.
 * @returns {Object} Résultat de l'opération.
 */
function previousTourStepVM() {
    try {
        const success = ProductTourDriverRepository.movePrevious();
        return {
            success,
            message: success ? 'Moved to previous step' : 'Failed to move to previous step'
        };
    } catch (error) {
        console.error('Error moving to previous step:', error);
        return {
            success: false,
            error: error.message
        };
    }
}

/**
 * Va à un step spécifique.
 * @param {number} index - Index du step.
 * @returns {Object} Résultat de l'opération.
 */
function goToTourStepVM(index) {
    try {
        const success = ProductTourDriverRepository.moveTo(index);
        return {
            success,
            message: success ? `Moved to step ${index}` : `Failed to move to step ${index}`
        };
    } catch (error) {
        console.error('Error moving to step:', error);
        return {
            success: false,
            error: error.message
        };
    }
}

// ============================================
// PREFERENCES
// ============================================

/**
 * Met à jour les préférences du tour.
 * @param {Object} preferences - Nouvelles préférences.
 * @returns {Promise<Object>} Résultat de l'opération.
 */
async function updateTourPreferencesVM(preferences) {
    try {
        await ProductTourStateRepository.updatePreferences(preferences);
        return {
            success: true,
            message: 'Preferences updated'
        };
    } catch (error) {
        console.error('Error updating preferences:', error);
        return {
            success: false,
            error: error.message
        };
    }
}

// ============================================
// UTILITY FUNCTIONS
// ============================================

/**
 * Vérifie si Driver.js est chargé.
 * @returns {boolean} True si chargé.
 */
function isDriverJsLoadedVM() {
    return typeof driver !== 'undefined';
}

/**
 * Récupère les informations du tour.
 * @returns {Object} Informations du tour.
 */
function getTourInfoVM() {
    const state = ProductTourStateRepository.getState();
    const steps = ProductTourStepsRepository.getAllSteps();
    const isActive = ProductTourDriverRepository.isActive();

    return {
        state,
        stepCount: steps.length,
        isActive,
        driverLoaded: isDriverJsLoadedVM(),
        isMobile: window.innerWidth < 768
    };
}

// ========== js-refactor/48.product-tour.view.js ==========
/**
 * [MVVM : Product Tour View]
 * Rendu HTML et gestion du DOM pour le système de visite guidée.
 */

console.log('🎓 Product Tour View loaded');

// ============================================
// WELCOME MODAL VIEW
// ============================================

const ProductTourWelcomeView = {
    /**
     * Affiche le modal de bienvenue.
     * @param {Function} onStart - Callback pour démarrer le tour.
     * @param {Function} onSkip - Callback pour ignorer le tour.
     * @param {Function} onDontShowAgain - Callback pour ne plus afficher.
     */
    show: function (onStart, onSkip, onDontShowAgain) {
        // Créer l'overlay
        const overlay = document.createElement('div');
        overlay.className = 'tour-welcome-overlay';
        overlay.id = 'tourWelcomeOverlay';

        // Créer le modal
        const modal = document.createElement('div');
        modal.className = 'tour-welcome-modal';
        modal.id = 'tourWelcomeModal';
        modal.innerHTML = `
            <div class="tour-welcome-header">
                <div class="tour-welcome-icon">🪶</div>
                <h2 class="tour-welcome-title">Bienvenue dans Plume</h2>
                <p class="tour-welcome-subtitle">Votre compagnon d'écriture</p>
            </div>
            <div class="tour-welcome-content">
                <p>Plume est un outil complet pour organiser et écrire vos histoires.</p>
                <p>Voulez-vous découvrir les fonctionnalités principales en quelques minutes ?</p>
            </div>
            <div class="tour-welcome-actions">
                <button class="tour-welcome-btn tour-welcome-btn-secondary" id="tourSkipBtn">
                    Plus tard
                </button>
                <button class="tour-welcome-btn tour-welcome-btn-primary" id="tourStartBtn">
                    Commencer la visite
                </button>
            </div>
            <div class="tour-welcome-checkbox">
                <label>
                    <input type="checkbox" id="tourDontShowAgain">
                    Ne plus afficher ce message
                </label>
            </div>
        `;

        // Ajouter au DOM
        document.body.appendChild(overlay);
        document.body.appendChild(modal);

        // Attacher les événements
        const startBtn = document.getElementById('tourStartBtn');
        const skipBtn = document.getElementById('tourSkipBtn');
        const dontShowCheckbox = document.getElementById('tourDontShowAgain');

        startBtn.addEventListener('click', () => {
            const dontShow = dontShowCheckbox.checked;
            this.hide();
            if (dontShow && onDontShowAgain) {
                onDontShowAgain();
            }
            if (onStart) {
                onStart();
            }
        });

        skipBtn.addEventListener('click', () => {
            const dontShow = dontShowCheckbox.checked;
            this.hide();
            if (dontShow && onDontShowAgain) {
                onDontShowAgain();
            }
            if (onSkip) {
                onSkip();
            }
        });

        // Fermer avec Escape
        const handleEscape = (e) => {
            if (e.key === 'Escape') {
                skipBtn.click();
                document.removeEventListener('keydown', handleEscape);
            }
        };
        document.addEventListener('keydown', handleEscape);

        // Focus sur le bouton principal
        setTimeout(() => startBtn.focus(), 100);
    },

    /**
     * Cache le modal de bienvenue.
     */
    hide: function () {
        const overlay = document.getElementById('tourWelcomeOverlay');
        const modal = document.getElementById('tourWelcomeModal');

        if (overlay) {
            overlay.remove();
        }
        if (modal) {
            modal.remove();
        }
    },

    /**
     * Vérifie si le modal est visible.
     * @returns {boolean} True si visible.
     */
    isVisible: function () {
        return document.getElementById('tourWelcomeModal') !== null;
    }
};

// ============================================
// TOUR BUTTON VIEW
// ============================================

const ProductTourButtonView = {
    /**
     * Crée et affiche le bouton de tour dans le header.
     * @param {Function} onClick - Callback au clic.
     * @returns {HTMLElement|null} Élément bouton créé.
     */
    create: function (onClick) {
        // Vérifier si le bouton existe déjà
        if (document.getElementById('tourTriggerBtn')) {
            return document.getElementById('tourTriggerBtn');
        }

        // Trouver le conteneur des actions du header
        const headerActions = document.querySelector('.header-actions');
        if (!headerActions) {
            console.warn('Header actions container not found');
            return null;
        }

        // Créer le bouton
        const button = document.createElement('button');
        button.id = 'tourTriggerBtn';
        button.className = 'header-action-btn tour-trigger-btn';
        button.title = 'Démarrer la visite guidée';
        button.setAttribute('aria-label', 'Démarrer la visite guidée');
        button.innerHTML = '<i data-lucide="help-circle"></i>';

        // Attacher l'événement
        button.addEventListener('click', (e) => {
            e.preventDefault();
            if (onClick) {
                onClick();
            }
        });

        // Ajouter au header (avant le bouton des projets si possible)
        const projectsBtn = headerActions.querySelector('[onclick*="showProjectsModal"]');
        if (projectsBtn) {
            headerActions.insertBefore(button, projectsBtn);
        } else {
            headerActions.appendChild(button);
        }

        // Initialiser l'icône Lucide
        if (typeof lucide !== 'undefined') {
            lucide.createIcons();
        }

        return button;
    },

    /**
     * Supprime le bouton de tour.
     */
    remove: function () {
        const button = document.getElementById('tourTriggerBtn');
        if (button) {
            button.remove();
        }
    },

    /**
     * Active/désactive le bouton.
     * @param {boolean} enabled - True pour activer.
     */
    setEnabled: function (enabled) {
        const button = document.getElementById('tourTriggerBtn');
        if (button) {
            button.disabled = !enabled;
        }
    },

    /**
     * Met à jour le tooltip du bouton.
     * @param {string} text - Nouveau texte du tooltip.
     */
    setTooltip: function (text) {
        const button = document.getElementById('tourTriggerBtn');
        if (button) {
            button.title = text;
            button.setAttribute('aria-label', text);
        }
    }
};

// ============================================
// NOTIFICATION VIEW
// ============================================

const ProductTourNotificationView = {
    /**
     * Affiche une notification de succès.
     * @param {string} message - Message à afficher.
     */
    showSuccess: function (message) {
        this._showNotification(message, 'success');
    },

    /**
     * Affiche une notification d'erreur.
     * @param {string} message - Message à afficher.
     */
    showError: function (message) {
        this._showNotification(message, 'error');
    },

    /**
     * Affiche une notification d'information.
     * @param {string} message - Message à afficher.
     */
    showInfo: function (message) {
        this._showNotification(message, 'info');
    },

    /**
     * Affiche une notification.
     * @private
     * @param {string} message - Message à afficher.
     * @param {string} type - Type de notification.
     */
    _showNotification: function (message, type = 'info') {
        // Utiliser le système de notification existant si disponible
        if (typeof showNotification === 'function') {
            showNotification(message, type);
            return;
        }

        // Fallback: console log
        console.log(`[${type.toUpperCase()}] ${message}`);
    }
};

// ============================================
// DRIVER VIEW HELPERS
// ============================================

const ProductTourDriverView = {
    /**
     * Prépare la vue pour un step spécifique.
     * @param {Object} step - Step à préparer.
     */
    prepareForStep: function (step) {
        // S'assurer que l'élément est visible
        if (step.element) {
            const element = document.querySelector(step.element);
            if (element) {
                this._ensureElementVisible(element);
            }
        }
    },

    /**
     * S'assure qu'un élément est visible dans le viewport.
     * @private
     * @param {HTMLElement} element - Élément à rendre visible.
     */
    _ensureElementVisible: function (element) {
        if (!element) return;

        // Vérifier si l'élément est dans le viewport
        const rect = element.getBoundingClientRect();
        const isVisible = (
            rect.top >= 0 &&
            rect.left >= 0 &&
            rect.bottom <= window.innerHeight &&
            rect.right <= window.innerWidth
        );

        // Scroller si nécessaire
        if (!isVisible) {
            element.scrollIntoView({
                behavior: 'smooth',
                block: 'center',
                inline: 'center'
            });
        }
    },

    /**
     * Nettoie les éléments de la vue après le tour.
     */
    cleanup: function () {
        console.log('🧹 Cleaning up tour elements...');
        
        // Supprimer les éléments temporaires
        const tempElements = document.querySelectorAll('[data-tour-temp]');
        tempElements.forEach(el => el.remove());
        
        // Supprimer tous les éléments Driver.js qui pourraient rester
        const driverElements = [
            '.driver-overlay',
            '.driver-popover',
            '#driver-popover-content',
            '.driver-active-element',
            '.driver-no-interaction',
            '#driver-dummy-element'
        ];
        
        driverElements.forEach(selector => {
            const elements = document.querySelectorAll(selector);
            elements.forEach(el => {
                console.log('Removing element:', selector);
                el.remove();
            });
        });
        
        // Retirer les classes Driver.js du body
        document.body.classList.remove('driver-active', 'driver-fade', 'driver-simple');
        
        // Retirer les attributs aria ajoutés par Driver.js
        document.querySelectorAll('[aria-haspopup="dialog"]').forEach(el => {
            el.removeAttribute('aria-haspopup');
            el.removeAttribute('aria-expanded');
            el.removeAttribute('aria-controls');
        });
        
        console.log('✅ Tour cleanup complete');
    }
};

    </script>

    </body>
</html>
