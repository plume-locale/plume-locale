<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Outil d'Écriture - Organisation par Chapitres</title>
    <link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:wght@300;400;600;700&family=Noto+Serif+JP:wght@300;500;700&family=Source+Code+Pro:wght@400;500&display=swap" rel="stylesheet">
    <!-- Export Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/docx/7.8.2/docx.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <!-- IndexedDB wrapper for easier usage -->
    <script src="https://cdn.jsdelivr.net/npm/idb@7/build/umd.js"></script>
    <!-- Lucide Icons - Modern line icons -->
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.min.js"></script>

    <style>
/* ========== 01.variables.css ========== */
        :root {
            /* Thème épuré blanc */
            --bg-primary: #ffffff;
            --bg-secondary: #f8f9fa;
            --bg-tertiary: #f0f1f3;
            --bg-accent: #2a2622;
            --text-primary: #1a1a1a;
            --text-secondary: #666666;
            --text-muted: #999999;
            --border-color: #e0e0e0;
            
            /* Couleur principale (orange) */
            --primary-color: #ff8c42;
            --primary-hover: #ff7629;
            
            /* Touches de couleur */
            --accent-red: #ff6b6b;
            --accent-gold: #ffd93d;
            --accent-blue: #4a9eff;
            --accent-green: #51cf66;
            --accent-purple: #a78bfa;
            --error-color: #dc2626;
            
            --shadow: rgba(0, 0, 0, 0.08);
            
            /* Revision colors */
            --highlight-yellow: rgba(255, 235, 59, 0.4);
            --highlight-green: rgba(76, 175, 80, 0.3);
            --highlight-blue: rgba(33, 150, 243, 0.3);
            --highlight-red: rgba(244, 67, 54, 0.3);
            --highlight-purple: rgba(156, 39, 176, 0.3);
        }


/* ========== 02.base.css ========== */
* {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: 'Crimson Pro', serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
        }

        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        
        .app-header {
            flex-shrink: 0;
            height: 60px;
        }
        
        .app-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        
        .sidebar {
            flex-shrink: 0;
            width: 350px;
        }
        
        .sidebar-versions {
            flex-shrink: 0;
            width: 280px;
        }
        
        .sidebar-versions.hidden {
            display: none;
        }
        
        .editor-container {
            flex: 1;
            overflow: auto;
            min-height: 0;
        }


/* ========== 03.header.css ========== */
/* Top Header */
        .app-header {
            background: var(--bg-primary);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            padding: 0 2rem;
            gap: 2rem;
            position: relative;
            z-index: 1000;
            box-shadow: 0 1px 3px var(--shadow);
            overflow: hidden;
        }
        
        .app-logo {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-size: 1.3rem;
            font-weight: 600;
            color: var(--accent-blue);
            font-family: 'Noto Serif JP', serif;
            white-space: nowrap;
            flex-shrink: 0;
        }
        
        .app-logo-icon {
            font-size: 1.5rem;
        }
        
        .header-nav {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex: 1;
            overflow-x: auto;
            overflow-y: hidden;
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE/Edge */
        }
        
        .header-nav::-webkit-scrollbar {
            display: none; /* Chrome/Safari */
        }
        
        .nav-group {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            padding-right: 1rem;
            border-right: 1px solid var(--border-color);
            flex-shrink: 0;
        }
        
        .nav-group:last-child {
            border-right: none;
        }
        
        .nav-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 0.25rem;
            padding: 0.5rem 0.5rem;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-family: 'Crimson Pro', serif;
            font-size: 0.7rem;
            border-radius: 8px;
            transition: all 0.2s ease;
            white-space: nowrap;
            flex-shrink: 0;
            min-width: 36px;
        }
        
        .nav-btn:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }
        
        .nav-btn.active {
            background: var(--primary-color);
            color: white;
            font-weight: 600;
        }
        
        .nav-btn-icon {
            font-size: 1.3rem;
            line-height: 1;
        }
        
        /* Lucide Icons Styling */
        .nav-btn-icon [data-lucide],
        .mobile-nav-item-icon [data-lucide],
        .header-action-btn [data-lucide],
        [data-lucide] {
            width: 18px;
            height: 18px;
            stroke-width: 1.75;
            vertical-align: middle;
        }
        
        .nav-btn-icon [data-lucide] {
            width: 20px;
            height: 20px;
        }
        
        .mobile-nav-item-icon [data-lucide] {
            width: 22px;
            height: 22px;
        }
        
        .header-action-btn [data-lucide] {
            width: 18px;
            height: 18px;
        }
        
        .app-logo-icon [data-lucide] {
            width: 24px;
            height: 24px;
            stroke: var(--primary-color);
        }
        
        .modal-title [data-lucide] {
            width: 22px;
            height: 22px;
            vertical-align: middle;
            margin-right: 8px;
        }
        
        .mobile-nav-section-title [data-lucide] {
            width: 16px;
            height: 16px;
            vertical-align: middle;
            margin-right: 6px;
        }
        
        .nav-btn-text {
            font-size: 0.7rem;
            line-height: 1;
        }
        
        .header-actions {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-left: auto;
            flex-shrink: 0;
        }
        
        .header-action-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 36px;
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            cursor: pointer;
            font-size: 1.1rem;
            border-radius: 4px;
            transition: all 0.2s ease;
        }
        
        .header-action-btn:hover:not(:disabled) {
            background: var(--accent-gold);
            color: white;
            border-color: var(--accent-gold);
        }
        
        .header-action-btn.active {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }
        
        .header-action-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }


/* ========== 04.sidebar.css ========== */
/* Sidebar Navigation */
        .sidebar {
            background: var(--bg-secondary);
            border-right: 2px solid var(--border-color);
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
        }
        
        /* Sidebar Versions (pour les versions de scènes) */
        .sidebar-versions {
            background: var(--bg-secondary);
            border-right: 2px solid var(--border-color);
            border-left: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-width: 250px;
            width: 280px;
        }
        
        .sidebar-versions.hidden {
            display: none;
            min-width: 0;
            width: 0;
        }
        
        .sidebar-versions-header {
            padding: 1rem;
            border-bottom: 1px solid var(--border-color);
            background: var(--bg-secondary);
            flex-shrink: 0;
        }
        
        .sidebar-versions-title {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.5rem;
        }
        
        .sidebar-versions-title h3 {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .sidebar-versions-toggle {
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            padding: 0.25rem;
            font-size: 1rem;
            transition: color 0.2s;
        }
        
        .sidebar-versions-toggle:hover {
            color: var(--text-primary);
        }
        
        .sidebar-versions-scene {
            font-size: 0.75rem;
            color: var(--text-muted);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .sidebar-versions-actions {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--border-color);
            background: var(--bg-primary);
            flex-shrink: 0;
        }
        
        .btn-new-version {
            width: 100%;
            padding: 0.6rem 1rem;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 6px;
            font-family: 'Crimson Pro', serif;
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        
        .btn-new-version:hover {
            background: var(--primary-hover);
            transform: translateY(-1px);
        }
        
        .sidebar-versions-list {
            flex: 1;
            overflow-y: auto;
            padding: 0.5rem;
        }
        
        .version-card {
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }
        
        .version-card:hover {
            border-color: var(--primary-color);
            background: rgba(255, 140, 66, 0.05);
        }
        
        .version-card.active {
            border-color: var(--primary-color);
            background: rgba(255, 140, 66, 0.1);
            box-shadow: 0 0 0 3px rgba(255, 140, 66, 0.15);
        }
        
        .version-card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.5rem;
        }
        
        .version-card-number {
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--primary-color);
        }
        
        .version-card-actions {
            display: flex;
            gap: 0.25rem;
            opacity: 1;
        }
        
        .version-card:hover .version-card-actions {
            opacity: 1;
        }
        
        .version-card-btn {
            background: var(--bg-tertiary);
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            padding: 0.35rem;
            font-size: 0.8rem;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        .version-card-btn:hover {
            background: var(--bg-primary);
            color: var(--text-primary);
        }
        
        .version-card-btn.delete:hover {
            background: rgba(255, 107, 107, 0.1);
            color: var(--accent-red);
        }
        
        .version-card-date {
            font-size: 0.75rem;
            color: var(--text-muted);
        }
        
        .version-card-stats {
            font-size: 0.7rem;
            color: var(--text-secondary);
            margin-top: 0.25rem;
        }
        
        .version-card-label {
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-top: 0.5rem;
            font-style: italic;
        }
        
        /* Version finale */
        .version-card.final {
            border-color: var(--accent-gold);
            background: rgba(255, 217, 61, 0.1);
        }
        
        .version-card.final .version-card-number::after {
            content: ' ⭐';
        }
        
        .version-card-final-badge {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            background: var(--accent-gold);
            color: var(--bg-accent);
            font-size: 0.65rem;
            font-weight: 700;
            padding: 0.15rem 0.5rem;
            border-radius: 10px;
            margin-left: 0.5rem;
            text-transform: uppercase;
        }
        
        .version-card-btn.final {
            color: var(--text-muted);
        }
        
        .version-card-btn.final:hover {
            background: rgba(255, 217, 61, 0.2);
            color: var(--accent-gold);
        }
        
        .version-card-btn.final.is-final {
            color: var(--accent-gold);
        }


/* ========== 05.modals.css ========== */
/* Diff Viewer Modal */
        .diff-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.6);
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 2rem;
        }
        
        .diff-modal-content {
            background: var(--bg-primary);
            border-radius: 12px;
            width: 100%;
            max-width: 1200px;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        
        .diff-modal-header {
            padding: 1.25rem 1.5rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-shrink: 0;
        }
        
        .diff-modal-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .diff-modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            color: var(--text-muted);
            cursor: pointer;
            padding: 0.25rem;
            line-height: 1;
            transition: color 0.2s;
        }
        
        .diff-modal-close:hover {
            color: var(--text-primary);
        }
        
        .diff-toolbar {
            padding: 0.75rem 1.5rem;
            border-bottom: 1px solid var(--border-color);
            background: var(--bg-secondary);
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 1rem;
            flex-shrink: 0;
        }
        
        .diff-stats {
            display: flex;
            gap: 1rem;
            font-size: 0.85rem;
        }
        
        .diff-stat {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }
        
        .diff-stat.added {
            color: #2e7d32;
        }
        
        .diff-stat.removed {
            color: #c62828;
        }
        
        .diff-stat.changed {
            color: #f57c00;
        }
        
        .diff-view-toggle {
            display: flex;
            gap: 0.25rem;
        }
        
        .diff-view-btn {
            padding: 0.4rem 0.8rem;
            border: 1px solid var(--border-color);
            background: var(--bg-primary);
            color: var(--text-secondary);
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .diff-view-btn:first-child {
            border-radius: 4px 0 0 4px;
        }
        
        .diff-view-btn:last-child {
            border-radius: 0 4px 4px 0;
        }
        
        .diff-view-btn.active {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }
        
        .diff-nav-buttons {
            display: flex;
            gap: 0.5rem;
        }
        
        .diff-nav-btn {
            padding: 0.4rem 0.8rem;
            border: 1px solid var(--border-color);
            background: var(--bg-primary);
            color: var(--text-secondary);
            font-size: 0.8rem;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        .diff-nav-btn:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        .diff-content {
            flex: 1;
            overflow: auto;
            padding: 1rem;
        }
        
        /* Vue unifiée */
        .diff-unified {
            font-family: 'Crimson Pro', serif;
            font-size: 1rem;
            line-height: 1.8;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        
        .diff-line {
            padding: 0.1rem 0.5rem;
            margin: 0 -0.5rem;
            border-radius: 3px;
        }
        
        .diff-line.added {
            background: rgba(46, 125, 50, 0.15);
        }
        
        .diff-line.removed {
            background: rgba(198, 40, 40, 0.15);
            text-decoration: line-through;
            opacity: 0.7;
        }
        
        .diff-word {
            padding: 0.1rem 0.2rem;
            border-radius: 2px;
        }
        
        .diff-word.added {
            background: rgba(46, 125, 50, 0.3);
            color: #1b5e20;
        }
        
        .diff-word.removed {
            background: rgba(198, 40, 40, 0.3);
            color: #b71c1c;
            text-decoration: line-through;
        }
        
        /* Vue côte à côte */
        .diff-side-by-side {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            height: 100%;
        }
        
        .diff-side {
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .diff-side-header {
            padding: 0.75rem 1rem;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            font-weight: 600;
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .diff-side-header.old {
            color: #c62828;
        }
        
        .diff-side-header.new {
            color: #2e7d32;
        }
        
        .diff-side-content {
            flex: 1;
            overflow: auto;
            padding: 1rem;
            font-family: 'Crimson Pro', serif;
            font-size: 1rem;
            line-height: 1.8;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        
        .diff-paragraph {
            margin-bottom: 1rem;
            padding: 0.5rem;
            border-radius: 4px;
            transition: background 0.2s;
        }
        
        .diff-paragraph.modified {
            background: rgba(255, 152, 0, 0.1);
            border-left: 3px solid #ff9800;
        }
        
        .diff-paragraph.added {
            background: rgba(46, 125, 50, 0.1);
            border-left: 3px solid #4caf50;
        }
        
        .diff-paragraph.removed {
            background: rgba(198, 40, 40, 0.1);
            border-left: 3px solid #f44336;
            text-decoration: line-through;
            opacity: 0.6;
        }
        
        .diff-highlight {
            cursor: pointer;
        }
        
        .diff-highlight:hover {
            filter: brightness(0.95);
        }
        
        .diff-empty-state {
            text-align: center;
            padding: 3rem;
            color: var(--text-muted);
        }
        
        .diff-empty-state-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }
        
        /* Version selector dans le diff */
        .diff-version-selector {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.85rem;
        }
        
        .diff-version-select {
            padding: 0.4rem 0.8rem;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background: var(--bg-primary);
            color: var(--text-primary);
            font-size: 0.85rem;
            cursor: pointer;
        }
        
        /* Bouton comparer dans version card */
        .version-card-btn.compare {
            color: #1976d2;
        }
        
        .version-card-btn.compare:hover {
            background: rgba(25, 118, 210, 0.1);
            color: #1565c0;
        }
        
        .versions-empty {
            text-align: center;
            padding: 2rem 1rem;
            color: var(--text-muted);
        }
        
        .versions-empty-icon {
            font-size: 2.5rem;
            margin-bottom: 0.75rem;
            opacity: 0.5;
        }
        
        .versions-empty-text {
            font-size: 0.85rem;
            line-height: 1.5;
        }
        
        .versions-no-scene {
            text-align: center;
            padding: 3rem 1rem;
            color: var(--text-muted);
        }
        
        .versions-no-scene-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
            opacity: 0.3;
        }
        
        .versions-no-scene-text {
            font-size: 0.9rem;
            line-height: 1.6;
        }
        
        /* Poignée de redimensionnement */
        .sidebar-resize-handle {
            position: absolute;
            top: 0;
            right: 0;
            width: 8px;
            height: 100%;
            cursor: ew-resize;
            z-index: 3000;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }
        
        .sidebar-resize-handle:hover {
            background: rgba(212, 175, 55, 0.1);
        }
        
        .sidebar-resize-handle:active {
            background: rgba(212, 175, 55, 0.2);
        }
        
        .resize-handle-line {
            width: 3px;
            height: 40px;
            background: var(--border-color);
            border-radius: 2px;
            transition: all 0.2s;
        }
        
        .sidebar-resize-handle:hover .resize-handle-line {
            background: var(--accent-gold);
            height: 60px;
        }


        .sidebar-header {
            padding: 1.5rem 1rem 1rem;
            border-bottom: 1px solid var(--border-color);
            position: relative;
            z-index: 2600;
            flex-shrink: 0;
        }

        .search-container {
            position: relative;
            margin-bottom: 1rem;
            z-index: 10;
        }

        .search-input {
            width: 100%;
            padding: 0.75rem 2.5rem 0.75rem 1rem;
            border: 1px solid var(--border-color);
            background: var(--bg-primary);
            font-family: 'Crimson Pro', serif;
            font-size: 0.9rem;
            color: var(--text-primary);
            border-radius: 2px;
            outline: none;
            transition: all 0.2s ease;
        }

        .search-input:focus {
            border-color: var(--accent-gold);
            box-shadow: 0 0 0 2px rgba(212, 175, 55, 0.1);
        }

        .search-icon {
            position: absolute;
            right: 0.75rem;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-muted);
            font-size: 1.2rem;
            pointer-events: none;
        }

        .search-results {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--bg-primary);
            border: 2px solid var(--accent-gold);
            border-radius: 4px;
            max-height: 400px;
            overflow-y: auto;
            z-index: 20;
            box-shadow: 0 4px 16px var(--shadow);
            margin-top: 0.5rem;
            display: none;
        }

        .search-results.active {
            display: block;
        }

        .search-result-item {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .search-result-item:last-child {
            border-bottom: none;
        }

        .search-result-item:hover {
            background: rgba(212, 175, 55, 0.1);
        }

        .search-result-type {
            font-size: 0.7rem;
            padding: 0.2rem 0.5rem;
            background: var(--accent-gold);
            color: var(--bg-primary);
            border-radius: 2px;
            margin-bottom: 0.5rem;
            display: inline-block;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            font-weight: 600;
        }

        .search-result-title {
            font-size: 0.9rem;
            font-weight: 600;
            margin-bottom: 0.25rem;
            color: var(--text-primary);
        }

        .search-result-path {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-bottom: 0.5rem;
        }

        .search-result-preview {
            font-size: 0.8rem;
            color: var(--text-secondary);
            line-height: 1.4;
        }

        .search-highlight {
            background: rgba(212, 175, 55, 0.3);
            font-weight: 600;
            padding: 0 2px;
        }

        .search-no-results {
            padding: 2rem;
            text-align: center;
            color: var(--text-muted);
            font-style: italic;
        }

        .view-tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .view-tab {
            flex: 1;
            padding: 0.5rem;
            border: 1px solid var(--border-color);
            background: var(--bg-primary);
            color: var(--text-secondary);
            cursor: pointer;
            font-family: 'Crimson Pro', serif;
            font-size: 0.85rem;
            font-weight: 500;
            transition: all 0.2s ease;
            border-radius: 2px;
            text-align: center;
        }

        .view-tab:hover {
            background: var(--bg-secondary);
        }

        .view-tab.active {
            background: var(--accent-gold);
            color: var(--bg-primary);
            border-color: var(--accent-gold);
        }

        .project-title {
            font-family: 'Noto Serif JP', serif;
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
            letter-spacing: 0.02em;
        }

        .project-stats {
            font-size: 0.85rem;
            color: var(--text-muted);
            font-weight: 300;
            display: flex;
            gap: 1rem;
        }

        .chapters-list {
            flex: 1;
            overflow-y: auto;
            padding: 1rem 0;
            position: relative;
            z-index: 1;
        }

        .database-list {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
            position: relative;
            z-index: 1;
        }
        
        /* Treeview compact style */
        .treeview-group {
            margin-bottom: 0.25rem;
        }
        
        .treeview-header {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.4rem 0.5rem;
            cursor: pointer;
            border-radius: 4px;
            transition: background 0.15s;
            user-select: none;
        }
        
        .treeview-header:hover {
            background: var(--bg-secondary);
        }
        
        .treeview-chevron {
            width: 14px;
            height: 14px;
            color: var(--text-muted);
            flex-shrink: 0;
        }
        
        .treeview-label {
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.03em;
            flex: 1;
        }
        
        .treeview-count {
            font-size: 0.7rem;
            color: var(--text-muted);
            background: var(--bg-secondary);
            padding: 0.1rem 0.4rem;
            border-radius: 10px;
        }
        
        .treeview-children {
            margin-left: 0.5rem;
            border-left: 1px solid var(--border-color);
            padding-left: 0.5rem;
            overflow: hidden;
            transition: max-height 0.2s ease, opacity 0.2s ease;
        }
        
        .treeview-children.collapsed {
            display: none;
        }
        
        .treeview-item {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            padding: 0.35rem 0.5rem;
            cursor: pointer;
            border-radius: 4px;
            transition: background 0.15s;
            position: relative;
        }
        
        .treeview-item:hover {
            background: var(--bg-secondary);
        }
        
        .treeview-item:hover .treeview-item-delete {
            opacity: 1;
        }
        
        .treeview-item-icon {
            font-size: 0.85rem;
            flex-shrink: 0;
            width: 18px;
            text-align: center;
        }
        
        .treeview-item-label {
            font-size: 0.85rem;
            color: var(--text-primary);
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .treeview-item-delete {
            opacity: 0;
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            padding: 0 0.25rem;
            font-size: 1rem;
            line-height: 1;
            transition: opacity 0.15s, color 0.15s;
        }
        
        .treeview-item-delete:hover {
            color: var(--accent-red);
        }
        
        .database-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 1rem;
            margin-bottom: 0.75rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .database-card:hover {
            border-color: var(--accent-gold);
            background: rgba(212, 175, 55, 0.05);
            transform: translateX(2px);
        }

        /* Acts Hierarchy */
        .act-group {
            margin-bottom: 0.25rem;
        }

        .act-header {
            padding: 0.3rem 0.5rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.3rem;
            transition: all 0.15s ease;
            position: relative;
            background: var(--bg-secondary);
            border-left: 3px solid var(--accent-red);
            border-radius: 0 4px 4px 0;
            font-weight: 600;
            font-size: 0.85rem;
        }

        .act-header:hover {
            background: var(--bg-tertiary);
        }

        .act-header.active {
            background: var(--accent-red);
            color: white;
        }

        .act-icon {
            font-size: 0.65rem;
            transition: transform 0.2s ease;
            color: var(--accent-red);
            width: 12px;
            text-align: center;
        }

        .act-header.active .act-icon {
            color: white;
        }

        .act-icon.expanded {
            transform: rotate(90deg);
        }

        .act-title {
            flex: 1;
            font-size: 0.8rem;
            font-family: 'Noto Serif JP', serif;
            letter-spacing: 0.01em;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .act-count {
            font-size: 0.65rem;
            opacity: 0.7;
            font-family: 'Source Code Pro', monospace;
        }

        .act-chapters {
            display: none;
            padding-left: 0.25rem;
        }

        .act-chapters.visible {
            display: block;
        }

        .chapter-group {
            margin-bottom: 0.1rem;
        }

        .chapter-header {
            padding: 0.25rem 0.5rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.3rem;
            transition: all 0.15s ease;
            position: relative;
            border-radius: 4px;
            font-size: 0.8rem;
        }

        .chapter-header:hover {
            background: var(--bg-secondary);
        }

        .chapter-header.active {
            background: var(--primary-color);
            color: white;
        }

        .chapter-icon {
            font-size: 0.6rem;
            transition: transform 0.2s ease;
            color: var(--text-muted);
            width: 10px;
            text-align: center;
        }

        .chapter-header.active .chapter-icon {
            color: white;
        }

        .chapter-icon.expanded {
            transform: rotate(90deg);
        }

        .chapter-title {
            flex: 1;
            font-size: 0.8rem;
            font-weight: 600;
            letter-spacing: 0.01em;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .chapter-count {
            font-size: 0.65rem;
            opacity: 0.7;
            font-family: 'Source Code Pro', monospace;
        }

        .scenes-list {
            display: none;
            padding-left: 0.75rem;
        }

        .scenes-list.visible {
            display: block;
        }

        .scene-item {
            padding: 0.2rem 0.5rem;
            cursor: pointer;
            font-size: 0.78rem;
            transition: all 0.15s ease;
            border-left: 2px solid transparent;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .scene-item:hover {
            background: var(--bg-secondary);
            border-left-color: var(--accent-red);
        }

        .scene-item.active {
            background: rgba(196, 69, 54, 0.1);
            border-left-color: var(--accent-red);
            color: var(--text-primary);
            font-weight: 500;
        }
        
        .scene-synopsis {
            display: none;
            font-size: 0.7rem;
            color: var(--text-muted);
            font-style: italic;
            line-height: 1.2;
            margin-top: 0.1rem;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            opacity: 0.8;
        }
        
        .scene-item:hover .scene-synopsis {
            display: block;
            opacity: 1;
        }
        
        /* Tree collapse toolbar */
        .tree-collapse-toolbar {
            display: flex;
            gap: 0.25rem;
            padding: 0.35rem 0.5rem;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
        }
        
        .tree-collapse-btn {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.2rem 0.5rem;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 3px;
            font-size: 0.7rem;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.15s ease;
        }
        
        .tree-collapse-btn:hover {
            background: var(--bg-tertiary);
            border-color: var(--primary-color);
            color: var(--primary-color);
        }

        .sidebar-actions {
            padding: 0.75rem 1rem;
            border-top: 1px solid var(--border-color);
            background: var(--bg-primary);
            display: flex;
            gap: 0.4rem;
            position: relative;
            z-index: 1;
            flex-shrink: 0;
        }
        
        .sidebar-actions .btn {
            flex: 1;
            padding: 0.5rem 0.25rem;
            font-size: 0.75rem;
            white-space: nowrap;
        }

        /* Scene Tools Bar */
        .scene-tools {
            display: flex;
            gap: 0.5rem;
            padding: 0.75rem 1rem;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
        }
        
        .scene-tool-btn {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            padding: 0.5rem 0.75rem;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-secondary);
            font-size: 0.8rem;
            font-family: 'Crimson Pro', serif;
            cursor: pointer;
            transition: all 0.2s ease;
            flex: 1;
            justify-content: center;
        }
        
        .scene-tool-btn:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        .scene-tool-btn.active {
            background: var(--primary-color);
            border-color: var(--primary-color);
            color: white;
        }
        
        .scene-tool-btn [data-lucide] {
            width: 16px;
            height: 16px;
        }
        
        .scene-tool-badge {
            background: var(--accent-red);
            color: white;
            font-size: 0.65rem;
            padding: 0.1rem 0.4rem;
            border-radius: 10px;
            font-weight: 600;
            margin-left: 0.25rem;
        }


/* ========== 06.editor.css ========== */
a/* Main Editor */
        .editor-container {
            display: flex;
            flex-direction: column;
            background: var(--bg-primary);
            height: calc(100vh - 60px);
            overflow-y: auto;
            overflow-x: hidden;
        }

        .editor-fixed-top {
            flex-shrink: 0;
            z-index: 100;
        }

        .editor-header {
            padding: 2rem 3rem 1rem;
            border-bottom: 1px solid var(--border-color);
            background: var(--bg-primary);
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }

        .editor-breadcrumb {
            font-size: 0.85rem;
            color: var(--text-muted);
            margin-bottom: 0.75rem;
            font-weight: 300;
        }

        .editor-title {
            font-family: 'Noto Serif JP', serif;
            font-size: 2rem;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
            letter-spacing: 0.01em;
        }

        .editor-meta {
            display: flex;
            gap: 2rem;
            font-size: 0.85rem;
            color: var(--text-muted);
            font-family: 'Source Code Pro', monospace;
        }
        
        .editor-synopsis {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-top: 0.75rem;
            padding-top: 0.75rem;
            border-top: 1px dashed var(--border-color);
        }
        
        .synopsis-label {
            display: flex;
            align-items: center;
            gap: 0.3rem;
            font-size: 0.8rem;
            color: var(--text-muted);
            white-space: nowrap;
        }
        
        .synopsis-input {
            flex: 1;
            min-width: 200px;
            padding: 0.4rem 0.6rem;
            font-size: 0.85rem;
            font-style: italic;
            color: var(--text-secondary);
            background: transparent;
            border: 1px solid transparent;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        .synopsis-input:hover {
            background: var(--bg-secondary);
            border-color: var(--border-color);
        }
        
        .synopsis-input:focus {
            outline: none;
            background: var(--bg-primary);
            border-color: var(--primary-color);
            font-style: normal;
        }
        
        .synopsis-input::placeholder {
            color: var(--text-muted);
            font-style: italic;
        }

        .editor-toolbar {
            display: flex;
            gap: 8px;
            padding: 8px 16px;
            border-bottom: 1px solid var(--border-color);
            background: var(--bg-primary);
            flex-wrap: wrap;
            align-items: center;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            overflow: visible;
        }

        .editor-toolbar::-webkit-scrollbar {
            display: none;
        }

        .links-panel-toggle {
            display: none;
            width: 100%;
            padding: 0.5rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 0.9rem;
            color: var(--text-primary);
            cursor: pointer;
            text-align: center;
            font-weight: 600;
        }

        .links-panel-toggle:active {
            background: var(--accent-gold);
            color: white;
        }

        .links-panel-sticky {
            padding: 1rem 3rem;
            background: var(--bg-primary);
            border-bottom: 1px solid var(--border-color);
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }

        .links-panel-sticky.hidden {
            display: none;
        }

        .editor-workspace {
            flex: 1 1 auto;
            overflow-y: scroll;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
        }

        .editor-content {
            max-width: none;
            margin: 0 auto;
            padding: 3rem;
        }

        .editor-textarea {
            width: 100%;
            min-height: 1200px;
            border: none;
            background: transparent;
            font-family: 'Crimson Pro', serif;
            font-size: 1.15rem;
            line-height: 1.8;
            color: var(--text-primary);
            outline: none;
            font-weight: 400;
        }

        .editor-textarea:focus {
            outline: none;
        }

        .editor-textarea::placeholder {
            color: var(--text-muted);
            font-style: italic;
        }

        /* Buttons */
        .btn {
            padding: 0.6rem 1.2rem;
            border: 1px solid var(--border-color);
            background: white;
            color: var(--text-primary);
            cursor: pointer;
            font-family: 'Crimson Pro', serif;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.2s ease;
            border-radius: 8px;
        }

        .btn:hover {
            background: var(--bg-secondary);
            border-color: var(--text-secondary);
        }

        .btn-primary {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
            border-radius: 8px;
            padding: 0.75rem 1.5rem;
            font-weight: 600;
        }

        .btn-primary:hover {
            background: var(--primary-hover);
            border-color: var(--primary-hover);
        }

        .btn-secondary {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            padding: 0.75rem 1.5rem;
            font-weight: 600;
            cursor: pointer;
            font-family: 'Crimson Pro', serif;
            font-size: 0.9rem;
            transition: all 0.2s ease;
        }

        .btn-secondary:hover {
            background: var(--bg-tertiary);
            border-color: var(--text-secondary);
        }

        .btn-small {
            padding: 0.4rem 0.8rem;
            font-size: 0.8rem;
        }

        .btn-icon {
            padding: 0.5rem;
            width: 32px;
            height: 32px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        /* Empty State */
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            text-align: center;
            padding: 3rem;
        }

        .empty-state-icon {
            font-size: 4rem;
            margin-bottom: 1.5rem;
            opacity: 0.3;
        }
        
        .empty-state-icon [data-lucide] {
            width: 64px;
            height: 64px;
            stroke-width: 1.5;
        }

        .empty-state-title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: var(--text-primary);
        }

        .empty-state-text {
            color: var(--text-muted);
            margin-bottom: 1.5rem;
            max-width: 400px;
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(42, 38, 34, 0.6);
            backdrop-filter: blur(4px);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: var(--bg-primary);
            padding: 2rem;
            border-radius: 4px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 8px 32px var(--shadow);
            border: 2px solid var(--border-color);
        }
        
        /* Modal overlay pour thèmes */
        .modal-overlay {
            display: flex;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(42, 38, 34, 0.85);
            backdrop-filter: blur(4px);
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 1rem;
            margin-bottom: 1.5rem;
            border-bottom: 2px solid var(--accent-gold);
        }
        
        .modal-header h2 {
            margin: 0;
            font-family: 'Noto Serif JP', serif;
        }
        
        .modal-close {
            background: transparent;
            border: none;
            font-size: 2rem;
            cursor: pointer;
            color: var(--text-muted);
            padding: 0.5rem;
            line-height: 1;
            transition: all 0.2s;
            border-radius: 4px;
            min-width: 44px;
            min-height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .modal-close:hover {
            color: var(--accent-red);
            background: rgba(196, 69, 54, 0.1);
        }

        .modal-close:active {
            transform: scale(0.95);
        }

        .modal-title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 1.5rem;
            font-family: 'Noto Serif JP', serif;
        }

		.modal-body {
            margin-bottom: 1.5rem;
        }

        .modal-footer {
            display: flex;
            gap: 0.75rem;
            justify-content: flex-end;
            align-items: center;
            padding-top: 1.5rem;
            margin-top: 1.5rem;
            border-top: 1px solid var(--border-color);
        }
        
        .form-group {
            margin-bottom: 1.5rem;
        }

        .form-label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: var(--text-secondary);
        }

        .form-input {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid var(--border-color);
            background: var(--bg-secondary);
            font-family: 'Crimson Pro', serif;
            font-size: 1rem;
            color: var(--text-primary);
            border-radius: 2px;
            outline: none;
            transition: all 0.2s ease;
        }

        .form-input:focus {
            border-color: var(--accent-gold);
            background: var(--bg-primary);
        }


/*//////////////////////////////////////////////////////////
//  Focus mode panel
///////////////////////////////////////////////////////////*/

        .focus-mode-panel {
            position: fixed;
            top: 0;
            right: 0;
            width: 350px;
            height: 100vh;
            background: var(--bg-primary);
            border-left: 2px solid var(--accent-gold);
            box-shadow: -8px 0 24px rgba(0, 0, 0, 0.3);
            transform: translateX(100%);
            transition: transform 0.3s ease;
            z-index: 2000;
            display: flex;
            flex-direction: column;
        }

        .focus-mode-panel.active {
            transform: translateX(0);
        }

        .app-container.focus-mode .focus-mode-panel {
            display: flex;
        }

        .focus-panel-header {
            padding: 1.5rem;
            border-bottom: 2px solid var(--border-color);
            background: var(--bg-accent);
            color: var(--bg-primary);
        }

        .focus-panel-title {
            font-size: 1.2rem;
            font-weight: 700;
            font-family: 'Noto Serif JP', serif;
        }

        .focus-panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 1.5rem;
        }

        .focus-section {
            margin-bottom: 2rem;
        }

        .focus-section-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .pomodoro-timer {
            text-align: center;
            padding: 2rem;
            background: var(--bg-primary);
            border-radius: 4px;
            border: 2px solid var(--border-color);
        }

        .pomodoro-display {
            font-size: 3rem;
            font-weight: 700;
            font-family: 'Source Code Pro', monospace;
            color: var(--text-primary);
            margin-bottom: 1rem;
        }

        .pomodoro-controls {
            display: flex;
            gap: 0.5rem;
            justify-content: center;
        }

        .ambient-music {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .focus-toggle-btn {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            z-index: 2001;
            background: var(--accent-gold);
            color: var(--bg-primary);
            border: none;
            padding: 0.75rem 1.25rem;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.9rem;
            transition: all 0.2s ease;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            display: none;
            font-family: 'Crimson Pro', serif;
        }

        .app-container.focus-mode .focus-toggle-btn {
            display: block !important;
        }

        .focus-toggle-btn:hover {
            background: var(--accent-red);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px var(--shadow);
        }

        .focus-stats {
            display: flex;
            gap: 1rem;
            margin-top: 1rem;
        }

        .focus-stat-box {
            flex: 1;
            padding: 0.75rem;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 2px;
            text-align: center;
        }

        .focus-stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--accent-gold);
            font-family: 'Source Code Pro', monospace;
        }

        .focus-stat-label {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-top: 0.25rem;
        }

        /* =========================================
   STYLES POUR LE PANNEAU DE LIENS (Auto-detect)
   ========================================= */

/* Conteneur de base pour un item (perso ou lieu) */
.link-item .quick-links {
    display: flex;
    justify-content: space-between;
    align-items: center;
    /*padding: 6px 8px;*/
    margin-bottom: 2px;
    border-radius: 6px;
    transition: all 0.2s ease;
    font-size: 0.9rem;
    border: 1px solid transparent;
}

/* --- ZONES D'ÉTAT --- */

/* 1. Présent (Validé) - Vert subtil */
.link-item.present {
    background-color: rgba(46, 204, 113, 0.1); /* Vert très clair */
    border-left: 3px solid #2ecc71;
}
.link-item.present:hover {
    background-color: rgba(46, 204, 113, 0.2);
}

/* 2. Suggéré (En attente) - Orange/Accent */
.link-item.suggested {
    background-color: rgba(255, 165, 0, 0.1); /* Orange très clair */
    border-left: 3px solid orange;
}
.link-item.suggested:hover {
    background-color: rgba(255, 165, 0, 0.2);
}

/* 3. Absent (Ignoré) - Grisé et discret */
.link-item.absent {
    background-color: rgba(255, 255, 255, 0.03);
    border: 1px solid var(--border-color, #ccc);
    opacity: 0.7;
    filter: grayscale(0.8);
}
.link-item.absent:hover {
    opacity: 1;
    filter: grayscale(0);
    background-color: rgba(255, 255, 255, 0.08);
}
.link-item.absent span {
    text-decoration: line-through;
    color: var(--text-muted, #888);
}

/* --- ÉLÉMENTS INTERNES --- */

/* Avatar et Nom */
.link-item > div:first-child {
    display: flex;
    align-items: center;
    gap: 8px;
    overflow: hidden; /* Pour les noms très longs */
}

.link-item span {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

/* --- BOUTONS D'ACTION (Icônes) --- */
.btn-icon {
    background: none;
    border: none;
    cursor: pointer;
    padding: 4px;
    border-radius: 4px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: transform 0.2s, background-color 0.2s, color 0.2s;
    color: var(--text-muted, #888);
}

.btn-icon:hover {
    background-color: rgba(0, 0, 0, 0.1); /* Ou blanc semi-transparent en thème sombre */
    transform: scale(1.1);
    color: var(--text-main, #000);
}

/* Couleurs spécifiques au survol des boutons */
.btn-icon[title*="Valider"]:hover {
    color: #2ecc71; /* Vert au survol */
    background-color: rgba(46, 204, 113, 0.15);
}

.btn-icon[title*="Retirer"]:hover,
.btn-icon[title*="Ignorer"]:hover {
    color: #e74c3c; /* Rouge au survol */
    background-color: rgba(231, 76, 60, 0.15);
}

.btn-icon[title*="Rétablir"]:hover {
    color: #3498db; /* Bleu au survol */
    background-color: rgba(52, 152, 219, 0.15);
}

/* AJOUT/MODIFICATION DANS VOTRE FICHIER CSS */

#linksPanel .quick-links h4 {
    /* Garantit que le texte est aligné à gauche */
    text-align: left; 
    /* S'assure qu'ils prennent toute la largeur pour être bien distincts */
    width: 100%; 
    /* S'assure qu'ils sont des blocs distincts, ce qui est le défaut de <h4> */
    display: block; 
}


/* ========== 07.characters.css ========== */
/* Detail View Styles (Characters, World, etc.) */


        /* En-tête de groupe dans la sidebar */
        .character-group-header {
            padding: 8px 15px;
            background-color: var(--bg-secondary); /* ou une couleur légèrement plus foncée */
            color: var(--text-muted);
            font-size: 0.85rem;
            font-weight: bold;
            text-transform: uppercase;
            border-bottom: 1px solid var(--border-color);
            border-top: 1px solid var(--border-color);
            margin-top: 10px;
            display: flex;
            justify-content: space-between;
        }

        .character-group-header:first-child {
            margin-top: 0;
            border-top: none;
        }

        .character-group-header .count {
            background: rgba(0,0,0,0.2);
            padding: 1px 6px;
            border-radius: 10px;
            font-size: 0.75rem;
        }

        .detail-view {
            padding: 2rem 3rem;
            max-width: 1400px;
            width: 100%;
            margin: 0 auto;
            height: 100vh;
            overflow-y: auto;
            box-sizing: border-box;
        }
        
        /* Character Sheet Styles */
        .character-sheet {
            padding: 1.5rem;
            height: 100%;
            overflow-y: auto;
        }
        
        /* Grille des sections - 2 colonnes sur desktop */
        .character-sections-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
        }
        
        /* Section qui prend toute la largeur */
        .character-section.full-width {
            grid-column: 1 / -1;
        }
        
        /* Responsive: 3 colonnes sur très grand écran */
        @media (min-width: 1600px) {
            .character-sections-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }
        
        /* Responsive: 4 colonnes sur écran ultra-large */
        @media (min-width: 2200px) {
            .character-sections-grid {
                grid-template-columns: repeat(4, 1fr);
            }
        }
        
        .character-sheet-header {
            display: flex;
            gap: 2rem;
            padding: 1.5rem;
            background: var(--bg-secondary);
            border-radius: 8px;
            margin-bottom: 1.5rem;
            border: 1px solid var(--border-color);
            position: relative;
        }
        
        .character-avatar {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--accent-red) 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5rem;
            color: white;
            flex-shrink: 0;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            border: 3px solid var(--bg-primary);
            box-shadow: 0 4px 12px var(--shadow);
        }
        
        .character-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .character-avatar:hover::after {
            content: '📷';
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
        }
        
        .character-header-info {
            flex: 1;
        }
        
        .character-header-info h2 {
            font-size: 1.6rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: var(--text-primary);
        }
        
        .character-header-info .character-meta {
            font-size: 0.9rem;
            color: var(--text-secondary);
            list-style: disc;
            margin-left: 1.2rem;
        }
        
        .character-header-actions {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 0.75rem;
        }
        
        .character-role-stars {
            display: flex;
            gap: 0.25rem;
        }
        
        .character-role-stars .star {
            font-size: 1.3rem;
            cursor: pointer;
            color: #ddd;
            transition: color 0.2s;
        }
        
        .character-role-stars .star.filled {
            color: var(--primary-color);
        }
        
        .character-role-stars .star:hover {
            color: var(--primary-hover);
        }
        
        .btn-write-beside {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 20px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .btn-write-beside:hover {
            border-color: var(--primary-color);
            color: var(--primary-color);
        }
        
        .character-close-btn {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--text-muted);
            line-height: 1;
        }
        
        .character-close-btn:hover {
            color: var(--accent-red);
        }
        
        .character-section {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow: hidden;
        }
        
        .character-section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1rem;
            background: var(--bg-secondary);
            cursor: pointer;
            user-select: none;
        }
        
        .character-section-header:hover {
            background: var(--bg-tertiary);
        }
        
        .character-section-title {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--accent-red);
        }
        
        .character-section-title::before {
            content: '';
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--primary-color);
        }
        
        .character-section-toggle {
            font-size: 0.9rem;
            color: var(--text-muted);
            transition: transform 0.2s;
        }
        
        .character-section.collapsed .character-section-toggle {
            transform: rotate(-90deg);
        }
        
        .character-section.collapsed .character-section-content {
            display: none;
        }
        
        .character-section-content {
            padding: 1rem;
        }
        
        .character-field-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 0.75rem;
            margin-bottom: 0.75rem;
        }
        
        .character-field-row:last-child {
            margin-bottom: 0;
        }
        
        .character-field {
            display: flex;
            flex-direction: column;
            gap: 0.3rem;
        }
        
        .character-field-label {
            font-size: 0.75rem;
            font-weight: 500;
            color: var(--accent-red);
            text-transform: capitalize;
        }
        
        .character-field input,
        .character-field textarea,
        .character-field select {
            padding: 0.5rem 0.6rem;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 0.9rem;
            font-family: inherit;
            background: var(--bg-primary);
            color: var(--text-primary);
            transition: border-color 0.2s;
        }
        
        .character-field input:focus,
        .character-field textarea:focus {
            outline: none;
            border-color: var(--primary-color);
        }
        
        .character-field textarea {
            resize: vertical;
            min-height: 60px;
        }
        
        .character-radio-group {
            display: flex;
            gap: 1rem;
            padding: 0.5rem 0;
        }
        
        /* Responsive: 1 colonne sur tablette/mobile */
        @media (max-width: 900px) {
            .character-sections-grid {
                grid-template-columns: 1fr;
            }
            
            .character-section.full-width {
                grid-column: 1;
            }
        }
        
        .character-radio-group label {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            cursor: pointer;
            font-size: 0.9rem;
        }
        
        .character-radio-group input[type="radio"] {
            accent-color: var(--primary-color);
        }
        
        /* Système de traits de caractère */
        .selected-traits-container {
            display: flex;
            flex-wrap: wrap;
            gap: 0.4rem;
            padding: 0.75rem;
            border: 2px solid var(--primary-color);
            border-radius: 8px;
            background: rgba(212, 175, 55, 0.05);
            min-height: 50px;
            align-items: flex-start;
        }
        
        .selected-trait {
            display: inline-flex;
            align-items: center;
            gap: 0.3rem;
            padding: 0.3rem 0.6rem;
            background: var(--primary-color);
            color: white;
            border-radius: 15px;
            font-size: 0.8rem;
            font-weight: 500;
        }
        
        .trait-remove {
            cursor: pointer;
            opacity: 0.7;
            font-size: 0.9rem;
            line-height: 1;
            margin-left: 0.2rem;
        }
        
        .trait-remove:hover {
            opacity: 1;
        }
        
        .no-traits {
            color: var(--text-muted);
            font-style: italic;
            font-size: 0.85rem;
        }
        
        .traits-categories {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-top: 1rem;
        }
        
        /* Sections principales de traits */
        .trait-section {
            border: 2px solid var(--border-color);
            border-radius: 8px;
            overflow: hidden;
            background: var(--bg-primary);
        }
        
        .trait-section-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.6rem 1rem;
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--accent-gold) 100%);
            cursor: pointer;
            user-select: none;
            font-size: 0.9rem;
            font-weight: 700;
            color: white;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .trait-section-header:hover {
            filter: brightness(1.1);
        }
        
        .trait-section-icon {
            font-size: 1.1rem;
            margin-right: 0.5rem;
        }
        
        .trait-section-toggle {
            font-size: 0.8rem;
            transition: transform 0.2s;
        }
        
        .trait-section.collapsed .trait-section-toggle {
            transform: rotate(-90deg);
        }
        
        .trait-section.collapsed .trait-section-content {
            display: none;
        }
        
        .trait-section-content {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
            gap: 0.5rem;
            padding: 0.75rem;
            background: var(--bg-secondary);
        }
        
        .trait-category {
            border: 1px solid var(--border-color);
            border-radius: 6px;
            overflow: hidden;
            background: var(--bg-primary);
        }
        
        .trait-category-header {
            display: flex;
            align-items: center;
            padding: 0.4rem 0.6rem;
            background: var(--bg-tertiary);
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .trait-category-icon {
            font-size: 0.9rem;
            margin-right: 0.3rem;
        }
        
        .trait-category-content {
            padding: 0.4rem;
            display: flex;
            flex-wrap: wrap;
            gap: 0.25rem;
        }
        
        .trait-option {
            padding: 0.2rem 0.45rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            font-size: 0.7rem;
            cursor: pointer;
            transition: all 0.15s;
            color: var(--text-secondary);
        }
        
        .trait-option:hover {
            background: var(--bg-tertiary);
            border-color: var(--primary-color);
            color: var(--text-primary);
        }
        
        .trait-option.selected {
            background: var(--primary-color);
            border-color: var(--primary-color);
            color: white;
        }
        
        /* Tags input */
        .character-tags-container {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            padding: 0.5rem;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            background: var(--bg-primary);
            min-height: 42px;
            align-items: center;
        }
        
        .character-tag {
            display: flex;
            align-items: center;
            gap: 0.3rem;
            padding: 0.25rem 0.6rem;
            background: var(--bg-tertiary);
            border-radius: 12px;
            font-size: 0.85rem;
        }
        
        .character-tag-remove {
            cursor: pointer;
            color: var(--text-muted);
            font-size: 0.9rem;
            line-height: 1;
        }
        
        .character-tag-remove:hover {
            color: var(--accent-red);
        }
        
        .character-tags-input {
            border: none !important;
            padding: 0.25rem !important;
            flex: 1;
            min-width: 120px;
            font-size: 0.9rem !important;
        }
        
        .character-tags-input:focus {
            outline: none;
        }
        
        /* Radar Chart */
        .character-radar-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 1rem;
        }
        
        .character-radar-canvas {
            max-width: 350px;
            max-height: 350px;
        }
        
        .character-radar-controls {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.75rem;
            width: 100%;
            max-width: 500px;
            margin-top: 1rem;
        }
        
        .radar-control {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .radar-control label {
            font-size: 0.85rem;
            min-width: 90px;
            color: var(--text-secondary);
        }
        
        .radar-control input[type="range"] {
            flex: 1;
            accent-color: var(--primary-color);
        }
        
        .radar-control .radar-value {
            font-size: 0.8rem;
            min-width: 24px;
            text-align: right;
            color: var(--text-muted);
        }
        
        /* Wealth slider */
        .wealth-slider-container {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .wealth-slider {
            flex: 1;
            height: 8px;
            -webkit-appearance: none;
            background: linear-gradient(to right, var(--bg-tertiary), var(--primary-color));
            border-radius: 4px;
            outline: none;
        }
        
        .wealth-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        }
        
        /* Timeline cards (Passé/Présent/Futur) */
        .character-timeline {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
        }
        
        .timeline-card {
            background: var(--bg-secondary);
            border-radius: 6px;
            padding: 1rem;
            border: 1px solid var(--border-color);
        }
        
        .timeline-card-title {
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--accent-red);
            margin-bottom: 0.5rem;
        }
        
        .timeline-card textarea {
            width: 100%;
            border: none;
            background: transparent;
            resize: none;
            font-family: inherit;
            font-size: 0.9rem;
            color: var(--text-secondary);
            min-height: 100px;
        }
        
        .timeline-card textarea:focus {
            outline: none;
        }
        
        /* Inventory items */
        .inventory-item {
            background: var(--bg-secondary);
            border-radius: 6px;
            padding: 1rem;
            margin-bottom: 0.75rem;
            border: 1px solid var(--border-color);
            position: relative;
        }
        
        .inventory-item-delete {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background: none;
            border: none;
            cursor: pointer;
            color: var(--text-muted);
            font-size: 1rem;
        }
        
        .inventory-item-delete:hover {
            color: var(--accent-red);
        }
        
        .inventory-add-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            padding: 0.75rem;
            border: 1px dashed var(--border-color);
            border-radius: 20px;
            background: transparent;
            cursor: pointer;
            color: var(--text-muted);
            font-size: 0.9rem;
            transition: all 0.2s;
            margin-top: 1rem;
        }
        
        .inventory-add-btn:hover {
            border-color: var(--primary-color);
            color: var(--primary-color);
        }
        
        /* Side-by-side mode */
        .editor-split-mode {
            display: flex;
            height: 100%;
        }
        
        .editor-split-mode .editor-main {
            flex: 1;
            overflow-y: auto;
            border-right: 1px solid var(--border-color);
        }
        
        .editor-split-mode .character-sheet-panel {
            width: 450px;
            overflow-y: auto;
            background: var(--bg-primary);
        }
        
        .character-sheet-panel .character-sheet {
            padding: 1rem;
        }
        
        .character-sheet-panel .character-sheet-header {
            flex-direction: column;
            align-items: center;
            text-align: center;
            gap: 1rem;
        }
        
        .character-sheet-panel .character-avatar {
            width: 80px;
            height: 80px;
            font-size: 2rem;
        }
        
        .character-sheet-panel .character-header-info h2 {
            font-size: 1.3rem;
        }
        
        /* ==========================================
           SPLIT VIEW SYSTEM
           ========================================== */
        
        .split-view-container {
            display: flex;
            height: 100%;
            width: 100%;
            position: relative;
        }
        
        .split-view-container.vertical {
            flex-direction: column;
        }
        
        .split-panel {
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-width: 250px;
            min-height: 200px;
        }
        
        .split-panel-left {
            flex: 6;
        }
        
        .split-panel-right {
            flex: 4;
        }
        
        .split-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0.75rem;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
            min-height: 40px;
        }
        
        .split-panel-title {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 0.5rem;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .split-panel-actions {
            display: flex;
            gap: 0.25rem;
            flex-shrink: 0;
        }
        
        .split-panel-btn {
            background: none;
            border: none;
            padding: 0.25rem 0.5rem;
            cursor: pointer;
            color: var(--text-muted);
            border-radius: 4px;
            font-size: 0.8rem;
            transition: all 0.2s;
        }
        
        .split-panel-btn:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        .split-panel-content {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
        }
        
        /* Active panel indicator */
        .split-panel.active {
            box-shadow: inset 0 0 0 2px var(--primary-color);
        }
        
        .split-panel.active .split-panel-header {
            background: var(--primary-color);
            color: white;
        }
        
        .split-panel.active .split-panel-header .split-panel-title {
            color: white;
        }
        
        .split-panel.active .split-panel-btn {
            color: rgba(255,255,255,0.8);
        }
        
        .split-panel.active .split-panel-btn:hover {
            background: rgba(255,255,255,0.2);
            color: white;
        }
        
        .split-panel-indicator {
            font-size: 8px;
            color: var(--text-muted);
            opacity: 0.3;
        }
        
        .split-panel-indicator.active {
            color: white;
            opacity: 1;
        }
        
        .split-panel-header {
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .split-panel-header:hover {
            background: var(--bg-tertiary);
        }
        
        .split-panel.active .split-panel-header:hover {
            background: var(--primary-color-dark, var(--primary-color));
            filter: brightness(0.9);
        }
        
        /* View option in selector */
        .split-view-option:hover {
            filter: brightness(1.1);
            transform: translateY(-1px);
        }
        
        /* Resizer */
        .split-resizer {
            flex-shrink: 0;
            background: var(--border-color);
            transition: background 0.2s;
            position: relative;
        }
        
        .split-resizer:hover,
        .split-resizer.dragging {
            background: var(--primary-color);
        }
        
        .split-resizer.horizontal {
            width: 5px;
            cursor: col-resize;
        }
        
        .split-resizer.vertical {
            height: 5px;
            cursor: row-resize;
        }
        
        .split-resizer::after {
            content: '';
            position: absolute;
            background: var(--text-muted);
            border-radius: 2px;
            opacity: 0.5;
        }
        
        .split-resizer.horizontal::after {
            width: 3px;
            height: 30px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        .split-resizer.vertical::after {
            width: 30px;
            height: 3px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        /* Split View Selector Dropdown */
        .split-selector {
            position: relative;
        }
        
        .split-selector-btn {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.4rem 0.75rem;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            color: var(--text-secondary);
            transition: all 0.2s;
        }
        
        .split-selector-btn:hover {
            border-color: var(--primary-color);
            color: var(--text-primary);
        }
        
        .split-selector-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            min-width: 200px;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            box-shadow: 0 4px 12px var(--shadow);
            z-index: 100;
            display: none;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .split-selector-dropdown.open {
            display: block;
        }
        
        .split-selector-group {
            padding: 0.5rem 0;
            border-bottom: 1px solid var(--border-color);
        }
        
        .split-selector-group:last-child {
            border-bottom: none;
        }
        
        .split-selector-group-title {
            padding: 0.25rem 0.75rem;
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            color: var(--text-muted);
            letter-spacing: 0.5px;
        }
        
        .split-selector-item {
            padding: 0.5rem 0.75rem;
            cursor: pointer;
            font-size: 0.85rem;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 0.5rem;
            transition: background 0.15s;
        }
        
        .split-selector-item:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }
        
        .split-selector-item.active {
            background: var(--bg-tertiary);
            color: var(--primary-color);
            font-weight: 500;
        }
        
        /* Split Mode Toggle Button in Header */
        .split-mode-toggle {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            padding: 0.4rem 0.75rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            color: var(--text-secondary);
            transition: all 0.2s;
        }
        
        .split-mode-toggle:hover {
            border-color: var(--primary-color);
            color: var(--primary-color);
        }
        
        .split-mode-toggle.active {
            background: var(--primary-color);
            border-color: var(--primary-color);
            color: white;
        }
        
        /* Responsive */
        @media (max-width: 900px) {
            .split-view-container {
                flex-direction: column !important;
            }
            
            .split-resizer.horizontal {
                width: 100%;
                height: 5px;
                cursor: row-resize;
            }
            
            .split-resizer.horizontal::after {
                width: 30px;
                height: 3px;
            }
            
            .split-panel {
                min-width: unset;
                min-height: 150px;
            }
            
            .split-panel-left,
            .split-panel-right {
                flex: 1;
            }
        }
        
        /* Character sheet adjustments in split view */
        .split-panel .character-sheet {
            padding: 1rem;
            height: auto;
        }
        
        .split-panel .character-sheet-header {
            padding: 1rem;
        }
        
        .split-panel .character-avatar {
            width: 80px;
            height: 80px;
            font-size: 2rem;
        }

        @media (max-width: 900px) {
            .character-sheet {
                padding: 1rem;
            }
            
            .character-sheet-header {
                flex-direction: column;
                align-items: center;
                text-align: center;
            }
            
            .character-header-actions {
                align-items: center;
            }
            
            .character-field-row {
                grid-template-columns: 1fr;
            }
            
            .character-timeline {
                grid-template-columns: 1fr;
            }
            
            .character-radar-controls {
                grid-template-columns: 1fr;
            }
        }
        
        .detail-header {
            padding: 1.5rem;
            background: var(--bg-secondary);
            border-radius: 4px;
            margin-bottom: 2rem;
            border-left: 4px solid var(--accent-red);
        }
        
        .detail-title {
            font-size: 1.8rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--text-primary);
            font-family: 'Noto Serif JP', serif;
        }
        
        .detail-section {
            background: var(--bg-secondary);
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            border-radius: 4px;
            border: 1px solid var(--border-color);
        }
        
        .detail-section-title {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--text-primary);
            padding-bottom: 0.75rem;
            border-bottom: 2px solid var(--border-color);
        }
        
        .detail-field {
            margin-bottom: 1.25rem;
        }
        
        .detail-field:last-child {
            margin-bottom: 0;
        }
        
        .detail-label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: var(--text-secondary);
            font-size: 0.95rem;
        }

        .modal-actions {
            display: flex;
            gap: 0.75rem;
            justify-content: flex-end;
        }

        .modal-button-group {
            display: flex;
            gap: 0.75rem;
            flex-wrap: wrap;
        }

        .modal-button-group .btn {
            flex: 1;
            min-width: 180px;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 12px;
            height: 12px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 6px;
            border: 2px solid var(--bg-secondary);
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }

        /* Better scrollbar for editor workspace */
        .editor-workspace::-webkit-scrollbar-thumb {
            background: var(--accent-gold);
            border: 2px solid var(--bg-primary);
        }

        .editor-workspace::-webkit-scrollbar-thumb:hover {
            background: var(--accent-red);
        }

        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .chapter-group {
            animation: fadeIn 0.3s ease forwards;
        }

        /* ==========================================
           AMÉLIORATIONS VISUELLES - OPT 1
           ========================================== */
        
        /* Badge de statut amélioré */
        .status-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            margin-left: 0.4rem;
            flex-shrink: 0;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            font-size: 10px;
            cursor: pointer;
            position: relative;
        }
        
        .status-badge:hover {
            transform: scale(1.2);
            box-shadow: 0 0 0 3px rgba(0,0,0,0.1);
        }
        
        .status-draft { 
            background: #ff6b6b; 
        }
        .status-draft::after { content: ""; }
        
        .status-progress { 
            background: #ffd93d; 
        }
        .status-progress::after { content: ""; }
        
        .status-complete { 
            background: #51cf66; 
        }
        .status-complete::after { content: "✓"; color: white; font-weight: bold; }
        
        .status-review { 
            background: #4a9eff; 
        }
        .status-review::after { content: ""; }
        
        /* Menu contextuel de statut */
        .status-menu {
            position: fixed;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 10000;
            min-width: 140px;
            padding: 0.5rem 0;
            display: none;
        }
        
        .status-menu.visible {
            display: block;
        }
        
        .status-menu-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            cursor: pointer;
            font-size: 0.85rem;
            color: var(--text-primary);
            transition: background 0.2s;
        }
        
        .status-menu-item:hover {
            background: var(--bg-secondary);
        }
        
        .status-menu-item.active {
            background: var(--bg-tertiary);
            font-weight: 600;
        }
        
        .status-menu-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            flex-shrink: 0;
        }
        
        .status-menu-dot.draft { background: #ff6b6b; }
        .status-menu-dot.progress { background: #ffd93d; }
        .status-menu-dot.complete { background: #51cf66; }
        .status-menu-dot.review { background: #4a9eff; }
        
        /* Barre de progression globale */
        .project-progress-bar {
            padding: 0.75rem 1rem;
            background: var(--bg-primary);
            border-bottom: 1px solid var(--border-color);
        }
        
        .progress-stats {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
            font-size: 0.75rem;
            color: var(--text-secondary);
        }
        
        .progress-track {
            height: 6px;
            background: var(--bg-tertiary);
            border-radius: 3px;
            overflow: hidden;
            display: flex;
        }
        
        .progress-segment {
            height: 100%;
            transition: width 0.3s ease;
        }
        
        .progress-segment.complete { background: #51cf66; }
        .progress-segment.review { background: #4a9eff; }
        .progress-segment.progress { background: #ffd93d; }
        .progress-segment.draft { background: #ff6b6b; }
        
        /* Filtres de statut */
        .status-filters {
            display: flex;
            gap: 0.25rem;
            padding: 0.5rem 1rem;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            flex-wrap: wrap;
        }
        
        .status-filter-btn {
            display: flex;
            align-items: center;
            gap: 0.3rem;
            padding: 0.3rem 0.6rem;
            border: 1px solid var(--border-color);
            border-radius: 12px;
            background: var(--bg-primary);
            font-size: 0.7rem;
            cursor: pointer;
            transition: all 0.2s;
            color: var(--text-secondary);
        }
        
        .status-filter-btn:hover {
            border-color: var(--text-muted);
        }
        
        .status-filter-btn.active {
            border-color: currentColor;
            font-weight: 600;
        }
        
        .status-filter-btn.draft.active { 
            background: rgba(255, 107, 107, 0.15); 
            color: #e55a5a;
            border-color: #ff6b6b;
        }
        .status-filter-btn.progress.active { 
            background: rgba(255, 217, 61, 0.15); 
            color: #c9a82e;
            border-color: #ffd93d;
        }
        .status-filter-btn.complete.active { 
            background: rgba(81, 207, 102, 0.15); 
            color: #3db854;
            border-color: #51cf66;
        }
        .status-filter-btn.review.active { 
            background: rgba(74, 158, 255, 0.15); 
            color: #3a8ae6;
            border-color: #4a9eff;
        }
        
        .status-filter-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }
        
        .status-filter-dot.draft { background: #ff6b6b; }
        .status-filter-dot.progress { background: #ffd93d; }
        .status-filter-dot.complete { background: #51cf66; }
        .status-filter-dot.review { background: #4a9eff; }
        
        .status-filter-count {
            font-weight: 600;
        }
        
        /* Scènes filtrées (cachées) */
        .scene-item.filtered-out {
            display: none !important;
        }
        
        .chapter-group.filtered-out {
            display: none !important;
        }
        
        .act-group.filtered-out {
            display: none !important;
        }
        
        /* Compteur de mots */
        .word-count-badge {
            font-size: 0.6rem;
            color: var(--text-muted);
            font-family: 'Courier New', monospace;
            padding: 0.05rem 0.25rem;
            background: var(--bg-tertiary);
            border-radius: 2px;
            white-space: nowrap;
            font-weight: 600;
        }
        
        /* Numérotation automatique */
        .auto-number {
            font-size: 0.65rem;
            color: var(--text-muted);
            font-family: 'Courier New', monospace;
            font-weight: 700;
            min-width: 28px;
            text-align: right;
            margin-right: 0.2rem;
            flex-shrink: 0;
        }

        .delete-btn {
            opacity: 0;
            margin-left: auto;
            transition: opacity 0.2s ease;
            padding: 0 0.2rem !important;
            min-width: auto !important;
            width: 18px !important;
            height: 18px !important;
            font-size: 0.8rem !important;
        }

        .act-header:hover .delete-btn,
        .chapter-header:hover .delete-btn,
        .scene-item:hover .delete-btn {
            opacity: 1;
        }

        .scene-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        /* Drag and Drop */
        .draggable {
            cursor: move;
        }

        .draggable:active {
            cursor: grabbing;
        }

        .drag-over {
            background: rgba(212, 175, 55, 0.2);
            border-left: 3px solid var(--accent-gold);
        }

        .dragging {
            opacity: 0.5;
            background: var(--bg-accent);
            color: var(--bg-primary);
        }

        .drag-handle {
            cursor: grab;
            padding: 0 0.2rem;
            color: var(--text-muted);
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.7rem;
        }

        .chapter-header:hover .drag-handle,
        .scene-item:hover .drag-handle,
        .act-header:hover .drag-handle {
            opacity: 1;
        }

        .drag-handle:active {
            cursor: grabbing;
        }

        /* Inline Editing */
        .editing-input {
            background: var(--bg-primary);
            border: 2px solid var(--accent-gold);
            padding: 0.15rem 0.3rem;
            font-family: 'Crimson Pro', serif;
            font-size: inherit;
            font-weight: inherit;
            color: var(--text-primary);
            border-radius: 2px;
            outline: none;
            width: 100%;
        }

        .chapter-title,
        .scene-item > div > span:not(.drag-handle) {
            cursor: text;
        }

        .chapter-title:hover,
        .scene-item > div > span:not(.drag-handle):hover {
            background: rgba(212, 175, 55, 0.1);
            padding: 0.15rem 0.3rem;
            margin: -0.15rem -0.3rem;
            border-radius: 2px;
        }

        .edit-hint {
            font-size: 0.6rem;
            color: var(--text-muted);
            opacity: 0;
            transition: opacity 0.2s ease;
            font-style: italic;
            margin-left: 0.25rem;
        }

        .chapter-header:hover .edit-hint,
        .scene-item:hover .edit-hint {
            opacity: 1;
        }

        /* Rich Text Editor Toolbar - defined above in main structure */

        .toolbar-group {
            display: flex;
            gap: 4px;
            padding-right: 12px;
            border-right: 1px solid var(--border-color);
            flex-shrink: 0;
        }

        .toolbar-group:last-child {
            border-right: none;
        }

        .toolbar-btn {
            padding: 0;
            min-width: 36px;
            height: 36px;
            border: none;
            background: transparent;
            color: var(--text-primary);
            cursor: pointer;
            font-family: 'Crimson Pro', serif;
            font-size: 16px;
            font-weight: 400;
            transition: all 0.15s ease;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .toolbar-btn:hover {
            background: var(--bg-secondary);
        }

        .toolbar-btn.active {
            background: var(--primary-color);
            color: white;
        }

        .toolbar-btn[data-format="bold"] {
            font-weight: 700;
        }

        .toolbar-btn[data-format="italic"] {
            font-style: italic;
        }

        .toolbar-btn[data-format="underline"] {
            text-decoration: underline;
        }

        /* Bouton annotations avec badge */
        .annotations-toolbar-btn {
            position: relative;
        }
        
        .annotations-toolbar-btn.has-annotations::after {
            content: attr(data-count);
            position: absolute;
            top: 2px;
            right: 2px;
            background: var(--accent-red);
            color: white;
            font-size: 10px;
            font-weight: 600;
            min-width: 14px;
            height: 14px;
            border-radius: 7px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 3px;
        }
        
        .annotations-toolbar-btn.panel-open {
            background: var(--primary-color);
            color: white;
        }

        /* Select dans le toolbar */
        select.toolbar-btn {
            min-width: 100px;
            padding: 0 32px 0 12px;
            font-size: 14px;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg width='10' height='6' viewBox='0 0 10 6' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 1L5 5L9 1' stroke='%23666' stroke-width='1.5' stroke-linecap='round'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 10px center;
            background-color: transparent;
        }

        select.toolbar-btn:hover {
            background-color: var(--bg-secondary);
            background-image: url("data:image/svg+xml,%3Csvg width='10' height='6' viewBox='0 0 10 6' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 1L5 5L9 1' stroke='%23666' stroke-width='1.5' stroke-linecap='round'/%3E%3C/svg%3E");
        }

        /* Color Picker Dropdown */
        .color-picker-wrapper {
            position: relative;
            display: inline-block;
        }

        .color-picker-dropdown {
            position: fixed;
            background: var(--bg-primary);
            border: 2px solid var(--border-color);
            border-radius: 4px;
            padding: 0.75rem;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 99999;
            display: none;
            min-width: 200px;
        }

        .color-picker-dropdown.active {
            display: block;
        }

        .color-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 0.25rem;
            margin-bottom: 0.5rem;
        }

        .color-swatch {
            width: 24px;
            height: 24px;
            border: 2px solid var(--border-color);
            border-radius: 2px;
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .color-swatch:hover {
            transform: scale(1.1);
            border-color: var(--accent-gold);
        }

        .color-input-wrapper {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-top: 0.5rem;
            padding-top: 0.5rem;
            border-top: 1px solid var(--border-color);
        }

        .color-input-wrapper input[type="color"] {
            width: 40px;
            height: 30px;
            border: 1px solid var(--border-color);
            border-radius: 2px;
            cursor: pointer;
        }

        .color-input-wrapper input[type="text"] {
            flex: 1;
            padding: 0.3rem 0.5rem;
            border: 1px solid var(--border-color);
            border-radius: 2px;
            font-family: 'Source Code Pro', monospace;
            font-size: 0.85rem;
        }

        /* Font Size Selector */
        .font-size-selector {
            padding: 0.5rem;
            border: 1px solid var(--border-color);
            background: var(--bg-primary);
            color: var(--text-primary);
            cursor: pointer;
            font-family: 'Crimson Pro', serif;
            font-size: 0.9rem;
            border-radius: 2px;
            min-width: 70px;
        }

        .font-size-selector:hover {
            background: var(--accent-gold);
            color: var(--bg-primary);
            border-color: var(--accent-gold);
        }

        /* Font Family Selector */
        .font-family-selector {
            padding: 0.5rem;
            border: 1px solid var(--border-color);
            background: var(--bg-primary);
            color: var(--text-primary);
            cursor: pointer;
            font-size: 0.9rem;
            border-radius: 2px;
            min-width: 150px;
        }

        .font-family-selector:hover {
            background: var(--accent-gold);
            color: var(--bg-primary);
            border-color: var(--accent-gold);
        }

        /* Toolbar separator */
        .toolbar-separator {
            width: 1px;
            height: 30px;
            background: var(--border-color);
            margin: 0 0.25rem;
        }

        /* Rich Text Editor Content */
        .editor-textarea[contenteditable="true"] {
            outline: none;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .editor-textarea[contenteditable="true"]:empty:before {
            content: attr(data-placeholder);
            color: var(--text-muted);
            font-style: italic;
            pointer-events: none;
        }

        .editor-textarea strong,
        .editor-textarea b {
            font-weight: 700;
        }

        .editor-textarea em,
        .editor-textarea i {
            font-style: italic;
        }

        .editor-textarea u {
            text-decoration: underline;
        }

        .editor-textarea h1 {
            font-size: 2em;
            font-weight: 700;
            margin: 1em 0 0.5em;
            font-family: 'Noto Serif JP', serif;
        }

        .editor-textarea h2 {
            font-size: 1.5em;
            font-weight: 600;
            margin: 1em 0 0.5em;
            font-family: 'Noto Serif JP', serif;
        }

        .editor-textarea h3 {
            font-size: 1.25em;
            font-weight: 600;
            margin: 1em 0 0.5em;
        }

        .editor-textarea blockquote {
            border-left: 4px solid var(--accent-gold);
            padding-left: 1.5rem;
            margin: 1.5rem 0;
            font-style: italic;
            color: var(--text-secondary);
        }

        .editor-textarea ul,
        .editor-textarea ol {
            margin: 1rem 0;
            padding-left: 2rem;
        }

        .editor-textarea li {
            margin: 0.5rem 0;
        }

        .editor-textarea hr {
            border: none;
            border-top: 2px solid var(--border-color);
            margin: 2rem 0;
        }

        /* Text alignment */
        .editor-textarea [style*="text-align: left"] {
            text-align: left;
        }

        .editor-textarea [style*="text-align: center"] {
            text-align: center;
        }

        .editor-textarea [style*="text-align: right"] {
            text-align: right;
        }

        .editor-textarea [style*="text-align: justify"] {
            text-align: justify;
        }

        /* Strikethrough */
        .editor-textarea s,
        .editor-textarea strike {
            text-decoration: line-through;
        }

        /* Superscript and subscript */
        .editor-textarea sup {
            vertical-align: super;
            font-size: 0.75em;
        }

        .editor-textarea sub {
            vertical-align: sub;
            font-size: 0.75em;
        }

        /* Timeline Styles */
        .timeline-container {
            position: relative;
            padding: 1rem 0 1rem 2.5rem;
        }

        .timeline-line {
            position: absolute;
            left: 0.75rem;
            top: 0;
            bottom: 0;
            width: 2px;
            background: var(--border-color);
        }

        .timeline-event {
            position: relative;
            margin-bottom: 1.5rem;
            padding: 0.75rem;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .timeline-event::before {
            content: '';
            position: absolute;
            left: -2rem;
            top: 1rem;
            width: 10px;
            height: 10px;
            background: var(--accent-red);
            border: 2px solid var(--bg-primary);
            border-radius: 50%;
            z-index: 2;
        }

        .timeline-event:hover {
            border-color: var(--accent-gold);
            box-shadow: 0 2px 8px var(--shadow);
        }

        .timeline-event.active {
            border-color: var(--accent-red);
            background: var(--bg-secondary);
        }

        .timeline-date {
            font-size: 0.75rem;
            color: var(--accent-gold);
            font-weight: 600;
            margin-bottom: 0.4rem;
            font-family: 'Source Code Pro', monospace;
        }

        .timeline-title {
            font-size: 0.95rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.4rem;
        }

        .timeline-meta {
            display: flex;
            gap: 0.75rem;
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-bottom: 0.4rem;
            flex-wrap: wrap;
        }

        .timeline-meta-item {
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .timeline-description {
            font-size: 0.85rem;
            color: var(--text-secondary);
            line-height: 1.4;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        /* Notes Styles */
        .note-card {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 1rem;
            margin-bottom: 1rem;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .note-card:hover {
            border-color: var(--accent-gold);
            box-shadow: 0 2px 8px var(--shadow);
        }

        .note-card.active {
            border-color: var(--accent-red);
            background: var(--bg-secondary);
        }

        .note-category-badge {
            display: inline-block;
            font-size: 0.7rem;
            padding: 0.25rem 0.5rem;
            background: var(--accent-gold);
            color: var(--bg-primary);
            border-radius: 2px;
            margin-bottom: 0.5rem;
            font-family: 'Source Code Pro', monospace;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .note-title {
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
        }

        .note-preview {
            font-size: 0.85rem;
            color: var(--text-secondary);
            line-height: 1.4;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
            overflow: hidden;
            margin-bottom: 0.5rem;
        }

        .note-tags {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .note-tag {
            font-size: 0.7rem;
            padding: 0.2rem 0.5rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 2px;
            color: var(--text-muted);
        }

        .note-date {
            font-size: 0.7rem;
            color: var(--text-muted);
            margin-top: 0.5rem;
            font-family: 'Source Code Pro', monospace;
        }

        /* Note Medias */
        .note-medias-container {
            margin-top: 0.5rem;
        }

        .note-medias-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 1rem;
        }

        .note-media-item {
            position: relative;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow: hidden;
            background: var(--bg-secondary);
            transition: all 0.2s;
        }

        .note-media-item:hover {
            border-color: var(--primary-color);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .note-media-image {
            cursor: pointer;
        }

        .note-media-image img {
            width: 100%;
            height: 150px;
            object-fit: cover;
            display: block;
        }

        .note-media-overlay {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.5rem;
            background: var(--bg-primary);
            border-top: 1px solid var(--border-color);
        }

        .note-media-title {
            font-size: 0.8rem;
            font-weight: 500;
            color: var(--text-primary);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            flex: 1;
        }

        .note-media-delete {
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 1.2rem;
            cursor: pointer;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .note-media-delete:hover {
            background: var(--accent-red);
            color: white;
        }

        .note-media-url {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 1rem;
            cursor: pointer;
        }

        .note-media-url-icon {
            font-size: 1.5rem;
            flex-shrink: 0;
        }

        .note-media-url-info {
            flex: 1;
            min-width: 0;
        }

        .note-media-domain {
            display: block;
            font-size: 0.7rem;
            color: var(--text-muted);
            margin-top: 0.2rem;
        }

        .note-media-audio {
            display: flex;
            align-items: flex-start;
            gap: 0.75rem;
            padding: 1rem;
        }

        .note-media-audio-icon {
            font-size: 1.5rem;
            flex-shrink: 0;
        }

        .note-media-audio-info {
            flex: 1;
            min-width: 0;
        }

        .note-media-youtube {
            cursor: pointer;
        }

        .note-media-youtube-thumb {
            position: relative;
            width: 100%;
            height: 120px;
            overflow: hidden;
        }

        .note-media-youtube-thumb img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .note-media-youtube-play {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 50px;
            height: 50px;
            background: rgba(255, 0, 0, 0.9);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 1.2rem;
            transition: transform 0.2s;
        }

        .note-media-youtube:hover .note-media-youtube-play {
            transform: translate(-50%, -50%) scale(1.1);
        }

        /* Treeview media icon */
        .treeview-media-icon {
            font-size: 0.75rem;
            margin-left: 0.25rem;
        }

        /* Statistics Styles */
        .stat-box {
            background: var(--bg-primary);
            border: 2px solid var(--border-color);
            border-radius: 4px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
        }

        .stat-title {
            font-size: 0.85rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.5rem;
            font-weight: 500;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: 700;
            color: var(--text-primary);
            font-family: 'Noto Serif JP', serif;
        }

        .stat-label {
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-top: 0.25rem;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: var(--bg-secondary);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 0.5rem;
        }

        .progress-fill {
            height: 100%;
            background: var(--accent-gold);
            transition: width 0.3s ease;
        }

        .goal-input {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        /* Codex Styles */
        .codex-card {
            background: var(--bg-primary);
            border-left: 4px solid var(--accent-gold);
            border-right: 1px solid var(--border-color);
            border-top: 1px solid var(--border-color);
            border-bottom: 1px solid var(--border-color);
            border-radius: 0 4px 4px 0;
            padding: 1rem;
            margin-bottom: 1rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .codex-card:hover {
            border-left-color: var(--accent-red);
            box-shadow: 0 2px 8px var(--shadow);
        }

        /* Version Styles */
        .version-card {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 1rem;
            margin-bottom: 1rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .version-card:hover {
            border-color: var(--accent-gold);
            box-shadow: 0 2px 8px var(--shadow);
        }

        .version-timestamp {
            font-size: 0.85rem;
            color: var(--accent-gold);
            font-weight: 600;
            margin-bottom: 0.5rem;
            font-family: 'Source Code Pro', monospace;
        }

        .version-label {
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
        }

        .version-stats {
            font-size: 0.8rem;
            color: var(--text-muted);
        }

        /* References and Links Styles */
        .references-section {
            margin-bottom: 1.5rem;
        }

        .references-title {
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .reference-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.5rem 0.75rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 2px;
            margin-bottom: 0.5rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .reference-item:hover {
            background: rgba(212, 175, 55, 0.1);
            border-color: var(--accent-gold);
        }

        .reference-link {
            display: inline-block;
            padding: 0.25rem 0.5rem;
            background: var(--accent-gold);
            color: var(--bg-primary);
            border-radius: 2px;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s ease;
            text-decoration: none;
            margin: 0.25rem;
        }

        .reference-link:hover {
            background: var(--accent-red);
        }

        .tag-selector {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .tag-option {
            padding: 0.4rem 0.8rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 2px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s ease;
        }

        .tag-option:hover {
            border-color: var(--accent-gold);
        }

        .tag-option.selected {
            background: var(--accent-gold);
            color: var(--bg-primary);
            border-color: var(--accent-gold);
        }

        .link-badge {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.25rem 0.5rem;
            background: rgba(212, 175, 55, 0.2);
            border: 1px solid var(--accent-gold);
            border-radius: 2px;
            font-size: 0.75rem;
            color: var(--text-primary);
            margin: 0.25rem 0.25rem 0.25rem 0;
            cursor: pointer;
        }

        .link-badge:hover {
            background: rgba(212, 175, 55, 0.3);
        }

        .link-badge-remove {
            cursor: pointer;
            color: var(--accent-red);
            font-weight: bold;
            margin-left: 0.25rem;
        }

        .link-badge-remove:hover {
            color: #8b2a1f;
        }

        .quick-links {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-top: 0.5rem;
        }

        /* Projects Management Styles */
        .project-card {
            background: var(--bg-primary);
            border: 2px solid var(--border-color);
            border-radius: 4px;
            padding: 1.5rem;
            margin-bottom: 1rem;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .project-card:hover {
            border-color: var(--accent-gold);
            box-shadow: 0 2px 8px var(--shadow);
        }

        .project-card.active {
            border-color: var(--accent-red);
            background: var(--bg-secondary);
        }

        .project-card-header {
            display: flex;
            justify-content: space-between;
            align-items: start;
            margin-bottom: 0.75rem;
        }

        .project-card-title {
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--text-primary);
            font-family: 'Noto Serif JP', serif;
        }

        .project-card-genre {
            font-size: 0.75rem;
            padding: 0.25rem 0.5rem;
            background: var(--accent-gold);
            color: var(--bg-primary);
            border-radius: 2px;
            font-weight: 600;
        }

        .project-card-desc {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 0.75rem;
            line-height: 1.4;
        }

        .project-card-stats {
            display: flex;
            gap: 1.5rem;
            font-size: 0.85rem;
            color: var(--text-muted);
            font-family: 'Source Code Pro', monospace;
        }

        .project-card-actions {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        /* Focus Mode Styles */
        .app-container.focus-mode {
            display: flex !important;
            flex-direction: column !important;
        }
        
        .app-container.focus-mode .app-content {
            display: flex !important;
            flex: 1 !important;
            overflow: hidden !important;
        }
        
        .app-container.focus-mode .sidebar {
            display: none !important;
            width: 0 !important;
        }
        
        .app-container.focus-mode .sidebar-versions {
            display: none !important;
            width: 0 !important;
        }
        
        .app-container.focus-mode .app-header {
            display: none !important;
        }
        
        .app-container.focus-mode .annotations-panel {
            display: none !important;
        }

        .app-container.focus-mode .editor-container {
            background: var(--bg-primary);
            height: 100vh !important;
            width: 100% !important;
            flex: 1 !important;
        }

        /* Header de l'éditeur toujours visible en mode focus */
        .app-container.focus-mode .editor-header {
            opacity: 1;
        }

        /* Toolbar toujours visible en mode focus (garde son style normal) */
        .app-container.focus-mode .editor-toolbar {
            opacity: 1;
        }
        
        /* Bouton Paramètres Focus - styles quand visible */
        .focus-settings-btn {
            background: var(--accent-gold) !important;
            color: var(--bg-accent) !important;
            border-color: var(--accent-gold) !important;
        }
        
        .focus-settings-btn:hover {
            background: var(--accent-red) !important;
            border-color: var(--accent-red) !important;
            color: white !important;
        }
        
        /* Barre de progression d'écriture */
        .writing-progress-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 28px;
            background: rgba(0,0,0,0.85);
            z-index: 9999;
            display: none;
            flex-direction: column;
            /* Ne participe pas au grid */
        }
        
        .app-container.focus-mode .writing-progress-bar {
            display: flex;
        }
        
        .writing-progress-fill {
            height: 3px;
            background: linear-gradient(90deg, var(--accent-gold), var(--accent-red));
            transition: width 0.3s ease;
            width: 0%;
        }
        
        .writing-progress-text {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            color: rgba(255,255,255,0.8);
            font-size: 0.7rem;
            font-family: 'Courier New', monospace;
            padding: 0.2rem;
        }
        
        /* Indicateur de position discret - DÉSACTIVÉ, intégré dans la barre */
        .position-indicator {
            display: none !important;
        }

        .focus-mode-panel {
            position: fixed;
            top: 0;
            right: 0;
            width: 350px;
            height: 100vh;
            background: var(--bg-primary);
            border-left: 2px solid var(--accent-gold);
            box-shadow: -8px 0 24px rgba(0, 0, 0, 0.3);
            transform: translateX(100%);
            transition: transform 0.3s ease;
            z-index: 2000;
            display: flex;
            flex-direction: column;
        }

        .focus-mode-panel.active {
            transform: translateX(0);
        }

        .app-container.focus-mode .focus-mode-panel {
            display: flex;
        }

        .focus-panel-header {
            padding: 1.5rem;
            border-bottom: 2px solid var(--border-color);
            background: var(--bg-accent);
            color: var(--bg-primary);
        }

        .focus-panel-title {
            font-size: 1.2rem;
            font-weight: 700;
            font-family: 'Noto Serif JP', serif;
        }

        .focus-panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 1.5rem;
        }

        .focus-section {
            margin-bottom: 2rem;
        }

        .focus-section-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .pomodoro-timer {
            text-align: center;
            padding: 2rem;
            background: var(--bg-primary);
            border-radius: 4px;
            border: 2px solid var(--border-color);
        }

        .pomodoro-display {
            font-size: 3rem;
            font-weight: 700;
            font-family: 'Source Code Pro', monospace;
            color: var(--text-primary);
            margin-bottom: 1rem;
        }

        .pomodoro-controls {
            display: flex;
            gap: 0.5rem;
            justify-content: center;
        }

        /* Pomodoro Popup dans le header */
        .pomodoro-popup {
            position: fixed;
            top: 60px;
            right: 100px;
            background: var(--bg-primary);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.15);
            z-index: 10000;
            display: none;
            min-width: 200px;
        }
        
        .pomodoro-popup.active {
            display: block;
        }
        
        .pomodoro-popup-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1rem;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            font-weight: 600;
            border-radius: 6px 6px 0 0;
        }
        
        .pomodoro-popup-close {
            cursor: pointer;
            font-size: 1.2rem;
            color: var(--text-muted);
            transition: color 0.2s;
        }
        
        .pomodoro-popup-close:hover {
            color: var(--accent-red);
        }
        
        .pomodoro-popup-content {
            padding: 1.5rem;
            text-align: center;
        }
        
        .pomodoro-popup .pomodoro-display {
            font-size: 2.5rem;
            margin-bottom: 1rem;
        }
        
        .pomodoro-popup .pomodoro-controls {
            margin-bottom: 1rem;
        }
        
        .pomodoro-stats {
            display: flex;
            justify-content: center;
            gap: 1rem;
        }
        
        .pomodoro-stat {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .pomodoro-stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--primary-color);
        }
        
        .pomodoro-stat-label {
            font-size: 0.75rem;
            color: var(--text-muted);
            text-transform: uppercase;
        }
        
        /* Indicateur visuel quand le timer tourne */
        .header-action-btn.pomodoro-active {
            color: var(--accent-red);
            animation: pomodoro-pulse 1s ease-in-out infinite;
        }
        
        @keyframes pomodoro-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .ambient-music {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .focus-stats {
            display: flex;
            gap: 1rem;
            margin-top: 1rem;
        }

        .focus-stat-box {
            flex: 1;
            padding: 0.75rem;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 2px;
            text-align: center;
        }

        .focus-stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--accent-gold);
            font-family: 'Source Code Pro', monospace;
        }

        .focus-stat-label {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-top: 0.25rem;
        }

        /* REVISION MODE STYLES */
        .highlight-yellow { background: var(--highlight-yellow); }
        .highlight-green { background: var(--highlight-green); }
        .highlight-blue { background: var(--highlight-blue); }
        .highlight-red { background: var(--highlight-red); }
        .highlight-purple { background: var(--highlight-purple); }

        .revision-toolbar {
            display: flex;
            gap: 0.5rem;
            padding: 1rem 3rem;
            border-bottom: 2px solid var(--accent-red);
            background: var(--bg-secondary);
            flex-wrap: wrap;
            align-items: center;
        }

        .revision-badge {
            padding: 0.5rem 1rem;
            background: var(--accent-red);
            color: var(--bg-primary);
            border-radius: 4px;
            font-weight: 600;
            margin-right: 1rem;
        }

        .highlight-btn {
            padding: 0.5rem 0.75rem;
            border: 1px solid var(--border-color);
            background: var(--bg-primary);
            cursor: pointer;
            font-size: 0.85rem;
            border-radius: 2px;
            transition: all 0.2s;
        }

        .highlight-btn.active {
            border-width: 2px;
            font-weight: 600;
        }

        .highlight-btn.yellow { background: var(--highlight-yellow); }
        .highlight-btn.green { background: var(--highlight-green); }
        .highlight-btn.blue { background: var(--highlight-blue); }
        .highlight-btn.red { background: var(--highlight-red); }
        .highlight-btn.purple { background: var(--highlight-purple); }

        .annotations-panel {
            position: fixed;
            right: -350px;
            top: 350px;
            width: 320px;
            height: calc(100vh - 350px);
            background: var(--bg-secondary);
            border-left: 2px solid var(--border-color);
            padding: 0;
            overflow: hidden;
            transition: right 0.3s;
            box-shadow: -4px 0 12px rgba(0,0,0,0.1);
            z-index: 50;
            display: flex;
            flex-direction: column;
        }

        .annotations-panel.visible {
            right: 0;
        }
        
        .annotations-panel-spacer {
            display: none; /* Plus besoin du spacer */
        }
        
        .annotations-panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
        }
        
        .annotations-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid var(--border-color);
        }
        
        .annotations-panel-close {
            cursor: pointer;
            font-size: 1.5rem;
            color: var(--text-muted);
            transition: color 0.2s;
            padding: 0.5rem;
            line-height: 1;
        }
        
        .annotations-panel-close:hover {
            color: var(--accent-red);
        }

        .annotation-card {
            background: var(--bg-primary);
            border-left: 4px solid var(--accent-gold);
            padding: 1rem;
            margin-bottom: 1rem;
            border-radius: 0 4px 4px 0;
            cursor: pointer;
        }

        .annotation-card:hover {
            transform: translateX(-4px);
        }

        .annotation-card.todo { border-left-color: var(--accent-red); }
        .annotation-card.note { border-left-color: #4CAF50; }
        .annotation-card.question { border-left-color: #2196F3; }

        .annotation-type {
            font-size: 0.7rem;
            padding: 0.25rem 0.5rem;
            border-radius: 2px;
            text-transform: uppercase;
            font-weight: 600;
            display: inline-block;
            margin-bottom: 0.5rem;
        }

        .annotation-type.comment { background: var(--accent-gold); color: white; }
        .annotation-type.todo { background: var(--accent-red); color: white; }
        .annotation-type.note { background: #4CAF50; color: white; }
        .annotation-type.question { background: #2196F3; color: white; }

        .annotation-content {
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
        }

        .annotation-context {
            font-size: 0.75rem;
            color: var(--text-muted);
            font-style: italic;
            padding: 0.5rem;
            background: var(--bg-secondary);
            border-radius: 2px;
            margin-bottom: 0.5rem;
        }

        /* Marqueurs d'annotation dans le texte */
        .annotation-marker {
            padding: 2px 0;
            border-radius: 2px;
            transition: background 0.3s ease, box-shadow 0.3s ease;
            position: relative;
        }

        .annotation-marker:hover {
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .annotation-marker.comment {
            background: rgba(255, 235, 59, 0.3);
            border-bottom: 2px solid #FBC02D;
        }

        .annotation-marker.question {
            background: rgba(33, 150, 243, 0.3);
            border-bottom: 2px solid #1976D2;
        }

        .annotation-marker.todo {
            background: rgba(244, 67, 54, 0.3);
            border-bottom: 2px solid #D32F2F;
        }

        .annotation-marker.note {
            background: rgba(76, 175, 80, 0.3);
            border-bottom: 2px solid #4CAF50;
        }

        .annotation-popup {
            position: fixed;
            background: var(--bg-primary);
            border: 2px solid var(--accent-gold);
            border-radius: 4px;
            padding: 1.5rem;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            z-index: 10000;
            min-width: 350px;
            display: none;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
        }

        .annotation-popup.visible {
            display: block;
        }

        .annotation-type-selector {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .annotation-type-btn {
            flex: 1;
            padding: 0.5rem;
            border: 1px solid var(--border-color);
            background: var(--bg-secondary);
            cursor: pointer;
            font-size: 0.75rem;
            border-radius: 2px;
        }

        .annotation-type-btn.active {
            border-width: 2px;
            font-weight: 600;
        }

        .annotation-type-btn.comment.active { border-color: var(--accent-gold); }
        .annotation-type-btn.todo.active { border-color: var(--accent-red); }
        .annotation-type-btn.note.active { border-color: #4CAF50; }
        .annotation-type-btn.question.active { border-color: #2196F3; }

        .annotation-popup textarea {
            width: 100%;
            min-height: 100px;
            padding: 0.75rem;
            border: 1px solid var(--border-color);
            border-radius: 2px;
            font-family: inherit;
            font-size: 0.95rem;
            margin-bottom: 1rem;
        }

        .todo-item {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            padding: 0.75rem;
            margin-bottom: 0.75rem;
            border-radius: 4px;
            display: flex;
            gap: 0.75rem;
            cursor: pointer;
        }

        .todo-item:hover {
            border-color: var(--accent-gold);
        }

        .todo-checkbox {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .todo-text {
            flex: 1;
        }

        .todo-text.done {
            text-decoration: line-through;
            color: var(--text-muted);
        }

        .scene-badge {
            font-size: 0.7rem;
            padding: 0.2rem 0.4rem;
            background: var(--accent-red);
            color: white;
            border-radius: 2px;
            margin-left: 0.5rem;
        }


/* ========== 08.visualizations.css ========== */
/* ============================================ */
        /* CORK BOARD STYLES */
        /* ============================================ */
        
        .cork-board-container {
            padding: 2rem;
            background: var(--bg-tertiary);
            background-image: 
                radial-gradient(circle at 20% 30%, rgba(0,0,0,0.03) 1px, transparent 1px),
                radial-gradient(circle at 70% 60%, rgba(0,0,0,0.03) 1px, transparent 1px),
                radial-gradient(circle at 40% 80%, rgba(0,0,0,0.03) 1px, transparent 1px);
            background-size: 100px 100px, 150px 150px, 120px 120px;
            min-height: calc(100vh - 200px);
            overflow-y: auto;
        }
        
        .cork-board-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            padding: 1rem 2rem;
            background: var(--bg-primary);
            border-radius: 8px;
            box-shadow: 0 2px 8px var(--shadow);
        }
        
        .cork-board-title {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--text-primary);
        }
        
        .cork-board-filters {
            display: flex;
            gap: 1rem;
            align-items: center;
        }
        
        .cork-board-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 2rem;
            padding: 1rem;
        }
        
        .cork-card {
            background: var(--bg-primary);
            padding: 1.5rem;
            border-radius: 4px;
            box-shadow: 
                0 2px 4px var(--shadow),
                0 4px 8px var(--shadow);
            cursor: move;
            transition: all 0.3s ease;
            position: relative;
            min-height: 200px;
            border: 1px solid var(--border-color);
        }
        
        .cork-card::before {
            content: '📌';
            position: absolute;
            top: -10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.5rem;
            filter: drop-shadow(0 2px 2px var(--shadow));
        }
        
        .cork-card:hover {
            transform: translateY(-5px) rotate(1deg);
            box-shadow: 
                0 4px 8px var(--shadow),
                0 8px 16px var(--shadow);
        }
        
        .cork-card.dragging {
            opacity: 0.5;
            transform: rotate(5deg);
        }
        
        .cork-card-header {
            display: flex;
            justify-content: space-between;
            align-items: start;
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 2px dashed var(--border-color);
        }
        
        .cork-card-number {
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--text-muted);
            font-family: 'Source Code Pro', monospace;
        }
        
        .cork-card-color-tag {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 2px solid rgba(0,0,0,0.2);
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        .cork-card-color-tag:hover {
            transform: scale(1.2);
        }
        
        .cork-card-title {
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 1rem;
            line-height: 1.3;
        }
        
        .cork-card-synopsis {
            font-size: 0.9rem;
            color: var(--text-secondary);
            line-height: 1.6;
            margin-bottom: 1rem;
            min-height: 60px;
        }
        
        .cork-card-meta {
            display: flex;
            gap: 1rem;
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-top: auto;
        }
        
        .cork-card-actions {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
            padding-top: 0.75rem;
            border-top: 1px dashed var(--border-color);
        }
        
        .cork-color-palette {
            position: absolute;
            top: 100%;
            right: 0;
            background: white;
            border: 2px solid var(--border-color);
            border-radius: 4px;
            padding: 0.5rem;
            display: none;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        
        .cork-color-palette.visible {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 0.5rem;
        }
        
        .cork-color-option {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 2px solid rgba(0,0,0,0.2);
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        .cork-color-option:hover {
            transform: scale(1.2);
        }
        
        /* Couleurs prédéfinies pour POV/Intrigues */
        .cork-color-yellow { background: #ffd93d; }
        .cork-color-pink { background: #ff6b9d; }
        .cork-color-blue { background: #6bcfff; }
        .cork-color-green { background: #6bff9d; }
        .cork-color-purple { background: #c26bff; }
        .cork-color-orange { background: #ffb56b; }
        .cork-color-red { background: #ff6b6b; }
        .cork-color-teal { background: #6bffd9; }
        .cork-color-default { background: #fef9e7; }
        
        .cork-board-empty {
            text-align: center;
            padding: 4rem;
            color: var(--text-muted);
        }
        
        .cork-board-empty-icon {
            font-size: 4rem;
            margin-bottom: 1rem;
            opacity: 0.5;
        }
        
        .cork-filter-btn {
            padding: 0.5rem 1rem;
            border: 2px solid var(--border-color);
            background: var(--bg-primary);
            color: var(--text-primary);
            cursor: pointer;
            font-size: 0.85rem;
            border-radius: 4px;
            transition: all 0.2s;
            font-weight: 500;
        }
        
        .cork-filter-btn:hover {
            background: var(--accent-gold);
            color: white;
            border-color: var(--accent-gold);
        }
        
        .cork-filter-btn.active {
            background: var(--accent-red);
            color: white;
            border-color: var(--accent-red);
        }

        /* ============================================
           STRUCTURED VIEW (Style plume_locale)
           ============================================ */
        
        .structured-act-container {
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 1rem;
            border: 1px solid var(--border-color);
        }
        
        .structured-act-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
        }
        
        .structured-collapse-btn {
            background: transparent;
            border: none;
            color: var(--text-primary);
            cursor: pointer;
            font-size: 0.9rem;
            padding: 0.25rem;
        }
        
        .structured-collapse-btn:hover {
            color: var(--primary-color);
        }
        
        .structured-act-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .structured-count {
            color: var(--text-secondary);
            font-size: 0.9rem;
            margin-left: auto;
        }
        
        .structured-chapters-grid {
            display: grid;
            /* On remplace 300px par la variable, avec une valeur par défaut de 300px */
            grid-template-columns: repeat(auto-fill, minmax(var(--chapter-card-width, 300px), 1fr));
            gap: 1rem;
            transition: all 0.3s ease; /* Ajoute une fluidité lors du redimensionnement */
        }
        
        .structured-chapter-container {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 1rem;
        }
        
        .structured-chapter-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid var(--border-color);
        }
        
        .structured-chapter-icon {
            color: var(--text-muted);
            font-size: 1rem;
        }
        
        .structured-chapter-title {
            color: var(--text-primary);
            font-weight: 500;
            font-size: 0.95rem;
        }
        
        .structured-menu-btn {
            background: transparent;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            padding: 0.25rem 0.5rem;
            font-size: 1.2rem;
        }
        
        .structured-menu-btn:hover {
            color: var(--accent-gold);
        }
        
        .structured-scenes-list {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        
        .structured-scene-card {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 0.75rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .structured-scene-card:hover {
            border-color: var(--accent-gold);
            transform: translateX(2px);
        }
        
        .structured-scene-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }
        
        .structured-scene-icon {
            color: var(--text-muted);
            font-size: 0.9rem;
        }
        
        .structured-scene-title {
            color: var(--text-primary);
            font-size: 0.9rem;
            font-weight: 500;
        }
        
        .structured-scene-menu {
            background: transparent;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            padding: 0.25rem;
            margin-left: auto;
        }
        
        .structured-scene-menu:hover {
            color: var(--accent-gold);
        }
        
        .structured-scene-synopsis {
            color: var(--text-secondary);
            font-size: 0.85rem;
            line-height: 1.4;
            margin-bottom: 0.5rem;
            min-height: 2.5rem;
        }
        
        .structured-scene-synopsis:empty:before {
            content: attr(data-placeholder);
            color: var(--text-muted);
        }
        
        .structured-scene-synopsis:focus {
            outline: none;
            color: var(--text-primary);
        }
        
        .structured-scene-label {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            font-size: 0.8rem;
            color: var(--text-muted);
            cursor: pointer;
        }
        
        .structured-scene-label:hover {
            color: var(--accent-gold);
        }
        
        .label-icon {
            font-size: 0.9rem;
        }
        
        .structured-add-scene-btn {
            background: transparent;
            border: 1px dashed var(--border-color);
            border-radius: 4px;
            padding: 0.75rem;
            color: var(--text-muted);
            cursor: pointer;
            font-size: 0.85rem;
            width: 100%;
            transition: all 0.2s ease;
        }
        
        .structured-add-scene-btn:hover {
            border-color: var(--accent-gold);
            color: var(--accent-gold);
            background: rgba(212, 175, 55, 0.05);
        }
        
        .structured-bottom-actions {
            display: flex;
            gap: 0.75rem;
            margin-top: 2rem;
            padding-top: 2rem;
            border-top: 1px solid var(--border-color);
        }
        
        /* Couleurs pour les cartes de scène */
        .structured-color-yellow { border-left: 3px solid #f4c430; }
        .structured-color-pink { border-left: 3px solid #ff69b4; }
        .structured-color-blue { border-left: 3px solid #4a9eff; }
        .structured-color-green { border-left: 3px solid #4caf50; }
        .structured-color-purple { border-left: 3px solid #9b59b6; }
        .structured-color-orange { border-left: 3px solid #ff8c42; }
        .structured-color-red { border-left: 3px solid #e74c3c; }
        .structured-color-teal { border-left: 3px solid #1abc9c; }
        .structured-color-default { border-left: 3px solid #3a3a3a; }

        @keyframes slideIn {
            from { transform: translateX(400px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        @keyframes slideOut {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(400px); opacity: 0; }
        }

        /* ============================================
           STYLES POUR LES NOUVELLES VISUALISATIONS
           ============================================ */

        /* Canvas pour les visualisations */
        .visualization-canvas {
            width: 100%;
            height: 600px;
            background: white;
            border: 2px solid var(--border-color);
            border-radius: 4px;
            position: relative;
            overflow: hidden;
        }

        /* Mindmap Styles */
        /* Mindmap Styles */
        .mindmap-wrapper {
            display: flex;
            height: 100%;
            width: 100%;
            overflow: hidden;
        }

        .mindmap-sidebar {
            width: 250px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        .mindmap-sidebar-header {
            padding: 1rem;
            border-bottom: 1px solid var(--border-color);
            background: var(--bg-primary);
        }

        .mindmap-list {
            flex: 1;
            overflow-y: auto;
        }

        .mindmap-item {
            padding: 0.75rem 1rem;
            cursor: pointer;
            border-bottom: 1px solid var(--border-color);
            transition: background 0.2s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .mindmap-item:hover {
            background: rgba(212, 175, 55, 0.1);
        }

        .mindmap-item.active {
            background: rgba(212, 175, 55, 0.2);
            border-left: 3px solid var(--accent-gold);
        }

        .mindmap-main {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .mindmap-toolbar {
            padding: 0.75rem 1rem;
            background: var(--bg-primary);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            gap: 0.5rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .mindmap-canvas-wrapper {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: 
                linear-gradient(90deg, rgba(212, 175, 55, 0.05) 1px, transparent 1px),
                linear-gradient(rgba(212, 175, 55, 0.05) 1px, transparent 1px);
            background-size: 20px 20px;
        }

        .mindmap-canvas {
            width: 100%;
            height: 100%;
            position: relative;
            transform-origin: 0 0;
            cursor: grab;
        }

        .mindmap-canvas.panning {
            cursor: grabbing;
        }

        .mindmap-canvas.linking {
            cursor: crosshair;
        }

        .mindmap-node {
            position: absolute;
            padding: 1rem;
            background: var(--bg-primary);
            border: 2px solid var(--accent-gold);
            border-radius: 8px;
            cursor: move;
            box-shadow: 0 2px 8px var(--shadow);
            min-width: 120px;
            max-width: 200px;
            user-select: none;
            transition: box-shadow 0.2s ease;
        }

        .mindmap-node:hover {
            box-shadow: 0 4px 16px rgba(212, 175, 55, 0.3);
            z-index: 10;
        }

        .mindmap-node.selected {
            border-color: var(--accent-red);
            box-shadow: 0 0 0 3px rgba(196, 69, 54, 0.2);
        }

        .mindmap-node.dragging {
            opacity: 0.7;
            cursor: grabbing;
        }

        .mindmap-node-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
            font-weight: 600;
        }

        .mindmap-node-icon {
            font-size: 1.2rem;
        }

        .mindmap-node-title {
            flex: 1;
            font-size: 0.9rem;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .mindmap-node-delete {
            opacity: 0;
            cursor: pointer;
            color: var(--accent-red);
            font-size: 1.2rem;
            line-height: 1;
            transition: opacity 0.2s ease;
        }

        .mindmap-node:hover .mindmap-node-delete {
            opacity: 1;
        }

        .mindmap-node-link-btn {
            opacity: 0;
            cursor: pointer;
            color: var(--accent-gold);
            font-size: 1rem;
            line-height: 1;
            transition: opacity 0.2s ease;
            margin-right: 0.25rem;
        }

        .mindmap-node:hover .mindmap-node-link-btn {
            opacity: 1;
        }

        .mindmap-node-link-btn:hover {
            transform: scale(1.2);
        }

        .mindmap-node.linking-source {
            border-color: var(--accent-red);
            box-shadow: 0 0 0 3px rgba(196, 69, 54, 0.3);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 0 3px rgba(196, 69, 54, 0.3); }
            50% { box-shadow: 0 0 0 6px rgba(196, 69, 54, 0.1); }
        }

        @keyframes pulse-text {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .mindmap-canvas-wrapper.linking-mode {
            cursor: crosshair;
        }

        .mindmap-canvas-wrapper.linking-mode .mindmap-node:not(.linking-source) {
            cursor: pointer;
        }

        .mindmap-canvas-wrapper.linking-mode .mindmap-node:not(.linking-source):hover {
            box-shadow: 0 0 0 3px rgba(74, 158, 255, 0.5);
            border-color: var(--accent-blue);
        }

        .mindmap-node-content {
            font-size: 0.85rem;
            color: var(--text-secondary);
            line-height: 1.4;
        }

        .mindmap-node.type-character {
            border-color: var(--accent-red);
            background: rgba(196, 69, 54, 0.05);
        }

        .mindmap-node.type-element {
            border-color: #4caf50;
            background: rgba(76, 175, 80, 0.05);
        }

        .mindmap-node.type-scene {
            border-color: #2196f3;
            background: rgba(33, 150, 243, 0.05);
        }

        .mindmap-node.type-note {
            border-color: var(--accent-gold);
            background: var(--bg-primary);
        }

        .mindmap-node.type-codex {
            border-color: var(--accent-purple);
            background: rgba(167, 139, 250, 0.05);
        }

        .mindmap-node.type-act {
            border-color: var(--primary-color);
            background: rgba(255, 140, 66, 0.08);
        }

        .mindmap-node.type-chapter {
            border-color: var(--accent-blue);
            background: rgba(74, 158, 255, 0.05);
        }

        .mindmap-link-line {
            position: absolute;
            pointer-events: stroke;
            cursor: pointer;
        }

        .mindmap-link-label {
            position: absolute;
            padding: 0.25rem 0.5rem;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 0.75rem;
            white-space: nowrap;
            pointer-events: none;
            transform: translate(-50%, -50%);
        }

        .mindmap-library {
            width: 250px;
            background: var(--bg-secondary);
            border-left: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .mindmap-library.collapsed {
            width: 40px;
        }

        .mindmap-library-toggle {
            padding: 0.75rem;
            text-align: center;
            cursor: pointer;
            border-bottom: 1px solid var(--border-color);
            background: var(--bg-primary);
            font-size: 1.2rem;
        }

        .mindmap-library-tabs {
            display: flex;
            border-bottom: 1px solid var(--border-color);
        }

        .mindmap-library.collapsed .mindmap-library-tabs {
            display: none;
        }

        .mindmap-library-tab {
            flex: 1;
            padding: 0.5rem;
            text-align: center;
            cursor: pointer;
            font-size: 0.85rem;
            border-right: 1px solid var(--border-color);
            transition: background 0.2s ease;
        }

        .mindmap-library-tab:last-child {
            border-right: none;
        }

        .mindmap-library-tab:hover {
            background: rgba(212, 175, 55, 0.1);
        }

        .mindmap-library-tab.active {
            background: var(--accent-gold);
            color: white;
            font-weight: 600;
        }

        .mindmap-library-content {
            flex: 1;
            overflow-y: auto;
            padding: 0.5rem;
        }

        .mindmap-library.collapsed .mindmap-library-content {
            display: none;
        }

        .mindmap-library-item {
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: grab;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .mindmap-library-item:hover {
            border-color: var(--accent-gold);
            box-shadow: 0 2px 8px var(--shadow);
        }

        .mindmap-library-item:active {
            cursor: grabbing;
        }

        .mindmap-library-item-icon {
            font-size: 1.2rem;
        }

        .mindmap-library-item-text {
            flex: 1;
            font-size: 0.85rem;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .mindmap-empty {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: var(--text-muted);
            padding: 2rem;
            text-align: center;
        }

        .mindmap-empty-icon {
            font-size: 4rem;
            margin-bottom: 1rem;
            opacity: 0.3;
        }


        /* ============================================
           NARRATIVE ARCS STYLES
           ============================================ */
        
        /* Arc Detail View Styles */
        .arc-detail-view {
            padding: 2rem;
            max-width: none;
            margin: 0 auto;
        }
        
        .arc-detail-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 2rem;
            padding-bottom: 1.5rem;
            border-bottom: 2px solid var(--border-color);
        }
        
        .arc-detail-title-group {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .arc-detail-icon {
            font-size: 2.5rem;
        }
        
        .arc-detail-header h2 {
            margin: 0;
            font-size: 2rem;
            color: var(--text-primary);
        }
        
        .arc-detail-actions {
            display: flex;
            gap: 0.75rem;
        }
        
        .arc-detail-content {
            display: flex;
            flex-direction: column;
            gap: 2rem;
        }
        
        .arc-detail-section h3 {
            font-size: 1.2rem;
            color: var(--text-primary);
            margin-bottom: 1rem;
        }
        
        .arc-detail-meta {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1.5rem;
            margin-bottom: 1rem;
        }
        
        .arc-detail-meta-item {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        
        .arc-detail-meta-label {
            font-size: 0.85rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .arc-detail-meta-value {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .arc-progress-bar {
            height: 12px;
            background: var(--bg-secondary);
            border-radius: 6px;
            overflow: hidden;
            margin-bottom: 0.5rem;
        }
        
        .arc-progress-fill {
            height: 100%;
            transition: width 0.3s ease;
            border-radius: 6px;
        }
        
        .arc-progress-text {
            font-size: 0.9rem;
            color: var(--text-muted);
            margin: 0;
        }
        
        .arc-scenes-list {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        
        .arc-scene-item {
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .arc-scene-item:hover {
            border-color: var(--primary-color);
            background: var(--bg-tertiary);
        }
        
        .arc-scene-title {
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
        }
        
        .arc-scene-meta {
            display: flex;
            gap: 1rem;
            font-size: 0.85rem;
            color: var(--text-muted);
            margin-bottom: 0.5rem;
        }
        
        .arc-scene-intensity {
            color: var(--primary-color);
            font-weight: 600;
        }
        
        .arc-scene-notes {
            font-size: 0.9rem;
            color: var(--text-secondary);
            font-style: italic;
            margin-top: 0.5rem;
        }
        
        .btn-danger {
            padding: 0.75rem 1.5rem;
            background: var(--error-color);
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            font-family: 'Crimson Pro', serif;
            font-size: 1rem;
        }
        
		.btn-danger:hover {
            background: #b91c1c;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(220, 38, 38, 0.3);
        }

        .btn-danger:active {
            transform: translateY(0);
        }
        
        /* Arc Editor View Styles */
        .arc-editor-view {
            padding: 2rem;
            max-width: none;
            margin: 0 auto;
        }
        
        .arc-editor-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            padding-bottom: 1.5rem;
            border-bottom: 2px solid var(--border-color);
        }
        
        .arc-editor-header h2 {
            margin: 0;
            font-size: 2rem;
            color: var(--text-primary);
        }
        
        .arc-editor-actions-header {
            display: flex;
            gap: 0.75rem;
        }
        
        .arc-editor-form {
            display: flex;
            flex-direction: column;
            gap: 2rem;
        }
        
        .arc-editor-section {
            background: var(--bg-secondary);
            padding: 1.5rem;
            border-radius: 12px;
            border: 2px solid var(--border-color);
        }
        
        .arc-editor-section h3 {
            margin: 0 0 1.5rem 0;
            font-size: 1.2rem;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .arc-editor-section h3 [data-lucide] {
            width: 20px;
            height: 20px;
            color: var(--primary-color);
        }
        
        .arc-editor-header h2 {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .arc-editor-header h2 [data-lucide] {
            width: 24px;
            height: 24px;
            color: var(--primary-color);
        }
        
        .btn-primary [data-lucide],
        .btn-secondary [data-lucide] {
            width: 16px;
            height: 16px;
            vertical-align: middle;
            margin-right: 4px;
        }
        
        .form-group {
            margin-bottom: 1.5rem;
        }
        
        .form-group:last-child {
            margin-bottom: 0;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 600;
            color: var(--text-primary);
            font-size: 0.95rem;
        }
        
        .form-input {
            width: 100%;
            padding: 0.75rem;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            font-size: 1rem;
            font-family: inherit;
            background: var(--bg-primary);
            color: var(--text-primary);
        }
        
        .form-input:focus {
            outline: none;
            border-color: var(--primary-color);
        }
        
        .form-textarea {
            width: 100%;
            min-height: 120px;
            padding: 0.75rem;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            font-size: 1rem;
            font-family: inherit;
            resize: vertical;
            background: var(--bg-primary);
            color: var(--text-primary);
        }
        
        .form-textarea:focus {
            outline: none;
            border-color: var(--primary-color);
        }
        
        .form-select {
            width: 100%;
            padding: 0.75rem;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            font-size: 1rem;
            font-family: inherit;
            background: var(--bg-primary);
            color: var(--text-primary);
        }
        
        .form-select:focus {
            outline: none;
            border-color: var(--primary-color);
        }
        
        .form-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
        }
        
        .form-help {
            margin: 0.5rem 0 0 0;
            font-size: 0.85rem;
            color: var(--text-muted);
        }
        
        .color-picker-group {
            display: flex;
            gap: 1rem;
            align-items: center;
        }
        
        .color-picker-group input[type="color"] {
            width: 80px;
            height: 44px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            cursor: pointer;
            background: none;
        }
        
        .form-input-small {
            width: 120px;
            padding: 0.75rem;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            font-family: monospace;
            background: var(--bg-primary);
            color: var(--text-primary);
        }
        
        .arc-types-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 0.75rem;
        }
        
        /* Sidebar item styles for arcs */
        .sidebar-item-icon {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .sidebar-item-icon [data-lucide] {
            width: 18px;
            height: 18px;
            stroke-width: 2;
        }
        
        .sidebar-empty-icon {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            opacity: 0.4;
            margin-bottom: 0.5rem;
        }
        
        .sidebar-empty-icon [data-lucide] {
            width: 32px;
            height: 32px;
            stroke-width: 1.5;
        }
        
        .arc-panel-empty-icon {
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.4;
            margin-bottom: 0.5rem;
        }
        
        .arc-panel-empty-icon [data-lucide] {
            width: 32px;
            height: 32px;
            stroke-width: 1.5;
        }
        
        .arc-in-scene-title [data-lucide] {
            width: 16px;
            height: 16px;
            vertical-align: middle;
            margin-right: 4px;
        }
        
        .arc-type-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            padding: 1rem;
            background: var(--bg-primary);
            border: 2px solid var(--border-color);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .arc-type-card:hover {
            border-color: var(--primary-color);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px var(--shadow);
        }
        
        .arc-type-card.selected {
            border-color: var(--primary-color);
            background: var(--primary-color);
            color: white;
        }
        
        .arc-type-icon {
            font-size: 2rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .arc-type-icon [data-lucide] {
            width: 32px;
            height: 32px;
            stroke-width: 1.5;
        }
        
        .arc-type-card.selected .arc-type-icon [data-lucide] {
            color: white;
        }
        
        .arc-type-label {
            font-size: 0.9rem;
            font-weight: 600;
            text-align: center;
        }
        
        .arc-type-card.selected .arc-type-label {
            color: white;
        }
        
        /* Arc Scene Panel Styles */
        .arc-scene-panel {
            position: fixed;
            right: 0;
            top: 60px;
            width: 350px;
            height: calc(100vh - 60px);
            background: var(--bg-primary);
            border-left: 2px solid var(--border-color);
            box-shadow: -4px 0 12px var(--shadow);
            z-index: 900;
            transition: transform 0.3s ease;
            display: flex;
            flex-direction: column;
        }
        
        .arc-scene-panel.hidden {
            transform: translateX(100%);
        }
        
        .arc-scene-panel-header {
            padding: 1.5rem;
            border-bottom: 2px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .arc-scene-panel-header h3 {
            margin: 0;
            font-size: 1.1rem;
            color: var(--text-primary);
        }
        
        .arc-panel-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--text-muted);
            padding: 0;
            line-height: 1;
        }
        
        .arc-panel-close:hover {
            color: var(--error-color);
        }
        
        .arc-scene-panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
        }
        
        .arc-scene-info {
            background: var(--bg-secondary);
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1rem;
            font-size: 0.9rem;
        }
        
        .arc-scene-info-title {
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
        }
        
        .arc-in-scene {
            background: var(--bg-primary);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
        }
        
        .arc-in-scene-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 1rem;
        }
        
        .arc-in-scene-title {
            font-weight: 600;
            color: var(--text-primary);
            flex: 1;
        }
        
        .arc-in-scene-remove {
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            font-size: 1.2rem;
            padding: 0;
        }
        
        .arc-in-scene-remove:hover {
            color: var(--error-color);
        }
        
        .arc-in-scene-control {
            margin-bottom: 1rem;
        }
        
        .arc-in-scene-label {
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
            display: block;
        }
        
        .arc-intensity-slider {
            width: 100%;
            margin-bottom: 0.5rem;
        }
        
        .arc-intensity-value {
            text-align: center;
            font-weight: 600;
            color: var(--primary-color);
        }
        
        .arc-status-select {
            width: 100%;
            padding: 0.5rem;
            border: 2px solid var(--border-color);
            border-radius: 6px;
            background: var(--bg-primary);
            font-size: 0.9rem;
        }
        
        .arc-notes-textarea {
            width: 100%;
            min-height: 60px;
            padding: 0.5rem;
            border: 2px solid var(--border-color);
            border-radius: 6px;
            font-size: 0.85rem;
            font-family: inherit;
            resize: vertical;
        }
        
        .arc-panel-add-select {
            width: 100%;
            padding: 0.75rem;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            margin-bottom: 0.5rem;
        }
        
        .arc-panel-add-btn {
            width: 100%;
            padding: 0.75rem;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            margin-top: 0.5rem;
        }
        
        .arc-panel-add-btn:hover {
            opacity: 0.9;
        }
        
        .arc-panel-empty {
            text-align: center;
            padding: 2rem 1rem;
            color: var(--text-muted);
        }
        
        .arc-panel-empty-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
            opacity: 0.3;
        }


/* ========== 09.utilities.css ========== */
/* Storage Quota Badge Styles */
        .storage-badge {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 12px 18px;
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: 25px;
            font-size: 13px;
            font-weight: 600;
            color: var(--text-primary);
            box-shadow: 0 4px 12px var(--shadow);
            z-index: 10001;
            transition: all 0.3s;
            cursor: pointer;
            display: none;
            align-items: center;
            gap: 8px;
            min-width: 120px;
            -webkit-tap-highlight-color: transparent;
        }
        
        /* Version header du badge de stockage */
        .storage-badge-header {
            padding: 6px 12px;
            background: var(--bg-secondary);
            border: 1.5px solid var(--border-color);
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-primary);
            transition: all 0.2s;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            -webkit-tap-highlight-color: transparent;
        }
        
        .storage-badge-header:hover {
            border-color: var(--accent-gold);
            background: var(--bg-tertiary);
        }
        
        .storage-badge-header .storage-icon {
            font-size: 14px;
            line-height: 1;
        }
        
        .storage-badge-header.status-ok {
            border-color: #4caf50;
        }

        .storage-badge-header.status-warning {
            border-color: #ffc107;
        }

        .storage-badge-header.status-danger {
            border-color: #f44336;
        }

        .storage-badge:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px var(--shadow);
            border-color: var(--accent-gold);
        }

        .storage-badge:active {
            transform: translateY(0);
        }

        .storage-icon {
            font-size: 18px;
            line-height: 1;
        }

        .storage-badge.status-ok {
            border-color: #4caf50;
        }

        .storage-badge.status-warning {
            border-color: #ffc107;
            animation: pulse-warning 2s infinite;
        }

        .storage-badge.status-danger {
            border-color: #f44336;
            animation: pulse-danger 1.5s infinite;
        }

        @keyframes pulse-warning {
            0%, 100% {
                box-shadow: 0 4px 12px var(--shadow);
            }
            50% {
                box-shadow: 0 4px 20px rgba(255, 193, 7, 0.4);
            }
        }

        @keyframes pulse-danger {
            0%, 100% {
                box-shadow: 0 4px 12px var(--shadow);
            }
            50% {
                box-shadow: 0 4px 20px rgba(244, 67, 54, 0.5);
            }
        }

        .storage-details-modal .modal-content {
            max-width: 500px;
        }

        .storage-info {
            margin: 20px 0;
        }

        .storage-bar {
            width: 100%;
            height: 30px;
            background: var(--bg-tertiary);
            border-radius: 15px;
            overflow: hidden;
            margin: 15px 0;
            position: relative;
        }

        .storage-bar-fill {
            height: 100%;
            transition: width 0.5s ease, background-color 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            color: white;
        }

        .storage-bar-fill.ok {
            background: linear-gradient(90deg, #4caf50, #20c997);
        }

        .storage-bar-fill.warning {
            background: linear-gradient(90deg, #ffc107, #ffb800);
        }

        .storage-bar-fill.danger {
            background: linear-gradient(90deg, #f44336, #c62828);
        }

        .storage-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 20px 0;
        }

        .storage-stat {
            background: var(--bg-tertiary);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .storage-stat-label {
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 5px;
        }

        .storage-stat-value {
            font-size: 20px;
            font-weight: bold;
            color: var(--accent-gold);
        }

        .storage-recommendations {
            background: var(--bg-tertiary);
            padding: 15px;
            border-radius: 8px;
            border-left: 3px solid var(--accent-gold);
            margin: 20px 0;
        }

        .storage-recommendations h4 {
            color: var(--accent-gold);
            margin-bottom: 10px;
        }

        .storage-recommendations ul {
            margin-left: 20px;
            color: var(--text-secondary);
            line-height: 1.8;
        }


/* ========== 10.mobile.css ========== */
/* ============================================ */
        /* FLOATING EDITOR MENU (MOBILE) */
        /* ============================================ */
        
        #floatingEditorToggle {
            display: none;
            position: fixed;
            bottom: 0;
            right: 0;
            width: 60px;
            height: 44px;
            border-radius: 0;
            background: white;
            border: none;
            border-left: 1px solid #e0e0e0;
            border-top: 1px solid #e0e0e0;
            color: #333;
            font-size: 24px;
            cursor: pointer;
            box-shadow: -2px -2px 8px rgba(0,0,0,0.1);
            z-index: 10002;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #floatingEditorToggle:active {
            transform: scale(0.95);
            background: #f5f5f5;
        }
            height: 44px;
            padding: 0 16px;
            background: white;
            border: none;
            border-top: 1px solid #e0e0e0;
            border-left: 1px solid #e0e0e0;
            border-radius: 8px 0 0 0;
            color: #333;
            font-size: 20px;
            cursor: pointer;
            box-shadow: -2px -2px 10px rgba(0,0,0,0.05);
            z-index: 10002;
            transition: all 0.2s ease;
            align-items: center;
            justify-content: center;
        }

        #floatingEditorToggle:active {
            background: #f0f0f0;
        }

        #floatingEditorMenu {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 60px;
            background: white;
            border-top: 1px solid #e0e0e0;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.05);
            z-index: 10001;
            overflow: visible;
            padding: 0;
            flex-direction: column-reverse;
        }

        #floatingEditorMenu.active {
            display: flex;
        }

        #floatingMenuHandle {
            display: none;
        }

        #floatingMenuContent {
            padding: 6px 12px;
            background: white;
            display: flex;
            gap: 8px;
            align-items: center;
            justify-content: flex-start;
            overflow-x: auto;
            overflow-y: hidden;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none;
            height: 44px;
        }

        #floatingMenuContent::-webkit-scrollbar {
            display: none;
        }
        
        /* Barre de sous-menu avancé */
        #advancedMenuBar {
            padding: 6px 12px;
            background: white;
            display: none !important;
            gap: 8px;
            align-items: center;
            justify-content: flex-start;
            overflow-x: auto;
            overflow-y: hidden;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none;
            height: 44px;
            border-bottom: 1px solid #e0e0e0;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
            width: 100%;
        }
        
        #advancedMenuBar::-webkit-scrollbar {
            display: none;
        }
        
        #floatingEditorMenu #advancedMenuBar.active {
            display: flex !important;
        }

        .floating-toolbar-row {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .floating-btn-mini {
            min-width: 36px;
            height: 36px;
            padding: 0;
            background: transparent;
            border: none;
            color: #333;
            cursor: pointer;
            transition: all 0.15s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: 400;
            position: relative;
            flex-shrink: 0;
        }

        .floating-btn-mini:active {
            background: #f0f0f0;
            border-radius: 6px;
        }

        .floating-select-mini {
            height: 36px;
            padding: 0 28px 0 10px;
            background: transparent;
            border: none;
            color: #333;
            font-size: 15px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            cursor: pointer;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg width='10' height='6' viewBox='0 0 10 6' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 1L5 5L9 1' stroke='%23666' stroke-width='1.5' stroke-linecap='round'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 8px center;
            flex-shrink: 0;
        }

        .floating-select-mini:active {
            background-color: #f0f0f0;
            border-radius: 6px;
        }

        .floating-divider {
            width: 1px;
            height: 24px;
            background: #e0e0e0;
            flex-shrink: 0;
        }

        /* Storage icon mobile - déjà géré dans la media query principale */
        /* Link Editor Modal */
        .link-editor-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }

        .link-editor-modal {
            background: var(--bg-primary);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            padding: 1.5rem;
            min-width: 400px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .link-editor-header {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--text-primary);
        }

        .link-editor-field {
            margin-bottom: 1rem;
        }

        .link-editor-label {
            display: block;
            font-size: 0.85rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: var(--text-secondary);
        }

        .link-editor-input {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-family: inherit;
            font-size: 0.9rem;
        }

        .link-editor-colors {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .link-color-option {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.2s ease;
        }

        .link-color-option:hover {
            transform: scale(1.1);
        }

        .link-color-option.selected {
            border-color: var(--text-primary);
            box-shadow: 0 0 0 2px var(--bg-primary), 0 0 0 4px var(--text-primary);
        }

        .link-editor-buttons {
            display: flex;
            gap: 0.5rem;
            margin-top: 1.5rem;
        }

        /* Relation Graph Styles */
        .relation-graph {
            width: 100%;
            height: 100%;
            position: relative;
        }

        .relation-node {
            position: absolute;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: var(--bg-primary);
            border: 3px solid var(--accent-gold);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 4px 12px var(--shadow);
        }

        .relation-node:hover {
            transform: scale(1.2);
            z-index: 100;
        }

        .relation-node-avatar {
            font-size: 2rem;
        }

        .relation-node-label {
            position: absolute;
            bottom: -25px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.85rem;
            font-weight: 600;
            white-space: nowrap;
            background: white;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            box-shadow: 0 2px 4px var(--shadow);
        }

        .relation-legend {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: white;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 1rem;
            box-shadow: 0 4px 12px var(--shadow);
        }

        .relation-legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
            font-size: 0.85rem;
        }

        .relation-legend-line {
            width: 30px;
            height: 3px;
        }

        /* Timeline Viz Styles */
        .timeline-viz-container {
            width: 100%;
            padding: 2rem;
            overflow-x: auto;
        }

        .timeline-viz {
            display: flex;
            position: relative;
            min-width: 100%;
            padding: 2rem 0;
        }

        .timeline-viz-line {
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 4px;
            background: var(--accent-gold);
            transform: translateY(-50%);
        }

        .timeline-viz-item {
            position: relative;
            flex: 0 0 200px;
            padding: 0 1rem;
        }

        .timeline-viz-marker {
            width: 20px;
            height: 20px;
            background: var(--accent-gold);
            border: 4px solid white;
            border-radius: 50%;
            margin: 0 auto;
            position: relative;
            z-index: 2;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .timeline-viz-marker:hover {
            transform: scale(1.5);
            background: var(--accent-red);
        }

        .timeline-viz-content {
            background: white;
            border: 2px solid var(--border-color);
            border-radius: 4px;
            padding: 1rem;
            margin-top: 2rem;
            box-shadow: 0 4px 12px var(--shadow);
            transition: all 0.2s ease;
        }

        .timeline-viz-content:hover {
            border-color: var(--accent-gold);
            transform: translateY(-4px);
        }

        .timeline-viz-date {
            font-size: 0.8rem;
            color: var(--text-muted);
            margin-bottom: 0.5rem;
        }

        .timeline-viz-title {
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
        }

        .timeline-viz-description {
            font-size: 0.85rem;
            color: var(--text-secondary);
            line-height: 1.4;
        }

        /* Metro Timeline Styles */
        .metro-timeline-container {
            width: 100%;
            min-height: 500px;
            overflow-x: auto;
            overflow-y: auto;
            background: var(--bg-primary);
            border-radius: 8px;
            position: relative;
        }

        .metro-timeline-wrapper {
            display: flex;
            min-width: max-content;
            padding: 2rem;
        }

        .metro-characters-column {
            flex: 0 0 180px;
            padding-right: 1rem;
            border-right: 2px solid var(--border-color);
            position: sticky;
            left: 0;
            background: var(--bg-primary);
            z-index: 10;
        }

        .metro-character-row {
            height: 60px;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem;
            border-radius: 4px;
            margin-bottom: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .metro-character-row:hover {
            background: var(--bg-secondary);
        }

        .metro-character-color {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 3px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            cursor: pointer;
            transition: transform 0.2s;
        }

        .metro-character-color:hover {
            transform: scale(1.2);
        }

        .metro-character-name {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 120px;
        }

        .metro-events-area {
            flex: 1;
            position: relative;
            min-width: 600px;
        }

        .metro-svg-container {
            display: block;
            min-height: 400px;
        }

        .metro-timeline-container svg {
            display: block;
        }

        .metro-event-node {
            cursor: pointer;
            transition: all 0.2s;
        }

        .metro-event-node:hover circle {
            r: 14;
        }

        .metro-event-node:hover .metro-event-label {
            font-weight: 700;
        }

        .metro-event-label {
            font-size: 11px;
            fill: var(--text-primary);
            pointer-events: none;
        }

        .metro-line {
            fill: none;
            stroke-width: 4;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        .metro-toolbar {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-bottom: 1rem;
            padding: 1rem;
            background: var(--bg-secondary);
            border-radius: 8px;
        }

        .metro-toolbar .btn {
            font-size: 0.85rem;
            padding: 0.5rem 1rem;
        }

        /* Metro Event Modal */
        .metro-event-form {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .metro-characters-selector {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 0.5rem;
        }

        .metro-char-option {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .metro-char-option:hover {
            background: var(--bg-secondary);
        }

        .metro-char-option.selected {
            background: var(--accent-blue-light, #e3f2fd);
            border: 1px solid var(--accent-blue);
        }

        .metro-char-option input[type="checkbox"] {
            margin: 0;
        }

        .metro-char-color-dot {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .metro-linked-chars {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .metro-linked-char-tag {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.25rem 0.5rem;
            border-radius: 12px;
            font-size: 0.8rem;
            color: white;
        }

        .metro-linked-char-tag .remove-char {
            cursor: pointer;
            opacity: 0.8;
            margin-left: 0.25rem;
        }

        .metro-linked-char-tag .remove-char:hover {
            opacity: 1;
        }

        .metro-empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 400px;
            color: var(--text-muted);
            text-align: center;
            padding: 2rem;
        }

        .metro-empty-state i {
            font-size: 4rem;
            margin-bottom: 1rem;
            opacity: 0.3;
        }

        .metro-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            padding: 1rem;
            background: var(--bg-secondary);
            border-radius: 8px;
            margin-top: 1rem;
        }

        .metro-legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.85rem;
        }

        .metro-legend-line {
            width: 30px;
            height: 4px;
            border-radius: 2px;
        }

        /* Metro Events Sortable List */
        .metro-events-sortable {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .metro-event-item {
            display: flex;
            align-items: stretch;
            background: var(--bg-primary);
            border-radius: 4px;
            font-size: 0.85rem;
            cursor: grab;
            transition: all 0.2s;
            border: 2px solid transparent;
        }

        .metro-event-item:hover {
            border-color: var(--border-color);
        }

        .metro-event-item.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }

        .metro-event-item.drag-over {
            border-color: var(--accent-blue);
            background: var(--accent-blue-light, #e3f2fd);
        }

        .metro-event-reorder-btns {
            display: flex;
            flex-direction: column;
            gap: 2px;
            padding: 0.25rem;
        }

        .metro-reorder-btn {
            width: 22px;
            height: 22px;
            border: none;
            background: var(--bg-secondary);
            color: var(--text-muted);
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
        }

        .metro-reorder-btn:hover:not(:disabled) {
            background: var(--accent-blue);
            color: white;
        }

        .metro-reorder-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .metro-event-item-content {
            flex: 1;
            padding: 0.5rem;
            padding-left: 0;
            cursor: pointer;
        }

        .metro-event-item-content:hover {
            background: var(--bg-secondary);
            border-radius: 0 4px 4px 0;
        }

        .metro-drop-indicator {
            height: 3px;
            background: var(--accent-blue);
            border-radius: 2px;
            margin: 2px 0;
        }

        /* Plot Graph Styles */
        .plot-graph {
            width: 100%;
            height: 100%;
            padding: 2rem;
        }

        .plot-legend {
            position: absolute;
            top: 2rem;
            right: 2rem;
            background: white;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 1rem;
            box-shadow: 0 4px 12px var(--shadow);
        }

        /* Map Styles */
        .world-map-container {
            width: 100%;
            height: 100%;
            position: relative;
            overflow: auto;
            background: #f0e6d2;
            background-image: 
                repeating-linear-gradient(0deg, transparent, transparent 20px, rgba(0,0,0,0.03) 20px, rgba(0,0,0,0.03) 21px),
                repeating-linear-gradient(90deg, transparent, transparent 20px, rgba(0,0,0,0.03) 20px, rgba(0,0,0,0.03) 21px);
        }

        .world-map {
            min-width: 100%;
            min-height: 100%;
            position: relative;
            cursor: grab;
        }

        .world-map:active {
            cursor: grabbing;
        }

        .map-location {
            position: absolute;
            width: 40px;
            height: 40px;
            background: var(--accent-red);
            border: 3px solid white;
            border-radius: 50% 50% 50% 0;
            transform: rotate(-45deg);
            cursor: pointer;
            box-shadow: 0 4px 12px var(--shadow);
            transition: all 0.2s ease;
        }

        .map-location:hover {
            transform: rotate(-45deg) scale(1.2);
            z-index: 100;
        }

        .map-location::after {
            content: attr(data-label);
            position: absolute;
            top: 45px;
            left: 50%;
            transform: translateX(-50%) rotate(45deg);
            background: white;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.85rem;
            font-weight: 600;
            white-space: nowrap;
            box-shadow: 0 2px 8px var(--shadow);
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .map-location:hover::after {
            opacity: 1;
        }

        .map-upload-zone {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border: 3px dashed var(--border-color);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .map-upload-zone:hover {
            border-color: var(--accent-gold);
            background: rgba(212, 175, 55, 0.05);
        }

        .map-upload-icon {
            font-size: 4rem;
            margin-bottom: 1rem;
            opacity: 0.5;
        }

        .map-uploaded-image {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        /* Toolbar pour les visualisations */
        .visualization-toolbar {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
            padding: 1rem;
            background: var(--bg-secondary);
            border-radius: 4px;
        }

        .viz-tool-btn {
            padding: 0.5rem 1rem;
            background: var(--primary-color);
            color: white
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Crimson Pro', serif;
            font-size: 0.9rem;
            transition: all 0.2s ease;
        }

        .viz-tool-btn:hover {
            background: var(--accent-gold);
            color: var(--bg-secondary);
            border-color: var(--accent-gold);
        }

        .viz-tool-btn.active {
            background: var(--accent-gold);
            color: var(--bg-secondary);
            border-color: var(--accent-gold);
        }

        /* ========================================
           RESPONSIVE DESIGN - MOBILE & TABLET
           ======================================== */

        /* Mobile Menu Handle (poignée latérale) */
        /* Mobile Menu Handle (poignée latérale) - Style blanc épuré */
        .mobile-menu-handle {
            display: none;
            position: fixed;
            top: 50%;
            left: 0;
            transform: translateY(-50%);
            width: 24px;
            height: 100px;
            background: white;
            border-radius: 0 12px 12px 0;
            cursor: pointer;
            z-index: 10003;
            transition: all 0.3s ease;
            box-shadow: 2px 0 12px rgba(0,0,0,0.15);
            border: 1px solid rgba(0,0,0,0.1);
            border-left: none;
        }

        .mobile-menu-handle::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 2px;
            height: 50px;
            background: linear-gradient(to bottom, 
                rgba(0,0,0,0.1) 0%, 
                rgba(0,0,0,0.3) 50%, 
                rgba(0,0,0,0.1) 100%);
            border-radius: 1px;
        }

        .mobile-menu-handle::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 8px;
            height: 8px;
            background: rgba(0,0,0,0.2);
            border-radius: 50%;
        }

        .mobile-menu-handle:active {
            transform: translateY(-50%) translateX(6px);
            box-shadow: 1px 0 8px rgba(0,0,0,0.1);
        }

        .mobile-menu-handle.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .mobile-menu-toggle:active {
            transform: scale(0.95);
        }

        /* Mobile Navigation Dropdown */
        .mobile-nav-dropdown {
            display: none;
            position: fixed;
            top: 56px;
            left: 0;
            right: 0;
            background: var(--bg-secondary);
            border-bottom: 2px solid var(--accent-gold);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            z-index: 9999;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .mobile-nav-dropdown.active {
            max-height: 80vh;
            overflow-y: auto;
        }

        .mobile-nav-section {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--border-color);
        }

        .mobile-nav-section-title {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 0.5rem;
        }

        .mobile-nav-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 1rem;
            color: var(--text-primary);
            background: transparent;
            border: none;
            width: 100%;
            text-align: left;
        }

        .mobile-nav-item:active {
            background: var(--accent-gold);
            color: white;
        }

        .mobile-nav-item.active {
            background: var(--accent-gold);
            color: white;
            font-weight: 600;
        }

        .mobile-nav-item-icon {
            font-size: 1.3rem;
            width: 28px;
            text-align: center;
        }

        .mobile-nav-toggle-btn {
            display: none;
            position: absolute;
            right: 1rem;
            top: 50%;
            transform: translateY(-50%);
            background: var(--accent-gold);
            color: white;
            border: none;
            border-radius: 6px;
            width: 36px;
            height: 36px;
            font-size: 1.2rem;
            cursor: pointer;
            z-index: 1001;
        }

        .mobile-nav-toggle-btn:active {
            opacity: 0.7;
        }

        /* Collapsible Editor Toolbar on Mobile */
        .toolbar-mobile-toggle {
            display: none;
            width: 100%;
            padding: 0.5rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 0.9rem;
            color: var(--text-primary);
            cursor: pointer;
            margin-bottom: 0.5rem;
            text-align: center;
            font-weight: 600;
        }

        .toolbar-mobile-toggle:active {
            background: var(--accent-gold);
            color: white;
        }

        /* Mobile Sidebar Overlay */
        .sidebar-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 10001;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .sidebar-overlay.active {
            opacity: 1;
        }

        /* Tablet styles (landscape phones and portrait tablets) */
        @media (max-width: 1024px) {
            .app-header {
                padding: 0 1rem;
                gap: 1rem;
            }

            .app-logo {
                font-size: 1.1rem;
            }

            .header-nav {
                gap: 0.25rem;
            }

            .nav-btn {
                padding: 0.5rem 0.75rem;
                font-size: 0.85rem;
            }

            .header-actions {
                gap: 0.25rem;
            }

            .header-action-btn {
                width: 36px;
                height: 36px;
                font-size: 1.1rem;
            }

            .app-container {
                grid-template-columns: 240px 1fr;
            }

            .sidebar {
                width: 240px;
            }

            .modal-content {
                max-width: 90%;
                margin: 2rem auto;
            }
            
            /* Masquer le texte des boutons scene-tools sur tablette */
            .scene-tool-btn span:not(.scene-tool-badge) {
                display: none;
            }
        }

        /* Force mobile nav quand le header déborde */
        body.force-mobile-nav .header-nav {
            display: none !important;
        }
        
        body.force-mobile-nav .mobile-nav-toggle-btn {
            display: block !important;
        }
        
        body.force-mobile-nav .mobile-nav-dropdown {
            display: block !important;
        }
        
        body.force-mobile-nav #headerStatsContainer {
            display: none !important;
        }
        
        body.force-mobile-nav .header-actions {
            gap: 0.35rem;
            margin-right: 3.5rem !important;
        }
        
        body.force-mobile-nav .split-mode-toggle span {
            display: none;
        }

        /* Mobile styles (phones) */
        /* ============================================ */
        /* RESPONSIVE - MOBILE FIRST */
        /* ============================================ */
        
        /* MOBILE (< 900px) */
        @media (max-width: 900px) {
            /* Layout Mobile */
            .app-content {
                flex-direction: column;
            }
            
            /* Sidebar versions en overlay sur mobile */
            .sidebar-versions {
                position: fixed !important;
                top: 0 !important;
                right: 0 !important;
                bottom: 0 !important;
                left: 0 !important;
                width: 100% !important;
                height: 100% !important;
                z-index: 10000 !important;
                background: var(--bg-primary) !important;
                transform: translateX(100%);
                transition: transform 0.3s ease;
            }
            
            .sidebar-versions:not(.hidden) {
                transform: translateX(0);
            }
            
            .sidebar-versions.hidden {
                display: block !important;
                transform: translateX(100%);
            }
            
            .sidebar-versions {
                padding-bottom: calc(60px + env(safe-area-inset-bottom, 20px));
            }
            
            .sidebar-versions-header {
                padding: 1rem;
                border-bottom: 2px solid var(--primary-color);
            }
            
            .sidebar-versions-toggle {
                font-size: 1.5rem;
                padding: 0.5rem;
            }

            /* Header Mobile */
            .app-header {
                height: 56px;
                padding: 0 1rem;
                gap: 1rem;
            }

            .app-logo {
                font-size: 1.1rem;
            }

            .app-logo-icon {
                font-size: 1.3rem;
            }

            /* Cacher navigation desktop */
            .header-nav {
                display: none !important;
            }

            /* Afficher toggle navigation mobile */
            .mobile-nav-toggle-btn {
                display: block;
            }
            
            /* Afficher le bouton ✏️ flottant en mobile */
            #floatingEditorToggle {
                display: flex !important;
            }

            /* Afficher la poignée latérale sur mobile */
            .mobile-menu-handle {
                display: block;
            }

            .mobile-nav-dropdown {
                display: block;
            }

            /* Cacher stats et boutons secondaires sur mobile */
            #headerStatsContainer,
            #headerUndoBtn,
            #headerRedoBtn,
            #storage-badge,
            #pomodoroHeaderBtn {
                display: none !important;
            }
            
            /* Header actions mobile - compacts et alignés */
            .header-actions {
                gap: 0.35rem;
                margin-left: auto;
                margin-right: 3.5rem !important;
            }
            
            .header-action-btn {
                width: 32px;
                height: 32px;
                padding: 0;
                font-size: 0.9rem;
            }
            
            /* Split toggle plus compact sur mobile */
            .split-mode-toggle {
                padding: 0.35rem 0.6rem;
                font-size: 0.75rem;
                gap: 0.25rem;
            }
            
            .split-mode-toggle span {
                display: none;
            }
            
            /* Logo plus compact */
            .app-logo {
                font-size: 0.95rem;
                max-width: 140px;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
            }
            
            .app-logo-icon {
                font-size: 1.1rem;
                flex-shrink: 0;
            }

            /* Sidebar Mobile - en overlay */
            .sidebar {
                position: fixed;
                top: 56px;
                left: -100%;
                width: 85%;
                max-width: 320px;
                height: calc(100vh - 56px);
                z-index: 10002;
                transition: left 0.3s ease;
                box-shadow: 2px 0 12px rgba(0,0,0,0.2);
                background: var(--bg-secondary);
                overflow-y: auto;
                padding-bottom: calc(60px + env(safe-area-inset-bottom, 20px));
            }

            .sidebar.mobile-open {
                left: 0;
            }
            
            /* Padding pour les listes de la sidebar sur mobile */
            .chapters-list,
            .database-list {
                padding-bottom: calc(80px + env(safe-area-inset-bottom, 20px));
            }
            
            .sidebar-actions {
                padding-bottom: calc(1rem + env(safe-area-inset-bottom, 20px));
            }
            
            /* Sidebar Structure - Optimisation mobile */
            .status-filters {
                padding: 0.3rem 0.5rem;
                gap: 0.25rem;
                flex-wrap: wrap;
            }
            
            .status-filter-btn {
                padding: 0.2rem 0.4rem;
                font-size: 0.6rem;
                gap: 0.15rem;
            }
            
            .status-filter-btn span:not(.status-filter-dot):not(.status-filter-count) {
                display: none; /* Cacher le texte, garder seulement le point et le count */
            }
            
            .status-filter-dot {
                width: 6px;
                height: 6px;
            }
            
            .status-filter-count {
                font-size: 0.55rem;
                padding: 0 0.2rem;
            }
            
            .scene-tools {
                padding: 0.3rem 0.5rem;
                gap: 0.25rem;
                flex-wrap: wrap;
            }
            
            .scene-tool-btn {
                padding: 0.25rem 0.4rem;
                font-size: 0.65rem;
                gap: 0.2rem;
            }
            
            .scene-tool-btn span {
                display: none;
            }
            
            .scene-tool-btn i {
                width: 14px !important;
                height: 14px !important;
            }
            
            .tree-collapse-toolbar {
                padding: 0.2rem 0.5rem;
                gap: 0.15rem;
            }
            
            .tree-collapse-btn {
                padding: 0.15rem 0.35rem;
                font-size: 0.6rem;
                gap: 0.15rem;
            }
            
            /* Treeview ULTRA compact sur mobile */
            .act-group {
                margin-bottom: 0.1rem;
            }
            
            .act-header {
                padding: 0.15rem 0.3rem;
                font-size: 0.7rem;
                gap: 0.15rem;
                min-height: 24px;
            }
            
            .act-icon {
                font-size: 0.5rem;
                width: 8px;
            }
            
            .act-title {
                font-size: 0.65rem;
            }
            
            .act-chapters {
                padding-left: 0.15rem;
            }
            
            .chapter-group {
                margin-bottom: 0;
            }
            
            .chapter-header {
                padding: 0.1rem 0.3rem;
                font-size: 0.65rem;
                gap: 0.15rem;
                min-height: 22px;
            }
            
            .chapter-icon {
                font-size: 0.45rem;
                width: 6px;
            }
            
            .chapter-title {
                font-size: 0.65rem;
            }
            
            .scenes-list {
                padding-left: 0.4rem;
            }
            
            .scene-item {
                padding: 0.08rem 0.3rem;
                font-size: 0.65rem;
                gap: 0.15rem;
                min-height: 20px;
            }
            
            .auto-number {
                font-size: 0.5rem;
                min-width: 20px;
                margin-right: 0.1rem;
            }
            
            .word-count-badge {
                font-size: 0.45rem;
                padding: 0 0.15rem;
            }
            
            .status-badge {
                width: 6px;
                height: 6px;
            }
            
            .drag-handle {
                padding: 0 0.1rem;
                font-size: 0.5rem;
            }
            
            .delete-btn {
                width: 14px !important;
                height: 14px !important;
                font-size: 0.6rem !important;
                padding: 0 !important;
            }
            
            .edit-hint {
                display: none;
            }
            
            .chapter-count {
                font-size: 0.5rem;
            }
            
            /* Barre de progression mobile */
            .sidebar-progress-info {
                padding: 0.25rem 0.5rem;
                font-size: 0.6rem;
            }
            
            /* Search bar mobile */
            .search-container {
                padding: 0.3rem 0.5rem;
                margin-bottom: 0.5rem;
            }
            
            .search-container input {
                padding: 0.35rem 0.5rem;
                font-size: 0.75rem;
            }
            
            /* Stats overview compact */
            .stats-overview {
                padding: 0.5rem;
                margin-bottom: 0.5rem;
            }
            
            .stats-overview .stat-group {
                gap: 0.25rem;
            }
            
            .stats-overview .stat-badge {
                padding: 0.15rem 0.4rem;
                font-size: 0.7rem;
            }
            
            /* Toolbar collapse buttons compact */
            .tree-collapse-toolbar {
                padding: 0.25rem 0.5rem;
                margin-bottom: 0.25rem;
            }
            
            .tree-collapse-btn {
                padding: 0.25rem 0.5rem;
                font-size: 0.75rem;
                gap: 0.25rem;
            }
            
            /* Sidebar actions mobile compact */
            .sidebar-actions .btn {
                padding: 0.4rem 0.6rem;
                font-size: 0.7rem;
            }

            /* Editor full width */
            .editor-container {
                width: 100%;
            }

            /* Toolbar Desktop - masqué et remplacé par bouton toggle */
            .toolbar-mobile-toggle {
                display: block;
                width: 100%;
                padding: 12px;
                background: white;
                border: none;
                border-bottom: 1px solid var(--border-color);
                color: var(--text-primary);
                font-size: 14px;
                font-weight: 600;
                cursor: pointer;
                text-align: center;
                transition: all 0.2s ease;
            }

            .toolbar-mobile-toggle:active {
                background: var(--bg-secondary);
            }

            .toolbar-mobile-toggle .toggle-icon {
                display: inline-block;
                transition: transform 0.3s ease;
                margin-left: 0.5rem;
            }

            .toolbar-mobile-toggle.expanded .toggle-icon {
                transform: rotate(180deg);
            }

            /* Toolbar collapsible */
            .editor-toolbar {
                max-height: 0 !important;
                overflow: hidden !important;
                transition: max-height 0.3s ease;
                padding: 0 !important;
                border-bottom: none !important;
            }

            .editor-toolbar.expanded {
                max-height: 500px !important;
                overflow-y: auto !important;
                overflow-x: hidden !important;
                padding: 12px !important;
                border-bottom: 1px solid var(--border-color) !important;
                flex-wrap: wrap !important;
            }

            /* Menu flottant mobile visible */
            #floatingEditorToggle {
                display: flex;
            }

            /* Editor content */
            .editor-content {
                padding: 1.5rem;
            }

            .editor-textarea {
                font-size: 1rem;
                line-height: 1.7;
            }
            
            /* Editor header mobile */
            .editor-header {
                padding: 1rem 1rem 0.75rem;
            }
            
            .editor-breadcrumb {
                font-size: 0.75rem;
                margin-bottom: 0.5rem;
            }
            
            .editor-title {
                font-size: 1.4rem;
            }
            
            .editor-meta {
                flex-wrap: wrap;
                gap: 0.5rem 1rem;
                font-size: 0.75rem;
            }
            
            /* Bouton Focus plus compact */
            .editor-header .btn-small,
            .editor-header .btn {
                padding: 0.4rem 0.6rem;
                font-size: 0.75rem;
            }
            
            /* Links panel toggle - comme toolbar */
            .links-panel-toggle {
                display: block;
                width: 100%;
                padding: 12px;
                background: white;
                border: none;
                border-bottom: 1px solid var(--border-color);
                color: var(--text-primary);
                font-size: 14px;
                font-weight: 600;
                cursor: pointer;
                text-align: center;
                transition: all 0.2s ease;
            }

            .links-panel-toggle:active {
                background: var(--bg-secondary);
            }

            /* Links panel collapsible - comme toolbar */
            #linksPanel {
                max-height: 0;
                overflow: hidden;
                transition: max-height 0.3s ease;
                padding: 0 1rem;
                border-bottom: none;
            }

            #linksPanel.expanded {
                max-height: 500px;
                overflow-y: auto;
                padding: 0.75rem 1rem;
                border-bottom: 1px solid var(--border-color);
            }
            
            .links-panel-sticky > div {
                flex-direction: column;
                gap: 0.75rem !important;
            }
            
            .quick-links {
                flex-wrap: wrap;
                gap: 0.4rem;
            }
            
            .link-badge {
                font-size: 0.75rem;
                padding: 0.25rem 0.5rem;
            }

            /* Modals */
            .modal-content {
                width: 95%;
                max-width: 95%;
                margin: 1rem;
                max-height: 90vh;
            }

            /* Boutons */
            .btn {
                padding: 0.7rem 1rem;
                font-size: 15px;
                touch-action: manipulation;
            }

            /* Formulaires */
            .form-input,
            .form-textarea {
                font-size: 16px; /* Évite le zoom sur iOS */
            }

            /* Storage badge */
            .storage-badge {
                bottom: 60px;
                right: 15px;
                font-size: 11px;
                min-width: 80px;
                min-height: 40px;
                padding: 8px 12px;
            }
        }

        /* TABLETTE (901px - 1024px) */
        @media (min-width: 901px) and (max-width: 1024px) {
            .app-content {
                display: flex;
                flex-direction: row;
            }

            .sidebar {
                position: static !important;
                left: auto !important;
                width: 240px !important;
                max-width: 240px !important;
                height: auto !important;
                z-index: auto !important;
                transition: none !important;
                display: flex !important;
                flex-shrink: 0;
            }

            .mobile-menu-handle,
            .sidebar-overlay {
                display: none !important;
            }

            .editor-content {
                padding: 2rem;
            }

            .app-header {
                padding: 0 1.5rem;
            }

            .editor-toolbar {
                padding: 8px 12px;
                flex-wrap: wrap;
            }
        }

        /* DESKTOP (> 1024px) */
        @media (min-width: 1025px) {
            /* Masquer les éléments mobile */
            .mobile-nav-toggle-btn,
            .mobile-nav-dropdown,
            .toolbar-mobile-toggle,
            #floatingEditorToggle,
            #floatingEditorMenu,
            .mobile-menu-handle,
            .sidebar-overlay {
                display: none !important;
            }

            /* Afficher navigation desktop */
            .header-nav {
                display: flex !important;
            }

            /* Toolbar toujours visible */
            .editor-toolbar {
                /*display: flex !important;*/
                max-height: none !important;
                flex-wrap: wrap !important;
            }

            /* SIDEBAR DESKTOP - CRITIQUE */
            .sidebar {
                position: static !important;
                left: auto !important;
                width: 350px !important;
                max-width: 350px !important;
                height: auto !important;
                z-index: auto !important;
                transition: none !important;
                display: flex !important;
            }

            /* Grid layout desktop */
            .app-container {
                grid-template-columns: 350px 1fr !important;
                grid-template-areas:
                    "header header"
                    "sidebar main" !important;
            }
        }

        /* GRAND ÉCRAN (> 1440px) */
        @media (min-width: 1441px) {
            .editor-content {
                max-width: 850px;
            }
        }

        /* Styles additionnels pour mobile (900px) - storage badge */
        @media (max-width: 900px) {
            .storage-badge {
                bottom: 15px;
                right: 15px;
                padding: 10px 15px;
                font-size: 12px;
                min-width: 100px;
                min-height: 44px;
                z-index: 10001;
            }

            /* Scene metadata */
            .scene-metadata {
                flex-direction: column;
                gap: 0.75rem;
            }

            .metadata-item {
                width: 100%;
            }

            /* Character and element links */
            .scene-links {
                flex-direction: column;
            }

            .link-group {
                width: 100%;
            }

            /* Content editor */
            #sceneContent {
                font-size: 1rem;
                line-height: 1.6;
                padding: 1rem;
            }

            /* Sidebar actions */
            .sidebar-actions {
                flex-direction: row;
                gap: 0.25rem;
                padding: 0.5rem;
            }

            .sidebar-actions .btn {
                width: 33.333%;
                flex: 1;
                font-size: 0.8rem;
                padding: 0.5rem 0.25rem;
                white-space: nowrap;
            }

            /* Modals */
            .modal-content {
                width: 95%;
                max-width: 95%;
                margin: 1rem auto;
                max-height: 90vh;
                overflow-y: auto;
            }

            .modal-title {
                font-size: 1.3rem;
            }

            /* Boutons dans les modals - empiler verticalement sur mobile */
            .modal-button-group {
                flex-direction: column;
            }

            .modal-button-group .btn {
                width: 100%;
                min-width: unset;
                margin: 0;
            }

            .modal-button-group .btn + .btn {
                margin-top: 0.75rem;
            }

            .modal-content > div > .btn {
                display: block;
                width: 100%;
                margin: 0.5rem 0;
            }

            /* Forms */
            .form-input,
            .form-textarea {
                font-size: 16px; /* Prevents zoom on iOS */
            }

            /* Buttons */
            .btn {
                padding: 0.65rem 1rem;
                font-size: 0.95rem;
                touch-action: manipulation;
                -webkit-tap-highlight-color: transparent;
            }

            .btn-small {
                padding: 0.4rem 0.6rem;
                font-size: 0.85rem;
            }

            /* Stats cards */
            .stats-cards {
                grid-template-columns: 1fr;
                gap: 1rem;
            }

            /* Character/World cards */
            .character-card,
            .world-card {
                padding: 1rem;
            }

            /* Act/Chapter structure */
            .act-header,
            .chapter-header {
                padding: 0.5rem 0.75rem;
                min-height: unset;
            }

            .act-title,
            .chapter-title {
                font-size: 0.9rem;
                line-height: 1.3;
            }

            .scene-item {
                padding: 0.45rem 0.75rem;
                font-size: 0.85rem;
                min-height: unset;
                line-height: 1.3;
            }
            
            /* Reduce spacing in act/chapter groups */
            .act-group {
                margin-bottom: 0.5rem;
            }
            
            .chapter-group {
                margin-bottom: 0.25rem;
            }
            
            /* Compact word count badges */
            .word-count-badge {
                font-size: 0.7rem;
                padding: 0.15rem 0.4rem;
            }
            
            /* Compact status badges */
            .status-badge {
                width: 6px;
                height: 6px;
            }
            
            /* Compact chapter count */
            .chapter-count {
                font-size: 0.7rem;
                padding: 0.15rem 0.35rem;
            }

            /* Empty state */
            .empty-state {
                padding: 2rem 1rem;
            }

            .empty-state-icon {
                font-size: 3rem;
            }

            .empty-state-title {
                font-size: 1.3rem;
            }

            /* Timeline visualization */
            .timeline-item {
                padding: 1rem;
            }

            /* Cork board */
            .cork-card {
                min-width: 200px;
                font-size: 0.9rem;
            }

            /* Search */
            .search-input {
                font-size: 0.95rem;
                padding: 0.65rem 2.5rem 0.65rem 1rem;
            }

            /* Tabs */
            .tabs {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }

            .tab-btn {
                flex-shrink: 0;
                padding: 0.6rem 1rem;
                font-size: 0.9rem;
            }
        }

        /* Small mobile phones */
        @media (max-width: 480px) {
            .app-header {
                height: 52px;
                padding: 0 0.5rem;
            }

            .app-logo {
                font-size: 0.9rem;
            }

            .app-logo-icon {
                font-size: 1.1rem;
            }

            .nav-btn {
                padding: 0.35rem 0.5rem;
                font-size: 0.95rem;
            }

            .header-action-btn {
                width: 32px;
                height: 32px;
                font-size: 0.95rem;
            }

            .sidebar {
                width: 90%;
                max-width: 280px;
                top: 52px;
                height: calc(100vh - 52px);
            }

            .app-container {
                grid-template-rows: 52px 1fr;
            }

            .scene-editor {
                padding: 0.75rem;
            }

            .scene-title {
                font-size: 1.3rem;
            }

            #sceneContent {
                font-size: 0.95rem;
                padding: 0.75rem;
            }

            .mobile-menu-toggle {
                width: 52px;
                height: 52px;
                font-size: 1.3rem;
                bottom: 16px;
                right: 16px;
            }

            .modal-content {
                width: 98%;
                margin: 0.5rem auto;
                padding: 1rem;
            }

            .modal-title {
                font-size: 1.2rem;
            }

            .btn {
                padding: 0.6rem 0.85rem;
                font-size: 0.9rem;
            }
        }

        /* Landscape orientation on phones */
        @media (max-width: 900px) and (orientation: landscape) {
            .app-header {
                height: 48px;
            }

            .sidebar {
                top: 48px;
                height: calc(100vh - 48px);
            }

            .app-container {
                grid-template-rows: 48px 1fr;
            }

            .modal-content {
                max-height: 85vh;
            }

            .mobile-menu-toggle {
                width: 48px;
                height: 48px;
                bottom: 12px;
                right: 12px;
            }
        }

        /* iOS specific fixes */
        @supports (-webkit-touch-callout: none) {
            /* iOS safe area insets */
            .app-header {
                padding-top: max(env(safe-area-inset-top), 0px);
            }

            .sidebar {
                padding-bottom: max(env(safe-area-inset-bottom), 0px);
            }

            .mobile-menu-toggle {
                bottom: max(env(safe-area-inset-bottom, 20px) + 20px, 20px);
                right: max(env(safe-area-inset-right, 20px) + 20px, 20px);
            }

            /* Prevent elastic scrolling on body */
            body {
                position: fixed;
                width: 100%;
            }

            /* Fix textarea font size to prevent zoom */
            input,
            textarea,
            select {
                font-size: 16px !important;
            }
        }

        /* Android Chrome specific */
        @media screen and (-webkit-min-device-pixel-ratio: 0) {
            select,
            textarea,
            input {
                font-size: 16px;
            }
        }

        /* High DPI screens */
        @media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
            .app-header {
                border-bottom-width: 1px;
            }
        }

        /* Dark mode support (if device prefers dark) */
        @media (prefers-color-scheme: dark) {
            /* This is ready for future dark mode implementation */
        }

        /* Reduced motion for accessibility */
        @media (prefers-reduced-motion: reduce) {
            *,
            *::before,
            *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* Touch device optimizations */
        @media (hover: none) and (pointer: coarse) {
            /* Larger touch targets */
            .btn,
            .nav-btn,
            .toolbar-btn,
            button {
                min-height: 44px;
                min-width: 44px;
            }

            /* Remove hover effects on touch devices */
            .btn:hover,
            .nav-btn:hover,
            .toolbar-btn:hover {
                transform: none;
            }

            /* Add active state feedback */
            .btn:active,
            .nav-btn:active,
            .toolbar-btn:active {
                opacity: 0.7;
            }
        }


/* ========== 11.storygrid.css ========== */
* ============================================
   Module: views/storygrid
   Story Grid - Styles CSS
   ============================================ */

/* ============================================
   CONTAINER & LAYOUT
   ============================================ */

.storygrid-container {
    display: flex;
    flex-direction: column;
    height: 100%;
    background: var(--bg-secondary, #f8f9fa);
    overflow: hidden;
}

.storygrid-main {
    display: flex;
    flex: 1;
    overflow: hidden;
}

/* ============================================
   TOOLBAR
   ============================================ */

.storygrid-toolbar {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 12px 16px;
    background: var(--bg-primary, #fff);
    border-bottom: 1px solid var(--border-color, #e0e0e0);
    gap: 16px;
    flex-shrink: 0;
}

.storygrid-toolbar-left,
.storygrid-toolbar-center,
.storygrid-toolbar-right {
    display: flex;
    align-items: center;
    gap: 12px;
}

.storygrid-toolbar-title {
    display: flex;
    align-items: center;
    gap: 8px;
    font-weight: 600;
    font-size: 16px;
    color: var(--text-primary, #1a1a2e);
}

.storygrid-toolbar-title i {
    width: 20px;
    height: 20px;
    color: var(--primary-color, #6366f1);
}

/* View Mode Buttons */
.storygrid-view-modes {
    display: flex;
    gap: 4px;
    padding: 4px;
    background: var(--bg-tertiary, #f0f0f0);
    border-radius: 8px;
}

.storygrid-view-btn {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 36px;
    height: 32px;
    border: none;
    background: transparent;
    border-radius: 6px;
    cursor: pointer;
    color: var(--text-secondary, #666);
    transition: all 0.2s ease;
}

.storygrid-view-btn:hover {
    background: var(--bg-hover, #e0e0e0);
    color: var(--text-primary, #1a1a2e);
}

.storygrid-view-btn.active {
    background: var(--bg-primary, #fff);
    color: var(--primary-color, #6366f1);
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}

.storygrid-view-btn i {
    width: 18px;
    height: 18px;
}

/* Zoom Control */
.storygrid-zoom-control {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 4px;
    background: var(--bg-tertiary, #f0f0f0);
    border-radius: 8px;
}

.storygrid-zoom-btn {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 28px;
    height: 28px;
    border: none;
    background: transparent;
    border-radius: 6px;
    cursor: pointer;
    color: var(--text-secondary, #666);
    transition: all 0.2s ease;
}

.storygrid-zoom-btn:hover {
    background: var(--bg-hover, #e0e0e0);
    color: var(--text-primary, #1a1a2e);
}

.storygrid-zoom-btn i {
    width: 16px;
    height: 16px;
}

.storygrid-zoom-label {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 0 8px;
    font-size: 13px;
    color: var(--text-secondary, #666);
    min-width: 100px;
    justify-content: center;
}

.storygrid-zoom-label i {
    width: 14px;
    height: 14px;
}

/* Action Buttons */
.storygrid-action-btn {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 8px 12px;
    border: 1px solid var(--border-color, #e0e0e0);
    background: var(--bg-primary, #fff);
    border-radius: 8px;
    cursor: pointer;
    font-size: 13px;
    color: var(--text-secondary, #666);
    transition: all 0.2s ease;
}

.storygrid-action-btn:hover {
    background: var(--bg-hover, #f5f5f5);
    border-color: var(--primary-color, #6366f1);
    color: var(--primary-color, #6366f1);
}

.storygrid-action-btn i {
    width: 16px;
    height: 16px;
}

.storygrid-action-btn.disabled,
.storygrid-action-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    pointer-events: none;
}

/* View Mode Info Banner */
.storygrid-view-mode-info {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 16px;
    background: var(--primary-color, #6366f1);
    background: linear-gradient(135deg, var(--primary-color, #6366f1), var(--accent-purple, #a78bfa));
    color: white;
    font-size: 13px;
    font-weight: 500;
}

.storygrid-view-mode-info i {
    width: 14px;
    height: 14px;
    opacity: 0.9;
}

/* ============================================
   FILTERS
   ============================================ */

.storygrid-filters {
    display: flex;
    align-items: center;
    gap: 16px;
    padding: 12px 16px;
    background: var(--bg-primary, #fff);
    border-bottom: 1px solid var(--border-color, #e0e0e0);
}

.storygrid-filters-title {
    font-size: 13px;
    font-weight: 500;
    color: var(--text-secondary, #666);
}

.storygrid-filters-options {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
}

.storygrid-filter-option {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 6px 10px;
    background: var(--bg-tertiary, #f0f0f0);
    border-radius: 6px;
    cursor: pointer;
    font-size: 12px;
    transition: all 0.2s ease;
}

.storygrid-filter-option:hover {
    background: var(--bg-hover, #e0e0e0);
}

.storygrid-filter-option input {
    accent-color: var(--primary-color, #6366f1);
}

.storygrid-filter-option i {
    width: 14px;
    height: 14px;
}

/* ============================================
   ROW HEADERS (LEFT PANEL)
   ============================================ */

.storygrid-row-headers {
    display: flex;
    flex-direction: column;
    width: 220px;
    min-width: 220px;
    background: var(--bg-primary, #fff);
    border-right: 1px solid var(--border-color, #e0e0e0);
    flex-shrink: 0;
}

.storygrid-corner {
    display: flex;
    align-items: center;
    justify-content: center;
    border-bottom: 1px solid var(--border-color, #e0e0e0);
    color: var(--text-muted, #999);
}

.storygrid-corner i {
    width: 16px;
    height: 16px;
}

.storygrid-row-header {
    display: flex;
    align-items: center;
    gap: 8px;
    height: 80px;
    padding: 0 12px;
    border-bottom: 1px solid var(--border-color, #e0e0e0);
    background: var(--bg-primary, #fff);
    cursor: grab;
    transition: all 0.2s ease;
}

.storygrid-row-header:hover {
    background: var(--bg-hover, #f5f5f5);
}

.storygrid-row-header.dragging {
    opacity: 0.5;
    cursor: grabbing;
}

.storygrid-row-header.drag-over {
    background: var(--primary-color-light, #e0e7ff);
    border-top: 2px solid var(--primary-color, #6366f1);
}

.storygrid-row-drag {
    display: flex;
    align-items: center;
    color: var(--text-muted, #999);
    cursor: grab;
}

.storygrid-row-drag i {
    width: 14px;
    height: 14px;
}

.storygrid-row-icon {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 32px;
    height: 32px;
    border-radius: 8px;
    background: color-mix(in srgb, var(--row-color) 15%, transparent);
}

.storygrid-row-icon i {
    width: 18px;
    height: 18px;
}

.storygrid-row-title {
    flex: 1;
    font-size: 13px;
    font-weight: 500;
    color: var(--text-primary, #1a1a2e);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    cursor: text;
}

.storygrid-row-title-input {
    width: 100%;
    padding: 4px 8px;
    border: 1px solid var(--primary-color, #6366f1);
    border-radius: 4px;
    font-size: 13px;
    outline: none;
}

.storygrid-row-actions {
    display: flex;
    opacity: 0;
    transition: opacity 0.2s ease;
}

.storygrid-row-header:hover .storygrid-row-actions {
    opacity: 1;
}

.storygrid-row-action {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 28px;
    height: 28px;
    border: none;
    background: transparent;
    border-radius: 6px;
    cursor: pointer;
    color: var(--text-secondary, #666);
    transition: all 0.2s ease;
}

.storygrid-row-action:hover {
    background: var(--bg-tertiary, #f0f0f0);
    color: var(--text-primary, #1a1a2e);
}

.storygrid-row-action i {
    width: 16px;
    height: 16px;
}

.storygrid-empty-rows {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 40px 20px;
    text-align: center;
    color: var(--text-muted, #999);
    gap: 12px;
}

.storygrid-empty-rows i {
    width: 32px;
    height: 32px;
    opacity: 0.5;
}

.storygrid-empty-rows p {
    font-size: 13px;
    margin: 0;
}

/* ============================================
   CONTENT AREA (SCROLLABLE GRID)
   ============================================ */

.storygrid-content {
    flex: 1;
    overflow: auto;
    position: relative;
}

/* Column Headers */
.storygrid-column-headers {
    position: sticky;
    top: 0;
    z-index: 10;
    background: var(--bg-primary, #fff);
}

.storygrid-act-groups {
    display: flex;
    border-bottom: 1px solid var(--border-color, #e0e0e0);
}

.storygrid-act-group {
    display: flex;
    align-items: center;
    justify-content: center;
    height: 32px;
    font-size: 11px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: var(--text-secondary, #666);
    background: var(--bg-tertiary, #f0f0f0);
    border-right: 1px solid var(--border-color, #e0e0e0);
    box-sizing: border-box;
    flex-shrink: 0;
}

.storygrid-chapter-groups {
    display: flex;
    border-bottom: 1px solid var(--border-color, #e0e0e0);
}

.storygrid-chapter-group {
    display: flex;
    align-items: center;
    justify-content: center;
    height: 32px;
    font-size: 11px;
    font-weight: 500;
    text-transform: uppercase;
    letter-spacing: 0.3px;
    color: var(--text-secondary, #666);
    background: var(--bg-primary, #fff);
    border-right: 1px solid var(--border-color, #e0e0e0);
    box-sizing: border-box;
    flex-shrink: 0;
}

.storygrid-columns {
    display: flex;
    border-bottom: 1px solid var(--border-color, #e0e0e0);
}

.storygrid-column-header {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 48px;
    padding: 8px;
    border-right: 1px solid var(--border-color, #e0e0e0);
    background: var(--bg-primary, #fff);
    flex-shrink: 0;
    box-sizing: border-box;
}

.storygrid-column-title {
    font-size: 12px;
    font-weight: 500;
    color: var(--text-primary, #1a1a2e);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 100%;
    text-align: center;
}

.storygrid-column-count {
    font-size: 10px;
    color: var(--text-muted, #999);
    margin-top: 2px;
}

.storygrid-empty-columns {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 40px;
    color: var(--text-muted, #999);
    gap: 8px;
}

.storygrid-empty-columns i {
    width: 24px;
    height: 24px;
    opacity: 0.5;
}

.storygrid-empty-columns p {
    font-size: 13px;
    margin: 0;
}

/* ============================================
   GRID BODY
   ============================================ */

.storygrid-body {
    display: flex;
    flex-direction: column;
}

.storygrid-body.empty {
    min-height: 200px;
}

.storygrid-row {
    display: flex;
}

.storygrid-cell {
    position: relative;
    height: 80px;
    border-right: 1px solid var(--border-color, #e0e0e0);
    border-bottom: 1px solid var(--border-color, #e0e0e0);
    background: var(--bg-primary, #fff);
    flex-shrink: 0;
    display: flex;
    flex-direction: column;
    gap: 4px;
    padding: 4px;
    overflow: hidden;
    transition: background 0.2s ease;
    box-sizing: border-box;
}

.storygrid-cell.has-spanning-card {
    /* Allow spanning cards to overflow */
    overflow: visible;
    z-index: 5;
}

.storygrid-cell.storygrid-cell-covered {
    /* Cell covered by a spanning card - subtle appearance */
    background: transparent;
    pointer-events: none;
}

.storygrid-cell:hover {
    background: var(--bg-hover, #fafafa);
}

.storygrid-cell.has-content {
    background: var(--bg-secondary, #f8f9fa);
}

.storygrid-cell.has-cards {
    background: var(--bg-primary, #fff);
}

.storygrid-cell.drag-over {
    background: var(--primary-color-light, #e0e7ff);
    outline: 2px dashed var(--primary-color, #6366f1);
    outline-offset: -2px;
}

/* Cell Add Button */
.storygrid-cell-add {
    position: absolute;
    bottom: 4px;
    right: 4px;
    width: 24px;
    height: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 4px;
    background: transparent;
    color: var(--text-muted, #999);
    cursor: pointer;
    opacity: 0;
    transition: all 0.2s ease;
}

.storygrid-cell:hover .storygrid-cell-add {
    opacity: 1;
}

.storygrid-cell-add:hover {
    background: var(--primary-color, #6366f1);
    color: white;
}

.storygrid-cell-add i {
    width: 14px;
    height: 14px;
}

/* Auto Card (Presence Indicator) */
.storygrid-auto-card {
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 6px;
    border: 1px dashed;
}

.storygrid-auto-card-icon i {
    width: 20px;
    height: 20px;
    opacity: 0.7;
}

/* ============================================
   CARDS
   ============================================ */

.storygrid-card {
    position: relative;
    padding: 8px;
    background: var(--bg-primary, #fff);
    border-radius: 6px;
    border-left: 3px solid var(--card-color, #6366f1);
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    cursor: pointer;
    transition: all 0.2s ease;
    overflow: hidden;
}

.storygrid-card.spanning {
    /* Card that spans multiple columns - just wider */
    min-width: 100%;
}

.storygrid-card:hover {
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    transform: translateY(-1px);
    z-index: 10;
}

.storygrid-card-delete {
    position: absolute;
    top: 4px;
    right: 4px;
    width: 20px;
    height: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(239, 68, 68, 0.9);
    color: white;
    border: none;
    border-radius: 50%;
    cursor: pointer;
    opacity: 0;
    transition: opacity 0.2s ease, transform 0.1s ease;
    font-size: 12px;
    line-height: 1;
    z-index: 10;
}

.storygrid-card:hover .storygrid-card-delete {
    opacity: 1;
}

.storygrid-card-delete:hover {
    background: rgba(220, 38, 38, 1);
    transform: scale(1.1);
}

.storygrid-card-delete:active {
    transform: scale(0.95);
}

.storygrid-card.dragging {
    opacity: 0.5;
    cursor: grabbing;
    transform: scale(1.02);
}

.storygrid-card-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 4px;
}

.storygrid-card-status {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 16px;
    height: 16px;
    border-radius: 50%;
    background: var(--status-color, #95a5a6);
    color: white;
}

.storygrid-card-status i {
    width: 10px;
    height: 10px;
}

.storygrid-card-intensity {
    display: flex;
    gap: 2px;
}

.intensity-dot {
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background: var(--border-color, #e0e0e0);
    transition: background 0.2s ease;
}

.intensity-dot.active {
    background: var(--card-color, #6366f1);
}

.storygrid-card-title {
    font-size: 11px;
    font-weight: 600;
    color: var(--text-primary, #1a1a2e);
    line-height: 1.3;
    overflow: hidden;
    text-overflow: ellipsis;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
}

.storygrid-card-summary {
    font-size: 10px;
    color: var(--text-secondary, #666);
    margin-top: 4px;
    overflow: hidden;
    text-overflow: ellipsis;
    display: -webkit-box;
    -webkit-line-clamp: 1;
    -webkit-box-orient: vertical;
}

.storygrid-card-conflict {
    display: flex;
    align-items: center;
    gap: 4px;
    font-size: 10px;
    color: var(--warning-color, #f59e0b);
    margin-top: 4px;
}

.storygrid-card-conflict i {
    width: 12px;
    height: 12px;
}

/* ============================================
   TWIN CARDS STYLES
   ============================================ */

/* Card jumelle (apparaît sur plusieurs lignes) */
.storygrid-card.is-twin {
    background: linear-gradient(135deg, var(--bg-primary, #fff) 0%, rgba(99, 102, 241, 0.05) 100%);
    border-left-style: dashed;
}

/* Card originale avec des jumelles */
.storygrid-card.has-twins {
    /* Légère mise en évidence */
}

/* Surbrillance synchronisée des jumelles */
.storygrid-card.twin-highlight {
    box-shadow: 0 0 0 3px var(--primary-color, #6366f1), 0 4px 12px rgba(99, 102, 241, 0.3);
    transform: translateY(-2px);
    z-index: 20;
    animation: twinGlow 1s ease infinite;
}

@keyframes twinGlow {
    0%, 100% { box-shadow: 0 0 0 3px var(--primary-color, #6366f1), 0 4px 12px rgba(99, 102, 241, 0.3); }
    50% { box-shadow: 0 0 0 5px var(--primary-color, #6366f1), 0 4px 20px rgba(99, 102, 241, 0.5); }
}

/* Badge compteur de jumelles */
.storygrid-card-twins {
    display: flex;
    align-items: center;
    gap: 2px;
    padding: 2px 6px;
    background: var(--primary-color, #6366f1);
    color: white;
    border-radius: 10px;
    font-size: 9px;
    font-weight: 600;
}

.storygrid-card-twins i {
    width: 10px;
    height: 10px;
}

/* Badge jumelle */
.storygrid-card-twin-badge {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 16px;
    height: 16px;
    background: rgba(99, 102, 241, 0.15);
    color: var(--primary-color, #6366f1);
    border-radius: 4px;
}

.storygrid-card-twin-badge i {
    width: 10px;
    height: 10px;
}

/* Badges de liaison sur les cards */
.storygrid-card-badges {
    display: flex;
    gap: 4px;
    flex-wrap: wrap;
    margin-top: 6px;
}

.card-badge {
    display: inline-flex;
    align-items: center;
    gap: 2px;
    padding: 2px 5px;
    font-size: 9px;
    font-weight: 600;
    border-radius: 8px;
    color: white;
}

.card-badge i {
    width: 9px;
    height: 9px;
}

.card-badge-character {
    background: #3498db;
}

.card-badge-arc {
    background: #e74c3c;
}

.card-badge-location {
    background: #27ae60;
}

/* ============================================
   CARD DETAIL MODAL - LIENS SECTION
   ============================================ */

.storygrid-card-links-section {
    margin-top: 24px;
    padding-top: 24px;
    border-top: 1px solid var(--border-color, #e0e0e0);
}

.section-title {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 14px;
    font-weight: 600;
    margin-bottom: 16px;
    color: var(--text-primary, #1a1a2e);
}

.section-title i {
    width: 18px;
    height: 18px;
    color: var(--primary-color, #6366f1);
}

.storygrid-links-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 16px;
}

@media (max-width: 768px) {
    .storygrid-links-grid {
        grid-template-columns: 1fr;
    }
}

.storygrid-link-group {
    background: var(--bg-secondary, #f8f9fa);
    border-radius: 8px;
    padding: 12px;
}

.storygrid-link-group-header {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 10px;
    font-size: 12px;
    font-weight: 600;
    color: var(--text-secondary, #666);
}

.storygrid-link-group-header i {
    width: 16px;
    height: 16px;
}

.storygrid-link-group-header .btn {
    margin-left: auto;
}

.storygrid-link-group-items {
    display: flex;
    flex-direction: column;
    gap: 6px;
    min-height: 40px;
}

.storygrid-link-tag {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    padding: 6px 10px;
    background: var(--bg-primary, #fff);
    border-radius: 6px;
    border-left: 3px solid var(--tag-color, #6366f1);
    font-size: 12px;
    transition: background 0.2s ease;
}

.storygrid-link-tag:hover {
    background: var(--bg-hover, #f5f5f5);
}

.storygrid-link-tag span {
    flex: 1;
}

.tag-remove {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 18px;
    height: 18px;
    border: none;
    background: transparent;
    border-radius: 4px;
    cursor: pointer;
    color: var(--text-muted, #999);
    transition: all 0.2s ease;
}

.tag-remove:hover {
    background: var(--danger-color, #ef4444);
    color: white;
}

.tag-remove i {
    width: 12px;
    height: 12px;
}

.storygrid-no-links {
    font-size: 12px;
    color: var(--text-muted, #999);
    font-style: italic;
    padding: 8px 0;
}

/* Liste d'ajout de liaison */
.storygrid-add-link-list {
    display: flex;
    flex-direction: column;
    gap: 4px;
    max-height: 300px;
    overflow-y: auto;
}

.storygrid-add-link-item {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 10px 12px;
    border-radius: 8px;
    cursor: pointer;
    transition: background 0.2s ease;
}

.storygrid-add-link-item:hover {
    background: var(--bg-hover, #f5f5f5);
}

.storygrid-add-link-item .item-icon {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 32px;
    height: 32px;
    border-radius: 8px;
}

.storygrid-add-link-item .item-icon i {
    width: 18px;
    height: 18px;
}

.storygrid-add-link-item span {
    flex: 1;
    font-size: 14px;
}

/* Boutons ghost */
.btn-ghost {
    background: transparent;
    border: none;
    color: var(--text-secondary, #666);
    padding: 4px 8px;
    cursor: pointer;
    border-radius: 4px;
    transition: all 0.2s ease;
}

.btn-ghost:hover {
    background: var(--bg-hover, #f5f5f5);
    color: var(--primary-color, #6366f1);
}

.btn-xs {
    padding: 4px 8px;
    font-size: 11px;
}

/* ============================================
   SVG LINKS
   ============================================ */

.storygrid-links-svg {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 5;
}

.storygrid-link-path {
    pointer-events: stroke;
    cursor: pointer;
    transition: stroke-width 0.2s ease;
}

.storygrid-link-path:hover {
    stroke-width: 4;
}

/* ============================================
   CONTEXT MENU
   ============================================ */

.storygrid-context-menu {
    position: fixed;
    background: var(--bg-primary, #fff);
    border-radius: 8px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.15);
    padding: 4px;
    min-width: 160px;
    z-index: 1000;
}

.context-menu-item {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 10px 12px;
    font-size: 13px;
    color: var(--text-primary, #1a1a2e);
    cursor: pointer;
    border-radius: 6px;
    transition: all 0.15s ease;
}

.context-menu-item:hover {
    background: var(--bg-hover, #f5f5f5);
}

.context-menu-item.danger {
    color: var(--danger-color, #ef4444);
}

.context-menu-item.danger:hover {
    background: #fef2f2;
}

.context-menu-item i {
    width: 16px;
    height: 16px;
}

.context-menu-divider {
    height: 1px;
    background: var(--border-color, #e0e0e0);
    margin: 4px 8px;
}

/* ============================================
   ADD ROW MODAL
   ============================================ */

.storygrid-row-type-selector {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 8px;
    margin-top: 8px;
}

.storygrid-row-type-option {
    cursor: pointer;
}

.storygrid-row-type-option input {
    display: none;
}

.storygrid-row-type-card {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
    padding: 16px 12px;
    border: 2px solid var(--border-color, #e0e0e0);
    border-radius: 8px;
    transition: all 0.2s ease;
}

.storygrid-row-type-option input:checked + .storygrid-row-type-card {
    border-color: var(--primary-color, #6366f1);
    background: var(--primary-color-light, #e0e7ff);
}

.storygrid-row-type-card:hover {
    border-color: var(--primary-color, #6366f1);
}

.storygrid-row-type-card i {
    width: 24px;
    height: 24px;
}

.storygrid-row-type-card span {
    font-size: 12px;
    font-weight: 500;
}

/* ============================================
   CARD DETAIL MODAL
   ============================================ */

.storygrid-card-modal {
    max-width: 800px !important;
}

.storygrid-card-title-input {
    width: 100%;
    padding: 4px 0;
    border: none;
    border-bottom: 2px solid transparent;
    font-size: 18px;
    font-weight: 600;
    background: transparent;
    color: var(--text-primary, #1a1a2e);
    outline: none;
    transition: border-color 0.2s ease;
}

.storygrid-card-title-input:focus {
    border-bottom-color: var(--primary-color, #6366f1);
}

.storygrid-card-detail-grid {
    display: grid;
    grid-template-columns: 1fr 250px;
    gap: 24px;
}

.storygrid-card-detail-main {
    display: flex;
    flex-direction: column;
    gap: 16px;
}

.storygrid-card-detail-side {
    display: flex;
    flex-direction: column;
    gap: 16px;
    padding-left: 24px;
    border-left: 1px solid var(--border-color, #e0e0e0);
}

/* Intensity Selector */
.storygrid-intensity-selector {
    display: flex;
    gap: 4px;
}

.intensity-btn {
    width: 36px;
    height: 36px;
    display: flex;
    align-items: center;
    justify-content: center;
    border: 2px solid var(--border-color, #e0e0e0);
    background: var(--bg-primary, #fff);
    border-radius: 8px;
    font-size: 14px;
    font-weight: 600;
    color: var(--text-secondary, #666);
    cursor: pointer;
    transition: all 0.2s ease;
}

.intensity-btn:hover {
    border-color: var(--primary-color, #6366f1);
    color: var(--primary-color, #6366f1);
}

.intensity-btn.active {
    background: var(--primary-color, #6366f1);
    border-color: var(--primary-color, #6366f1);
    color: white;
}

/* Color Picker */
.storygrid-color-picker {
    display: flex;
    gap: 8px;
    align-items: center;
}

.storygrid-color-picker input[type="color"] {
    width: 48px;
    height: 36px;
    padding: 0;
    border: 2px solid var(--border-color, #e0e0e0);
    border-radius: 6px;
    cursor: pointer;
}

/* Card Links */
.storygrid-card-links {
    display: flex;
    flex-direction: column;
    gap: 8px;
    margin-bottom: 8px;
}

.storygrid-no-links {
    font-size: 12px;
    color: var(--text-muted, #999);
    font-style: italic;
}

.storygrid-link-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 8px 10px;
    background: var(--bg-tertiary, #f0f0f0);
    border-radius: 6px;
    border-left: 3px solid;
}

.storygrid-link-info {
    display: flex;
    flex-direction: column;
    gap: 2px;
}

.storygrid-link-type {
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: var(--text-secondary, #666);
}

.storygrid-link-target {
    font-size: 12px;
    font-weight: 500;
    color: var(--text-primary, #1a1a2e);
}

.storygrid-link-remove {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 24px;
    height: 24px;
    border: none;
    background: transparent;
    border-radius: 4px;
    cursor: pointer;
    color: var(--text-muted, #999);
    transition: all 0.2s ease;
}

.storygrid-link-remove:hover {
    background: var(--danger-color, #ef4444);
    color: white;
}

.storygrid-link-remove i {
    width: 14px;
    height: 14px;
}

/* ============================================
   TOGGLE LABEL
   ============================================ */

.toggle-label {
    display: flex;
    align-items: center;
    gap: 10px;
    cursor: pointer;
    font-size: 13px;
}

.toggle-label input[type="checkbox"] {
    width: 18px;
    height: 18px;
    accent-color: var(--primary-color, #6366f1);
}

/* ============================================
   RESPONSIVE
   ============================================ */

@media (max-width: 768px) {
    .storygrid-toolbar {
        flex-wrap: wrap;
        gap: 12px;
    }
    
    .storygrid-toolbar-left,
    .storygrid-toolbar-center,
    .storygrid-toolbar-right {
        flex: 1 1 100%;
        justify-content: center;
    }
    
    .storygrid-row-headers {
        width: 160px;
        min-width: 160px;
    }
    
    .storygrid-card-detail-grid {
        grid-template-columns: 1fr;
    }
    
    .storygrid-card-detail-side {
        padding-left: 0;
        padding-top: 16px;
        border-left: none;
        border-top: 1px solid var(--border-color, #e0e0e0);
    }
}

/* ============================================
   DARK MODE SUPPORT
   ============================================ */

[data-theme="dark"] .storygrid-container {
    background: var(--bg-secondary);
}

[data-theme="dark"] .storygrid-toolbar,
[data-theme="dark"] .storygrid-row-headers,
[data-theme="dark"] .storygrid-column-header,
[data-theme="dark"] .storygrid-cell,
[data-theme="dark"] .storygrid-card,
[data-theme="dark"] .storygrid-context-menu {
    background: var(--bg-primary);
}

[data-theme="dark"] .storygrid-card {
    box-shadow: 0 1px 3px rgba(0,0,0,0.3);
}

[data-theme="dark"] .storygrid-card:hover {
    box-shadow: 0 4px 12px rgba(0,0,0,0.4);
}

[data-theme="dark"] .storygrid-cell.drag-over {
    background: rgba(99, 102, 241, 0.2);
}

[data-theme="dark"] .storygrid-row-header.drag-over {
    background: rgba(99, 102, 241, 0.2);
}

/* ============================================
   ANIMATIONS
   ============================================ */

@keyframes cardPulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.02); }
}

.storygrid-card.highlight {
    animation: cardPulse 0.3s ease;
}

@keyframes fadeIn {
    from { opacity: 0; transform: translateY(-10px); }
    to { opacity: 1; transform: translateY(0); }
}

.storygrid-context-menu {
    animation: fadeIn 0.15s ease;
}

/* ============================================
   AUTO-CARD NAVIGATION BUTTON
   ============================================ */

.storygrid-auto-card {
    position: relative;
}

.storygrid-auto-nav {
    position: absolute;
    top: 4px;
    left: 4px;
    width: 22px;
    height: 22px;
    border: none;
    background: var(--bg-primary, #fff);
    border-radius: 4px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0;
    transition: all 0.2s ease;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    z-index: 2;
}

.storygrid-auto-card:hover .storygrid-auto-nav {
    opacity: 1;
}

.storygrid-auto-nav:hover {
    background: var(--primary-color, #6366f1);
    color: white;
}

.storygrid-auto-nav i {
    width: 14px;
    height: 14px;
}

/* ============================================
   CELLS WITH CONTENT (COLORED BACKGROUND)
   ============================================ */

.storygrid-cell.has-content {
    transition: all 0.2s ease;
}

.storygrid-cell.has-content:hover {
    z-index: 2;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

/* ============================================
   SCENE NAVIGATION MODAL
   ============================================ */

.scene-nav-options {
    display: flex;
    flex-direction: column;
    gap: 12px;
}

.scene-nav-option {
    display: flex;
    align-items: flex-start;
    gap: 16px;
    padding: 16px;
    border: 2px solid var(--border-color, #e0e0e0);
    border-radius: 12px;
    cursor: pointer;
    transition: all 0.2s ease;
}

.scene-nav-option:hover {
    border-color: var(--primary-color, #6366f1);
    background: var(--bg-hover, #f5f5f5);
}

.scene-nav-option-icon {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 40px;
    height: 40px;
    border-radius: 10px;
    background: var(--bg-tertiary, #f0f0f0);
    flex-shrink: 0;
}

.scene-nav-option-icon i {
    width: 20px;
    height: 20px;
}

.scene-nav-option-content {
    flex: 1;
}

.scene-nav-option-title {
    font-size: 14px;
    font-weight: 600;
    color: var(--text-primary, #1a1a2e);
    margin-bottom: 4px;
}

.scene-nav-option-desc {
    font-size: 12px;
    color: var(--text-secondary, #666);
    line-height: 1.4;
}

/* Dark mode support for navigation */
[data-theme="dark"] .storygrid-auto-nav {
    background: var(--bg-secondary);
}

[data-theme="dark"] .scene-nav-option:hover {
    background: var(--bg-tertiary);
}

/* ========== 12.arc-board.css ========== */
/* ============================================
   ARC BOARD - Canvas Style (Milanote-inspired)
   ============================================ */

/* ============================================
   SIDEBAR TREEVIEW
   ============================================ */

.sidebar-tree-category {
    margin-bottom: 4px;
}

.sidebar-tree-header {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 12px;
    cursor: pointer;
    border-radius: 6px;
    transition: background 0.15s ease;
}

.sidebar-tree-header:hover {
    background: var(--bg-secondary);
}

.sidebar-tree-toggle {
    width: 16px;
    height: 16px;
    display: flex;
    align-items: center;
    justify-content: center;
    color: var(--text-muted);
}

.sidebar-tree-toggle svg {
    width: 14px;
    height: 14px;
}

.sidebar-tree-icon {
    width: 18px;
    height: 18px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.sidebar-tree-icon svg {
    width: 16px;
    height: 16px;
}

.sidebar-tree-label {
    flex: 1;
    font-family: 'Inter', sans-serif;
    font-size: 13px;
    font-weight: 500;
    color: var(--text-primary);
}

.sidebar-tree-count {
    font-family: 'Inter', sans-serif;
    font-size: 11px;
    color: var(--text-muted);
    background: var(--bg-tertiary);
    padding: 2px 6px;
    border-radius: 10px;
}

.sidebar-tree-children {
    margin-left: 24px;
    overflow: hidden;
    transition: max-height 0.3s ease;
}

.sidebar-tree-children.collapsed {
    max-height: 0;
    opacity: 0;
}

.sidebar-tree-item {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 6px 12px;
    cursor: pointer;
    border-radius: 6px;
    transition: background 0.15s ease;
    margin-bottom: 2px;
}

.sidebar-tree-item:hover {
    background: var(--bg-secondary);
}

.sidebar-tree-item.active {
    background: var(--primary-color);
}

.sidebar-tree-item.active .sidebar-tree-item-title {
    color: white;
}

.sidebar-tree-item.active .sidebar-tree-item-menu {
    color: rgba(255, 255, 255, 0.7);
}

.sidebar-tree-item-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    flex-shrink: 0;
}

.sidebar-tree-item-title {
    flex: 1;
    font-family: 'Inter', sans-serif;
    font-size: 13px;
    color: var(--text-primary);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.sidebar-tree-item-menu {
    width: 24px;
    height: 24px;
    border: none;
    background: transparent;
    border-radius: 4px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    color: var(--text-muted);
    opacity: 0;
    transition: opacity 0.15s ease;
}

.sidebar-tree-item:hover .sidebar-tree-item-menu {
    opacity: 1;
}

.sidebar-tree-item-menu:hover {
    background: var(--bg-tertiary);
    color: var(--text-primary);
}

.sidebar-tree-item-menu svg {
    width: 14px;
    height: 14px;
}

.sidebar-tree-add {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 10px 12px;
    cursor: pointer;
    color: var(--text-muted);
    font-family: 'Inter', sans-serif;
    font-size: 13px;
    border-radius: 6px;
    margin-top: 8px;
    border: 1px dashed var(--border-color);
    transition: all 0.15s ease;
}

.sidebar-tree-add:hover {
    background: var(--bg-secondary);
    border-color: var(--primary-color);
    color: var(--primary-color);
}

.sidebar-tree-add svg {
    width: 16px;
    height: 16px;
}

/* Card add button inside column */
.arc-card-add {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
    padding: 12px;
    color: var(--text-muted);
    font-family: 'Inter', sans-serif;
    font-size: 12px;
    cursor: pointer;
    border: 1px dashed var(--border-color);
    border-radius: 6px;
    transition: all 0.15s ease;
    margin-top: 4px;
}

.arc-card-add:hover {
    background: var(--bg-secondary);
    border-color: var(--primary-color);
    color: var(--primary-color);
}

.arc-card-add svg {
    width: 14px;
    height: 14px;
}

/* ============================================
   LAYOUT PRINCIPAL
   ============================================ */

.arc-board-container {
    display: flex;
    flex: 1;
    height: 100%;
    overflow: hidden;
    background: var(--bg-secondary);
}

/* ============================================
   TOOLBAR GAUCHE (Outils de création)
   ============================================ */

.arc-board-toolbar {
    width: 56px;
    background: var(--bg-primary);
    border-right: 1px solid var(--border-color);
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 12px 0;
    gap: 4px;
    flex-shrink: 0;
    z-index: 100;
}

.arc-toolbar-btn {
    width: 40px;
    height: 40px;
    border: none;
    background: transparent;
    border-radius: 8px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    color: var(--text-secondary);
    transition: all 0.2s ease;
    position: relative;
}

.arc-toolbar-btn:hover {
    background: var(--bg-secondary);
    color: var(--text-primary);
}

.arc-toolbar-btn.active {
    background: var(--primary-color);
    color: white;
}

.arc-toolbar-btn svg {
    width: 20px;
    height: 20px;
}

.arc-toolbar-btn[data-tooltip]::after {
    content: attr(data-tooltip);
    position: absolute;
    left: calc(100% + 8px);
    top: 50%;
    transform: translateY(-50%);
    background: var(--bg-accent);
    color: white;
    padding: 6px 10px;
    border-radius: 6px;
    font-size: 12px;
    font-family: 'Inter', sans-serif;
    white-space: nowrap;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.2s ease;
    z-index: 1000;
}

.arc-toolbar-btn:hover[data-tooltip]::after {
    opacity: 1;
}

.arc-toolbar-separator {
    width: 32px;
    height: 1px;
    background: var(--border-color);
    margin: 8px 0;
}

/* ============================================
   CANVAS PRINCIPAL
   ============================================ */

.arc-board-canvas-wrapper {
    flex: 1;
    position: relative;
    overflow: hidden;
    background: var(--bg-secondary);
}

.arc-board-canvas {
    position: absolute;
    width: 100%;
    height: 100%;
    overflow: auto;
    cursor: grab;
    /* Grille de fond style Milanote */
    background-image: 
        radial-gradient(circle, var(--border-color) 1px, transparent 1px);
    background-size: 24px 24px;
    background-position: 0 0;
}

.arc-board-canvas.dragging {
    cursor: grabbing;
}

.arc-board-canvas.connecting {
    cursor: crosshair;
}

.arc-board-content {
    position: relative;
    min-width: 3000px;
    min-height: 2000px;
    padding: 40px;
}

/* Layer SVG pour les connexions */
.arc-connections-layer {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 1;
}

.arc-connections-layer svg {
    width: 100%;
    height: 100%;
}

.arc-connection-line {
    stroke: var(--text-muted);
    stroke-width: 2;
    fill: none;
    pointer-events: stroke;
    cursor: pointer;
}

.arc-connection-line:hover {
    stroke: var(--primary-color);
    stroke-width: 3;
}

.arc-connection-line.selected {
    stroke: var(--primary-color);
    stroke-width: 3;
}

.arc-connection-arrow {
    fill: var(--text-muted);
}

.arc-connection-temp {
    stroke: var(--primary-color);
    stroke-width: 2;
    stroke-dasharray: 8 4;
    fill: none;
}

/* ============================================
   COLONNES (Boards)
   ============================================ */

.arc-column {
    position: absolute;
    background: var(--bg-primary);
    border-radius: 12px;
    box-shadow: 0 2px 8px var(--shadow), 0 0 0 1px var(--border-color);
    min-width: 200px;
    max-width: 500px;
    display: flex;
    flex-direction: column;
    z-index: 10;
    transition: box-shadow 0.2s ease;
}

.arc-column:hover {
    box-shadow: 0 4px 16px var(--shadow), 0 0 0 1px var(--border-color);
}

.arc-column.selected {
    box-shadow: 0 4px 16px var(--shadow), 0 0 0 2px var(--primary-color);
}

.arc-column.dragging {
    opacity: 0.9;
    z-index: 1000;
    cursor: grabbing;
}

.arc-column-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 12px 16px;
    border-bottom: 1px solid var(--border-color);
    cursor: grab;
    background: var(--bg-primary);
    border-radius: 12px 12px 0 0;
}

.arc-column-header:active {
    cursor: grabbing;
}

.arc-column-title {
    font-family: 'Inter', sans-serif;
    font-size: 14px;
    font-weight: 600;
    color: var(--text-primary);
    flex: 1;
    border: none;
    background: transparent;
    outline: none;
    padding: 4px 0;
}

.arc-column-title:focus {
    background: var(--bg-secondary);
    padding: 4px 8px;
    margin: -4px -8px;
    border-radius: 4px;
}

.arc-column-meta {
    font-family: 'Inter', sans-serif;
    font-size: 11px;
    color: var(--text-muted);
    margin-left: 8px;
}

.arc-column-arrow {
    color: var(--text-muted);
    margin-left: 12px;
}

.arc-column-arrow svg {
    width: 16px;
    height: 16px;
}

.arc-column-body {
    flex: 1;
    padding: 8px;
    display: flex;
    flex-direction: column;
    gap: 8px;
    overflow-y: auto;
    max-height: 600px;
}

/* Resize handle */
.arc-column-resize {
    position: absolute;
    right: 0;
    top: 0;
    bottom: 0;
    width: 8px;
    cursor: ew-resize;
    background: transparent;
}

.arc-column-resize:hover {
    background: linear-gradient(to right, transparent, rgba(255, 140, 66, 0.2));
}

/* ============================================
   CARTES (Items dans les colonnes)
   ============================================ */

.arc-card {
    background: var(--bg-primary);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 12px;
    cursor: pointer;
    transition: all 0.2s ease;
    position: relative;
}

.arc-card:hover {
    border-color: var(--primary-color);
    box-shadow: 0 2px 8px var(--shadow);
}

.arc-card.selected {
    border-color: var(--primary-color);
    box-shadow: 0 0 0 2px rgba(255, 140, 66, 0.2);
}

.arc-card.dragging {
    opacity: 0.7;
    transform: rotate(2deg);
}

/* Bouton de suppression de carte */
.arc-card-delete {
    position: absolute;
    top: 4px;
    right: 4px;
    width: 22px;
    height: 22px;
    border: none;
    background: var(--bg-secondary);
    border-radius: 4px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    color: var(--text-muted);
    opacity: 0;
    transition: all 0.15s ease;
    z-index: 10;
}

.arc-card:hover .arc-card-delete {
    opacity: 1;
}

.arc-card-delete:hover {
    background: var(--error-color);
    color: white;
}

.arc-card-delete svg {
    width: 14px;
    height: 14px;
}

/* Card type: Note/Text */
.arc-card-note .arc-card-content {
    font-family: 'Crimson Pro', serif;
    font-size: 15px;
    line-height: 1.6;
    color: var(--text-primary);
    min-height: 40px;
}

.arc-card-note .arc-card-content:empty::before {
    content: 'Commencez à écrire...';
    color: var(--text-muted);
}

.arc-card-note .arc-card-content[contenteditable="true"]:focus {
    outline: none;
}

/* Card type: Image */
.arc-card-image {
    padding: 0;
    overflow: hidden;
}

.arc-card-image img {
    width: 100%;
    display: block;
    border-radius: 7px;
}

.arc-card-image .arc-card-upload {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 32px 16px;
    color: var(--text-muted);
    gap: 8px;
}

.arc-card-image .arc-card-upload svg {
    width: 32px;
    height: 32px;
    opacity: 0.5;
}

.arc-card-image .arc-card-caption {
    padding: 8px 12px;
    font-family: 'Inter', sans-serif;
    font-size: 12px;
    color: var(--text-secondary);
    border-top: 1px solid var(--border-color);
}

/* Card type: Link */
.arc-card-link {
    padding: 0;
}

.arc-card-link .arc-link-input {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 12px;
    color: var(--text-muted);
}

.arc-card-link .arc-link-input svg {
    width: 16px;
    height: 16px;
    flex-shrink: 0;
}

.arc-card-link .arc-link-input input {
    flex: 1;
    border: none;
    background: transparent;
    font-family: 'Inter', sans-serif;
    font-size: 13px;
    color: var(--text-primary);
    outline: none;
}

.arc-card-link .arc-link-input input::placeholder {
    color: var(--text-muted);
}

.arc-card-link .arc-link-preview {
    display: flex;
    flex-direction: column;
}

.arc-card-link .arc-link-preview-image {
    height: 120px;
    background: var(--bg-secondary);
    background-size: cover;
    background-position: center;
    border-radius: 7px 7px 0 0;
}

.arc-card-link .arc-link-preview-info {
    padding: 12px;
}

.arc-card-link .arc-link-preview-title {
    font-family: 'Inter', sans-serif;
    font-size: 13px;
    font-weight: 500;
    color: var(--text-primary);
    margin-bottom: 4px;
}

.arc-card-link .arc-link-preview-url {
    font-family: 'Inter', sans-serif;
    font-size: 11px;
    color: var(--text-muted);
}

/* Card type: To-do */
.arc-card-todo .arc-card-title {
    font-family: 'Inter', sans-serif;
    font-size: 14px;
    font-weight: 600;
    color: var(--text-primary);
    margin-bottom: 12px;
    border: none;
    background: transparent;
    width: 100%;
    outline: none;
}

.arc-card-todo .arc-todo-list {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.arc-card-todo .arc-todo-item {
    display: flex;
    align-items: flex-start;
    gap: 8px;
}

.arc-card-todo .arc-todo-checkbox {
    width: 18px;
    height: 18px;
    border: 2px solid var(--border-color);
    border-radius: 4px;
    cursor: pointer;
    flex-shrink: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-top: 2px;
    transition: all 0.2s ease;
}

.arc-card-todo .arc-todo-checkbox:hover {
    border-color: var(--primary-color);
}

.arc-card-todo .arc-todo-checkbox.checked {
    background: var(--accent-green);
    border-color: var(--accent-green);
}

.arc-card-todo .arc-todo-checkbox.checked svg {
    color: white;
    width: 12px;
    height: 12px;
}

.arc-card-todo .arc-todo-text {
    flex: 1;
    font-family: 'Inter', sans-serif;
    font-size: 13px;
    color: var(--text-primary);
    border: none;
    background: transparent;
    outline: none;
    line-height: 1.5;
}

.arc-card-todo .arc-todo-text.completed {
    text-decoration: line-through;
    color: var(--text-muted);
}

.arc-card-todo .arc-todo-add {
    display: flex;
    align-items: center;
    gap: 8px;
    color: var(--text-muted);
    font-family: 'Inter', sans-serif;
    font-size: 13px;
    cursor: pointer;
    padding: 4px 0;
    margin-top: 4px;
}

.arc-card-todo .arc-todo-add:hover {
    color: var(--primary-color);
}

.arc-card-todo .arc-todo-assign {
    font-family: 'Inter', sans-serif;
    font-size: 11px;
    color: var(--text-muted);
    border: 1px solid var(--border-color);
    border-radius: 4px;
    padding: 4px 8px;
    background: transparent;
    cursor: pointer;
    margin-top: 8px;
}

.arc-card-todo .arc-todo-assign:hover {
    border-color: var(--primary-color);
    color: var(--primary-color);
}

/* Card type: Comment */
.arc-card-comment {
    background: #fffde7;
    border-color: #fff59d;
}

.arc-card-comment .arc-card-content {
    font-family: 'Inter', sans-serif;
    font-size: 13px;
    line-height: 1.5;
    color: var(--text-primary);
}

/* Card type: Table */
.arc-card-table {
    padding: 0;
    overflow: hidden;
}

.arc-card-table table {
    width: 100%;
    border-collapse: collapse;
    font-family: 'Inter', sans-serif;
    font-size: 12px;
}

.arc-card-table th,
.arc-card-table td {
    padding: 8px 12px;
    border: 1px solid var(--border-color);
    text-align: left;
}

.arc-card-table th {
    background: var(--bg-secondary);
    font-weight: 600;
}

.arc-card-table td[contenteditable="true"]:focus {
    background: var(--bg-secondary);
    outline: none;
}

/* Card type: Audio embed */
.arc-card-audio {
    padding: 12px;
}

.arc-card-audio .arc-audio-placeholder {
    display: flex;
    align-items: center;
    gap: 12px;
    color: var(--text-muted);
    font-family: 'Inter', sans-serif;
    font-size: 13px;
}

.arc-card-audio .arc-audio-placeholder svg {
    width: 24px;
    height: 24px;
    color: #1DB954;
}

/* Card type: Separator/Divider */
.arc-card-divider {
    padding: 16px 12px;
    text-align: center;
}

.arc-card-divider hr {
    border: none;
    border-top: 2px solid var(--border-color);
}

/* ============================================
   ITEMS FLOTTANTS (hors colonnes)
   ============================================ */

.arc-floating-item {
    position: absolute;
    z-index: 5;
    cursor: move;
}

.arc-floating-item.selected {
    z-index: 50;
}

.arc-floating-note {
    background: var(--bg-primary);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 16px;
    min-width: 200px;
    max-width: 400px;
    box-shadow: 0 2px 8px var(--shadow);
}

.arc-floating-note:hover,
.arc-floating-note.selected {
    border-color: var(--primary-color);
}

.arc-floating-image {
    background: var(--bg-primary);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 2px 8px var(--shadow);
}

.arc-floating-image img {
    display: block;
    max-width: 400px;
}

/* ============================================
   PANNEAU CONTEXTUEL (droite)
   ============================================ */

.arc-board-context-panel {
    width: 280px;
    background: var(--bg-primary);
    border-left: 1px solid var(--border-color);
    display: flex;
    flex-direction: column;
    flex-shrink: 0;
    transition: width 0.3s ease;
    overflow: hidden;
}

.arc-board-context-panel.collapsed {
    width: 0;
    border-left: none;
}

.arc-context-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 16px;
    border-bottom: 1px solid var(--border-color);
}

.arc-context-title {
    font-family: 'Inter', sans-serif;
    font-size: 13px;
    font-weight: 600;
    color: var(--text-primary);
    display: flex;
    align-items: center;
    gap: 8px;
}

.arc-context-title svg {
    width: 16px;
    height: 16px;
    color: var(--primary-color);
}

.arc-context-close {
    width: 28px;
    height: 28px;
    border: none;
    background: transparent;
    border-radius: 6px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    color: var(--text-muted);
}

.arc-context-close:hover {
    background: var(--bg-secondary);
    color: var(--text-primary);
}

.arc-context-body {
    flex: 1;
    overflow-y: auto;
    padding: 16px;
}

/* Context tools */
.arc-context-section {
    margin-bottom: 20px;
}

.arc-context-section-title {
    font-family: 'Inter', sans-serif;
    font-size: 11px;
    font-weight: 600;
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 12px;
}

.arc-context-tools {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
}

.arc-context-tool {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 4px;
    padding: 12px;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    background: var(--bg-primary);
    cursor: pointer;
    transition: all 0.2s ease;
    width: calc(50% - 4px);
}

.arc-context-tool:hover {
    border-color: var(--primary-color);
    background: var(--bg-secondary);
}

.arc-context-tool svg {
    width: 20px;
    height: 20px;
    color: var(--text-secondary);
}

.arc-context-tool span {
    font-family: 'Inter', sans-serif;
    font-size: 11px;
    color: var(--text-secondary);
}

/* Text formatting tools */
.arc-context-format-bar {
    display: flex;
    gap: 4px;
    flex-wrap: wrap;
}

.arc-format-btn {
    width: 32px;
    height: 32px;
    border: 1px solid var(--border-color);
    background: var(--bg-primary);
    border-radius: 6px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    color: var(--text-secondary);
    transition: all 0.2s ease;
}

.arc-format-btn:hover {
    border-color: var(--primary-color);
    color: var(--primary-color);
}

.arc-format-btn.active {
    background: var(--primary-color);
    border-color: var(--primary-color);
    color: white;
}

.arc-format-btn svg {
    width: 16px;
    height: 16px;
}

/* Color picker in context */
.arc-context-colors {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
}

.arc-color-swatch {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    cursor: pointer;
    border: 2px solid transparent;
    transition: all 0.2s ease;
}

.arc-color-swatch:hover {
    transform: scale(1.1);
}

.arc-color-swatch.selected {
    border-color: var(--text-primary);
}

/* Delete button */
.arc-context-delete {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    padding: 12px;
    border: 1px solid var(--error-color);
    border-radius: 8px;
    background: transparent;
    color: var(--error-color);
    cursor: pointer;
    font-family: 'Inter', sans-serif;
    font-size: 13px;
    width: 100%;
    transition: all 0.2s ease;
}

.arc-context-delete:hover {
    background: var(--error-color);
    color: white;
}

/* ============================================
   ZOOM CONTROLS
   ============================================ */

.arc-zoom-controls {
    position: absolute;
    bottom: 20px;
    right: 20px;
    display: flex;
    align-items: center;
    gap: 4px;
    background: var(--bg-primary);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 4px;
    box-shadow: 0 2px 8px var(--shadow);
    z-index: 100;
}

.arc-zoom-btn {
    width: 32px;
    height: 32px;
    border: none;
    background: transparent;
    border-radius: 6px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    color: var(--text-secondary);
}

.arc-zoom-btn:hover {
    background: var(--bg-secondary);
    color: var(--text-primary);
}

.arc-zoom-btn svg {
    width: 18px;
    height: 18px;
}

.arc-zoom-level {
    font-family: 'Inter', sans-serif;
    font-size: 12px;
    color: var(--text-secondary);
    padding: 0 8px;
    min-width: 50px;
    text-align: center;
}

/* ============================================
   MINIMAP
   ============================================ */

.arc-minimap {
    position: absolute;
    bottom: 70px;
    right: 20px;
    width: 150px;
    height: 100px;
    background: var(--bg-primary);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 2px 8px var(--shadow);
    z-index: 100;
}

.arc-minimap-content {
    width: 100%;
    height: 100%;
    position: relative;
}

.arc-minimap-item {
    position: absolute;
    background: var(--primary-color);
    border-radius: 2px;
    opacity: 0.6;
}

.arc-minimap-viewport {
    position: absolute;
    border: 2px solid var(--primary-color);
    background: rgba(255, 140, 66, 0.1);
    border-radius: 2px;
}

/* ============================================
   EMPTY STATE
   ============================================ */

.arc-board-empty {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    text-align: center;
    color: var(--text-muted);
    pointer-events: none;
}

.arc-board-empty-icon {
    width: 64px;
    height: 64px;
    margin: 0 auto 16px;
    opacity: 0.3;
}

.arc-board-empty-icon svg {
    width: 100%;
    height: 100%;
}

.arc-board-empty-title {
    font-family: 'Inter', sans-serif;
    font-size: 16px;
    font-weight: 600;
    margin-bottom: 8px;
    color: var(--text-secondary);
}

.arc-board-empty-text {
    font-family: 'Inter', sans-serif;
    font-size: 13px;
    line-height: 1.5;
}

/* ============================================
   SELECTION BOX (multi-select)
   ============================================ */

.arc-selection-box {
    position: absolute;
    border: 2px dashed var(--primary-color);
    background: rgba(255, 140, 66, 0.1);
    pointer-events: none;
    z-index: 1000;
}

/* ============================================
   DRAG & DROP BIDIRECTIONNEL
   ============================================ */

/* Zone de drop sur les colonnes */
.arc-column-body.drop-target {
    background: rgba(255, 140, 66, 0.05);
    border: 2px dashed var(--primary-color);
    border-radius: 8px;
    min-height: 100px;
}

.arc-column-body.drop-hover {
    background: rgba(255, 140, 66, 0.15);
    border-color: var(--primary-color);
    box-shadow: inset 0 0 20px rgba(255, 140, 66, 0.1);
}

/* Zone de drop sur le canvas (pour sortir les cartes) */
.arc-board-canvas.drop-hover {
    background: 
        radial-gradient(circle at center, rgba(255, 140, 66, 0.1) 0%, transparent 70%),
        radial-gradient(circle, var(--border-color) 1px, transparent 1px);
    background-size: 100% 100%, 24px 24px;
}

/* Éléments flottants en cours de drag */
.arc-floating-item.dragging {
    opacity: 0.6;
    transform: rotate(2deg);
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
    z-index: 1000;
}

/* Cartes en cours de drag */
.arc-card.dragging {
    opacity: 0.6;
    transform: rotate(2deg);
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
}

/* Indication visuelle sur les éléments draggables */
.arc-floating-item[draggable="true"],
.arc-card[draggable="true"] {
    cursor: grab;
}

.arc-floating-item[draggable="true"]:active,
.arc-card[draggable="true"]:active {
    cursor: grabbing;
}

/* ============================================
   CONNECTION MODE
   ============================================ */

.arc-board-canvas.connection-mode {
    cursor: crosshair;
}

.arc-connection-mode-hint {
    position: absolute;
    top: 16px;
    left: 50%;
    transform: translateX(-50%);
    background: var(--bg-accent);
    color: white;
    padding: 10px 20px;
    border-radius: 8px;
    display: flex;
    align-items: center;
    gap: 12px;
    font-family: 'Inter', sans-serif;
    font-size: 13px;
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
    z-index: 200;
}

.arc-connection-mode-hint svg {
    width: 18px;
    height: 18px;
    color: var(--primary-color);
}

.arc-connection-mode-hint button {
    display: flex;
    align-items: center;
    gap: 4px;
    padding: 4px 10px;
    background: rgba(255, 255, 255, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 4px;
    color: white;
    font-size: 12px;
    cursor: pointer;
    transition: all 0.15s ease;
}

.arc-connection-mode-hint button:hover {
    background: rgba(255, 255, 255, 0.2);
}

.arc-connection-mode-hint button svg {
    width: 14px;
    height: 14px;
    color: white;
}

/* Éléments connectables */
.arc-column.connectable,
.arc-floating-item.connectable {
    cursor: crosshair;
    box-shadow: 0 0 0 2px var(--primary-color), 0 4px 16px var(--shadow);
}

.arc-column.connection-source,
.arc-floating-item.connection-source {
    box-shadow: 0 0 0 3px var(--accent-green), 0 4px 16px var(--shadow);
}

.arc-column.connection-target,
.arc-floating-item.connection-target {
    cursor: crosshair;
}

.arc-column.connection-target:hover,
.arc-floating-item.connection-target:hover {
    box-shadow: 0 0 0 3px var(--primary-color), 0 4px 16px rgba(255, 140, 66, 0.3);
}

/* ============================================
   CONNECTION POINTS (removed - using click system now)
   ============================================ */

/* ============================================
   CONTEXT MENU
   ============================================ */

.arc-context-menu {
    position: fixed;
    background: var(--bg-primary);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    box-shadow: 0 4px 16px var(--shadow);
    padding: 8px 0;
    min-width: 180px;
    z-index: 10000;
}

.arc-context-menu-item {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 8px 16px;
    font-family: 'Inter', sans-serif;
    font-size: 13px;
    color: var(--text-primary);
    cursor: pointer;
    transition: background 0.15s ease;
}

.arc-context-menu-item:hover {
    background: var(--bg-secondary);
}

.arc-context-menu-item svg {
    width: 16px;
    height: 16px;
    color: var(--text-secondary);
}

.arc-context-menu-item.danger {
    color: var(--error-color);
}

.arc-context-menu-item.danger svg {
    color: var(--error-color);
}

.arc-context-menu-separator {
    height: 1px;
    background: var(--border-color);
    margin: 8px 0;
}

/* ============================================
   DRAG GHOST
   ============================================ */

.arc-drag-ghost {
    position: fixed;
    pointer-events: none;
    z-index: 10000;
    opacity: 0.8;
    transform: rotate(3deg);
}



/* ============================================
   FORMULAIRES INLINE SIDEBAR
   Ajouter à la fin de arc-board.css
   ============================================ */

.sidebar-inline-form {
    background: var(--bg-primary);
    border: 1px solid var(--primary-color);
    border-radius: 8px;
    margin-bottom: 12px;
    overflow: hidden;
    animation: slideDown 0.2s ease-out;
}

@keyframes slideDown {
    from {
        opacity: 0;
        transform: translateY(-10px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.sidebar-inline-form-header {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 10px 12px;
    background: var(--bg-secondary);
    border-bottom: 1px solid var(--border-color);
    font-family: 'Inter', sans-serif;
    font-size: 13px;
    font-weight: 600;
    color: var(--text-primary);
}

.sidebar-inline-form-header > i,
.sidebar-inline-form-header > svg {
    width: 16px;
    height: 16px;
    color: var(--primary-color);
}

.sidebar-inline-form-header span {
    flex: 1;
}

.sidebar-inline-form-close {
    width: 24px;
    height: 24px;
    border: none;
    background: transparent;
    border-radius: 4px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    color: var(--text-muted);
    transition: all 0.15s ease;
}

.sidebar-inline-form-close:hover {
    background: var(--bg-tertiary);
    color: var(--text-primary);
}

.sidebar-inline-form-close svg {
    width: 14px;
    height: 14px;
}

.sidebar-inline-form-body {
    padding: 12px;
}

.sidebar-inline-form-group {
    margin-bottom: 12px;
}

.sidebar-inline-form-group:last-of-type {
    margin-bottom: 0;
}

.sidebar-inline-form-group label {
    display: block;
    font-family: 'Inter', sans-serif;
    font-size: 11px;
    font-weight: 500;
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 6px;
}

.sidebar-inline-input {
    width: 100%;
    padding: 8px 10px;
    font-family: 'Inter', sans-serif;
    font-size: 13px;
    color: var(--text-primary);
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 6px;
    transition: all 0.15s ease;
}

.sidebar-inline-input:focus {
    outline: none;
    border-color: var(--primary-color);
    box-shadow: 0 0 0 3px rgba(255, 140, 66, 0.1);
}

.sidebar-inline-input.error {
    border-color: var(--error-color);
    box-shadow: 0 0 0 3px rgba(231, 76, 60, 0.1);
    animation: shake 0.3s ease;
}

@keyframes shake {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-4px); }
    75% { transform: translateX(4px); }
}

.sidebar-inline-input::placeholder {
    color: var(--text-muted);
}

.sidebar-inline-select {
    width: 100%;
    padding: 8px 10px;
    font-family: 'Inter', sans-serif;
    font-size: 13px;
    color: var(--text-primary);
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.15s ease;
}

.sidebar-inline-select:focus {
    outline: none;
    border-color: var(--primary-color);
    box-shadow: 0 0 0 3px rgba(255, 140, 66, 0.1);
}

.sidebar-inline-color-row {
    display: flex;
    align-items: center;
    gap: 10px;
}

.sidebar-inline-color {
    width: 36px;
    height: 36px;
    padding: 2px;
    border: 1px solid var(--border-color);
    border-radius: 6px;
    cursor: pointer;
    background: var(--bg-secondary);
}

.sidebar-inline-color::-webkit-color-swatch-wrapper {
    padding: 2px;
}

.sidebar-inline-color::-webkit-color-swatch {
    border-radius: 4px;
    border: none;
}

.sidebar-inline-color-hex {
    font-family: 'JetBrains Mono', monospace;
    font-size: 12px;
    color: var(--text-secondary);
}

.sidebar-inline-form-actions {
    display: flex;
    justify-content: flex-end;
    gap: 8px;
    margin-top: 16px;
    padding-top: 12px;
    border-top: 1px solid var(--border-color);
}

/* Boutons compacts pour la sidebar */
.btn-sm {
    padding: 6px 12px;
    font-size: 12px;
    border-radius: 6px;
}

.btn-sm svg,
.btn-sm i {
    width: 14px;
    height: 14px;
}

.btn-secondary.btn-sm {
    background: var(--bg-secondary);
    color: var(--text-secondary);
    border: 1px solid var(--border-color);
}

.btn-secondary.btn-sm:hover {
    background: var(--bg-tertiary);
    color: var(--text-primary);
}

.btn-primary.btn-sm {
    background: var(--primary-color);
    color: white;
    border: none;
    display: flex;
    align-items: center;
    gap: 4px;
}

.btn-primary.btn-sm:hover {
    background: var(--primary-hover);
}



/* ============================================
   RESPONSIVE
   ============================================ */

@media (max-width: 768px) {
    .arc-board-toolbar {
        width: 48px;
        padding: 8px 0;
    }
    
    .arc-toolbar-btn {
        width: 36px;
        height: 36px;
    }
    
    .arc-board-context-panel {
        position: absolute;
        right: 0;
        top: 0;
        bottom: 0;
        z-index: 200;
        box-shadow: -4px 0 16px var(--shadow);
    }
    
    .arc-zoom-controls {
        bottom: 10px;
        right: 10px;
    }
    
    .arc-minimap {
        display: none;
    }
}

/* ============================================
   ANIMATIONS
   ============================================ */

@keyframes arcItemAppear {
    from {
        opacity: 0;
        transform: scale(0.95);
    }
    to {
        opacity: 1;
        transform: scale(1);
    }
}

.arc-column,
.arc-floating-item {
    animation: arcItemAppear 0.2s ease;
}

/* ============================================
   PRINT STYLES
   ============================================ */

@media print {
    .arc-board-toolbar,
    .arc-board-context-panel,
    .arc-zoom-controls,
    .arc-minimap {
        display: none !important;
    }
    
    .arc-board-canvas {
        background: white !important;
    }
}


/* ========== 13.thriller-board.css ========== */
/* ============================================
   THRILLER BOARD - Canvas Style for Mystery Elements
   ============================================ */

/* ============================================
   MAIN CONTAINER
   ============================================ */

.thriller-board-container {
    display: flex;
    flex-direction: column;
    height: 100vh;
    background: var(--bg-primary);
}

/* ============================================
   TOOLBAR
   ============================================ */

.thriller-board-toolbar {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 12px 20px;
    background: var(--bg-secondary);
    border-bottom: 1px solid var(--border-color);
    gap: 20px;
}

.thriller-toolbar-left {
    display: flex;
    align-items: center;
    gap: 12px;
}

.thriller-toolbar-center {
    display: flex;
    align-items: center;
    gap: 8px;
}

.thriller-toolbar-right {
    display: flex;
    align-items: center;
    gap: 8px;
}

.thriller-filter select {
    padding: 6px 12px;
    border: 1px solid var(--border-color);
    border-radius: 6px;
    background: var(--bg-primary);
    color: var(--text-primary);
    font-size: 13px;
}

/* ============================================
   CANVAS AREA
   ============================================ */

.thriller-board-canvas-wrapper {
    flex: 1;
    overflow: hidden;
    position: relative;
    background: var(--bg-tertiary);
}

.thriller-board-canvas {
    position: absolute;
    width: 3000px;
    height: 2000px;
    cursor: grab;
    transform-origin: 0 0;
    transition: transform 0.1s ease;
}

.thriller-board-canvas.dragging {
    cursor: grabbing;
}

.thriller-board-content {
    position: relative;
    width: 100%;
    height: 100%;
}

/* ============================================
   ELEMENTS
   ============================================ */

.thriller-element-card {
    position: absolute;
    background: var(--bg-primary);
    border-radius: 12px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    border: 2px solid transparent;
    overflow: hidden;
    cursor: pointer;
    transition: all 0.15s ease;
}

.thriller-element-card:hover {
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
    transform: translateY(-2px);
}

.thriller-element-card.selected {
    border-color: var(--accent-gold);
    box-shadow: 0 0 0 3px rgba(255, 193, 7, 0.2);
}

.thriller-element-header {
    display: flex;
    align-items: center;
    padding: 12px 16px;
    color: white;
    gap: 12px;
}

.thriller-element-icon {
    width: 24px;
    height: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.thriller-element-icon svg {
    width: 20px;
    height: 20px;
}

.thriller-element-title {
    flex: 1;
    font-weight: 600;
    font-size: 14px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.thriller-element-actions {
    opacity: 0;
    transition: opacity 0.15s ease;
}

.thriller-element-card:hover .thriller-element-actions {
    opacity: 1;
}

.thriller-element-content {
    padding: 16px;
}

.thriller-element-description {
    font-size: 13px;
    line-height: 1.5;
    color: var(--text-secondary);
}

/* ============================================
   CONNECTIONS
   ============================================ */

.thriller-connection {
    pointer-events: none;
    stroke-linecap: round;
}

/* ============================================
   CONTEXT PANEL
   ============================================ */

.thriller-board-context-panel {
    width: 300px;
    background: var(--bg-secondary);
    border-left: 1px solid var(--border-color);
    display: flex;
    flex-direction: column;
    transition: width 0.3s ease;
}

.thriller-board-context-panel.collapsed {
    width: 50px;
}

.thriller-context-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 16px;
    border-bottom: 1px solid var(--border-color);
}

.thriller-context-header h3 {
    margin: 0;
    font-size: 16px;
    font-weight: 600;
    color: var(--text-primary);
}

.thriller-context-content {
    flex: 1;
    overflow-y: auto;
    padding: 16px;
}

.thriller-stats h4 {
    margin: 0 0 12px 0;
    font-size: 14px;
    font-weight: 600;
    color: var(--text-primary);
}

.thriller-stat-item {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 0;
    border-bottom: 1px solid var(--border-light);
}

.thriller-stat-item:last-child {
    border-bottom: none;
}

.thriller-stat-icon {
    width: 20px;
    height: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.thriller-stat-icon svg {
    width: 16px;
    height: 16px;
}

.thriller-stat-label {
    flex: 1;
    font-size: 13px;
    color: var(--text-primary);
}

.thriller-stat-count {
    font-size: 12px;
    font-weight: 600;
    color: var(--text-muted);
    background: var(--bg-tertiary);
    padding: 2px 8px;
    border-radius: 12px;
}

.thriller-recent h4 {
    margin: 20px 0 12px 0;
    font-size: 14px;
    font-weight: 600;
    color: var(--text-primary);
}

.thriller-recent-item {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 12px;
    border-radius: 6px;
    cursor: pointer;
    transition: background 0.15s ease;
    margin-bottom: 4px;
}

.thriller-recent-item:hover {
    background: var(--bg-tertiary);
}

.thriller-recent-icon {
    width: 18px;
    height: 18px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.thriller-recent-icon svg {
    width: 14px;
    height: 14px;
}

.thriller-recent-title {
    flex: 1;
    font-size: 13px;
    color: var(--text-primary);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

/* ============================================
   TYPE SELECTOR MODAL
   ============================================ */

.thriller-type-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 16px;
    margin-top: 20px;
}

.thriller-type-card {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 20px;
    border: 2px solid var(--border-color);
    border-radius: 12px;
    background: var(--bg-primary);
    cursor: pointer;
    transition: all 0.15s ease;
    text-align: center;
}

.thriller-type-card:hover {
    border-color: var(--accent-gold);
    box-shadow: 0 4px 16px rgba(255, 193, 7, 0.1);
    transform: translateY(-2px);
}

.thriller-type-icon {
    width: 48px;
    height: 48px;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: 12px;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.1);
}

.thriller-type-icon svg {
    width: 24px;
    height: 24px;
}

.thriller-type-label {
    font-size: 16px;
    font-weight: 600;
    color: var(--text-primary);
    margin-bottom: 4px;
}

.thriller-type-desc {
    font-size: 13px;
    color: var(--text-secondary);
    line-height: 1.4;
}

/* ============================================
   RESPONSIVE DESIGN
   ============================================ */

@media (max-width: 768px) {
    .thriller-board-toolbar {
        padding: 8px 12px;
        flex-wrap: wrap;
    }

    .thriller-toolbar-left,
    .thriller-toolbar-center,
    .thriller-toolbar-right {
        flex: 1;
        justify-content: center;
    }

    .thriller-board-context-panel {
        width: 250px;
    }

    .thriller-board-context-panel.collapsed {
        width: 40px;
    }

    .thriller-type-grid {
        grid-template-columns: 1fr;
    }
}

/* ============================================
   DARK MODE SUPPORT
   ============================================ */

@media (prefers-color-scheme: dark) {
    .thriller-element-card {
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    .thriller-element-card:hover {
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
    }
}

    </style>
</head>
<body>
    <!-- Mobile Menu Handle (poignée latérale) -->
    <div class="mobile-menu-handle" onclick="toggleMobileSidebar()"></div>
    
    <!-- Mobile Sidebar Overlay -->
    <div class="sidebar-overlay" onclick="toggleMobileSidebar()"></div>
    
    <!-- Mobile Navigation Dropdown (déplacé hors du grid) -->
    <div class="mobile-nav-dropdown" id="mobileNavDropdown">
        <div class="mobile-nav-section">
            <div class="mobile-nav-section-title"><i data-lucide="pen-tool"></i> Écriture</div>
            <button class="mobile-nav-item active" onclick="switchViewMobile('editor')" data-view="editor">
                <span class="mobile-nav-item-icon"><i data-lucide="pen-line"></i></span>
                <span>Structure</span>
            </button>
            <button class="mobile-nav-item" onclick="switchViewMobile('corkboard')" data-view="corkboard">
                <span class="mobile-nav-item-icon"><i data-lucide="layout-grid"></i></span>
                <span>Tableau</span>
            </button>
            <button class="mobile-nav-item" onclick="switchViewMobile('plot')" data-view="plot">
                <span class="mobile-nav-item-icon"><i data-lucide="trending-up"></i></span>
                <span>Intrigue</span>
            </button>
            <button class="mobile-nav-item" onclick="switchViewMobile('arcs')" data-view="arcs">
                <span class="mobile-nav-item-icon"><i data-lucide="git-commit-horizontal"></i></span>
                <span>Arcs Narratifs</span>
            </button>
            <button class="mobile-nav-item" onclick="switchViewMobile('thriller')" data-view="thriller">
                <span class="mobile-nav-item-icon"><i data-lucide="detective"></i></span>
                <span>Thriller</span>
            </button>
            <button class="mobile-nav-item" onclick="switchViewMobile('storygrid')" data-view="plot">
                <span class="mobile-nav-item-icon"><i data-lucide="grid-3x3"></i></span>
                <span>Storygrid</span>
            </button>
        </div>

        <div class="mobile-nav-section">
            <div class="mobile-nav-section-title"><i data-lucide="database"></i> Base de données</div>
            <button class="mobile-nav-item" onclick="switchViewMobile('characters')" data-view="characters">
                <span class="mobile-nav-item-icon"><i data-lucide="users"></i></span>
                <span>Personnages</span>
            </button>
            <button class="mobile-nav-item" onclick="switchViewMobile('world')" data-view="world">
                <span class="mobile-nav-item-icon"><i data-lucide="globe"></i></span>
                <span>Univers</span>
            </button>
            <button class="mobile-nav-item" onclick="switchViewMobile('codex')" data-view="codex">
                <span class="mobile-nav-item-icon"><i data-lucide="book-open"></i></span>
                <span>Codex</span>
            </button>
            <button class="mobile-nav-item" onclick="switchViewMobile('notes')" data-view="notes">
                <span class="mobile-nav-item-icon"><i data-lucide="sticky-note"></i></span>
                <span>Notes</span>
            </button>

        </div>

        <div class="mobile-nav-section">
            <div class="mobile-nav-section-title"><i data-lucide="eye"></i> Visualisation</div>
            <button class="mobile-nav-item" onclick="switchViewMobile('mindmap')" data-view="mindmap">
                <span class="mobile-nav-item-icon"><i data-lucide="git-branch"></i></span>
                <span>Mindmap</span>
            </button>
            <button class="mobile-nav-item" onclick="switchViewMobile('relations')" data-view="relations">
                <span class="mobile-nav-item-icon"><i data-lucide="link"></i></span>
                <span>Relations</span>
            </button>
            <button class="mobile-nav-item" onclick="switchViewMobile('map')" data-view="map">
                <span class="mobile-nav-item-icon"><i data-lucide="map"></i></span>
                <span>Carte</span>
            </button>
            <button class="mobile-nav-item" onclick="switchViewMobile('timelineviz')" data-view="timelineviz">
                <span class="mobile-nav-item-icon"><i data-lucide="clock"></i></span>
                <span>Timeline</span>
            </button>
        </div>

        <div class="mobile-nav-section">
            <div class="mobile-nav-section-title"><i data-lucide="wrench"></i> Outils</div>
            <button class="mobile-nav-item" onclick="switchViewMobile('stats')" data-view="stats">
                <span class="mobile-nav-item-icon"><i data-lucide="bar-chart-3"></i></span>
                <span>Stats</span>
            </button>
            <button class="mobile-nav-item" onclick="switchViewMobile('analysis')" data-view="analysis">
                <span class="mobile-nav-item-icon"><i data-lucide="scan-search"></i></span>
                <span>Analyse</span>
            </button>
        </div>

        <div class="mobile-nav-section">
            <div class="mobile-nav-section-title"><i data-lucide="history"></i> Historique</div>
            <button class="mobile-nav-item" onclick="switchViewMobile('versions')" data-view="versions">
                <span class="mobile-nav-item-icon"><i data-lucide="history"></i></span>
                <span>Snapshots</span>
            </button>
        </div>

        <div class="mobile-nav-section">
            <div class="mobile-nav-section-title"><i data-lucide="settings"></i> Actions</div>
            <button class="mobile-nav-item" onclick="openProjectsModal(); toggleMobileNav();">
                <span class="mobile-nav-item-icon"><i data-lucide="folder-open"></i></span>
                <span>Mes Projets</span>
            </button>
            <button class="mobile-nav-item" onclick="openThemeManager(); toggleMobileNav();">
                <span class="mobile-nav-item-icon"><i data-lucide="palette"></i></span>
                <span>Thèmes</span>
            </button>
            <button class="mobile-nav-item" onclick="undo(); toggleMobileNav();" id="mobileUndoBtn">
                <span class="mobile-nav-item-icon"><i data-lucide="undo-2"></i></span>
                <span>Annuler</span>
            </button>
            <button class="mobile-nav-item" onclick="redo(); toggleMobileNav();" id="mobileRedoBtn">
                <span class="mobile-nav-item-icon"><i data-lucide="redo-2"></i></span>
                <span>Rétablir</span>
            </button>
            <button class="mobile-nav-item" onclick="showBackupMenu(); toggleMobileNav();">
                <span class="mobile-nav-item-icon"><i data-lucide="download"></i></span>
                <span>Sauvegarde/Export</span>
            </button>
        </div>
    </div>
    
    <!-- Barre de progression d'écriture (mode focus) - hors du grid -->
    <div class="writing-progress-bar">
        <div class="writing-progress-fill" id="writingProgressFill"></div>
        <div class="writing-progress-text" id="positionIndicator">
            Mot 0 / 0
        </div>
    </div>
    
    <div class="app-container">
        <!-- Top Header -->
        <div class="app-header">
            <div class="app-logo" onclick="renameProject()" style="cursor: pointer;" title="Cliquer pour renommer le projet">
                <span class="app-logo-icon"><i data-lucide="feather"></i></span>
                <span id="headerProjectTitle">Plume</span>
                <i data-lucide="pencil" style="width: 12px; height: 12px; opacity: 0.5; margin-left: 4px;"></i>
            </div>

            <!-- Mobile Navigation Toggle -->
            <button class="mobile-nav-toggle-btn" onclick="toggleMobileNav()" id="mobileNavToggleBtn">
                <i data-lucide="menu"></i>
            </button>
            
            <nav class="header-nav">
                <!-- Section 1 : Structure, Tableau, Intrigue -->
                <div class="nav-group">
                    <button class="nav-btn active" onclick="switchView('editor')" id="header-tab-editor">
                        <span class="nav-btn-icon"><i data-lucide="pen-line"></i></span>
                        <span class="nav-btn-text">Structure</span>
                    </button>
                    <button class="nav-btn" onclick="switchView('corkboard')" id="header-tab-corkboard">
                        <span class="nav-btn-icon"><i data-lucide="layout-grid"></i></span>
                        <span class="nav-btn-text">Tableau</span>
                    </button>
                    <button class="nav-btn" onclick="switchView('plot')" id="header-tab-plot">
                        <span class="nav-btn-icon"><i data-lucide="trending-up"></i></span>
                        <span class="nav-btn-text">Intrigue</span>
                    </button>
                    <button class="nav-btn" onclick="switchView('arcs')" id="header-tab-arcs">
                        <span class="nav-btn-icon"><i data-lucide="git-commit-horizontal"></i></span>
                        <span class="nav-btn-text">Arcs</span>
                    </button>
                    <button class="nav-btn" onclick="switchView('thriller')" id="header-tab-thriller">
                        <span class="nav-btn-icon"><i data-lucide="detective"></i></span>
                        <span class="nav-btn-text">Thriller</span>
                    </button>
                    <button class="nav-btn" onclick="switchView('storygrid')" id="header-tab-plot">
                        <span class="nav-btn-icon"><i data-lucide="grid-3x3"></i></span>
                        <span class="nav-btn-text">StoryGrid</span>
                    </button>
                </div>
                
                <!-- Section 2 : Personnages, Univers, Codex, Notes -->
                <div class="nav-group">
                    <button class="nav-btn" onclick="switchView('characters')" id="header-tab-characters">
                        <span class="nav-btn-icon"><i data-lucide="users"></i></span>
                        <span class="nav-btn-text">Personnages</span>
                    </button>
                    <button class="nav-btn" onclick="switchView('world')" id="header-tab-world">
                        <span class="nav-btn-icon"><i data-lucide="globe"></i></span>
                        <span class="nav-btn-text">Univers</span>
                    </button>
                    <button class="nav-btn" onclick="switchView('codex')" id="header-tab-codex">
                        <span class="nav-btn-icon"><i data-lucide="book-open"></i></span>
                        <span class="nav-btn-text">Codex</span>
                    </button>

                    <button class="nav-btn" onclick="switchView('notes')" id="header-tab-notes">
                        <span class="nav-btn-icon"><i data-lucide="sticky-note"></i></span>
                        <span class="nav-btn-text">Notes</span>
                    </button>
                </div>
                
                <!-- Section 3 : Mindmap, Relations, Carte, Timeline -->
                <div class="nav-group">
                    <button class="nav-btn" onclick="switchView('mindmap')" id="header-tab-mindmap">
                        <span class="nav-btn-icon"><i data-lucide="git-branch"></i></span>
                        <span class="nav-btn-text">Mindmap</span>
                    </button>
                    <button class="nav-btn" onclick="switchView('relations')" id="header-tab-relations">
                        <span class="nav-btn-icon"><i data-lucide="link"></i></span>
                        <span class="nav-btn-text">Relations</span>
                    </button>
                    <button class="nav-btn" onclick="switchView('map')" id="header-tab-map">
                        <span class="nav-btn-icon"><i data-lucide="map"></i></span>
                        <span class="nav-btn-text">Carte</span>
                    </button>
                    <button class="nav-btn" onclick="switchView('timelineviz')" id="header-tab-timeline-viz">
                        <span class="nav-btn-icon"><i data-lucide="clock"></i></span>
                        <span class="nav-btn-text">Timeline</span>
                    </button>
                </div>
                
                <!-- Section 4 : Stats, Analyse -->
                <div class="nav-group">
                    <button class="nav-btn" onclick="switchView('stats')" id="header-tab-stats">
                        <span class="nav-btn-icon"><i data-lucide="bar-chart-3"></i></span>
                        <span class="nav-btn-text">Stats</span>
                    </button>
                    <button class="nav-btn" onclick="switchView('analysis')" id="header-tab-analysis">
                        <span class="nav-btn-icon"><i data-lucide="scan-search"></i></span>
                        <span class="nav-btn-text">Analyse</span>
                    </button>
                </div>
                
                <!-- Section 5 : Snapshots -->
                <div class="nav-group">
                    <button class="nav-btn" onclick="switchView('versions')" id="header-tab-versions">
                        <span class="nav-btn-icon"><i data-lucide="history"></i></span>
                        <span class="nav-btn-text">Snapshots</span>
                    </button>
                </div>
            </nav>
            
            <!-- Actions à droite -->
            <div class="header-actions">
                <div id="headerStatsContainer" style="font-size: 0.85rem; color: var(--text-muted); margin-right: 0.5rem;">
                    <span id="headerTotalWords">0 mots</span>
                    <span id="headerStatsSeparator"> · </span>
                    <span id="headerTotalChapters">0 chapitres</span>
                </div>
                
                <!-- Split View Toggle -->
                <button class="split-mode-toggle" onclick="toggleSplitView()" id="splitModeToggle" title="Activer/désactiver le mode split (vue côte à côte)">
                    <i data-lucide="columns-2" style="width:14px;height:14px;"></i>
                    <span>Split</span>
                </button>
                
                <!-- Storage badge intégré dans le header -->
                <div class="storage-badge-header status-ok" id="storage-badge" onclick="showStorageDetails()" title="Espace de stockage">
                    <span class="storage-icon"><i data-lucide="hard-drive"></i></span>
                    <span id="storage-percentage">...</span>
                </div>
                
                <button class="header-action-btn" onclick="undo()" id="headerUndoBtn" title="Annuler (Ctrl+Z)" disabled><i data-lucide="undo-2"></i></button>
                <button class="header-action-btn" onclick="redo()" id="headerRedoBtn" title="Rétablir (Ctrl+Y)" disabled><i data-lucide="redo-2"></i></button>
                <button class="header-action-btn" onclick="togglePomodoroPopup()" id="pomodoroHeaderBtn" title="Timer Pomodoro"><i data-lucide="timer"></i></button>
                <button class="header-action-btn" onclick="openThemeManager()" title="Gérer les thèmes"><i data-lucide="palette"></i></button>
                <button class="header-action-btn" onclick="openProjectsModal()" title="Gérer les projets"><i data-lucide="folder-open"></i></button>
            </div>
        </div>
        
        <!-- Pomodoro Popup -->
        <div class="pomodoro-popup" id="pomodoroPopup">
            <div class="pomodoro-popup-header">
                <span>⏱️ Pomodoro</span>
                <span class="pomodoro-popup-close" onclick="togglePomodoroPopup()">×</span>
            </div>
            <div class="pomodoro-popup-content">
                <div class="pomodoro-display" id="pomodoroDisplay">25:00</div>
                <div class="pomodoro-controls">
                    <button class="btn btn-small" onclick="startPomodoro()">▶</button>
                    <button class="btn btn-small" onclick="pausePomodoro()">⏸</button>
                    <button class="btn btn-small" onclick="resetPomodoro()">↻</button>
                </div>
                <div class="pomodoro-stats">
                    <div class="pomodoro-stat">
                        <span class="pomodoro-stat-value" id="pomodorosCompleted">0</span>
                        <span class="pomodoro-stat-label">sessions</span>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Conteneur principal (sidebar + versions + éditeur) -->
        <div class="app-content">
            <!-- Sidebar Navigation -->
            <div class="sidebar">
            <!-- Poignée de redimensionnement -->
            <div class="sidebar-resize-handle" id="sidebarResizeHandle">
                <div class="resize-handle-line"></div>
            </div>
            
            <div class="sidebar-header">
                <div class="search-container">
                    <input type="text" 
                           class="search-input" 
                           id="globalSearch" 
                           placeholder="🔍 Rechercher dans tout le projet..."
                           oninput="performGlobalSearch(this.value)"
                           onfocus="this.select()">
                    <span class="search-icon">🔍</span>
                    <div class="search-results" id="searchResults"></div>
                </div>
            </div>

            <!-- Barre de progression globale -->
            <div class="project-progress-bar" id="projectProgressBar">
                <div class="progress-stats">
                    <span id="progressStatsText">0 scènes</span>
                    <span id="progressPercent">0%</span>
                </div>
                <div class="progress-track">
                    <div class="progress-segment complete" id="progressComplete" style="width: 0%"></div>
                    <div class="progress-segment review" id="progressReview" style="width: 0%"></div>
                    <div class="progress-segment progress" id="progressProgress" style="width: 0%"></div>
                    <div class="progress-segment draft" id="progressDraft" style="width: 0%"></div>
                </div>
            </div>

            <!-- Filtres de statut -->
            <div class="status-filters" id="statusFilters">
                <button class="status-filter-btn draft active" onclick="toggleStatusFilter('draft')" data-status="draft">
                    <span class="status-filter-dot draft"></span>
                    <span>Brouillon</span>
                    <span class="status-filter-count" id="countDraft">0</span>
                </button>
                <button class="status-filter-btn progress active" onclick="toggleStatusFilter('progress')" data-status="progress">
                    <span class="status-filter-dot progress"></span>
                    <span>En cours</span>
                    <span class="status-filter-count" id="countProgress">0</span>
                </button>
                <button class="status-filter-btn complete active" onclick="toggleStatusFilter('complete')" data-status="complete">
                    <span class="status-filter-dot complete"></span>
                    <span>Terminé</span>
                    <span class="status-filter-count" id="countComplete">0</span>
                </button>
                <button class="status-filter-btn review active" onclick="toggleStatusFilter('review')" data-status="review">
                    <span class="status-filter-dot review"></span>
                    <span>À réviser</span>
                    <span class="status-filter-count" id="countReview">0</span>
                </button>
            </div>

            <!-- Outils de scène -->
            <div class="scene-tools" id="sceneTools">
                <button class="scene-tool-btn" onclick="toggleVersionsSidebar()" id="headerVersionsToggle" title="Afficher/masquer les versions de scène">
                    <i data-lucide="git-branch"></i>
                    <span>Versions</span>
                </button>
                <button class="scene-tool-btn" onclick="toggleAnnotationsPanel()" id="sidebarAnnotationsBtn" title="Afficher/masquer les annotations">
                    <i data-lucide="message-square"></i>
                    <span>Annotations</span>
                    <span class="scene-tool-badge" id="annotationsBadge" style="display: none;">0</span>
                </button>
                <button class="scene-tool-btn" onclick="toggleTodosPanel()" id="sidebarTodosBtn" title="Afficher/masquer les TODOs">
                    <i data-lucide="check-square"></i>
                    <span>TODOs</span>
                    <span class="scene-tool-badge" id="todosBadge" style="display: none;">0</span>
                </button>
            </div>

            <!-- Boutons déplier/replier tout -->
            <div class="tree-collapse-toolbar" id="treeCollapseToolbar">
                <button class="tree-collapse-btn" onclick="expandAllTree()" title="Tout déplier">
                    <i data-lucide="unfold-vertical" style="width:12px;height:12px;"></i>
                    <span>Déplier</span>
                </button>
                <button class="tree-collapse-btn" onclick="collapseAllTree()" title="Tout replier">
                    <i data-lucide="fold-vertical" style="width:12px;height:12px;"></i>
                    <span>Replier</span>
                </button>
            </div>

            <div class="chapters-list" id="chaptersList">
                <!-- Structure will be dynamically inserted here -->
            </div>

            <div class="database-list" id="charactersList" style="display: none;">
                <!-- Characters will be dynamically inserted here -->
            </div>

            <div class="database-list" id="worldList" style="display: none;">
                <!-- World elements will be dynamically inserted here -->
            </div>

            <div class="database-list" id="timelineList" style="display: none;">
                <!-- Timeline events will be dynamically inserted here -->
            </div>

            <div class="database-list" id="notesList" style="display: none;">
                <!-- Notes will be dynamically inserted here -->
            </div>

            <div class="database-list" id="codexList" style="display: none;">
                <!-- Codex entries will be dynamically inserted here -->
            </div>

            <div class="database-list" id="arcsList" style="display: none;">
                <!-- Narrative arcs will be dynamically inserted here -->
            </div>

            <div class="database-list" id="statsList" style="display: none;">
                <!-- Statistics will be dynamically inserted here -->
            </div>

            <div class="database-list" id="versionsList" style="display: none;">
                <!-- Versions will be dynamically inserted here -->
            </div>

            <div class="database-list" id="analysisList" style="display: none;">
                <!-- Analysis will be dynamically inserted here -->
            </div>

            <div class="database-list" id="corkboardList" style="display: none;">
                <!-- Cork Board info will be here -->
            </div>

            <div class="database-list" id="mindmapList" style="display: none;">
                <!-- Mindmap will be here -->
            </div>

            <div class="database-list" id="plotList" style="display: none;">
                <!-- Plot graph will be here -->
            </div>

            <div class="database-list" id="relationsList" style="display: none;">
                <!-- Relations graph will be here -->
            </div>

            <div class="database-list" id="mapList" style="display: none;">
                <!-- World map will be here -->
            </div>

            <div class="database-list" id="timelineVizList" style="display: none;">
                <!-- Visual timeline will be here -->
            </div>

            <div class="database-list" id="todosList" style="display: none;">
                <!-- TODOs list will be here -->
            </div>

            <div class="database-list" id="noSidebarMessage" style="display: none;">
                <!-- Message for views without sidebar -->
            </div>

            <div class="sidebar-actions" id="sidebarActions">
                <button class="btn btn-primary" onclick="openAddActModal()">+ Acte</button>
                <button class="btn btn-primary" onclick="openAddChapterModal()">+ Chapitre</button>
                <button class="btn btn-primary" onclick="openAddSceneModalQuick()">+ Scène</button>
            </div>
        </div>

        <!-- Sidebar Versions (pour les versions de scènes) -->
        <div class="sidebar-versions hidden" id="sidebarVersions">
            <div class="sidebar-versions-header">
                <div class="sidebar-versions-title">
                    <h3><i data-lucide="git-branch" style="width:16px;height:16px;vertical-align:middle;margin-right:6px;"></i>Versions</h3>
                    <button class="sidebar-versions-toggle" onclick="toggleVersionsSidebar()" title="Masquer">✕</button>
                </div>
                <div class="sidebar-versions-scene" id="versionsSceneName">Aucune scène sélectionnée</div>
            </div>
            <div class="sidebar-versions-actions" id="versionsActionsArea">
                <button class="btn-new-version" onclick="createSceneVersion()" id="btnNewVersion" disabled>
                    + Nouvelle version
                </button>
            </div>
            <div class="sidebar-versions-list" id="sceneVersionsList">
                <div class="versions-no-scene">
                    <div class="versions-no-scene-icon">📄</div>
                    <div class="versions-no-scene-text">
                        Sélectionnez une scène<br>dans la structure<br>pour voir ses versions
                    </div>
                </div>
            </div>
        </div>

        <!-- Main Editor -->
        <div class="editor-container" id="editorView">
            <div class="empty-state">
                <div class="empty-state-icon">✍️</div>
                <div class="empty-state-title">Commencez votre histoire</div>
                <div class="empty-state-text">
                    Créez votre premier chapitre pour commencer à écrire.
                </div>
                <button class="btn btn-primary" onclick="openAddChapterModal()">+ Créer un chapitre</button>
            </div>
        </div>
        </div><!-- Fin app-content -->

            <!-- Focus Mode Toggle Button -->
        <button class="focus-toggle-btn" onclick="toggleFocusPanel()">⚙️ Paramètres Focus</button>
        
        <!-- Focus Mode Panel (inside app-container for fullscreen) -->
        <div class="focus-mode-panel" id="focusPanel">
            <div class="focus-panel-header">
                <div class="focus-panel-title">🧘 Mode Focus</div>
            </div>
            <div class="focus-panel-content">
                <!-- Pomodoro Timer -->
                <div class="focus-section">
                    <div class="focus-section-title">⏱️ Timer Pomodoro</div>
                    <div class="pomodoro-timer">
                        <div class="pomodoro-display" id="pomodoroDisplay">25:00</div>
                        <div class="pomodoro-controls">
                            <button class="btn btn-small" onclick="startPomodoro()">▶ Démarrer</button>
                            <button class="btn btn-small" onclick="pausePomodoro()">⏸ Pause</button>
                            <button class="btn btn-small" onclick="resetPomodoro()">↻ Reset</button>
                        </div>
                        <div class="focus-stats">
                            <div class="focus-stat-box">
                                <div class="focus-stat-value" id="pomodorosCompleted">0</div>
                                <div class="focus-stat-label">Pomodoros</div>
                            </div>
                            <div class="focus-stat-box">
                                <div class="focus-stat-value" id="focusWordCount">0</div>
                                <div class="focus-stat-label">Mots</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Focus Settings -->
                <div class="focus-section">
                    <div class="focus-section-title">⚙️ Paramètres</div>
                    <div style="display: flex; flex-direction: column; gap: 0.75rem;">
                        <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                            <input type="checkbox" id="hideToolbar" onchange="toggleToolbar()">
                            <span>Masquer la barre d'outils</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                            <input type="checkbox" id="hideLinksPanel" onchange="toggleLinksPanelVisibility()">
                            <span>Masquer le panneau de liens</span>
                        </label>
                    </div>
                </div>

                <!-- Exit Focus Mode -->
                <div class="focus-section">
                    <button class="btn btn-primary" style="width: 100%;" onclick="toggleFocusMode()">
                        ← Quitter le mode Focus
                    </button>
                </div>
            </div>
        </div>
        
    </div><!-- Fin app-container -->

    <!-- Diff Modal -->
    <div class="diff-modal" id="diffModal" style="display: none;">
        <div class="diff-modal-content">
            <div class="diff-modal-header">
                <div class="diff-modal-title">
                    <span>🔀</span>
                    <span>Comparaison des versions</span>
                </div>
                <button class="diff-modal-close" onclick="closeDiffModal()">×</button>
            </div>
            <div class="diff-toolbar">
                <div class="diff-version-selector">
                    <span>Comparer</span>
                    <select class="diff-version-select" id="diffVersionOld" onchange="updateDiff()">
                    </select>
                    <span>avec</span>
                    <select class="diff-version-select" id="diffVersionNew" onchange="updateDiff()">
                    </select>
                </div>
                <div class="diff-stats" id="diffStats">
                    <span class="diff-stat added">+0 ajoutés</span>
                    <span class="diff-stat removed">−0 supprimés</span>
                </div>
                <div class="diff-view-toggle">
                    <button class="diff-view-btn active" onclick="setDiffView('unified')" id="btnDiffUnified">Unifié</button>
                    <button class="diff-view-btn" onclick="setDiffView('side')" id="btnDiffSide">Côte à côte</button>
                </div>
            </div>
            <div class="diff-content" id="diffContent">
                <!-- Diff content will be inserted here -->
            </div>
        </div>
    </div>

    <!-- Add Act Modal -->
    <!-- Storage Details Modal -->
    <div class="modal storage-details-modal" id="storage-modal">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header">
                <h2>💾 Espace de stockage</h2>
                <button class="modal-close" onclick="closeModal('storage-modal')">×</button>
            </div>
            <div class="storage-info">
                <div class="storage-bar">
                    <div class="storage-bar-fill ok" id="storage-bar-fill" style="width: 0%">
                        <span id="storage-bar-text">0%</span>
                    </div>
                </div>
                <div class="storage-stats">
                    <div class="storage-stat">
                        <div class="storage-stat-label">Utilisé</div>
                        <div class="storage-stat-value" id="storage-used">0 MB</div>
                    </div>
                    <div class="storage-stat">
                        <div class="storage-stat-label">Disponible</div>
                        <div class="storage-stat-value" id="storage-available">5 MB</div>
                    </div>
                </div>
                <!-- Section repliable pour les recommandations -->
                <details id="storage-recommendations-details" style="margin-top: 1rem;">
                    <summary style="cursor: pointer; font-weight: 600; color: var(--accent-green); font-size: 0.9rem;">✅ Espace suffisant</summary>
                    <div id="storage-recommendations-container" style="margin-top: 0.5rem;"></div>
                </details>
            </div>
            
            <hr style="border: none; border-top: 1px solid var(--border-color); margin: 1.25rem 0;">
            
            <!-- Importer des données -->
            <div style="margin-bottom: 1rem;">
                <div style="font-size: 0.9rem; font-weight: 600; margin-bottom: 0.5rem; color: var(--text-primary);">Importer</div>
                <button class="btn" onclick="importProject()" style="width: 100%; font-size: 0.85rem;">
                    <i data-lucide="upload" style="width:14px;height:14px;vertical-align:middle;margin-right:6px;"></i>Importer depuis un fichier JSON
                </button>
            </div>

            <!-- Exporter les données -->
            <div style="margin-bottom: 1rem;">
                <div style="font-size: 0.9rem; font-weight: 600; margin-bottom: 0.5rem; color: var(--text-primary);">Exporter</div>
                <div style="display: flex; flex-direction: column; gap: 0.5rem;">
                    <button class="btn btn-primary" onclick="closeModal('storage-modal'); openExportNovelModal();" style="font-weight: 600; font-size: 0.85rem;">
                        <i data-lucide="book-open" style="width:14px;height:14px;vertical-align:middle;margin-right:6px;"></i>Exporter le roman (MD, TXT, HTML ...)
                    </button>
                    <div style="display: flex; gap: 0.5rem;">
                        <button class="btn" onclick="exportToJSON()" style="flex: 1; font-size: 0.8rem;">
                            <i data-lucide="hard-drive" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>JSON
                        </button>
                        <button class="btn" onclick="exportProject()" style="flex: 1; font-size: 0.8rem;">
                            <i data-lucide="file-text" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>TXT
                        </button>
                    </div>
                </div>
            </div>

            <!-- Cloud manuel - repliable -->
            <details style="margin-bottom: 1rem;">
                <summary style="cursor: pointer; font-weight: 600; color: var(--text-primary); font-size: 0.9rem;">☁️ Cloud (manuel)</summary>
                <div style="padding: 0.75rem; background: var(--bg-secondary); border-radius: 4px; margin-top: 0.5rem; border: 1px solid var(--border-color);">
                    <ol style="font-size: 0.75rem; color: var(--text-secondary); line-height: 1.6; padding-left: 1.25rem; margin: 0;">
                        <li>Télécharge en JSON</li>
                        <li>Uploade sur Google Drive / Dropbox</li>
                        <li>Pour restaurer : "Importer depuis un fichier"</li>
                    </ol>
                </div>
            </details>

            <!-- Avertissement très petit -->
            <p style="font-size: 0.7rem; color: var(--text-muted); text-align: center; margin: 0;">
                ⚠️ Pense à exporter régulièrement — les données navigateur peuvent être effacées
            </p>

            <div class="modal-actions" style="margin-top: 1rem;">
                <button class="btn" onclick="closeModal('storage-modal')">Fermer</button>
            </div>
        </div>
    </div>

    <!-- Modals -->
    <div class="modal" id="addActModal">
        <div class="modal-content">
            <div class="modal-title">Nouvel Acte</div>
            <div class="form-group">
                <label class="form-label">Titre de l'acte</label>
                <input type="text" class="form-input" id="actTitleInput" placeholder="Acte I : L'Éveil">
            </div>
            <div class="modal-actions">
                <button class="btn" onclick="closeModal('addActModal')">Annuler</button>
                <button class="btn btn-primary" onclick="addAct()">Créer</button>
            </div>
        </div>
    </div>

    <!-- Add Chapter Modal -->
    <div class="modal" id="addChapterModal">
        <div class="modal-content">
            <div class="modal-title">Nouveau Chapitre</div>
            <div class="form-group">
                <label class="form-label">Titre du chapitre</label>
                <input type="text" class="form-input" id="chapterTitleInput" placeholder="Chapitre 1 : Le Début">
            </div>
            <div class="modal-actions">
                <button class="btn" onclick="closeModal('addChapterModal')">Annuler</button>
                <button class="btn btn-primary" onclick="addChapter()">Créer</button>
            </div>
        </div>
    </div>

    <!-- Add Scene Modal -->
    <div class="modal" id="addSceneModal">
        <div class="modal-content">
            <div class="modal-title">Nouvelle Scène</div>
            <div class="form-group">
                <label class="form-label">Titre de la scène</label>
                <input type="text" class="form-input" id="sceneTitleInput" placeholder="Scène 1 : Rencontre">
            </div>
            <div class="modal-actions">
                <button class="btn" onclick="closeModal('addSceneModal')">Annuler</button>
                <button class="btn btn-primary" onclick="addScene()">Créer</button>
            </div>
        </div>
    </div>

    <!-- Split View Selector Modal -->
    <div class="modal" id="splitSelectorModal">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-title"><i data-lucide="layout" style="width:20px;height:20px;vertical-align:middle;margin-right:8px;"></i>Choisir la vue</div>
            <div id="splitSelectorContent" style="max-height: 600px; overflow-y: auto;">
                <!-- Content will be populated by JavaScript -->
            </div>
            <div class="modal-actions">
                <button class="btn" onclick="closeModal('splitSelectorModal')">Annuler</button>
            </div>
        </div>
    </div>

    <!-- Add Character Modal -->
    <div class="modal" id="addCharacterModal">
        <div class="modal-content">
            <div class="modal-title">Nouveau Personnage</div>
            <div class="form-group">
                <label class="form-label">Nom du personnage</label>
                <input type="text" class="form-input" id="characterNameInput" placeholder="Akiko">
            </div>
            <div class="form-group">
                <label class="form-label">Rôle</label>
                <input type="text" class="form-input" id="characterRoleInput" placeholder="Protagoniste, Antagoniste, Allié...">
            </div>
            <div class="form-group">
                <label class="form-label">Description rapide</label>
                <textarea class="form-input" id="characterDescInput" placeholder="Description du personnage..." rows="3"></textarea>
            </div>
            <div class="modal-actions">
                <button class="btn" onclick="closeModal('addCharacterModal')">Annuler</button>
                <button class="btn btn-primary" onclick="addCharacter()">Créer</button>
            </div>
        </div>
    </div>

    <!-- Add World Element Modal -->
    <div class="modal" id="addWorldModal">
        <div class="modal-content">
            <div class="modal-title">Nouvel Élément d'Univers</div>
            <div class="form-group">
                <label class="form-label">Nom</label>
                <input type="text" class="form-input" id="worldNameInput" placeholder="Cité de Voile">
            </div>
            <div class="form-group">
                <label class="form-label">Type</label>
                <select class="form-input" id="worldTypeInput">
                    <option value="Lieu">Lieu</option>
                    <option value="Objet">Objet</option>
                    <option value="Concept">Concept</option>
                    <option value="Organisation">Organisation</option>
                    <option value="Événement">Événement</option>
                </select>
            </div>
            <div class="form-group">
                <label class="form-label">Description rapide</label>
                <textarea class="form-input" id="worldDescInput" placeholder="Description de l'élément..." rows="3"></textarea>
            </div>
            <div class="modal-actions">
                <button class="btn" onclick="closeModal('addWorldModal')">Annuler</button>
                <button class="btn btn-primary" onclick="addWorldElement()">Créer</button>
            </div>
        </div>
    </div>

    <!-- Add Timeline Event Modal -->
    <div class="modal" id="addTimelineModal">
        <div class="modal-content">
            <div class="modal-title">Nouvel Événement</div>
            <div class="form-group">
                <label class="form-label">Titre de l'événement</label>
                <input type="text" class="form-input" id="timelineTitleInput" placeholder="La grande bataille">
            </div>
            <div class="form-group">
                <label class="form-label">Date / Moment</label>
                <input type="text" class="form-input" id="timelineDateInput" placeholder="An 2157, Printemps / Chapitre 5 / Jour 3...">
            </div>
            <div class="form-group">
                <label class="form-label">Localisation</label>
                <input type="text" class="form-input" id="timelineLocationInput" placeholder="Cité de Voile">
            </div>
            <div class="form-group">
                <label class="form-label">Personnages impliqués</label>
                <input type="text" class="form-input" id="timelineCharactersInput" placeholder="Akiko, Sora, Kumi...">
            </div>
            <div class="form-group">
                <label class="form-label">Description</label>
                <textarea class="form-input" id="timelineDescInput" placeholder="Description de l'événement..." rows="4"></textarea>
            </div>
            <div class="modal-actions">
                <button class="btn" onclick="closeModal('addTimelineModal')">Annuler</button>
                <button class="btn btn-primary" onclick="addTimelineEvent()">Créer</button>
            </div>
        </div>
    </div>

    <!-- Metro Timeline Event Modal -->
    <div class="modal" id="metroEventModal">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-title" id="metroEventModalTitle">Nouvel Événement</div>
            <input type="hidden" id="metroEventId">
            <div class="metro-event-form">
                <div class="form-group">
                    <label class="form-label">Titre de l'événement *</label>
                    <input type="text" class="form-input" id="metroEventTitle" placeholder="La grande bataille">
                </div>
                <div class="form-group">
                    <label class="form-label">Date / Moment</label>
                    <input type="text" class="form-input" id="metroEventDate" placeholder="An 2157, Printemps...">
                </div>
                <div class="form-group">
                    <label class="form-label">Position sur la timeline</label>
                    <select class="form-input" id="metroEventPosition">
                        <!-- Populated dynamically -->
                    </select>
                    <input type="hidden" id="metroEventOrder">
                    <small style="color: var(--text-muted);">Choisissez où placer cet événement dans la chronologie</small>
                </div>
                <div class="form-group">
                    <label class="form-label">Description</label>
                    <textarea class="form-input" id="metroEventDesc" placeholder="Ce qui se passe..." rows="3"></textarea>
                </div>
                <div class="form-group">
                    <label class="form-label">Scène liée</label>
                    <select class="form-input" id="metroEventScene">
                        <option value="">Aucune scène</option>
                        <!-- Populated dynamically -->
                    </select>
                    <small style="color: var(--text-muted);">Associez cet événement à une scène de votre roman</small>
                </div>
                <div class="form-group">
                    <label class="form-label">Personnages impliqués</label>
                    <div id="metroCharactersSelector" class="metro-characters-selector">
                        <!-- Populated dynamically -->
                    </div>
                    <div id="metroLinkedChars" class="metro-linked-chars">
                        <!-- Tags des personnages liés -->
                    </div>
                </div>
            </div>
            <div class="modal-actions">
                <button class="btn" onclick="closeModal('metroEventModal')">Annuler</button>
                <button class="btn" style="background: var(--accent-red); color: white;" onclick="deleteMetroEvent()" id="metroDeleteBtn" style="display: none;">Supprimer</button>
                <button class="btn btn-primary" onclick="saveMetroEvent()">Enregistrer</button>
            </div>
        </div>
    </div>

    <!-- Metro Event View Choice Modal -->
    <div class="modal" id="metroViewChoiceModal">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-title">Ouvrir l'événement Timeline</div>
            <input type="hidden" id="metroViewChoiceEventId">
            <div style="padding: 1rem 0;">
                <p style="color: var(--text-secondary); margin-bottom: 1.5rem;">
                    Comment souhaitez-vous visualiser cet événement ?
                </p>
                <div style="display: flex; flex-direction: column; gap: 1rem;">
                    <button class="btn" onclick="openMetroEventFullView()" style="padding: 1rem; text-align: left; display: flex; align-items: start; gap: 1rem; border: 2px solid var(--border-color);">
                        <i data-lucide="maximize-2" style="width: 24px; height: 24px; flex-shrink: 0; color: var(--accent-blue);"></i>
                        <div>
                            <div style="font-weight: 600; margin-bottom: 0.25rem;">Vue complète</div>
                            <div style="font-size: 0.85rem; color: var(--text-muted);">Basculer vers la vue Timeline Métro (quitte la vue actuelle)</div>
                        </div>
                    </button>
                    <button class="btn" onclick="openMetroEventSplitView()" style="padding: 1rem; text-align: left; display: flex; align-items: start; gap: 1rem; border: 2px solid var(--border-color);">
                        <i data-lucide="columns-2" style="width: 24px; height: 24px; flex-shrink: 0; color: var(--accent-green);"></i>
                        <div>
                            <div style="font-weight: 600; margin-bottom: 0.25rem;">Split-view</div>
                            <div style="font-size: 0.85rem; color: var(--text-muted);">Ouvrir la Timeline en vue séparée (conserve l'éditeur)</div>
                        </div>
                    </button>
                </div>
            </div>
            <div class="modal-actions">
                <button class="btn" onclick="closeModal('metroViewChoiceModal')">Annuler</button>
            </div>
        </div>
    </div>

    <!-- Metro Character Color Picker Modal -->
    <div class="modal" id="metroColorModal">
        <div class="modal-content" style="max-width: 350px;">
            <div class="modal-title">Couleur de la ligne</div>
            <input type="hidden" id="metroColorCharId">
            <div class="form-group">
                <label class="form-label" id="metroColorCharName">Personnage</label>
                <div style="display: flex; flex-wrap: wrap; gap: 0.5rem; margin-top: 0.5rem;">
                    <div class="metro-color-option" data-color="#E53935" style="background: #E53935;" onclick="selectMetroColor('#E53935')"></div>
                    <div class="metro-color-option" data-color="#D81B60" style="background: #D81B60;" onclick="selectMetroColor('#D81B60')"></div>
                    <div class="metro-color-option" data-color="#8E24AA" style="background: #8E24AA;" onclick="selectMetroColor('#8E24AA')"></div>
                    <div class="metro-color-option" data-color="#5E35B1" style="background: #5E35B1;" onclick="selectMetroColor('#5E35B1')"></div>
                    <div class="metro-color-option" data-color="#3949AB" style="background: #3949AB;" onclick="selectMetroColor('#3949AB')"></div>
                    <div class="metro-color-option" data-color="#1E88E5" style="background: #1E88E5;" onclick="selectMetroColor('#1E88E5')"></div>
                    <div class="metro-color-option" data-color="#039BE5" style="background: #039BE5;" onclick="selectMetroColor('#039BE5')"></div>
                    <div class="metro-color-option" data-color="#00ACC1" style="background: #00ACC1;" onclick="selectMetroColor('#00ACC1')"></div>
                    <div class="metro-color-option" data-color="#00897B" style="background: #00897B;" onclick="selectMetroColor('#00897B')"></div>
                    <div class="metro-color-option" data-color="#43A047" style="background: #43A047;" onclick="selectMetroColor('#43A047')"></div>
                    <div class="metro-color-option" data-color="#7CB342" style="background: #7CB342;" onclick="selectMetroColor('#7CB342')"></div>
                    <div class="metro-color-option" data-color="#C0CA33" style="background: #C0CA33;" onclick="selectMetroColor('#C0CA33')"></div>
                    <div class="metro-color-option" data-color="#FDD835" style="background: #FDD835;" onclick="selectMetroColor('#FDD835')"></div>
                    <div class="metro-color-option" data-color="#FFB300" style="background: #FFB300;" onclick="selectMetroColor('#FFB300')"></div>
                    <div class="metro-color-option" data-color="#FB8C00" style="background: #FB8C00;" onclick="selectMetroColor('#FB8C00')"></div>
                    <div class="metro-color-option" data-color="#F4511E" style="background: #F4511E;" onclick="selectMetroColor('#F4511E')"></div>
                    <div class="metro-color-option" data-color="#6D4C41" style="background: #6D4C41;" onclick="selectMetroColor('#6D4C41')"></div>
                    <div class="metro-color-option" data-color="#757575" style="background: #757575;" onclick="selectMetroColor('#757575')"></div>
                    <div class="metro-color-option" data-color="#546E7A" style="background: #546E7A;" onclick="selectMetroColor('#546E7A')"></div>
                    <div class="metro-color-option" data-color="#263238" style="background: #263238;" onclick="selectMetroColor('#263238')"></div>
                </div>
                <div style="margin-top: 1rem;">
                    <label class="form-label">Couleur personnalisée</label>
                    <input type="color" id="metroCustomColor" class="form-input" style="width: 100%; height: 40px; padding: 0; cursor: pointer;">
                </div>
            </div>
            <div class="modal-actions">
                <button class="btn" onclick="closeModal('metroColorModal')">Annuler</button>
                <button class="btn btn-primary" onclick="applyMetroColor()">Appliquer</button>
            </div>
        </div>
    </div>

    <style>
        .metro-color-option {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.2s;
        }
        .metro-color-option:hover {
            transform: scale(1.15);
            border-color: white;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
        .metro-color-option.selected {
            border-color: var(--text-primary);
            box-shadow: 0 0 0 2px var(--accent-blue);
        }
    </style>

    <!-- Add Note Modal -->
    <div class="modal" id="addNoteModal">
        <div class="modal-content">
            <div class="modal-title">Nouvelle Note</div>
            <div class="form-group">
                <label class="form-label">Titre de la note</label>
                <input type="text" class="form-input" id="noteTitleInput" placeholder="Recherche sur les sanctuaires Shinto">
            </div>
            <div class="form-group">
                <label class="form-label">Catégorie</label>
                <select class="form-input" id="noteCategoryInput">
                    <option value="Recherche">Recherche</option>
                    <option value="Idée">Idée</option>
                    <option value="Référence">Référence</option>
                    <option value="A faire">À faire</option>
                    <option value="Question">Question</option>
                    <option value="Autre">Autre</option>
                </select>
            </div>
            <div class="form-group">
                <label class="form-label">Tags (séparés par des virgules)</label>
                <input type="text" class="form-input" id="noteTagsInput" placeholder="shinto, religion, japon">
            </div>
            <div class="form-group">
                <label class="form-label">Contenu</label>
                <textarea class="form-input" id="noteContentInput" placeholder="Contenu de la note..." rows="6"></textarea>
            </div>
            <div class="modal-actions">
                <button class="btn" onclick="closeModal('addNoteModal')">Annuler</button>
                <button class="btn btn-primary" onclick="addNote()">Créer</button>
            </div>
        </div>
    </div>

    <!-- Add Codex Entry Modal -->
    <div class="modal" id="addCodexModal">
        <div class="modal-content">
            <div class="modal-title">Nouvelle Entrée Codex</div>
            <div class="form-group">
                <label class="form-label">Titre</label>
                <input type="text" class="form-input" id="codexTitleInput" placeholder="Les Sanctuaires Shinto">
            </div>
            <div class="form-group">
                <label class="form-label">Catégorie</label>
                <select class="form-input" id="codexCategoryInput">
                    <option value="Culture">Culture</option>
                    <option value="Histoire">Histoire</option>
                    <option value="Technologie">Technologie</option>
                    <option value="Géographie">Géographie</option>
                    <option value="Politique">Politique</option>
                    <option value="Magie/Pouvoir">Magie/Pouvoir</option>
                    <option value="Religion">Religion</option>
                    <option value="Société">Société</option>
                    <option value="Autre">Autre</option>
                </select>
            </div>
            <div class="form-group">
                <label class="form-label">Résumé rapide</label>
                <textarea class="form-input" id="codexSummaryInput" placeholder="Description courte..." rows="3"></textarea>
            </div>
            <div class="modal-actions">
                <button class="btn" onclick="closeModal('addCodexModal')">Annuler</button>
                <button class="btn btn-primary" onclick="addCodexEntry()">Créer</button>
            </div>
        </div>
    </div>

    <!-- Projects Management Modal -->
    <div class="modal" id="projectsModal">
        <div class="modal-content" style="max-width: 800px;">
            <div class="modal-title"><i data-lucide="folder-open"></i> Mes Projets</div>
            
            <div class="modal-button-group" style="margin-bottom: 2rem;">
                <button class="btn btn-primary" onclick="openNewProjectModal()">+ Nouveau Projet</button>
                <button class="btn" onclick="importProject()">📥 Importer un projet</button>
            </div>

            <div id="projectsList" style="max-height: 400px; overflow-y: auto;">
                <!-- Projects will be listed here -->
            </div>

            <div class="modal-actions">
                <button class="btn" onclick="closeModal('projectsModal')">Fermer</button>
            </div>
        </div>
    </div>

    <!-- New Project Modal -->
    <div class="modal" id="newProjectModal">
        <div class="modal-content">
            <div class="modal-title">Nouveau Projet</div>
            
            <div class="form-group">
                <label class="form-label">Titre du projet</label>
                <input type="text" class="form-input" id="newProjectTitle" placeholder="Mon Roman">
            </div>
            
            <div class="form-group">
                <label class="form-label">Description (optionnel)</label>
                <textarea class="form-input" id="newProjectDesc" placeholder="Un roman de fantasy épique..." rows="3"></textarea>
            </div>
            
            <div class="form-group">
                <label class="form-label">Genre</label>
                <select class="form-input" id="newProjectGenre">
                    <option value="">Aucun</option>
                    <option value="Fantasy">Fantasy</option>
                    <option value="Science-Fiction">Science-Fiction</option>
                    <option value="Thriller">Thriller</option>
                    <option value="Romance">Romance</option>
                    <option value="Policier">Policier</option>
                    <option value="Horreur">Horreur</option>
                    <option value="Historique">Historique</option>
                    <option value="Aventure">Aventure</option>
                    <option value="Drame">Drame</option>
                    <option value="Autre">Autre</option>
                </select>
            </div>

            <div class="form-group">
                <label class="form-label">Utiliser un template ?</label>
                <select class="form-input" id="newProjectTemplate">
                    <option value="">Projet vide</option>
                    <option value="fantasy">Fantasy (3 actes + personnages types)</option>
                    <option value="thriller">Thriller (Structure suspense)</option>
                    <option value="scifi">Science-Fiction (Worldbuilding avancé)</option>
                </select>
            </div>
            
            <div class="modal-actions">
                <button class="btn" onclick="closeModal('newProjectModal')">Annuler</button>
                <button class="btn btn-primary" onclick="createNewProject()">Créer</button>
            </div>
        </div>
    </div>

    <input type="file" id="importProjectInput" accept=".json" style="display: none;" onchange="handleProjectImport(event)">

    <!-- Backup Menu Modal -->
    <div class="modal" id="backupModal">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-title"><i data-lucide="hard-drive"></i> Sauvegardes et Exports</div>
            
            <div style="margin-bottom: 2rem;">
                <div style="font-size: 1rem; font-weight: 600; margin-bottom: 1rem; color: var(--text-primary);"><i data-lucide="download" style="width:16px;height:16px;vertical-align:middle;margin-right:6px;"></i>Importer des données</div>
                <div style="display: flex; flex-direction: column; gap: 0.75rem;">
                    <button class="btn" onclick="importFromFile()">
                        <i data-lucide="folder-open" style="width:16px;height:16px;vertical-align:middle;margin-right:6px;"></i>Importer depuis un fichier JSON
                    </button>
                    <input type="file" id="importFileInput" accept=".json" style="display: none;" onchange="handleFileImport(event)">
                </div>
            </div>

            <div style="margin-bottom: 2rem;">
                <div style="font-size: 1rem; font-weight: 600; margin-bottom: 1rem; color: var(--text-primary);"><i data-lucide="upload" style="width:16px;height:16px;vertical-align:middle;margin-right:6px;"></i>Exporter les données</div>
                <div style="display: flex; flex-direction: column; gap: 0.75rem;">
                    <button class="btn btn-primary" onclick="openExportNovelModal()" style="font-weight: 600;">
                        <i data-lucide="book-open" style="width:16px;height:16px;vertical-align:middle;margin-right:6px;"></i>Exporter le roman (MD, TXT, HTML ...)
                    </button>
                    <button class="btn" onclick="exportToJSON()">
                        <i data-lucide="hard-drive" style="width:16px;height:16px;vertical-align:middle;margin-right:6px;"></i>Télécharger en JSON (sauvegarde complète)
                    </button>
                    <button class="btn" onclick="exportProject()">
                        <i data-lucide="file-text" style="width:16px;height:16px;vertical-align:middle;margin-right:6px;"></i>Exporter en TXT (texte seulement)
                    </button>
                </div>
            </div>

            <div style="margin-bottom: 2rem;">
                <div style="font-size: 1rem; font-weight: 600; margin-bottom: 1rem; color: var(--text-primary);"><i data-lucide="cloud" style="width:16px;height:16px;vertical-align:middle;margin-right:6px;"></i>Cloud (manuel)</div>
                <div style="padding: 1rem; background: var(--bg-secondary); border-radius: 4px; border: 1px solid var(--border-color);">
                    <p style="font-size: 0.9rem; color: var(--text-secondary); margin-bottom: 1rem; line-height: 1.6;">
                        Pour sauvegarder sur Google Drive, Dropbox, ou tout autre service cloud :
                    </p>
                    <ol style="font-size: 0.85rem; color: var(--text-secondary); line-height: 1.8; padding-left: 1.5rem;">
                        <li>Clique sur "Télécharger en JSON"</li>
                        <li>Le fichier contient TOUTES tes données</li>
                        <li>Uploade-le manuellement sur ton service cloud préféré</li>
                        <li>Pour restaurer : télécharge le fichier et utilise "Importer depuis un fichier"</li>
                    </ol>
                </div>
            </div>

            <div style="padding: 1rem; background: rgba(196, 69, 54, 0.1); border-radius: 4px; border: 1px solid var(--accent-red);">
                <div style="font-size: 0.85rem; font-weight: 600; color: var(--accent-red); margin-bottom: 0.5rem;">
                    ⚠️ Important : Sauvegarde régulière
                </div>
                <p style="font-size: 0.8rem; color: var(--text-secondary); line-height: 1.6;">
                    Le localStorage peut être effacé par le navigateur. Pense à exporter régulièrement ton projet en JSON et à le sauvegarder dans un endroit sûr (Google Drive, Dropbox, disque dur, etc.).
                </p>
            </div>

            <div class="modal-actions" style="margin-top: 1.5rem;">
                <button class="btn" onclick="closeModal('backupModal')">Fermer</button>
            </div>
        </div>
    </div>

    <!-- Export Novel Modal -->
    <div class="modal" id="exportNovelModal">
        <div class="modal-content" style="max-width: 700px; max-height: 90vh; overflow-y: auto;">
            <div class="modal-title"><i data-lucide="book-open"></i> Exporter votre roman</div>
            
            <p style="font-size: 0.95rem; color: var(--text-secondary); margin-bottom: 1.5rem; line-height: 1.6;">
                Vous pouvez exporter votre roman dans plusieurs formats. Vous pouvez ensuite importer les données dans d'autres logiciels d'écriture.
            </p>

            <!-- Toggle All Button -->
            <div style="margin-bottom: 1.5rem;">
                <button class="btn btn-small" onclick="toggleAllScenes()" style="width: 100%;">
                    🔄 Tout sélectionner / Tout désélectionner
                </button>
            </div>

            <!-- Acts/Chapters/Scenes Selection Tree -->
            <div style="margin-bottom: 1.5rem; max-height: 300px; overflow-y: auto; border: 1px solid var(--border-color); border-radius: 6px; padding: 1rem; background: var(--bg-secondary);" id="exportTreeContainer">
                <!-- Will be populated by JavaScript -->
            </div>

            <!-- Format Selection -->
            <div style="margin-bottom: 1.5rem;">
                <label style="display: block; font-weight: 600; margin-bottom: 0.75rem; color: var(--text-primary);">
                    Format du fichier
                </label>
                <select id="exportFormatSelect" onchange="updateExportFormatInfo()" style="width: 100%; padding: 0.75rem; background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); font-size: 0.95rem; font-family: 'Crimson Pro', serif;">
                    <option value="markdown">📝 Markdown (.md)</option>
                    <option value="txt">📋 Texte brut (.txt)</option>
                    <option value="html">🌐 HTML (.html)</option>
                    <option value="epub">📚 EPUB (.epub)</option>
                </select>
                <div id="formatInfoBox" style="margin-top: 0.75rem; padding: 0.75rem; background: rgba(212, 175, 55, 0.1); border-radius: 4px; border: 1px solid var(--accent-gold); font-size: 0.85rem; color: var(--text-secondary); line-height: 1.5;">
                    <strong style="color: var(--text-primary);">ℹ️ Note :</strong> 
                    Toutes les fonctionnalités ne sont pas supportées en format DOCX. Le texte exporté pourrait ne pas ressembler exactement à l'éditeur. Pour une compatibilité complète, utilisez un autre format.
                </div>
            </div>

            <!-- General Options -->
            <div style="margin-bottom: 1.5rem;">
                <label style="display: block; font-weight: 600; margin-bottom: 0.75rem; color: var(--text-primary);">
                    Options générales
                </label>
                <div style="display: flex; flex-direction: column; gap: 0.5rem;">
                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-size: 0.95rem;">
                        <input type="checkbox" id="exportSummariesCheck" style="cursor: pointer;">
                        <span>Exporter les résumés</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-size: 0.95rem;">
                        <input type="checkbox" id="exportProseCheck" checked style="cursor: pointer;">
                        <span>Exporter le texte</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-size: 0.95rem;">
                        <input type="checkbox" id="includeActTitlesCheck" checked style="cursor: pointer;">
                        <span>Inclure les titres d'actes <span style="color: var(--text-muted); font-size: 0.85rem;">(désactiver pour ex. Vellum, Atticus)</span></span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-size: 0.95rem;">
                        <input type="checkbox" id="includeSceneSubtitlesCheck" checked style="cursor: pointer;">
                        <span>Inclure les sous-titres de scènes</span>
                    </label>
                </div>
            </div>

            <!-- Scene Dividers -->
            <div style="margin-bottom: 1.5rem;">
                <label style="display: block; font-weight: 600; margin-bottom: 0.75rem; color: var(--text-primary);">
                    Séparateurs de scènes
                </label>
                <select id="sceneDividerSelect" style="width: 100%; padding: 0.75rem; background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); font-size: 0.95rem; font-family: 'Crimson Pro', serif;">
                    <option value="asterisks">Astérisques ( * * * )</option>
                    <option value="hash">Dièse ( ### )</option>
                    <option value="line">Ligne horizontale (---)</option>
                    <option value="space">Espace vide</option>
                    <option value="none">Aucun séparateur</option>
                </select>
            </div>

            <!-- Project Export (ZIP with all data) -->
            <div style="margin-bottom: 1.5rem; padding: 1rem; background: var(--bg-secondary); border-radius: 6px; border: 1px solid var(--border-color);">
                <label style="display: block; font-weight: 600; margin-bottom: 0.75rem; color: var(--text-primary);">
                    Export du projet complet
                </label>
                <p style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 1rem; line-height: 1.5;">
                    En exportant le projet complet, le fichier résultant sera une archive ZIP contenant tout le contenu sélectionné.
                </p>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-size: 0.95rem;">
                        <input type="checkbox" id="includeCharactersCheck" style="cursor: pointer;">
                        <span>👤 Personnages</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-size: 0.95rem;">
                        <input type="checkbox" id="includeWorldCheck" style="cursor: pointer;">
                        <span>🌍 Univers</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-size: 0.95rem;">
                        <input type="checkbox" id="includeTimelineCheck" style="cursor: pointer;">
                        <span>📅 Timeline</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-size: 0.95rem;">
                        <input type="checkbox" id="includeRelationsCheck" style="cursor: pointer;">
                        <span>🔗 Relations</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-size: 0.95rem;">
                        <input type="checkbox" id="includeCodexCheck" style="cursor: pointer;">
                        <span>📚 Codex</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-size: 0.95rem;">
                        <input type="checkbox" id="includeNotesCheck" style="cursor: pointer;">
                        <span>📝 Notes</span>
                    </label>
                </div>
                <div style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px dashed var(--border-color);">
                    <button onclick="toggleAllExportOptions(true)" class="btn btn-small" style="margin-right: 0.5rem; font-size: 0.8rem; padding: 0.3rem 0.6rem;">
                        Tout sélectionner
                    </button>
                    <button onclick="toggleAllExportOptions(false)" class="btn btn-small" style="font-size: 0.8rem; padding: 0.3rem 0.6rem;">
                        Tout désélectionner
                    </button>
                </div>
            </div>

            <!-- Export Button -->
            <div style="text-align: center; padding-top: 1rem; border-top: 1px solid var(--border-color);">
                <button class="btn btn-primary" onclick="executeNovelExport()" style="padding: 0.75rem 2rem; font-size: 1rem; font-weight: 600;">
                    📥 Exporter
                </button>
            </div>

            <div class="modal-actions" style="margin-top: 1rem;">
                <button class="btn" onclick="closeModal('exportNovelModal')">Annuler</button>
            </div>
        </div>
    </div>

    <!-- Tension Words Editor Modal -->
    <div class="modal" id="tensionWordsModal">
        <div class="modal-content" style="max-width: 900px;">
            <div class="modal-title">✏️ Personnaliser les mots de tension</div>
            
            <div style="margin-bottom: 1.5rem; padding: 1rem; background: var(--bg-secondary); border-radius: 6px; border: 1px solid var(--border-color);">
                <p style="font-size: 0.9rem; color: var(--text-secondary); line-height: 1.6; margin: 0;">
                    Ces mots sont utilisés pour calculer automatiquement la tension narrative de vos scènes. 
                    Personnalisez-les selon votre style d'écriture et le genre de votre roman.
                </p>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 1.5rem; margin-bottom: 1.5rem;">
                <!-- High Tension Words -->
                <div style="background: var(--bg-secondary); border-radius: 8px; padding: 1.25rem; border: 2px solid rgba(196, 69, 54, 0.3);">
                    <h3 style="margin: 0 0 0.75rem 0; font-size: 1rem; color: var(--accent-red); display: flex; align-items: center; gap: 0.5rem;">
                        🔥 Haute tension
                        <span style="font-size: 0.75rem; color: var(--text-muted); font-weight: normal;">(+3 pts chacun)</span>
                    </h3>
                    <div style="margin-bottom: 0.75rem;">
                        <input type="text" id="highTensionInput" placeholder="Ajouter un mot..." 
                               style="width: 100%; padding: 0.5rem; background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); font-size: 0.85rem;"
                               onkeypress="if(event.key==='Enter') addTensionWord('high')">
                        <button onclick="addTensionWord('high')" 
                                style="width: 100%; margin-top: 0.5rem; padding: 0.5rem; background: var(--accent-red); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85rem; font-weight: 500;">
                            + Ajouter
                        </button>
                        <button onclick="openBulkImport('high')" 
                                style="width: 100%; margin-top: 0.5rem; padding: 0.5rem; background: rgba(196, 69, 54, 0.2); color: var(--accent-red); border: 1px solid var(--accent-red); border-radius: 4px; cursor: pointer; font-size: 0.85rem; font-weight: 500;">
                            📥 Import en masse
                        </button>
                    </div>
                    <div id="highTensionList" style="max-height: 300px; overflow-y: auto; display: flex; flex-direction: column; gap: 0.4rem;">
                        <!-- Words will be added here -->
                    </div>
                </div>

                <!-- Medium Tension Words -->
                <div style="background: var(--bg-secondary); border-radius: 8px; padding: 1.25rem; border: 2px solid rgba(230, 162, 60, 0.3);">
                    <h3 style="margin: 0 0 0.75rem 0; font-size: 1rem; color: #e6a23c; display: flex; align-items: center; gap: 0.5rem;">
                        ⚡ Tension moyenne
                        <span style="font-size: 0.75rem; color: var(--text-muted); font-weight: normal;">(+1.5 pts chacun)</span>
                    </h3>
                    <div style="margin-bottom: 0.75rem;">
                        <input type="text" id="mediumTensionInput" placeholder="Ajouter un mot..." 
                               style="width: 100%; padding: 0.5rem; background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); font-size: 0.85rem;"
                               onkeypress="if(event.key==='Enter') addTensionWord('medium')">
                        <button onclick="addTensionWord('medium')" 
                                style="width: 100%; margin-top: 0.5rem; padding: 0.5rem; background: #e6a23c; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85rem; font-weight: 500;">
                            + Ajouter
                        </button>
                        <button onclick="openBulkImport('medium')" 
                                style="width: 100%; margin-top: 0.5rem; padding: 0.5rem; background: rgba(230, 162, 60, 0.2); color: #e6a23c; border: 1px solid #e6a23c; border-radius: 4px; cursor: pointer; font-size: 0.85rem; font-weight: 500;">
                            📥 Import en masse
                        </button>
                    </div>
                    <div id="mediumTensionList" style="max-height: 300px; overflow-y: auto; display: flex; flex-direction: column; gap: 0.4rem;">
                        <!-- Words will be added here -->
                    </div>
                </div>

                <!-- Low Tension Words -->
                <div style="background: var(--bg-secondary); border-radius: 8px; padding: 1.25rem; border: 2px solid rgba(74, 144, 226, 0.3);">
                    <h3 style="margin: 0 0 0.75rem 0; font-size: 1rem; color: var(--accent-blue); display: flex; align-items: center; gap: 0.5rem;">
                        🌊 Faible tension
                        <span style="font-size: 0.75rem; color: var(--text-muted); font-weight: normal;">(-2 pts chacun)</span>
                    </h3>
                    <div style="margin-bottom: 0.75rem;">
                        <input type="text" id="lowTensionInput" placeholder="Ajouter un mot..." 
                               style="width: 100%; padding: 0.5rem; background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); font-size: 0.85rem;"
                               onkeypress="if(event.key==='Enter') addTensionWord('low')">
                        <button onclick="addTensionWord('low')" 
                                style="width: 100%; margin-top: 0.5rem; padding: 0.5rem; background: #2d6bb3; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85rem; font-weight: 500;">
                            + Ajouter
                        </button>
                        <button onclick="openBulkImport('low')" 
                                style="width: 100%; margin-top: 0.5rem; padding: 0.5rem; background: rgba(45, 107, 179, 0.15); color: #2d6bb3; border: 1px solid #2d6bb3; border-radius: 4px; cursor: pointer; font-size: 0.85rem; font-weight: 500;">
                            📥 Import en masse
                        </button>
                    </div>
                    <div id="lowTensionList" style="max-height: 300px; overflow-y: auto; display: flex; flex-direction: column; gap: 0.4rem;">
                        <!-- Words will be added here -->
                    </div>
                </div>
            </div>

            <div class="modal-actions" style="display: flex; justify-content: space-between; align-items: center;">
                <div style="display: flex; gap: 0.75rem;">
                    <button class="btn" onclick="exportTensionWords()" style="background: #2d6bb3; color: white; border: 1px solid #2d6bb3;">
                        📤 Exporter les dictionnaires
                    </button>
                    <button class="btn" onclick="resetTensionWordsToDefault()" style="background: var(--accent-red); color: white;">
                        🔄 Réinitialiser aux valeurs par défaut
                    </button>
                </div>
                <div style="display: flex; gap: 0.75rem;">
                    <button class="btn" onclick="closeModal('tensionWordsModal')">Annuler</button>
                    <button class="btn btn-primary" onclick="saveTensionWords()">💾 Enregistrer</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Bulk Import Modal -->
    <div class="modal" id="bulkImportModal">
        <div class="modal-content" style="max-width: 700px;">
            <div class="modal-title" id="bulkImportTitle">📥 Import en masse</div>
            
            <div style="margin-bottom: 1.5rem;">
                <p style="font-size: 0.9rem; color: var(--text-secondary); line-height: 1.6; margin-bottom: 1rem;">
                    Importez une liste de mots en masse. Vous pouvez :
                </p>
                <ul style="font-size: 0.85rem; color: var(--text-secondary); line-height: 1.8; padding-left: 1.5rem;">
                    <li><strong>Coller du texte</strong> : Un mot par ligne ou séparés par des virgules</li>
                    <li><strong>Importer un fichier</strong> : Fichier .txt avec un mot par ligne</li>
                </ul>
            </div>

            <div style="margin-bottom: 1.5rem;">
                <label class="form-label">Collez vos mots ici :</label>
                <textarea id="bulkImportText" 
                          placeholder="Ex: combat, bataille, mort&#10;tuer, danger, peur&#10;terreur, cri, hurler" 
                          style="width: 100%; min-height: 200px; padding: 0.75rem; background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); font-size: 0.85rem; font-family: monospace; resize: vertical;">
                </textarea>
                <div style="font-size: 0.75rem; color: var(--text-muted); margin-top: 0.5rem;">
                    💡 Formats acceptés : un mot par ligne, ou plusieurs mots séparés par des virgules
                </div>
            </div>

            <div style="margin-bottom: 1.5rem;">
                <label class="form-label">Ou importez un fichier .txt :</label>
                <input type="file" id="bulkImportFile" accept=".txt" 
                       style="width: 100%; padding: 0.5rem; background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); font-size: 0.85rem;">
            </div>

            <div style="padding: 1rem; background: rgba(74, 144, 226, 0.1); border-radius: 4px; border: 1px solid var(--accent-blue); margin-bottom: 1.5rem;">
                <div style="font-size: 0.85rem; font-weight: 600; color: var(--accent-blue); margin-bottom: 0.5rem;">
                    ℹ️ Mode de fusion
                </div>
                <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; margin-bottom: 0.5rem;">
                    <input type="radio" name="importMode" value="add" checked>
                    <span style="font-size: 0.85rem; color: var(--text-primary);">Ajouter aux mots existants (recommandé)</span>
                </label>
                <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                    <input type="radio" name="importMode" value="replace">
                    <span style="font-size: 0.85rem; color: var(--text-primary);">Remplacer tous les mots existants</span>
                </label>
            </div>

            <div class="modal-actions">
                <button class="btn" onclick="closeModal('bulkImportModal')">Annuler</button>
                <button class="btn btn-primary" onclick="processBulkImport()">📥 Importer les mots</button>
            </div>
        </div>
    </div>

    <!-- References Panel Modal -->
    <div class="modal" id="referencesModal">
        <div class="modal-content" style="max-width: 700px;">
            <div class="modal-title" id="referencesModalTitle">Références et Liens</div>
            <div id="referencesModalContent"></div>
            <div class="modal-actions">
                <button class="btn" onclick="closeModal('referencesModal')">Fermer</button>
            </div>
        </div>
    </div>


    <!-- Annotations Panel -->
    <div class="annotations-panel" id="annotationsPanel">
        <div class="annotations-panel-spacer"></div>
        <div class="annotations-panel-content" id="annotationsPanelContent"></div>
    </div>

    <!-- TODOs Panel -->
    <div class="annotations-panel" id="todosPanel">
        <div class="annotations-panel-spacer"></div>
        <div class="annotations-panel-content" id="todosPanelContent"></div>
    </div>

    <!-- Annotation Popup -->
    <div class="annotation-popup" id="annotationPopup">
        <h3 style="margin-bottom: 1rem;">Ajouter une annotation</h3>
        <div class="annotation-type-selector">
            <div class="annotation-type-btn comment active" onclick="selectAnnotationType('comment')"><i data-lucide="message-circle" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Commentaire</div>
            <div class="annotation-type-btn todo" onclick="selectAnnotationType('todo')"><i data-lucide="check-square" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>TODO</div>
            <div class="annotation-type-btn note" onclick="selectAnnotationType('note')"><i data-lucide="sticky-note" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Note</div>
            <div class="annotation-type-btn question" onclick="selectAnnotationType('question')">? Question</div>
        </div>
        <textarea id="annotationText" placeholder="Votre annotation..."></textarea>
        <div style="display: flex; gap: 0.75rem; justify-content: flex-end;">
            <button class="btn" onclick="closeAnnotationPopup()">Annuler</button>
            <button class="btn btn-primary" onclick="saveAnnotation()">Enregistrer</button>
        </div>
    </div>

    <!-- Floating Editor Menu Toggle Button (Mobile) -->
    <button id="floatingEditorToggle" onclick="toggleFloatingEditorMenu()">✏️</button>

    <!-- Floating Editor Menu (Mobile) -->
    <div id="floatingEditorMenu">
        <div id="floatingMenuContent">
            <!-- Annuler/Rétablir -->
            <button class="floating-btn-mini" onclick="undo()" title="Annuler">↶</button>
            <button class="floating-btn-mini" onclick="redo()" title="Rétablir">↷</button>
            
            <div class="floating-divider"></div>
            
            <!-- Formatage de base -->
            <button class="floating-btn-mini" onclick="formatText('bold')" title="Gras"><b>B</b></button>
            <button class="floating-btn-mini" onclick="formatText('italic')" title="Italique"><i>I</i></button>
            <button class="floating-btn-mini" onclick="formatText('underline')" title="Souligné"><u>U</u></button>
            <button class="floating-btn-mini" onclick="formatText('strikeThrough')" title="Barré"><s>S</s></button>
            
            <div class="floating-divider"></div>
            
            <!-- Alignement -->
            <button class="floating-btn-mini" onclick="formatText('justifyLeft')" title="Aligner à gauche">⬅</button>
            <button class="floating-btn-mini" onclick="formatText('justifyCenter')" title="Centrer">↔</button>
            <button class="floating-btn-mini" onclick="formatText('justifyRight')" title="Aligner à droite">➡</button>
            <button class="floating-btn-mini" onclick="formatText('justifyFull')" title="Justifier">⬌</button>
            
            <div class="floating-divider"></div>
            
            <!-- Listes -->
            <button class="floating-btn-mini" onclick="formatText('insertUnorderedList')" title="Liste à puces">•</button>
            <button class="floating-btn-mini" onclick="formatText('insertOrderedList')" title="Liste numérotée">1.</button>
            
            <div class="floating-divider"></div>
            
            <!-- Plus d'options - Toggle sous-menu -->
            <button class="floating-btn-mini" onclick="toggleAdvancedMenu()" id="advancedMenuBtn" title="Plus d'options">⋮</button>
        </div>
        
        <!-- Barre de sous-menu avancé (apparaît au-dessus grâce à column-reverse) -->
        <div id="advancedMenuBar" style="display: none;">
            <button class="floating-btn-mini" onclick="formatText('removeFormat')" title="Supprimer le formatage">🚫</button>
            <button class="floating-btn-mini" onclick="insertLink()" title="Insérer un lien"><i data-lucide="link" style="width:16px;height:16px;"></i></button>
            <button class="floating-btn-mini" onclick="formatText('formatBlock', 'h1')" title="Titre 1">H1</button>
            <button class="floating-btn-mini" onclick="formatText('formatBlock', 'h2')" title="Titre 2">H2</button>
            <button class="floating-btn-mini" onclick="formatText('formatBlock', 'h3')" title="Titre 3">H3</button>
            <button class="floating-btn-mini" onclick="formatText('formatBlock', 'blockquote')" title="Citation">❝</button>
            <button class="floating-btn-mini" onclick="formatText('insertHorizontalRule')" title="Ligne horizontale">―</button>
        </div>
    </div>
            <button class="floating-btn-mini" onclick="formatText('insertUnorderedList')" title="Liste à puces">•</button>
            <button class="floating-btn-mini" onclick="formatText('insertOrderedList')" title="Liste numérotée">1.</button>
            
            <div class="floating-divider"></div>
            
            <!-- Plus d'options - Toggle sous-menu -->
            <button class="floating-btn-mini" onclick="toggleAdvancedMenu()" id="advancedMenuBtn" title="Plus d'options">⋮</button>
        </div>
    </div>


    <script>
// ========== 01.app.js ==========
        // Data Structure
        let projects = []; // Array of all projects
        let currentProjectId = null;
        let project = {
            id: null,
            title: "Mon Roman",
            description: "",
            genre: "",
            createdAt: null,
            updatedAt: null,
            acts: [], // Acts contain chapters, chapters contain scenes
            characters: [], // Character database
            world: [], // World elements (locations, objects, concepts)
            timeline: [], // Timeline events
            notes: [], // Standalone notes and research
            codex: [], // Wiki/Codex entries for worldbuilding
            stats: {
                dailyGoal: 500,
                totalGoal: 80000,
                writingSessions: [] // Track writing sessions with word count and date
            },
            versions: [], // Version history snapshots
            relationships: [], // Cross-references between elements
            relations: [], // Character relations with types and colors
            characterPositions: {}, // Custom positions for relations graph
            mapLocations: [], // Geographic map markers
            mapImage: null, // Map image data URL
            visualTimeline: [], // Timeline visualization events
            metroTimeline: [], // Metro-style timeline with character links
            characterColors: {}, // Colors for metro timeline lines
            mindmaps: [], // Custom mindmaps with nodes and links
            thrillerElements: [], // Thriller mystery elements (alibis, clues, secrets, etc.)
            thrillerConnections: [] // Connections between thriller elements
        };

        let currentActId = null;
        let currentChapterId = null;
        let currentSceneId = null;
        let activeActId = null;
        let activeChapterId = null;
        let currentView = 'editor'; // 'editor', 'characters', 'world', 'timeline', 'notes', 'stats', 'codex', 'versions'
        let currentMindmapId = null; // ID du mindmap actuellement affiché
        
        // SPLIT VIEW SYSTEM - New Architecture
        let splitViewActive = false;
        let splitActivePanel = 'left'; // 'left' or 'right' - which panel is currently active
        let splitViewState = {
            left: {
                view: 'editor',
                sceneId: null,
                actId: null,
                chapterId: null,
                characterId: null,
                worldId: null,
                noteId: null,
                codexId: null
            },
            right: {
                view: null, // null = empty
                sceneId: null,
                actId: null,
                chapterId: null,
                characterId: null,
                worldId: null,
                noteId: null,
                codexId: null
            },
            ratio: 60,
            persistOnReload: true
        };

        // TREE STATE - pour mémoriser l'état d'expansion
        let expandedActs = new Set(); // IDs des actes dépliés
        let expandedChapters = new Set(); // IDs des chapitres dépliés

        // REVISION MODE VARIABLES
        let revisionMode = false;
        let selectedHighlightColor = 'yellow';
        let selectedAnnotationType = 'comment';
        let currentSelection = null; // 'editor', 'characters', 'world', 'timeline', 'notes', 'stats', 'codex', 'versions'

        // UNDO/REDO SYSTEM
        let historyStack = []; // Stack pour les états précédents
        let redoStack = []; // Stack pour redo
        let maxHistorySize = 50; // Garder max 50 états
        let isUndoRedoAction = false; // Flag pour éviter de sauvegarder pendant undo/redo
        let historyDebounceTimer = null; // Timer pour debounce
        let historyDebounceDelay = 2000; // 2 secondes de délai



// ========== 02.storage.js ==========
        // ============================================
        // INDEXEDDB FUNCTIONS
        // ============================================
        
        let db = null; // Instance de la base de données
        let useLocalStorage = false; // Fallback si IndexedDB échoue
        
        // Initialiser IndexedDB
        async function initDB() {
            try {
                console.log('🔧 Initialisation IndexedDB...');
                
                // Vérifier si IndexedDB est disponible
                if (!window.indexedDB) {
                    console.warn('⚠️ IndexedDB non disponible, utilisation de localStorage');
                    useLocalStorage = true;
                    return true;
                }
                
                // Vérifier si idb est chargé
                if (typeof idb === 'undefined') {
                    console.warn('⚠️ Bibliothèque idb non chargée, utilisation de localStorage');
                    useLocalStorage = true;
                    return true;
                }
                
                // Ouvrir (ou créer) la base de données
                db = await idb.openDB('PlumeDB', 1, {
                    upgrade(db) {
                        // Créer les object stores si ils n'existent pas
                        if (!db.objectStoreNames.contains('projects')) {
                            db.createObjectStore('projects', { keyPath: 'id' });
                            console.log('✅ Object store "projects" créé');
                        }
                        if (!db.objectStoreNames.contains('settings')) {
                            db.createObjectStore('settings');
                            console.log('✅ Object store "settings" créé');
                        }
                    }
                });
                
                console.log('✅ IndexedDB initialisé avec succès');
                
                // Migrer depuis localStorage si nécessaire
                await migrateFromLocalStorage();
                
                return true;
            } catch (error) {
                console.error('❌ Erreur initialisation IndexedDB:', error);
                console.warn('⚠️ Fallback vers localStorage');
                useLocalStorage = true;
                return true; // Retourne true pour continuer avec localStorage
            }
        }
        async function migrateFromLocalStorage() {
            try {
                // Vérifier si migration déjà effectuée
                const migrated = await db.get('settings', 'migrated_from_localStorage');
                if (migrated) {
                    console.log('✅ Migration déjà effectuée précédemment');
                    return;
                }
                
                console.log('🔄 Vérification des données localStorage...');
                
                // Récupérer les anciennes données
                const oldData = localStorage.getItem('novelcraft_project');
                const oldProjects = localStorage.getItem('novelcraft_projects');
                const oldCurrentId = localStorage.getItem('novelcraft_currentProjectId');
                const oldTreeState = localStorage.getItem('treeState');
                
                if (!oldData && !oldProjects) {
                    console.log('ℹ️ Aucune donnée à migrer');
                    await db.put('settings', true, 'migrated_from_localStorage');
                    return;
                }
                
                console.log('📦 Migration des données...');
                
                // Migrer le projet actuel
                if (oldData) {
                    try {
                        const projectData = JSON.parse(oldData);
                        
                        // S'assurer qu'il a un ID
                        if (!projectData.id) {
                            projectData.id = 'project_' + Date.now();
                        }
                        
                        // S'assurer qu'il a des timestamps
                        if (!projectData.createdAt) {
                            projectData.createdAt = Date.now();
                        }
                        if (!projectData.updatedAt) {
                            projectData.updatedAt = Date.now();
                        }
                        
                        await db.put('projects', projectData);
                        console.log('✅ Projet principal migré:', projectData.title);
                    } catch (e) {
                        console.error('❌ Erreur migration projet:', e);
                    }
                }
                
                // Migrer la liste des projets
                if (oldProjects) {
                    try {
                        const projectsList = JSON.parse(oldProjects);
                        for (const proj of projectsList) {
                            // Éviter les doublons
                            const existing = await db.get('projects', proj.id);
                            if (!existing) {
                                await db.put('projects', proj);
                                console.log('✅ Projet migré:', proj.title);
                            }
                        }
                    } catch (e) {
                        console.error('❌ Erreur migration liste projets:', e);
                    }
                }
                
                // Migrer les settings
                if (oldCurrentId) {
                    await db.put('settings', oldCurrentId, 'currentProjectId');
                }
                if (oldTreeState) {
                    await db.put('settings', oldTreeState, 'treeState');
                }
                
                // Marquer la migration comme effectuée
                await db.put('settings', true, 'migrated_from_localStorage');
                
                console.log('✅ Migration terminée avec succès !');
                console.log('ℹ️ Les anciennes données localStorage sont conservées par sécurité');
                
                // NE PAS supprimer localStorage pour l'instant (sécurité)
                // L'utilisateur pourra le faire manuellement plus tard
                
            } catch (error) {
                console.error('❌ Erreur lors de la migration:', error);
            }
        }
        
        // Sauvegarder un projet dans IndexedDB
        async function saveProjectToDB(projectData) {
            try {
                if (!db) {
                    console.error('❌ Base de données non initialisée');
                    return false;
                }
                
                // S'assurer que le projet a un ID
                if (!projectData.id) {
                    projectData.id = 'project_' + Date.now();
                }
                
                // Mettre à jour le timestamp
                projectData.updatedAt = Date.now();
                
                // Sauvegarder dans IndexedDB
                await db.put('projects', projectData);
                
                console.log('💾 Projet sauvegardé dans IndexedDB:', projectData.title);
                return true;
            } catch (error) {
                console.error('❌ Erreur sauvegarde IndexedDB:', error);
                alert('Erreur lors de la sauvegarde. Veuillez exporter votre projet par sécurité.');
                return false;
            }
        }
        
        // Charger un projet depuis IndexedDB
        async function loadProjectFromDB(projectId) {
            try {
                if (!db) {
                    console.error('❌ Base de données non initialisée');
                    return null;
                }
                
                const projectData = await db.get('projects', projectId);
                
                if (projectData) {
                    console.log('📖 Projet chargé depuis IndexedDB:', projectData.title);
                    return projectData;
                } else {
                    console.log('ℹ️ Projet non trouvé:', projectId);
                    return null;
                }
            } catch (error) {
                console.error('❌ Erreur chargement IndexedDB:', error);
                return null;
            }
        }
        
        // Charger tous les projets
        async function loadAllProjectsFromDB() {
            try {
                if (!db) {
                    console.error('❌ Base de données non initialisée');
                    return [];
                }
                
                const allProjects = await db.getAll('projects');
                console.log(`📚 ${allProjects.length} projet(s) chargé(s)`);
                return allProjects;
            } catch (error) {
                console.error('❌ Erreur chargement projets:', error);
                return [];
            }
        }
        
        // Supprimer un projet
        async function deleteProjectFromDB(projectId) {
            try {
                if (!db) {
                    console.error('❌ Base de données non initialisée');
                    return false;
                }
                
                await db.delete('projects', projectId);
                console.log('🗑️ Projet supprimé:', projectId);
                return true;
            } catch (error) {
                console.error('❌ Erreur suppression projet:', error);
                return false;
            }
        }
        
        // Obtenir la taille totale utilisée par IndexedDB
        async function getIndexedDBSize() {
            try {
                if (!db) return 0;
                
                const allProjects = await db.getAll('projects');
                const allSettings = await db.getAll('settings');
                
                // Calculer la taille approximative
                const projectsSize = JSON.stringify(allProjects).length * 2; // UTF-16
                const settingsSize = JSON.stringify(allSettings).length * 2;
                
                return projectsSize + settingsSize;
            } catch (error) {
                console.error('❌ Erreur calcul taille IndexedDB:', error);
                return 0;
            }
        }
        
        // Sauvegarder un setting
        async function saveSetting(key, value) {
            try {
                if (!db) return false;
                await db.put('settings', value, key);
                return true;
            } catch (error) {
                console.error('❌ Erreur sauvegarde setting:', error);
                return false;
            }
        }
        
        // Charger un setting
        async function loadSetting(key) {
            try {
                if (!db) return null;
                return await db.get('settings', key);
            } catch (error) {
                console.error('❌ Erreur chargement setting:', error);
                return null;
            }
        }

        // ============================================
        // END INDEXEDDB FUNCTIONS
        // ============================================


// ========== 03.project.js ==========

        // View Management (définie tôt pour être accessible partout)
        function switchView(view) {
            // Si split view actif, changer la vue du panneau actif
            if (splitViewActive) {
                switchSplitPanelView(splitActivePanel, view);
                return;
            }
            
            currentView = view;
            
            // Update header nav buttons
            document.querySelectorAll('[id^="header-tab-"]').forEach(btn => {
                btn.classList.remove('active');
            });
            const headerBtn = document.getElementById(`header-tab-${view}`);
            if (headerBtn) {
                headerBtn.classList.add('active');
            }
            
            // Éléments spécifiques à la vue Structure
            const structureOnlyElements = [
                'projectProgressBar',  // Barre de progression
                'statusFilters',       // Filtres Brouillon/En cours/Terminé/À réviser
                'sceneTools'           // Boutons Versions/Annotations/TODOs
            ];
            
            // Masquer/Afficher les éléments Structure uniquement
            structureOnlyElements.forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    el.style.display = (view === 'editor') ? '' : 'none';
                }
            });
            
            // Update tree collapse toolbar visibility (for views with collapsible groups)
            const treeCollapseToolbar = document.getElementById('treeCollapseToolbar');
            const viewsWithGroups = ['editor', 'world', 'notes', 'codex'];
            if (treeCollapseToolbar) {
                treeCollapseToolbar.style.display = viewsWithGroups.includes(view) ? '' : 'none';
            }
            
            // Gérer la sidebar des versions (à droite)
            const sidebarVersions = document.getElementById('sidebarVersions');
            if (sidebarVersions) {
                // Toujours cacher par défaut lors du changement de vue
                // L'utilisateur peut l'ouvrir manuellement s'il le souhaite
                if (view !== 'editor') {
                    sidebarVersions.classList.add('hidden');
                }
                // Si on est en vue editor, ne rien changer (garde l'état actuel)
            }
            
            // Cacher toutes les listes de la sidebar
            const sidebarLists = [
                'chaptersList', 'charactersList', 'worldList', 'timelineList', 
                'notesList', 'codexList', 'arcsList', 'statsList', 'versionsList', 'analysisList',
                'todosList', 'corkboardList', 'mindmapList', 'plotList', 
                'relationsList', 'mapList', 'timelineVizList', 'storyGridList', 'noSidebarMessage'
            ];
            
            sidebarLists.forEach(listId => {
                const el = document.getElementById(listId);
                if (el) el.style.display = 'none';
            });
            
            // Vues qui utilisent la sidebar (listes à gauche)
            const sidebarViews = {
                'editor': 'chaptersList',
                'characters': 'charactersList',
                'world': 'worldList',
                'notes': 'notesList',
                'codex': 'codexList',
                'arcs': 'arcsList',
                'mindmap': 'mindmapList',
                'timelineviz': 'timelineVizList'
            };
            
            // Vues qui utilisent editorView entièrement (visualisations plein écran sans sidebar)
            const editorViewVues = ['stats', 'analysis', 'versions', 'todos', 'timeline', 'corkboard', 'plot', 'relations', 'map', 'thriller'];
            
            // Labels pour les vues sans sidebar
            const viewLabelsNoSidebar = {
                'stats': 'Statistiques',
                'analysis': 'Analyse',
                'versions': 'Versions',
                'todos': 'TODOs',
                'timeline': 'Timeline',
                'corkboard': 'Tableau',
                'plot': 'Intrigue',
                'relations': 'Relations',
                'map': 'Carte',
                'thriller': 'Thriller',
                'storygrid': 'Story Grid'
            };
            
            // Afficher la bonne liste sidebar si applicable
            if (sidebarViews[view]) {
                const listEl = document.getElementById(sidebarViews[view]);
                if (listEl) listEl.style.display = 'block';
            } else if (editorViewVues.includes(view)) {
                // Afficher le message pour les vues sans sidebar
                const noSidebarEl = document.getElementById('noSidebarMessage');
                if (noSidebarEl) {
                    const viewLabel = viewLabelsNoSidebar[view] || 'Cette vue';
                    noSidebarEl.innerHTML = `
                        <div style="padding: 2rem 1rem; text-align: center; color: var(--text-muted);">
                            <i data-lucide="layout-dashboard" style="width: 48px; height: 48px; opacity: 0.3; margin-bottom: 1rem;"></i>
                            <div style="font-size: 0.9rem; line-height: 1.6;">
                                <strong>${viewLabel}</strong> utilise tout l'espace disponible.
                            </div>
                            <div style="font-size: 0.85rem; margin-top: 0.5rem; opacity: 0.8;">
                                La barre latérale n'est pas utilisée dans cette vue.
                            </div>
                        </div>
                    `;
                    noSidebarEl.style.display = 'block';
                    
                    // Refresh icons
                    setTimeout(() => {
                        if (typeof lucide !== 'undefined') lucide.createIcons();
                    }, 50);
                }
            }
            
            // Sur mobile, créer une vue centrale pour les vues sidebar
            const isMobile = window.innerWidth <= 900;
            const editorView = document.getElementById('editorView');
            
            if (isMobile && sidebarViews[view]) {
                // Créer une vue mobile pour les vues avec sidebar
                renderMobileSidebarView(view);
            } else if (editorViewVues.includes(view)) {
                // Ces vues remplissent l'editorView
                if (editorView) {
                    // Le contenu sera rempli par les fonctions de rendu
                }
            }
            
            // Update sidebar actions
            const actionsHTML = {
                editor: '<button class="btn btn-primary" onclick="openAddActModal()">+ Acte</button><button class="btn btn-primary" onclick="openAddChapterModal()">+ Chapitre</button><button class="btn btn-primary" onclick="openAddSceneModalQuick()">+ Scène</button>',
                characters: '<button class="btn btn-primary" onclick="openAddCharacterModal()">+ Personnage</button>',
                world: '<button class="btn btn-primary" onclick="openAddWorldModal()">+ Élément</button>',
                notes: '<button class="btn btn-primary" onclick="openAddNoteModal()">+ Note</button>',
                codex: '<button class="btn btn-primary" onclick="openAddCodexModal()">+ Entrée</button>',
                arcs: '<button class="btn btn-primary" onclick="createNewArc()">+ Arc narratif</button>'
            };
            const sidebarActions = document.getElementById('sidebarActions');
            if (sidebarActions) {
                sidebarActions.innerHTML = actionsHTML[view] || '';
            }
            
            // Render appropriate content based on view
            renderViewContent(view, 'editorView');
            
            // Refresh Lucide icons after view change
            setTimeout(() => {
                if (typeof lucide !== 'undefined') lucide.createIcons();
            }, 50);
        }
        
        // Fonction pour rendre le contenu d'une vue dans un conteneur donné
        function renderViewContent(view, containerId) {
            const container = document.getElementById(containerId);
            if (!container) return;
            
            switch(view) {
                case 'editor':
                    if (currentActId && currentChapterId && currentSceneId) {
                        // Use renderEditor for the main editor view (not split mode)
                        if (containerId === 'editorView' && !splitViewActive) {
                            const act = project.acts.find(a => a.id === currentActId);
                            if (act) {
                                const chapter = act.chapters.find(c => c.id === currentChapterId);
                                if (chapter) {
                                    const scene = chapter.scenes.find(s => s.id === currentSceneId);
                                    if (scene) {
                                        renderEditor(act, chapter, scene);
                                    }
                                }
                            }
                        } else {
                            // Use simplified version for split-view panels
                            renderSceneInContainer(currentActId, currentChapterId, currentSceneId, containerId);
                        }
                    } else if (project.acts.length === 0 || (project.acts.length === 1 && project.acts[0].chapters.length === 0)) {
                        container.innerHTML = `
                            <div class="empty-state">
                                <div class="empty-state-icon">✏️</div>
                                <div class="empty-state-title">Commencez votre histoire</div>
                                <div class="empty-state-text">Créez votre premier chapitre pour commencer à écrire.</div>
                                <button class="btn btn-primary" onclick="openAddChapterModal()">+ Créer un chapitre</button>
                            </div>
                        `;
                    } else {
                        container.innerHTML = `
                            <div class="empty-state">
                                <div class="empty-state-icon">✏️</div>
                                <div class="empty-state-title">Sélectionnez une scène</div>
                                <div class="empty-state-text">Choisissez une scène dans la barre latérale pour commencer à écrire.</div>
                            </div>
                        `;
                    }
                    break;
                case 'characters':
                    if (typeof renderCharactersList === 'function') renderCharactersList();
                    renderCharacterWelcome();
                    break;
                case 'world':
                    if (typeof renderWorldList === 'function') renderWorldList();
                    renderWorldWelcome();
                    break;
                case 'notes':
                    if (typeof renderNotesList === 'function') renderNotesList();
                    renderNotesWelcome();
                    break;
                case 'codex':
                    if (typeof renderCodexList === 'function') renderCodexList();
                    renderCodexWelcome();
                    break;
                case 'stats':
                    if (typeof renderStats === 'function') renderStats();
                    break;
                case 'analysis':
                    if (typeof renderAnalysis === 'function') renderAnalysis();
                    break;
                case 'versions':
                    if (typeof renderVersionsList === 'function') renderVersionsList();
                    break;
                case 'todos':
                    if (typeof renderTodosList === 'function') renderTodosList();
                    break;
                case 'corkboard':
                    if (typeof openCorkBoardView === 'function') openCorkBoardView();
                    break;
                case 'mindmap':
                    if (typeof renderMindmapView === 'function') renderMindmapView();
                    break;
                case 'plot':
                    if (typeof renderPlotView === 'function') renderPlotView();
                    break;
                case 'relations':
                    if (typeof renderRelationsView === 'function') renderRelationsView();
                    break;
                case 'map':
                    if (typeof renderMapView === 'function') renderMapView();
                    break;
                case 'timelineviz':
                    if (typeof renderTimelineVizView === 'function') renderTimelineVizView();
                    break;
                case 'arcs':
                    if (typeof renderArcsList === 'function') renderArcsList();
                    renderArcsWelcome();
                    break;
                case 'storygrid':
                    if (typeof renderStoryGrid === 'function') renderStoryGrid();
                    break;
                case 'thriller':
                    if (typeof renderThrillerBoard === 'function') renderThrillerBoard();
                    break;
                default:
                    container.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-state-icon"><i data-lucide="layout" style="width:48px;height:48px;stroke-width:1;"></i></div>
                            <div class="empty-state-title">Panneau vide</div>
                            <div class="empty-state-text">Cliquez sur l'en-tête pour choisir une vue</div>
                        </div>
                    `;
            }
        }
        
        // Render scene in a specific container (for split view)
        function renderSceneInContainer(actId, chapterId, sceneId, containerId) {
            const container = document.getElementById(containerId);
            if (!container) return;
            
            const act = project.acts.find(a => a.id === actId);
            if (!act) return;
            const chapter = act.chapters.find(c => c.id === chapterId);
            if (!chapter) return;
            const scene = chapter.scenes.find(s => s.id === sceneId);
            if (!scene) return;
            
            const wordCount = getWordCount(scene.content || '');
            
            container.innerHTML = `
                <div class="split-scene-view" style="height: 100%; display: flex; flex-direction: column;">
                    <div style="padding: 0.75rem 1rem; background: var(--bg-secondary); border-bottom: 1px solid var(--border-color);">
                        <div style="font-size: 0.8rem; color: var(--text-muted);">${act.title} > ${chapter.title}</div>
                        <div style="font-size: 1.1rem; font-weight: 600;">${scene.title || 'Sans titre'}</div>
                        <div style="font-size: 0.75rem; color: var(--text-muted);">${wordCount} mots</div>
                    </div>
                    <div class="editor-textarea" 
                         contenteditable="true" 
                         data-container="${containerId}"
                         data-scene-id="${scene.id}"
                         data-chapter-id="${chapter.id}"
                         data-act-id="${act.id}"
                         oninput="updateSplitSceneContent(this)"
                         style="flex: 1; padding: 1.5rem; overflow-y: auto; outline: none; line-height: 1.8; font-size: 1.1rem;"
                    >${scene.content || ''}</div>
                </div>
            `;
        }

        let lastSavedState = null; // Dernier état sauvegardé pour détecter les changements

        // Projects Management
        function openProjectsModal() {
            renderProjectsList();
            document.getElementById('projectsModal').classList.add('active');
        }

        function openNewProjectModal() {
            document.getElementById('newProjectModal').classList.add('active');
            setTimeout(() => document.getElementById('newProjectTitle').focus(), 100);
        }

        function createNewProject() {
            const title = document.getElementById('newProjectTitle').value.trim();
            const description = document.getElementById('newProjectDesc').value.trim();
            const genre = document.getElementById('newProjectGenre').value;
            const template = document.getElementById('newProjectTemplate').value;

            if (!title) {
                alert('Veuillez entrer un titre pour le projet');
                return;
            }

            const newProject = {
                id: Date.now(),
                title: title,
                description: description,
                genre: genre,
                createdAt: new Date().toISOString(),
                updatedAt: new Date().toISOString(),
                acts: [],
                characters: [],
                world: [],
                timeline: [],
                notes: [],
                codex: [],
                stats: { dailyGoal: 500, totalGoal: 80000, writingSessions: [] },
                versions: [],
                relationships: []
            };

            // Apply template if selected
            if (template === 'fantasy') {
                newProject.acts = [
                    { id: Date.now(), title: "Acte I - Le Monde Ordinaire", chapters: [] },
                    { id: Date.now() + 1, title: "Acte II - L'Aventure", chapters: [] },
                    { id: Date.now() + 2, title: "Acte III - Le Retour", chapters: [] }
                ];
                newProject.stats.dailyGoal = 1000;
                newProject.stats.totalGoal = 120000;
            } else if (template === 'thriller') {
                newProject.acts = [
                    { id: Date.now(), title: "Acte I - L'Incident", chapters: [] },
                    { id: Date.now() + 1, title: "Acte II - La Tension", chapters: [] },
                    { id: Date.now() + 2, title: "Acte III - Le Dénouement", chapters: [] }
                ];
                newProject.stats.dailyGoal = 800;
                newProject.stats.totalGoal = 90000;
            } else if (template === 'scifi') {
                newProject.acts = [
                    { id: Date.now(), title: "Acte I - Découverte", chapters: [] },
                    { id: Date.now() + 1, title: "Acte II - Exploration", chapters: [] },
                    { id: Date.now() + 2, title: "Acte III - Révélation", chapters: [] }
                ];
                newProject.stats.dailyGoal = 1000;
                newProject.stats.totalGoal = 150000;
            }

            projects.push(newProject);
            saveAllProjects();
            
            document.getElementById('newProjectTitle').value = '';
            document.getElementById('newProjectDesc').value = '';
            document.getElementById('newProjectGenre').value = '';
            document.getElementById('newProjectTemplate').value = '';
            
            closeModal('newProjectModal');
            switchToProject(newProject.id);
            closeModal('projectsModal');
        }

        function switchToProject(projectId) {
            currentProjectId = projectId;
            project = projects.find(p => p.id === projectId);
            
            if (!project) return;

            const headerTitle = document.getElementById('headerProjectTitle');
            if (headerTitle) headerTitle.textContent = project.title;
            
            currentActId = null;
            currentChapterId = null;
            currentSceneId = null;
            
            switchView('editor');
            renderActsList();
            showEmptyState();
            
            localStorage.setItem('plume_locale_current_project', projectId);
        }

        function deleteProject(projectId) {
            const proj = projects.find(p => p.id === projectId);
            if (!proj) return;

            if (!confirm(`Supprimer "${proj.title}" ?\n\nIrréversible !`)) return;

            projects = projects.filter(p => p.id !== projectId);
            saveAllProjects();

            if (currentProjectId === projectId) {
                if (projects.length > 0) {
                    switchToProject(projects[0].id);
                } else {
                    createDefaultProject();
                }
            }

            renderProjectsList();
        }

        function exportProjectIndividual(projectId) {
            const proj = projects.find(p => p.id === projectId);
            if (!proj) return;

            const dataStr = JSON.stringify(proj, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${proj.title.replace(/\s+/g, '_')}_${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function importProject() {
            document.getElementById('importProjectInput').click();
        }

        function handleProjectImport(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const imported = JSON.parse(e.target.result);
                    if (!imported.title) throw new Error('Format invalide');

                    imported.id = Date.now();
                    imported.title += " (Importé)";
                    imported.createdAt = new Date().toISOString();
                    imported.updatedAt = new Date().toISOString();

                    projects.push(imported);
                    saveAllProjects();
                    renderProjectsList();
                    alert(`✅ "${imported.title}" importé !`);
                } catch (error) {
                    alert('❌ Erreur: ' + error.message);
                }
                event.target.value = '';
            };
            reader.readAsText(file);
        }

        function renderProjectsList() {
            const container = document.getElementById('projectsList');
            
            if (projects.length === 0) {
                container.innerHTML = '<div style="padding: 2rem; text-align: center; color: var(--text-muted);">Aucun projet</div>';
                return;
            }

            container.innerHTML = projects.map(proj => {
                const wordCount = proj.acts.reduce((sum, act) => sum + act.chapters.reduce((ch, chapter) => ch + chapter.scenes.reduce((sc, scene) => sc + getWordCount(scene.content), 0), 0), 0);
                const isActive = proj.id === currentProjectId;

                return `
                    <div class="project-card ${isActive ? 'active' : ''}" onclick="switchToProject(${proj.id}); closeModal('projectsModal');">
                        <div class="project-card-header">
                            <div>
                                <div class="project-card-title">${proj.title}</div>
                                ${proj.genre ? `<span class="project-card-genre">${proj.genre}</span>` : ''}
                            </div>
                            ${isActive ? '<span style="color: var(--accent-red); font-weight: 600;">● Actif</span>' : ''}
                        </div>
                        ${proj.description ? `<div class="project-card-desc">${proj.description}</div>` : ''}
                        <div class="project-card-stats">
                            <span>${wordCount.toLocaleString('fr-FR')} mots</span>
                            <span>${proj.acts.length} actes</span>
                            <span>${proj.characters.length} personnages</span>
                        </div>
                        <div class="project-card-actions">
                            <button class="btn btn-small" onclick="event.stopPropagation(); exportProjectIndividual(${proj.id})">📤 Exporter</button>
                            <button class="btn btn-small" onclick="event.stopPropagation(); deleteProject(${proj.id})">🗑️ Supprimer</button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        async function saveAllProjects() {
            try {
                if (currentProjectId) {
                    const index = projects.findIndex(p => p.id === currentProjectId);
                    if (index >= 0) {
                        projects[index] = { ...project, updatedAt: new Date().toISOString() };
                    }
                }
                
                // Sauvegarder tous les projets dans IndexedDB
                for (const proj of projects) {
                    await saveProjectToDB(proj);
                }
                
                // Sauvegarder le projet actuel
                await saveSetting('currentProjectId', currentProjectId);
                
                console.log('💾 Tous les projets sauvegardés');
            } catch (error) {
                console.error('❌ Erreur sauvegarde projets:', error);
            }
        }

        async function loadAllProjects() {
            try {
                // Charger tous les projets depuis IndexedDB
                const loadedProjects = await loadAllProjectsFromDB();
                
                if (loadedProjects && loadedProjects.length > 0) {
                    projects = loadedProjects;
                    
                    // Charger le dernier projet utilisé
                    const savedId = await loadSetting('currentProjectId');
                    
                    if (savedId) {
                        currentProjectId = savedId;
                        project = projects.find(p => p.id === currentProjectId);
                    }
                    
                    // Si projet non trouvé, prendre le premier
                    if (!project && projects.length > 0) {
                        project = projects[0];
                        currentProjectId = project.id;
                    }
                } else {
                    // Aucun projet trouvé, créer un projet par défaut
                    createDefaultProject();
                    await saveProjectToDB(project);
                }
                
                ensureProjectStructure();
                
                if (project?.title) {
                    const headerTitle = document.getElementById('headerProjectTitle');
                    if (headerTitle) headerTitle.textContent = project.title;
                }
                
                console.log('✅ Projets chargés:', projects.length);
            } catch (error) {
                console.error('❌ Erreur chargement projets:', error);
                createDefaultProject();
            }
        }

        function createDefaultProject() {
            project = {
                id: Date.now(),
                title: "Mon Roman",
                description: "",
                genre: "",
                createdAt: new Date().toISOString(),
                updatedAt: new Date().toISOString(),
                acts: [],
                characters: [],
                world: [],
                timeline: [],
                notes: [],
                codex: [],
                stats: { dailyGoal: 500, totalGoal: 80000, writingSessions: [] },
                versions: [],
                relationships: []
            };
            projects = [project];
            currentProjectId = project.id;
        }

        function ensureProjectStructure() {
            if (!project) return;
            project.characters = project.characters || [];
            project.world = project.world || [];
            project.timeline = project.timeline || [];
            project.notes = project.notes || [];
            project.codex = project.codex || [];
            project.stats = project.stats || { dailyGoal: 500, totalGoal: 80000, writingSessions: [] };
            project.versions = project.versions || [];
            project.relationships = project.relationships || [];
        }

        const originalSaveProject = saveProject;
        saveProject = function() {
            saveAllProjects();
        };

        // Text Analysis Tools
        function renderAnalysis() {
            const editorView = document.getElementById('editorView');
            if (!editorView) {
                console.error('editorView not found');
                return;
            }
            
            editorView.innerHTML = `
                <div style="height: 100%; overflow-y: auto; padding: 2rem 3rem;">
                    <h2 style="margin-bottom: 2rem; color: var(--accent-gold);"><i data-lucide="scan-search" style="width:24px;height:24px;vertical-align:middle;margin-right:8px;"></i>Analyse du texte</h2>
                    
                    <div style="background: var(--bg-secondary); padding: 2rem; border-radius: 8px; margin-bottom: 2rem;">
                        <label style="display: block; font-weight: 600; margin-bottom: 1rem; font-size: 1rem;">Portée de l'analyse :</label>
                        <select id="analysisScope" class="form-input" style="width: 100%; max-width: 400px; font-size: 1rem;">
                            <option value="current">Scène actuelle</option>
                            <option value="chapter">Chapitre actuel</option>
                            <option value="act">Acte actuel</option>
                            <option value="all">Tout le projet</option>
                        </select>
                    </div>
                    
                    <div id="analysisResults"></div>
                </div>
            `;
            
            // Attach event listener after DOM is updated
            setTimeout(() => {
                const scopeSelect = document.getElementById('analysisScope');
                if (scopeSelect) {
                    scopeSelect.addEventListener('change', runTextAnalysis);
                }
                runTextAnalysis();
            }, 0);
        }

        function runTextAnalysis() {
            const scope = document.getElementById('analysisScope')?.value || 'current';
            const text = getTextForAnalysis(scope);
            
            if (!text || text.trim().length === 0) {
                document.getElementById('analysisResults').innerHTML = '<div style="padding: 2rem; text-align: center; color: var(--text-muted);">Aucun texte à analyser</div>';
                return;
            }

            const analysis = {
                wordCount: getWordCount(text),
                repetitions: detectRepetitions(text),
                readability: calculateReadability(text),
                wordFrequency: calculateWordFrequency(text),
                sentenceLength: calculateSentenceLength(text),
                narrativeDistribution: analyzeNarrativeDistribution(text)
            };

            displayAnalysisResults(analysis);
        }

        function getTextForAnalysis(scope) {
            console.log('getTextForAnalysis called with scope:', scope);
            console.log('currentActId:', currentActId, 'currentChapterId:', currentChapterId, 'currentSceneId:', currentSceneId);
            
            if (scope === 'current' && currentSceneId) {
                const act = project.acts.find(a => a.id === currentActId);
                if (!act) return '';
                const chapter = act.chapters.find(c => c.id === currentChapterId);
                if (!chapter) return '';
                const scene = chapter.scenes.find(s => s.id === currentSceneId);
                if (!scene) return '';
                console.log('Current scene text length:', stripHTML(scene.content).length);
                return stripHTML(scene.content);
            } else if (scope === 'chapter') {
                if (!currentChapterId) {
                    // Try to use first chapter of first act
                    if (project.acts.length > 0 && project.acts[0].chapters.length > 0) {
                        const chapter = project.acts[0].chapters[0];
                        const text = chapter.scenes.map(s => stripHTML(s.content)).join('\n\n');
                        console.log('Using first chapter, text length:', text.length);
                        return text;
                    }
                    return '';
                }
                const act = project.acts.find(a => a.id === currentActId);
                if (!act) return '';
                const chapter = act.chapters.find(c => c.id === currentChapterId);
                if (!chapter) return '';
                const text = chapter.scenes.map(s => stripHTML(s.content)).join('\n\n');
                console.log('Chapter text length:', text.length);
                return text;
            } else if (scope === 'act') {
                if (!currentActId) {
                    // Try to use first act
                    if (project.acts.length > 0) {
                        const act = project.acts[0];
                        const text = act.chapters.flatMap(ch => ch.scenes.map(s => stripHTML(s.content))).join('\n\n');
                        console.log('Using first act, text length:', text.length);
                        return text;
                    }
                    return '';
                }
                const act = project.acts.find(a => a.id === currentActId);
                if (!act) return '';
                const text = act.chapters.flatMap(ch => ch.scenes.map(s => stripHTML(s.content))).join('\n\n');
                console.log('Act text length:', text.length);
                return text;
            } else if (scope === 'all') {
                const text = project.acts.flatMap(a => a.chapters.flatMap(ch => ch.scenes.map(s => stripHTML(s.content)))).join('\n\n');
                console.log('All project text length:', text.length);
                return text;
            }
            return '';
        }

        function stripHTML(html) {
            const div = document.createElement('div');
            div.innerHTML = html;
            return div.textContent || div.innerText || '';
        }

        function detectRepetitions(text) {
            // Correction pour inclure les caractères accentués français et autres Unicode
            const words = text.toLowerCase().match(/[\p{L}]{4,}/gu) || []; 
            const frequency = {};
            words.forEach(word => frequency[word] = (frequency[word] || 0) + 1);
            
            const repeated = Object.entries(frequency)
                .filter(([word, count]) => count >= 5)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10);
            
            return repeated;
        }

        function calculateReadability(text) {
            const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
            // Correction pour inclure les caractères accentués français et autres Unicode
            const words = text.match(/[\p{L}]+/gu) || []; 
            const syllables = words.reduce((sum, word) => sum + countSyllables(word), 0);
            
            if (sentences.length === 0 || words.length === 0) return { score: 0, level: 'N/A' };
            
            // Flesch Reading Ease (adapted for French)
            const avgWordsPerSentence = words.length / sentences.length;
            const avgSyllablesPerWord = syllables / words.length;
            const score = 206.835 - (1.015 * avgWordsPerSentence) - (84.6 * avgSyllablesPerWord);
            
            let level = '';
            if (score >= 90) level = 'Très facile';
            else if (score >= 80) level = 'Facile';
            else if (score >= 70) level = 'Assez facile';
            else if (score >= 60) level = 'Standard';
            else if (score >= 50) level = 'Assez difficile';
            else if (score >= 30) level = 'Difficile';
            else level = 'Très difficile';
            
            return { score: Math.max(0, Math.min(100, score)).toFixed(1), level };
        }

        function countSyllables(word) {
            word = word.toLowerCase();
            const vowels = /[aeiouyàâäéèêëïîôùûü]/g;
            const matches = word.match(vowels);
            if (!matches) return 1;
            
            let count = matches.length;
            // Adjustments for French
            if (word.endsWith('e')) count--;
            if (word.match(/[aeiouy]{2,}/)) count--;
            return Math.max(1, count);
        }

        function calculateWordFrequency(text) {
            // Correction pour inclure les caractères accentués français et autres Unicode
            const words = text.toLowerCase().match(/[\p{L}]{3,}/gu) || []; 
            const stopWords = new Set(['le', 'la', 'les', 'un', 'une', 'des', 'de', 'du', 'et', 'ou', 'où', 'qui', 'que', 'quoi', 'dont', 'ce', 'cette', 'ces', 'son', 'sa', 'ses', 'mon', 'ma', 'mes', 'ton', 'ta', 'tes', 'notre', 'nos', 'votre', 'vos', 'leur', 'leurs', 'je', 'tu', 'il', 'elle', 'nous', 'vous', 'ils', 'elles', 'on', 'ne', 'pas', 'plus', 'dans', 'sur', 'pour', 'par', 'avec', 'sans', 'est', 'était', 'être', 'avoir', 'fait', 'faire', 'dit', 'dire', 'peut', 'bien', 'tout', 'tous', 'comme', 'très', 'aussi', 'encore', 'mais', 'donc', 'ainsi']);
            
            const frequency = {};
            words.forEach(word => {
                if (!stopWords.has(word)) {
                    frequency[word] = (frequency[word] || 0) + 1;
                }
            });
            
            return Object.entries(frequency)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 15);
        }

        function calculateSentenceLength(text) {
            const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
            const lengths = sentences.map(s => s.trim().split(/\s+/).length);
            
            if (lengths.length === 0) return { avg: 0, min: 0, max: 0, distribution: [] };
            
            const avg = lengths.reduce((a, b) => a + b, 0) / lengths.length;
            const min = Math.min(...lengths);
            const max = Math.max(...lengths);
            
            // Distribution
            const ranges = [
                { label: '1-5 mots', count: lengths.filter(l => l >= 1 && l <= 5).length },
                { label: '6-10 mots', count: lengths.filter(l => l >= 6 && l <= 10).length },
                { label: '11-15 mots', count: lengths.filter(l => l >= 11 && l <= 15).length },
                { label: '16-20 mots', count: lengths.filter(l => l >= 16 && l <= 20).length },
                { label: '20+ mots', count: lengths.filter(l => l > 20).length }
            ];
            
            return { avg: avg.toFixed(1), min, max, distribution: ranges };
        }

        function analyzeNarrativeDistribution(text) {
            const dialogRegex = /[«"—–]\s*[^»"—–]{10,}?\s*[»"—–]/g;
            const dialogs = text.match(dialogRegex) || [];
            const dialogLength = dialogs.join('').length;
            const totalLength = text.length;
            
            const dialogPercent = totalLength > 0 ? (dialogLength / totalLength * 100).toFixed(1) : 0;
            const narrativePercent = totalLength > 0 ? (100 - dialogPercent).toFixed(1) : 0;
            
            return {
                dialogue: dialogPercent,
                narrative: narrativePercent,
                dialogCount: dialogs.length
            };
        }

        function displayAnalysisResults(analysis) {
            const container = document.getElementById('analysisResults');
            
            container.innerHTML = `
                <div style="margin-top: 1rem;">
                    <!-- General Stats -->
                    <div style="background: var(--bg-primary); padding: 1rem; border-radius: 4px; border: 1px solid var(--border-color); margin-bottom: 1rem;">
                        <div style="font-weight: 700; font-size: 1rem; margin-bottom: 0.75rem; color: var(--accent-gold);"><i data-lucide="bar-chart-3" style="width:16px;height:16px;vertical-align:middle;margin-right:6px;"></i>Statistiques générales</div>
                        <div style="font-size: 1.2rem; font-weight: 600;">${analysis.wordCount.toLocaleString('fr-FR')} mots</div>
                    </div>

                    <!-- Readability -->
                    <div style="background: var(--bg-primary); padding: 1rem; border-radius: 4px; border: 1px solid var(--border-color); margin-bottom: 1rem;">
                        <div style="font-weight: 700; font-size: 1rem; margin-bottom: 0.75rem; color: var(--accent-gold);"><i data-lucide="book-open" style="width:16px;height:16px;vertical-align:middle;margin-right:6px;"></i>Lisibilité (Flesch)</div>
                        <div style="font-size: 1.1rem; margin-bottom: 0.25rem;">Score: <strong>${analysis.readability.score}</strong> / 100</div>
                        <div style="color: var(--text-muted);">Niveau: ${analysis.readability.level}</div>
                        <div style="margin-top: 0.5rem; font-size: 0.75rem; color: var(--text-muted); line-height: 1.4;">
                            Plus le score est élevé, plus le texte est facile à lire. 60-70 = Standard, 70-80 = Facile.
                        </div>
                    </div>

                    <!-- Sentence Length -->
                    <div style="background: var(--bg-primary); padding: 1rem; border-radius: 4px; border: 1px solid var(--border-color); margin-bottom: 1rem;">
                        <div style="font-weight: 700; font-size: 1rem; margin-bottom: 0.75rem; color: var(--accent-gold);"><i data-lucide="ruler" style="width:16px;height:16px;vertical-align:middle;margin-right:6px;"></i>Longueur des phrases</div>
                        <div style="display: flex; gap: 1rem; margin-bottom: 0.75rem;">
                            <div><strong>Moyenne:</strong> ${analysis.sentenceLength.avg} mots</div>
                            <div><strong>Min:</strong> ${analysis.sentenceLength.min}</div>
                            <div><strong>Max:</strong> ${analysis.sentenceLength.max}</div>
                        </div>
                        <div style="font-size: 0.8rem; font-weight: 600; margin-bottom: 0.5rem;">Distribution:</div>
                        ${analysis.sentenceLength.distribution.map(r => `
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.25rem;">
                                <span style="font-size: 0.75rem;">${r.label}</span>
                                <div style="flex: 1; margin: 0 0.5rem; height: 8px; background: var(--bg-secondary); border-radius: 4px; overflow: hidden;">
                                    <div style="height: 100%; width: ${r.count * 100 / analysis.sentenceLength.distribution.reduce((s, d) => s + d.count, 0)}%; background: var(--accent-gold);"></div>
                                </div>
                                <span style="font-size: 0.75rem; font-weight: 600; min-width: 30px; text-align: right;">${r.count}</span>
                            </div>
                        `).join('')}
                    </div>

                    <!-- Narrative Distribution -->
                    <div style="background: var(--bg-primary); padding: 1rem; border-radius: 4px; border: 1px solid var(--border-color); margin-bottom: 1rem;">
                        <div style="font-weight: 700; font-size: 1rem; margin-bottom: 0.75rem; color: var(--accent-gold);"><i data-lucide="message-circle" style="width:16px;height:16px;vertical-align:middle;margin-right:6px;"></i>Distribution narrative</div>
                        <div style="display: flex; gap: 1rem; margin-bottom: 0.75rem;">
                            <div><strong>Dialogues:</strong> ${analysis.narrativeDistribution.dialogue}%</div>
                            <div><strong>Narration:</strong> ${analysis.narrativeDistribution.narrative}%</div>
                        </div>
                        <div style="height: 20px; background: var(--bg-secondary); border-radius: 4px; overflow: hidden; display: flex;">
                            <div style="height: 100%; width: ${analysis.narrativeDistribution.dialogue}%; background: #4CAF50;" title="Dialogues"></div>
                            <div style="height: 100%; width: ${analysis.narrativeDistribution.narrative}%; background: var(--accent-gold);" title="Narration"></div>
                        </div>
                        <div style="margin-top: 0.5rem; font-size: 0.75rem; color: var(--text-muted);">
                            ${analysis.narrativeDistribution.dialogCount} segments de dialogue détectés
                        </div>
                    </div>

                    <!-- Word Frequency -->
                    <div style="background: var(--bg-primary); padding: 1rem; border-radius: 4px; border: 1px solid var(--border-color); margin-bottom: 1rem;">
                        <div style="font-weight: 700; font-size: 1rem; margin-bottom: 0.75rem; color: var(--accent-gold);"><i data-lucide="type" style="width:16px;height:16px;vertical-align:middle;margin-right:6px;"></i>Mots les plus fréquents</div>
                        <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 0.5rem;">
                            ${analysis.wordFrequency.map(([word, count]) => `
                                <div style="padding: 0.4rem 0.6rem; background: var(--bg-secondary); border-radius: 2px; font-size: 0.75rem;">
                                    <strong>${word}</strong>: ${count}×
                                </div>
                            `).join('')}
                        </div>
                    </div>

                    <!-- Repetitions -->
                    <div style="background: var(--bg-primary); padding: 1rem; border-radius: 4px; border: 1px solid var(--border-color);">
                        <div style="font-weight: 700; font-size: 1rem; margin-bottom: 0.75rem; color: var(--accent-red);"><i data-lucide="alert-triangle" style="width:16px;height:16px;vertical-align:middle;margin-right:6px;"></i>Répétitions à surveiller (5+ occurrences)</div>
                        ${analysis.repetitions.length > 0 ? `
                            <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 0.5rem;">
                                ${analysis.repetitions.map(([word, count]) => `
                                    <div style="padding: 0.4rem 0.6rem; background: rgba(196, 69, 54, 0.1); border: 1px solid var(--accent-red); border-radius: 2px; font-size: 0.75rem;">
                                        <strong>${word}</strong>: ${count}×
                                    </div>
                                `).join('')}
                            </div>
                        ` : '<div style="color: var(--text-muted); font-size: 0.85rem;">Aucune répétition excessive détectée</div>'}
                    </div>
                </div>
            `;
        }


// ========== 04.init.js ==========
        // Initialize
        async function init() {
            // Initialiser IndexedDB en premier
            const dbReady = await initDB();
            if (!dbReady) {
                console.error('❌ Impossible d\'initialiser la base de données');
                alert('Erreur critique : impossible d\'initialiser le stockage. Rechargez la page.');
                return;
            }
            
            // Charger les projets depuis IndexedDB
            await loadAllProjects();
            await loadTreeState(); // Charger l'état d'expansion
            
            // Forcer la vue Structure au démarrage
            currentView = 'editor';
            
            // S'assurer que les autres vues sont cachées
            setTimeout(() => {
                // Masquer toutes les vues
                const viewsToHide = ['charactersList', 'worldList', 'notesList', 'codexList', 'statsList', 
                                     'versionsList', 'analysisList', 'todosList', 'corkboardList'];
                viewsToHide.forEach(viewId => {
                    const el = document.getElementById(viewId);
                    if (el) el.style.display = 'none';
                });
                
                // Afficher la structure
                const chaptersList = document.getElementById('chaptersList');
                if (chaptersList) chaptersList.style.display = 'block';
                
                // Activer l'onglet Structure
                document.querySelectorAll('[id^="tab-"]').forEach(tab => {
                    tab.classList.remove('btn-primary');
                });
                const editorTab = document.getElementById('tab-editor');
                if (editorTab) editorTab.classList.add('btn-primary');
            }, 100);
            
            switchView('editor');
            renderActsList();
            
            // Initialiser l'historique avec l'état initial
            saveToHistory();
            
            // Initialize color pickers
            initializeColorPickers();
            
            // Initialize sidebar resize
            initSidebarResize();
            
            // Initialize floating editor menu (mobile)
            initFloatingEditorMenu();
            
            // Initialize touch gestures for editor
            initEditorGestures();
            
            // Initialize storage monitoring
            initStorageMonitoring();
            
            // Initialize scene versions sidebar
            renderSceneVersionsList();
            
            // Initialize progress bar
            updateProgressBar();
            
            // Auto-save every 30 seconds
            setInterval(saveProject, 30000);
            
            // Update storage badge every 10 seconds
            setInterval(updateStorageBadge, 10000);
        }

        // Fonction utilitaire pour convertir un nombre en chiffres romains
        function toRoman(num) {
            const romanNumerals = [
                { value: 10, numeral: 'X' },
                { value: 9, numeral: 'IX' },
                { value: 5, numeral: 'V' },
                { value: 4, numeral: 'IV' },
                { value: 1, numeral: 'I' }
            ];
            
            let result = '';
            for (const { value, numeral } of romanNumerals) {
                while (num >= value) {
                    result += numeral;
                    num -= value;
                }
            }
            return result;
        }

        // Save/Load from localStorage
        async function saveProject() {
            try {
                // Sauvegarder dans IndexedDB
                const success = await saveProjectToDB(project);
                
                if (!success) {
                    throw new Error('Échec de la sauvegarde IndexedDB');
                }
                
                // Mettre à jour le badge de stockage après chaque sauvegarde
                updateStorageBadge();
                
                console.log('💾 saveProject appelé - isUndoRedoAction:', isUndoRedoAction);
                
                // Si c'est une action undo/redo, ne pas sauvegarder dans l'historique
                if (isUndoRedoAction) {
                    console.log('⏭️ Action undo/redo, pas de sauvegarde historique');
                    return;
                }
                
                // Si c'est le premier changement (pas de timer actif)
                if (!historyDebounceTimer) {
                    console.log('🆕 Premier changement - sauvegarde immédiate');
                    // Sauvegarder l'état ACTUEL comme point de départ
                    saveToHistory();
                    lastSavedState = JSON.stringify(project);
                } else {
                    console.log('⏱️ Timer existant, réinitialisation');
                }
                
                // Annuler le timer précédent
                if (historyDebounceTimer) {
                    clearTimeout(historyDebounceTimer);
                }
                
                // Créer un nouveau timer
                historyDebounceTimer = setTimeout(() => {
                    console.log('⏰ Timer expiré - vérification changements');
                    // Sauvegarder l'état final après la pause
                    const finalState = JSON.stringify(project);
                    
                    // Ne sauvegarder que si l'état a changé
                    if (finalState !== lastSavedState) {
                        console.log('✏️ État modifié - sauvegarde finale');
                        saveToHistory();
                        lastSavedState = finalState;
                    } else {
                        console.log('⏭️ Aucun changement détecté');
                    }
                    
                    historyDebounceTimer = null; // Réinitialiser
                }, historyDebounceDelay);
            } catch (error) {
                console.error('❌ Erreur de sauvegarde:', error);
                alert('Erreur lors de la sauvegarde. Veuillez exporter votre projet par sécurité.');
            }
        }
        
        function renameProject() {
            const newName = prompt('Nouveau nom du projet :', project.title || 'Mon Roman');
            if (newName === null) return; // Annulé
            
            const trimmedName = newName.trim();
            if (trimmedName === '') {
                showNotification('Le nom ne peut pas être vide');
                return;
            }
            
            project.title = trimmedName;
            
            // Mettre à jour le titre dans le header
            const headerTitle = document.getElementById('headerProjectTitle');
            if (headerTitle) {
                headerTitle.textContent = trimmedName;
            }
            
            // Mettre à jour le titre de la page
            document.title = trimmedName + ' - Plume';
            
            saveProject();
            showNotification('✓ Projet renommé');
        }
        


// ========== 05.undo-redo.js ==========
        function saveToHistory() {
            // Créer une copie profonde du projet
            const snapshot = JSON.parse(JSON.stringify(project));
            
            console.log('📝 saveToHistory appelé - historyStack.length:', historyStack.length);
            
            // Ajouter à l'historique
            historyStack.push(snapshot);
            
            // Limiter la taille de l'historique
            if (historyStack.length > maxHistorySize) {
                historyStack.shift(); // Retirer le plus ancien
            }
            
            // Vider le redo stack car on a fait une nouvelle action
            redoStack = [];
            
            console.log('✓ État sauvegardé - Total dans historique:', historyStack.length);
            
            // Mettre à jour l'UI
            updateUndoRedoButtons();
        }
        
        // Sauvegarder immédiatement dans l'historique (pour actions importantes)
        function saveToHistoryImmediate() {
            // Annuler le timer de debounce en cours
            if (historyDebounceTimer) {
                clearTimeout(historyDebounceTimer);
                historyDebounceTimer = null;
            }
            
            // Sauvegarder immédiatement
            saveToHistory();
        }
        
        function undo() {
            console.log('🔙 Undo appelé - historyStack.length:', historyStack.length);
            
            if (historyStack.length === 0) {
                console.log('⚠️ Historique vide !');
                showNotification('⚠️ Aucune action à annuler');
                return;
            }
            
            // Sauvegarder l'état actuel dans le redo stack
            redoStack.push(JSON.parse(JSON.stringify(project)));
            console.log('💾 État actuel sauvegardé dans redoStack');
            
            // Restaurer l'état précédent
            const previousState = historyStack.pop();
            console.log('📂 État précédent récupéré - reste dans historique:', historyStack.length);
            
            // Flag pour éviter de sauvegarder cette restauration
            isUndoRedoAction = true;
            project = JSON.parse(JSON.stringify(previousState));
            console.log('✓ Projet restauré');
            
            // Sauvegarder et rafraîchir
            saveProject();
            refreshAllViews();
            
            isUndoRedoAction = false;
            updateUndoRedoButtons();
            showNotification('↶ Annulé');
        }
        
        function redo() {
            if (redoStack.length === 0) {
                showNotification('⚠️ Aucune action à rétablir');
                return;
            }
            
            // Sauvegarder l'état actuel dans l'historique
            historyStack.push(JSON.parse(JSON.stringify(project)));
            
            // Restaurer l'état suivant
            const nextState = redoStack.pop();
            
            // Flag pour éviter de sauvegarder cette restauration
            isUndoRedoAction = true;
            project = JSON.parse(JSON.stringify(nextState));
            
            // Sauvegarder et rafraîchir
            saveProject();
            refreshAllViews();
            
            isUndoRedoAction = false;
            updateUndoRedoButtons();
            showNotification('↷ Rétabli');
        }
        
        function updateUndoRedoButtons() {
            // Boutons dans le header
            const headerUndoBtn = document.getElementById('headerUndoBtn');
            const headerRedoBtn = document.getElementById('headerRedoBtn');
            
            // Boutons dans le menu mobile
            const mobileUndoBtn = document.getElementById('mobileUndoBtn');
            const mobileRedoBtn = document.getElementById('mobileRedoBtn');
            
            const undoDisabled = historyStack.length === 0;
            const redoDisabled = redoStack.length === 0;
            
            if (headerUndoBtn) {
                headerUndoBtn.disabled = undoDisabled;
                headerUndoBtn.title = historyStack.length > 0 
                    ? `Annuler (${historyStack.length} action(s) disponible(s)) - Ctrl+Z`
                    : 'Aucune action à annuler';
            }
            
            if (headerRedoBtn) {
                headerRedoBtn.disabled = redoDisabled;
                headerRedoBtn.title = redoStack.length > 0 
                    ? `Rétablir (${redoStack.length} action(s) disponible(s)) - Ctrl+Y`
                    : 'Aucune action à rétablir';
            }
            
            // Mettre à jour aussi les boutons mobiles
            if (mobileUndoBtn) {
                mobileUndoBtn.disabled = undoDisabled;
                if (undoDisabled) {
                    mobileUndoBtn.style.opacity = '0.5';
                    mobileUndoBtn.style.cursor = 'not-allowed';
                } else {
                    mobileUndoBtn.style.opacity = '1';
                    mobileUndoBtn.style.cursor = 'pointer';
                }
            }
            
            if (mobileRedoBtn) {
                mobileRedoBtn.disabled = redoDisabled;
                if (redoDisabled) {
                    mobileRedoBtn.style.opacity = '0.5';
                    mobileRedoBtn.style.cursor = 'not-allowed';
                } else {
                    mobileRedoBtn.style.opacity = '1';
                    mobileRedoBtn.style.cursor = 'pointer';
                }
            }
        }
        


// ========== 06.structure.js ==========
        function refreshAllViews() {
            // Rafraîchir tous les affichages après un undo/redo
            renderActsList();
            
            // Restaurer l'état d'expansion immédiatement après le rendu
            setTimeout(() => restoreTreeState(), 100);
            
            updateStats();
            
            // Rafraîchir la vue actuelle
            switch(currentView) {
                case 'editor':
                    // Render the acts/chapters sidebar
                    renderActsList();
                    // renderViewContent will handle rendering the editor
                    break;
                case 'characters':
                    renderCharactersList();
                    break;
                case 'world':
                    renderWorldList();
                    break;
                case 'timeline':
                    renderTimelineList();
                    break;
                case 'notes':
                    renderNotesList();
                    break;
                case 'codex':
                    renderCodexList();
                    break;
                case 'stats':
                    renderStats();
                    break;
                case 'analysis':
                    renderAnalysis();
                    break;
                case 'versions':
                    renderVersionsList();
                    break;
                case 'todos':
                    if (typeof renderTodosList === 'function') renderTodosList();
                    break;
                case 'corkboard':
                    if (typeof renderCorkBoard === 'function') renderCorkBoard();
                    break;
                case 'mindmap':
                    if (typeof renderMindmapView === 'function') renderMindmapView();
                    break;
                case 'plot':
                    if (typeof renderPlotView === 'function') renderPlotView();
                    break;
                case 'relations':
                    if (typeof renderRelationsView === 'function') renderRelationsView();
                    break;
                case 'map':
                    if (typeof renderMapView === 'function') renderMapView();
                    break;
                case 'timelineviz':
                    if (typeof renderTimelineVizView === 'function') renderTimelineVizView();
                    break;
            }
            
            // Rafraîchir l'éditeur si une scène est ouverte
            if (currentSceneId) {
                const scene = findScene(currentActId, currentChapterId, currentSceneId);
                if (scene) {
                    document.getElementById('sceneTitle').value = scene.title;
                    document.getElementById('sceneContent').value = scene.content || '';
                    updateWordCount();
                }
            }
        }
        
        // Raccourcis clavier pour undo/redo
        document.addEventListener('keydown', function(e) {
            // Ctrl+Z ou Cmd+Z pour undo
            if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                undo();
            }
            // Ctrl+Y ou Cmd+Shift+Z pour redo
            else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
                e.preventDefault();
                redo();
            }
        });

        function loadProject() {
            const saved = localStorage.getItem('plume_locale_project');
            if (saved) {
                const loadedProject = JSON.parse(saved);
                
                // Migration: Convert old structure (chapters array) to new structure (acts array)
                if (loadedProject.chapters && !loadedProject.acts) {
                    console.log('Migrating old project structure to acts-based structure...');
                    project = {
                        title: loadedProject.title || "Mon Roman",
                        acts: [
                            {
                                id: Date.now(),
                                title: "Acte I",
                                chapters: loadedProject.chapters || []
                            }
                        ],
                        characters: loadedProject.characters || [],
                        world: loadedProject.world || []
                    };
                    // Save migrated structure
                    saveProject();
                    console.log('Migration complete!');
                } else {
                    // Ensure all data structures exist
                    project = {
                        ...loadedProject,
                        characters: loadedProject.characters || [],
                        world: loadedProject.world || [],
                        timeline: loadedProject.timeline || [],
                        notes: loadedProject.notes || [],
                        codex: loadedProject.codex || [],
                        stats: loadedProject.stats || {
                            dailyGoal: 500,
                            totalGoal: 80000,
                            writingSessions: []
                        },
                        versions: loadedProject.versions || [],
                        relationships: loadedProject.relationships || [],
                        metroTimeline: loadedProject.metroTimeline || [],
                        characterColors: loadedProject.characterColors || {}
                    };
                    
                    // Ensure all scenes have linked arrays
                    project.acts.forEach(act => {
                        act.chapters.forEach(chapter => {
                            chapter.scenes.forEach(scene => {
                                if (!scene.linkedCharacters) scene.linkedCharacters = [];
                                if (!scene.linkedElements) scene.linkedElements = [];
                            });
                        });
                    });
                    
                    // Ensure all characters have linked arrays
                    project.characters.forEach(char => {
                        if (!char.linkedScenes) char.linkedScenes = [];
                        if (!char.linkedElements) char.linkedElements = [];
                    });
                    
                    // Ensure all world elements have linked arrays
                    project.world.forEach(elem => {
                        if (!elem.linkedScenes) elem.linkedScenes = [];
                        if (!elem.linkedElements) elem.linkedElements = [];
                    });
                }
            }
        }

        // Act Management
        function addAct() {
            const title = document.getElementById('actTitleInput').value.trim();
            if (!title) return;

            const act = {
                id: Date.now(),
                title: title,
                chapters: []
            };

            project.acts.push(act);
            
            // Auto-déplier le nouvel acte
            expandedActs.add(act.id);
            
            document.getElementById('actTitleInput').value = '';
            closeModal('addActModal');
            saveProject();
            renderActsList();
        }

        function deleteAct(actId) {
            if (!confirm('Êtes-vous sûr de vouloir supprimer cet acte et tous ses chapitres ?')) return;
            
            project.acts = project.acts.filter(a => a.id !== actId);
            if (currentActId === actId) {
                currentActId = null;
                currentChapterId = null;
                currentSceneId = null;
                showEmptyState();
            }
            saveProject();
            renderActsList();
        }

        function toggleAct(actId) {
            const element = document.getElementById(`act-${actId}`);
            const icon = element.querySelector('.act-icon');
            const chaptersContainer = element.querySelector('.act-chapters');
            
            const isExpanded = icon.classList.contains('expanded');
            
            icon.classList.toggle('expanded');
            chaptersContainer.classList.toggle('visible');
            
            // Sauvegarder l'état
            if (isExpanded) {
                expandedActs.delete(actId);
            } else {
                expandedActs.add(actId);
            }
            saveTreeState();
        }

        function startEditingAct(actId, element) {
            const act = project.acts.find(a => a.id === actId);
            if (!act) return;

            const originalText = act.title;
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'editing-input';
            input.value = originalText;
            
            element.textContent = '';
            element.appendChild(input);
            input.focus();
            input.select();

            const finishEditing = () => {
                const newTitle = input.value.trim();
                if (newTitle && newTitle !== originalText) {
                    act.title = newTitle;
                    saveProject();
                }
                renderActsList();
            };

            input.addEventListener('blur', finishEditing);
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    finishEditing();
                } else if (e.key === 'Escape') {
                    renderActsList();
                }
            });
        }

        // Chapter Management
        function addChapter() {
            const title = document.getElementById('chapterTitleInput').value.trim();
            if (!title) return;
            
            // Si pas d'acte, en créer un par défaut
            if (!activeActId || !project.acts.find(a => a.id === activeActId)) {
                if (project.acts.length === 0) {
                    const defaultAct = {
                        id: Date.now(),
                        title: 'Roman',
                        chapters: []
                    };
                    project.acts.push(defaultAct);
                    activeActId = defaultAct.id;
                    expandedActs.add(defaultAct.id);
                } else {
                    activeActId = project.acts[0].id;
                }
            }

            const act = project.acts.find(a => a.id === activeActId);
            if (!act) return;

            const chapter = {
                id: Date.now() + 1, // +1 pour éviter collision avec l'acte créé juste avant
                title: title,
                scenes: []
            };

            act.chapters.push(chapter);
            
            // Auto-déplier l'acte parent et le nouveau chapitre
            expandedActs.add(act.id);
            expandedChapters.add(chapter.id);
            
            console.log('addChapter - act.id:', act.id, 'chapter.id:', chapter.id);
            console.log('expandedActs:', [...expandedActs]);
            console.log('expandedChapters:', [...expandedChapters]);
            
            document.getElementById('chapterTitleInput').value = '';
            closeModal('addChapterModal');
            saveProject();
            renderActsList();
        }

        function deleteChapter(actId, chapterId) {
            if (!confirm('Êtes-vous sûr de vouloir supprimer ce chapitre et toutes ses scènes ?')) return;
            
            const act = project.acts.find(a => a.id === actId);
            if (!act) return;

            act.chapters = act.chapters.filter(c => c.id !== chapterId);
            if (currentChapterId === chapterId) {
                currentChapterId = null;
                currentSceneId = null;
                showEmptyState();
            }
            saveProject();
            renderActsList();
        }

        function toggleChapter(actId, chapterId) {
            const element = document.getElementById(`chapter-${chapterId}`);
            const icon = element.querySelector('.chapter-icon');
            const scenesList = element.querySelector('.scenes-list');
            
            const isExpanded = icon.classList.contains('expanded');
            
            icon.classList.toggle('expanded');
            scenesList.classList.toggle('visible');
            
            // Sauvegarder l'état
            if (isExpanded) {
                expandedChapters.delete(chapterId);
            } else {
                expandedChapters.add(chapterId);
            }
            saveTreeState();
        }
        
        async function saveTreeState() {
            // Sauvegarder l'état d'expansion dans IndexedDB
            try {
                await saveSetting('expanded_acts', [...expandedActs]);
                await saveSetting('expanded_chapters', [...expandedChapters]);
            } catch (error) {
                console.error('❌ Erreur sauvegarde TreeState:', error);
            }
        }
        
        function expandAllTree() {
            // Déplier tous les actes
            document.querySelectorAll('.act-group').forEach(actEl => {
                const icon = actEl.querySelector('.act-icon');
                const chaptersContainer = actEl.querySelector('.act-chapters');
                const actId = parseInt(actEl.dataset.actId);
                
                if (icon && chaptersContainer) {
                    icon.classList.add('expanded');
                    chaptersContainer.classList.add('visible');
                    expandedActs.add(actId);
                }
            });
            
            // Déplier tous les chapitres
            document.querySelectorAll('.chapter-group').forEach(chapterEl => {
                const icon = chapterEl.querySelector('.chapter-icon');
                const scenesList = chapterEl.querySelector('.scenes-list');
                const chapterId = parseInt(chapterEl.dataset.chapterId);
                
                if (icon && scenesList) {
                    icon.classList.add('expanded');
                    scenesList.classList.add('visible');
                    expandedChapters.add(chapterId);
                }
            });
            
            // Déplier tous les groupes treeview (univers, codex)
            const collapsedState = JSON.parse(localStorage.getItem('plume_treeview_collapsed') || '{}');
            document.querySelectorAll('.treeview-group').forEach(group => {
                const header = group.querySelector('.treeview-header');
                const children = group.querySelector('.treeview-children');
                const chevron = group.querySelector('.treeview-chevron');
                
                if (children) {
                    children.classList.remove('collapsed');
                }
                if (chevron) {
                    chevron.setAttribute('data-lucide', 'chevron-down');
                }
                
                // Update localStorage state
                const onclickAttr = header ? header.getAttribute('onclick') : '';
                const match = onclickAttr ? onclickAttr.match(/toggleTreeviewGroup\('([^']+)'\)/) : null;
                if (match) {
                    collapsedState[match[1]] = false;
                }
            });
            localStorage.setItem('plume_treeview_collapsed', JSON.stringify(collapsedState));
            
            // Déplier les catégories de notes
            expandedNoteCategories = new Set(['Idée', 'Recherche', 'Référence', 'A faire', 'Question', 'Autre']);
            if (document.getElementById('notesList').style.display !== 'none') {
                renderNotesList();
            }
            
            saveTreeState();
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }
        
        function collapseAllTree() {
            // Replier tous les actes
            document.querySelectorAll('.act-group').forEach(actEl => {
                const icon = actEl.querySelector('.act-icon');
                const chaptersContainer = actEl.querySelector('.act-chapters');
                const actId = parseInt(actEl.dataset.actId);
                
                if (icon && chaptersContainer) {
                    icon.classList.remove('expanded');
                    chaptersContainer.classList.remove('visible');
                    expandedActs.delete(actId);
                }
            });
            
            // Replier tous les chapitres
            document.querySelectorAll('.chapter-group').forEach(chapterEl => {
                const icon = chapterEl.querySelector('.chapter-icon');
                const scenesList = chapterEl.querySelector('.scenes-list');
                const chapterId = parseInt(chapterEl.dataset.chapterId);
                
                if (icon && scenesList) {
                    icon.classList.remove('expanded');
                    scenesList.classList.remove('visible');
                    expandedChapters.delete(chapterId);
                }
            });
            
            // Replier tous les groupes treeview (univers, codex)
            const collapsedState = JSON.parse(localStorage.getItem('plume_treeview_collapsed') || '{}');
            document.querySelectorAll('.treeview-group').forEach(group => {
                const header = group.querySelector('.treeview-header');
                const children = group.querySelector('.treeview-children');
                const chevron = group.querySelector('.treeview-chevron');
                
                if (children) {
                    children.classList.add('collapsed');
                }
                if (chevron) {
                    chevron.setAttribute('data-lucide', 'chevron-right');
                }
                
                // Update localStorage state
                const onclickAttr = header ? header.getAttribute('onclick') : '';
                const match = onclickAttr ? onclickAttr.match(/toggleTreeviewGroup\('([^']+)'\)/) : null;
                if (match) {
                    collapsedState[match[1]] = true;
                }
            });
            localStorage.setItem('plume_treeview_collapsed', JSON.stringify(collapsedState));
            
            // Replier les catégories de notes
            expandedNoteCategories.clear();
            if (document.getElementById('notesList').style.display !== 'none') {
                renderNotesList();
            }
            
            saveTreeState();
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }
        
        async function loadTreeState() {
            // Charger l'état d'expansion depuis IndexedDB
            try {
                const savedActs = await loadSetting('expanded_acts');
                const savedChapters = await loadSetting('expanded_chapters');
                
                if (savedActs) {
                    expandedActs = new Set(savedActs);
                }
                if (savedChapters) {
                    expandedChapters = new Set(savedChapters);
                }
            } catch (e) {
                console.error('Erreur chargement état arborescence:', e);
            }
        }
        
        function restoreTreeState() {
            // Restaurer visuellement l'état d'expansion après le rendu
            expandedActs.forEach(actId => {
                const element = document.getElementById(`act-${actId}`);
                if (element) {
                    const icon = element.querySelector('.act-icon');
                    const chaptersContainer = element.querySelector('.act-chapters');
                    if (icon && chaptersContainer) {
                        icon.classList.add('expanded');
                        chaptersContainer.classList.add('visible');
                    }
                }
            });
            
            expandedChapters.forEach(chapterId => {
                const element = document.getElementById(`chapter-${chapterId}`);
                if (element) {
                    const icon = element.querySelector('.chapter-icon');
                    const scenesList = element.querySelector('.scenes-list');
                    if (icon && scenesList) {
                        icon.classList.add('expanded');
                        scenesList.classList.add('visible');
                    }
                }
            });
        }

        function startEditingChapter(actId, chapterId, element) {
            const act = project.acts.find(a => a.id === actId);
            if (!act) return;

            const chapter = act.chapters.find(c => c.id === chapterId);
            if (!chapter) return;

            const originalText = chapter.title;
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'editing-input';
            input.value = originalText;
            
            element.textContent = '';
            element.appendChild(input);
            input.focus();
            input.select();

            const finishEditing = () => {
                const newTitle = input.value.trim();
                if (newTitle && newTitle !== originalText) {
                    chapter.title = newTitle;
                    saveProject();
                    
                    // Update editor if this chapter is currently open
                    if (currentChapterId === chapterId) {
                        const breadcrumb = document.querySelector('.editor-breadcrumb');
                        if (breadcrumb) breadcrumb.textContent = `${act.title} > ${newTitle}`;
                    }
                }
                renderActsList();
            };

            input.addEventListener('blur', finishEditing);
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    finishEditing();
                } else if (e.key === 'Escape') {
                    renderActsList();
                }
            });
        }

        // Scene Management
        function openAddSceneModal(actId, chapterId) {
            activeActId = actId;
            activeChapterId = chapterId;
            document.getElementById('addSceneModal').classList.add('active');
        }
        
        function openAddSceneModalQuick() {
            // Utiliser le chapitre courant s'il existe, sinon le premier chapitre disponible
            if (currentActId && currentChapterId) {
                openAddSceneModal(currentActId, currentChapterId);
            } else if (project.acts.length > 0 && project.acts[0].chapters.length > 0) {
                openAddSceneModal(project.acts[0].id, project.acts[0].chapters[0].id);
            } else {
                showNotification('Créez d\'abord un chapitre');
            }
        }

        function addScene() {
            const title = document.getElementById('sceneTitleInput').value.trim();
            if (!title || !activeActId || !activeChapterId) return;

            const act = project.acts.find(a => a.id === activeActId);
            if (!act) return;

            const chapter = act.chapters.find(c => c.id === activeChapterId);
            if (!chapter) return;

            const scene = {
                id: Date.now(),
                title: title,
                content: '',
                linkedCharacters: [],
                linkedElements: [],
                wordCount: 0,
                status: 'draft'
            };

            chapter.scenes.push(scene);
            
            // Auto-déplier l'acte et le chapitre parents
            expandedActs.add(act.id);
            expandedChapters.add(chapter.id);
            
            document.getElementById('sceneTitleInput').value = '';
            closeModal('addSceneModal');
            saveProject();
            renderActsList();
            
            // Auto-open the new scene
            openScene(activeActId, activeChapterId, scene.id);
        }

        // Variable pour les filtres actifs
        let activeStatusFilters = ['draft', 'progress', 'complete', 'review'];
        let currentStatusMenu = null;

        function toggleSceneStatus(actId, chapterId, sceneId, event) {
            event = event || window.event;
            event.stopPropagation();
            
            // Fermer tout menu existant
            closeStatusMenu();
            
            const act = project.acts.find(a => a.id === actId);
            if (!act) return;
            
            const chapter = act.chapters.find(c => c.id === chapterId);
            if (!chapter) return;
            
            const scene = chapter.scenes.find(s => s.id === sceneId);
            if (!scene) return;
            
            const currentStatus = scene.status || 'draft';
            
            // Créer le menu contextuel
            const menu = document.createElement('div');
            menu.className = 'status-menu visible';
            menu.id = 'statusMenu';
            menu.innerHTML = `
                <div class="status-menu-item ${currentStatus === 'draft' ? 'active' : ''}" onclick="setSceneStatus(${actId}, ${chapterId}, ${sceneId}, 'draft')">
                    <span class="status-menu-dot draft"></span>
                    <span>Brouillon</span>
                </div>
                <div class="status-menu-item ${currentStatus === 'progress' ? 'active' : ''}" onclick="setSceneStatus(${actId}, ${chapterId}, ${sceneId}, 'progress')">
                    <span class="status-menu-dot progress"></span>
                    <span>En cours</span>
                </div>
                <div class="status-menu-item ${currentStatus === 'complete' ? 'active' : ''}" onclick="setSceneStatus(${actId}, ${chapterId}, ${sceneId}, 'complete')">
                    <span class="status-menu-dot complete"></span>
                    <span>Terminé</span>
                </div>
                <div class="status-menu-item ${currentStatus === 'review' ? 'active' : ''}" onclick="setSceneStatus(${actId}, ${chapterId}, ${sceneId}, 'review')">
                    <span class="status-menu-dot review"></span>
                    <span>À réviser</span>
                </div>
            `;
            
            // Positionner le menu en position fixe près du clic
            const badge = event.target.closest('.status-badge');
            if (badge) {
                const rect = badge.getBoundingClientRect();
                menu.style.top = (rect.bottom + 5) + 'px';
                menu.style.left = (rect.left - 100) + 'px'; // Décaler vers la gauche
                
                // S'assurer que le menu ne sort pas de l'écran
                document.body.appendChild(menu);
                
                const menuRect = menu.getBoundingClientRect();
                if (menuRect.right > window.innerWidth) {
                    menu.style.left = (window.innerWidth - menuRect.width - 10) + 'px';
                }
                if (menuRect.left < 0) {
                    menu.style.left = '10px';
                }
                if (menuRect.bottom > window.innerHeight) {
                    menu.style.top = (rect.top - menuRect.height - 5) + 'px';
                }
                
                currentStatusMenu = menu;
            }
            
            // Fermer le menu si on clique ailleurs
            setTimeout(() => {
                document.addEventListener('click', closeStatusMenuOnClickOutside);
            }, 10);
        }
        
        function closeStatusMenu() {
            const menu = document.getElementById('statusMenu');
            if (menu) {
                menu.remove();
            }
            currentStatusMenu = null;
            document.removeEventListener('click', closeStatusMenuOnClickOutside);
        }
        
        function closeStatusMenuOnClickOutside(event) {
            if (currentStatusMenu && !currentStatusMenu.contains(event.target)) {
                closeStatusMenu();
            }
        }
        
        function setSceneStatus(actId, chapterId, sceneId, status) {
            const act = project.acts.find(a => a.id === actId);
            if (!act) return;
            
            const chapter = act.chapters.find(c => c.id === chapterId);
            if (!chapter) return;
            
            const scene = chapter.scenes.find(s => s.id === sceneId);
            if (!scene) return;
            
            scene.status = status;
            
            closeStatusMenu();
            saveProject();
            renderActsList();
            updateProgressBar();
        }
        
        function toggleStatusFilter(status) {
            const index = activeStatusFilters.indexOf(status);
            const btn = document.querySelector(`.status-filter-btn[data-status="${status}"]`);
            
            if (index > -1) {
                // Désactiver le filtre (cacher ce statut)
                activeStatusFilters.splice(index, 1);
                btn.classList.remove('active');
            } else {
                // Activer le filtre (montrer ce statut)
                activeStatusFilters.push(status);
                btn.classList.add('active');
            }
            
            applyStatusFilters();
        }
        
        function applyStatusFilters() {
            // Appliquer les filtres à toutes les scènes
            document.querySelectorAll('.scene-item[data-scene-id]').forEach(sceneEl => {
                const sceneId = parseInt(sceneEl.dataset.sceneId);
                const actId = parseInt(sceneEl.dataset.actId);
                const chapterId = parseInt(sceneEl.dataset.chapterId);
                
                const act = project.acts.find(a => a.id === actId);
                if (!act) return;
                const chapter = act.chapters.find(c => c.id === chapterId);
                if (!chapter) return;
                const scene = chapter.scenes.find(s => s.id === sceneId);
                if (!scene) return;
                
                const status = scene.status || 'draft';
                
                if (activeStatusFilters.includes(status)) {
                    sceneEl.classList.remove('filtered-out');
                } else {
                    sceneEl.classList.add('filtered-out');
                }
            });
            
            // Cacher les chapitres dont toutes les scènes sont filtrées (mais pas les chapitres vides)
            document.querySelectorAll('.chapter-group').forEach(chapterEl => {
                const allScenes = chapterEl.querySelectorAll('.scene-item[data-scene-id]');
                const visibleScenes = chapterEl.querySelectorAll('.scene-item[data-scene-id]:not(.filtered-out)');
                
                // Si le chapitre a des scènes mais aucune visible, le cacher
                // Si le chapitre n'a pas de scènes (vide), le garder visible
                if (allScenes.length > 0 && visibleScenes.length === 0) {
                    chapterEl.classList.add('filtered-out');
                } else {
                    chapterEl.classList.remove('filtered-out');
                }
            });
            
            // Cacher les actes dont tous les chapitres sont filtrés (mais pas les actes avec chapitres vides)
            document.querySelectorAll('.act-group').forEach(actEl => {
                const allChapters = actEl.querySelectorAll('.chapter-group');
                const visibleChapters = actEl.querySelectorAll('.chapter-group:not(.filtered-out)');
                
                // Si l'acte a des chapitres mais aucun visible, le cacher
                // Si l'acte n'a pas de chapitres (vide), le garder visible
                if (allChapters.length > 0 && visibleChapters.length === 0) {
                    actEl.classList.add('filtered-out');
                } else {
                    actEl.classList.remove('filtered-out');
                }
            });
        }
        
        function updateProgressBar() {
            let counts = { draft: 0, progress: 0, complete: 0, review: 0 };
            let total = 0;
            
            project.acts.forEach(act => {
                act.chapters.forEach(chapter => {
                    chapter.scenes.forEach(scene => {
                        const status = scene.status || 'draft';
                        counts[status] = (counts[status] || 0) + 1;
                        total++;
                    });
                });
            });
            
            // Mettre à jour les compteurs
            document.getElementById('countDraft').textContent = counts.draft;
            document.getElementById('countProgress').textContent = counts.progress;
            document.getElementById('countComplete').textContent = counts.complete;
            document.getElementById('countReview').textContent = counts.review;
            
            // Mettre à jour le texte de progression
            const completedPercent = total > 0 ? Math.round((counts.complete / total) * 100) : 0;
            document.getElementById('progressStatsText').textContent = `${total} scène${total > 1 ? 's' : ''}`;
            document.getElementById('progressPercent').textContent = `${completedPercent}% terminé`;
            
            // Mettre à jour les segments de la barre
            if (total > 0) {
                document.getElementById('progressComplete').style.width = `${(counts.complete / total) * 100}%`;
                document.getElementById('progressReview').style.width = `${(counts.review / total) * 100}%`;
                document.getElementById('progressProgress').style.width = `${(counts.progress / total) * 100}%`;
                document.getElementById('progressDraft').style.width = `${(counts.draft / total) * 100}%`;
            } else {
                document.getElementById('progressComplete').style.width = '0%';
                document.getElementById('progressReview').style.width = '0%';
                document.getElementById('progressProgress').style.width = '0%';
                document.getElementById('progressDraft').style.width = '0%';
            }
        }

        function deleteScene(actId, chapterId, sceneId) {
            if (!confirm('Êtes-vous sûr de vouloir supprimer cette scène ?')) return;
            
            const act = project.acts.find(a => a.id === actId);
            if (!act) return;

            const chapter = act.chapters.find(c => c.id === chapterId);
            if (!chapter) return;

            chapter.scenes = chapter.scenes.filter(s => s.id !== sceneId);
            if (currentSceneId === sceneId) {
                currentSceneId = null;
                showEmptyState();
            }
            saveProject();
            renderActsList();
        }

        function startEditingScene(actId, chapterId, sceneId, element) {
            const act = project.acts.find(a => a.id === actId);
            if (!act) return;

            const chapter = act.chapters.find(c => c.id === chapterId);
            if (!chapter) return;
            
            const scene = chapter.scenes.find(s => s.id === sceneId);
            if (!scene) return;

            const originalText = scene.title;
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'editing-input';
            input.value = originalText;
            
            element.textContent = '';
            element.appendChild(input);
            input.focus();
            input.select();

            const finishEditing = () => {
                const newTitle = input.value.trim();
                if (newTitle && newTitle !== originalText) {
                    scene.title = newTitle;
                    saveProject();
                    
                    // Update editor if this scene is currently open
                    if (currentSceneId === sceneId) {
                        const editorTitle = document.querySelector('.editor-title');
                        if (editorTitle) editorTitle.textContent = newTitle;
                    }
                }
                renderActsList();
            };

            input.addEventListener('blur', finishEditing);
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    finishEditing();
                } else if (e.key === 'Escape') {
                    renderActsList();
                }
            });
        }

        // Navigation
        function openScene(actId, chapterId, sceneId) {
            // Close mobile sidebar if open (for mobile devices)
            if (window.innerWidth <= 900 && typeof closeMobileSidebar === 'function') {
                closeMobileSidebar();
            }
            
            // Sauvegarder l'état avant d'ouvrir une nouvelle scène
            saveToHistoryImmediate();
            
            currentActId = actId;
            currentChapterId = chapterId;
            currentSceneId = sceneId;
            
            const act = project.acts.find(a => a.id === actId);
            const chapter = act.chapters.find(c => c.id === chapterId);
            const scene = chapter.scenes.find(s => s.id === sceneId);
            
            // Update active states in sidebar
            document.querySelectorAll('.act-header, .chapter-header, .scene-item').forEach(el => {
                el.classList.remove('active');
            });
            
            const sceneElement = document.querySelector(`[data-scene-id="${sceneId}"]`);
            if (sceneElement) {
                sceneElement.classList.add('active');
                
                // Expand parent chapter and act if needed
                const chapterElement = document.getElementById(`chapter-${chapterId}`);
                if (chapterElement) {
                    const chapterIcon = chapterElement.querySelector('.chapter-icon');
                    const scenesList = chapterElement.querySelector('.scenes-list');
                    if (!scenesList.classList.contains('visible')) {
                        chapterIcon.classList.add('expanded');
                        scenesList.classList.add('visible');
                    }
                }
                
                const actElement = document.getElementById(`act-${actId}`);
                if (actElement) {
                    const actIcon = actElement.querySelector('.act-icon');
                    const chaptersContainer = actElement.querySelector('.act-chapters');
                    if (!chaptersContainer.classList.contains('visible')) {
                        actIcon.classList.add('expanded');
                        chaptersContainer.classList.add('visible');
                    }
                }
                
                // Scroll the scene into view in the sidebar
                setTimeout(() => {
                    const chaptersList = document.getElementById('chaptersList');
                    if (chaptersList && sceneElement) {
                        const containerRect = chaptersList.getBoundingClientRect();
                        const elementRect = sceneElement.getBoundingClientRect();
                        
                        if (elementRect.top < containerRect.top || elementRect.bottom > containerRect.bottom) {
                            sceneElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        }
                    }
                }, 100);
            }
            
            // Handle split view mode
            if (splitViewActive) {
                // Find which panel has the editor view
                let editorPanel = null;
                if (splitViewState.left.view === 'editor') {
                    editorPanel = 'left';
                } else if (splitViewState.right.view === 'editor') {
                    editorPanel = 'right';
                }
                
                if (editorPanel) {
                    // Update the editor panel's state
                    const state = editorPanel === 'left' ? splitViewState.left : splitViewState.right;
                    state.sceneId = sceneId;
                    state.actId = actId;
                    state.chapterId = chapterId;
                    renderSplitPanelViewContent(editorPanel);
                    
                    // Set this as the active panel
                    splitActivePanel = editorPanel;
                    saveSplitViewState();
                } else {
                    // No editor panel found, use the active panel
                    const state = splitActivePanel === 'left' ? splitViewState.left : splitViewState.right;
                    state.view = 'editor';
                    state.sceneId = sceneId;
                    state.actId = actId;
                    state.chapterId = chapterId;
                    renderSplitPanelViewContent(splitActivePanel);
                    saveSplitViewState();
                }
                
                // CORRECTION SPLIT VIEW : Après le rendu, on rafraîchit les liens pour la scène active
                // Nous appelons les fonctions directement car les IDs globaux sont désormais corrects.
                autoDetectLinks();
                refreshLinksPanel();

            } else {
                // Normal mode
                renderEditor(act, chapter, scene);

                // CORRECTION NORMAL MODE : APRES le rendu de l'éditeur
                // 1. Déclenche l'analyse pour mettre à jour les suggestions
                autoDetectLinks(); 
                // 2. Affiche le panneau des liens avec les 3 listes
                refreshLinksPanel(); 
            }
            
            // Update scene versions sidebar
            renderSceneVersionsList();
            
            // Afficher automatiquement le panneau d'annotations si la scène en contient (sauf sur mobile)
            const annotationsPanel = document.getElementById('annotationsPanel');
            const annotations = getVersionAnnotations(scene);
            if (annotations && annotations.length > 0) {
                // Sur mobile, ne pas ouvrir automatiquement le panneau
                if (window.innerWidth > 900) {
                    renderAnnotationsPanel();
                }
                updateAnnotationsButton(true);
            } else {
                if (annotationsPanel) {
                    annotationsPanel.classList.remove('visible');
                }
                updateAnnotationsButton(false);
            }
        }

        // Rendering
        // Expand/Collapse All
        function expandAll() {
            project.acts.forEach(act => {
                const actElement = document.getElementById(`act-${act.id}`);
                if (actElement) {
                    const icon = actElement.querySelector('.act-icon');
                    const chaptersContainer = actElement.querySelector('.act-chapters');
                    if (icon && chaptersContainer) {
                        icon.classList.add('expanded');
                        chaptersContainer.classList.add('visible');
                    }
                }
                
                act.chapters.forEach(chapter => {
                    const chapterElement = document.getElementById(`chapter-${chapter.id}`);
                    if (chapterElement) {
                        const icon = chapterElement.querySelector('.chapter-icon');
                        const scenesContainer = chapterElement.querySelector('.scenes-list');
                        if (icon && scenesContainer) {
                            icon.classList.add('expanded');
                            scenesContainer.classList.add('visible');
                        }
                    }
                });
            });
        }

        function collapseAll() {
            project.acts.forEach(act => {
                const actElement = document.getElementById(`act-${act.id}`);
                if (actElement) {
                    const icon = actElement.querySelector('.act-icon');
                    const chaptersContainer = actElement.querySelector('.act-chapters');
                    if (icon && chaptersContainer) {
                        icon.classList.remove('expanded');
                        chaptersContainer.classList.remove('visible');
                    }
                }
                
                act.chapters.forEach(chapter => {
                    const chapterElement = document.getElementById(`chapter-${chapter.id}`);
                    if (chapterElement) {
                        const icon = chapterElement.querySelector('.chapter-icon');
                        const scenesContainer = chapterElement.querySelector('.scenes-list');
                        if (icon && scenesContainer) {
                            icon.classList.remove('expanded');
                            scenesContainer.classList.remove('visible');
                        }
                    }
                });
            });
        }



// ========== 07.stats.js ==========
        // ==========================================
        // HELPER FUNCTIONS - STATS & PROGRESSION
        // ==========================================
        
        function formatWordCount(count) {
            if (count >= 1000) {
                return (count / 1000).toFixed(1).replace('.0', '') + 'k';
            }
            return count.toString();
        }
        
        // getSceneStatus supprimée - on utilise directement scene.status

        function getChapterStats(chapter) {
            const totalScenes = chapter.scenes.length;
            const totalWords = chapter.scenes.reduce((sum, s) => sum + (s.wordCount || 0), 0);
            const completedScenes = chapter.scenes.filter(s => (s.status || 'draft') === 'complete').length;
            const progressPercent = totalScenes > 0 ? Math.round((completedScenes / totalScenes) * 100) : 0;
            return { totalScenes, totalWords, completedScenes, progressPercent };
        }

        function getActStats(act) {
            const totalChapters = act.chapters.length;
            const totalScenes = act.chapters.reduce((sum, ch) => sum + ch.scenes.length, 0);
            const totalWords = act.chapters.reduce((sum, ch) => 
                sum + ch.scenes.reduce((s, scene) => s + (scene.wordCount || 0), 0), 0);
            return { totalChapters, totalScenes, totalWords };
        }

        function renderActsList() {
            const container = document.getElementById('chaptersList');
            
            console.log('renderActsList called');
            console.log('container:', container);
            console.log('project.acts.length:', project.acts.length);
            
            if (!container) {
                console.error('chaptersList container not found!');
                return;
            }
            
            if (project.acts.length === 0) {
                console.log('No acts, showing empty state');
                container.innerHTML = `
                    <div style="padding: 2rem; text-align: center; color: var(--text-muted);">
                        <div style="margin-bottom: 1rem;">Aucun chapitre</div>
                        <button class="btn btn-primary" onclick="openAddChapterModal()">+ Créer un chapitre</button>
                    </div>
                `;
                updateStats();
                return;
            }
            
            console.log('Acts found:', project.acts);
            console.log('expandedActs:', [...expandedActs]);
            console.log('expandedChapters:', [...expandedChapters]);
        
            let html = '<div style="padding: 0 0.5rem;">';
            
            project.acts.forEach((act, actIndex) => {
                const actStats = getActStats(act);
                
                html += '<div class="act-group" id="act-' + act.id + '" data-act-id="' + act.id + '">';
                
                // Toujours afficher le header de l'acte
                const actExpanded = expandedActs.has(act.id);
                html += '<div class="act-header" data-act-id="' + act.id + '">';
                html += '<span class="drag-handle" draggable="true" onclick="event.stopPropagation()">⋮⋮</span>';
                html += '<span class="act-icon' + (actExpanded ? ' expanded' : '') + '" onclick="toggleAct(' + act.id + '); event.stopPropagation();" style="cursor: pointer;">▶</span>';
                html += '<span class="auto-number">' + (actIndex + 1) + '.</span>';
                html += '<span class="act-title" ondblclick="event.stopPropagation(); startEditingAct(' + act.id + ', this)" onclick="toggleAct(' + act.id + ')">' + act.title + '</span>';
                html += '<span class="edit-hint">✏️</span>';
                html += '<span class="word-count-badge" title="' + actStats.totalWords.toLocaleString() + ' mots">' + formatWordCount(actStats.totalWords) + '</span>';
                html += '<button class="btn btn-icon btn-small delete-btn" onclick="event.stopPropagation(); deleteAct(' + act.id + ')">×</button>';
                html += '</div>';
                
                // Visible si dans expandedActs
                const actVisible = expandedActs.has(act.id);
                html += '<div class="act-chapters' + (actVisible ? ' visible' : '') + '">';
        
                act.chapters.forEach((chapter, chapterIndex) => {
                    const chapterStats = getChapterStats(chapter);
                    const chapterStatus = chapterStats.progressPercent === 100 ? 'complete' : chapterStats.progressPercent > 0 ? 'progress' : 'draft';
                    
                    // Numérotation complète
                    const chapterNumber = (actIndex + 1) + '.' + (chapterIndex + 1);
                    
                    html += '<div class="chapter-group" id="chapter-' + chapter.id + '" data-chapter-id="' + chapter.id + '" data-act-id="' + act.id + '">';
                    html += '<div class="chapter-header" data-chapter-id="' + chapter.id + '" data-act-id="' + act.id + '">';
                    html += '<span class="drag-handle" draggable="true" onclick="event.stopPropagation()">⋮⋮</span>';
                    
                    // Icône avec classe expanded si le chapitre est déplié
                    const chapterExpanded = expandedChapters.has(chapter.id);
                    html += '<span class="chapter-icon' + (chapterExpanded ? ' expanded' : '') + '" onclick="toggleChapter(' + act.id + ', ' + chapter.id + '); event.stopPropagation();" style="cursor: pointer;">▶</span>';
                    html += '<span class="auto-number">' + chapterNumber + '</span>';
                    html += '<span class="chapter-title" ondblclick="event.stopPropagation(); startEditingChapter(' + act.id + ', ' + chapter.id + ', this)" onclick="toggleChapter(' + act.id + ', ' + chapter.id + ')">' + chapter.title + '</span>';
                    html += '<span class="edit-hint">✏️</span>';
                    html += '<span class="word-count-badge" title="' + chapterStats.totalWords.toLocaleString() + ' mots">' + formatWordCount(chapterStats.totalWords) + '</span>';
                    html += '<span class="status-badge status-' + chapterStatus + '" title="' + chapterStats.progressPercent + '%"></span>';
                    html += '<span class="chapter-count">' + chapter.scenes.length + '</span>';
                    html += '<button class="btn btn-icon btn-small delete-btn" onclick="event.stopPropagation(); deleteChapter(' + act.id + ', ' + chapter.id + ')">×</button>';
                    html += '</div>';
                    
                    // Visible si dans expandedChapters
                    const chapterVisible = expandedChapters.has(chapter.id);
                    html += '<div class="scenes-list' + (chapterVisible ? ' visible' : '') + '">';
        
                    chapter.scenes.forEach((scene, sceneIndex) => {
                        const sceneStatus = scene.status || 'draft';
                        const sceneWords = scene.wordCount || 0;
                        const synopsis = scene.synopsis ? scene.synopsis.substring(0, 100) + (scene.synopsis.length > 100 ? '...' : '') : '';
                        const tooltipText = scene.synopsis ? scene.synopsis.replace(/"/g, '&quot;').replace(/'/g, '&#39;') : '';
                        
                        // Numérotation complète
                        const sceneNumber = (actIndex + 1) + '.' + (chapterIndex + 1) + '.' + (sceneIndex + 1);
                        
                        html += '<div class="scene-item draggable" draggable="true" data-scene-id="' + scene.id + '" data-chapter-id="' + chapter.id + '" data-act-id="' + act.id + '" onclick="openScene(' + act.id + ', ' + chapter.id + ', ' + scene.id + ')"' + (tooltipText ? ' title="' + tooltipText + '"' : '') + '>';
                        html += '<div style="display: flex; align-items: center; gap: 0.4rem; flex: 1; min-width: 0;">';
                        html += '<span class="drag-handle">⋮⋮</span>';
                        html += '<span class="auto-number">' + sceneNumber + '</span>';
                        html += '<div style="flex: 1; min-width: 0; overflow: hidden;">';
                        html += '<span ondblclick="event.stopPropagation(); startEditingScene(' + act.id + ', ' + chapter.id + ', ' + scene.id + ', this)" style="display: block;">' + scene.title + '</span>';
                        if (synopsis) {
                            html += '<span class="scene-synopsis">' + synopsis + '</span>';
                        }
                        html += '</div>';
                        html += '<span class="edit-hint">✏️</span>';
                        html += '</div>';
                        html += '<span class="word-count-badge" title="' + sceneWords.toLocaleString() + ' mots">' + formatWordCount(sceneWords) + '</span>';
                        html += '<span class="status-badge status-' + sceneStatus + '" onclick="event.stopPropagation(); toggleSceneStatus(' + act.id + ', ' + chapter.id + ', ' + scene.id + ', event)" style="cursor: pointer;" title="Cliquez pour changer le statut"></span>';
                        html += '<button class="btn btn-icon btn-small delete-btn" onclick="event.stopPropagation(); deleteScene(' + act.id + ', ' + chapter.id + ', ' + scene.id + ')">×</button>';
                        html += '</div>';
                    });
        
                    html += '<div class="scene-item" onclick="openAddSceneModal(' + act.id + ', ' + chapter.id + ')" style="opacity: 0.6; font-style: italic;">+ Ajouter une scène</div>';
                    html += '</div></div>';
                });
        
                // Bouton ajouter chapitre
                html += '<div class="scene-item" onclick="openAddChapterModal(' + act.id + ')" style="opacity: 0.6; font-style: italic; margin-left: 1rem;">+ Ajouter un chapitre</div>';
                html += '</div></div>';
            });
        
            html += '</div>';
            
            console.log('Generated HTML length:', html.length);
            console.log('First 500 chars:', html.substring(0, 500));
            
            container.innerHTML = html;
            
            console.log('Container innerHTML set, children:', container.children.length);
            
            setupActDragAndDrop();
            setupChapterDragAndDrop();
            setupSceneDragAndDrop();
            updateStats();
            updateProgressBar();
            applyStatusFilters();
            setTimeout(() => restoreTreeState(), 50);
        }
        function renderSceneCharacters(actId, chapterId, scene) {
            if (!scene.linkedCharacters || scene.linkedCharacters.length === 0) {
                return '<span style="font-size: 0.8rem; color: var(--text-muted); font-style: italic;">Aucun personnage lié</span>';
            }

            return scene.linkedCharacters.map(charId => {
                const character = project.characters.find(c => c.id === charId);
                if (!character) return '';
                return `
                    <span class="link-badge" onclick="event.stopPropagation(); switchView('characters'); openCharacterDetail(${charId});">
                        ${character.name}
                        <span class="link-badge-remove" onclick="event.stopPropagation(); toggleCharacterInScene(${actId}, ${chapterId}, ${scene.id}, ${charId}); openScene(${actId}, ${chapterId}, ${scene.id});">×</span>
                    </span>
                `;
            }).join('');
        }

        function renderSceneElements(actId, chapterId, scene) {
            //if (!scene.linkedElements || scene.linkedElements.length === 0) {
            //    return '<span style="font-size: 0.8rem; color: var(--text-muted); font-style: italic;">Aucun élément lié</span>';
            //}

            //return scene.linkedElements.map(elemId => {
            //    const element = project.world.find(e => e.id === elemId);
            //    if (!element) return '';
            //    return `
            //        <span class="link-badge" onclick="event.stopPropagation(); switchView('world'); openWorldDetail(${elemId});">
            //            ${element.name}
            //            <span class="link-badge-remove" onclick="event.stopPropagation(); toggleElementInScene(${actId}, ${chapterId}, ${scene.id}, ${elemId}); openScene(${actId}, ${chapterId}, ${scene.id});">×</span>
            //       </span>
            //    `;
            //}).join('');
            return '';
        }

        function renderSceneMetroEvents(sceneId) {
            if (!project.metroTimeline || project.metroTimeline.length === 0) {
                return '<span style="font-size: 0.8rem; color: var(--text-muted); font-style: italic;">Aucun événement</span>';
            }

            // Find all events linked to this scene (use == for loose comparison to handle string/number)
            const linkedEvents = project.metroTimeline.filter(event => event.sceneId == sceneId);
            
            if (linkedEvents.length === 0) {
                return '<span style="font-size: 0.8rem; color: var(--text-muted); font-style: italic;">Aucun événement lié</span>';
            }

            return linkedEvents.map(event => {
                return `
                    <span class="link-badge" style="background: var(--accent-blue); color: white;" onclick="event.stopPropagation(); openMetroEventFromScene(${event.id});" title="${event.date || 'Sans date'}">
                        <i data-lucide="train-track" style="width:12px;height:12px;vertical-align:middle;margin-right:2px;"></i>
                        ${event.title}
                    </span>
                `;
            }).join('');
        }

        function openCharacterLinker(actId, chapterId, sceneId) {
            const act = project.acts.find(a => a.id === actId);
            const chapter = act.chapters.find(c => c.id === chapterId);
            const scene = chapter.scenes.find(s => s.id === sceneId);

            document.getElementById('referencesModalTitle').textContent = 'Lier des personnages à cette scène';
            document.getElementById('referencesModalContent').innerHTML = `
                <div class="tag-selector">
                    ${project.characters.map(char => {
                        // Utiliser la nouvelle structure confirmedPresentCharacters pour l'état visuel de la modale
                        const isLinked = scene.confirmedPresentCharacters && scene.confirmedPresentCharacters.includes(char.id);
                        return `
                            <div class="tag-option ${isLinked ? 'selected' : ''}" 
                                 onclick="toggleCharacterLinkerAction(${char.id}); this.classList.toggle('selected');">
                                ${char.name}
                            </div>
                        `;
                    }).join('')}
                </div>
                ${project.characters.length === 0 ? '<p style="color: var(--text-muted); margin-top: 1rem;">Aucun personnage créé. Créez des personnages dans l\'onglet Personnages.</p>' : ''}
            `;

            document.getElementById('referencesModal').classList.add('active');
        }

        function openElementLinker(actId, chapterId, sceneId) {
            const act = project.acts.find(a => a.id === actId);
            const chapter = act.chapters.find(c => c.id === chapterId);
            const scene = chapter.scenes.find(s => s.id === sceneId);

            document.getElementById('referencesModalTitle').textContent = 'Lier des lieux/éléments à cette scène';
            document.getElementById('referencesModalContent').innerHTML = `
                <div class="tag-selector">
                    ${project.world.map(elem => {
                        const isLinked = scene.linkedElements && scene.linkedElements.includes(elem.id);
                        return `
                            <div class="tag-option ${isLinked ? 'selected' : ''}" 
                                 onclick="toggleElementInScene(${actId}, ${chapterId}, ${sceneId}, ${elem.id}); this.classList.toggle('selected');">
                                ${elem.name} <small>(${elem.type})</small>
                            </div>
                        `;
                    }).join('')}
                </div>
                ${project.world.length === 0 ? '<p style="color: var(--text-muted); margin-top: 1rem;">Aucun élément créé. Créez des lieux dans l\'onglet Univers.</p>' : ''}
            `;

            document.getElementById('referencesModal').classList.add('active');
        }

        function renderEditor(act, chapter, scene) {
            const editorView = document.getElementById('editorView');
            const wordCount = getWordCount(scene.content);
            
            // Vérifier si une version finale existe
            const hasFinalVersion = scene.versions && scene.versions.some(v => v.isFinal === true);
            const finalVersion = hasFinalVersion ? scene.versions.find(v => v.isFinal === true) : null;
            const finalVersionBadge = hasFinalVersion 
                ? `<span style="display: inline-flex; align-items: center; gap: 0.25rem; background: var(--accent-gold); color: var(--bg-accent); font-size: 0.7rem; font-weight: 600; padding: 0.2rem 0.5rem; border-radius: 10px; margin-left: 0.5rem;" title="Version finale : ${finalVersion.number}">⭐ ${finalVersion.number}</span>`
                : '';
            
            editorView.innerHTML = `
                <div class="editor-fixed-top">
                    <div class="editor-header">
                        <div class="editor-breadcrumb">${act.title} > ${chapter.title}</div>
                        <div style="display: flex; align-items: center; gap: 1rem;">
                            <div class="editor-title" style="flex: 1;">${scene.title}${finalVersionBadge}</div>
                            <button class="btn btn-small" onclick="toggleFocusMode()" title="Mode Focus (F11)" style="white-space: nowrap;">
                                <i data-lucide="maximize" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Focus
                            </button>
                        </div>
                        <div class="editor-meta">
                            <span id="sceneWordCount">${wordCount} mots</span>
                            <span>Dernière modification : ${new Date().toLocaleDateString('fr-FR')}</span>
                        </div>
                        <div class="editor-synopsis">
                            <span class="synopsis-label"><i data-lucide="file-text" style="width:12px;height:12px;"></i> Résumé :</span>
                            <input type="text" 
                                   class="synopsis-input" 
                                   value="${(scene.synopsis || '').replace(/"/g, '&quot;')}" 
                                   placeholder="Ajouter un résumé de la scène..."
                                   onchange="updateSceneSynopsis(${act.id}, ${chapter.id}, ${scene.id}, this.value)"
                                   oninput="this.style.width = Math.max(200, this.scrollWidth) + 'px'">
                        </div>
                    </div>
                    <button class="toolbar-mobile-toggle" onclick="toggleEditorToolbar()">
                        <span id="toolbarToggleText"><i data-lucide="pen-line" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Afficher les outils de formatage</span>
                    </button>
                    <button class="links-panel-toggle" onclick="toggleLinksPanel()">
                        <span id="linksPanelToggleText"><i data-lucide="chevron-right" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Afficher personnages & lieux liés</span>
                    </button>
                    <div class="editor-toolbar" id="editorToolbar">
                        <!-- Basic formatting -->
                        <div class="toolbar-group">
                            <button class="toolbar-btn" data-format="bold" onclick="formatText('bold')" title="Gras (Ctrl+B)">
                                <strong>B</strong>
                            </button>
                            <button class="toolbar-btn" data-format="italic" onclick="formatText('italic')" title="Italique (Ctrl+I)">
                                <em>I</em>
                            </button>
                            <button class="toolbar-btn" data-format="underline" onclick="formatText('underline')" title="Souligné (Ctrl+U)">
                                <u>U</u>
                            </button>
                            <button class="toolbar-btn" data-format="strikethrough" onclick="formatText('strikeThrough')" title="Barré">
                                <s>S</s>
                            </button>
                        </div>
                        
                        <!-- Font family and size -->
                        <div class="toolbar-group">
                            <select class="font-family-selector" onchange="formatText('fontName', this.value)" title="Police de caractères">
                                <option value="Crimson Pro">Crimson Pro</option>
                                <option value="Arial">Arial</option>
                                <option value="Georgia">Georgia</option>
                                <option value="Times New Roman">Times New Roman</option>
                                <option value="Courier New">Courier New</option>
                                <option value="Verdana">Verdana</option>
                                <option value="Garamond">Garamond</option>
                                <option value="Palatino">Palatino</option>
                            </select>
                            <select class="font-size-selector" onchange="formatText('fontSize', this.value)" title="Taille de police">
                                <option value="1">Très petit</option>
                                <option value="2">Petit</option>
                                <option value="3" selected>Normal</option>
                                <option value="4">Grand</option>
                                <option value="5">Très grand</option>
                                <option value="6">Énorme</option>
                                <option value="7">Gigantesque</option>
                            </select>
                        </div>
                        
                        <!-- Text color -->
                        <div class="toolbar-group">
                            <div class="color-picker-wrapper">
                                <button class="toolbar-btn" onclick="toggleColorPicker('text', event)" title="Couleur du texte">
                                    <span style="border-bottom: 3px solid currentColor;">A</span>
                                </button>
                                <div class="color-picker-dropdown" id="textColorPicker">
                                    <div class="color-grid" id="textColorGrid"></div>
                                    <div class="color-input-wrapper">
                                        <input type="color" id="textColorInput" onchange="applyTextColor(this.value)">
                                        <input type="text" id="textColorHex" placeholder="#000000" maxlength="7" onchange="applyTextColor(this.value)">
                                    </div>
                                </div>
                            </div>
                            <div class="color-picker-wrapper">
                                <button class="toolbar-btn" onclick="toggleColorPicker('background', event)" title="Couleur de fond">
                                    <span style="background: yellow; padding: 0 4px;">A</span>
                                </button>
                                <div class="color-picker-dropdown" id="backgroundColorPicker">
                                    <div class="color-grid" id="backgroundColorGrid"></div>
                                    <div class="color-input-wrapper">
                                        <input type="color" id="bgColorInput" onchange="applyBackgroundColor(this.value)">
                                        <input type="text" id="bgColorHex" placeholder="#FFFF00" maxlength="7" onchange="applyBackgroundColor(this.value)">
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Alignment -->
                        <div class="toolbar-group">
                            <button class="toolbar-btn" onclick="formatText('justifyLeft')" title="Aligner à gauche">
                                ⫷
                            </button>
                            <button class="toolbar-btn" onclick="formatText('justifyCenter')" title="Centrer">
                                ⫶
                            </button>
                            <button class="toolbar-btn" onclick="formatText('justifyRight')" title="Aligner à droite">
                                ⫸
                            </button>
                            <button class="toolbar-btn" onclick="formatText('justifyFull')" title="Justifier">
                                ☰
                            </button>
                        </div>
                        
                        <!-- Headings -->
                        <div class="toolbar-group">
                            <button class="toolbar-btn" onclick="formatText('formatBlock', 'h1')" title="Titre 1">H1</button>
                            <button class="toolbar-btn" onclick="formatText('formatBlock', 'h2')" title="Titre 2">H2</button>
                            <button class="toolbar-btn" onclick="formatText('formatBlock', 'h3')" title="Titre 3">H3</button>
                            <button class="toolbar-btn" onclick="formatText('formatBlock', 'p')" title="Paragraphe">P</button>
                        </div>
                        
                        <!-- Lists and quotes -->
                        <div class="toolbar-group">
                            <button class="toolbar-btn" onclick="formatText('insertUnorderedList')" title="Liste à puces">• Liste</button>
                            <button class="toolbar-btn" onclick="formatText('insertOrderedList')" title="Liste numérotée">1. Liste</button>
                            <button class="toolbar-btn" onclick="formatText('formatBlock', 'blockquote')" title="Citation">❝ Citation</button>
                        </div>
                        
                        <!-- Indentation -->
                        <div class="toolbar-group">
                            <button class="toolbar-btn" onclick="formatText('indent')" title="Augmenter l'indentation">→|</button>
                            <button class="toolbar-btn" onclick="formatText('outdent')" title="Diminuer l'indentation">|←</button>
                        </div>
                        
                        <!-- Superscript, subscript -->
                        <div class="toolbar-group">
                            <button class="toolbar-btn" onclick="formatText('superscript')" title="Exposant">x²</button>
                            <button class="toolbar-btn" onclick="formatText('subscript')" title="Indice">x₂</button>
                        </div>
                        
                        <!-- Annotations -->
                        <div class="toolbar-group">
                            <button class="toolbar-btn annotations-toolbar-btn" onclick="toggleAnnotationsPanel()" title="Annotations" id="toolbarAnnotationsBtn"><i data-lucide="message-square"></i></button>
                        </div>
                        
                        <!-- Arcs Narratifs -->
                        <div class="toolbar-group">
                            <button class="toolbar-btn" onclick="toggleArcScenePanel()" title="Arcs narratifs" id="toolbarArcsBtn"><i data-lucide="git-commit-horizontal"></i></button>
                        </div>
                        
                        <!-- Other -->
                        <div class="toolbar-group">
                            <button class="toolbar-btn" onclick="formatText('insertHorizontalRule')" title="Ligne horizontale">─</button>
                            <button class="toolbar-btn" onclick="formatText('removeFormat')" title="Supprimer le formatage">✕ Format</button>
                        </div>
                        
                        <!-- Révision - à la fin -->
                        <div class="toolbar-group">
                            <button class="toolbar-btn" onclick="toggleRevisionMode()" title="Mode Révision (Ctrl+R)" id="toolbarRevisionBtn" style="color: var(--accent-gold); font-weight: 600;">✏️ RÉVISION</button>
                        </div>
                    </div>
                    
                    <div class="links-panel-sticky" id="linksPanel">
                        <div style="display: flex; gap: 2rem; align-items: start;">
                            <div style="flex: 1;">
                                <div style="font-size: 0.85rem; font-weight: 600; margin-bottom: 0.5rem; color: var(--text-muted);"><i data-lucide="users" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Personnages</div>
                                <div class="quick-links">
                                    ${renderSceneCharacters(act.id, chapter.id, scene)}
                                    </div>
                            </div>
                            <div style="flex: 1;">
                                <div style="font-size: 0.85rem; font-weight: 600; margin-bottom: 0.5rem; color: var(--text-muted);"><i data-lucide="globe" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Lieux/Éléments</div>
                                <div class="quick-links">
                                    ${renderSceneElements(act.id, chapter.id, scene)}
                                    </div>
                            </div>
                            <div style="flex: 1;">
                                <div style="font-size: 0.85rem; font-weight: 600; margin-bottom: 0.5rem; color: var(--text-muted);"><i data-lucide="train-track" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Timeline</div>
                                <div class="quick-links">
                                    ${renderSceneMetroEvents(scene.id)}
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="editor-workspace">
                    <div class="editor-content">
                        <div 
                            class="editor-textarea" 
                            contenteditable="true"
                            spellcheck="true"
                            data-placeholder="Commencez à écrire votre scène..."
                            oninput="updateSceneContent()"
                            onkeydown="handleEditorKeydown(event)"
                        >${scene.content}</div>
                    </div>
                </div>
            `;
            
            // Focus the editor
            setTimeout(() => {
                const editor = document.querySelector('.editor-textarea');
                if (editor && editor.textContent.trim() === '') {
                    editor.focus();
                }
            }, 100);
        }

        function showEmptyState() {
            const editorView = document.getElementById('editorView');
            editorView.innerHTML = `
                <div class="empty-state">
                    <div class="empty-state-icon">✍️</div>
                    <div class="empty-state-title">Sélectionnez une scène</div>
                    <div class="empty-state-text">
                        Choisissez une scène dans la barre latérale pour commencer à écrire.
                    </div>
                </div>
            `;
            
            // Reset versions sidebar
            renderSceneVersionsList();
        }

        // Alias pour renderWelcomeEditor
        function renderWelcomeEditor() {
            showEmptyState();
        }

        function renderCharacterWelcome() {
            const editorView = document.getElementById('editorView');
            editorView.innerHTML = `
                <div class="empty-state">
                    <div class="empty-state-icon"><i data-lucide="users" style="width:48px;height:48px;stroke-width:1.5;"></i></div>
                    <div class="empty-state-title">Personnages</div>
                    <div class="empty-state-text">
                        Sélectionnez un personnage dans la liste pour voir sa fiche,<br>
                        ou créez-en un nouveau.
                    </div>
                </div>
            `;
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }

        function renderWorldWelcome() {
            const editorView = document.getElementById('editorView');
            editorView.innerHTML = `
                <div class="empty-state">
                    <div class="empty-state-icon"><i data-lucide="globe" style="width:48px;height:48px;stroke-width:1.5;"></i></div>
                    <div class="empty-state-title">Univers</div>
                    <div class="empty-state-text">
                        Sélectionnez un élément dans la liste pour voir ses détails,<br>
                        ou créez un nouvel élément de votre univers.
                    </div>
                </div>
            `;
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }

        function renderNotesWelcome() {
            const editorView = document.getElementById('editorView');
            editorView.innerHTML = `
                <div class="empty-state">
                    <div class="empty-state-icon"><i data-lucide="sticky-note" style="width:48px;height:48px;stroke-width:1.5;"></i></div>
                    <div class="empty-state-title">Notes</div>
                    <div class="empty-state-text">
                        Sélectionnez une note dans la liste pour la consulter,<br>
                        ou créez une nouvelle note.
                    </div>
                </div>
            `;
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }

        function renderCodexWelcome() {
            const editorView = document.getElementById('editorView');
            editorView.innerHTML = `
                <div class="empty-state">
                    <div class="empty-state-icon"><i data-lucide="book-open" style="width:48px;height:48px;stroke-width:1.5;"></i></div>
                    <div class="empty-state-title">Codex</div>
                    <div class="empty-state-text">
                        Sélectionnez une entrée dans la liste pour la consulter,<br>
                        ou créez une nouvelle entrée de codex.
                    </div>
                </div>
            `;
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }

        function updateSceneContent() {
            const editor = document.querySelector('.editor-textarea');
            const act = project.acts.find(a => a.id === currentActId);
            const chapter = act.chapters.find(c => c.id === currentChapterId);
            const scene = chapter.scenes.find(s => s.id === currentSceneId);
            
            scene.content = editor.innerHTML;
            
            const wordCount = getWordCount(editor.innerHTML);
            scene.wordCount = wordCount;
            
            // Update active version content
            updateSceneContentWithVersion(editor.innerHTML);
            
            document.getElementById('sceneWordCount').textContent = `${wordCount} mots`;
            
            saveProject();
            updateStats();
            renderActsList();
            trackWritingSession();
            
            // Mettre à jour les indicateurs en mode focus
            if (focusModeActive) {
                updateWritingProgress();
            }
            
            // Auto-détection des personnages et lieux mentionnés dans le texte
            autoDetectLinksDebounced();
        }

        function getWordCount(html) {
            // Create temporary div to strip HTML tags
            const temp = document.createElement('div');
            temp.innerHTML = html;
            const text = temp.textContent || temp.innerText || '';
            return text.split(/\s+/).filter(w => w.length > 0).length;
        }



// ========== 08.auto-detect.js ==========
// ============================================
// AUTO-DÉTECTION DES PERSONNAGES ET LIEUX
// ============================================

let autoDetectTimeout = null;

/**
 * Lance la détection automatique avec un délai (Debounce)
 * pour éviter de surcharger pendant la frappe.
 */
function autoDetectLinksDebounced() {
    clearTimeout(autoDetectTimeout);
    autoDetectTimeout = setTimeout(() => {
        autoDetectLinks();
    }, 800); // Délai de 800ms après arrêt de la frappe
}

/**
 * Fonction utilitaire pour récupérer la scène active proprement
 */
function getCurrentScene() {
    if (!currentActId || !currentChapterId || !currentSceneId) return null;
    
    // On suppose que 'project' est global
    const act = project.acts.find(a => a.id === currentActId);
    if (!act) return null;
    const chapter = act.chapters.find(c => c.id === currentChapterId);
    if (!chapter) return null;
    
    return chapter.scenes.find(s => s.id === currentSceneId);
}

/**
 * Fonction utilitaire pour retirer un élément d'un tableau
 */
function removeIdfromArray(arr, id) {
    const index = arr.indexOf(id);
    if (index > -1) {
        arr.splice(index, 1);
        return true;
    }
    return false;
}

/**
 * Fonction principale de détection
 * Analyse le texte et met à jour les listes (Suggérés, Présents, Absents)
 */
function autoDetectLinks() {
    const scene = getCurrentScene();
    if (!scene) return;
    
    // Obtenir le texte brut de la scène depuis l'éditeur
    const editor = document.querySelector('.editor-textarea');
    if (!editor) return;
    
    const temp = document.createElement('div');
    temp.innerHTML = editor.innerHTML;
    const sceneText = temp.textContent || temp.innerText || '';
    
    // Normaliser le texte pour la recherche (sans accents, minuscule)
    const normalizedText = normalizeForSearch(sceneText);
    
    // Initialiser les tableaux si nécessaire (Migration de données ou création)
    if (!scene.confirmedPresentCharacters) scene.confirmedPresentCharacters = [];
    if (!scene.suggestedCharacters) scene.suggestedCharacters = [];
    if (!scene.confirmedAbsentCharacters) scene.confirmedAbsentCharacters = [];
    
    // Rétro-compatibilité : si linkedCharacters existe mais pas confirmedPresentCharacters
    if (scene.linkedCharacters && scene.linkedCharacters.length > 0 && scene.confirmedPresentCharacters.length === 0) {
         scene.confirmedPresentCharacters = [...scene.linkedCharacters];
         scene.linkedCharacters = []; // On vide l'ancien tableau
    }

    if (!scene.linkedElements) scene.linkedElements = [];
    
    let hasChanges = false;
    
    // ===============================================
    // LOGIQUE PERSONNAGES (3 ÉTATS)
    // ===============================================
    
    // 1. Identifier les noms de famille ambigus (partagés par plusieurs persos)
    const lastNameCounts = {};
    project.characters.forEach(char => {
        const normalizedLastName = normalizeForSearch(char.lastName || '');
        if (normalizedLastName) {
            lastNameCounts[normalizedLastName] = (lastNameCounts[normalizedLastName] || 0) + 1;
        }
    });
    
    const ambiguousLastNames = new Set(
        Object.keys(lastNameCounts).filter(name => lastNameCounts[name] > 1)
    );
    
    // 2. Boucle sur chaque personnage
    project.characters.forEach(char => {
        
        // --- Construction des patterns de recherche ---
        const namesToDetect = [];
        
        // A. Nom complet (Priorité haute)
        if (char.name && char.name.trim()) namesToDetect.push(char.name.trim());
        
        // B. Prénom (Priorité haute)
        if (char.firstName && char.firstName.trim()) namesToDetect.push(char.firstName.trim());
        
        // C. Surnom (Priorité haute)
        if (char.nickname && char.nickname.trim()) namesToDetect.push(char.nickname.trim());
        
        // D. Nom de famille (Conditionnel : Seulement si unique)
        if (char.lastName && char.lastName.trim()) {
            const normalizedLastName = normalizeForSearch(char.lastName);
            if (!ambiguousLastNames.has(normalizedLastName)) {
                namesToDetect.push(char.lastName.trim());
            }
        }

        // Nettoyage et normalisation des noms à chercher
        const uniqueNamesNormalized = [...new Set(namesToDetect)]
            .filter(n => n && n.trim())
            .map(name => normalizeForSearch(name));
        
        // --- Vérification de présence ---
        let isInText = false;
        for (const name of uniqueNamesNormalized) {
            // Regex : \b pour mot entier, 'i' pour insensible à la casse
            const regex = new RegExp('\\b' + escapeRegex(name) + '\\b', 'i');
            if (regex.test(normalizedText)) {
                isInText = true;
                break; // Trouvé ! Pas besoin de chercher les autres variantes
            }
        }
        
        // --- Gestion des États ---
        const isConfirmedPresent = scene.confirmedPresentCharacters.includes(char.id);
        const isSuggested = scene.suggestedCharacters.includes(char.id);
        const isConfirmedAbsent = scene.confirmedAbsentCharacters.includes(char.id);
        
        if (isInText) {
            // CAS : Le personnage est DÉTECTÉ dans le texte
            
            if (!isConfirmedPresent && !isConfirmedAbsent && !isSuggested) {
                // S'il n'est nulle part, on le met en SUGGESTION
                scene.suggestedCharacters.push(char.id);
                hasChanges = true;
            }
            // S'il est déjà confirmé présent ou absent, on ne touche à rien (décision humaine prioritaire)
            
        } else {
            // CAS : Le personnage n'est PAS DÉTECTÉ
            
            // S'il était suggéré, on retire la suggestion (c'était un faux positif ou le texte a changé)
            if (isSuggested) {
                removeIdfromArray(scene.suggestedCharacters, char.id);
                hasChanges = true;
            }
            
            // S'il était confirmé absent (parce que détecté précédemment), on retire cette confirmation
            // pour qu'il puisse être re-suggéré si le nom réapparaît plus tard.
            //if (isConfirmedAbsent) {
            //    removeIdfromArray(scene.confirmedAbsentCharacters, char.id);
            //    hasChanges = true;
            //}
            
            // Note: S'il est confirmé PRÉSENT, on le laisse. 
            // L'utilisateur peut vouloir lier un perso qui n'est pas explicitement nommé (sous-entendu).
        }
    });
    
    // ===============================================
    // LOGIQUE LIEUX/ÉLÉMENTS (Classique)
    // ===============================================
    project.world.forEach(elem => {
        const elemNameNormalized = normalizeForSearch(elem.name);
        const regex = new RegExp('\\b' + escapeRegex(elemNameNormalized) + '\\b', 'i');
        const isInText = regex.test(normalizedText);
        const isLinked = scene.linkedElements.includes(elem.id);
        
        if (isInText && !isLinked) {
            scene.linkedElements.push(elem.id);
            hasChanges = true;
        } else if (!isInText && isLinked) {
            const index = scene.linkedElements.indexOf(elem.id);
            if (index > -1) {
                scene.linkedElements.splice(index, 1);
                hasChanges = true;
            }
        }
    });
    
    // Mettre à jour si changements détectés
    if (hasChanges) {
        saveProject(); // Important pour IndexedDB
        refreshLinksPanel();
    }
}

// ============================================
// GESTION MANUELLE DES ÉTATS (ACTIONS UTILISATEUR)
// ============================================

/**
 * Action : L'utilisateur valide la présence (Check)
 * Déplace de Suggéré/Absent vers Présent
 */
function confirmCharacterPresence(charId) {
    const scene = getCurrentScene();
    if (!scene) return;

    // 1. Nettoyer les autres listes
    removeIdfromArray(scene.suggestedCharacters, charId);
    removeIdfromArray(scene.confirmedAbsentCharacters, charId);

    // 2. Ajouter aux présents si pas déjà là
    if (!scene.confirmedPresentCharacters.includes(charId)) {
        scene.confirmedPresentCharacters.push(charId);
    }
    
    saveProject();
    refreshLinksPanel();
}

/**
 * Action : L'utilisateur refuse la présence (Croix)
 * Déplace de Suggéré/Présent vers Absent
 */
function confirmCharacterAbsence(charId) {
    const scene = getCurrentScene();
    if (!scene) return;

    // 1. Nettoyer les autres listes
    removeIdfromArray(scene.suggestedCharacters, charId);
    removeIdfromArray(scene.confirmedPresentCharacters, charId);

    // 2. Ajouter aux absents (liste noire pour cette scène)
    if (!scene.confirmedAbsentCharacters.includes(charId)) {
        scene.confirmedAbsentCharacters.push(charId);
    }
    
    saveProject();
    refreshLinksPanel();
}

// ============================================
// RENDU VISUEL DU PANNEAU
// ============================================

// Fichier 08.auto-detect.js - REMPLACEMENT TOTAL DE function refreshLinksPanel()

function refreshLinksPanel() {
    const linksPanel = document.getElementById('linksPanel');
    if (!linksPanel) return;
    
    const scene = getCurrentScene();
    if (!scene) return;
    
    const flexDivs = linksPanel.querySelectorAll('[style*="flex: 1"]');

    // --- 1. Rafraîchir les Personnages ---
    if (flexDivs.length >= 1) {
        const charDiv = flexDivs[0];
        const quickLinks = charDiv.querySelector('.quick-links');
        
        if (quickLinks) {
            
            // Obtenir les listes de personnages pour le rendu
            const allCharacters = project.characters || [];
            const confirmedIds = scene.confirmedPresentCharacters || [];
            const suggestedIds = scene.suggestedCharacters || [];
            const absentIds = scene.confirmedAbsentCharacters || [];

            // Filtrer les objets personnages complets
            const presentList = allCharacters.filter(c => confirmedIds.includes(c.id));
            const suggestedList = allCharacters.filter(c => suggestedIds.includes(c.id));
            const absentList = allCharacters.filter(c => absentIds.includes(c.id));

            let html = '';

            // ZONE 1 : PRÉSENTS (Validés)
            // L'en-tête est affiché, même si la liste est vide.
            html += '<h4 style="margin: 0 0 8px 0; font-size: 0.8rem; opacity: 0.8; text-align: left;"><i data-lucide="check-circle" style="width: 14px; height: 14px; vertical-align: -2px; margin-right: 4px;"></i> Confirmés Présents</h4>';
            if (presentList.length > 0) {
                html += presentList.map(char => `
                    <div class="link-item present" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            ${getAvatarHTML(char)}
                            <span>${char.name}</span>
                        </div>
                        <button onclick="confirmCharacterAbsence(${char.id})" title="Retirer (Marquer absent)" class="btn-icon">
                            <i data-lucide="x" style="width: 16px; height: 16px;"></i>
                        </button>
                    </div>
                `).join('');
            } else {
                 html += '<p class="text-muted small" style="font-size: 0.75rem; margin-bottom: 12px; opacity: 0.7;">Aucun personnage confirmé présent.</p>';
            }


            // ZONE 2 : SUGGÉRÉS (En attente)
            // L'en-tête est affiché, même si la liste est vide.
            html += '<h4 style="margin: 12px 0 8px 0; font-size: 0.8rem; opacity: 0.8; color: var(--accent-color); text-align: left;"><i data-lucide="help-circle" style="width: 14px; height: 14px; vertical-align: -2px; margin-right: 4px;"></i> Suggestions</h4>';
            if (suggestedList.length > 0) {
                 html += suggestedList.map(char => `
                    <div class="link-item suggested" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            ${getAvatarHTML(char)}
                            <span>${char.name}</span>
                        </div>
                        <div style="display: flex; gap: 4px;">
                            <button onclick="confirmCharacterAbsence(${char.id})" title="Ignorer" class="btn-icon">
                                <i data-lucide="x" style="width: 16px; height: 16px;"></i>
                            </button>
                            <button onclick="confirmCharacterPresence(${char.id})" title="Valider" class="btn-icon">
                                <i data-lucide="check" style="width: 16px; height: 16px;"></i>
                            </button>
                        </div>
                    </div>
                `).join('');
            } else {
                 html += '<p class="text-muted small" style="font-size: 0.75rem; margin-bottom: 12px; opacity: 0.7;">Aucune suggestion.</p>';
            }


            // ZONE 3 : ABSENTS (Ignorés manuellement)
            // L'en-tête est affiché, même si la liste est vide.
            html += '<h4 style="margin: 12px 0 8px 0; font-size: 0.8rem; opacity: 0.8; text-align: left;"><i data-lucide="x-circle" style="width: 14px; height: 14px; vertical-align: -2px; margin-right: 4px;"></i> Confirmés Absents</h4>';
            if (absentList.length > 0) {
                 html += absentList.map(char => `
                    <div class="link-item absent" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            ${getAvatarHTML(char)}
                            <span style="text-decoration: line-through;">${char.name}</span>
                        </div>
                        <button onclick="confirmCharacterPresence(${char.id})" title="Rétablir" class="btn-icon">
                            <i data-lucide="rotate-ccw" style="width: 16px; height: 16px;"></i>
                        </button>
                    </div>
                `).join('');
            } else {
                 html += '<p class="text-muted small" style="font-size: 0.75rem; margin-bottom: 12px; opacity: 0.7;">Aucun personnage ignoré manuellement.</p>';
            }
            
            // Bouton d'ajout manuel
            html += `
                <div style="margin-top: 10px; text-align: center;">
                    <button class="btn btn-small" onclick="openCharacterLinker(${currentActId}, ${currentChapterId}, ${currentSceneId})" style="font-size: 0.75rem; padding: 4px 8px; width: 100%;">
                        <i data-lucide="plus" style="width: 12px; height: 12px; vertical-align: middle; margin-right: 4px;"></i> Lier manuellement
                    </button>
                </div>
            `;

            quickLinks.innerHTML = html;
        }
    }
    
    // --- 2. Rafraîchir les Lieux/Éléments (Nouveau Design) ---
    if (flexDivs.length >= 2) {
        const locationDiv = flexDivs[1];
        const quickLinks = locationDiv.querySelector('.quick-links');
        
        if (quickLinks) {
            
            // Les éléments n'ont qu'un seul état (lié ou non)
            const linkedIds = scene.linkedElements || [];
            const linkedElements = (project.world || []).filter(e => linkedIds.includes(e.id));
            
            let html = '';

            // En-tête + Bouton de liaison
            html += `
                <h4 style="margin: 0 0 8px 0; font-size: 0.8rem; opacity: 0.8; text-align: left;"><i data-lucide="globe" style="width:14px;height:14px;vertical-align:-2px;margin-right:4px;"></i> Éléments Liés</h4>
            `;

            if (linkedElements.length > 0) {
                html += linkedElements.map(elem => {
                    const iconName = getElementIcon(elem.type);
                    return `
                        <div class="link-item present" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                            <div style="display: flex; align-items: center; gap: 8px; flex: 1; min-width: 0;">
                                <i data-lucide="${iconName}" style="width: 20px; height: 20px;"></i>
                                <span style="white-space: nowrap; overflow: hidden; text-overflow: ellipsis;" title="${elem.name} (${elem.type})">${elem.name}</span>
                            </div>
                            <button onclick="toggleElementInScene(${currentActId}, ${currentChapterId}, ${currentSceneId}, ${elem.id}); openScene(${currentActId}, ${currentChapterId}, ${currentSceneId});" title="Délier" class="btn-icon">
                                <i data-lucide="x" style="width: 16px; height: 16px;"></i>
                            </button>
                        </div>
                    `;
                }).join('');
            } else {
                 html += '<p class="text-muted small" style="font-size: 0.75rem; margin-bottom: 12px; opacity: 0.7;">Aucun lieu ou élément lié.</p>';
            }

            // Bouton d'ajout manuel
            html += `
                <div style="margin-top: 10px; text-align: center;">
                    <button class="btn btn-small" onclick="openElementLinker(${currentActId}, ${currentChapterId}, ${currentSceneId})" style="font-size: 0.75rem; padding: 4px 8px; width: 100%;">
                        <i data-lucide="plus" style="width: 12px; height: 12px; vertical-align: middle; margin-right: 4px;"></i> Lier manuellement
                    </button>
                </div>
            `;

            quickLinks.innerHTML = html;
        }
    }
    
    // Réinitialiser les icônes Lucide après injection HTML
    if (typeof lucide !== 'undefined') lucide.createIcons();
}

/**
 * Détermine l'icône Lucide à utiliser pour un type d'élément donné.
 */
function getElementIcon(type) {
    switch (type.toLowerCase()) {
        case 'lieu':
        case 'place':
            return 'map-pin';
        case 'objet':
        case 'artifact':
            return 'box';
        case 'organisation':
        case 'group':
            return 'landmark';
        case 'concept':
        case 'idée':
            return 'lightbulb';
        default:
            return 'globe'; // Icône par défaut
    }
}

/**
 * Gère l'action de liaison/déliaison d'un personnage depuis la modale (Lier manuellement).
 * Bascule l'état entre ConfirmedPresent et non-lié.
 * Cette fonction est appelée par les boutons de la modale.
 * @param {number} charId - ID du personnage à lier/délier.
 */
function toggleCharacterLinkerAction(charId) {
    const scene = getCurrentScene();
    if (!scene) return;

    const isConfirmedPresent = scene.confirmedPresentCharacters.includes(charId);

    if (isConfirmedPresent) {
        // Délien: Le retirer de la liste des présents confirmés
        removeIdfromArray(scene.confirmedPresentCharacters, charId);
    } else {
        // Lien: L'ajouter aux présents confirmés
        scene.confirmedPresentCharacters.push(charId);
        
        // S'assurer qu'il n'est ni suggéré ni absent (la liaison manuelle est prioritaire)
        removeIdfromArray(scene.suggestedCharacters, charId);
        removeIdfromArray(scene.confirmedAbsentCharacters, charId);
    }
    
    saveProject(); 
    
    // Appel au NOUVEAU moteur de rendu pour mettre à jour le panneau des liens principal.
    refreshLinksPanel(); 
}

// ============================================
// FONCTIONS UTILITAIRES
// ============================================

// Helper pour générer le petit avatar HTML (Image ou Icône)
function getAvatarHTML(char) {
    if (char.avatarImage) {
        return `<img src="${char.avatarImage}" style="width: 20px; height: 20px; border-radius: 50%; object-fit: cover;">`;
    } else {
        return `<i data-lucide="user" style="width: 16px; height: 16px;"></i>`;
    }
}

// Normaliser le texte pour la recherche (retirer accents, minuscule)
function normalizeForSearch(text) {
    return text
        .toLowerCase()
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, ''); // Retire les accents
}

// Échapper les caractères spéciaux regex
function escapeRegex(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

// Rich Text Formatting (inchangé)
function formatText(command, value = null) {
    document.execCommand(command, false, value);
    document.querySelector('.editor-textarea').focus();
}

// ========== 09.floating-editor.js ==========
        // ============================================
        // FLOATING EDITOR MENU (MOBILE)
        // ============================================
        // GESTES TACTILES POUR L'ÉDITEUR
        // ============================================
        
        function initEditorGestures() {
            const editor = document.querySelector('.editor-textarea');
            if (!editor) return;
            
            let lastTap = 0;
            let initialPinchDistance = 0;
            let initialFontSize = 16;
            
            // Double-tap pour mode focus
            editor.addEventListener('touchend', (e) => {
                const currentTime = new Date().getTime();
                const tapLength = currentTime - lastTap;
                
                if (tapLength < 300 && tapLength > 0) {
                    // Double-tap détecté
                    e.preventDefault();
                    toggleFocusMode();
                }
                lastTap = currentTime;
            });
            
            // Swipe à 2 doigts pour annuler/refaire
            let touchStartY = 0;
            editor.addEventListener('touchstart', (e) => {
                if (e.touches.length === 2) {
                    touchStartY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
                    
                    // Calculer distance initiale pour pinch
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    initialPinchDistance = Math.sqrt(dx * dx + dy * dy);
                    
                    const computedStyle = window.getComputedStyle(editor);
                    initialFontSize = parseFloat(computedStyle.fontSize);
                }
            });
            
            editor.addEventListener('touchmove', (e) => {
                if (e.touches.length === 2) {
                    // Pinch to zoom font size
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    const currentDistance = Math.sqrt(dx * dx + dy * dy);
                    
                    const scale = currentDistance / initialPinchDistance;
                    const newFontSize = Math.max(12, Math.min(24, initialFontSize * scale));
                    
                    editor.style.fontSize = newFontSize + 'px';
                }
            });
            
            editor.addEventListener('touchend', (e) => {
                if (e.changedTouches.length === 2) {
                    const touchEndY = touchStartY;
                    const deltaY = touchEndY - touchStartY;
                    
                    // Swipe vers le haut = annuler
                    if (deltaY < -50) {
                        e.preventDefault();
                        undo();
                    }
                    // Swipe vers le bas = refaire
                    else if (deltaY > 50) {
                        e.preventDefault();
                        redo();
                    }
                }
            });
        }
        
        // ============================================
        // FLOATING EDITOR MENU (MOBILE)
        // ============================================
        
        let floatingMenuPosition = null;
        let isDraggingFloatingMenu = false;
        let dragOffset = { x: 0, y: 0 };

        function initFloatingEditorMenu() {
            const menu = document.getElementById('floatingEditorMenu');
            const handle = document.getElementById('floatingMenuHandle');
            const toggleBtn = document.getElementById('floatingEditorToggle');
            
            if (!menu || !handle) {
                console.error('❌ Menu flottant ou handle non trouvé');
                return;
            }

            if (!toggleBtn) {
                console.error('❌ Bouton toggle non trouvé');
                return;
            }

            // Ajouter le listener au bouton toggle
            toggleBtn.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                toggleFloatingEditorMenu();
            });

            console.log('✅ Menu flottant initialisé');
            
            // Load saved position or set default
            const savedPos = localStorage.getItem('floatingMenuPosition');
            if (savedPos) {
                try {
                    floatingMenuPosition = JSON.parse(savedPos);
                    console.log('📍 Position chargée:', floatingMenuPosition);
                } catch (e) {
                    console.error('Erreur chargement position:', e);
                    floatingMenuPosition = null;
                }
            }
            
            if (!floatingMenuPosition) {
                // Default position: center of screen
                floatingMenuPosition = {
                    x: Math.max(10, (window.innerWidth / 2) - 150),
                    y: Math.max(10, (window.innerHeight / 2) - 200)
                };
                console.log('📍 Position par défaut:', floatingMenuPosition);
            }

            // Setup drag - TOUCH
            handle.addEventListener('touchstart', function(e) {
                console.log('👆 TOUCH START - isDragging avant:', isDraggingFloatingMenu);
                isDraggingFloatingMenu = true;
                console.log('👆 TOUCH START - isDragging après:', isDraggingFloatingMenu);
                
                const touch = e.touches[0];
                const rect = menu.getBoundingClientRect();
                
                dragOffset.x = touch.clientX - rect.left;
                dragOffset.y = touch.clientY - rect.top;
                
                handle.style.background = 'var(--accent-red)';
                console.log('🎯 Touch:', touch.clientX, touch.clientY);
                console.log('🎯 Rect:', rect.left, rect.top, rect.width, rect.height);
                console.log('🎯 Drag offset:', dragOffset);
                
                e.preventDefault();
                e.stopPropagation();
            }, { passive: false });

            // Setup drag - MOUSE (pour test desktop)
            handle.addEventListener('mousedown', function(e) {
                console.log('🖱️ MOUSE DOWN');
                isDraggingFloatingMenu = true;
                const rect = menu.getBoundingClientRect();
                
                dragOffset.x = e.clientX - rect.left;
                dragOffset.y = e.clientY - rect.top;
                
                handle.style.background = 'var(--accent-red)';
                
                e.preventDefault();
                e.stopPropagation();
            });

            console.log('✅ Drag handlers installés sur handle');
        }

        // TOUCH MOVE - au niveau global
        document.addEventListener('touchmove', function(e) {
            console.log('👆 TOUCH MOVE event - isDragging:', isDraggingFloatingMenu);
            
            if (!isDraggingFloatingMenu) return;
            
            console.log('👆 TOUCH MOVE - vraiment en train de bouger!');
            const menu = document.getElementById('floatingEditorMenu');
            const handle = document.getElementById('floatingMenuHandle');
            const touch = e.touches[0];
            
            const newX = touch.clientX - dragOffset.x;
            const newY = touch.clientY - dragOffset.y;
            
            console.log('📍 Nouvelle position calculée:', newX, newY);
            
            floatingMenuPosition.x = Math.max(10, Math.min(newX, window.innerWidth - menu.offsetWidth - 10));
            floatingMenuPosition.y = Math.max(10, Math.min(newY, window.innerHeight - menu.offsetHeight - 10));
            
            console.log('📍 Position finale:', floatingMenuPosition);
            
            menu.style.transform = 'none';
            menu.style.left = floatingMenuPosition.x + 'px';
            menu.style.top = floatingMenuPosition.y + 'px';
            
            e.preventDefault();
            e.stopPropagation();
        }, { passive: false });

        // TOUCH END - au niveau global
        document.addEventListener('touchend', function(e) {
            console.log('👆 TOUCH END - isDragging:', isDraggingFloatingMenu);
            
            if (!isDraggingFloatingMenu) return;
            
            console.log('👆 TOUCH END - Position finale:', floatingMenuPosition);
            isDraggingFloatingMenu = false;
            
            const handle = document.getElementById('floatingMenuHandle');
            if (handle) handle.style.background = 'var(--accent-gold)';
            
            localStorage.setItem('floatingMenuPosition', JSON.stringify(floatingMenuPosition));
            console.log('💾 Position sauvegardée');
        });

        // MOUSE MOVE - au niveau global
        document.addEventListener('mousemove', function(e) {
            if (!isDraggingFloatingMenu) return;
            
            console.log('🖱️ MOUSE MOVE');
            const menu = document.getElementById('floatingEditorMenu');
            
            const newX = e.clientX - dragOffset.x;
            const newY = e.clientY - dragOffset.y;
            
            floatingMenuPosition.x = Math.max(10, Math.min(newX, window.innerWidth - menu.offsetWidth - 10));
            floatingMenuPosition.y = Math.max(10, Math.min(newY, window.innerHeight - menu.offsetHeight - 10));
            
            menu.style.transform = 'none';
            menu.style.left = floatingMenuPosition.x + 'px';
            menu.style.top = floatingMenuPosition.y + 'px';
            
            e.preventDefault();
        });

        // MOUSE UP - au niveau global
        document.addEventListener('mouseup', function(e) {
            if (!isDraggingFloatingMenu) return;
            
            console.log('🖱️ MOUSE UP - Position finale:', floatingMenuPosition);
            isDraggingFloatingMenu = false;
            
            const handle = document.getElementById('floatingMenuHandle');
            if (handle) handle.style.background = 'var(--accent-gold)';
            
            localStorage.setItem('floatingMenuPosition', JSON.stringify(floatingMenuPosition));
        });

        function updateFloatingMenuPosition() {
            const menu = document.getElementById('floatingEditorMenu');
            if (menu && floatingMenuPosition) {
                menu.style.transform = 'none'; // Annuler le centrage par défaut
                menu.style.left = floatingMenuPosition.x + 'px';
                menu.style.top = floatingMenuPosition.y + 'px';
                console.log('Position mise à jour:', floatingMenuPosition);
            }
        }

        function toggleFloatingEditorMenu() {
            console.log('toggleFloatingEditorMenu appelée');
            const menu = document.getElementById('floatingEditorMenu');
            const toggle = document.getElementById('floatingEditorToggle');
            
            console.log('Menu:', menu);
            console.log('Toggle:', toggle);
            
            if (!menu || !toggle) {
                console.error('Menu ou toggle non trouvé!');
                return;
            }
            
            if (menu.classList.contains('active')) {
                console.log('Fermeture du menu');
                menu.classList.remove('active');
                toggle.textContent = '✏️';
            } else {
                console.log('Ouverture du menu');
                menu.classList.add('active');
                updateFloatingMenuPosition();
                toggle.textContent = '✖️';
            }
        }

        function applyFloatingFormat() {
            const format = document.getElementById('floatingFormatBlock').value;
            document.execCommand('formatBlock', false, format);
            const editor = document.querySelector('.editor-textarea');
            if (editor) editor.focus();
        }

        function changeFloatingTextColor() {
            const color = document.getElementById('floatingTextColor').value;
            document.execCommand('foreColor', false, color);
            const editor = document.querySelector('.editor-textarea');
            if (editor) editor.focus();
        }

        function changeFloatingBackgroundColor() {
            const color = document.getElementById('floatingBgColor').value;
            document.execCommand('hiliteColor', false, color);
            const editor = document.querySelector('.editor-textarea');
            if (editor) editor.focus();
        }

        function insertLink() {
            const url = prompt('URL du lien :');
            if (url) {
                const selection = window.getSelection();
                if (selection.toString()) {
                    document.execCommand('createLink', false, url);
                } else {
                    const text = prompt('Texte du lien :');
                    if (text) {
                        document.execCommand('insertHTML', false, `<a href="${url}" target="_blank">${text}</a>`);
                    }
                }
                const editor = document.querySelector('.editor-textarea');
                if (editor) editor.focus();
            }
        }

        function insertImage() {
            const url = prompt('URL de l\'image :');
            if (url) {
                document.execCommand('insertImage', false, url);
                const editor = document.querySelector('.editor-textarea');
                if (editor) editor.focus();
            }
        }

        // ============================================
        // END FLOATING EDITOR MENU
        // ============================================


// ========== 10.colorpalette.js ==========

        // Color palette for quick selection
        const colorPalette = [
            '#000000', '#434343', '#666666', '#999999', '#b7b7b7', '#cccccc', '#d9d9d9', '#efefef',
            '#f3f3f3', '#ffffff', '#980000', '#ff0000', '#ff9900', '#ffff00', '#00ff00', '#00ffff',
            '#4a86e8', '#0000ff', '#9900ff', '#ff00ff', '#e6b8af', '#f4cccc', '#fce5cd', '#fff2cc',
            '#d9ead3', '#d0e0e3', '#c9daf8', '#cfe2f3', '#d9d2e9', '#ead1dc', '#dd7e6b', '#ea9999',
            '#f9cb9c', '#ffe599', '#b6d7a8', '#a2c4c9', '#a4c2f4', '#9fc5e8', '#b4a7d6', '#d5a6bd',
            '#cc4125', '#e06666', '#f6b26b', '#ffd966', '#93c47d', '#76a5af', '#6d9eeb', '#6fa8dc',
            '#8e7cc3', '#c27ba0', '#a61c00', '#cc0000', '#e69138', '#f1c232', '#6aa84f', '#45818e',
            '#3c78d8', '#3d85c6', '#674ea7', '#a64d79', '#85200c', '#990000', '#b45f06', '#bf9000',
            '#38761d', '#134f5c', '#1155cc', '#0b5394', '#351c75', '#741b47', '#5b0f00', '#660000'
        ];
        
        // Initialize color pickers
// ============================================
        // SIDEBAR RESIZE
        // ============================================
        
        function initSidebarResize() {
            const sidebar = document.querySelector('.sidebar');
            const resizeHandle = document.getElementById('sidebarResizeHandle');
            const appContainer = document.querySelector('.app-container');
            
            if (!sidebar || !resizeHandle) return;
            
            let isResizing = false;
            let startX = 0;
            let startWidth = 0;
            
            resizeHandle.addEventListener('mousedown', (e) => {
                isResizing = true;
                startX = e.clientX;
                startWidth = sidebar.offsetWidth;
                
                document.body.style.cursor = 'ew-resize';
                document.body.style.userSelect = 'none';
                
                e.preventDefault();
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;
                
                const diff = e.clientX - startX;
                const newWidth = startWidth + diff;
                
                // Respecter min et max width
                if (newWidth >= 200 && newWidth <= 600) {
                    sidebar.style.width = newWidth + 'px';
                    appContainer.style.gridTemplateColumns = `${newWidth}px 1fr`;
                }
            });
            
            document.addEventListener('mouseup', () => {
                if (isResizing) {
                    isResizing = false;
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';
                    
                    // Sauvegarder la largeur dans localStorage
                    localStorage.setItem('sidebarWidth', sidebar.offsetWidth);
                }
            });
            
            // Charger la largeur sauvegardée
            const savedWidth = localStorage.getItem('sidebarWidth');
            if (savedWidth) {
                const width = parseInt(savedWidth);
                if (width >= 200 && width <= 600) {
                    sidebar.style.width = width + 'px';
                    appContainer.style.gridTemplateColumns = `${width}px 1fr`;
                }
            }
        }

        function initializeColorPickers() {
            const textColorGrid = document.getElementById('textColorGrid');
            const bgColorGrid = document.getElementById('backgroundColorGrid');
            
            // Vérifier que les éléments existent
            if (!textColorGrid || !bgColorGrid) {
                console.log('Color pickers not found in DOM, skipping initialization');
                return;
            }
            
            colorPalette.forEach(color => {
                // Text color swatch
                const textSwatch = document.createElement('div');
                textSwatch.className = 'color-swatch';
                textSwatch.style.backgroundColor = color;
                textSwatch.title = color;
                textSwatch.onclick = () => applyTextColor(color);
                textColorGrid.appendChild(textSwatch);
                
                // Background color swatch
                const bgSwatch = document.createElement('div');
                bgSwatch.className = 'color-swatch';
                bgSwatch.style.backgroundColor = color;
                bgSwatch.title = color;
                bgSwatch.onclick = () => applyBackgroundColor(color);
                bgColorGrid.appendChild(bgSwatch);
            });
        }

        // Toggle color picker dropdown
        function toggleColorPicker(type, event) {
            const textPicker = document.getElementById('textColorPicker');
            const bgPicker = document.getElementById('backgroundColorPicker');
            
            // Obtenir le bouton cliqué pour positionner la popup
            const button = event ? event.currentTarget : null;
            
            if (type === 'text') {
                const wasActive = textPicker.classList.contains('active');
                bgPicker.classList.remove('active');
                
                if (!wasActive && button) {
                    const rect = button.getBoundingClientRect();
                    textPicker.style.top = (rect.bottom + 5) + 'px';
                    textPicker.style.left = rect.left + 'px';
                }
                textPicker.classList.toggle('active');
            } else {
                const wasActive = bgPicker.classList.contains('active');
                textPicker.classList.remove('active');
                
                if (!wasActive && button) {
                    const rect = button.getBoundingClientRect();
                    bgPicker.style.top = (rect.bottom + 5) + 'px';
                    bgPicker.style.left = rect.left + 'px';
                }
                bgPicker.classList.toggle('active');
            }
        }

        // Apply text color
        function applyTextColor(color) {
            document.execCommand('foreColor', false, color);
            document.getElementById('textColorInput').value = color;
            document.getElementById('textColorHex').value = color.toUpperCase();
            document.querySelector('.editor-textarea').focus();
        }

        // Apply background color
        function applyBackgroundColor(color) {
            document.execCommand('hiliteColor', false, color);
            document.getElementById('bgColorInput').value = color;
            document.getElementById('bgColorHex').value = color.toUpperCase();
            document.querySelector('.editor-textarea').focus();
        }

        // Close color pickers when clicking outside
        document.addEventListener('click', function(event) {
            if (!event.target.closest('.color-picker-wrapper')) {
                document.querySelectorAll('.color-picker-dropdown').forEach(picker => {
                    picker.classList.remove('active');
                });
            }
        });

        function handleEditorKeydown(event) {
            // Handle keyboard shortcuts
            if (event.ctrlKey || event.metaKey) {
                switch(event.key.toLowerCase()) {
                    case 'b':
                        event.preventDefault();
                        formatText('bold');
                        break;
                    case 'i':
                        event.preventDefault();
                        formatText('italic');
                        break;
                    case 'u':
                        event.preventDefault();
                        formatText('underline');
                        break;
                }
            }
        }

// ========== 11.updateStats.js ==========

        function updateStats() {
            const totalActs = project.acts.length;
            const totalChapters = project.acts.reduce((sum, act) => sum + act.chapters.length, 0);
            const totalWords = project.acts.reduce((sum, act) => {
                return sum + act.chapters.reduce((chSum, chapter) => {
                    return chSum + chapter.scenes.reduce((sceneSum, scene) => {
                        return sceneSum + getWordCount(scene.content);
                    }, 0);
                }, 0);
            }, 0);

            // Mettre à jour les stats dans le header
            const headerWords = document.getElementById('headerTotalWords');
            const headerChapters = document.getElementById('headerTotalChapters');
            if (headerWords) headerWords.textContent = `${totalWords} mots`;
            if (headerChapters) headerChapters.textContent = `${totalChapters} chapitres`;
            
            // Mettre à jour le titre du projet dans le header
            const headerTitle = document.getElementById('headerProjectTitle');
            if (headerTitle) headerTitle.textContent = project.title;
        }

// ========== 12.import-export.js ==========

        // Backup and Import Management
        function showBackupMenu() {
            document.getElementById('backupModal').classList.add('active');
        }

        function exportToJSON() {
            const dataStr = JSON.stringify(project, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const filename = `${project.title.replace(/\s+/g, '_')}_${new Date().toISOString().split('T')[0]}.json`;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
            
            alert(`? Fichier JSON téléchargé !\n\nNom : ${filename}\n\nTu peux maintenant l'uploader sur Google Drive, Dropbox, ou tout autre service cloud.`);
        }

        function importFromFile() {
            document.getElementById('importFileInput').click();
        }

        function handleFileImport(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (!file.name.endsWith('.json')) {
                alert('? Erreur : Le fichier doit être au format JSON');
                return;
            }

            if (!confirm('?? ATTENTION : L\'import va remplacer toutes vos données actuelles.\n\nVoulez-vous créer une sauvegarde avant de continuer ?')) {
                event.target.value = ''; // Reset input
                return;
            }

            // Create backup before import
            exportToJSON();

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedData = JSON.parse(e.target.result);
                    
                    // Validate imported data
                    if (!importedData.acts || !Array.isArray(importedData.acts)) {
                        throw new Error('Format de fichier invalide');
                    }

                    // Merge with current structure to ensure all fields exist
                    project = {
                        title: importedData.title || "Mon Roman",
                        acts: importedData.acts || [],
                        characters: importedData.characters || [],
                        world: importedData.world || [],
                        timeline: importedData.timeline || [],
                        notes: importedData.notes || [],
                        codex: importedData.codex || [],
                        stats: importedData.stats || {
                            dailyGoal: 500,
                            totalGoal: 80000,
                            writingSessions: []
                        },
                        versions: importedData.versions || []
                    };

                    saveProject();
                    switchView('editor');
                    renderActsList();
                    closeModal('backupModal');
                    
                    alert('? Import réussi !\n\nToutes vos données ont été restaurées.');
                } catch (error) {
                    alert('? Erreur lors de l\'import : ' + error.message);
                }
                
                event.target.value = ''; // Reset input
            };
            
            reader.onerror = function() {
                alert('? Erreur lors de la lecture du fichier');
                event.target.value = ''; // Reset input
            };
            
            reader.readAsText(file);
        }

        // Export
        function exportProject() {
            let text = `${project.title}\n${'='.repeat(project.title.length)}\n\n`;
            
            project.acts.forEach(act => {
                text += `\n\n${act.title}\n${'='.repeat(act.title.length)}\n\n`;
                
                act.chapters.forEach(chapter => {
                    text += `\n${chapter.title}\n${'-'.repeat(chapter.title.length)}\n\n`;
                    chapter.scenes.forEach(scene => {
                        // Convert HTML to plain text for export
                        const temp = document.createElement('div');
                        temp.innerHTML = scene.content;
                        const plainText = temp.textContent || temp.innerText || '';
                        
                        text += `\n${scene.title}\n\n${plainText}\n\n`;
                    });
                });
            });

            const blob = new Blob([text], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${project.title.replace(/\s+/g, '_')}.txt`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // Modal Management
        function openAddActModal() {
            document.getElementById('addActModal').classList.add('active');
            setTimeout(() => document.getElementById('actTitleInput').focus(), 100);
        }

        function openAddChapterModal(actId) {
            // Si pas d'actId fourni, utiliser le premier acte ou on en créera un
            if (actId) {
                activeActId = actId;
            } else if (project.acts.length > 0) {
                activeActId = project.acts[0].id;
            } else {
                activeActId = null; // Sera créé dans addChapter
            }
            document.getElementById('addChapterModal').classList.add('active');
            setTimeout(() => document.getElementById('chapterTitleInput').focus(), 100);
        }

        function closeModal(modalId) {
            document.getElementById(modalId).classList.remove('active');
        }


// ========== 13.mobile-menu.js ==========

 
       // ========================================
        // MOBILE MENU FUNCTIONS
        // ========================================
        
        function toggleMobileSidebar() {
            const sidebar = document.querySelector('.sidebar');
            const overlay = document.querySelector('.sidebar-overlay');
            const handle = document.querySelector('.mobile-menu-handle');
            
            console.log('?? toggleMobileSidebar appelé');
            console.log('Sidebar:', sidebar);
            console.log('Overlay:', overlay);
            console.log('Handle:', handle);
            
            // Toggle sidebar
            sidebar.classList.toggle('mobile-open');
            
            console.log('Sidebar classes:', sidebar.className);
            console.log('Sidebar mobile-open?', sidebar.classList.contains('mobile-open'));
            
            // Toggle overlay and handle
            if (sidebar.classList.contains('mobile-open')) {
                overlay.style.display = 'block';
                setTimeout(() => overlay.classList.add('active'), 10);
                if (handle) handle.classList.add('hidden');
                // Prevent body scroll when menu is open
                document.body.style.overflow = 'hidden';
                console.log('?  Sidebar ouverte');
            } else {
                overlay.classList.remove('active');
                setTimeout(() => overlay.style.display = 'none', 300);
                if (handle) handle.classList.remove('hidden');
                // Restore body scroll
                document.body.style.overflow = '';
                console.log('? Sidebar fermée');
            }
        }
        
        function closeMobileSidebar() {
            const sidebar = document.querySelector('.sidebar');
            const overlay = document.querySelector('.sidebar-overlay');
            const handle = document.querySelector('.mobile-menu-handle');
            
            if (sidebar.classList.contains('mobile-open')) {
                sidebar.classList.remove('mobile-open');
                overlay.classList.remove('active');
                setTimeout(() => overlay.style.display = 'none', 300);
                if (handle) handle.classList.remove('hidden');
                document.body.style.overflow = '';
            }
        }
        
        // ========================================
        // MOBILE NAVIGATION FUNCTIONS
        // ========================================
        
        function toggleMobileNav() {
            const dropdown = document.getElementById('mobileNavDropdown');
            const toggleBtn = document.getElementById('mobileNavToggleBtn');
            const sidebar = document.querySelector('.sidebar');

            // Icône Lucid 'Menu' (pour ouvrir)
            const menuIcon = `
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-menu">
                    <line x1="4" x2="20" y1="12" y2="12"/>
                    <line x1="4" x2="20" y1="6" y2="6"/>
                    <line x1="4" x2="20" y1="18" y2="18"/>
                </svg>
            `;

            // Icône Lucid 'X' (pour fermer)
            const closeIcon = `
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-x">
                    <path d="M18 6 6 18"/>
                    <path d="m6 6 12 12"/>
                </svg>
            `;
            
            // Déterminez si le menu est actif (ouvert)
            if (dropdown.classList.contains('active')) {
                // Fermer le menu
                dropdown.classList.remove('active');
                toggleBtn.innerHTML = menuIcon; // Remplacer par l'icône 'Menu'
                if (sidebar) sidebar.style.visibility = '';
            } else {
                // Ouvrir le menu
                dropdown.classList.add('active');
                toggleBtn.innerHTML = closeIcon; // Remplacer par l'icône 'X'
                if (sidebar) sidebar.style.visibility = 'hidden';
            }
        }
        
        function closeMobileNav() {
            const dropdown = document.getElementById('mobileNavDropdown');
            const toggleBtn = document.getElementById('mobileNavToggleBtn');
            const sidebar = document.querySelector('.sidebar');
            
            if (dropdown.classList.contains('active')) {
                dropdown.classList.remove('active');
                toggleBtn.innerHTML = '?';
                if (sidebar) sidebar.style.visibility = '';
            }
        }
        
        function switchViewMobile(view) {
            // Update active state in mobile menu
            document.querySelectorAll('.mobile-nav-item').forEach(item => {
                item.classList.remove('active');
            });
            const activeItem = document.querySelector(`[data-view="${view}"]`);
            if (activeItem) {
                activeItem.classList.add('active');
            }
            
            // Close mobile nav
            closeMobileNav();
            
            // Switch to the view
            switchView(view);
        }
        
        // ========================================
        // MOBILE EDITOR TOOLBAR FUNCTIONS
        // ========================================
        
        function toggleEditorToolbar() {
            const toolbar = document.getElementById('editorToolbar');
            const toggleText = document.getElementById('toolbarToggleText');
            const toggleBtn = document.querySelector('.toolbar-mobile-toggle');
            
            if (toolbar.classList.contains('expanded')) {
                toolbar.classList.remove('expanded');
                toggleText.innerHTML = '<i data-lucide="pen-line" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Afficher les outils de formatage';
                if (toggleBtn) toggleBtn.classList.remove('expanded');
                if (typeof lucide !== 'undefined') lucide.createIcons();
            } else {
                toolbar.classList.add('expanded');
                toggleText.innerHTML = '<i data-lucide="x" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Masquer les outils de formatage';
                if (toggleBtn) toggleBtn.classList.add('expanded');
                if (typeof lucide !== 'undefined') lucide.createIcons();
            }
        }

        function toggleLinksPanel() {
            const panel = document.getElementById('linksPanel');
            const toggleText = document.getElementById('linksPanelToggleText');
            const toggleBtn = document.querySelector('.links-panel-toggle');
            
            if (panel.classList.contains('expanded')) {
                panel.classList.remove('expanded');
                if (toggleText) toggleText.innerHTML = '<i data-lucide="chevron-right" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Afficher personnages & lieux liés';
                if (toggleBtn) toggleBtn.classList.remove('expanded');
                if (typeof lucide !== 'undefined') lucide.createIcons();
            } else {
                panel.classList.add('expanded');
                if (toggleText) toggleText.innerHTML = '<i data-lucide="chevron-down" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Masquer personnages & lieux liés';
                if (toggleBtn) toggleBtn.classList.add('expanded');
                if (typeof lucide !== 'undefined') lucide.createIcons();
            }
        }

        function toggleToolbarFromFloating() {
            // Fermer le menu flottant
            const floatingMenu = document.getElementById('floatingEditorMenu');
            const floatingToggle = document.getElementById('floatingEditorToggle');
            
            if (floatingMenu && floatingMenu.classList.contains('active')) {
                floatingMenu.classList.remove('active');
                if (floatingToggle) floatingToggle.textContent = '??';
            }
            
            // Ouvrir le toolbar complet
            const toolbar = document.getElementById('editorToolbar');
            const toggleText = document.getElementById('toolbarToggleText');
            const toggleBtn = document.querySelector('.toolbar-mobile-toggle');
            
            if (toolbar && !toolbar.classList.contains('expanded')) {
                toolbar.classList.add('expanded');
                if (toggleText) toggleText.textContent = '? Masquer les outils de formatage';
                if (toggleBtn) toggleBtn.classList.add('expanded');
            }
            
            // Scroll vers le toolbar pour le rendre visible
            setTimeout(() => {
                if (toolbar) {
                    toolbar.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
            }, 100);
        }
        
        function toggleAdvancedMenu() {
            const advancedBar = document.getElementById('advancedMenuBar');
            const advancedBtn = document.getElementById('advancedMenuBtn');
            
            console.log('Toggle advanced menu clicked');
            console.log('Advanced bar found:', !!advancedBar);
            console.log('Current display:', advancedBar ? window.getComputedStyle(advancedBar).display : 'not found');
            
            if (advancedBar.classList.contains('active')) {
                console.log('Hiding advanced menu');
                advancedBar.classList.remove('active');
                advancedBtn.style.background = '';
            } else {
                console.log('Showing advanced menu');
                advancedBar.classList.add('active');
                advancedBtn.style.background = 'rgba(255,215,0,0.3)';
                
                // Force display after a tick
                setTimeout(() => {
                    console.log('After timeout display:', window.getComputedStyle(advancedBar).display);
                }, 10);
            }
        }
        
        function insertLink() {
            const url = prompt('Entrez l\'URL du lien:');
            if (url) {
                formatText('createLink', url);
            }
        }
        
        // Override switchView to close mobile sidebar
        const originalSwitchView = switchView;
        switchView = function(view) {
            if (window.innerWidth <= 900) {
                closeMobileSidebar();
            }
            originalSwitchView(view);
        };
        
        // Détection dynamique du débordement du header
        function checkHeaderOverflow() {
            const header = document.querySelector('.app-header');
            const headerNav = document.querySelector('.header-nav');
            const body = document.body;
            
            if (!header || !headerNav) return;
            
            // Temporairement forcer le mode desktop pour mesurer
            body.classList.remove('force-mobile-nav');
            
            // Attendre le reflow
            requestAnimationFrame(() => {
                const headerWidth = header.offsetWidth;
                const logoWidth = document.querySelector('.app-logo')?.offsetWidth || 0;
                const actionsWidth = document.querySelector('.header-actions')?.offsetWidth || 0;
                const navWidth = headerNav.scrollWidth;
                const availableSpace = headerWidth - logoWidth - actionsWidth - 60; // 60px de marge
                
                if (navWidth > availableSpace) {
                    body.classList.add('force-mobile-nav');
                } else {
                    body.classList.remove('force-mobile-nav');
                }
            });
        }
        
        // Handle window resize
        let resizeTimeout;
        window.addEventListener('resize', function() {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(function() {
                // Vérifier le débordement du header
                checkHeaderOverflow();
                
                // If resizing to desktop, ensure sidebar is visible and overlay hidden
                if (window.innerWidth > 900 && !document.body.classList.contains('force-mobile-nav')) {
                    const sidebar = document.querySelector('.sidebar');
                    const overlay = document.querySelector('.sidebar-overlay');
                    const menuBtn = document.querySelector('.mobile-menu-toggle');
                    
                    if (sidebar) sidebar.classList.remove('mobile-open');
                    if (overlay) {
                        overlay.classList.remove('active');
                        overlay.style.display = 'none';
                    }
                    if (menuBtn) menuBtn.innerHTML = '?';
                    document.body.style.overflow = '';
                }
            }, 100);
        });
        
        // Vérifier au chargement
        window.addEventListener('load', function() {
            setTimeout(checkHeaderOverflow, 100);
        });


// ========== 14.dragndrop-acts.js ==========

        // Drag and Drop for Acts
        let draggedAct = null;

        function setupActDragAndDrop() {
            const actHeaders = document.querySelectorAll('.act-header');
            
            actHeaders.forEach(header => {
                const dragHandle = header.querySelector('.drag-handle');
                if (!dragHandle) return;
                
                dragHandle.addEventListener('dragstart', (e) => {
                    draggedAct = parseInt(header.dataset.actId);
                    header.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('type', 'act');
                    e.stopPropagation(); // Empêcher le clic de se propager
                });

                dragHandle.addEventListener('dragend', (e) => {
                    header.classList.remove('dragging');
                    draggedAct = null;
                });

                header.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    
                    const targetActId = parseInt(e.currentTarget.dataset.actId);
                    if (draggedAct && draggedAct !== targetActId) {
                        e.currentTarget.classList.add('drag-over');
                    }
                });

                header.addEventListener('dragleave', (e) => {
                    e.currentTarget.classList.remove('drag-over');
                });

                header.addEventListener('drop', (e) => {
                    e.preventDefault();
                    e.currentTarget.classList.remove('drag-over');
                    
                    const targetActId = parseInt(e.currentTarget.dataset.actId);
                    
                    if (draggedAct && draggedAct !== targetActId) {
                        reorderActs(draggedAct, targetActId);
                    }
                });
            });
        }

        function reorderActs(draggedId, targetId) {
            const draggedIndex = project.acts.findIndex(a => a.id === draggedId);
            const targetIndex = project.acts.findIndex(a => a.id === targetId);
            
            if (draggedIndex === -1 || targetIndex === -1) return;
            
            const [removed] = project.acts.splice(draggedIndex, 1);
            project.acts.splice(targetIndex, 0, removed);
            
            saveProject();
            renderActsList();
        }

        // Drag and Drop for Chapters
        let draggedChapter = { chapterId: null, actId: null };

        function setupChapterDragAndDrop() {
            const chapterHeaders = document.querySelectorAll('.chapter-header');
            
            chapterHeaders.forEach(header => {
                const dragHandle = header.querySelector('.drag-handle');
                if (!dragHandle) return;
                
                dragHandle.addEventListener('dragstart', (e) => {
                    draggedChapter.chapterId = parseInt(header.dataset.chapterId);
                    draggedChapter.actId = parseInt(header.dataset.actId);
                    header.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('type', 'chapter');
                    e.stopPropagation(); // Empêcher le clic de se propager
                });

                dragHandle.addEventListener('dragend', (e) => {
                    header.classList.remove('dragging');
                    draggedChapter = { chapterId: null, actId: null };
                });

                header.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    
                    const targetChapterId = parseInt(e.currentTarget.dataset.chapterId);
                    const targetActId = parseInt(e.currentTarget.dataset.actId);
                    
                    if (draggedChapter.chapterId && draggedChapter.chapterId !== targetChapterId) {
                        e.currentTarget.classList.add('drag-over');
                    } else if (draggedScene.sceneId && draggedScene.chapterId !== targetChapterId) {
                        e.currentTarget.classList.add('drag-over');
                    }
                });

                header.addEventListener('dragleave', (e) => {
                    e.currentTarget.classList.remove('drag-over');
                });

                header.addEventListener('drop', (e) => {
                    e.preventDefault();
                    e.currentTarget.classList.remove('drag-over');
                    
                    const targetChapterId = parseInt(e.currentTarget.dataset.chapterId);
                    const targetActId = parseInt(e.currentTarget.dataset.actId);
                    
                    if (draggedChapter.chapterId && draggedChapter.chapterId !== targetChapterId) {
                        reorderChapters(draggedChapter.chapterId, draggedChapter.actId, targetChapterId, targetActId);
                    } else if (draggedScene.sceneId && draggedScene.chapterId !== targetChapterId) {
                        moveSceneToChapter(draggedScene.sceneId, draggedScene.actId, draggedScene.chapterId, targetActId, targetChapterId);
                    }
                });
            });
        }

        function reorderChapters(draggedChapterId, draggedActId, targetChapterId, targetActId) {
            const sourceAct = project.acts.find(a => a.id === draggedActId);
            const targetAct = project.acts.find(a => a.id === targetActId);
            
            if (!sourceAct || !targetAct) return;
            
            const draggedIndex = sourceAct.chapters.findIndex(c => c.id === draggedChapterId);
            const targetIndex = targetAct.chapters.findIndex(c => c.id === targetChapterId);
            
            if (draggedIndex === -1 || targetIndex === -1) return;
            
            const [removed] = sourceAct.chapters.splice(draggedIndex, 1);
            
            if (draggedActId === targetActId) {
                targetAct.chapters.splice(targetIndex, 0, removed);
            } else {
                targetAct.chapters.splice(targetIndex, 0, removed);
            }
            
            saveProject();
            renderActsList();
        }

        // Drag and Drop for Scenes
        let draggedScene = { sceneId: null, chapterId: null, actId: null };

        function setupSceneDragAndDrop() {
            const sceneItems = document.querySelectorAll('.scene-item.draggable');
            
            sceneItems.forEach(item => {
                item.addEventListener('dragstart', (e) => {
                    draggedScene.sceneId = parseInt(e.target.dataset.sceneId);
                    draggedScene.chapterId = parseInt(e.target.dataset.chapterId);
                    draggedScene.actId = parseInt(e.target.dataset.actId);
                    e.target.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                });

                item.addEventListener('dragend', (e) => {
                    e.target.classList.remove('dragging');
                    draggedScene = { sceneId: null, chapterId: null, actId: null };
                });

                item.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    
                    const targetSceneId = parseInt(e.currentTarget.dataset.sceneId);
                    const targetChapterId = parseInt(e.currentTarget.dataset.chapterId);
                    
                    if (draggedScene.sceneId && draggedScene.sceneId !== targetSceneId) {
                        e.currentTarget.classList.add('drag-over');
                    }
                });

                item.addEventListener('dragleave', (e) => {
                    e.currentTarget.classList.remove('drag-over');
                });

                item.addEventListener('drop', (e) => {
                    e.preventDefault();
                    e.currentTarget.classList.remove('drag-over');
                    
                    const targetSceneId = parseInt(e.currentTarget.dataset.sceneId);
                    const targetChapterId = parseInt(e.currentTarget.dataset.chapterId);
                    const targetActId = parseInt(e.currentTarget.dataset.actId);
                    
                    if (draggedScene.sceneId && draggedScene.sceneId !== targetSceneId) {
                        reorderScenes(
                            draggedScene.sceneId, 
                            draggedScene.actId,
                            draggedScene.chapterId,
                            targetSceneId,
                            targetActId,
                            targetChapterId
                        );
                    }
                });
            });
        }

        function reorderScenes(draggedSceneId, draggedActId, draggedChapterId, targetSceneId, targetActId, targetChapterId) {
            const sourceAct = project.acts.find(a => a.id === draggedActId);
            const targetAct = project.acts.find(a => a.id === targetActId);
            
            if (!sourceAct || !targetAct) return;
            
            const sourceChapter = sourceAct.chapters.find(c => c.id === draggedChapterId);
            const targetChapter = targetAct.chapters.find(c => c.id === targetChapterId);
            
            if (!sourceChapter || !targetChapter) return;
            
            const draggedIndex = sourceChapter.scenes.findIndex(s => s.id === draggedSceneId);
            const targetIndex = targetChapter.scenes.findIndex(s => s.id === targetSceneId);
            
            if (draggedIndex === -1 || targetIndex === -1) return;
            
            const [removed] = sourceChapter.scenes.splice(draggedIndex, 1);
            
            if (draggedChapterId === targetChapterId) {
                targetChapter.scenes.splice(targetIndex, 0, removed);
            } else {
                targetChapter.scenes.splice(targetIndex, 0, removed);
            }
            
            saveProject();
            renderActsList();
        }

        function moveSceneToChapter(sceneId, sourceActId, sourceChapterId, targetActId, targetChapterId) {
            const sourceAct = project.acts.find(a => a.id === sourceActId);
            const targetAct = project.acts.find(a => a.id === targetActId);
            
            if (!sourceAct || !targetAct) return;
            
            const sourceChapter = sourceAct.chapters.find(c => c.id === sourceChapterId);
            const targetChapter = targetAct.chapters.find(c => c.id === targetChapterId);
            
            if (!sourceChapter || !targetChapter) return;
            
            const sceneIndex = sourceChapter.scenes.findIndex(s => s.id === sceneId);
            if (sceneIndex === -1) return;
            
            const [removed] = sourceChapter.scenes.splice(sceneIndex, 1);
            targetChapter.scenes.push(removed);
            
            saveProject();
            renderActsList();
            
            // Auto-expand target chapter
            setTimeout(() => {
                const targetChapterElement = document.getElementById(`chapter-${targetChapterId}`);
                if (targetChapterElement) {
                    const icon = targetChapterElement.querySelector('.chapter-icon');
                    const scenesList = targetChapterElement.querySelector('.scenes-list');
                    if (!scenesList.classList.contains('visible')) {
                        icon.classList.add('expanded');
                        scenesList.classList.add('visible');
                    }
                }
            }, 100);
        }


// ========== 15.characters.js ==========


        // View Management
        
        // Si la liste des races n'existe pas, on en crée une par défaut
        if (!project.races) {
            project.races = ['Humain', 'Elfe', 'Nain', 'Orc', 'Autre'];
        }

        function addNewRace(charId) {
            const newRace = prompt("Nom de la nouvelle race :");
            if (newRace && newRace.trim() !== "") {
                const formattedRace = newRace.trim();
                
                // Ajouter à la liste globale si elle n'existe pas déjà
                if (!project.races.includes(formattedRace)) {
                    project.races.push(formattedRace);
                    project.races.sort(); // Trier alphabétiquement
                    
                    // Sauvegarder le projet global
                    saveProject();
                    
                    // Assigner cette nouvelle race au personnage en cours
                    updateCharacterField(charId, 'race', formattedRace);
                    
                    // Rafraîchir l'affichage
                    openCharacterDetail(charId);
                    renderCharacterList();
                } else {
                    alert("Cette race existe déjà !");
                }
            }
        }

        // Character Management
        function openAddCharacterModal() {
            document.getElementById('addCharacterModal').classList.add('active');
            setTimeout(() => document.getElementById('characterNameInput').focus(), 100);
        }

        function addCharacter() {
            const name = document.getElementById('characterNameInput').value.trim();
            const role = document.getElementById('characterRoleInput').value.trim();
            const description = document.getElementById('characterDescInput').value.trim();
            
            if (!name) return;

            const character = {
                id: Date.now(),
                // État civil
                firstName: name.split(' ')[0] || '',
                lastName: name.split(' ').slice(1).join(' ') || '',
                nickname: '',
                pronouns: '',
                sex: '',
                race: 'Humain',
                age: '',
                birthDate: '',
                birthPlace: '',
                residence: '',
                occupation: '',
                // Header
                name: name,
                role: role || '',
                roleImportance: 3, // 1-5 stars
                avatarEmoji: '??',
                avatarImage: '',
                // Physique
                height: '',
                weight: '',
                bodyType: '',
                hairColor: '',
                eyeColor: '',
                voice: '',
                clothing: '',
                accessories: '',
                physicalDescription: description || '',
                // Caractère
                qualities: [], // tags array
                flaws: [], // tags array
                tastes: '',
                habits: '',
                fears: '',
                // Personnalité radar (0-20)
                personality: {
                    intelligence: 10,
                    force: 10,
                    robustesse: 10,
                    empathie: 10,
                    perception: 10,
                    agilite: 10,
                    sociabilite: 10
                },
                // Profil
                education: '',
                wealth: 50, // 0-100 slider
                secrets: '',
                beliefs: '',
                importantPlaces: '',
                catchphrases: '',
                // Évolution
                goals: '',
                past: '',
                present: '',
                future: '',
                // Inventaire & Possessions
                inventory: [], // [{id, name, quantity, description}]
                possessions: [], // [{id, name, quantity, description}]
                // Autres
                notes: '',
                // Legacy fields for compatibility
                appearance: '',
                background: '',
                relationships: '',
                linkedScenes: [],
                linkedElements: []
            };

            project.characters.push(character);
            
            // Clear inputs
            document.getElementById('characterNameInput').value = '';
            document.getElementById('characterRoleInput').value = '';
            document.getElementById('characterDescInput').value = '';
            
            closeModal('addCharacterModal');
            saveProject();
            renderCharactersList();
            
            // Open the new character detail
            openCharacterDetail(character.id);
        }

        function deleteCharacter(id) {
            if (!confirm('Êtes-vous sûr de vouloir supprimer ce personnage ?')) return;
            project.characters = project.characters.filter(c => c.id !== id);
            saveProject();
            renderCharactersList();
            showEmptyState();
        }

        function renderCharactersList() {
            const container = document.getElementById('charactersList');
            
            // 1. Gestion du cas vide
            if (!project.characters || project.characters.length === 0) {
                container.innerHTML = '<div style="padding: 1rem; text-align: center; color: var(--text-muted); font-size: 0.85rem;">Aucun personnage</div>';
                return;
            }

            // 2. Initialisation des groupes
            // On s'assure que la liste des races existe dans le projet
            if (!project.races) {
                project.races = ['Humain', 'Elfe', 'Nain', 'Orc', 'Autre']; // Valeurs par défaut si besoin
            }

            // On prépare l'objet de regroupement
            const groups = {};
            
            // On initialise les clés pour respecter l'ordre défini dans project.races
            project.races.forEach(race => {
                groups[race] = [];
            });
            // On ajoute le groupe fourre-tout à la fin
            groups['Non classé'] = [];

            // 3. Distribution des personnages dans les groupes
            project.characters.forEach(char => {
                migrateCharacterData(char); // On garde votre migration
                
                // Si la race du perso existe et fait partie de notre liste officielle -> on l'utilise
                // Sinon -> 'Non classé'
                const raceKey = (char.race && project.races.includes(char.race)) ? char.race : 'Non classé';
                
                // Sécurité au cas où project.races a changé mais le perso a une vieille race
                if (!groups[raceKey]) groups[raceKey] = [];
                
                groups[raceKey].push(char);
            });

            // 4. Construction du HTML
            let html = '<div class="treeview-children" style="margin-left: 0; border-left: none; padding-left: 0;">';
            
            // On parcourt chaque groupe (Race)
            Object.keys(groups).forEach(raceName => {
                const charsInGroup = groups[raceName];

                // On n'affiche le groupe que s'il contient des personnages
                if (charsInGroup.length > 0) {
                    
                    // Tri alphabétique interne au groupe
                    charsInGroup.sort((a, b) => {
                        const nameA = (a.name || a.firstName || '').toLowerCase();
                        const nameB = (b.name || b.firstName || '').toLowerCase();
                        return nameA.localeCompare(nameB, 'fr');
                    });

                    // En-tête de la race (Style visuel simple pour séparer)
                    html += `
                        <div style="
                            padding: 6px 12px;
                            background: var(--bg-secondary, rgba(255,255,255,0.05));
                            color: var(--text-muted);
                            font-size: 0.75rem;
                            font-weight: bold;
                            text-transform: uppercase;
                            border-top: 1px solid var(--border-color);
                            border-bottom: 1px solid var(--border-color);
                            margin-top: 8px;
                            margin-bottom: 4px;
                            display: flex; 
                            justify-content: space-between;
                        ">
                            <span>${raceName}</span>
                            <span style="opacity: 0.6;">${charsInGroup.length}</span>
                        </div>
                    `;

                    // Liste des personnages du groupe
                    charsInGroup.forEach(char => {
                        const displayName = char.name || char.firstName || 'Sans nom';
                        html += `
                            <div class="treeview-item" onclick="openCharacterDetail(${char.id})">
                                <span class="treeview-item-icon">
                                    <i data-lucide="user" style="width:14px;height:14px;vertical-align:middle;"></i>
                                </span>
                                <span class="treeview-item-label">${displayName}</span>
                                <button class="treeview-item-delete" onclick="event.stopPropagation(); deleteCharacter(${char.id})" title="Supprimer">×</button>
                            </div>
                        `;
                    });
                }
            });
            
            html += '</div>';
            container.innerHTML = html;

            // IMPORTANT : Rafraîchir les icônes Lucide car on a réécrit le DOM
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
        }
        
        function toggleTreeviewGroup(groupKey) {
            const collapsedState = JSON.parse(localStorage.getItem('plume_treeview_collapsed') || '{}');
            collapsedState[groupKey] = !collapsedState[groupKey];
            localStorage.setItem('plume_treeview_collapsed', JSON.stringify(collapsedState));
            
            // Re-render the appropriate list
            if (groupKey.startsWith('chars_')) renderCharactersList();
            else if (groupKey.startsWith('world_')) renderWorldList();
            else if (groupKey.startsWith('codex_')) renderCodexList();
        }

        function renderCharacterLinkedScenes(character) {
            const scenes = findScenesWithCharacter(character.id);
            if (scenes.length === 0) return '';

            return `
                <div class="detail-section">
                    <div class="detail-section-title"><i data-lucide="file-text" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Apparaît dans ${scenes.length} scène(s)</div>
                    <div class="quick-links">
                        ${scenes.map(scene => {
                            const actIndex = project.acts.findIndex(a => a.id === scene.actId);
                            const act = project.acts[actIndex];
                            const chapterIndex = act.chapters.findIndex(c => c.id === scene.chapterId);
                            const actNumber = toRoman(actIndex + 1);
                            const chapterNumber = chapterIndex + 1;
                            const breadcrumb = `Acte ${actNumber} › Chapitre ${chapterNumber} › ${scene.sceneTitle}`;
                            
                            return `
                            <span class="link-badge" onclick="openScene(${scene.actId}, ${scene.chapterId}, ${scene.sceneId})" title="${scene.actTitle} - ${scene.chapterTitle}">
                                ${breadcrumb}
                            </span>
                        `;
                        }).join('')}
                    </div>
                </div>
            `;
        }

        function openCharacterDetail(id) {
            const character = project.characters.find(c => c.id === id);
            if (!character) return;
            
            // 1. Initialiser les races si elles n'existent pas
            if (!project.races) {
                project.races = ['Humain', 'Elfe', 'Nain', 'Orc', 'Autre'];
            }

            // Ensure new fields exist for legacy characters
            migrateCharacterData(character);
            
            // Handle split view mode
            if (splitViewActive) {
                const state = splitActivePanel === 'left' ? splitViewState.left : splitViewState.right;
                if (state.view === 'characters') {
                    state.characterId = id;
                    renderSplitPanelViewContent(splitActivePanel);
                    saveSplitViewState();
                    return;
                }
            }

            const editorView = document.getElementById('editorView');
            // On appelle la fonction de rendu (modifiée ci-dessous)
            editorView.innerHTML = renderCharacterSheet(character, false);
            
            // Initialize radar chart
            setTimeout(() => {
                initCharacterRadar(character);
                lucide.createIcons();
            }, 50);
        }
        
        function migrateCharacterData(char) {
            // Migrate legacy characters to new structure
            if (!char.firstName) char.firstName = char.name?.split(' ')[0] || '';
            if (!char.lastName) char.lastName = char.name?.split(' ').slice(1).join(' ') || '';
            if (!char.nickname) char.nickname = '';
            if (!char.pronouns) char.pronouns = '';
            if (!char.sex) char.sex = '';
            if (!char.race) char.race = 'Humain';
            if (!char.birthDate) char.birthDate = '';
            if (!char.birthPlace) char.birthPlace = '';
            if (!char.residence) char.residence = '';
            if (!char.occupation) char.occupation = '';
            if (!char.roleImportance) char.roleImportance = 3;
            if (!char.avatarEmoji) char.avatarEmoji = '??';
            if (!char.avatarImage) char.avatarImage = '';
            if (!char.height) char.height = '';
            if (!char.weight) char.weight = '';
            if (!char.bodyType) char.bodyType = '';
            if (!char.hairColor) char.hairColor = '';
            if (!char.eyeColor) char.eyeColor = '';
            if (!char.voice) char.voice = '';
            if (!char.clothing) char.clothing = '';
            if (!char.accessories) char.accessories = '';
            if (!char.physicalDescription) char.physicalDescription = char.appearance || '';
            if (!char.qualities) char.qualities = [];
            if (!char.flaws) char.flaws = [];
            if (!char.tastes) char.tastes = '';
            if (!char.habits) char.habits = '';
            if (!char.fears) char.fears = '';
            if (!char.personality || typeof char.personality === 'string') {
                const oldPersonality = char.personality || '';
                char.personality = {
                    intelligence: 10,
                    force: 10,
                    robustesse: 10,
                    empathie: 10,
                    perception: 10,
                    agilite: 10,
                    sociabilite: 10
                };
                if (oldPersonality) char.notes = (char.notes || '') + '\n\nPersonnalité (ancien):\n' + oldPersonality;
            }
            if (!char.education) char.education = '';
            if (char.wealth === undefined) char.wealth = 50;
            if (!char.secrets) char.secrets = '';
            if (!char.beliefs) char.beliefs = '';
            if (!char.importantPlaces) char.importantPlaces = '';
            if (!char.catchphrases) char.catchphrases = '';
            if (!char.goals) char.goals = '';
            if (!char.past) char.past = char.background || '';
            if (!char.present) char.present = '';
            if (!char.future) char.future = '';
            if (!char.inventory) char.inventory = [];
            if (!char.possessions) char.possessions = [];
        }
        
        function renderCharacterSheet(character, compact = false) {
            const metaInfo = [];
            if (character.age) metaInfo.push(`${character.age}${character.birthPlace ? ', né à ' + character.birthPlace : ''}`);
            if (character.residence) metaInfo.push(character.residence);
            const racesList = project.races || ['Humain', 'Elfe', 'Nain', 'Orc', 'Autre'];
            const raceOptions = racesList.map(r => 
                `<option value="${r}" ${character.race === r ? 'selected' : ''}>${r}</option>`
            ).join('');
            
            return `
                <div class="character-sheet" data-character-id="${character.id}">
                    <!-- Header -->
                    <div class="character-sheet-header">
                        <div class="character-avatar" onclick="changeCharacterAvatar(${character.id})" title="Changer l'avatar">
                            ${character.avatarImage
                                ? `<img src="${character.avatarImage}" alt="${character.name}">`
                                : `<i data-lucide="user" style="width:80px;height:80px;"></i>`}
                        </div>
                        <div class="character-header-info">
                            <h2 contenteditable="true" onblur="updateCharacterName(${character.id}, this.textContent)">${character.firstName}${character.lastName ? ' ' + character.lastName : ''}</h2>
                            <ul class="character-meta">
                                ${metaInfo.map(m => `<li>${m}</li>`).join('')}
                            </ul>
                        </div>
                        <button class="character-close-btn" onclick="switchView('editor')" title="Fermer">×</button>
                    </div>
                    

                    <!-- Grille des sections -->
                    <div class="character-sections-grid">
                    
                    ${renderCharacterLinkedScenes(character)}

                    <!-- État Civil -->
                    <div class="character-section" id="section-etat-civil">
                        <div class="character-section-header" onclick="toggleCharacterSection('etat-civil')">
                            <div class="character-section-title">État Civil</div>
                            <span class="character-section-toggle">
                                <i data-lucide="chevron-down" style="width:18px;height:18px;"></i>
                            </span>
                        </div>
                        <div class="character-section-content">
                            <div class="character-field-row">
                                <div class="character-field">
                                    <label class="character-field-label">Prénom</label>
                                    <input type="text" value="${character.firstName || ''}" 
                                           onchange="updateCharacterField(${character.id}, 'firstName', this.value); updateCharacterDisplayName(${character.id})">
                                </div>
                                <div class="character-field">
                                    <label class="character-field-label">Nom de famille</label>
                                    <input type="text" value="${character.lastName || ''}" 
                                           onchange="updateCharacterField(${character.id}, 'lastName', this.value); updateCharacterDisplayName(${character.id})">
                                </div>
                            </div>
                            <div class="character-field-row">
                                <div class="character-field">
                                    <label class="character-field-label">Surnom</label>
                                    <input type="text" value="${character.nickname || ''}" 
                                           onchange="updateCharacterField(${character.id}, 'nickname', this.value)">
                                </div>
                                <div class="character-field">
                                    <label class="character-field-label">Pronoms</label>
                                    <input type="text" value="${character.pronouns || ''}" placeholder="il/lui, elle/elle, iel..."
                                           onchange="updateCharacterField(${character.id}, 'pronouns', this.value)">
                                </div>
                            </div>
                            <div class="character-field-row">
                                <div class="character-field">
                                    <label class="character-field-label">Sexe</label>
                                    <div class="character-radio-group">
                                        <label><input type="radio" name="sex-${character.id}" value="F" ${character.sex === 'F' ? 'checked' : ''} onchange="updateCharacterField(${character.id}, 'sex', 'F')"> Femme</label>
                                        <label><input type="radio" name="sex-${character.id}" value="M" ${character.sex === 'M' ? 'checked' : ''} onchange="updateCharacterField(${character.id}, 'sex', 'M')"> Homme</label>
                                        <label><input type="radio" name="sex-${character.id}" value="A" ${character.sex === 'A' ? 'checked' : ''} onchange="updateCharacterField(${character.id}, 'sex', 'A')"> Autre</label>
                                    </div>
                                </div>
                                <div class="character-field">
                                    <label class="character-field-label">Race</label>
                                    <div style="display: flex; gap: 5px; align-items: center;">
                                        <select class="detail-input" style="flex-grow: 1;"
                                            onchange="updateCharacterField(${character.id}, 'race', this.value); renderCharactersList();">
                                            <option value="">Sélectionner...</option>
                                            ${raceOptions}
                                        </select>
                                        <button onclick="addNewRace(${character.id})" class="btn-icon" title="Créer une nouvelle race" style="width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; padding: 0; cursor: pointer; border: 1px solid var(--border-color); background: var(--bg-secondary); border-radius: 4px;">
                                            <i data-lucide="plus" style="width:14px;height:14px;"></i>
                                        </button>
                                    </div>
                                </div>
                            </div>
                            <div class="character-field-row">
                                <div class="character-field" style="max-width: 100px;">
                                    <label class="character-field-label">Âge</label>
                                    <input type="text" value="${character.age || ''}" 
                                           onchange="updateCharacterField(${character.id}, 'age', this.value)">
                                </div>
                                <div class="character-field">
                                    <label class="character-field-label">Date de naissance</label>
                                    <input type="text" value="${character.birthDate || ''}" placeholder="JJ/MM/AAAA"
                                           onchange="updateCharacterField(${character.id}, 'birthDate', this.value)">
                                </div>
                                <div class="character-field">
                                    <label class="character-field-label">Lieu de naissance</label>
                                    <input type="text" value="${character.birthPlace || ''}" 
                                           onchange="updateCharacterField(${character.id}, 'birthPlace', this.value)">
                                </div>
                            </div>
                            <div class="character-field-row">
                                <div class="character-field">
                                    <label class="character-field-label">Lieu de résidence</label>
                                    <input type="text" value="${character.residence || ''}" 
                                           onchange="updateCharacterField(${character.id}, 'residence', this.value)">
                                </div>
                                <div class="character-field">
                                    <label class="character-field-label">Occupation</label>
                                    <input type="text" value="${character.occupation || ''}" 
                                           onchange="updateCharacterField(${character.id}, 'occupation', this.value)">
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Physique -->
                    <div class="character-section" id="section-physique">
                        <div class="character-section-header" onclick="toggleCharacterSection('physique')">
                            <div class="character-section-title">Physique</div>
                                <span class="character-section-toggle"><i data-lucide="chevron-down" style="width:18px;height:18px;"></i></span>
                            </div>
                        <div class="character-section-content">
                            <div class="character-field-row">
                                <div class="character-field">
                                    <label class="character-field-label">Taille</label>
                                    <input type="text" value="${character.height || ''}" placeholder="cm"
                                           onchange="updateCharacterField(${character.id}, 'height', this.value)">
                                </div>
                                <div class="character-field">
                                    <label class="character-field-label">Poids</label>
                                    <input type="text" value="${character.weight || ''}" placeholder="kg"
                                           onchange="updateCharacterField(${character.id}, 'weight', this.value)">
                                </div>
                                <div class="character-field">
                                    <label class="character-field-label">Corpulence</label>
                                    <input type="text" value="${character.bodyType || ''}" 
                                           onchange="updateCharacterField(${character.id}, 'bodyType', this.value)">
                                </div>
                            </div>
                            <div class="character-field-row">
                                <div class="character-field">
                                    <label class="character-field-label">Couleur des cheveux</label>
                                    <input type="text" value="${character.hairColor || ''}" 
                                           onchange="updateCharacterField(${character.id}, 'hairColor', this.value)">
                                </div>
                                <div class="character-field">
                                    <label class="character-field-label">Couleur des yeux</label>
                                    <input type="text" value="${character.eyeColor || ''}" 
                                           onchange="updateCharacterField(${character.id}, 'eyeColor', this.value)">
                                </div>
                                <div class="character-field">
                                    <label class="character-field-label">Voix / Manière de parler</label>
                                    <input type="text" value="${character.voice || ''}" 
                                           onchange="updateCharacterField(${character.id}, 'voice', this.value)">
                                </div>
                            </div>
                            <div class="character-field-row">
                                <div class="character-field">
                                    <label class="character-field-label">Tenue</label>
                                    <textarea rows="3" onchange="updateCharacterField(${character.id}, 'clothing', this.value)">${character.clothing || ''}</textarea>
                                </div>
                                <div class="character-field">
                                    <label class="character-field-label">Accessoires</label>
                                    <textarea rows="3" onchange="updateCharacterField(${character.id}, 'accessories', this.value)">${character.accessories || ''}</textarea>
                                </div>
                            </div>
                            <div class="character-field">
                                <label class="character-field-label">Description</label>
                                <textarea rows="4" onchange="updateCharacterField(${character.id}, 'physicalDescription', this.value)">${character.physicalDescription || ''}</textarea>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Évolution - Full width car contient la timeline -->
                    <div class="character-section full-width" id="section-evolution">
                        <div class="character-section-header" onclick="toggleCharacterSection('evolution')">
                            <div class="character-section-title">Évolution</div>
                            <span class="character-section-toggle"><i data-lucide="chevron-down" style="width:18px;height:18px;"></i></span>
                        </div>
                        <div class="character-section-content">
                            <div class="character-field">
                                <label class="character-field-label">Buts / Objectifs</label>
                                <textarea rows="3" onchange="updateCharacterField(${character.id}, 'goals', this.value)">${character.goals || ''}</textarea>
                            </div>
                                
                            <div class="character-timeline">
                                <div class="timeline-card">
                                    <div class="timeline-card-title">Passé</div>
                                    <textarea placeholder="Le personnage avant le début de l'histoire (enfance, souffrances potentielles...)." 
                                              onchange="updateCharacterField(${character.id}, 'past', this.value)">${character.past || ''}</textarea>
                                </div>
                                <div class="timeline-card">
                                    <div class="timeline-card-title">Présent</div>
                                    <textarea placeholder="Le personnage au commencement de l'histoire." 
                                              onchange="updateCharacterField(${character.id}, 'present', this.value)">${character.present || ''}</textarea>
                                </div>
                                <div class="timeline-card">
                                    <div class="timeline-card-title">Futur</div>
                                    <textarea placeholder="Le personnage à la fin de l'histoire." 
                                              onchange="updateCharacterField(${character.id}, 'future', this.value)">${character.future || ''}</textarea>
                                </div>
                            </div>
                        </div>
                    </div>



                    <!-- Caractère - Full width car contient beaucoup de catégories -->
                    <div class="character-section full-width" id="section-caractere">
                        <div class="character-section-header" onclick="toggleCharacterSection('caractere')">
                            <div class="character-section-title">Traits de Caractère</div>
                            <span class="character-section-toggle"><i data-lucide="chevron-down" style="width:18px;height:18px;"></i></span>
                        </div>
                        <div class="character-section-content">
                            <!-- Traits sélectionnés -->
                            <div class="character-field">
                                <label class="character-field-label">Traits sélectionnés</label>
                                <div class="selected-traits-container" id="selectedTraits-${character.id}">
                                    ${(character.traits || []).map((t, i) => `
                                        <span class="selected-trait">${t}<span class="trait-remove" onclick="removeCharacterTrait(${character.id}, ${i})">×</span></span>
                                    `).join('') || '<span class="no-traits">Cliquez sur les traits ci-dessous pour les ajouter</span>'}
                                </div>
                            </div>
                            
                            <!-- Catégories de traits -->
                            <div class="traits-categories">
                                ${renderTraitsCategories(character.id, character.traits || [])}
                            </div>
                            
                            <!-- Champs texte conservés -->
                            <div class="character-field" style="margin-top: 1rem;">
                                <label class="character-field-label">Goûts</label>
                                <textarea rows="2" onchange="updateCharacterField(${character.id}, 'tastes', this.value)">${character.tastes || ''}</textarea>
                            </div>
                            <div class="character-field">
                                <label class="character-field-label">Tics, manies, habitudes</label>
                                <textarea rows="2" onchange="updateCharacterField(${character.id}, 'habits', this.value)">${character.habits || ''}</textarea>
                            </div>
                            <div class="character-field">
                                <label class="character-field-label">Peurs et doutes</label>
                                <textarea rows="2" onchange="updateCharacterField(${character.id}, 'fears', this.value)">${character.fears || ''}</textarea>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Profil -->
                    <div class="character-section" id="section-profil">
                        <div class="character-section-header" onclick="toggleCharacterSection('profil')">
                            <div class="character-section-title">Profil</div>
                            <span class="character-section-toggle"><i data-lucide="chevron-down" style="width:18px;height:18px;"></i></span>
                        </div>
                        <div class="character-section-content">
                            <div class="character-field">
                                <label class="character-field-label">Éducation</label>
                                <textarea rows="3" onchange="updateCharacterField(${character.id}, 'education', this.value)">${character.education || ''}</textarea>
                            </div>
                            <div class="character-field">
                                <label class="character-field-label">Secrets</label>
                                <textarea rows="3" onchange="updateCharacterField(${character.id}, 'secrets', this.value)">${character.secrets || ''}</textarea>
                            </div>
                            <div class="character-field">
                                <label class="character-field-label">Croyances et idéologies</label>
                                <textarea rows="2" onchange="updateCharacterField(${character.id}, 'beliefs', this.value)">${character.beliefs || ''}</textarea>
                            </div>
                            <div class="character-field-row">
                                <div class="character-field">
                                    <label class="character-field-label">Lieux marquants</label>
                                    <input type="text" value="${character.importantPlaces || ''}" 
                                           onchange="updateCharacterField(${character.id}, 'importantPlaces', this.value)">
                                </div>
                                <div class="character-field">
                                    <label class="character-field-label">Phrases ou expressions typiques</label>
                                    <textarea rows="3" onchange="updateCharacterField(${character.id}, 'catchphrases', this.value)">${character.catchphrases || ''}</textarea>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Inventaire -->
                    <div class="character-section" id="section-inventaire">
                        <div class="character-section-header" onclick="toggleCharacterSection('inventaire')">
                            <div class="character-section-title">Inventaire</div>
                            <span class="character-section-toggle"><i data-lucide="chevron-down" style="width:18px;height:18px;"></i></span>
                        </div>
                        <div class="character-section-content">
                            <div id="inventory-list-${character.id}">
                                ${(character.inventory || []).map((item, i) => renderInventoryItem(character.id, 'inventory', item, i)).join('')}
                            </div>
                            <button class="inventory-add-btn" onclick="addInventoryItem(${character.id}, 'inventory')">
                                Ajouter <i data-lucide="plus-circle" style="width:16px;height:16px;"></i>
                            </button>
                        </div>
                    </div>
                    
                    <!-- Autres -->
                    <div class="character-section" id="section-autres">
                        <div class="character-section-header" onclick="toggleCharacterSection('autres')">
                            <div class="character-section-title">Autres</div>
                            <span class="character-section-toggle"><i data-lucide="chevron-down" style="width:18px;height:18px;"></i></span>
                        </div>
                        <div class="character-section-content">
                            <div class="character-field">
                                <textarea rows="5" placeholder="Notes diverses..." 
                                          onchange="updateCharacterField(${character.id}, 'notes', this.value)">${character.notes || ''}</textarea>
                            </div>
                        </div>
                    </div>
                    
                    
                    
                    
                    
                    </div><!-- Fin de character-sections-grid -->
                    

                </div>
            `;
        }
        
        function renderInventoryItem(charId, listType, item, index) {
            return `
                <div class="inventory-item" data-index="${index}">
                    <button class="inventory-item-delete" onclick="removeInventoryItem(${charId}, '${listType}', ${index})">
                        <i data-lucide="trash-2" style="width:14px;height:14px;"></i>
                    </button>
                    <div class="character-field-row">
                        <div class="character-field" style="flex: 2;">
                            <label class="character-field-label">Nom</label>
                            <input type="text" value="${item.name || ''}" 
                                   onchange="updateInventoryItem(${charId}, '${listType}', ${index}, 'name', this.value)">
                        </div>
                        <div class="character-field" style="max-width: 100px;">
                            <label class="character-field-label">Quantité</label>
                            <input type="number" value="${item.quantity || 1}" min="1"
                                   onchange="updateInventoryItem(${charId}, '${listType}', ${index}, 'quantity', parseInt(this.value))">
                        </div>
                    </div>
                    <div class="character-field">
                        <label class="character-field-label">Description</label>
                        <input type="text" value="${item.description || ''}" 
                               onchange="updateInventoryItem(${charId}, '${listType}', ${index}, 'description', this.value)">
                    </div>
                </div>
            `;
        }
        
        function toggleCharacterSection(sectionName) {
            const section = document.getElementById(`section-${sectionName}`);
            if (section) {
                section.classList.toggle('collapsed');
            }
        }
        
        function updateCharacterName(id, newName) {
            const character = project.characters.find(c => c.id === id);
            if (character) {
                const parts = newName.trim().split(' ');
                character.firstName = parts[0] || '';
                character.lastName = parts.slice(1).join(' ') || '';
                character.name = newName.trim();
                saveProject();
                renderCharactersList();
            }
        }
        
        function updateCharacterDisplayName(id) {
            const character = project.characters.find(c => c.id === id);
            if (character) {
                character.name = `${character.firstName || ''} ${character.lastName || ''}`.trim();
                saveProject();
                renderCharactersList();
            }
        }
        
        function handleTagInput(event, charId, field) {
            if (event.key === 'Enter' && event.target.value.trim()) {
                event.preventDefault();
                const character = project.characters.find(c => c.id === charId);
                if (character) {
                    if (!character[field]) character[field] = [];
                    character[field].push(event.target.value.trim());
                    event.target.value = '';
                    saveProject();
                    // Refresh tags display
                    const container = document.getElementById(`${field}-${charId}`);
                    if (container) {
                        const input = container.querySelector('input');
                        container.innerHTML = character[field].map((tag, i) => `
                            <span class="character-tag">${tag}<span class="character-tag-remove" onclick="removeCharacterTag(${charId}, '${field}', ${i})">×</span></span>
                        `).join('') + `<input type="text" class="character-tags-input" placeholder="Ajouter..." onkeydown="handleTagInput(event, ${charId}, '${field}')">`;
                    }
                }
            }
        }
        
        function removeCharacterTag(charId, field, index) {
            const character = project.characters.find(c => c.id === charId);
            if (character && character[field]) {
                character[field].splice(index, 1);
                saveProject();
                openCharacterDetail(charId);
            }
        }
        
        // Système de traits de caractère
        const TRAIT_SECTIONS = {
            'emotional': {
                icon: 'brain-circuit', // Aspect Émotionnel
                label: 'Aspect Émotionnel',
                categories: {
                    'adversity': { icon: 'shield-half', label: 'Réaction face à l\'adversité', traits: ['Résilient', 'Fragile', 'Agressif', 'Évasif', 'Persévérant', 'Courageux'] },
                    'information': { icon: 'brain', label: 'Traitement de l\'information', traits: ['Analytique', 'Intuitif', 'Réfléchi', 'Impulsif', 'Distrait'] },
                    'emotions': { icon: 'heart', label: 'Gestion des émotions', traits: ['Expressif', 'Réservé', 'Explosif', 'Équilibré', 'Empathique', 'Apathique', 'Passionné', 'Téméraire'] },
                    'motivations': { icon: 'target', label: 'Motivations principales', traits: ['Ambition', 'Curiosité', 'Besoin de sécurité', 'Besoin d\'approbation', 'Quête de sens'] },
                    'social': { icon: 'user-check', label: 'Interactions sociales', traits: ['Leader', 'Suiveur', 'Confiant', 'Timide', 'Solitaire', 'Mystérieux', 'Médiateur', 'Manipulateur', 'Pédagogue'] },
                    'change': { icon: 'repeat-2', label: 'Gestion du changement', traits: ['Adaptatif', 'Résistant', 'Enthousiaste', 'Craintif', 'Indécis'] },
                    'self': { icon: 'eye', label: 'Vision de soi', traits: ['Confiant', 'Insécure', 'Narcissique', 'Humble', 'Critique'] },
                    'intimacy': { icon: 'heart-handshake', label: 'Rapport à l\'intimité', traits: ['Prude', 'Pudique', 'Romantique', 'Discret', 'Réservé', 'Ouvert', 'Extraverti'] },
                    'sexuality': { icon: 'flame', label: 'Rapport à la sexualité', traits: ['Sensuel', 'Chaste', 'Timide', 'Décomplexé', 'Romantique', 'Passionné', 'Libertin', 'Asexuel'] },
                    'pain': { icon: 'bandage', label: 'Rapport à la douleur', traits: ['Sadique', 'Masochiste', 'Stoïque', 'Sensible', 'Endurant', 'Douillet', 'Vulnérable'] },
                    'time': { icon: 'clock', label: 'Rapport au temps', traits: ['Nostalgique', 'Tourné vers l\'avenir', 'Carpe Diem', 'Cynique', 'Patient', 'Impatient'] }
                }
            },
            'evolution': {
                icon: 'trending-up', // Évolution Personnelle
                label: 'Évolution Personnelle',
                categories: {
                    'initial': { icon: 'sparkles', label: 'État initial', traits: ['Innocent', 'Naïf', 'Ferme dans ses convictions', 'Curieux', 'Méfiant', 'Mystérieux', 'Téméraire'] },
                    'learning': { icon: 'book-open', label: 'Approche face à l\'apprentissage', traits: ['Autodidacte', 'Chercheur de mentors', 'Expérimentateur', 'Sceptique', 'Réfractaire au changement'] },
                    'failure': { icon: 'alert-triangle', label: 'Gestion des échecs', traits: ['Persévérant', 'Résilient', 'Facilement découragé', 'Fuyant', 'Auto-compassion', 'Revanchard', 'Défaitiste'] },
                    'quest': { icon: 'compass', label: 'Quête personnelle', traits: ['Chercheur d\'identité', 'Chercheur de vérité', 'Chercheur de sensations', 'Chercheur d\'équilibre', 'Chercheur de pouvoir'] },
                    'adaptability': { icon: 'shuffle', label: 'Adaptabilité à l\'évolution', traits: ['Flexible', 'Rigide', 'Conservateur', 'Caméléon'] },
                    'world': { icon: 'globe', label: 'Interaction avec le monde', traits: ['Explorateur', 'Protecteur', 'Observateur', 'Pionnier', 'Réformateur'] },
                    'relationships': { icon: 'user-heart', label: 'Gestion des relations', traits: ['Loyal', 'Solidaire', 'Indépendant', 'Codépendant'] },
                    'death': { icon: 'skull', label: 'Rapport à la mort', traits: ['Stoïque', 'Anxieux', 'Fataliste', 'Spirituel', 'Déni'] }
                }
            },
            'daily': {
                icon: 'home', // Au Quotidien
                label: 'Au Quotidien',
                categories: {
                    'order': { icon: 'list-checks', label: 'Organisation et ordre', traits: ['Désordonné', 'Méticuleux', 'Négligent', 'Soigneux'] },
                    'appearance': { icon: 'shirt', label: 'Apparence et style', traits: ['Coquet', 'Négligé', 'Élégant', 'Décontracté', 'Mystérieux', 'Inspirant'] },
                    'physical': { icon: 'dumbbell', label: 'Habileté physique', traits: ['Adroit', 'Maladroit', 'Agile', 'Fort', 'Fragile', 'Précis', 'Souple'] },
                    'timeManagement': { icon: 'timer', label: 'Gestion du temps', traits: ['Ponctuel', 'Retardataire', 'Organisé', 'Procrastinateur'] }
                }
            },
            'others': {
                icon: 'users', // Rapport aux Autres
                label: 'Rapport aux Autres',
                categories: {
                    'norms': { icon: 'ban', label: 'Réponse aux normes culturelles', traits: ['Conformiste', 'Rebelle', 'Innovateur', 'Traditionaliste', 'Indifférent'] },
                    'group': { icon: 'group', label: 'Rapport au groupe', traits: ['Leader', 'Suiveur', 'Autoritaire', 'Solitaire', 'Médiateur', 'Esprit de contradiction'] },
                    'maturity': { icon: 'gem', label: 'Maturité émotionnelle', traits: ['Candide', 'Immature', 'Mature', 'Naïf', 'Sage'] },
                    'communication': { icon: 'message-square', label: 'Communication', traits: ['Expressif', 'Réservé', 'Enthousiaste', 'Observateur', 'Provocateur', 'Éloquent', 'Persuasif', 'À l\'écoute', 'Franc'] },
                    'diversity': { icon: 'dices', label: 'Réaction à la diversité', traits: ['Tolérant', 'Intolérant', 'Curieux', 'Ignorant', 'Ambivalent'] },
                    'pressure': { icon: 'gauge', label: 'Gestion de la pression sociale', traits: ['Influençable', 'Résistant', 'Indécis', 'Évitant'] },
                    'identity': { icon: 'user-circle', label: 'Quête d\'identité sociale', traits: ['Cherche l\'appartenance', 'Caméléon social', 'Loup solitaire', 'Conformiste', 'Cosmopolite'] },
                    'success': { icon: 'trophy', label: 'Vision de la réussite', traits: ['Ambitieux', 'Minimaliste', 'Opportuniste', 'Idéaliste', 'Pessimiste'] },
                    'institutions': { icon: 'gavel', label: 'Interactions avec les institutions', traits: ['Respectueux', 'Critique', 'Manipulateur', 'Défenseur', 'Détaché'] }
                }
            },
            'age': {
                icon: 'hourglass', // Personnalité selon l\'Âge
                label: 'Personnalité selon l\'Âge',
                categories: {
                    'childhood': { icon: 'baby', label: 'Enfance et adolescence', traits: ['Curieux', 'Rebelle', 'Suiveur', 'Protecteur', 'Rêveur'] },
                    'youngAdult': { icon: 'briefcase', label: 'Jeunes adultes', traits: ['Ambitieux', 'Aventurier', 'Stable', 'Introspectif', 'Social', 'Téméraire'] },
                    'midLife': { icon: 'building-2', label: 'Milieu de vie', traits: ['Responsable', 'Pédagogue', 'Entrepreneur', 'Nostalgique', 'Philanthrope', 'Mentor', 'Sage', 'Expérimenté', 'Accompli'] },
                    'mature': { icon: 'library', label: 'Âge mûr', traits: ['Sage', 'Conservateur', 'Libéré', 'Prudent', 'Gardien de la tradition'] },
                    'generations': { icon: 'tree-pine', label: 'Interactions entre générations', traits: ['Respectueux', 'Aime les défier', 'Guide', 'Élève', 'Indifférent'] }
                }
            },
            'moral': {
                icon: 'scale', // La Morale
                label: 'La Morale',
                categories: {
                    'virtues': { icon: 'check-circle', label: 'Vertus', traits: ['Courageux', 'Juste', 'Sage', 'Tempéré', 'Tolérant', 'Intègre', 'Honnête', 'Loyal', 'Compatissant', 'Bienveillant', 'Sincère', 'Désintéressé', 'Responsable'] },
                    'neutral': { icon: 'circle', label: 'Traits neutres', traits: ['Modéré', 'Prudent', 'Réfléchi', 'Objectif', 'Réaliste', 'Modeste', 'Patient'] },
                    'ambiguous': { icon: 'infinity', label: 'Ambiguïté morale', traits: ['Astucieux', 'Manipulateur', 'Séducteur', 'Rusé', 'Stratège', 'Entêté'] },
                    'minorVices': { icon: 'alert-circle', label: 'Vices mineurs', traits: ['Paresseux', 'Égoïste', 'Impulsif', 'Moqueur', 'Malhonnête', 'Hypocrite', 'Lâche', 'Cupide', 'Envieux'] },
                    'majorVices': { icon: 'skull', label: 'Vices majeurs', traits: ['Cruel', 'Tyrannique', 'Malveillant', 'Traître', 'Violent', 'Sadique'] },
                    'redemption': { icon: 'rotate-ccw', label: 'Traits rédempteurs', traits: ['Repentant', 'Humble', 'Reconnaissant', 'Miséricordieux', 'Compatissant'] },
                    'moralApproach': { icon: 'compass', label: 'Approche de la moralité', traits: ['Amoral', 'Nihiliste', 'Utilitariste', 'Paragon de vertu'] },
                    'values': { icon: 'diamond', label: 'Principes et valeurs', traits: ['Conformiste', 'Conventionnel', 'Éthique', 'Honnête', 'Idéaliste', 'Incorruptible', 'Intransigeant', 'Non-conformiste', 'Pragmatique', 'Rebelle', 'Respectueux', 'Révolutionnaire', 'Traditionnel', 'Transgressif'] }
                }
            },
            'past': {
                icon: 'history', // En Fonction du Passé
                label: 'En Fonction du Passé',
                categories: {
                    'privileged': { icon: 'crown', label: 'Enfance privilégiée', traits: ['Confiant', 'Naïf', 'Entreprenant', 'Éduqué'] },
                    'trauma': { icon: 'x-circle', label: 'Traumatismes passés', traits: ['Méfiant', 'Résilient', 'Tourmenté', 'Secret', 'Vigilant', 'Mystérieux'] },
                    'hardship': { icon: 'pickaxe', label: 'Enfance dans l\'adversité', traits: ['Combattif', 'Ingénieux', 'Méfiant', 'Endurci', 'Tenace'] },
                    'nomad': { icon: 'tent', label: 'Passé nomade', traits: ['S\'adapte facilement', 'Curieux', 'Indépendant', 'Nomade', 'Polyglotte'] },
                    'educated': { icon: 'microscope', label: 'Éducation formelle', traits: ['Analytique', 'Érudit', 'Précis', 'Structuré', 'Sceptique'] },
                    'artist': { icon: 'palette', label: 'Passé d\'artiste', traits: ['Imaginatif', 'Sensible', 'Non-conformiste', 'Passionné', 'Perfectionniste'] },
                    'delinquent': { icon: 'handcuffs', label: 'Ancien délinquant', traits: ['Rusé', 'Secret', 'Rebelle', 'Débrouillard', 'Insoumis'] },
                    'noble': { icon: 'castle', label: 'Origines nobles', traits: ['Digne', 'Autoritaire', 'Élitiste', 'Gracieux', 'Maniéré', 'Conservateur'] }
                }
            },
            'elements': {
                icon: 'leaf', // Éléments Naturels
                label: 'Éléments Naturels',
                categories: {
                    'earth': { icon: 'mountain', label: 'Terre', traits: ['Ancré', 'Résistant', 'Patient', 'Pratique', 'Loyal'] },
                    'water': { icon: 'water', label: 'Eau', traits: ['Sensible', 'Profond', 'Réfléchi', 'Adaptable', 'Empathique'] },
                    'fire': { icon: 'flame', label: 'Feu', traits: ['Enthousiaste', 'Colérique', 'Charismatique', 'Audacieux', 'Créatif', 'Impulsif'] },
                    'air': { icon: 'wind', label: 'Air', traits: ['Analytique', 'Expressif', 'Léger', 'Intuitif', 'Curieux'] },
                    'metal': { icon: 'hammer', label: 'Métal', traits: ['Organisé', 'Tenace', 'Réfléchi', 'Précis', 'Discipliné'] },
                    'wood': { icon: 'tree-pine', label: 'Bois', traits: ['Innovateur', 'Visionnaire', 'Ambitieux', 'Flexible', 'Énergique'] },
                    'space': { icon: 'satellite', label: 'Espace', traits: ['Indépendant', 'Mystérieux', 'Rêveur', 'Explorateur', 'Contemplatif'] },
                    'light': { icon: 'sun', label: 'Lumière', traits: ['Lumineux', 'Optimiste', 'Inspirant', 'Chaleureux', 'Rayonnant', 'Bienveillant', 'Leader'] }
                }
            }
        };
        
function renderTraitsCategories(charId, selectedTraits) {
            return Object.entries(TRAIT_SECTIONS).map(([sectionKey, section]) => `
                <div class="trait-section" id="trait-section-${sectionKey}">
                    <div class="trait-section-header" onclick="toggleTraitSection('${sectionKey}')">
                        <span>
                            <span class="trait-section-icon"><i data-lucide="${section.icon}" style="width:18px; height:18px; vertical-align: middle;"></i></span>
                            ${section.label}
                        </span>
                        <span class="trait-section-toggle">?</span>
                    </div>
                    <div class="trait-section-content">
                        ${Object.entries(section.categories).map(([catKey, category]) => `
                            <div class="trait-category" id="trait-cat-${sectionKey}-${catKey}">
                                <div class="trait-category-header">
                                    <span>
                                        <span class="trait-category-icon"><i data-lucide="${category.icon}" style="width:14px; height:14px; vertical-align: middle;"></i></span>
                                        ${category.label}
                                    </span>
                                </div>
                                <div class="trait-category-content">
                                    ${category.traits.map(trait => `
                                        <span class="trait-option ${selectedTraits.includes(trait) ? 'selected' : ''}" 
                                            onclick="event.stopPropagation(); toggleCharacterTrait(${charId}, '${trait.replace(/'/g, "\\'")}')">${trait}</span>
                                    `).join('')}
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `).join('');
        }
        
        function toggleTraitSection(sectionKey) {
            const section = document.getElementById(`trait-section-${sectionKey}`);
            if (section) {
                section.classList.toggle('collapsed');
            }
        }
        
        function toggleCharacterTrait(charId, trait) {
            const character = project.characters.find(c => c.id === charId);
            if (!character) return;
            
            if (!character.traits) character.traits = [];
            
            const index = character.traits.indexOf(trait);
            if (index > -1) {
                // Retirer le trait
                character.traits.splice(index, 1);
            } else {
                // Ajouter le trait
                character.traits.push(trait);
            }
            
            saveProject();
            refreshTraitsDisplay(charId);
        }
        
        function removeCharacterTrait(charId, index) {
            const character = project.characters.find(c => c.id === charId);
            if (!character || !character.traits) return;
            
            character.traits.splice(index, 1);
            saveProject();
            refreshTraitsDisplay(charId);
        }
        
        function refreshTraitsDisplay(charId) {
            const character = project.characters.find(c => c.id === charId);
            if (!character) return;
            
            const traits = character.traits || [];
            
            // Mettre à jour la zone des traits sélectionnés
            const selectedContainer = document.getElementById(`selectedTraits-${charId}`);
            if (selectedContainer) {
                selectedContainer.innerHTML = traits.length > 0 
                    ? traits.map((t, i) => `
                        <span class="selected-trait">${t}<span class="trait-remove" onclick="removeCharacterTrait(${charId}, ${i})">×</span></span>
                    `).join('')
                    : '<span class="no-traits">Cliquez sur les traits ci-dessous pour les ajouter</span>';
            }
            
            // Mettre à jour les options dans les catégories
            document.querySelectorAll('.trait-option').forEach(option => {
                const traitName = option.textContent;
                if (traits.includes(traitName)) {
                    option.classList.add('selected');
                } else {
                    option.classList.remove('selected');
                }
            });
        }
        
        function updatePersonalityStat(charId, stat, value) {
            const character = project.characters.find(c => c.id === charId);
            if (character && character.personality) {
                character.personality[stat] = parseInt(value);
                saveProject();
                // Update display
                const control = event.target.parentElement;
                const valueSpan = control.querySelector('.radar-value');
                if (valueSpan) valueSpan.textContent = value;
                // Redraw radar
                initCharacterRadar(character);
            }
        }
        
        function initCharacterRadar(character) {
            const canvas = document.getElementById(`radarChart-${character.id}`);
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = Math.min(centerX, centerY) - 50;
            
            const stats = character.personality;
            const labels = ['Intelligence', 'Force', 'Robustesse', 'Empathie', 'Perception', 'Agilité', 'Sociabilité'];
            const values = [stats.intelligence, stats.force, stats.robustesse, stats.empathie, stats.perception, stats.agilite, stats.sociabilite];
            const numPoints = labels.length;
            const angleStep = (Math.PI * 2) / numPoints;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid circles
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            for (let i = 1; i <= 4; i++) {
                ctx.beginPath();
                const gridRadius = (radius / 4) * i;
                for (let j = 0; j <= numPoints; j++) {
                    const angle = (angleStep * j) - Math.PI / 2;
                    const x = centerX + Math.cos(angle) * gridRadius;
                    const y = centerY + Math.sin(angle) * gridRadius;
                    if (j === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.stroke();
            }
            
            // Draw axes
            ctx.strokeStyle = '#ccc';
            for (let i = 0; i < numPoints; i++) {
                const angle = (angleStep * i) - Math.PI / 2;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(centerX + Math.cos(angle) * radius, centerY + Math.sin(angle) * radius);
                ctx.stroke();
            }
            
            // Draw data polygon
            ctx.fillStyle = 'rgba(100, 100, 120, 0.5)';
            ctx.strokeStyle = 'var(--primary-color)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let i = 0; i < numPoints; i++) {
                const angle = (angleStep * i) - Math.PI / 2;
                const value = values[i] / 20; // Normalize to 0-1
                const x = centerX + Math.cos(angle) * radius * value;
                const y = centerY + Math.sin(angle) * radius * value;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // Draw data points
            ctx.fillStyle = 'var(--primary-color)';
            for (let i = 0; i < numPoints; i++) {
                const angle = (angleStep * i) - Math.PI / 2;
                const value = values[i] / 20;
                const x = centerX + Math.cos(angle) * radius * value;
                const y = centerY + Math.sin(angle) * radius * value;
                ctx.beginPath();
                ctx.arc(x, y, 5, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Draw labels
            ctx.fillStyle = 'var(--text-secondary)';
            ctx.font = '12px "Crimson Pro", serif';
            ctx.textAlign = 'center';
            for (let i = 0; i < numPoints; i++) {
                const angle = (angleStep * i) - Math.PI / 2;
                const labelRadius = radius + 30;
                const x = centerX + Math.cos(angle) * labelRadius;
                const y = centerY + Math.sin(angle) * labelRadius;
                
                // Draw value in brackets
                const displayValue = values[i] === 20 ? '[MAX]' : `[${values[i]}]`;
                ctx.fillText(`${displayValue} ${labels[i]}`, x, y);
            }
            
            // Draw center cross
            ctx.strokeStyle = '#999';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(centerX - 5, centerY);
            ctx.lineTo(centerX + 5, centerY);
            ctx.moveTo(centerX, centerY - 5);
            ctx.lineTo(centerX, centerY + 5);
            ctx.stroke();
        }
        
        function addInventoryItem(charId, listType) {
            const character = project.characters.find(c => c.id === charId);
            if (character) {
                if (!character[listType]) character[listType] = [];
                character[listType].push({
                    id: Date.now(),
                    name: '',
                    quantity: 1,
                    description: ''
                });
                saveProject();
                // Mettre à jour seulement la liste sans re-rendre toute la fiche
                refreshInventoryList(charId, listType);
            }
        }
        
        function removeInventoryItem(charId, listType, index) {
            const character = project.characters.find(c => c.id === charId);
            if (character && character[listType]) {
                character[listType].splice(index, 1);
                saveProject();
                // Mettre à jour seulement la liste sans re-rendre toute la fiche
                refreshInventoryList(charId, listType);
            }
        }
        
        function refreshInventoryList(charId, listType) {
            const character = project.characters.find(c => c.id === charId);
            if (!character) return;
            
            const containerId = `inventory-list-${charId}`;
            const container = document.getElementById(containerId);
            if (!container) {
                // Fallback: re-rendre toute la fiche si le container n'existe pas
                openCharacterDetail(charId);
                return;
            }
            
            const items = character[listType] || [];
            
            container.innerHTML = items.map((item, index) => renderInventoryItem(charId, listType, item, index)).join('');
            
            // Rafraîchir les icônes Lucide
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }
        
        function updateInventoryItem(charId, listType, index, field, value) {
            const character = project.characters.find(c => c.id === charId);
            if (character && character[listType] && character[listType][index]) {
                character[listType][index][field] = value;
                saveProject();
            }
        }
        
        function changeCharacterAvatar(charId) {
            const character = project.characters.find(c => c.id === charId);
            if (!character) return;
            
            const choice = prompt('Choisissez un emoji pour l\'avatar (ou collez une URL d\'image) :', character.avatarEmoji || '??');
            if (choice === null) return;
            
            if (choice.startsWith('http')) {
                character.avatarImage = choice;
                character.avatarEmoji = '';
            } else {
                character.avatarEmoji = choice || '??';
                character.avatarImage = '';
            }
            
            saveProject();
            openCharacterDetail(charId);
        }


// ========== 16.split-view.js ==========
        // ==========================================
        // SPLIT VIEW SYSTEM - New Architecture
        // ==========================================
        
        const viewLabels = {
            'editor': 'Structure',
            'characters': 'Personnages',
            'world': 'Univers',
            'notes': 'Notes',
            'codex': 'Codex',
            'stats': 'Statistiques',
            'analysis': 'Analyse',
            'versions': 'Snapshots',
            'todos': 'TODOs',
            'corkboard': 'Tableau',
            'mindmap': 'Mindmap',
            'plot': 'Intrigue',
            'relations': 'Relations',
            'map': 'Carte',
            'timelineviz': 'Timeline'
        };
        
        const viewIcons = {
            'editor': 'pen-line',
            'characters': 'users',
            'world': 'globe',
            'notes': 'sticky-note',
            'codex': 'book-open',
            'stats': 'bar-chart-3',
            'analysis': 'scan-search',
            'versions': 'history',
            'todos': 'check-square',
            'corkboard': 'layout-grid',
            'mindmap': 'git-branch',
            'plot': 'trending-up',
            'relations': 'link',
            'map': 'map',
            'timelineviz': 'clock'
        };
        
        function toggleSplitView() {
            if (splitViewActive) {
                closeSplitView();
            } else {
                activateSplitView();
            }
        }
        
        function activateSplitView() {
            splitViewActive = true;
            splitActivePanel = 'left';
            
            // Initialize left panel with current view state
            splitViewState.left.view = currentView || 'editor';
            if (currentSceneId) {
                splitViewState.left.sceneId = currentSceneId;
                splitViewState.left.actId = currentActId;
                splitViewState.left.chapterId = currentChapterId;
            }
            
            // Right panel starts empty or with a default
            if (!splitViewState.right.view) {
                splitViewState.right.view = null;
            }
            
            renderSplitView();
            updateSplitToggleButton();
            showNotification('Mode split activé - Cliquez sur un panneau pour le sélectionner');
        }
        
        function closeSplitView() {
            splitViewActive = false;
            
            // Find which panel has the editor and restore it as the main view
            let viewToRestore = 'editor';
            let sceneToRestore = null;
            
            if (splitViewState.left.view === 'editor') {
                viewToRestore = 'editor';
                sceneToRestore = splitViewState.left.sceneId;
                currentActId = splitViewState.left.actId;
                currentChapterId = splitViewState.left.chapterId;
            } else if (splitViewState.right.view === 'editor') {
                viewToRestore = 'editor';
                sceneToRestore = splitViewState.right.sceneId;
                currentActId = splitViewState.right.actId;
                currentChapterId = splitViewState.right.chapterId;
            } else {
                // No editor found, restore left panel view
                viewToRestore = splitViewState.left.view || 'editor';
            }
            
            currentView = viewToRestore;
            if (sceneToRestore) {
                currentSceneId = sceneToRestore;
            }
            
            // Reset split state
            splitViewState.right.view = null;
            
            // Restore normal view
            switchView(currentView);
            
            updateSplitToggleButton();
            saveSplitViewState();
            showNotification('Mode split désactivé');
        }
        
        function updateSplitToggleButton() {
            const btn = document.getElementById('splitModeToggle');
            if (btn) {
                if (splitViewActive) {
                    btn.classList.add('active');
                    btn.innerHTML = '<i data-lucide="columns-2" style="width:14px;height:14px;"></i> <span>Split actif</span>';
                } else {
                    btn.classList.remove('active');
                    btn.innerHTML = '<i data-lucide="columns-2" style="width:14px;height:14px;"></i> <span>Split</span>';
                }
                if (typeof lucide !== 'undefined') lucide.createIcons();
            }
        }
        
        function renderSplitView() {
            if (!splitViewActive) return;
            
            const editorView = document.getElementById('editorView');
            const ratio = splitViewState.ratio || 60;
            
            const leftLabel = splitViewState.left.view ? viewLabels[splitViewState.left.view] || 'Vue' : 'Vide';
            const rightLabel = splitViewState.right.view ? viewLabels[splitViewState.right.view] || 'Vue' : 'Vide';
            const leftIcon = splitViewState.left.view ? viewIcons[splitViewState.left.view] || 'file' : 'plus-circle';
            const rightIcon = splitViewState.right.view ? viewIcons[splitViewState.right.view] || 'file' : 'plus-circle';
            
            editorView.innerHTML = `
                <div class="split-view-container" id="splitViewContainer">
                    <div class="split-panel split-panel-left ${splitActivePanel === 'left' ? 'active' : ''}" 
                         id="splitPanelLeft" 
                         style="flex: ${ratio};"
                         onclick="setActiveSplitPanel('left')">
                        <div class="split-panel-header" onclick="openSplitViewSelector('left'); event.stopPropagation();">
                            <div class="split-panel-title" id="splitLeftTitle">
                                <i data-lucide="${leftIcon}" style="width:14px;height:14px;"></i>
                                <span>${leftLabel}</span>
                                <i data-lucide="chevron-down" style="width:12px;height:12px;opacity:0.5;margin-left:4px;"></i>
                            </div>
                            <div class="split-panel-actions" onclick="event.stopPropagation();">
                                <span class="split-panel-indicator ${splitActivePanel === 'left' ? 'active' : ''}" title="Panneau actif">●</span>
                            </div>
                        </div>
                        <div class="split-panel-content" id="splitLeftContent">
                            <!-- Content rendered by renderSplitPanelViewContent -->
                        </div>
                    </div>
                    
                    <div class="split-resizer horizontal" id="splitResizer" 
                         onmousedown="startSplitResize(event)"
                         ontouchstart="startSplitResize(event)"></div>
                    
                    <div class="split-panel split-panel-right ${splitActivePanel === 'right' ? 'active' : ''}" 
                         id="splitPanelRight" 
                         style="flex: ${100 - ratio};"
                         onclick="setActiveSplitPanel('right')">
                        <div class="split-panel-header" onclick="openSplitViewSelector('right'); event.stopPropagation();">
                            <div class="split-panel-title" id="splitRightTitle">
                                <i data-lucide="${rightIcon}" style="width:14px;height:14px;"></i>
                                <span>${rightLabel}</span>
                                <i data-lucide="chevron-down" style="width:12px;height:12px;opacity:0.5;margin-left:4px;"></i>
                            </div>
                            <div class="split-panel-actions" onclick="event.stopPropagation();">
                                <span class="split-panel-indicator ${splitActivePanel === 'right' ? 'active' : ''}" title="Panneau actif">●</span>
                                <button class="split-panel-btn" onclick="closeSplitView(); event.stopPropagation();" title="Fermer le split">
                                    <i data-lucide="x" style="width:12px;height:12px;"></i>
                                </button>
                            </div>
                        </div>
                        <div class="split-panel-content" id="splitRightContent">
                            <!-- Content rendered by renderSplitPanelViewContent -->
                        </div>
                    </div>
                </div>
            `;
            
            // Render content for both panels
            renderSplitPanelViewContent('left');
            renderSplitPanelViewContent('right');
            
            // Update sidebar for active panel
            updateSidebarForSplitPanel(splitActivePanel);
            
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }
        
        function setActiveSplitPanel(panel) {
            if (splitActivePanel === panel) return;
            
            splitActivePanel = panel;
            
            // Update visual indicators
            document.getElementById('splitPanelLeft')?.classList.toggle('active', panel === 'left');
            document.getElementById('splitPanelRight')?.classList.toggle('active', panel === 'right');
            
            // Update indicators
            document.querySelectorAll('.split-panel-indicator').forEach((el, index) => {
                el.classList.toggle('active', (index === 0 && panel === 'left') || (index === 1 && panel === 'right'));
            });
            
            // Update sidebar for this panel's view
            updateSidebarForSplitPanel(panel);
            
            // Update header nav to reflect active panel's view
            const activeView = panel === 'left' ? splitViewState.left.view : splitViewState.right.view;
            if (activeView) {
                document.querySelectorAll('[id^="header-tab-"]').forEach(btn => btn.classList.remove('active'));
                const headerBtn = document.getElementById(`header-tab-${activeView}`);
                if (headerBtn) headerBtn.classList.add('active');
            }
        }
        
        function updateSidebarForSplitPanel(panel) {
            const state = panel === 'left' ? splitViewState.left : splitViewState.right;
            const view = state.view;
            
            if (!view) return;
            
            // Map views to their sidebar lists
            const sidebarViews = {
                'editor': 'chaptersList',
                'characters': 'charactersList',
                'world': 'worldList',
                'notes': 'notesList',
                'codex': 'codexList',
                'arcs': 'arcsList',
                'mindmap': 'mindmapList',
                'timelineviz': 'timelineVizList'
            };
            
            // Views that don't use sidebar (full-screen views)
            const noSidebarViews = ['stats', 'analysis', 'versions', 'todos', 'timeline', 'corkboard', 'plot', 'relations', 'map'];
            
            // Labels for views without sidebar
            const viewLabelsNoSidebar = {
                'stats': 'Statistiques',
                'analysis': 'Analyse',
                'versions': 'Versions',
                'todos': 'TODOs',
                'timeline': 'Timeline',
                'corkboard': 'Tableau',
                'plot': 'Intrigue',
                'relations': 'Relations',
                'map': 'Carte'
            };
            
            // Hide all sidebar lists including noSidebarMessage
            const allLists = [
                'chaptersList', 'charactersList', 'worldList', 'timelineList', 
                'notesList', 'codexList', 'statsList', 'versionsList', 'analysisList',
                'todosList', 'corkboardList', 'mindmapList', 'plotList', 
                'relationsList', 'mapList', 'timelineVizList', 'noSidebarMessage'
            ];
            allLists.forEach(listId => {
                const el = document.getElementById(listId);
                if (el) el.style.display = 'none';
            });
            
            // Show the appropriate list and refresh its content
            if (sidebarViews[view]) {
                const listEl = document.getElementById(sidebarViews[view]);
                if (listEl) listEl.style.display = 'block';
                
                // Refresh the list content based on view
                switch(view) {
                    case 'editor':
                        renderActsList();
                        break;
                    case 'characters':
                        if (typeof renderCharactersList === 'function') renderCharactersList();
                        break;
                    case 'world':
                        if (typeof renderWorldList === 'function') renderWorldList();
                        break;
                    case 'notes':
                        if (typeof renderNotesList === 'function') renderNotesList();
                        break;
                    case 'codex':
                        if (typeof renderCodexList === 'function') renderCodexList();
                        break;
                    case 'mindmap':
                        if (typeof renderMindmapList === 'function') renderMindmapList();
                        break;
                    case 'timelineviz':
                        if (typeof renderTimelineVizList === 'function') renderTimelineVizList();
                        break;
                }
            } else if (noSidebarViews.includes(view)) {
                // Show message for views without sidebar
                const noSidebarEl = document.getElementById('noSidebarMessage');
                if (noSidebarEl) {
                    const viewLabel = viewLabelsNoSidebar[view] || 'Cette vue';
                    noSidebarEl.innerHTML = `
                        <div style="padding: 2rem 1rem; text-align: center; color: var(--text-muted);">
                            <i data-lucide="layout-dashboard" style="width: 48px; height: 48px; opacity: 0.3; margin-bottom: 1rem;"></i>
                            <div style="font-size: 0.9rem; line-height: 1.6;">
                                <strong>${viewLabel}</strong> utilise tout l'espace disponible.
                            </div>
                            <div style="font-size: 0.85rem; margin-top: 0.5rem; opacity: 0.8;">
                                La barre latérale n'est pas utilisée dans cette vue.
                            </div>
                        </div>
                    `;
                    noSidebarEl.style.display = 'block';
                    
                    // Refresh icons
                    setTimeout(() => {
                        if (typeof lucide !== 'undefined') lucide.createIcons();
                    }, 50);
                }
            }
            
            // Update sidebar actions
            const actionsHTML = {
                editor: '<button class="btn btn-primary" onclick="openAddActModal()">+ Acte</button><button class="btn btn-primary" onclick="openAddChapterModal()">+ Chapitre</button><button class="btn btn-primary" onclick="openAddSceneModalQuick()">+ Scène</button>',
                characters: '<button class="btn btn-primary" onclick="openAddCharacterModal()">+ Personnage</button>',
                world: '<button class="btn btn-primary" onclick="openAddWorldModal()">+ Élément</button>',
                notes: '<button class="btn btn-primary" onclick="openAddNoteModal()">+ Note</button>',
                codex: '<button class="btn btn-primary" onclick="openAddCodexModal()">+ Entrée</button>',
                arcs: '<button class="btn btn-primary" onclick="createNewArc()">+ Arc narratif</button>'
            };
            const sidebarActions = document.getElementById('sidebarActions');
            if (sidebarActions) {
                sidebarActions.innerHTML = actionsHTML[view] || '';
            }
            
            // Update structure-only elements visibility
            const structureOnlyElements = ['projectProgressBar', 'statusFilters', 'sceneTools'];
            structureOnlyElements.forEach(id => {
                const el = document.getElementById(id);
                if (el) el.style.display = (view === 'editor') ? '' : 'none';
            });
            
            // Update tree collapse toolbar visibility (for views with collapsible groups)
            const treeCollapseToolbar = document.getElementById('treeCollapseToolbar');
            const viewsWithGroups = ['editor', 'world', 'notes', 'codex'];
            if (treeCollapseToolbar) {
                treeCollapseToolbar.style.display = viewsWithGroups.includes(view) ? '' : 'none';
            }
            
            // Refresh Lucide icons
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }
        
        function switchSplitPanelView(panel, view) {
            const state = panel === 'left' ? splitViewState.left : splitViewState.right;
            state.view = view;
            
            // Reset specific IDs when changing view type
            state.sceneId = null;
            state.characterId = null;
            state.worldId = null;
            state.noteId = null;
            
            // If switching to editor view and we have a current scene, use it
            if (view === 'editor' && currentSceneId) {
                state.sceneId = currentSceneId;
                state.actId = currentActId;
                state.chapterId = currentChapterId;
            }
            
            // Re-render the panel content
            renderSplitPanelViewContent(panel);
            
            // Update panel header
            updateSplitPanelHeader(panel);
            
            // Update sidebar if this is the active panel
            if (splitActivePanel === panel) {
                updateSidebarForSplitPanel(panel);
                
                // Update header nav
                document.querySelectorAll('[id^="header-tab-"]').forEach(btn => btn.classList.remove('active'));
                const headerBtn = document.getElementById(`header-tab-${view}`);
                if (headerBtn) headerBtn.classList.add('active');
            }
            
            saveSplitViewState();
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }
        
        function updateSplitPanelHeader(panel) {
            const state = panel === 'left' ? splitViewState.left : splitViewState.right;
            const titleEl = document.getElementById(panel === 'left' ? 'splitLeftTitle' : 'splitRightTitle');
            
            if (titleEl) {
                const label = state.view ? viewLabels[state.view] || 'Vue' : 'Vide';
                const icon = state.view ? viewIcons[state.view] || 'file' : 'plus-circle';
                titleEl.innerHTML = `
                    <i data-lucide="${icon}" style="width:14px;height:14px;"></i>
                    <span>${label}</span>
                    <i data-lucide="chevron-down" style="width:12px;height:12px;opacity:0.5;margin-left:4px;"></i>
                `;
                if (typeof lucide !== 'undefined') lucide.createIcons();
            }
        }
        
        function renderSplitPanelViewContent(panel) {
            const container = document.getElementById(panel === 'left' ? 'splitLeftContent' : 'splitRightContent');
            if (!container) return;
            
            const state = panel === 'left' ? splitViewState.left : splitViewState.right;
            const view = state.view;
            
            if (!view) {
                container.innerHTML = `
                    <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; color: var(--text-muted); text-align: center; padding: 2rem;">
                        <i data-lucide="plus-circle" style="width:48px;height:48px;stroke-width:1;margin-bottom:1rem;opacity:0.5;"></i>
                        <div style="font-size: 1rem; margin-bottom: 0.5rem;">Panneau vide</div>
                        <div style="font-size: 0.85rem; margin-bottom: 1rem;">Cliquez sur l'en-tête pour choisir une vue</div>
                    </div>
                `;
                if (typeof lucide !== 'undefined') lucide.createIcons();
                return;
            }
            
            // Create a unique container ID for this panel's content
            const contentId = `split-${panel}-view-content`;
            container.innerHTML = `<div id="${contentId}" style="height: 100%; overflow: auto;"></div>`;
            
            const contentContainer = document.getElementById(contentId);
            
            // Render the view content into this container
            renderViewInSplitPanel(view, contentContainer, state, panel);
        }
        
        function renderViewInSplitPanel(view, container, state, panel) {
            // Technique: créer un faux editorView temporaire pour que les fonctions de rendu existantes fonctionnent
            const realEditorView = document.getElementById('editorView');
            
            // Créer un conteneur temporaire avec l'ID editorView
            const tempContainer = document.createElement('div');
            tempContainer.id = 'editorView';
            tempContainer.style.cssText = 'height: 100%; overflow: auto;';
            container.innerHTML = '';
            container.appendChild(tempContainer);
            
            // Temporairement masquer le vrai editorView et changer son ID
            if (realEditorView) {
                realEditorView.id = 'editorView-backup';
            }
            
            // Fonction pour restaurer après le rendu
            const restoreEditorView = () => {
                // Restaurer l'ID du vrai editorView
                if (realEditorView) {
                    realEditorView.id = 'editorView';
                }
                // Le tempContainer garde le contenu rendu mais perd son ID
                tempContainer.id = 'splitPanelContent-' + panel;
            };
            
            switch(view) {
                case 'editor':
                    if (state.sceneId) {
                        const act = project.acts.find(a => a.id === state.actId);
                        const chapter = act?.chapters.find(c => c.id === state.chapterId);
                        const scene = chapter?.scenes.find(s => s.id === state.sceneId);
                        if (act && chapter && scene) {
                            renderEditorInContainer(act, chapter, scene, container, panel);
                            restoreEditorView();
                            return; // On sort car renderEditorInContainer gère tout
                        }
                    } else {
                        tempContainer.innerHTML = `
                            <div class="empty-state">
                                <div class="empty-state-icon">✍️</div>
                                <div class="empty-state-title">Sélectionnez une scène</div>
                                <div class="empty-state-text">Choisissez une scène dans la barre latérale</div>
                            </div>
                        `;
                    }
                    break;
                    
                case 'characters':
                    if (state.characterId) {
                        const char = project.characters.find(c => c.id === state.characterId);
                        if (char) {
                            migrateCharacterData(char);
                            tempContainer.innerHTML = renderCharacterSheet(char, false);
                            setTimeout(() => {
                                initCharacterRadar(char);
                                if (typeof lucide !== 'undefined') lucide.createIcons();
                            }, 100);
                        }
                    } else {
                        tempContainer.innerHTML = `
                            <div class="empty-state">
                                <div class="empty-state-icon"><i data-lucide="users" style="width:48px;height:48px;stroke-width:1.5;"></i></div>
                                <div class="empty-state-title">Personnages</div>
                                <div class="empty-state-text">Sélectionnez un personnage dans la barre latérale</div>
                            </div>
                        `;
                    }
                    break;
                    
                case 'world':
                    if (state.worldId) {
                        const elem = project.world?.find(e => e.id === state.worldId);
                        if (elem) {
                            // Appeler la vraie fonction openWorldDetail via le faux editorView
                            if (typeof renderWorldDetailFull === 'function') {
                                renderWorldDetailFull(elem, tempContainer);
                            } else {
                                // Générer le même HTML que openWorldDetail
                                tempContainer.innerHTML = `
                                    <div class="detail-view">
                                        <div class="detail-header">
                                            <div style="display: flex; align-items: center; gap: 1rem;">
                                                <div class="detail-title">${elem.name}</div>
                                                <span style="font-size: 0.9rem; padding: 0.5rem 1rem; background: var(--accent-gold); color: var(--bg-primary); border-radius: 2px;">${elem.type}</span>
                                            </div>
                                        </div>
                                        
                                        ${typeof renderElementLinkedScenes === 'function' ? renderElementLinkedScenes(elem) : ''}
                                        
                                        <div class="detail-section">
                                            <div class="detail-section-title">Informations de base</div>
                                            <div class="detail-field">
                                                <div class="detail-label">Nom</div>
                                                <input type="text" class="form-input" value="${elem.name}" 
                                                       onchange="updateWorldField(${elem.id}, 'name', this.value)">
                                            </div>
                                        </div>

                                        <div class="detail-section">
                                            <div class="detail-section-title">Type</div>
                                            <select class="form-input" onchange="updateWorldField(${elem.id}, 'type', this.value)">
                                                <option value="Lieu" ${elem.type === 'Lieu' ? 'selected' : ''}>Lieu</option>
                                                <option value="Objet" ${elem.type === 'Objet' ? 'selected' : ''}>Objet</option>
                                                <option value="Concept" ${elem.type === 'Concept' ? 'selected' : ''}>Concept</option>
                                                <option value="Organisation" ${elem.type === 'Organisation' ? 'selected' : ''}>Organisation</option>
                                                <option value="Événement" ${elem.type === 'Événement' ? 'selected' : ''}>Événement</option>
                                            </select>
                                        </div>

                                        <div class="detail-section">
                                            <div class="detail-section-title">Description</div>
                                            <textarea class="form-input" rows="6" 
                                                      onchange="updateWorldField(${elem.id}, 'description', this.value)">${elem.description || ''}</textarea>
                                        </div>

                                        <div class="detail-section">
                                            <div class="detail-section-title">Détails</div>
                                            <textarea class="form-input" rows="6" 
                                                      onchange="updateWorldField(${elem.id}, 'details', this.value)">${elem.details || ''}</textarea>
                                        </div>

                                        <div class="detail-section">
                                            <div class="detail-section-title">Histoire</div>
                                            <textarea class="form-input" rows="6" 
                                                      onchange="updateWorldField(${elem.id}, 'history', this.value)">${elem.history || ''}</textarea>
                                        </div>

                                        <div class="detail-section">
                                            <div class="detail-section-title">Notes</div>
                                            <textarea class="form-input" rows="4" 
                                                      onchange="updateWorldField(${elem.id}, 'notes', this.value)">${elem.notes || ''}</textarea>
                                        </div>
                                    </div>
                                `;
                            }
                        }
                    } else {
                        tempContainer.innerHTML = `
                            <div class="empty-state">
                                <div class="empty-state-icon"><i data-lucide="globe" style="width:48px;height:48px;stroke-width:1.5;"></i></div>
                                <div class="empty-state-title">Univers</div>
                                <div class="empty-state-text">Sélectionnez un élément dans la barre latérale</div>
                            </div>
                        `;
                    }
                    break;
                    
                case 'notes':
                    if (state.noteId) {
                        const note = project.notes?.find(n => n.id === state.noteId);
                        if (note) {
                            // Même HTML que openNoteDetail
                            tempContainer.innerHTML = `
                                <div class="detail-view">
                                    <div class="detail-header">
                                        <div style="display: flex; align-items: center; gap: 1rem; flex: 1;">
                                            <input type="text" class="form-input" value="${note.title || ''}" 
                                                   style="font-size: 1.8rem; font-weight: 600; font-family: 'Noto Serif JP', serif; padding: 0.5rem;"
                                                   onchange="updateNoteField(${note.id}, 'title', this.value)"
                                                   placeholder="Titre de la note">
                                            <span style="font-size: 0.8rem; padding: 0.4rem 0.8rem; background: var(--accent-gold); color: var(--bg-primary); border-radius: 2px;">${note.category || 'Note'}</span>
                                        </div>
                                    </div>
                                    
                                    <div class="detail-section">
                                        <div class="detail-section-title">Catégorie</div>
                                        <select class="form-input" onchange="updateNoteField(${note.id}, 'category', this.value)">
                                            <option value="Recherche" ${note.category === 'Recherche' ? 'selected' : ''}>Recherche</option>
                                            <option value="Idée" ${note.category === 'Idée' ? 'selected' : ''}>Idée</option>
                                            <option value="Référence" ${note.category === 'Référence' ? 'selected' : ''}>Référence</option>
                                            <option value="A faire" ${note.category === 'A faire' ? 'selected' : ''}>À faire</option>
                                            <option value="Question" ${note.category === 'Question' ? 'selected' : ''}>Question</option>
                                            <option value="Autre" ${note.category === 'Autre' ? 'selected' : ''}>Autre</option>
                                        </select>
                                    </div>

                                    <div class="detail-section">
                                        <div class="detail-section-title">Tags</div>
                                        <input type="text" class="form-input" value="${(note.tags || []).join(', ')}" 
                                               onchange="updateNoteTags(${note.id}, this.value)">
                                        <small style="color: var(--text-muted); font-style: italic;">Séparez les tags par des virgules</small>
                                    </div>

                                    <div class="detail-section">
                                        <div class="detail-section-title">Contenu</div>
                                        <textarea class="form-input" rows="20" 
                                                  oninput="updateNoteField(${note.id}, 'content', this.value)">${note.content || ''}</textarea>
                                    </div>

                                    <div style="font-size: 0.8rem; color: var(--text-muted); margin-top: 2rem; font-family: 'Source Code Pro', monospace;">
                                        Créée le ${new Date(note.createdAt).toLocaleDateString('fr-FR')} • 
                                        Modifiée le ${new Date(note.updatedAt).toLocaleDateString('fr-FR')}
                                    </div>
                                </div>
                            `;
                        }
                    } else {
                        tempContainer.innerHTML = `
                            <div class="empty-state">
                                <div class="empty-state-icon"><i data-lucide="sticky-note" style="width:48px;height:48px;stroke-width:1.5;"></i></div>
                                <div class="empty-state-title">Notes</div>
                                <div class="empty-state-text">Sélectionnez une note dans la barre latérale</div>
                            </div>
                        `;
                    }
                    break;
                    
                case 'mindmap':
                    // Appeler la vraie fonction renderMindmapView
                    if (typeof renderMindmapView === 'function') {
                        renderMindmapView();
                    }
                    break;
                    
                case 'corkboard':
                    // Call real render function
                    if (typeof openCorkBoardView === 'function') {
                        openCorkBoardView();
                    }
                    break;
                    
                case 'stats':
                    // Call real render function
                    if (typeof renderStats === 'function') {
                        renderStats();
                    }
                    break;
                    
                case 'analysis':
                    // Call real render function
                    if (typeof renderAnalysis === 'function') {
                        renderAnalysis();
                    }
                    break;
                    
                case 'map':
                    // Call real render function
                    if (typeof renderMapView === 'function') {
                        renderMapView();
                    }
                    break;
                    
                case 'codex':
                    if (state.codexId) {
                        // Render specific codex entry directly in the container
                        const entry = project.codex?.find(c => c.id === state.codexId);
                        if (entry) {
                            tempContainer.innerHTML = `
                                <div class="detail-view">
                                    <div class="detail-header">
                                        <div style="display: flex; align-items: center; gap: 1rem; flex: 1;">
                                            <input type="text" class="form-input" value="${entry.title}" 
                                                   style="font-size: 1.8rem; font-weight: 600; font-family: 'Noto Serif JP', serif; padding: 0.5rem;"
                                                   onchange="updateCodexField(${entry.id}, 'title', this.value)"
                                                   placeholder="Titre de l'entrée">
                                            <span style="font-size: 0.8rem; padding: 0.4rem 0.8rem; background: var(--accent-gold); color: var(--bg-primary); border-radius: 2px;">${entry.category}</span>
                                        </div>
                                    </div>
                                    
                                    <div class="detail-section">
                                        <div class="detail-section-title">Catégorie</div>
                                        <select class="form-input" onchange="updateCodexField(${entry.id}, 'category', this.value)">
                                            <option value="Culture" ${entry.category === 'Culture' ? 'selected' : ''}>Culture</option>
                                            <option value="Histoire" ${entry.category === 'Histoire' ? 'selected' : ''}>Histoire</option>
                                            <option value="Technologie" ${entry.category === 'Technologie' ? 'selected' : ''}>Technologie</option>
                                            <option value="Géographie" ${entry.category === 'Géographie' ? 'selected' : ''}>Géographie</option>
                                            <option value="Politique" ${entry.category === 'Politique' ? 'selected' : ''}>Politique</option>
                                            <option value="Magie/Pouvoir" ${entry.category === 'Magie/Pouvoir' ? 'selected' : ''}>Magie/Pouvoir</option>
                                            <option value="Religion" ${entry.category === 'Religion' ? 'selected' : ''}>Religion</option>
                                            <option value="Société" ${entry.category === 'Société' ? 'selected' : ''}>Société</option>
                                            <option value="Autre" ${entry.category === 'Autre' ? 'selected' : ''}>Autre</option>
                                        </select>
                                    </div>

                                    <div class="detail-section">
                                        <div class="detail-section-title">Résumé</div>
                                        <textarea class="form-input" rows="3" 
                                                  onchange="updateCodexField(${entry.id}, 'summary', this.value)">${entry.summary || ''}</textarea>
                                    </div>

                                    <div class="detail-section">
                                        <div class="detail-section-title">Contenu détaillé</div>
                                        <textarea class="form-input" rows="20" 
                                                  oninput="updateCodexField(${entry.id}, 'content', this.value)">${entry.content || ''}</textarea>
                                    </div>
                                </div>
                            `;
                        }
                    } else {
                        tempContainer.innerHTML = `
                            <div class="empty-state">
                                <div class="empty-state-icon"><i data-lucide="book-open" style="width:48px;height:48px;stroke-width:1.5;"></i></div>
                                <div class="empty-state-title">Codex</div>
                                <div class="empty-state-text">Sélectionnez une entrée dans la barre latérale</div>
                            </div>
                        `;
                    }
                    break;
                
                case 'plot':
                    // Call real render function
                    if (typeof renderPlotView === 'function') {
                        renderPlotView();
                    }
                    break;
                    
                case 'relations':
                    // Call real render function
                    if (typeof renderRelationsView === 'function') {
                        renderRelationsView();
                    }
                    break;
                    
                case 'timelineviz':
                    // Render timeline metro in split panel (without sidebar, just the main content)
                    const charCount = project.characters?.length || 0;
                    
                    if (charCount === 0) {
                        tempContainer.innerHTML = `
                            <div class="metro-empty-state">
                                <i data-lucide="users" style="width: 64px; height: 64px; opacity: 0.3;"></i>
                                <h3 style="margin: 1rem 0 0.5rem;">Aucun personnage</h3>
                                <p style="margin-bottom: 1.5rem;">Créez d'abord des personnages dans l'onglet "Personnages".</p>
                            </div>
                        `;
                    } else {
                        tempContainer.innerHTML = `
                            <div style="padding: 1rem; height: 100%; overflow: auto;">
                                <div class="metro-toolbar" style="margin-bottom: 1rem;">
                                    <button class="btn btn-primary" onclick="openMetroEventModal()">
                                        <i data-lucide="plus" style="width: 16px; height: 16px;"></i>
                                        Nouvel événement
                                    </button>
                                    <button class="btn" onclick="sortMetroByDate()">
                                        <i data-lucide="calendar" style="width: 16px; height: 16px;"></i>
                                        Trier par date
                                    </button>
                                </div>
                                
                                <div class="metro-timeline-container" id="metroTimelineContainer-split-${panel}">
                                    ${renderMetroSVG()}
                                </div>
                                
                                <div class="metro-legend" style="margin-top: 1rem;">
                                    ${project.characters.map(char => `
                                        <div class="metro-legend-item" onclick="openMetroColorPicker(${char.id})" style="cursor: pointer;" title="Cliquer pour changer la couleur">
                                            <div class="metro-legend-line" style="background: ${project.characterColors[char.id] || '#999'};"></div>
                                            <span>${char.name}</span>
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                        `;
                    }
                    break;
                    
                case 'versions':
                    // Call real render function
                    if (typeof renderVersionsList === 'function') {
                        renderVersionsList();
                    }
                    break;
                    
                case 'todos':
                    // Call real render function
                    if (typeof renderTodosList === 'function') {
                        renderTodosList();
                    }
                    break;
                    
                case 'timeline':
                    // Call real render function
                    if (typeof renderTimelineList === 'function') {
                        renderTimelineList();
                    }
                    break;
                    
                default:
                    tempContainer.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-state-icon"><i data-lucide="${viewIcons[view] || 'file'}" style="width:48px;height:48px;stroke-width:1.5;"></i></div>
                            <div class="empty-state-title">${viewLabels[view] || view}</div>
                            <div class="empty-state-text">Cette vue est disponible</div>
                        </div>
                    `;
            }
            
            // Restaurer l'ID du vrai editorView
            restoreEditorView();
            
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }
        
        // Render the full editor with toolbar in a container (for split view)
        function renderEditorInContainer(act, chapter, scene, container, panel) {
            const wordCount = getWordCount(scene.content || '');
            
            // Vérifier si une version finale existe
            const hasFinalVersion = scene.versions && scene.versions.some(v => v.isFinal === true);
            const finalVersion = hasFinalVersion ? scene.versions.find(v => v.isFinal === true) : null;
            const finalVersionBadge = hasFinalVersion 
                ? `<span style="display: inline-flex; align-items: center; gap: 0.25rem; background: var(--accent-gold); color: var(--bg-accent); font-size: 0.7rem; font-weight: 600; padding: 0.2rem 0.5rem; border-radius: 10px; margin-left: 0.5rem;" title="Version finale : ${finalVersion.number}">⭐ ${finalVersion.number}</span>`
                : '';
            
            container.innerHTML = `
                <div class="editor-fixed-top" style="position: relative;">
                    <div class="editor-header">
                        <div class="editor-breadcrumb">${act.title} > ${chapter.title}</div>
                        <div style="display: flex; align-items: center; gap: 1rem;">
                            <div class="editor-title" style="flex: 1;">${scene.title}${finalVersionBadge}</div>
                        </div>
                        <div class="editor-meta">
                            <span class="split-word-count-${panel}">${wordCount} mots</span>
                            <span>Dernière modification : ${new Date().toLocaleDateString('fr-FR')}</span>
                        </div>
                    </div>
                    <button class="toolbar-mobile-toggle" onclick="toggleSplitEditorToolbar('${panel}')">
                        <span><i data-lucide="pen-line" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Outils de formatage</span>
                    </button>
                    <div class="editor-toolbar" id="editorToolbar-${panel}">
                        <!-- Basic formatting -->
                        <div class="toolbar-group">
                            <button class="toolbar-btn" onclick="formatTextInPanel('${panel}', 'bold')" title="Gras (Ctrl+B)">
                                <strong>B</strong>
                            </button>
                            <button class="toolbar-btn" onclick="formatTextInPanel('${panel}', 'italic')" title="Italique (Ctrl+I)">
                                <em>I</em>
                            </button>
                            <button class="toolbar-btn" onclick="formatTextInPanel('${panel}', 'underline')" title="Souligné (Ctrl+U)">
                                <u>U</u>
                            </button>
                            <button class="toolbar-btn" onclick="formatTextInPanel('${panel}', 'strikeThrough')" title="Barré">
                                <s>S</s>
                            </button>
                        </div>
                        
                        <!-- Font family and size -->
                        <div class="toolbar-group">
                            <select class="font-family-selector" onchange="formatTextInPanel('${panel}', 'fontName', this.value)" title="Police de caractères">
                                <option value="Crimson Pro">Crimson Pro</option>
                                <option value="Arial">Arial</option>
                                <option value="Georgia">Georgia</option>
                                <option value="Times New Roman">Times New Roman</option>
                                <option value="Courier New">Courier New</option>
                                <option value="Verdana">Verdana</option>
                                <option value="Garamond">Garamond</option>
                                <option value="Palatino">Palatino</option>
                            </select>
                            <select class="font-size-selector" onchange="formatTextInPanel('${panel}', 'fontSize', this.value)" title="Taille de police">
                                <option value="1">Très petit</option>
                                <option value="2">Petit</option>
                                <option value="3" selected>Normal</option>
                                <option value="4">Grand</option>
                                <option value="5">Très grand</option>
                                <option value="6">Énorme</option>
                                <option value="7">Gigantesque</option>
                            </select>
                        </div>
                        
                        <!-- Alignment -->
                        <div class="toolbar-group">
                            <button class="toolbar-btn" onclick="formatTextInPanel('${panel}', 'justifyLeft')" title="Aligner à gauche">
                                ⫷
                            </button>
                            <button class="toolbar-btn" onclick="formatTextInPanel('${panel}', 'justifyCenter')" title="Centrer">
                                ⫶
                            </button>
                            <button class="toolbar-btn" onclick="formatTextInPanel('${panel}', 'justifyRight')" title="Aligner à droite">
                                ⫸
                            </button>
                            <button class="toolbar-btn" onclick="formatTextInPanel('${panel}', 'justifyFull')" title="Justifier">
                                ☰
                            </button>
                        </div>
                        
                        <!-- Headings -->
                        <div class="toolbar-group">
                            <button class="toolbar-btn" onclick="formatTextInPanel('${panel}', 'formatBlock', 'h1')" title="Titre 1">H1</button>
                            <button class="toolbar-btn" onclick="formatTextInPanel('${panel}', 'formatBlock', 'h2')" title="Titre 2">H2</button>
                            <button class="toolbar-btn" onclick="formatTextInPanel('${panel}', 'formatBlock', 'h3')" title="Titre 3">H3</button>
                            <button class="toolbar-btn" onclick="formatTextInPanel('${panel}', 'formatBlock', 'p')" title="Paragraphe">P</button>
                        </div>
                        
                        <!-- Lists and quotes -->
                        <div class="toolbar-group">
                            <button class="toolbar-btn" onclick="formatTextInPanel('${panel}', 'insertUnorderedList')" title="Liste à puces">• Liste</button>
                            <button class="toolbar-btn" onclick="formatTextInPanel('${panel}', 'insertOrderedList')" title="Liste numérotée">1. Liste</button>
                            <button class="toolbar-btn" onclick="formatTextInPanel('${panel}', 'formatBlock', 'blockquote')" title="Citation">❝ Citation</button>
                        </div>
                        
                        <!-- Indentation -->
                        <div class="toolbar-group">
                            <button class="toolbar-btn" onclick="formatTextInPanel('${panel}', 'indent')" title="Augmenter l'indentation">→|</button>
                            <button class="toolbar-btn" onclick="formatTextInPanel('${panel}', 'outdent')" title="Diminuer l'indentation">|←</button>
                        </div>
                        
                        <!-- Superscript, subscript -->
                        <div class="toolbar-group">
                            <button class="toolbar-btn" onclick="formatTextInPanel('${panel}', 'superscript')" title="Exposant">x²</button>
                            <button class="toolbar-btn" onclick="formatTextInPanel('${panel}', 'subscript')" title="Indice">x₂</button>
                        </div>
                        
                        <!-- Other -->
                        <div class="toolbar-group">
                            <button class="toolbar-btn" onclick="formatTextInPanel('${panel}', 'insertHorizontalRule')" title="Ligne horizontale">─</button>
                            <button class="toolbar-btn" onclick="formatTextInPanel('${panel}', 'removeFormat')" title="Supprimer le formatage">✕ Format</button>
                        </div>
                    </div>
                    <div class="links-panel-sticky" id="linksPanel-${panel}">
                        <div style="display: flex; gap: 2rem; align-items: start;">
                            <div style="flex: 1;">
                                <div style="font-size: 0.85rem; font-weight: 600; margin-bottom: 0.5rem; color: var(--text-muted);"><i data-lucide="users" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Personnages</div>
                                <div class="quick-links">
                                    ${renderSceneCharacters(act.id, chapter.id, scene)}
                                    <button class="btn btn-small" onclick="openCharacterLinker(${act.id}, ${chapter.id}, ${scene.id})" style="font-size: 0.75rem; padding: 0.3rem 0.6rem;">+ Lier</button>
                                </div>
                            </div>
                            <div style="flex: 1;">
                                <div style="font-size: 0.85rem; font-weight: 600; margin-bottom: 0.5rem; color: var(--text-muted);"><i data-lucide="globe" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Lieux/Éléments</div>
                                <div class="quick-links">
                                    ${renderSceneElements(act.id, chapter.id, scene)}
                                    <button class="btn btn-small" onclick="openElementLinker(${act.id}, ${chapter.id}, ${scene.id})" style="font-size: 0.75rem; padding: 0.3rem 0.6rem;">+ Lier</button>
                                </div>
                            </div>
                            <div style="flex: 1;">
                                <div style="font-size: 0.85rem; font-weight: 600; margin-bottom: 0.5rem; color: var(--text-muted);"><i data-lucide="train-track" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Timeline</div>
                                <div class="quick-links">
                                    ${renderSceneMetroEvents(scene.id)}
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="editor-workspace">
                    <div class="editor-content">
                        <div 
                            class="editor-textarea" 
                            contenteditable="true"
                            spellcheck="true"
                            id="editor-${panel}"
                            data-panel="${panel}"
                            data-scene-id="${scene.id}"
                            data-chapter-id="${chapter.id}"
                            data-act-id="${act.id}"
                            data-placeholder="Commencez à écrire votre scène..."
                            oninput="updateSplitSceneContent(this)"
                            onkeydown="handleEditorKeydown(event)"
                        >${scene.content || ''}</div>
                    </div>
                </div>
            `;
            
            // Initialize lucide icons
            setTimeout(() => {
                if (typeof lucide !== 'undefined') lucide.createIcons();
            }, 50);
        }
        
        // Toggle toolbar visibility in split panel
        function toggleSplitEditorToolbar(panel) {
            const toolbar = document.getElementById('editorToolbar-' + panel);
            if (toolbar) {
                toolbar.classList.toggle('visible');
            }
        }
        
        // Format text in a specific panel's editor
        function formatTextInPanel(panel, command, value = null) {
            const editor = document.getElementById('editor-' + panel);
            if (!editor) return;
            
            // Focus the editor first
            editor.focus();
            
            // Execute the command
            if (value) {
                document.execCommand(command, false, value);
            } else {
                document.execCommand(command, false, null);
            }
        }
        
        // Render full world detail in container
        function renderWorldDetailInContainer(element, container) {
            container.innerHTML = `
                <div class="detail-view" style="height: 100%; overflow-y: auto;">
                    <div class="detail-header" style="position: sticky; top: 0; background: var(--bg-primary); z-index: 10; padding: 1rem; border-bottom: 1px solid var(--border-color);">
                        <div style="display: flex; align-items: center; gap: 1rem;">
                            <div class="detail-title" style="font-size: 1.5rem; font-weight: 600;">${element.name}</div>
                            <span style="font-size: 0.85rem; padding: 0.4rem 0.8rem; background: var(--primary-color); color: white; border-radius: 4px;">${element.type}</span>
                        </div>
                    </div>
                    
                    <div style="padding: 1.5rem;">
                        <div class="detail-section" style="margin-bottom: 1.5rem;">
                            <div class="detail-section-title" style="font-size: 0.9rem; font-weight: 600; color: var(--text-muted); margin-bottom: 0.5rem;">Nom</div>
                            <input type="text" class="form-input" value="${element.name}" 
                                   onchange="updateWorldField(${element.id}, 'name', this.value)" style="width: 100%;">
                        </div>

                        <div class="detail-section" style="margin-bottom: 1.5rem;">
                            <div class="detail-section-title" style="font-size: 0.9rem; font-weight: 600; color: var(--text-muted); margin-bottom: 0.5rem;">Type</div>
                            <select class="form-input" onchange="updateWorldField(${element.id}, 'type', this.value)" style="width: 100%;">
                                <option value="Lieu" ${element.type === 'Lieu' ? 'selected' : ''}>Lieu</option>
                                <option value="Objet" ${element.type === 'Objet' ? 'selected' : ''}>Objet</option>
                                <option value="Concept" ${element.type === 'Concept' ? 'selected' : ''}>Concept</option>
                                <option value="Organisation" ${element.type === 'Organisation' ? 'selected' : ''}>Organisation</option>
                                <option value="Événement" ${element.type === 'Événement' ? 'selected' : ''}>Événement</option>
                            </select>
                        </div>

                        <div class="detail-section" style="margin-bottom: 1.5rem;">
                            <div class="detail-section-title" style="font-size: 0.9rem; font-weight: 600; color: var(--text-muted); margin-bottom: 0.5rem;">Description</div>
                            <textarea class="form-input" rows="6" style="width: 100%; resize: vertical;"
                                      onchange="updateWorldField(${element.id}, 'description', this.value)">${element.description || ''}</textarea>
                        </div>

                        <div class="detail-section" style="margin-bottom: 1.5rem;">
                            <div class="detail-section-title" style="font-size: 0.9rem; font-weight: 600; color: var(--text-muted); margin-bottom: 0.5rem;">Détails</div>
                            <textarea class="form-input" rows="6" style="width: 100%; resize: vertical;"
                                      onchange="updateWorldField(${element.id}, 'details', this.value)">${element.details || ''}</textarea>
                        </div>

                        <div class="detail-section" style="margin-bottom: 1.5rem;">
                            <div class="detail-section-title" style="font-size: 0.9rem; font-weight: 600; color: var(--text-muted); margin-bottom: 0.5rem;">Histoire</div>
                            <textarea class="form-input" rows="6" style="width: 100%; resize: vertical;"
                                      onchange="updateWorldField(${element.id}, 'history', this.value)">${element.history || ''}</textarea>
                        </div>

                        <div class="detail-section" style="margin-bottom: 1.5rem;">
                            <div class="detail-section-title" style="font-size: 0.9rem; font-weight: 600; color: var(--text-muted); margin-bottom: 0.5rem;">Notes</div>
                            <textarea class="form-input" rows="4" style="width: 100%; resize: vertical;"
                                      onchange="updateWorldField(${element.id}, 'notes', this.value)">${element.notes || ''}</textarea>
                        </div>
                    </div>
                </div>
            `;
        }
        
        // Render full note detail in container
        function renderNoteDetailInContainer(note, container) {
            container.innerHTML = `
                <div class="detail-view" style="height: 100%; display: flex; flex-direction: column; overflow: hidden;">
                    <div class="detail-header" style="padding: 1rem; background: var(--bg-secondary); border-bottom: 1px solid var(--border-color);">
                        <div style="display: flex; align-items: center; gap: 1rem;">
                            <input type="text" class="form-input" value="${note.title || ''}" 
                                   style="font-size: 1.3rem; font-weight: 600; flex: 1; border: none; background: transparent;"
                                   onchange="updateNoteField(${note.id}, 'title', this.value)"
                                   placeholder="Titre de la note">
                            <select class="form-input" onchange="updateNoteField(${note.id}, 'category', this.value)" style="width: auto;">
                                <option value="Recherche" ${note.category === 'Recherche' ? 'selected' : ''}>Recherche</option>
                                <option value="Idée" ${note.category === 'Idée' ? 'selected' : ''}>Idée</option>
                                <option value="Référence" ${note.category === 'Référence' ? 'selected' : ''}>Référence</option>
                                <option value="A faire" ${note.category === 'A faire' ? 'selected' : ''}>À faire</option>
                                <option value="Question" ${note.category === 'Question' ? 'selected' : ''}>Question</option>
                                <option value="Autre" ${note.category === 'Autre' ? 'selected' : ''}>Autre</option>
                            </select>
                        </div>
                        <div style="margin-top: 0.5rem;">
                            <input type="text" class="form-input" value="${(note.tags || []).join(', ')}" 
                                   style="font-size: 0.85rem; width: 100%;"
                                   onchange="updateNoteTags(${note.id}, this.value)"
                                   placeholder="Tags (séparés par des virgules)">
                        </div>
                    </div>
                    <div style="flex: 1; padding: 1rem; overflow: hidden;">
                        <textarea class="form-input" 
                                  style="width: 100%; height: 100%; resize: none; font-size: 1rem; line-height: 1.7; border: none; background: var(--bg-primary);"
                                  oninput="updateNoteField(${note.id}, 'content', this.value)"
                                  placeholder="Contenu de la note...">${note.content || ''}</textarea>
                    </div>
                    <div style="padding: 0.5rem 1rem; font-size: 0.75rem; color: var(--text-muted); background: var(--bg-secondary); border-top: 1px solid var(--border-color);">
                        Créée le ${new Date(note.createdAt).toLocaleDateString('fr-FR')} • 
                        Modifiée le ${new Date(note.updatedAt).toLocaleDateString('fr-FR')}
                    </div>
                </div>
            `;
        }
        
        function renderCorkboardInSplitPanel(containerId) {
            const container = document.getElementById(containerId);
            if (!container) return;
            
            container.innerHTML = `
                <div style="padding: 1rem;">
                    <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 1rem;">
                        ${project.acts.map(act => 
                            act.chapters.map(chapter => 
                                chapter.scenes.map(scene => `
                                    <div class="cork-card" onclick="openSceneFromSplit(${act.id}, ${chapter.id}, ${scene.id})" style="background: var(--bg-secondary); padding: 1rem; border-radius: 8px; border: 1px solid var(--border-color); cursor: pointer; transition: transform 0.15s, box-shadow 0.15s;">
                                        <div style="font-weight: 600; margin-bottom: 0.5rem;">${scene.title || 'Sans titre'}</div>
                                        <div style="font-size: 0.8rem; color: var(--text-muted);">${chapter.title}</div>
                                        <div style="font-size: 0.75rem; color: var(--text-muted); margin-top: 0.5rem;">${getWordCount(scene.content || '')} mots</div>
                                    </div>
                                `).join('')
                            ).join('')
                        ).join('')}
                    </div>
                </div>
            `;
        }
        
        // Helper to open a scene from corkboard in split mode
        function openSceneFromSplit(actId, chapterId, sceneId) {
            if (splitViewActive) {
                const state = splitActivePanel === 'left' ? splitViewState.left : splitViewState.right;
                state.view = 'editor';
                state.actId = actId;
                state.chapterId = chapterId;
                state.sceneId = sceneId;
                renderSplitPanelViewContent(splitActivePanel);
                updateSplitPanelHeader(splitActivePanel);
                updateSidebarForSplitPanel(splitActivePanel);
            } else {
                openScene(actId, chapterId, sceneId);
            }
        }
        
        function renderStatsInSplitPanel(containerId) {
            const container = document.getElementById(containerId);
            if (!container) return;
            
            let totalWords = 0;
            let totalScenes = 0;
            let totalChapters = 0;
            
            project.acts.forEach(act => {
                act.chapters.forEach(chapter => {
                    totalChapters++;
                    chapter.scenes.forEach(scene => {
                        totalScenes++;
                        totalWords += getWordCount(scene.content || '');
                    });
                });
            });
            
            container.innerHTML = `
                <div style="padding: 1.5rem;">
                    <h3 style="margin-bottom: 1.5rem;">Statistiques du projet</h3>
                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem;">
                        <div style="background: var(--bg-secondary); padding: 1.5rem; border-radius: 8px; text-align: center;">
                            <div style="font-size: 2rem; font-weight: 700; color: var(--primary-color);">${totalWords.toLocaleString()}</div>
                            <div style="color: var(--text-muted);">Mots</div>
                        </div>
                        <div style="background: var(--bg-secondary); padding: 1.5rem; border-radius: 8px; text-align: center;">
                            <div style="font-size: 2rem; font-weight: 700; color: var(--primary-color);">${totalScenes}</div>
                            <div style="color: var(--text-muted);">Scènes</div>
                        </div>
                        <div style="background: var(--bg-secondary); padding: 1.5rem; border-radius: 8px; text-align: center;">
                            <div style="font-size: 2rem; font-weight: 700; color: var(--primary-color);">${totalChapters}</div>
                            <div style="color: var(--text-muted);">Chapitres</div>
                        </div>
                        <div style="background: var(--bg-secondary); padding: 1.5rem; border-radius: 8px; text-align: center;">
                            <div style="font-size: 2rem; font-weight: 700; color: var(--primary-color);">${project.characters?.length || 0}</div>
                            <div style="color: var(--text-muted);">Personnages</div>
                        </div>
                    </div>
                </div>
            `;
        }
        
        // Render Plot view in split panel
        function renderPlotInSplitPanel(container) {
            // Initialiser les points d'intrigue si nécessaire
            if (typeof plotPoints === 'undefined' || plotPoints.length === 0) {
                if (typeof initPlotPoints === 'function') {
                    initPlotPoints();
                }
            }
            
            const svgWidth = 600;
            const svgHeight = 350;
            const padding = 50;
            const plotWidth = svgWidth - padding * 2;
            const plotHeight = svgHeight - padding * 2;
            
            let pathData = '';
            let pointsHTML = '';
            let gridLines = '';
            
            // Lignes de grille
            for (let i = 0; i <= 4; i++) {
                const y = padding + (plotHeight / 4) * i;
                gridLines += `<line x1="${padding}" y1="${y}" x2="${svgWidth - padding}" y2="${y}" stroke="var(--border-color)" stroke-width="1" opacity="0.3" stroke-dasharray="5,5"/>`;
            }
            
            // Générer la courbe si plotPoints existe
            if (typeof plotPoints !== 'undefined' && plotPoints.length > 0) {
                plotPoints.forEach((point, index) => {
                    const x = padding + (plotWidth / Math.max(plotPoints.length - 1, 1)) * index;
                    const y = padding + plotHeight - (point.intensity / 100) * plotHeight;
                    
                    if (index === 0) {
                        pathData = `M ${x} ${y}`;
                    } else {
                        pathData += ` L ${x} ${y}`;
                    }
                    
                    pointsHTML += `
                        <circle cx="${x}" cy="${y}" r="5" fill="var(--accent-gold)" stroke="white" stroke-width="2" 
                                style="cursor: pointer;" 
                                onclick="openScene(${point.actId}, ${point.chapterId}, ${point.sceneId})">
                            <title>${point.title} - Tension: ${Math.round(point.intensity)}%</title>
                        </circle>
                    `;
                });
            }
            
            container.innerHTML = `
                <div style="padding: 1.5rem;">
                    <h3 style="margin-bottom: 1rem;"><i data-lucide="trending-up" style="width:18px;height:18px;vertical-align:middle;margin-right:6px;"></i>Graphique d'Intrigue</h3>
                    <div style="background: var(--bg-secondary); border-radius: 8px; padding: 1rem; overflow-x: auto;">
                        <svg viewBox="0 0 ${svgWidth} ${svgHeight}" style="width: 100%; max-width: ${svgWidth}px; height: auto;">
                            ${gridLines}
                            ${pathData ? `<path d="${pathData}" fill="none" stroke="var(--primary-color)" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/>` : ''}
                            ${pointsHTML}
                        </svg>
                    </div>
                    <div style="margin-top: 1rem; font-size: 0.85rem; color: var(--text-muted);">
                        ${typeof plotPoints !== 'undefined' ? plotPoints.length : 0} points d'intrigue • Cliquez sur un point pour ouvrir la scène
                    </div>
                </div>
            `;
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }
        
        // Render Relations view in split panel
        function renderRelationsInSplitPanel(container) {
            const relationships = project.relationships || [];
            const characters = project.characters || [];
            
            if (characters.length < 2) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon"><i data-lucide="heart-handshake" style="width:48px;height:48px;stroke-width:1.5;"></i></div>
                        <div class="empty-state-title">Relations</div>
                        <div class="empty-state-text">Créez au moins 2 personnages pour définir leurs relations</div>
                    </div>
                `;
                if (typeof lucide !== 'undefined') lucide.createIcons();
                return;
            }
            
            let relationsHTML = '';
            if (relationships.length > 0) {
                relationsHTML = relationships.map(rel => {
                    const char1 = characters.find(c => c.id === rel.character1Id);
                    const char2 = characters.find(c => c.id === rel.character2Id);
                    if (!char1 || !char2) return '';
                    
                    return `
                        <div style="background: var(--bg-secondary); padding: 1rem; border-radius: 8px; margin-bottom: 0.75rem;">
                            <div style="display: flex; align-items: center; gap: 1rem;">
                                <span style="font-weight: 600;">${char1.name || char1.firstName || 'Personnage 1'}</span>
                                <span style="color: var(--primary-color);">↔</span>
                                <span style="font-weight: 600;">${char2.name || char2.firstName || 'Personnage 2'}</span>
                            </div>
                            <div style="font-size: 0.9rem; color: var(--text-muted); margin-top: 0.5rem;">${rel.type || 'Relation'}</div>
                            ${rel.description ? `<div style="font-size: 0.85rem; margin-top: 0.5rem;">${rel.description}</div>` : ''}
                        </div>
                    `;
                }).join('');
            } else {
                relationsHTML = '<div style="color: var(--text-muted); text-align: center; padding: 2rem;">Aucune relation définie</div>';
            }
            
            container.innerHTML = `
                <div style="padding: 1.5rem;">
                    <h3 style="margin-bottom: 1rem;"><i data-lucide="heart-handshake" style="width:18px;height:18px;vertical-align:middle;margin-right:6px;"></i>Relations entre personnages</h3>
                    <div>${relationsHTML}</div>
                    <button class="btn btn-primary" onclick="openAddRelationModal()" style="margin-top: 1rem;">+ Ajouter une relation</button>
                </div>
            `;
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }
        
        // Render Timeline view in split panel
        function renderTimelineInSplitPanel(container) {
            const events = project.timeline || [];
            
            if (events.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon"><i data-lucide="calendar-range" style="width:48px;height:48px;stroke-width:1.5;"></i></div>
                        <div class="empty-state-title">Timeline</div>
                        <div class="empty-state-text">Aucun événement dans la chronologie</div>
                        <button class="btn btn-primary" onclick="openAddTimelineModal()" style="margin-top: 1rem;">+ Ajouter un événement</button>
                    </div>
                `;
                if (typeof lucide !== 'undefined') lucide.createIcons();
                return;
            }
            
            // Trier par date si possible
            const sortedEvents = [...events].sort((a, b) => {
                if (a.date && b.date) return new Date(a.date) - new Date(b.date);
                return 0;
            });
            
            const eventsHTML = sortedEvents.map((event, index) => `
                <div style="display: flex; gap: 1rem; margin-bottom: 1.5rem;">
                    <div style="display: flex; flex-direction: column; align-items: center;">
                        <div style="width: 12px; height: 12px; background: var(--primary-color); border-radius: 50%;"></div>
                        ${index < sortedEvents.length - 1 ? '<div style="width: 2px; flex: 1; background: var(--border-color);"></div>' : ''}
                    </div>
                    <div style="flex: 1; background: var(--bg-secondary); padding: 1rem; border-radius: 8px;">
                        <div style="font-weight: 600;">${event.title}</div>
                        ${event.date ? `<div style="font-size: 0.85rem; color: var(--primary-color); margin-top: 0.25rem;">${event.date}</div>` : ''}
                        ${event.description ? `<div style="font-size: 0.9rem; color: var(--text-muted); margin-top: 0.5rem;">${event.description}</div>` : ''}
                    </div>
                </div>
            `).join('');
            
            container.innerHTML = `
                <div style="padding: 1.5rem;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
                        <h3 style="margin: 0;"><i data-lucide="calendar-range" style="width:18px;height:18px;vertical-align:middle;margin-right:6px;"></i>Chronologie</h3>
                        <button class="btn btn-small" onclick="openAddTimelineModal()">+ Événement</button>
                    </div>
                    <div>${eventsHTML}</div>
                </div>
            `;
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }
        
        // View selector for split panels
        let currentSplitSelectorPanel = null;
        
        function openSplitViewSelector(panel) {
            currentSplitSelectorPanel = panel;
            
            const content = document.getElementById('splitSelectorContent');
            if (!content) return;
            
            const currentView = panel === 'left' ? splitViewState.left.view : splitViewState.right.view;
            
            const views = [
                { id: 'editor', label: 'Structure', icon: 'pen-line', desc: 'Écrire vos scènes' },
                { id: 'characters', label: 'Personnages', icon: 'users', desc: 'Fiches personnages' },
                { id: 'world', label: 'Univers', icon: 'globe', desc: 'Lieux et éléments' },
                { id: 'notes', label: 'Notes', icon: 'sticky-note', desc: 'Vos notes' },
                { id: 'codex', label: 'Codex', icon: 'book-open', desc: 'Encyclopédie' },
                { id: 'corkboard', label: 'Tableau', icon: 'layout-grid', desc: 'Vue tableau liège' },
                { id: 'mindmap', label: 'Mindmap', icon: 'git-branch', desc: 'Carte mentale' },
                { id: 'plot', label: 'Intrigue', icon: 'trending-up', desc: 'Arcs narratifs' },
                { id: 'relations', label: 'Relations', icon: 'heart-handshake', desc: 'Liens entre personnages' },
                { id: 'map', label: 'Carte', icon: 'map', desc: 'Carte du monde' },
                { id: 'timelineviz', label: 'Timeline Métro', icon: 'train-track', desc: 'Timeline visuelle' },
                { id: 'timeline', label: 'Timeline', icon: 'calendar-range', desc: 'Timeline classique' },
                { id: 'stats', label: 'Statistiques', icon: 'bar-chart-3', desc: 'Stats du projet' },
                { id: 'analysis', label: 'Analyse', icon: 'trending-up', desc: 'Analyse du texte' },
                { id: 'versions', label: 'Versions', icon: 'file-clock', desc: 'Versions des scènes' },
                { id: 'todos', label: 'TODOs', icon: 'list-todo', desc: 'Liste des tâches' }
            ];
            
            content.innerHTML = `
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.5rem; padding: 0.5rem;">
                    ${views.map(v => `
                        <div class="split-view-option ${currentView === v.id ? 'active' : ''}" 
                             onclick="selectSplitPanelView('${v.id}')"
                             style="display: flex; flex-direction: column; align-items: center; gap: 0.5rem; padding: 1rem 0.5rem; border-radius: 8px; cursor: pointer; background: ${currentView === v.id ? 'var(--primary-color)' : 'var(--bg-secondary)'}; color: ${currentView === v.id ? 'white' : 'var(--text-primary)'}; transition: all 0.15s; text-align: center;">
                            <i data-lucide="${v.icon}" style="width:28px;height:28px;"></i>
                            <div>
                                <div style="font-weight: 600; font-size: 0.9rem;">${v.label}</div>
                                <div style="font-size: 0.7rem; opacity: 0.7; margin-top: 0.25rem;">${v.desc}</div>
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
            
            document.getElementById('splitSelectorModal').classList.add('active');
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }
        
        function selectSplitPanelView(view) {
            if (!currentSplitSelectorPanel) return;
            
            switchSplitPanelView(currentSplitSelectorPanel, view);
            closeModal('splitSelectorModal');
        }
        
        // Handle scene selection in split view
        function openSceneInSplitPanel(actId, chapterId, sceneId) {
            if (!splitViewActive) return;
            
            const state = splitActivePanel === 'left' ? splitViewState.left : splitViewState.right;
            
            // Only update if the active panel is showing editor view
            if (state.view === 'editor') {
                state.actId = actId;
                state.chapterId = chapterId;
                state.sceneId = sceneId;
                
                // Also update global current IDs
                currentActId = actId;
                currentChapterId = chapterId;
                currentSceneId = sceneId;
                
                renderSplitPanelViewContent(splitActivePanel);
                saveSplitViewState();
            }
        }
        
        // Handle character selection in split view
        function openCharacterInSplitPanel(charId) {
            if (!splitViewActive) return;
            
            const state = splitActivePanel === 'left' ? splitViewState.left : splitViewState.right;
            
            if (state.view === 'characters') {
                state.characterId = charId;
                renderSplitPanelViewContent(splitActivePanel);
                saveSplitViewState();
            }
        }
        
        // Handle world element selection in split view
        function openWorldElementInSplitPanel(elemId) {
            if (!splitViewActive) return;
            
            const state = splitActivePanel === 'left' ? splitViewState.left : splitViewState.right;
            
            if (state.view === 'world') {
                state.worldId = elemId;
                renderSplitPanelViewContent(splitActivePanel);
                saveSplitViewState();
            }
        }
        
        // Handle note selection in split view  
        function openNoteInSplitPanel(noteId) {
            if (!splitViewActive) return;
            
            const state = splitActivePanel === 'left' ? splitViewState.left : splitViewState.right;
            
            if (state.view === 'notes') {
                state.noteId = noteId;
                renderSplitPanelViewContent(splitActivePanel);
                saveSplitViewState();
            }
        }
        
        function updateSplitSceneContent(editor) {
            const sceneId = parseInt(editor.dataset.sceneId);
            const chapterId = parseInt(editor.dataset.chapterId);
            const actId = parseInt(editor.dataset.actId);
            const panel = editor.dataset.panel;
            
            const act = project.acts.find(a => a.id === actId);
            if (!act) return;
            const chapter = act.chapters.find(c => c.id === chapterId);
            if (!chapter) return;
            const scene = chapter.scenes.find(s => s.id === sceneId);
            if (!scene) return;
            
            scene.content = editor.innerHTML;
            const wordCount = getWordCount(editor.innerHTML);
            scene.wordCount = wordCount;
            
            // Update word count display
            const wcDisplay = document.querySelector(`.split-word-count-${panel}`);
            if (wcDisplay) wcDisplay.textContent = wordCount;
            
            saveProject();
        }
        
        function updateSplitNoteContent(textarea) {
            const noteId = parseInt(textarea.dataset.noteId);
            const note = project.notes?.find(n => n.id === noteId);
            if (note) {
                note.content = textarea.value;
                saveProject();
            }
        }
        
        // Resizer functionality
        let isResizing = false;
        
        function startSplitResize(e) {
            isResizing = true;
            
            const resizer = document.getElementById('splitResizer');
            if (resizer) resizer.classList.add('dragging');
            
            document.body.style.cursor = 'col-resize';
            document.body.style.userSelect = 'none';
            
            document.addEventListener('mousemove', doSplitResize);
            document.addEventListener('mouseup', stopSplitResize);
            document.addEventListener('touchmove', doSplitResize, { passive: false });
            document.addEventListener('touchend', stopSplitResize);
            
            e.preventDefault();
        }
        
        function doSplitResize(e) {
            if (!isResizing) return;
            
            const container = document.getElementById('splitViewContainer');
            if (!container) return;
            
            const currentX = e.clientX || (e.touches && e.touches[0].clientX);
            const containerRect = container.getBoundingClientRect();
            const containerWidth = containerRect.width;
            
            let newRatio = ((currentX - containerRect.left) / containerWidth) * 100;
            newRatio = Math.max(20, Math.min(80, newRatio));
            
            splitViewState.ratio = newRatio;
            
            const leftPanel = document.getElementById('splitPanelLeft');
            const rightPanel = document.getElementById('splitPanelRight');
            
            if (leftPanel) leftPanel.style.flex = newRatio;
            if (rightPanel) rightPanel.style.flex = 100 - newRatio;
            
            e.preventDefault();
        }
        
        function stopSplitResize() {
            isResizing = false;
            
            const resizer = document.getElementById('splitResizer');
            if (resizer) resizer.classList.remove('dragging');
            
            document.body.style.cursor = '';
            document.body.style.userSelect = '';
            
            document.removeEventListener('mousemove', doSplitResize);
            document.removeEventListener('mouseup', stopSplitResize);
            document.removeEventListener('touchmove', doSplitResize);
            document.removeEventListener('touchend', stopSplitResize);
            
            saveSplitViewState();
        }
        
        function saveSplitViewState() {
            if (splitViewState.persistOnReload) {
                localStorage.setItem('plume_splitViewState', JSON.stringify({
                    active: splitViewActive,
                    activePanel: splitActivePanel,
                    state: splitViewState
                }));
            }
        }
        
        function loadSplitViewState() {
            const saved = localStorage.getItem('plume_splitViewState');
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    if (data.state && data.state.persistOnReload) {
                        splitViewState = { ...splitViewState, ...data.state };
                        splitActivePanel = data.activePanel || 'left';
                        if (data.active) {
                            splitViewActive = true;
                            setTimeout(() => {
                                renderSplitView();
                                updateSplitToggleButton();
                            }, 500);
                        }
                    }
                } catch (e) {
                    console.error('Error loading split view state:', e);
                }
            }
        }
        
        // Legacy function for compatibility
        function openCharacterBeside(charId) {
            if (!splitViewActive) {
                activateSplitView();
            }
            
            // Set right panel to characters view with this character
            splitViewState.right.view = 'characters';
            splitViewState.right.characterId = charId;
            splitActivePanel = 'right';
            
            renderSplitView();
            showNotification('Personnage ouvert dans le panneau droit');
        }

        function updateCharacterField(id, field, value) {
            const character = project.characters.find(c => c.id === id);
            if (character) {
                character[field] = value;
                saveProject();
                renderCharactersList();
            }
        }

        

// ========== 17.world.js ==========
// World Management
        function openAddWorldModal() {
            document.getElementById('addWorldModal').classList.add('active');
            setTimeout(() => document.getElementById('worldNameInput').focus(), 100);
        }

        function addWorldElement() {
            const name = document.getElementById('worldNameInput').value.trim();
            const type = document.getElementById('worldTypeInput').value;
            const description = document.getElementById('worldDescInput').value.trim();
            
            if (!name) return;

            const element = {
                id: Date.now(),
                name: name,
                type: type,
                description: description || '',
                details: '',
                history: '',
                notes: '',
                linkedScenes: [], // Array of scene IDs where this element appears
                linkedElements: [] // Array of {type, id} for related characters/timeline/etc
            };

            project.world.push(element);
            
            // Clear inputs
            document.getElementById('worldNameInput').value = '';
            document.getElementById('worldDescInput').value = '';
            
            closeModal('addWorldModal');
            saveProject();
            renderWorldList();
        }

        function deleteWorldElement(id) {
            if (!confirm('Êtes-vous sûr de vouloir supprimer cet élément ?')) return;
            project.world = project.world.filter(w => w.id !== id);
            saveProject();
            renderWorldList();
            showEmptyState();
        }

        function renderWorldList() {
            const container = document.getElementById('worldList');
            
            if (project.world.length === 0) {
                container.innerHTML = '<div style="padding: 1rem; text-align: center; color: var(--text-muted); font-size: 0.85rem;">Aucun élément</div>';
                return;
            }
            
            // Group by type
            const groups = {};
            project.world.forEach(elem => {
                const type = elem.type || 'Autre';
                if (!groups[type]) groups[type] = [];
                groups[type].push(elem);
            });
            
            // Icons for each type (Mise à jour avec Lucide Icons)
            const typeIcons = {
                'Lieu': 'map-pin',
                'Objet': 'package', 
                'Concept': 'lightbulb',
                'Organisation': 'users',
                'Événement': 'calendar',
                'Autre': 'more-horizontal'
            };
            
            // Get collapsed state from localStorage
            const collapsedState = JSON.parse(localStorage.getItem('plume_treeview_collapsed') || '{}');
            
            let html = '';
            Object.keys(groups).sort().forEach(type => {
                const groupKey = 'world_' + type;
                const isCollapsed = collapsedState[groupKey] === true;
                
                // Sort elements alphabetically within each group
                const sortedElements = [...groups[type]].sort((a, b) => {
                    return (a.name || '').toLowerCase().localeCompare((b.name || '').toLowerCase(), 'fr');
                });
                
                html += `
                    <div class="treeview-group">
                        <div class="treeview-header" onclick="toggleTreeviewGroup('${groupKey}')">
                            <i data-lucide="${isCollapsed ? 'chevron-right' : 'chevron-down'}" class="treeview-chevron"></i>
                            <span class="treeview-label">${type}</span>
                            <span class="treeview-count">${groups[type].length}</span>
                        </div>
                        <div class="treeview-children ${isCollapsed ? 'collapsed' : ''}">
                            ${sortedElements.map(elem => {
                                const iconName = typeIcons[type] || 'circle'; // Icône par défaut 'circle'
                                
                                return `
                                <div class="treeview-item" onclick="openWorldDetail(${elem.id})">
                                    <span class="treeview-item-icon"><i data-lucide="${iconName}" style="width:14px;height:14px;vertical-align:middle;"></i></span>
                                    <span class="treeview-item-label">${elem.name}</span>
                                    <button class="treeview-item-delete" onclick="event.stopPropagation(); deleteWorldElement(${elem.id})" title="Supprimer">×</button>
                                </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                `;
            });

            container.innerHTML = html;
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }

        function renderElementLinkedScenes(element) {
            const scenes = findScenesWithElement(element.id);
            if (scenes.length === 0) return '';

            return `
                <div class="detail-section">
                    <div class="detail-section-title"><i data-lucide="file-text" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Apparaît dans ${scenes.length} scène(s)</div>
                    <div class="quick-links">
                        ${scenes.map(scene => {
                            const actIndex = project.acts.findIndex(a => a.id === scene.actId);
                            const act = project.acts[actIndex];
                            const chapterIndex = act.chapters.findIndex(c => c.id === scene.chapterId);
                            const actNumber = toRoman(actIndex + 1);
                            const chapterNumber = chapterIndex + 1;
                            const breadcrumb = `Acte ${actNumber} › Chapitre ${chapterNumber} › ${scene.sceneTitle}`;
                            
                            return `
                            <span class="link-badge" onclick="openScene(${scene.actId}, ${scene.chapterId}, ${scene.sceneId})" title="${scene.actTitle} - ${scene.chapterTitle}">
                                ${breadcrumb}
                            </span>
                        `;
                        }).join('')}
                    </div>
                </div>
            `;
        }

        function openWorldDetail(id) {
            const element = project.world.find(w => w.id === id);
            if (!element) return;
            
            // Handle split view mode
            if (splitViewActive) {
                const state = splitActivePanel === 'left' ? splitViewState.left : splitViewState.right;
                if (state.view === 'world') {
                    state.worldId = id;
                    renderSplitPanelViewContent(splitActivePanel);
                    saveSplitViewState();
                    return;
                }
            }

            const editorView = document.getElementById('editorView');
            editorView.innerHTML = `
                <div class="detail-view">
                    <div class="detail-header">
                        <div style="display: flex; align-items: center; gap: 1rem;">
                            <div class="detail-title">${element.name}</div>
                            <span style="font-size: 0.9rem; padding: 0.5rem 1rem; background: var(--accent-gold); color: var(--bg-primary); border-radius: 2px;">${element.type}</span>
                        </div>
                        <div style="display: flex; gap: 0.5rem;">
                            <button class="btn btn-small" onclick="showReferencesForElement(${id})"><i data-lucide="link" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Voir les références</button>
                            <button class="btn" onclick="switchView('editor')">? Retour à l'éditeur</button>
                        </div>
                    </div>
                    
                    ${renderElementLinkedScenes(element)}
                    
                    <div class="detail-section">
                        <div class="detail-section-title">Informations de base</div>
                        <div class="detail-field">
                            <div class="detail-label">Nom</div>
                            <input type="text" class="form-input" value="${element.name}" 
                                   onchange="updateWorldField(${id}, 'name', this.value)">
                        </div>
                    </div>

                    <div class="detail-section">
                        <div class="detail-section-title">Type</div>
                        <select class="form-input" onchange="updateWorldField(${id}, 'type', this.value)">
                            <option value="Lieu" ${element.type === 'Lieu' ? 'selected' : ''}>Lieu</option>
                            <option value="Objet" ${element.type === 'Objet' ? 'selected' : ''}>Objet</option>
                            <option value="Concept" ${element.type === 'Concept' ? 'selected' : ''}>Concept</option>
                            <option value="Organisation" ${element.type === 'Organisation' ? 'selected' : ''}>Organisation</option>
                            <option value="Événement" ${element.type === 'Événement' ? 'selected' : ''}>Événement</option>
                        </select>
                    </div>

                    <div class="detail-section">
                        <div class="detail-section-title">Description</div>
                        <textarea class="form-input" rows="6" 
                                  onchange="updateWorldField(${id}, 'description', this.value)">${element.description}</textarea>
                    </div>

                    <div class="detail-section">
                        <div class="detail-section-title">Détails</div>
                        <textarea class="form-input" rows="6" 
                                  onchange="updateWorldField(${id}, 'details', this.value)">${element.details}</textarea>
                    </div>

                    <div class="detail-section">
                        <div class="detail-section-title">Histoire</div>
                        <textarea class="form-input" rows="6" 
                                  onchange="updateWorldField(${id}, 'history', this.value)">${element.history}</textarea>
                    </div>

                    <div class="detail-section">
                        <div class="detail-section-title">Notes</div>
                        <textarea class="form-input" rows="4" 
                                  onchange="updateWorldField(${id}, 'notes', this.value)">${element.notes}</textarea>
                    </div>
                </div>
            `;
        }

        function updateWorldField(id, field, value) {
            const element = project.world.find(w => w.id === id);
            if (element) {
                element[field] = value;
                saveProject();
                renderWorldList();
            }
        }

// ========== 18.timeline.js ==========

        // Timeline Management
        function openAddTimelineModal() {
            document.getElementById('addTimelineModal').classList.add('active');
            setTimeout(() => document.getElementById('timelineTitleInput').focus(), 100);
        }

        function addTimelineEvent() {
            const title = document.getElementById('timelineTitleInput').value.trim();
            const date = document.getElementById('timelineDateInput').value.trim();
            const location = document.getElementById('timelineLocationInput').value.trim();
            const characters = document.getElementById('timelineCharactersInput').value.trim();
            const description = document.getElementById('timelineDescInput').value.trim();
            
            if (!title) return;

            const event = {
                id: Date.now(),
                title: title,
                date: date || '',
                location: location || '',
                characters: characters || '',
                description: description || '',
                order: project.timeline.length, // For manual reordering
                consequences: '',
                notes: ''
            };

            project.timeline.push(event);
            
            // Clear inputs
            document.getElementById('timelineTitleInput').value = '';
            document.getElementById('timelineDateInput').value = '';
            document.getElementById('timelineLocationInput').value = '';
            document.getElementById('timelineCharactersInput').value = '';
            document.getElementById('timelineDescInput').value = '';
            
            closeModal('addTimelineModal');
            saveProject();
            renderTimelineList();
        }

        function deleteTimelineEvent(id) {
            if (!confirm('Êtes-vous sûr de vouloir supprimer cet événement ?')) return;
            project.timeline = project.timeline.filter(e => e.id !== id);
            saveProject();
            renderTimelineList();
            showEmptyState();
        }

        function renderTimelineList() {
            const container = document.getElementById('timelineList');
            
            if (project.timeline.length === 0) {
                container.innerHTML = '<div style="padding: 2rem; text-align: center; color: var(--text-muted);">Aucun événement</div>';
                return;
            }

            // Sort by order field for manual ordering
            const sortedTimeline = [...project.timeline].sort((a, b) => a.order - b.order);

            container.innerHTML = `
                <div class="timeline-container">
                    <div class="timeline-line"></div>
                    ${sortedTimeline.map(event => `
                        <div class="timeline-event" onclick="openTimelineDetail(${event.id})">
                            <div style="display: flex; justify-content: space-between; align-items: start;">
                                <div style="flex: 1;">
                                    ${event.date ? `<div class="timeline-date">?? ${event.date}</div>` : ''}
                                    <div class="timeline-title">${event.title}</div>
                                    <div class="timeline-meta">
                                        ${event.location ? `<div class="timeline-meta-item">?? ${event.location}</div>` : ''}
                                        ${event.characters ? `<div class="timeline-meta-item"><i data-lucide="users" style="width:12px;height:12px;vertical-align:middle;margin-right:4px;"></i>${event.characters}</div>` : ''}
                                    </div>
                                    ${event.description ? `<div class="timeline-description">${event.description}</div>` : ''}
                                </div>
                                <button class="btn btn-icon btn-small" onclick="event.stopPropagation(); deleteTimelineEvent(${event.id})" title="Supprimer">×</button>
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        function openTimelineDetail(id) {
            const event = project.timeline.find(e => e.id === id);
            if (!event) return;

            const editorView = document.getElementById('editorView');
            editorView.innerHTML = `
                <div class="detail-view">
                    <div class="detail-header">
                        <div class="detail-title">${event.title}</div>
                        <button class="btn" onclick="switchView('editor')">? Retour à l'éditeur</button>
                    </div>
                    
                    <div class="detail-section">
                        <div class="detail-section-title">Informations</div>
                        <div class="detail-field">
                            <div class="detail-label">Date / Moment</div>
                            <input type="text" class="form-input" value="${event.date}" 
                                   onchange="updateTimelineField(${id}, 'date', this.value)">
                        </div>
                        <div class="detail-field">
                            <div class="detail-label">Localisation</div>
                            <input type="text" class="form-input" value="${event.location}" 
                                   onchange="updateTimelineField(${id}, 'location', this.value)">
                        </div>
                        <div class="detail-field">
                            <div class="detail-label">Personnages impliqués</div>
                            <input type="text" class="form-input" value="${event.characters}" 
                                   onchange="updateTimelineField(${id}, 'characters', this.value)">
                        </div>
                    </div>

                    <div class="detail-section">
                        <div class="detail-section-title">Description</div>
                        <textarea class="form-input" rows="6" 
                                  onchange="updateTimelineField(${id}, 'description', this.value)">${event.description}</textarea>
                    </div>

                    <div class="detail-section">
                        <div class="detail-section-title">Conséquences</div>
                        <textarea class="form-input" rows="6" 
                                  onchange="updateTimelineField(${id}, 'consequences', this.value)">${event.consequences}</textarea>
                        <small style="color: var(--text-muted); font-style: italic;">Qu'est-ce que cet événement déclenche ou change dans l'histoire ?</small>
                    </div>

                    <div class="detail-section">
                        <div class="detail-section-title">Notes</div>
                        <textarea class="form-input" rows="4" 
                                  onchange="updateTimelineField(${id}, 'notes', this.value)">${event.notes}</textarea>
                    </div>
                </div>
            `;
        }

        function updateTimelineField(id, field, value) {
            const event = project.timeline.find(e => e.id === id);
            if (event) {
                event[field] = value;
                saveProject();
                renderTimelineList();
            }
        }


// ========== 19.notes.js ==========
// Notes Management
        function openAddNoteModal() {
            document.getElementById('addNoteModal').classList.add('active');
            setTimeout(() => document.getElementById('noteTitleInput').focus(), 100);
        }

        function addNote() {
            const title = document.getElementById('noteTitleInput').value.trim();
            const category = document.getElementById('noteCategoryInput').value;
            const tags = document.getElementById('noteTagsInput').value.trim();
            const content = document.getElementById('noteContentInput').value.trim();
            
            if (!title) return;

            const note = {
                id: Date.now(),
                title: title,
                category: category,
                tags: tags ? tags.split(',').map(t => t.trim()).filter(t => t) : [],
                content: content || '',
                medias: [], // Support pour les médias: {type: 'url'|'image'|'audio', url: '', title: ''}
                createdAt: new Date().toISOString(),
                updatedAt: new Date().toISOString()
            };

            project.notes.push(note);
            
            // Clear inputs
            document.getElementById('noteTitleInput').value = '';
            document.getElementById('noteTagsInput').value = '';
            document.getElementById('noteContentInput').value = '';
            
            closeModal('addNoteModal');
            saveProject();
            renderNotesList();
        }

        function deleteNote(id) {
            if (!confirm('Êtes-vous sûr de vouloir supprimer cette note ?')) return;
            project.notes = project.notes.filter(n => n.id !== id);
            saveProject();
            renderNotesList();
            showEmptyState();
        }

        // Expanded state for notes categories
        let expandedNoteCategories = new Set(['Idée', 'Recherche', 'Référence', 'A faire', 'Question', 'Autre']);

        function renderNotesList() {
            const container = document.getElementById('notesList');
            
            if (project.notes.length === 0) {
                container.innerHTML = '<div style="padding: 1rem; text-align: center; color: var(--text-muted); font-size: 0.85rem;">Aucune note</div>';
                return;
            }

            // Group notes by category
            const categories = {};
            // Icônes Lucide pour les catégories
            const categoryIcons = {
                'Idée': 'lightbulb',
                'Recherche': 'search',
                'Référence': 'bookmark',
                'A faire': 'check-circle',
                'Question': 'help-circle',
                'Autre': 'file-text'
            };
            
            project.notes.forEach(note => {
                const cat = note.category || 'Autre';
                if (!categories[cat]) categories[cat] = [];
                categories[cat].push(note);
            });

            // Sort notes within categories alphabetically by title
            Object.keys(categories).forEach(cat => {
                categories[cat].sort((a, b) => {
                    return (a.title || '').toLowerCase().localeCompare((b.title || '').toLowerCase(), 'fr');
                });
            });

            let html = '';

            // Render each category as a collapsible group
            const categoryOrder = ['Idée', 'Recherche', 'Référence', 'A faire', 'Question', 'Autre'];
            categoryOrder.forEach(cat => {
                if (!categories[cat] || categories[cat].length === 0) return;
                
                const isExpanded = expandedNoteCategories.has(cat);
                const icon = categoryIcons[cat] || 'file-text';
                
                html += `
                    <div class="treeview-group" data-category="${cat}">
                        <div class="treeview-header" onclick="toggleNoteCategory('${cat}')">
                            <span class="treeview-icon ${isExpanded ? 'expanded' : ''}"><i data-lucide="${isExpanded ? 'chevron-down' : 'chevron-right'}" style="width:14px; height:14px;"></i></span>
                            <span class="treeview-category-icon"><i data-lucide="${icon}" style="width:16px; height:16px;"></i></span>
                            <span class="treeview-title">${cat}</span>
                            <span class="treeview-count">${categories[cat].length}</span>
                        </div>
                        <div class="treeview-children ${isExpanded ? '' : 'collapsed'}">
                            ${categories[cat].map(note => {
                                const hasMedia = note.medias && note.medias.length > 0;
                                // Remplacement du ?? par l'icône de trombone
                                const mediaIcon = hasMedia ? 'paperclip' : ''; 
                                return `
                                    <div class="treeview-item" onclick="openNoteDetail(${note.id})">
                                        <span class="treeview-item-title">${note.title}</span>
                                        ${mediaIcon ? `<span class="treeview-media-icon"><i data-lucide="${mediaIcon}" style="width:14px; height:14px;"></i></span>` : ''}
                                        <button class="btn btn-icon btn-small delete-btn" onclick="event.stopPropagation(); deleteNote(${note.id})" title="Supprimer">×</button>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                `;
            });

            container.innerHTML = html;
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }

        function toggleNoteCategory(category) {
            if (expandedNoteCategories.has(category)) {
                expandedNoteCategories.delete(category);
            } else {
                expandedNoteCategories.add(category);
            }
            renderNotesList();
        }

        function expandAllNoteCategories() {
            expandedNoteCategories = new Set(['Idée', 'Recherche', 'Référence', 'A faire', 'Question', 'Autre']);
            renderNotesList();
        }

        function collapseAllNoteCategories() {
            expandedNoteCategories.clear();
            renderNotesList();
        }

        function openNoteDetail(id) {
            const note = project.notes.find(n => n.id === id);
            if (!note) return;
            
            // Ensure medias array exists
            if (!note.medias) note.medias = [];
            
            // Handle split view mode
            if (splitViewActive) {
                const state = splitActivePanel === 'left' ? splitViewState.left : splitViewState.right;
                if (state.view === 'notes') {
                    state.noteId = id;
                    renderSplitPanelViewContent(splitActivePanel);
                    saveSplitViewState();
                    return;
                }
            }

            const editorView = document.getElementById('editorView');
            editorView.innerHTML = `
                <div class="detail-view">
                    <div class="detail-header">
                        <div style="display: flex; align-items: center; gap: 1rem; flex: 1;">
                            <input type="text" class="form-input" value="${note.title}" 
                                   style="font-size: 1.8rem; font-weight: 600; font-family: 'Noto Serif JP', serif; padding: 0.5rem;"
                                   onchange="updateNoteField(${id}, 'title', this.value)"
                                   placeholder="Titre de la note">
                            <span style="font-size: 0.8rem; padding: 0.4rem 0.8rem; background: var(--accent-gold); color: var(--bg-primary); border-radius: 2px;">${note.category}</span>
                        </div>
                        <button class="btn" onclick="switchView('editor')">? Retour à l'éditeur</button>
                    </div>
                    
                    <div class="detail-section">
                        <div class="detail-section-title">Catégorie</div>
                        <select class="form-input" onchange="updateNoteField(${id}, 'category', this.value)">
                            <option value="Recherche" ${note.category === 'Recherche' ? 'selected' : ''}>Recherche</option>
                            <option value="Idée" ${note.category === 'Idée' ? 'selected' : ''}>Idée</option>
                            <option value="Référence" ${note.category === 'Référence' ? 'selected' : ''}>Référence</option>
                            <option value="A faire" ${note.category === 'A faire' ? 'selected' : ''}>À faire</option>
                            <option value="Question" ${note.category === 'Question' ? 'selected' : ''}>Question</option>
                            <option value="Autre" ${note.category === 'Autre' ? 'selected' : ''}>Autre</option>
                        </select>
                    </div>

                    <div class="detail-section">
                        <div class="detail-section-title">Tags</div>
                        <input type="text" class="form-input" value="${note.tags.join(', ')}" 
                               onchange="updateNoteTags(${id}, this.value)">
                        <small style="color: var(--text-muted); font-style: italic;">Séparez les tags par des virgules</small>
                    </div>

                    <div class="detail-section">
                        <div class="detail-section-title">Contenu</div>
                        <textarea class="form-input" rows="12" 
                                  oninput="updateNoteField(${id}, 'content', this.value)">${note.content}</textarea>
                    </div>

                    <div class="detail-section">
                        <div class="detail-section-title">
                            Médias
                            <button class="btn btn-small" onclick="openAddMediaModal(${id})" style="margin-left: 1rem;">
                                <i data-lucide="plus" style="width:14px;height:14px;margin-right:0.3rem;"></i>Ajouter
                            </button>
                        </div>
                        <div class="note-medias-container" id="noteMedias-${id}">
                            ${renderNoteMedias(note)}
                        </div>
                    </div>

                    <div style="font-size: 0.8rem; color: var(--text-muted); margin-top: 2rem; font-family: 'Source Code Pro', monospace;">
                        Créée le ${new Date(note.createdAt).toLocaleDateString('fr-FR')} • 
                        Modifiée le ${new Date(note.updatedAt).toLocaleDateString('fr-FR')}
                    </div>
                </div>
            `;
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }

        function renderNoteMedias(note) {
            if (!note.medias || note.medias.length === 0) {
                return '<div style="color: var(--text-muted); font-style: italic; padding: 1rem; text-align: center; border: 1px dashed var(--border-color); border-radius: 8px;">Aucun média ajouté</div>';
            }

            return `<div class="note-medias-grid">${note.medias.map((media, index) => {
                if (media.type === 'image') {
                    return `
                        <div class="note-media-item note-media-image">
                            <img src="${media.url}" alt="${media.title || 'Image'}" onclick="window.open('${media.url}', '_blank')">
                            <div class="note-media-overlay">
                                <span class="note-media-title">${media.title || 'Image'}</span>
                                <button class="note-media-delete" onclick="deleteNoteMedia(${note.id}, ${index})">×</button>
                            </div>
                        </div>
                    `;
                } else if (media.type === 'audio') {
                    return `
                        <div class="note-media-item note-media-audio">
                            <div class="note-media-audio-icon"><i data-lucide="volume-2" style="width:24px; height:24px;"></i></div>
                            <div class="note-media-audio-info">
                                <span class="note-media-title">${media.title || 'Audio'}</span>
                                <audio controls src="${media.url}" style="width: 100%; margin-top: 0.5rem;"></audio>
                            </div>
                            <button class="note-media-delete" onclick="deleteNoteMedia(${note.id}, ${index})">×</button>
                        </div>
                    `;
                } else if (media.type === 'url') {
                    const domain = extractDomain(media.url);
                    return `
                        <div class="note-media-item note-media-url" onclick="window.open('${media.url}', '_blank')">
                            <div class="note-media-url-icon"><i data-lucide="link" style="width:24px; height:24px;"></i></div>
                            <div class="note-media-url-info">
                                <span class="note-media-title">${media.title || media.url}</span>
                                <span class="note-media-domain">${domain}</span>
                            </div>
                            <button class="note-media-delete" onclick="event.stopPropagation(); deleteNoteMedia(${note.id}, ${index})">×</button>
                        </div>
                    `;
                } else if (media.type === 'youtube') {
                    const videoId = extractYoutubeId(media.url);
                    return `
                        <div class="note-media-item note-media-youtube">
                            <div class="note-media-youtube-thumb" onclick="window.open('${media.url}', '_blank')">
                                <img src="https://img.youtube.com/vi/${videoId}/mqdefault.jpg" alt="YouTube">
                                <div class="note-media-youtube-play"><i data-lucide="play" style="width:32px; height:32px; fill: white; stroke: white;"></i></div>
                            </div>
                            <div class="note-media-overlay">
                                <span class="note-media-title">${media.title || 'Vidéo YouTube'}</span>
                                <button class="note-media-delete" onclick="deleteNoteMedia(${note.id}, ${index})">×</button>
                            </div>
                        </div>
                    `;
                }
                return '';
            }).join('')}</div>`;
        }

        function extractDomain(url) {
            try {
                const urlObj = new URL(url);
                return urlObj.hostname.replace('www.', '');
            } catch {
                return url;
            }
        }

        function extractYoutubeId(url) {
            const match = url.match(/(?:youtube\.com\/(?:watch\?v=|embed\/)|youtu\.be\/)([^&\s?]+)/);
            return match ? match[1] : '';
        }

        function openAddMediaModal(noteId) {
            // Create modal dynamically
            let modal = document.getElementById('addMediaModal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'addMediaModal';
                modal.className = 'modal';
                document.body.appendChild(modal);
            }
            
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 500px;">
                    <div class="modal-header">
                        <h3>Ajouter un média</h3>
                        <button class="modal-close" onclick="closeModal('addMediaModal')">×</button>
                    </div>
                    <div class="modal-body">
                        <div class="form-group">
                            <label class="form-label">Type de média</label>
                            <select id="mediaTypeInput" class="form-input" onchange="updateMediaInputPlaceholder()">
                                <option value="url">Lien URL</option>
                                <option value="image">Image (URL)</option>
                                <option value="audio">Audio (URL)</option>
                                <option value="youtube">Vidéo YouTube</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label class="form-label">Titre (optionnel)</label>
                            <input type="text" id="mediaTitleInput" class="form-input" placeholder="Titre du média">
                        </div>
                        <div class="form-group">
                            <label class="form-label">URL</label>
                            <input type="text" id="mediaUrlInput" class="form-input" placeholder="https://...">
                        </div>
                        <div id="mediaPreview" style="margin-top: 1rem;"></div>
                    </div>
                    <div class="modal-footer">
                        <button class="btn" onclick="closeModal('addMediaModal')">Annuler</button>
                        <button class="btn btn-primary" onclick="addNoteMedia(${noteId})">Ajouter</button>
                    </div>
                </div>
            `;
            modal.classList.add('active');
        }

        function updateMediaInputPlaceholder() {
            const type = document.getElementById('mediaTypeInput').value;
            const urlInput = document.getElementById('mediaUrlInput');
            const placeholders = {
                'url': 'https://example.com/article',
                'image': 'https://example.com/image.jpg',
                'audio': 'https://example.com/music.mp3',
                'youtube': 'https://www.youtube.com/watch?v=...'
            };
            urlInput.placeholder = placeholders[type] || 'https://...';
        }

        function addNoteMedia(noteId) {
            const type = document.getElementById('mediaTypeInput').value;
            const title = document.getElementById('mediaTitleInput').value.trim();
            const url = document.getElementById('mediaUrlInput').value.trim();
            
            if (!url) {
                alert('Veuillez entrer une URL');
                return;
            }

            const note = project.notes.find(n => n.id === noteId);
            if (!note) return;

            if (!note.medias) note.medias = [];
            
            note.medias.push({
                type: type,
                title: title || '',
                url: url,
                addedAt: new Date().toISOString()
            });

            note.updatedAt = new Date().toISOString();
            saveProject();
            closeModal('addMediaModal');
            openNoteDetail(noteId);
            renderNotesList();
        }

        function deleteNoteMedia(noteId, mediaIndex) {
            if (!confirm('Supprimer ce média ?')) return;
            
            const note = project.notes.find(n => n.id === noteId);
            if (!note || !note.medias) return;

            note.medias.splice(mediaIndex, 1);
            note.updatedAt = new Date().toISOString();
            saveProject();
            openNoteDetail(noteId);
            renderNotesList();
        }

        function updateNoteField(id, field, value) {
            const note = project.notes.find(n => n.id === id);
            if (note) {
                note[field] = value;
                note.updatedAt = new Date().toISOString();
                saveProject();
                renderNotesList();
            }
        }

        function updateNoteTags(id, tagsString) {
            const note = project.notes.find(n => n.id === id);
            if (note) {
                note.tags = tagsString.split(',').map(t => t.trim()).filter(t => t);
                note.updatedAt = new Date().toISOString();
                saveProject();
                renderNotesList();
            }
        }

// ========== 20.snapshots.js ==========

        // Version Control Management
        function createVersion() {
            const label = prompt('Nom de la version (ex: "Version 1.0", "Avant révision", etc.)');
            if (!label || !label.trim()) return;

            const totalWords = project.acts.reduce((sum, act) => {
                return sum + act.chapters.reduce((chSum, chapter) => {
                    return chSum + chapter.scenes.reduce((sceneSum, scene) => {
                        return sceneSum + getWordCount(scene.content);
                    }, 0);
                }, 0);
            }, 0);

            const version = {
                id: Date.now(),
                label: label.trim(),
                timestamp: new Date().toISOString(),
                wordCount: totalWords,
                snapshot: JSON.parse(JSON.stringify({ 
                    acts: project.acts,
                    characters: project.characters,
                    world: project.world,
                    timeline: project.timeline,
                    notes: project.notes,
                    codex: project.codex
                }))
            };

            project.versions.push(version);
            saveProject();
            renderVersionsList();
            alert('Version créée avec succès !');
        }

        function deleteVersion(id) {
            if (!confirm('Êtes-vous sûr de vouloir supprimer cette version ?')) return;
            project.versions = project.versions.filter(v => v.id !== id);
            saveProject();
            renderVersionsList();
        }

        function restoreVersion(id) {
            if (!confirm('?? ATTENTION: Restaurer cette version va remplacer votre travail actuel. Voulez-vous créer une sauvegarde avant de continuer ?')) {
                return;
            }

            // Create backup of current state
            createVersion();

            const version = project.versions.find(v => v.id === id);
            if (!version) return;

            // Restore snapshot
            project.acts = JSON.parse(JSON.stringify(version.snapshot.acts));
            project.characters = JSON.parse(JSON.stringify(version.snapshot.characters || []));
            project.world = JSON.parse(JSON.stringify(version.snapshot.world || []));
            project.timeline = JSON.parse(JSON.stringify(version.snapshot.timeline || []));
            project.notes = JSON.parse(JSON.stringify(version.snapshot.notes || []));
            project.codex = JSON.parse(JSON.stringify(version.snapshot.codex || []));

            saveProject();
            switchView('editor');
            renderActsList();
            alert('Version restaurée avec succès !');
        }

        function renderVersionsList() {
            const editorView = document.getElementById('editorView');
            if (!editorView) {
                console.error('editorView not found');
                return;
            }
            
            // Sort by most recent first
            const sortedVersions = [...project.versions].sort((a, b) => 
                new Date(b.timestamp) - new Date(a.timestamp)
            );

            editorView.innerHTML = `
                <div style="height: 100%; overflow-y: auto; padding: 2rem 3rem;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 2rem;">
                        <h2 style="color: var(--accent-gold);"><i data-lucide="history" style="width:24px;height:24px;vertical-align:middle;margin-right:8px;"></i>Gestion des Versions</h2>
                        <button class="btn btn-primary" onclick="createVersion()">
                            + Créer une version
                        </button>
                    </div>
                    
                    ${project.versions.length === 0 ? `
                        <div style="text-align: center; padding: 4rem 2rem; color: var(--text-muted);">
                            <div style="font-size: 3rem; margin-bottom: 1rem;">??</div>
                            <div style="font-size: 1.2rem; margin-bottom: 0.5rem;">Aucune version sauvegardée</div>
                            <div style="font-size: 0.9rem; margin-bottom: 2rem;">
                                Les versions vous permettent de créer des snapshots de votre projet<br>
                                pour revenir à un état antérieur si nécessaire.
                            </div>
                            <button class="btn btn-primary" onclick="createVersion()">
                                Créer votre première version
                            </button>
                        </div>
                    ` : `
                        <div style="display: grid; gap: 1rem;">
                            ${sortedVersions.map(version => `
                                <div style="background: var(--bg-secondary); padding: 1.5rem; border-radius: 8px; border-left: 4px solid var(--accent-gold);">
                                    <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 1rem;">
                                        <div>
                                            <div style="font-size: 1.1rem; font-weight: 600; color: var(--text-primary); margin-bottom: 0.25rem;">
                                                ${version.label}
                                            </div>
                                            <div style="font-size: 0.85rem; color: var(--text-muted);">
                                                ${new Date(version.timestamp).toLocaleString('fr-FR', { 
                                                    dateStyle: 'long', 
                                                    timeStyle: 'short' 
                                                })}
                                            </div>
                                        </div>
                                        <div style="text-align: right;">
                                            <div style="font-size: 1.5rem; font-weight: 700; color: var(--accent-gold);">
                                                ${version.wordCount.toLocaleString('fr-FR')}
                                            </div>
                                            <div style="font-size: 0.75rem; color: var(--text-muted);">
                                                mots
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                                        <button class="btn btn-small" onclick="restoreVersion(${version.id})" 
                                                style="background: var(--accent-gold); color: white; border: none;">
                                            <i data-lucide="undo" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i> 
                                            Restaurer
                                        </button>
                                        <button class="btn btn-small" onclick="compareVersion(${version.id})">
                                            <i data-lucide="git-compare" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>
                                            Comparer
                                        </button>
                                        <button class="btn btn-small" onclick="deleteVersion(${version.id})" 
                                                style="background: var(--accent-red); color: white; border: none;">
                                            <i data-lucide="trash-2" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i> 
                                            Supprimer
                                        </button>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    `}
                </div>
            `;
        }

        function compareVersion(id) {
            const version = project.versions.find(v => v.id === id);
            if (!version) return;

            const currentWords = project.acts.reduce((sum, act) => {
                return sum + act.chapters.reduce((chSum, chapter) => {
                    return chSum + chapter.scenes.reduce((sceneSum, scene) => {
                        return sceneSum + getWordCount(scene.content);
                    }, 0);
                }, 0);
            }, 0);

            const diff = currentWords - version.wordCount;
            const diffText = diff > 0 ? `+${diff}` : diff;

            alert(`Comparaison avec "${version.label}":\n\nVersion sauvegardée: ${version.wordCount.toLocaleString('fr-FR')} mots\nVersion actuelle: ${currentWords.toLocaleString('fr-FR')} mots\nDifférence: ${diffText} mots`);
        }

// ========== 21.sceneVersions.js ==========
        // ==========================================
        // SCENE VERSION MANAGEMENT (Versions par scène)
        // ==========================================
        
        let sceneVersionsSidebarVisible = false;
        
        function toggleVersionsSidebar() {
            const sidebar = document.getElementById('sidebarVersions');
            const toggleBtn = document.getElementById('headerVersionsToggle');
            sceneVersionsSidebarVisible = !sceneVersionsSidebarVisible;
            
            if (sceneVersionsSidebarVisible) {
                sidebar.classList.remove('hidden');
                if (toggleBtn) {
                    toggleBtn.classList.add('active');
                    toggleBtn.title = 'Masquer les versions de scène';
                }
            } else {
                sidebar.classList.add('hidden');
                if (toggleBtn) {
                    toggleBtn.classList.remove('active');
                    toggleBtn.title = 'Afficher les versions de scène';
                }
            }
        }
        
        function showVersionsSidebar() {
            const sidebar = document.getElementById('sidebarVersions');
            const toggleBtn = document.getElementById('headerVersionsToggle');
            sceneVersionsSidebarVisible = true;
            sidebar.classList.remove('hidden');
            if (toggleBtn) {
                toggleBtn.classList.add('active');
            }
        }
        
        function getSceneVersions(actId, chapterId, sceneId) {
            const act = project.acts.find(a => a.id === actId);
            if (!act) return [];
            const chapter = act.chapters.find(c => c.id === chapterId);
            if (!chapter) return [];
            const scene = chapter.scenes.find(s => s.id === sceneId);
            if (!scene) return [];
            
            // Ensure versions array exists
            if (!scene.versions) {
                scene.versions = [];
            }
            return scene.versions;
        }
        
        function getCurrentSceneForVersions() {
            if (!currentActId || !currentChapterId || !currentSceneId) return null;
            
            const act = project.acts.find(a => a.id === currentActId);
            if (!act) return null;
            const chapter = act.chapters.find(c => c.id === currentChapterId);
            if (!chapter) return null;
            const scene = chapter.scenes.find(s => s.id === currentSceneId);
            
            return scene ? { act, chapter, scene } : null;
        }
        
        function createSceneVersion() {
            const current = getCurrentSceneForVersions();
            if (!current) {
                alert('Veuillez d\'abord sélectionner une scène.');
                return;
            }
            
            const { scene } = current;
            
            // Ensure versions array exists
            if (!scene.versions) {
                scene.versions = [];
            }
            
            // Sauvegarder le contenu actuel de l'éditeur dans la version active
            const editor = document.getElementById('sceneEditor');
            const currentContent = editor ? editor.innerHTML : (scene.content || '');
            
            // Obtenir les annotations de la version active actuelle (pour les copier)
            const currentAnnotations = getVersionAnnotations(scene);
            
            // Sauvegarder le contenu de la version active actuelle
            const currentActiveVersion = scene.versions.find(v => v.isActive);
            if (currentActiveVersion) {
                currentActiveVersion.content = currentContent;
                currentActiveVersion.wordCount = getWordCount(currentContent);
            }
            
            // Create version - GARDER les mêmes IDs d'annotations car le HTML contient ces IDs
            const versionNumber = scene.versions.length + 1;
            const version = {
                id: Date.now(),
                number: versionNumber,
                label: '',
                content: currentContent,
                wordCount: getWordCount(currentContent),
                createdAt: new Date().toISOString(),
                isActive: false,
                // Copier les annotations avec les MÊMES IDs (deep copy sans changer les IDs)
                annotations: currentAnnotations.map(a => ({...a}))
            };
            
            // Mark all previous versions as inactive
            scene.versions.forEach(v => v.isActive = false);
            
            // Add new version as active
            version.isActive = true;
            scene.versions.push(version);
            
            // Update scene content reference to this version
            scene.activeVersionId = version.id;
            scene.content = currentContent;
            
            saveProject();
            renderSceneVersionsList();
            
            // Rafraîchir le panneau d'annotations
            const annotationsPanel = document.getElementById('annotationsPanel');
            if (annotationsPanel && annotationsPanel.classList.contains('visible')) {
                renderAnnotationsPanel();
            }
            updateAnnotationsButton(false);
            
            showNotification(`✓ Version ${versionNumber} créée`);
        }
        
        function switchToSceneVersion(versionId) {
            const current = getCurrentSceneForVersions();
            if (!current) return;
            
            const { scene } = current;
            if (!scene.versions) return;
            
            const version = scene.versions.find(v => v.id === versionId);
            if (!version) return;
            
            // Save current editor content to current active version before switching
            const currentActiveVersion = scene.versions.find(v => v.isActive);
            if (currentActiveVersion) {
                const editor = document.getElementById('sceneEditor');
                const currentContent = editor ? editor.innerHTML : (scene.content || '');
                currentActiveVersion.content = currentContent;
                currentActiveVersion.wordCount = getWordCount(currentContent);
            }
            
            // Mark all versions as inactive
            scene.versions.forEach(v => v.isActive = false);
            
            // Activate the selected version
            version.isActive = true;
            scene.activeVersionId = version.id;
            
            // Load version content into scene
            scene.content = version.content;
            scene.wordCount = version.wordCount;
            
            saveProject();
            renderSceneVersionsList();
            
            // Refresh editor if this scene is currently open
            if (currentSceneId === scene.id) {
                const act = project.acts.find(a => a.id === currentActId);
                const chapter = act.chapters.find(c => c.id === currentChapterId);
                renderEditor(act, chapter, scene);
                
                // Réattacher les event listeners sur les marqueurs d'annotation
                setTimeout(() => {
                    reattachAnnotationMarkerListeners();
                }, 50);
                
                // Rafraîchir le panneau d'annotations pour la nouvelle version
                const annotationsPanel = document.getElementById('annotationsPanel');
                if (annotationsPanel && annotationsPanel.classList.contains('visible')) {
                    renderAnnotationsPanel();
                }
                updateAnnotationsButton(false);
            }
        }
        
        // Réattacher les event listeners sur les marqueurs d'annotation après changement de version
        function reattachAnnotationMarkerListeners() {
            const markers = document.querySelectorAll('[data-annotation-id]');
            markers.forEach(marker => {
                const annotationId = parseInt(marker.getAttribute('data-annotation-id'));
                marker.style.cursor = 'pointer';
                marker.onclick = function(e) {
                    e.stopPropagation();
                    highlightAnnotation(annotationId);
                };
            });
        }
        
        function deleteSceneVersion(versionId) {
            const current = getCurrentSceneForVersions();
            if (!current) return;
            
            const { scene } = current;
            if (!scene.versions || scene.versions.length <= 1) {
                alert('Impossible de supprimer la dernière version.');
                return;
            }
            
            const version = scene.versions.find(v => v.id === versionId);
            if (!version) return;
            
            if (!confirm(`Supprimer la version ${version.number} ?`)) return;
            
            const wasActive = version.isActive;
            scene.versions = scene.versions.filter(v => v.id !== versionId);
            
            // Renumber remaining versions
            scene.versions.forEach((v, index) => {
                v.number = index + 1;
            });
            
            // If deleted version was active, activate the last one
            if (wasActive && scene.versions.length > 0) {
                const lastVersion = scene.versions[scene.versions.length - 1];
                lastVersion.isActive = true;
                scene.activeVersionId = lastVersion.id;
                scene.content = lastVersion.content;
                scene.wordCount = lastVersion.wordCount;
                
                // Refresh editor
                if (currentSceneId === scene.id) {
                    const act = project.acts.find(a => a.id === currentActId);
                    const chapter = act.chapters.find(c => c.id === currentChapterId);
                    renderEditor(act, chapter, scene);
                }
            }
            
            saveProject();
            renderSceneVersionsList();
        }
        
        function renameSceneVersion(versionId) {
            const current = getCurrentSceneForVersions();
            if (!current) return;
            
            const { scene } = current;
            if (!scene.versions) return;
            
            const version = scene.versions.find(v => v.id === versionId);
            if (!version) return;
            
            const newLabel = prompt('Nom de la version (optionnel):', version.label || '');
            if (newLabel === null) return; // Cancelled
            
            version.label = newLabel.trim();
            saveProject();
            renderSceneVersionsList();
        }
        
        function renderSceneVersionsList() {
            const listContainer = document.getElementById('sceneVersionsList');
            const sceneNameEl = document.getElementById('versionsSceneName');
            const btnNewVersion = document.getElementById('btnNewVersion');
            
            if (!listContainer) return;
            
            const current = getCurrentSceneForVersions();
            
            if (!current) {
                // No scene selected
                sceneNameEl.textContent = 'Aucune scène sélectionnée';
                btnNewVersion.disabled = true;
                listContainer.innerHTML = `
                    <div class="versions-no-scene">
                        <div class="versions-no-scene-icon">📄</div>
                        <div class="versions-no-scene-text">
                            Sélectionnez une scène<br>dans la structure<br>pour voir ses versions
                        </div>
                    </div>
                `;
                return;
            }
            
            const { act, chapter, scene } = current;
            
            // Update scene name
            sceneNameEl.textContent = `${act.title} › ${chapter.title} › ${scene.title}`;
            btnNewVersion.disabled = false;
            
            // Ensure versions array exists
            if (!scene.versions) {
                scene.versions = [];
            }
            
            if (scene.versions.length === 0) {
                listContainer.innerHTML = `
                    <div class="versions-empty">
                        <div class="versions-empty-icon"><i data-lucide="git-branch" style="width:48px;height:48px;"></i></div>
                        <div class="versions-empty-text">
                            Aucune version<br>
                            Créez votre première version pour tester différentes idées
                        </div>
                    </div>
                `;
                return;
            }
            
            // Sort by most recent first
            const sortedVersions = [...scene.versions].sort((a, b) => 
                new Date(b.createdAt) - new Date(a.createdAt)
            );
            
            let html = '';
            sortedVersions.forEach(version => {
                const date = new Date(version.createdAt);
                const dateStr = date.toLocaleDateString('fr-FR');
                const timeStr = date.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' });
                const canCompare = scene.versions.length >= 2;
                const isFinal = version.isFinal === true;
                const finalClass = isFinal ? 'final' : '';
                const activeClass = version.isActive ? 'active' : '';
                
                html += `
                    <div class="version-card ${activeClass} ${finalClass}" 
                         onclick="switchToSceneVersion(${version.id})">
                        <div class="version-card-header">
                            <span class="version-card-number">
                                ${version.number}
                                ${isFinal ? '<span class="version-card-final-badge">Finale</span>' : ''}
                            </span>
                            <div class="version-card-actions">
                                <button class="version-card-btn final ${isFinal ? 'is-final' : ''}" onclick="event.stopPropagation(); toggleFinalVersion(${version.id})" title="${isFinal ? 'Retirer comme version finale' : 'Marquer comme version finale'}">⭐</button>
                                ${canCompare ? `<button class="version-card-btn compare" onclick="event.stopPropagation(); openDiffModal(${version.id})" title="Comparer">🔀</button>` : ''}
                                <button class="version-card-btn" onclick="event.stopPropagation(); renameSceneVersion(${version.id})" title="Renommer">✏️</button>
                                <button class="version-card-btn delete" onclick="event.stopPropagation(); deleteSceneVersion(${version.id})" title="Supprimer">🗑️</button>
                            </div>
                        </div>
                        <div class="version-card-date">${dateStr} ${timeStr}</div>
                        <div class="version-card-stats">${version.wordCount.toLocaleString('fr-FR')} mots</div>
                        ${version.label ? `<div class="version-card-label">${version.label}</div>` : ''}
                    </div>
                `;
            });
            
            listContainer.innerHTML = html;
        }
        
        // Marquer/démarquer une version comme finale
        function toggleFinalVersion(versionId) {
            const current = getCurrentSceneForVersions();
            if (!current) return;
            
            const { scene } = current;
            if (!scene.versions) return;
            
            const version = scene.versions.find(v => v.id === versionId);
            if (!version) return;
            
            if (version.isFinal) {
                // Retirer le statut final
                version.isFinal = false;
                showNotification('Version retirée comme finale');
            } else {
                // Retirer le statut final des autres versions
                scene.versions.forEach(v => v.isFinal = false);
                // Marquer cette version comme finale
                version.isFinal = true;
                showNotification(`⭐ Version "${version.number}" marquée comme finale`);
            }
            
            saveProject();
            renderSceneVersionsList();
        }
        
        // Obtenir le contenu à exporter pour une scène (version finale si existe, sinon contenu actuel)
        function getSceneExportContent(scene) {
            if (scene.versions && scene.versions.length > 0) {
                const finalVersion = scene.versions.find(v => v.isFinal === true);
                if (finalVersion) {
                    return finalVersion.content;
                }
            }
            return scene.content;
        }
        
        // Update scene content when editing (also updates active version)
        function updateSceneContentWithVersion(content) {
            const current = getCurrentSceneForVersions();
            if (!current) return;
            
            const { scene } = current;
            scene.content = content;
            scene.wordCount = getWordCount(content);
            
            // Also update active version if exists
            if (scene.versions && scene.versions.length > 0) {
                const activeVersion = scene.versions.find(v => v.isActive);
                if (activeVersion) {
                    activeVersion.content = content;
                    activeVersion.wordCount = scene.wordCount;
                }
            }
        }



// ========== 22.diff.js ==========
        // ==========================================
        // DIFF VIEWER (Comparaison de versions)
        // ==========================================
        
        let currentDiffView = 'unified';
        let diffVersions = { old: null, new: null };
        
        function openDiffModal(versionId) {
            const current = getCurrentSceneForVersions();
            if (!current || !current.scene.versions || current.scene.versions.length < 2) {
                alert('Il faut au moins 2 versions pour comparer.');
                return;
            }
            
            const versions = current.scene.versions;
            const selectOld = document.getElementById('diffVersionOld');
            const selectNew = document.getElementById('diffVersionNew');
            
            // Remplir les sélecteurs
            selectOld.innerHTML = '';
            selectNew.innerHTML = '';
            
            versions.forEach((v, index) => {
                const label = v.label || `Version ${v.number}`;
                const date = new Date(v.createdAt).toLocaleDateString('fr-FR');
                const optionText = `${label} (${date})`;
                
                selectOld.innerHTML += `<option value="${v.id}">${optionText}</option>`;
                selectNew.innerHTML += `<option value="${v.id}">${optionText}</option>`;
            });
            
            // Sélectionner par défaut : version cliquée vs version active (ou la plus récente)
            const clickedVersion = versions.find(v => v.id === versionId);
            const activeVersion = versions.find(v => v.isActive);
            
            if (clickedVersion && activeVersion && clickedVersion.id !== activeVersion.id) {
                // Comparer la version cliquée avec l'active
                if (clickedVersion.number < activeVersion.number) {
                    selectOld.value = clickedVersion.id;
                    selectNew.value = activeVersion.id;
                } else {
                    selectOld.value = activeVersion.id;
                    selectNew.value = clickedVersion.id;
                }
            } else {
                // Comparer les 2 dernières versions
                const sorted = [...versions].sort((a, b) => b.number - a.number);
                if (sorted.length >= 2) {
                    selectOld.value = sorted[1].id;
                    selectNew.value = sorted[0].id;
                }
            }
            
            document.getElementById('diffModal').style.display = 'flex';
            updateDiff();
        }
        
        function closeDiffModal() {
            document.getElementById('diffModal').style.display = 'none';
        }
        
        function setDiffView(view) {
            currentDiffView = view;
            document.getElementById('btnDiffUnified').classList.toggle('active', view === 'unified');
            document.getElementById('btnDiffSide').classList.toggle('active', view === 'side');
            updateDiff();
        }
        
        function updateDiff() {
            const current = getCurrentSceneForVersions();
            if (!current) return;
            
            const versions = current.scene.versions;
            const oldId = parseInt(document.getElementById('diffVersionOld').value);
            const newId = parseInt(document.getElementById('diffVersionNew').value);
            
            const oldVersion = versions.find(v => v.id === oldId);
            const newVersion = versions.find(v => v.id === newId);
            
            if (!oldVersion || !newVersion) return;
            
            // Extraire le texte brut du HTML
            const oldText = stripHtml(oldVersion.content || '');
            const newText = stripHtml(newVersion.content || '');
            
            // Calculer le diff
            const diff = computeDiff(oldText, newText);
            
            // Afficher les statistiques
            updateDiffStats(diff);
            
            // Afficher le diff selon le mode
            if (currentDiffView === 'unified') {
                renderUnifiedDiff(diff, oldVersion, newVersion);
            } else {
                renderSideBySideDiff(diff, oldVersion, newVersion);
            }
        }
        
        function stripHtml(html) {
            // Remplacer les balises de bloc par des sauts de ligne
            let text = html
                .replace(/<br\s*\/?>/gi, '\n')
                .replace(/<\/p>/gi, '\n\n')
                .replace(/<\/div>/gi, '\n')
                .replace(/<\/h[1-6]>/gi, '\n\n')
                .replace(/<\/li>/gi, '\n')
                .replace(/<\/tr>/gi, '\n');
            
            // Supprimer toutes les autres balises HTML
            const tmp = document.createElement('div');
            tmp.innerHTML = text;
            text = tmp.textContent || tmp.innerText || '';
            
            // Normaliser les sauts de ligne multiples
            text = text.replace(/\n{3,}/g, '\n\n');
            
            return text.trim();
        }
        
        function computeDiff(oldText, newText) {
            // Normaliser les textes - préserver les sauts de ligne comme marqueurs
            const oldWords = tokenizeText(oldText);
            const newWords = tokenizeText(newText);
            
            // Utiliser l'algorithme de Myers (comme git)
            const diff = myersDiff(oldWords, newWords);
            
            // Convertir en format paragraphe unique pour le rendu
            return [{ type: 'paragraph', items: diff }];
        }
        
        function tokenizeText(text) {
            // Diviser le texte en tokens (mots + marqueurs de saut de ligne)
            const tokens = [];
            const lines = text.split(/\n/);
            
            lines.forEach((line, lineIndex) => {
                const words = line.split(/\s+/).filter(w => w.length > 0);
                words.forEach(word => {
                    tokens.push({ word: word, isBreak: false });
                });
                // Ajouter un marqueur de saut de ligne (sauf pour la dernière ligne)
                if (lineIndex < lines.length - 1) {
                    tokens.push({ word: '\n', isBreak: true });
                }
            });
            
            return tokens;
        }
        
        // Algorithme de Myers - le même que git utilise
        function myersDiff(oldTokens, newTokens) {
            const N = oldTokens.length;
            const M = newTokens.length;
            const MAX = N + M;
            
            // Fonction pour comparer deux tokens
            const tokensEqual = (a, b) => {
                if (a.isBreak && b.isBreak) return true;
                if (a.isBreak || b.isBreak) return false;
                return a.word === b.word;
            };
            
            // Cas simples
            if (N === 0 && M === 0) return [];
            if (N === 0) return newTokens.map(t => ({ type: 'added', text: t.word, isBreak: t.isBreak }));
            if (M === 0) return oldTokens.map(t => ({ type: 'removed', text: t.word, isBreak: t.isBreak }));
            
            // V contient les endpoints les plus éloignés pour chaque diagonale
            const V = new Map();
            V.set(1, 0);
            
            // Trace garde l'historique pour reconstruire le chemin
            const trace = [];
            
            // Chercher le chemin le plus court
            let found = false;
            for (let D = 0; D <= MAX && !found; D++) {
                trace.push(new Map(V));
                
                for (let k = -D; k <= D; k += 2) {
                    // Décider si on va vers le bas ou vers la droite
                    let x;
                    if (k === -D || (k !== D && (V.get(k - 1) || 0) < (V.get(k + 1) || 0))) {
                        x = V.get(k + 1) || 0; // Aller vers le bas (insertion)
                    } else {
                        x = (V.get(k - 1) || 0) + 1; // Aller vers la droite (suppression)
                    }
                    
                    let y = x - k;
                    
                    // Suivre la diagonale (éléments identiques)
                    while (x < N && y < M && tokensEqual(oldTokens[x], newTokens[y])) {
                        x++;
                        y++;
                    }
                    
                    V.set(k, x);
                    
                    // Vérifier si on a atteint la fin
                    if (x >= N && y >= M) {
                        found = true;
                        break;
                    }
                }
            }
            
            // Reconstruire le chemin (backtrack)
            const result = [];
            let x = N;
            let y = M;
            
            for (let d = trace.length - 1; d >= 0; d--) {
                const V = trace[d];
                const k = x - y;
                
                let prevK;
                if (k === -d || (k !== d && (V.get(k - 1) || 0) < (V.get(k + 1) || 0))) {
                    prevK = k + 1;
                } else {
                    prevK = k - 1;
                }
                
                const prevX = V.get(prevK) || 0;
                const prevY = prevX - prevK;
                
                // Ajouter les diagonales (éléments identiques)
                while (x > prevX && y > prevY) {
                    x--;
                    y--;
                    result.unshift({ type: 'same', text: oldTokens[x].word, isBreak: oldTokens[x].isBreak });
                }
                
                // Ajouter l'insertion ou la suppression
                if (d > 0) {
                    if (x === prevX) {
                        // Insertion
                        y--;
                        result.unshift({ type: 'added', text: newTokens[y].word, isBreak: newTokens[y].isBreak });
                    } else {
                        // Suppression
                        x--;
                        result.unshift({ type: 'removed', text: oldTokens[x].word, isBreak: oldTokens[x].isBreak });
                    }
                }
            }
            
            return result;
        }
        
        function addParagraphToResult(result, text, type) {
            const words = text.split(/\s+/).filter(w => w.length > 0);
            const items = words.map(word => ({ type: type, text: word }));
            result.push({ type: 'paragraph', status: type, items: items });
        }
        
        function updateDiffStats(diff) {
            let added = 0;
            let removed = 0;
            
            diff.forEach(para => {
                if (para.items) {
                    para.items.forEach(item => {
                        if (item.isBreak) return; // Ignorer les sauts de ligne
                        if (item.type === 'added' && item.text.trim()) added++;
                        if (item.type === 'removed' && item.text.trim()) removed++;
                    });
                }
            });
            
            document.getElementById('diffStats').innerHTML = `
                <span class="diff-stat added">+${added} mot${added > 1 ? 's' : ''} ajouté${added > 1 ? 's' : ''}</span>
                <span class="diff-stat removed">−${removed} mot${removed > 1 ? 's' : ''} supprimé${removed > 1 ? 's' : ''}</span>
            `;
        }
        
        function renderUnifiedDiff(diff, oldVersion, newVersion) {
            const container = document.getElementById('diffContent');
            
            if (diff.length === 0) {
                container.innerHTML = `
                    <div class="diff-empty-state">
                        <div class="diff-empty-state-icon"><i data-lucide="check" style="width:48px;height:48px;"></i></div>
                        <div>Les deux versions sont identiques</div>
                    </div>
                `;
                return;
            }
            
            let html = '<div class="diff-unified">';
            
            diff.forEach((para, paraIndex) => {
                if (paraIndex > 0) html += '<br><br>';
                
                const paraClass = para.status === 'added' ? 'diff-paragraph added' : 
                                  para.status === 'removed' ? 'diff-paragraph removed' : 
                                  'diff-paragraph';
                
                html += `<div class="${paraClass}">`;
                
                if (para.items) {
                    let needSpace = false;
                    para.items.forEach((item) => {
                        // Gérer les sauts de ligne
                        if (item.isBreak) {
                            html += '<br>';
                            needSpace = false;
                            return;
                        }
                        
                        const space = needSpace ? ' ' : '';
                        
                        if (item.type === 'same') {
                            html += space + escapeHtml(item.text);
                        } else if (item.type === 'added') {
                            html += space + `<span class="diff-word added">${escapeHtml(item.text)}</span>`;
                        } else if (item.type === 'removed') {
                            html += space + `<span class="diff-word removed">${escapeHtml(item.text)}</span>`;
                        }
                        needSpace = true;
                    });
                }
                
                html += '</div>';
            });
            
            html += '</div>';
            container.innerHTML = html;
        }
        
        function renderSideBySideDiff(diff, oldVersion, newVersion) {
            const container = document.getElementById('diffContent');
            
            const oldLabel = oldVersion.label || `Version ${oldVersion.number}`;
            const newLabel = newVersion.label || `Version ${newVersion.number}`;
            const oldDate = new Date(oldVersion.createdAt).toLocaleDateString('fr-FR');
            const newDate = new Date(newVersion.createdAt).toLocaleDateString('fr-FR');
            
            let oldHtml = '';
            let newHtml = '';
            
            diff.forEach((para, paraIndex) => {
                if (paraIndex > 0) {
                    oldHtml += '<br><br>';
                    newHtml += '<br><br>';
                }
                
                if (para.status === 'removed') {
                    // Paragraphe supprimé - seulement à gauche
                    oldHtml += '<div class="diff-paragraph removed">';
                    let needSpace = false;
                    para.items.forEach((item) => {
                        if (item.isBreak) {
                            oldHtml += '<br>';
                            needSpace = false;
                            return;
                        }
                        const space = needSpace ? ' ' : '';
                        oldHtml += space + `<span class="diff-word removed">${escapeHtml(item.text)}</span>`;
                        needSpace = true;
                    });
                    oldHtml += '</div>';
                } else if (para.status === 'added') {
                    // Paragraphe ajouté - seulement à droite
                    newHtml += '<div class="diff-paragraph added">';
                    let needSpace = false;
                    para.items.forEach((item) => {
                        if (item.isBreak) {
                            newHtml += '<br>';
                            needSpace = false;
                            return;
                        }
                        const space = needSpace ? ' ' : '';
                        newHtml += space + `<span class="diff-word added">${escapeHtml(item.text)}</span>`;
                        needSpace = true;
                    });
                    newHtml += '</div>';
                } else if (para.status === 'same') {
                    // Paragraphe identique
                    const text = para.items.filter(item => !item.isBreak).map(item => item.text).join(' ');
                    oldHtml += `<div class="diff-paragraph">${escapeHtml(text)}</div>`;
                    newHtml += `<div class="diff-paragraph">${escapeHtml(text)}</div>`;
                } else {
                    // Paragraphe modifié - afficher le diff mot par mot
                    oldHtml += '<div class="diff-paragraph modified">';
                    newHtml += '<div class="diff-paragraph modified">';
                    
                    let oldNeedSpace = false;
                    let newNeedSpace = false;
                    
                    para.items.forEach(item => {
                        if (item.isBreak) {
                            if (item.type === 'same' || item.type === 'removed') {
                                oldHtml += '<br>';
                                oldNeedSpace = false;
                            }
                            if (item.type === 'same' || item.type === 'added') {
                                newHtml += '<br>';
                                newNeedSpace = false;
                            }
                            return;
                        }
                        
                        if (item.type === 'same') {
                            const oldSpace = oldNeedSpace ? ' ' : '';
                            const newSpace = newNeedSpace ? ' ' : '';
                            oldHtml += oldSpace + escapeHtml(item.text);
                            newHtml += newSpace + escapeHtml(item.text);
                            oldNeedSpace = true;
                            newNeedSpace = true;
                        } else if (item.type === 'added') {
                            const space = newNeedSpace ? ' ' : '';
                            newHtml += space + `<span class="diff-word added">${escapeHtml(item.text)}</span>`;
                            newNeedSpace = true;
                        } else if (item.type === 'removed') {
                            const space = oldNeedSpace ? ' ' : '';
                            oldHtml += space + `<span class="diff-word removed">${escapeHtml(item.text)}</span>`;
                            oldNeedSpace = true;
                        }
                    });
                    
                    oldHtml += '</div>';
                    newHtml += '</div>';
                }
            });
            
            container.innerHTML = `
                <div class="diff-side-by-side">
                    <div class="diff-side">
                        <div class="diff-side-header old">
                            <span>${oldLabel}</span>
                            <span style="font-weight: normal; font-size: 0.75rem;">${oldDate} • ${oldVersion.wordCount} mots</span>
                        </div>
                        <div class="diff-side-content">${oldHtml}</div>
                    </div>
                    <div class="diff-side">
                        <div class="diff-side-header new">
                            <span>${newLabel}</span>
                            <span style="font-weight: normal; font-size: 0.75rem;">${newDate} • ${newVersion.wordCount} mots</span>
                        </div>
                        <div class="diff-side-content">${newHtml}</div>
                    </div>
                </div>
            `;
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }



// ========== 23.stats.js ==========

       // Statistics Management
        function renderStats() {
            const editorView = document.getElementById('editorView');
            if (!editorView) {
                console.error('editorView not found');
                return;
            }
            
            // Calculate total words
            const totalWords = project.acts.reduce((sum, act) => {
                return sum + act.chapters.reduce((chSum, chapter) => {
                    return chSum + chapter.scenes.reduce((sceneSum, scene) => {
                        return sceneSum + getWordCount(scene.content);
                    }, 0);
                }, 0);
            }, 0);

            // Calculate today's words
            const today = new Date().toDateString();
            const todaySession = project.stats.writingSessions.find(s => new Date(s.date).toDateString() === today);
            const todayWords = todaySession ? todaySession.words : 0;

            // Progress percentages
            const dailyProgress = Math.min((todayWords / project.stats.dailyGoal) * 100, 100);
            const totalProgress = Math.min((totalWords / project.stats.totalGoal) * 100, 100);

            editorView.innerHTML = `
                <div style="height: 100%; overflow-y: auto; padding: 2rem 3rem;">
                    <h2 style="margin-bottom: 2rem; color: var(--accent-gold);"><i data-lucide="bar-chart-3" style="width:24px;height:24px;vertical-align:middle;margin-right:8px;"></i>Statistiques</h2>
                    
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 2rem;">
                        <div class="stat-box" style="background: var(--bg-secondary); padding: 2rem; border-radius: 8px; border-left: 4px solid var(--accent-gold);">
                            <div style="font-size: 0.9rem; color: var(--text-muted); margin-bottom: 0.5rem;">Total de mots</div>
                            <div style="font-size: 2.5rem; font-weight: 700; color: var(--accent-gold); margin-bottom: 0.5rem;">${totalWords.toLocaleString('fr-FR')}</div>
                            <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 1rem;">sur ${project.stats.totalGoal.toLocaleString('fr-FR')} mots</div>
                            <div style="background: var(--bg-primary); height: 8px; border-radius: 4px; overflow: hidden;">
                                <div style="background: var(--accent-gold); height: 100%; width: ${totalProgress}%; transition: width 0.3s;"></div>
                            </div>
                            <div style="margin-top: 1rem; display: flex; gap: 0.5rem; align-items: center;">
                                <input type="number" class="form-input" value="${project.stats.totalGoal}" 
                                       id="totalGoalInput"
                                       style="flex: 1;" placeholder="Objectif total">
                                <button class="btn btn-small" onclick="updateGoal('totalGoal', document.getElementById('totalGoalInput').value)">Mettre à jour</button>
                            </div>
                        </div>

                        <div class="stat-box" style="background: var(--bg-secondary); padding: 2rem; border-radius: 8px; border-left: 4px solid var(--accent-red);">
                            <div style="font-size: 0.9rem; color: var(--text-muted); margin-bottom: 0.5rem;">Aujourd'hui</div>
                            <div style="font-size: 2.5rem; font-weight: 700; color: var(--accent-red); margin-bottom: 0.5rem;">${todayWords}</div>
                            <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 1rem;">sur ${project.stats.dailyGoal} mots</div>
                            <div style="background: var(--bg-primary); height: 8px; border-radius: 4px; overflow: hidden;">
                                <div style="background: var(--accent-red); height: 100%; width: ${dailyProgress}%; transition: width 0.3s;"></div>
                            </div>
                            <div style="margin-top: 1rem; display: flex; gap: 0.5rem; align-items: center;">
                                <input type="number" class="form-input" value="${project.stats.dailyGoal}" 
                                       id="dailyGoalInput"
                                       style="flex: 1;" placeholder="Objectif quotidien">
                                <button class="btn btn-small" onclick="updateGoal('dailyGoal', document.getElementById('dailyGoalInput').value)">Mettre à jour</button>
                            </div>
                        </div>
                    </div>
                    
                    <div style="margin-top: 2rem;">
                        <h3 style="margin-bottom: 1rem; color: var(--text-primary);">Par acte</h3>
                        <div style="background: var(--bg-secondary); padding: 1.5rem; border-radius: 8px;">
                            ${project.acts.map(act => {
                                const actWords = act.chapters.reduce((sum, chapter) => {
                                    return sum + chapter.scenes.reduce((sceneSum, scene) => {
                                        return sceneSum + getWordCount(scene.content);
                                    }, 0);
                                }, 0);
                                return `
                                    <div style="display: flex; justify-content: space-between; padding: 0.75rem 0; border-bottom: 1px solid var(--border-color);">
                                        <span style="color: var(--text-primary);">${act.title}</span>
                                        <span style="font-weight: 600; color: var(--accent-gold);">${actWords.toLocaleString('fr-FR')} mots</span>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>

                    <div style="margin-top: 2rem;">
                        <h3 style="margin-bottom: 1rem; color: var(--text-primary);">Historique (7 derniers jours)</h3>
                        <div style="background: var(--bg-secondary); padding: 1.5rem; border-radius: 8px;">
                            ${renderWritingHistory()}
                        </div>
                    </div>
                </div>
            `;
        }

        function renderWritingHistory() {
            const last7Days = [];
            for (let i = 6; i >= 0; i--) {
                const date = new Date();
                date.setDate(date.getDate() - i);
                last7Days.push(date);
            }

            return last7Days.map(date => {
                const dateStr = date.toDateString();
                const session = project.stats.writingSessions.find(s => new Date(s.date).toDateString() === dateStr);
                const words = session ? session.words : 0;
                const dayName = date.toLocaleDateString('fr-FR', { weekday: 'short', day: 'numeric', month: 'short' });
                
                return `
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.5rem 0;">
                        <span style="font-size: 0.85rem;">${dayName}</span>
                        <div style="flex: 1; margin: 0 1rem;">
                            <div class="progress-bar" style="height: 4px;">
                                <div class="progress-fill" style="width: ${Math.min((words / project.stats.dailyGoal) * 100, 100)}%; background: ${words >= project.stats.dailyGoal ? 'var(--accent-gold)' : 'var(--text-muted)'}"></div>
                            </div>
                        </div>
                        <span style="font-size: 0.85rem; font-weight: 600; font-family: 'Source Code Pro', monospace;">${words}</span>
                    </div>
                `;
            }).join('');
        }

        function updateGoal(type, value) {
            const numValue = parseInt(value);
            if (numValue && numValue > 0) {
                project.stats[type] = numValue;
                saveProject();
                renderStats();
            }
        }

        function trackWritingSession() {
            // Track writing session for stats
            const today = new Date().toDateString();
            const totalWords = project.acts.reduce((sum, act) => {
                return sum + act.chapters.reduce((chSum, chapter) => {
                    return chSum + chapter.scenes.reduce((sceneSum, scene) => {
                        return sceneSum + getWordCount(scene.content);
                    }, 0);
                }, 0);
            }, 0);

            const sessionIndex = project.stats.writingSessions.findIndex(s => new Date(s.date).toDateString() === today);
            
            if (sessionIndex >= 0) {
                project.stats.writingSessions[sessionIndex].words = totalWords - (project.stats.writingSessions[sessionIndex].startWords || 0);
            } else {
                project.stats.writingSessions.push({
                    date: new Date().toISOString(),
                    words: 0,
                    startWords: totalWords
                });
            }
        }


// ========== 24.codex.js ==========
// ============================================
// Module: views/codex
// Généré automatiquement - Plume Writer
// ============================================

        // Codex Management
        function openAddCodexModal() {
            document.getElementById('addCodexModal').classList.add('active');
            setTimeout(() => document.getElementById('codexTitleInput').focus(), 100);
        }

        function addCodexEntry() {
            const title = document.getElementById('codexTitleInput').value.trim();
            const category = document.getElementById('codexCategoryInput').value;
            const summary = document.getElementById('codexSummaryInput').value.trim();
            
            if (!title) return;

            const entry = {
                id: Date.now(),
                title: title,
                category: category,
                summary: summary || '',
                content: '',
                relatedTo: [] // IDs of related characters, world elements, etc.
            };

            project.codex.push(entry);
            
            // Clear inputs
            document.getElementById('codexTitleInput').value = '';
            document.getElementById('codexSummaryInput').value = '';
            
            closeModal('addCodexModal');
            saveProject();
            renderCodexList();
        }

        function deleteCodexEntry(id) {
            if (!confirm('Êtes-vous sûr de vouloir supprimer cette entrée ?')) return;
            project.codex = project.codex.filter(c => c.id !== id);
            saveProject();
            renderCodexList();
            showEmptyState();
        }

        function renderCodexList() {
            const container = document.getElementById('codexList');
            
            if (project.codex.length === 0) {
                container.innerHTML = '<div style="padding: 1rem; text-align: center; color: var(--text-muted); font-size: 0.85rem;">Aucune entrée</div>';
                return;
            }

            // Group by category
            const groups = {};
            project.codex.forEach(entry => {
                const cat = entry.category || 'Autre';
                if (!groups[cat]) groups[cat] = [];
                groups[cat].push(entry);
            });
            
            // Icons for each category (Mise à jour avec Lucide Icons)
            const catIcons = {
                'Culture': 'palette', // Art/Création
                'Histoire': 'scroll', // Parchemin
                'Technologie': 'cpu', // Processeur/Technologie
                'Géographie': 'globe', // Globe/Carte
                'Politique': 'scale', // Balance (Justice/Politique)
                'Magie/Pouvoir': 'sparkles', // Étincelles/Magie
                'Religion': 'book-open', // Livre ouvert/Écritures
                'Société': 'users', // Utilisateurs/Groupe social
                'Autre': 'file-text' // Document par défaut
            };
            
            // Get collapsed state from localStorage
            const collapsedState = JSON.parse(localStorage.getItem('plume_treeview_collapsed') || '{}');
            
            let html = '';
            Object.keys(groups).sort().forEach(category => {
                const groupKey = 'codex_' + category;
                const isCollapsed = collapsedState[groupKey] === true;
                
                // Sort entries alphabetically within each group
                const sortedEntries = [...groups[category]].sort((a, b) => {
                    return (a.title || '').toLowerCase().localeCompare((b.title || '').toLowerCase(), 'fr');
                });
                
                html += `
                    <div class="treeview-group">
                        <div class="treeview-header" onclick="toggleTreeviewGroup('${groupKey}')">
                            <i data-lucide="${isCollapsed ? 'chevron-right' : 'chevron-down'}" class="treeview-chevron"></i>
                            <span class="treeview-label">${category}</span>
                            <span class="treeview-count">${groups[category].length}</span>
                        </div>
                        <div class="treeview-children ${isCollapsed ? 'collapsed' : ''}">
                            ${sortedEntries.map(entry => {
                                const iconName = catIcons[category] || 'file-text'; // Icône par défaut 'file-text'

                                return `
                                <div class="treeview-item" onclick="openCodexDetail(${entry.id})">
                                    <span class="treeview-item-icon"><i data-lucide="${iconName}" style="width:14px;height:14px;vertical-align:middle;"></i></span>
                                    <span class="treeview-item-label">${entry.title}</span>
                                    <button class="treeview-item-delete" onclick="event.stopPropagation(); deleteCodexEntry(${entry.id})" title="Supprimer">×</button>
                                </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                `;
            });

            container.innerHTML = html;
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }

        function openCodexDetail(id) {
            const entry = project.codex.find(c => c.id === id);
            if (!entry) return;
            
            // Handle split view mode
            if (splitViewActive) {
                const state = splitActivePanel === 'left' ? splitViewState.left : splitViewState.right;
                if (state.view === 'codex') {
                    state.codexId = id;
                    renderSplitPanelViewContent(splitActivePanel);
                    saveSplitViewState();
                    return;
                }
            }
            const editorView = document.getElementById('editorView');
            editorView.innerHTML = `
                <div class="detail-view">
                    <div class="detail-header">
                        <div style="display: flex; align-items: center; gap: 1rem; flex: 1;">
                            <input type="text" class="form-input" value="${entry.title}" 
                                   style="font-size: 1.8rem; font-weight: 600; font-family: 'Noto Serif JP', serif; padding: 0.5rem;"
                                   onchange="updateCodexField(${id}, 'title', this.value)"
                                   placeholder="Titre de l'entrée">
                            <span style="font-size: 0.8rem; padding: 0.4rem 0.8rem; background: var(--accent-gold); color: var(--bg-primary); border-radius: 2px;">${entry.category}</span>
                        </div>
                        <button class="btn" onclick="switchView('editor')">← Retour à l'éditeur</button>
                    </div>
                    
                    <div class="detail-section">
                        <div class="detail-section-title">Catégorie</div>
                        <select class="form-input" onchange="updateCodexField(${id}, 'category', this.value)">
                            <option value="Culture" ${entry.category === 'Culture' ? 'selected' : ''}>Culture</option>
                            <option value="Histoire" ${entry.category === 'Histoire' ? 'selected' : ''}>Histoire</option>
                            <option value="Technologie" ${entry.category === 'Technologie' ? 'selected' : ''}>Technologie</option>
                            <option value="Géographie" ${entry.category === 'Géographie' ? 'selected' : ''}>Géographie</option>
                            <option value="Politique" ${entry.category === 'Politique' ? 'selected' : ''}>Politique</option>
                            <option value="Magie/Pouvoir" ${entry.category === 'Magie/Pouvoir' ? 'selected' : ''}>Magie/Pouvoir</option>
                            <option value="Religion" ${entry.category === 'Religion' ? 'selected' : ''}>Religion</option>
                            <option value="Société" ${entry.category === 'Société' ? 'selected' : ''}>Société</option>
                            <option value="Autre" ${entry.category === 'Autre' ? 'selected' : ''}>Autre</option>
                        </select>
                    </div>

                    <div class="detail-section">
                        <div class="detail-section-title">Résumé</div>
                        <textarea class="form-input" rows="3" 
                                  onchange="updateCodexField(${id}, 'summary', this.value)">${entry.summary}</textarea>
                    </div>

                    <div class="detail-section">
                        <div class="detail-section-title">Contenu détaillé</div>
                        <textarea class="form-input" rows="20" 
                                  oninput="updateCodexField(${id}, 'content', this.value)">${entry.content}</textarea>
                    </div>
                </div>
            `;
        }

        function updateCodexField(id, field, value) {
            const entry = project.codex.find(c => c.id === id);
            if (entry) {
                entry[field] = value;
                saveProject();
                renderCodexList();
            }
        }

        // References and Links Management
        function showReferencesForCharacter(characterId) {
            const character = project.characters.find(c => c.id === characterId);
            if (!character) return;

            const scenes = findScenesWithCharacter(characterId);
            const relatedElements = character.linkedElements || [];

            document.getElementById('referencesModalTitle').textContent = `Références : ${character.name}`;
            document.getElementById('referencesModalContent').innerHTML = `
                <div class="references-section">
                    <div class="references-title"><i data-lucide="file-text" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Scènes où ${character.name} apparaît (${scenes.length})</div>
                    ${scenes.length > 0 ? scenes.map(scene => `
                        <div class="reference-item" onclick="openScene(${scene.actId}, ${scene.chapterId}, ${scene.sceneId}); closeModal('referencesModal');">
                            <div>
                                <div style="font-weight: 600;">${scene.sceneTitle}</div>
                                <div style="font-size: 0.8rem; color: var(--text-muted);">${scene.actTitle} > ${scene.chapterTitle}</div>
                            </div>
                            <span>→</span>
                        </div>
                    `).join('') : '<div style="padding: 1rem; color: var(--text-muted);">Aucune scène liée</div>'}
                </div>

                <div class="references-section">
                    <div class="references-title"><i data-lucide="link" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Gérer les liens</div>
                    <button class="btn btn-small" onclick="openLinkManagerForCharacter(${characterId})">+ Lier à des scènes</button>
                </div>
            `;

            document.getElementById('referencesModal').classList.add('active');
        }

        function findScenesWithCharacter(characterId) {
            const scenes = [];
            project.acts.forEach(act => {
                act.chapters.forEach(chapter => {
                    chapter.scenes.forEach(scene => {
                        if (scene.linkedCharacters && scene.linkedCharacters.includes(characterId)) {
                            scenes.push({
                                actId: act.id,
                                actTitle: act.title,
                                chapterId: chapter.id,
                                chapterTitle: chapter.title,
                                sceneId: scene.id,
                                sceneTitle: scene.title
                            });
                        }
                    });
                });
            });
            return scenes;
        }

        function findScenesWithElement(elementId) {
            const scenes = [];
            project.acts.forEach(act => {
                act.chapters.forEach(chapter => {
                    chapter.scenes.forEach(scene => {
                        if (scene.linkedElements && scene.linkedElements.includes(elementId)) {
                            scenes.push({
                                actId: act.id,
                                actTitle: act.title,
                                chapterId: chapter.id,
                                chapterTitle: chapter.title,
                                sceneId: scene.id,
                                sceneTitle: scene.title
                            });
                        }
                    });
                });
            });
            return scenes;
        }

        function showReferencesForElement(elementId) {
            const element = project.world.find(e => e.id === elementId);
            if (!element) return;

            const scenes = findScenesWithElement(elementId);

            document.getElementById('referencesModalTitle').textContent = `Références : ${element.name}`;
            document.getElementById('referencesModalContent').innerHTML = `
                <div class="references-section">
                    <div class="references-title"><i data-lucide="file-text" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Scènes où ${element.name} apparaît (${scenes.length})</div>
                    ${scenes.length > 0 ? scenes.map(scene => `
                        <div class="reference-item" onclick="openScene(${scene.actId}, ${scene.chapterId}, ${scene.sceneId}); closeModal('referencesModal');">
                            <div>
                                <div style="font-weight: 600;">${scene.sceneTitle}</div>
                                <div style="font-size: 0.8rem; color: var(--text-muted);">${scene.actTitle} > ${scene.chapterTitle}</div>
                            </div>
                            <span>→</span>
                        </div>
                    `).join('') : '<div style="padding: 1rem; color: var(--text-muted);">Aucune scène liée</div>'}
                </div>

                <div class="references-section">
                    <div class="references-title"><i data-lucide="link" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Gérer les liens</div>
                    <button class="btn btn-small" onclick="openLinkManagerForElement(${elementId})">+ Lier à des scènes</button>
                </div>
            `;

            document.getElementById('referencesModal').classList.add('active');
        }

        function toggleCharacterInScene(sceneActId, sceneChapterId, sceneId, characterId) {
            const act = project.acts.find(a => a.id === sceneActId);
            const chapter = act.chapters.find(c => c.id === sceneChapterId);
            const scene = chapter.scenes.find(s => s.id === sceneId);

            if (!scene.linkedCharacters) scene.linkedCharacters = [];

            const index = scene.linkedCharacters.indexOf(characterId);
            if (index > -1) {
                scene.linkedCharacters.splice(index, 1);
            } else {
                scene.linkedCharacters.push(characterId);
            }

            saveProject();
            
            // Rafraîchir le panneau de liens dans l'éditeur si la scène est ouverte
            if (currentSceneId === sceneId && currentActId === sceneActId && currentChapterId === sceneChapterId) {
                const linksPanel = document.getElementById('linksPanel');
                if (linksPanel) {
                    // Trouver le premier div flex (celui des personnages)
                    const flexDivs = linksPanel.querySelectorAll('[style*="flex: 1"]');
                    if (flexDivs.length >= 1) {
                        const charDiv = flexDivs[0];
                        const quickLinks = charDiv.querySelector('.quick-links');
                        if (quickLinks) {
                            quickLinks.innerHTML = `
                                ${renderSceneCharacters(sceneActId, sceneChapterId, scene)}
                                <button class="btn btn-small" onclick="openCharacterLinker(${sceneActId}, ${sceneChapterId}, ${sceneId})" style="font-size: 0.75rem; padding: 0.3rem 0.6rem;">+ Lier</button>
                            `;
                        }
                    }
                }
            }
        }

        /**
         * Ajoute ou retire un élément (Lieu/Objet) d'une scène.
         * NOTE : Cette fonction se trouve généralement dans 04.modals.js ou 07.stats.js
         */
        function toggleElementInScene(sceneActId, sceneChapterId, sceneId, elementId) {
            const act = project.acts.find(a => a.id === sceneActId);
            if (!act) return;
            const chapter = act.chapters.find(c => c.id === sceneChapterId);
            if (!chapter) return;
            const scene = chapter.scenes.find(s => s.id === sceneId);
            if (!scene) return;

            if (!scene.linkedElements) scene.linkedElements = [];

            const index = scene.linkedElements.indexOf(elementId);
            let hasChanged = false; // Drapeau pour s'assurer qu'un changement a eu lieu

            if (index > -1) {
                // L'élément est déjà lié, on le retire (Délier)
                scene.linkedElements.splice(index, 1);
                hasChanged = true;
            } else {
                // L'élément n'est pas lié, on l'ajoute (Lier)
                scene.linkedElements.push(elementId);
                hasChanged = true;
            }

            if (hasChanged) {
                // 1. Sauvegarder les changements
                saveProject();

                // 2. Si la scène est ouverte, on rafraîchit l'affichage complet du panneau des liens
                if (currentSceneId === sceneId && currentActId === sceneActId && currentChapterId === sceneChapterId) {
                    
                    // APPEL CLÉ : Rafraîchit l'ensemble des trois colonnes (persos, lieux, timeline)
                    refreshLinksPanel(); 
                }
            }
        }

// ========== 25.globalSearch.js ==========

        // Global Search
        let searchTimeout = null;

        function performGlobalSearch(query) {
            clearTimeout(searchTimeout);
            
            const resultsContainer = document.getElementById('searchResults');
            
            if (!query || query.trim().length < 2) {
                resultsContainer.classList.remove('active');
                return;
            }

            // Debounce search
            searchTimeout = setTimeout(() => {
                const results = searchEverywhere(query.trim());
                displaySearchResults(results, query.trim());
            }, 300);
        }

        function searchEverywhere(query) {
            const results = [];
            const lowerQuery = query.toLowerCase();

            // Search in scenes
            project.acts.forEach(act => {
                act.chapters.forEach(chapter => {
                    chapter.scenes.forEach(scene => {
                        const temp = document.createElement('div');
                        temp.innerHTML = scene.content;
                        const textContent = temp.textContent || temp.innerText || '';
                        
                        if (scene.title.toLowerCase().includes(lowerQuery) || 
                            textContent.toLowerCase().includes(lowerQuery)) {
                            
                            const matchIndex = textContent.toLowerCase().indexOf(lowerQuery);
                            const preview = matchIndex >= 0 
                                ? getPreview(textContent, matchIndex, query.length)
                                : textContent.substring(0, 150);

                            results.push({
                                type: 'Scène',
                                title: scene.title,
                                path: `${act.title} > ${chapter.title}`,
                                preview: preview,
                                action: () => openScene(act.id, chapter.id, scene.id)
                            });
                        }
                    });
                });
            });

            // Search in characters
            project.characters.forEach(char => {
                const searchText = `${char.name} ${char.role} ${char.description} ${char.personality} ${char.background}`.toLowerCase();
                if (searchText.includes(lowerQuery)) {
                    results.push({
                        type: 'Personnage',
                        title: char.name,
                        path: char.role || 'Personnage',
                        preview: char.description || 'Aucune description',
                        action: () => { switchView('characters'); openCharacterDetail(char.id); }
                    });
                }
            });

            // Search in world elements
            project.world.forEach(element => {
                const searchText = `${element.name} ${element.description} ${element.details}`.toLowerCase();
                if (searchText.includes(lowerQuery)) {
                    results.push({
                        type: 'Univers',
                        title: element.name,
                        path: element.type,
                        preview: element.description || 'Aucune description',
                        action: () => { switchView('world'); openWorldDetail(element.id); }
                    });
                }
            });

            // Search in timeline
            project.timeline.forEach(event => {
                const searchText = `${event.title} ${event.description} ${event.location} ${event.characters}`.toLowerCase();
                if (searchText.includes(lowerQuery)) {
                    results.push({
                        type: 'Chronologie',
                        title: event.title,
                        path: event.date || 'Événement',
                        preview: event.description || 'Aucune description',
                        action: () => { switchView('timeline'); openTimelineDetail(event.id); }
                    });
                }
            });

            // Search in notes
            project.notes.forEach(note => {
                const searchText = `${note.title} ${note.content}`.toLowerCase();
                if (searchText.includes(lowerQuery)) {
                    const matchIndex = note.content.toLowerCase().indexOf(lowerQuery);
                    const preview = matchIndex >= 0 
                        ? getPreview(note.content, matchIndex, query.length)
                        : note.content.substring(0, 150);

                    results.push({
                        type: 'Note',
                        title: note.title,
                        path: note.category,
                        preview: preview,
                        action: () => { switchView('notes'); openNoteDetail(note.id); }
                    });
                }
            });

            // Search in codex
            project.codex.forEach(entry => {
                const searchText = `${entry.title} ${entry.summary} ${entry.content}`.toLowerCase();
                if (searchText.includes(lowerQuery)) {
                    const matchIndex = entry.content.toLowerCase().indexOf(lowerQuery);
                    const preview = matchIndex >= 0 
                        ? getPreview(entry.content, matchIndex, query.length)
                        : entry.summary || entry.content.substring(0, 150);

                    results.push({
                        type: 'Codex',
                        title: entry.title,
                        path: entry.category,
                        preview: preview,
                        action: () => { switchView('codex'); openCodexDetail(entry.id); }
                    });
                }
            });

            return results;
        }

        function getPreview(text, matchIndex, queryLength) {
            const start = Math.max(0, matchIndex - 60);
            const end = Math.min(text.length, matchIndex + queryLength + 90);
            let preview = text.substring(start, end);
            
            if (start > 0) preview = '...' + preview;
            if (end < text.length) preview = preview + '...';
            
            return preview;
        }

        function displaySearchResults(results, query) {
            const container = document.getElementById('searchResults');
            
            if (results.length === 0) {
                container.innerHTML = '<div class="search-no-results">Aucun résultat trouvé</div>';
                container.classList.add('active');
                return;
            }

            const highlightQuery = (text) => {
                const regex = new RegExp(`(${query})`, 'gi');
                return text.replace(regex, '<span class="search-highlight">$1</span>');
            };

            container.innerHTML = results.map((result, index) => `
                <div class="search-result-item" onclick="executeSearchAction(${index}); closeSearchResults();">
                    <div class="search-result-type">${result.type}</div>
                    <div class="search-result-title">${highlightQuery(result.title)}</div>
                    <div class="search-result-path">${result.path}</div>
                    <div class="search-result-preview">${highlightQuery(result.preview)}</div>
                </div>
            `).join('');

            // Store actions for execution
            window.searchResultActions = results.map(r => r.action);

            container.classList.add('active');
        }

        function executeSearchAction(index) {
            if (window.searchResultActions && window.searchResultActions[index]) {
                window.searchResultActions[index]();
            }
        }

        function closeSearchResults() {
            document.getElementById('searchResults').classList.remove('active');
            document.getElementById('globalSearch').value = '';
        }

        // Close search results when clicking outside
        document.addEventListener('click', (e) => {
            const searchContainer = document.querySelector('.search-container');
            if (searchContainer && !searchContainer.contains(e.target)) {
                closeSearchResults();
            }
        });


// ========== 26.focusMode.js ==========

       // Focus Mode Management
        let focusModeActive = false;
        let focusPanelOpen = false;
        let focusStartWordCount = 0;
        
        // Objectif de mots pour le projet (peut être configuré)
        let projectWordGoal = 50000;

        function updateWritingProgress() {
            if (!currentSceneId) return;
            
            const act = project.acts.find(a => a.id === currentActId);
            if (!act) return;
            const chapter = act.chapters.find(c => c.id === currentChapterId);
            if (!chapter) return;
            const scene = chapter.scenes.find(s => s.id === currentSceneId);
            if (!scene) return;
            
            const currentWords = getWordCount(scene.content || '');
            
            // Calculer le total de mots du projet
            const totalProjectWords = project.acts.reduce((sum, a) => 
                sum + a.chapters.reduce((s, ch) => 
                    s + ch.scenes.reduce((sc, scene) => sc + (scene.wordCount || 0), 0), 0), 0);
            
            // Mettre à jour la barre de progression
            const progressPercent = Math.min((totalProjectWords / projectWordGoal) * 100, 100);
            const progressFill = document.getElementById('writingProgressFill');
            if (progressFill) {
                progressFill.style.width = progressPercent + '%';
            }
            
            // Mettre à jour l'indicateur de position
            const positionIndicator = document.getElementById('positionIndicator');
            if (positionIndicator) {
                positionIndicator.textContent = `Mot ${currentWords.toLocaleString()} • Total: ${totalProjectWords.toLocaleString()} / ${projectWordGoal.toLocaleString()}`;
            }
        }

        function toggleFocusMode() {
            console.log('toggleFocusMode called, current state:', focusModeActive);
            
            focusModeActive = !focusModeActive;
            const appContainer = document.querySelector('.app-container');
            const focusBtn = document.querySelector('.focus-toggle-btn');
            
            console.log('App container found:', !!appContainer);
            console.log('Focus button found:', !!focusBtn);
            
            if (focusModeActive) {
                console.log('ACTIVATING FOCUS MODE');
                appContainer.classList.add('focus-mode');
                
                // Track starting word count
                if (currentSceneId) {
                    const act = project.acts.find(a => a.id === currentActId);
                    const chapter = act.chapters.find(c => c.id === currentChapterId);
                    const scene = chapter.scenes.find(s => s.id === currentSceneId);
                    focusStartWordCount = getWordCount(scene.content);
                }
                
                // Mettre à jour les indicateurs
                updateWritingProgress();
                
                // Request fullscreen on app-container
                if (appContainer.requestFullscreen) {
                    appContainer.requestFullscreen().catch((err) => {
                        console.log('Fullscreen not available or denied:', err);
                    });
                }
            } else {
                console.log('DEACTIVATING FOCUS MODE');
                appContainer.classList.remove('focus-mode');
                
                // Forcer la réinitialisation des styles inline si nécessaire
                const sidebar = document.querySelector('.sidebar');
                const sidebarVersions = document.querySelector('.sidebar-versions');
                const appContent = document.querySelector('.app-content');
                const editorContainer = document.querySelector('.editor-container');
                
                if (sidebar) sidebar.style.cssText = '';
                if (sidebarVersions && !sidebarVersions.classList.contains('hidden')) {
                    sidebarVersions.style.cssText = '';
                }
                if (appContent) appContent.style.cssText = '';
                if (editorContainer) editorContainer.style.cssText = '';
                
                // Exit fullscreen
                if (document.exitFullscreen && document.fullscreenElement) {
                    document.exitFullscreen();
                }
                focusPanelOpen = false;
                document.getElementById('focusPanel').classList.remove('active');
            }
        }

        function toggleFocusPanel() {
            focusPanelOpen = !focusPanelOpen;
            const panel = document.getElementById('focusPanel');
            
            if (focusPanelOpen) {
                panel.classList.add('active');
                console.log('Focus panel opened');
            } else {
                panel.classList.remove('active');
                console.log('Focus panel closed');
            }
        }

        function toggleToolbar() {
            const toolbar = document.getElementById('editorToolbar');
            if (toolbar) {
                toolbar.style.display = document.getElementById('hideToolbar').checked ? 'none' : 'flex';
            }
        }

        function toggleLinksPanelVisibility() {
            const linksPanel = document.getElementById('linksPanel');
            if (linksPanel) {
                linksPanel.style.display = document.getElementById('hideLinksPanel').checked ? 'none' : 'block';
            }
        }

        function updateFocusStats() {
            if (!focusModeActive || !currentSceneId) return;
            
            const act = project.acts.find(a => a.id === currentActId);
            const chapter = act.chapters.find(c => c.id === currentChapterId);
            const scene = chapter.scenes.find(s => s.id === currentSceneId);
            
            const currentWordCount = getWordCount(scene.content);
            const wordsWritten = Math.max(0, currentWordCount - focusStartWordCount);
            
            document.getElementById('focusWordCount').textContent = wordsWritten;
        }

        // Pomodoro Timer
        let pomodoroTime = 25 * 60; // 25 minutes in seconds
        let pomodoroInterval = null;
        let pomodoroRunning = false;
        let pomodorosCompleted = 0;

        function togglePomodoroPopup() {
            const popup = document.getElementById('pomodoroPopup');
            popup.classList.toggle('active');
        }
        
        // Fermer la popup si on clique ailleurs
        document.addEventListener('click', function(event) {
            const popup = document.getElementById('pomodoroPopup');
            const btn = document.getElementById('pomodoroHeaderBtn');
            if (popup && btn && !popup.contains(event.target) && !btn.contains(event.target)) {
                popup.classList.remove('active');
            }
        });

        function startPomodoro() {
            if (pomodoroRunning) return;
            
            pomodoroRunning = true;
            // Ajouter indicateur visuel sur le bouton header
            const headerBtn = document.getElementById('pomodoroHeaderBtn');
            if (headerBtn) headerBtn.classList.add('pomodoro-active');
            
            pomodoroInterval = setInterval(() => {
                if (pomodoroTime > 0) {
                    pomodoroTime--;
                    updatePomodoroDisplay();
                } else {
                    // Pomodoro completed
                    completedPomodoro();
                }
            }, 1000);
        }

        function pausePomodoro() {
            pomodoroRunning = false;
            // Retirer indicateur visuel
            const headerBtn = document.getElementById('pomodoroHeaderBtn');
            if (headerBtn) headerBtn.classList.remove('pomodoro-active');
            
            if (pomodoroInterval) {
                clearInterval(pomodoroInterval);
                pomodoroInterval = null;
            }
        }

        function resetPomodoro() {
            pausePomodoro();
            pomodoroTime = 25 * 60;
            updatePomodoroDisplay();
        }

        function completedPomodoro() {
            pausePomodoro();
            pomodorosCompleted++;
            document.getElementById('pomodorosCompleted').textContent = pomodorosCompleted;
            
            // Play notification sound (simple beep)
            playNotificationSound();
            
            // Alert user
            alert('?? Pomodoro terminé ! Temps de faire une pause de 5 minutes.');
            
            // Reset for next session
            pomodoroTime = 25 * 60;
            updatePomodoroDisplay();
        }

        function updatePomodoroDisplay() {
            const minutes = Math.floor(pomodoroTime / 60);
            const seconds = pomodoroTime % 60;
            document.getElementById('pomodoroDisplay').textContent = 
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        function playNotificationSound() {
            // Create a simple beep sound using Web Audio API
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.value = 800;
            oscillator.type = 'sine';
            
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.5);
        }

        // Update focus stats on content change
        const originalUpdateSceneContent = updateSceneContent;
        updateSceneContent = function() {
            originalUpdateSceneContent();
            updateFocusStats();
        };


// ========== 27.keyboardShortcuts.js ==========

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeModal('addChapterModal');
                closeModal('addSceneModal');
                closeModal('addActModal');
                closeModal('addCharacterModal');
                closeModal('addWorldModal');
                closeModal('addTimelineModal');
                closeModal('addNoteModal');
                closeModal('addCodexModal');
                closeModal('backupModal');
                closeModal('referencesModal');
                closeModal('projectsModal');
                closeModal('newProjectModal');
                closeSearchResults();
                
                // Close focus panel if open
                if (focusPanelOpen) {
                    toggleFocusPanel();
                }
            }
            if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
                e.preventDefault();
                document.getElementById('globalSearch').focus();
            }
            if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                e.preventDefault();
                saveProject();
            }
            if (e.key === 'F11') {
                e.preventDefault();
                toggleFocusMode();
            }
            // Raccourci pour le mode révision (Ctrl+R)
            if ((e.ctrlKey || e.metaKey) && e.key === 'r') {
                e.preventDefault();
                if (currentSceneId) {
                    toggleRevisionMode();
                }
            }
        });


// ========== 28.revision.js ==========
        // ============================================
        // REVISION MODE FUNCTIONS
        // ============================================

        function toggleRevisionMode() {
            // Vérifier qu'une scène est ouverte
            if (!currentSceneId) {
                alert('Veuillez d\'abord ouvrir une scène pour activer le mode révision.');
                return;
            }
            
            revisionMode = !revisionMode;
            let toolbar = document.getElementById('editorToolbar');
            if (!toolbar) {
                toolbar = document.querySelector('.editor-toolbar, .revision-toolbar');
            }
            if (!toolbar) {
                console.error('Toolbar not found!');
                alert('Erreur: Barre d\'outils introuvable. Rechargez la page.');
                return;
            }
            const editor = document.querySelector('.editor-textarea');
            const panel = document.getElementById('annotationsPanel');

            if (revisionMode) {
                // Activer le mode révision
                toolbar.className = 'revision-toolbar';
                toolbar.innerHTML = `
                    <span class="revision-badge">✏️ MODE RÉVISION</span>
                    <button class="highlight-btn yellow ${selectedHighlightColor === 'yellow' ? 'active' : ''}" 
                            onclick="selectHighlightColor('yellow')">Jaune</button>
                    <button class="highlight-btn green ${selectedHighlightColor === 'green' ? 'active' : ''}" 
                            onclick="selectHighlightColor('green')">Vert</button>
                    <button class="highlight-btn blue ${selectedHighlightColor === 'blue' ? 'active' : ''}" 
                            onclick="selectHighlightColor('blue')">Bleu</button>
                    <button class="highlight-btn red ${selectedHighlightColor === 'red' ? 'active' : ''}" 
                            onclick="selectHighlightColor('red')">Rouge</button>
                    <button class="highlight-btn purple ${selectedHighlightColor === 'purple' ? 'active' : ''}" 
                            onclick="selectHighlightColor('purple')">Violet</button>
                    <button class="btn" onclick="applyHighlight()">🖍️ Surligner</button>
                    <button class="btn" onclick="removeHighlight()">🗑️ Retirer</button>
                    <button class="btn" onclick="openAnnotationPopup()">💬 Annoter</button>
                    <div style="flex: 1;"></div>
                    <button class="btn btn-primary" onclick="toggleRevisionMode()">✓ Quitter</button>
                `;
                if (editor) editor.contentEditable = 'false';
                // Ne pas afficher automatiquement le panneau
                // L'utilisateur cliquera sur "Voir annotations" s'il le souhaite
            } else {
                // Désactiver le mode révision
                toolbar.className = 'editor-toolbar';
                toolbar.innerHTML = `
                    <!-- Basic formatting -->
                    <div class="toolbar-group">
                        <button class="toolbar-btn" data-format="bold" onclick="formatText('bold')" title="Gras (Ctrl+B)">
                            <strong>B</strong>
                        </button>
                        <button class="toolbar-btn" data-format="italic" onclick="formatText('italic')" title="Italique (Ctrl+I)">
                            <em>I</em>
                        </button>
                        <button class="toolbar-btn" data-format="underline" onclick="formatText('underline')" title="Souligné (Ctrl+U)">
                            <u>U</u>
                        </button>
                        <button class="toolbar-btn" data-format="strikethrough" onclick="formatText('strikeThrough')" title="Barré">
                            <s>S</s>
                        </button>
                    </div>
                    
                    <!-- Font family and size -->
                    <div class="toolbar-group">
                        <select class="font-family-selector" onchange="formatText('fontName', this.value)" title="Police de caractères">
                            <option value="Crimson Pro">Crimson Pro</option>
                            <option value="Arial">Arial</option>
                            <option value="Georgia">Georgia</option>
                            <option value="Times New Roman">Times New Roman</option>
                            <option value="Courier New">Courier New</option>
                            <option value="Verdana">Verdana</option>
                            <option value="Garamond">Garamond</option>
                            <option value="Palatino">Palatino</option>
                        </select>
                        <select class="font-size-selector" onchange="formatText('fontSize', this.value)" title="Taille de police">
                            <option value="1">Très petit</option>
                            <option value="2">Petit</option>
                            <option value="3" selected>Normal</option>
                            <option value="4">Grand</option>
                            <option value="5">Très grand</option>
                            <option value="6">Énorme</option>
                            <option value="7">Gigantesque</option>
                        </select>
                    </div>
                    
                    <!-- Text color -->
                    <div class="toolbar-group">
                        <div class="color-picker-wrapper">
                            <button class="toolbar-btn" onclick="toggleColorPicker('text', event)" title="Couleur du texte">
                                <span style="border-bottom: 3px solid currentColor;">A</span>
                            </button>
                            <div class="color-picker-dropdown" id="textColorPicker">
                                <div class="color-grid" id="textColorGrid"></div>
                                <div class="color-input-wrapper">
                                    <input type="color" id="textColorInput" onchange="applyTextColor(this.value)">
                                    <input type="text" id="textColorHex" placeholder="#000000" maxlength="7" onchange="applyTextColor(this.value)">
                                </div>
                            </div>
                        </div>
                        <div class="color-picker-wrapper">
                            <button class="toolbar-btn" onclick="toggleColorPicker('background', event)" title="Couleur de fond">
                                <span style="background: yellow; padding: 0 4px;">A</span>
                            </button>
                            <div class="color-picker-dropdown" id="backgroundColorPicker">
                                <div class="color-grid" id="backgroundColorGrid"></div>
                                <div class="color-input-wrapper">
                                    <input type="color" id="bgColorInput" onchange="applyBackgroundColor(this.value)">
                                    <input type="text" id="bgColorHex" placeholder="#FFFF00" maxlength="7" onchange="applyBackgroundColor(this.value)">
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Alignment -->
                    <div class="toolbar-group">
                        <button class="toolbar-btn" onclick="formatText('justifyLeft')" title="Aligner à gauche">
                            ⫷
                        </button>
                        <button class="toolbar-btn" onclick="formatText('justifyCenter')" title="Centrer">
                            ⫶
                        </button>
                        <button class="toolbar-btn" onclick="formatText('justifyRight')" title="Aligner à droite">
                            ⫸
                        </button>
                        <button class="toolbar-btn" onclick="formatText('justifyFull')" title="Justifier">
                            ☰
                        </button>
                    </div>
                    
                    <!-- Headings -->
                    <div class="toolbar-group">
                        <button class="toolbar-btn" onclick="formatText('formatBlock', 'h1')" title="Titre 1">H1</button>
                        <button class="toolbar-btn" onclick="formatText('formatBlock', 'h2')" title="Titre 2">H2</button>
                        <button class="toolbar-btn" onclick="formatText('formatBlock', 'h3')" title="Titre 3">H3</button>
                        <button class="toolbar-btn" onclick="formatText('formatBlock', 'p')" title="Paragraphe">P</button>
                    </div>
                    
                    <!-- Lists and quotes -->
                    <div class="toolbar-group">
                        <button class="toolbar-btn" onclick="formatText('insertUnorderedList')" title="Liste à puces">• Liste</button>
                        <button class="toolbar-btn" onclick="formatText('insertOrderedList')" title="Liste numérotée">1. Liste</button>
                        <button class="toolbar-btn" onclick="formatText('formatBlock', 'blockquote')" title="Citation">❝ Citation</button>
                    </div>
                    
                    <!-- Indentation -->
                    <div class="toolbar-group">
                        <button class="toolbar-btn" onclick="formatText('indent')" title="Augmenter l'indentation">→|</button>
                        <button class="toolbar-btn" onclick="formatText('outdent')" title="Diminuer l'indentation">|←</button>
                    </div>
                    
                    <!-- Superscript, subscript -->
                    <div class="toolbar-group">
                        <button class="toolbar-btn" onclick="formatText('superscript')" title="Exposant">x²</button>
                        <button class="toolbar-btn" onclick="formatText('subscript')" title="Indice">x₂</button>
                    </div>
                    
                    <!-- Other -->
                    <div class="toolbar-group">
                        <button class="toolbar-btn" onclick="formatText('insertHorizontalRule')" title="Ligne horizontale">─</button>
                        <button class="toolbar-btn" onclick="formatText('removeFormat')" title="Supprimer le formatage">✕ Format</button>
                    </div>
                    
                    <!-- Revision mode button -->
                    <div class="toolbar-group">
                        <button class="toolbar-btn" onclick="toggleRevisionMode()" title="Mode Révision (Ctrl+R)"><strong>✏️ RÉVISION</strong></button>
                    </div>
                `;
                if (editor) editor.contentEditable = 'true';
                if (panel) panel.classList.remove('visible');
                
                // Réinitialiser les color pickers après reconstruction de la toolbar
                initializeColorPickers();
            }
        }

        function selectHighlightColor(color) {
            selectedHighlightColor = color;
            document.querySelectorAll('.highlight-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`.highlight-btn.${color}`).classList.add('active');
        }

        function applyHighlight() {
            const sel = window.getSelection();
            if (!sel.rangeCount || sel.isCollapsed) {
                alert('Sélectionnez du texte à surligner');
                return;
            }

            const range = sel.getRangeAt(0);
            const span = document.createElement('span');
            span.className = `highlight-${selectedHighlightColor}`;
            
            try {
                range.surroundContents(span);
                updateSceneContent();
            } catch (e) {
                alert('Impossible de surligner cette sélection (essayez une sélection plus simple)');
            }
            
            sel.removeAllRanges();
        }

        function removeHighlight() {
            const sel = window.getSelection();
            if (!sel.rangeCount) {
                alert('Sélectionnez un texte surligné à retirer');
                return;
            }

            const range = sel.getRangeAt(0);
            let node = range.commonAncestorContainer;
            
            if (node.nodeType === 3) {
                node = node.parentElement;
            }

            if (node.className && node.className.includes('highlight-')) {
                const parent = node.parentNode;
                while (node.firstChild) {
                    parent.insertBefore(node.firstChild, node);
                }
                parent.removeChild(node);
                updateSceneContent();
            } else {
                alert('Sélectionnez un texte surligné');
            }

            sel.removeAllRanges();
        }

        function openAnnotationPopup() {
            const sel = window.getSelection();
            if (!sel.rangeCount || sel.isCollapsed) {
                alert('Sélectionnez du texte à annoter');
                return;
            }

            currentSelection = {
                text: sel.toString(),
                range: sel.getRangeAt(0).cloneRange()
            };

            document.getElementById('annotationPopup').classList.add('visible');
            document.getElementById('annotationText').value = '';
            document.getElementById('annotationText').focus();
        }

        function closeAnnotationPopup() {
            document.getElementById('annotationPopup').classList.remove('visible');
            currentSelection = null;
        }

        function selectAnnotationType(type) {
            selectedAnnotationType = type;
            document.querySelectorAll('.annotation-type-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`.annotation-type-btn.${type}`).classList.add('active');
        }

        function saveAnnotation() {
            const text = document.getElementById('annotationText').value.trim();
            if (!text) {
                alert('Veuillez entrer une annotation');
                return;
            }

            const act = project.acts.find(a => a.id === currentActId);
            const chapter = act.chapters.find(c => c.id === currentChapterId);
            const scene = chapter.scenes.find(s => s.id === currentSceneId);

            const annotationId = Date.now();
            
            // Ajouter l'annotation à la version active
            addVersionAnnotation(scene, {
                id: annotationId,
                type: selectedAnnotationType,
                text: text,
                context: currentSelection ? currentSelection.text : '',
                completed: false,
                createdAt: new Date().toISOString()
            });

            // Wrapper le texte sélectionné avec un marqueur
            if (currentSelection && currentSelection.range) {
                try {
                    const span = document.createElement('span');
                    span.id = `annotation-${annotationId}`;
                    span.className = `annotation-marker ${selectedAnnotationType}`;
                    span.setAttribute('data-annotation-id', annotationId);
                    span.style.cursor = 'pointer';
                    span.title = `${getAnnotationTypeLabel(selectedAnnotationType)}: ${text}`;
                    
                    // Définir les styles selon le type
                    const styles = {
                        comment: 'background: rgba(255, 235, 59, 0.3); border-bottom: 2px solid #FBC02D;',
                        question: 'background: rgba(33, 150, 243, 0.3); border-bottom: 2px solid #1976D2;',
                        todo: 'background: rgba(244, 67, 54, 0.3); border-bottom: 2px solid #D32F2F;'
                    };
                    span.style.cssText = styles[selectedAnnotationType] || '';
                    
                    // Wrapper le contenu
                    currentSelection.range.surroundContents(span);
                    
                    // Ajouter un event listener pour cliquer sur le marqueur
                    span.onclick = function(e) {
                        e.stopPropagation();
                        highlightAnnotation(annotationId);
                    };
                    
                    // IMPORTANT: Mettre à jour le contenu de la scène ET de la version active avec le nouveau HTML
                    const editor = document.getElementById('sceneEditor') || document.querySelector('.editor-textarea');
                    if (editor) {
                        scene.content = editor.innerHTML;
                        // Mettre à jour aussi le contenu de la version active
                        const activeVersion = getActiveVersion(scene);
                        if (activeVersion) {
                            activeVersion.content = editor.innerHTML;
                        }
                    }
                } catch (e) {
                    console.warn('Impossible de wrapper le texte:', e);
                }
            }

            saveProject();
            closeAnnotationPopup();
            renderAnnotationsPanel();
            renderActsList();
        }

        function renderAnnotationsPanel() {
            const panel = document.getElementById('annotationsPanelContent');
            const parentPanel = document.getElementById('annotationsPanel');
            
            if (!panel || !parentPanel) {
                console.error('Panneau annotations introuvable');
                return;
            }
            
            // Vérifier qu'une scène est sélectionnée
            if (!currentSceneId || !currentChapterId || !currentActId) {
                panel.innerHTML = `
                    <div class="annotations-panel-header">
                        <h3 style="margin: 0;">Annotations</h3>
                        <span class="annotations-panel-close" onclick="closeAnnotationsPanel()" title="Fermer">×</span>
                    </div>
                    <p style="text-align: center; color: var(--text-muted); padding: 2rem;">Sélectionnez une scène pour voir ses annotations</p>
                `;
                parentPanel.classList.add('visible');
                return;
            }
            
            const act = project.acts.find(a => a.id === currentActId);
            const chapter = act ? act.chapters.find(c => c.id === currentChapterId) : null;
            const scene = chapter ? chapter.scenes.find(s => s.id === currentSceneId) : null;
            
            if (!scene) {
                panel.innerHTML = `
                    <div class="annotations-panel-header">
                        <h3 style="margin: 0;">Annotations</h3>
                        <span class="annotations-panel-close" onclick="closeAnnotationsPanel()" title="Fermer">×</span>
                    </div>
                    <p style="text-align: center; color: var(--text-muted); padding: 2rem;">Scène introuvable</p>
                `;
                parentPanel.classList.add('visible');
                return;
            }
            
            // Migrer les anciennes annotations si nécessaire
            migrateSceneAnnotationsToVersion(scene);

            // Obtenir les annotations de la version active
            const annotations = getVersionAnnotations(scene);
            const activeVersion = getActiveVersion(scene);
            const versionLabel = activeVersion ? (activeVersion.label || `Version ${activeVersion.number}`) : '';

            if (!annotations || annotations.length === 0) {
                panel.innerHTML = `
                    <div class="annotations-panel-header">
                        <h3 style="margin: 0;">Annotations (0)</h3>
                        <span class="annotations-panel-close" onclick="closeAnnotationsPanel()" title="Fermer">×</span>
                    </div>
                    ${versionLabel ? `<div style="font-size: 0.75rem; color: var(--text-muted); padding: 0.5rem 1rem; background: var(--bg-tertiary); border-bottom: 1px solid var(--border-color);">📌 ${versionLabel}</div>` : ''}
                    <p style="text-align: center; color: var(--text-muted); padding: 2rem;">Aucune annotation pour cette version</p>
                `;
            } else {
                panel.innerHTML = `
                    <div class="annotations-panel-header">
                        <h3 style="margin: 0;">Annotations (${annotations.length})</h3>
                        <span class="annotations-panel-close" onclick="closeAnnotationsPanel()" title="Fermer">×</span>
                    </div>
                    ${versionLabel ? `<div style="font-size: 0.75rem; color: var(--text-muted); padding: 0.5rem 1rem; background: var(--bg-tertiary); border-bottom: 1px solid var(--border-color);">📌 ${versionLabel}</div>` : ''}
                    ${annotations.map(a => `
                        <div class="annotation-card ${a.type}" onclick="scrollToAnnotation(${a.id})">
                            <div class="annotation-type ${a.type}">${getAnnotationTypeLabel(a.type)}</div>
                            <div class="annotation-content">${a.text}</div>
                            ${a.context ? `<div class="annotation-context">"${a.context}"</div>` : ''}
                            ${a.type === 'todo' ? `
                                <button class="btn btn-small ${a.completed ? 'btn-primary' : ''}" 
                                        onclick="event.stopPropagation(); toggleAnnotationComplete(${a.id})" 
                                        style="margin-top: 0.5rem;">
                                    ${a.completed ? '✓ Terminé' : '○ À faire'}
                                </button>
                            ` : ''}
                            <button class="btn btn-small" onclick="event.stopPropagation(); deleteAnnotation(${a.id})" 
                                    style="margin-top: 0.5rem;">Supprimer</button>
                        </div>
                    `).join('')}
                `;
            }

            // Afficher le panneau
            parentPanel.classList.add('visible');
        }



        function toggleAnnotationsPanel() {
            const panel = document.getElementById('annotationsPanel');
            if (panel.classList.contains('visible')) {
                panel.classList.remove('visible');
                updateAnnotationsButton(false);
            } else {
                renderAnnotationsPanel();
                updateAnnotationsButton(true);
            }
        }

        function closeAnnotationsPanel() {
            const panel = document.getElementById('annotationsPanel');
            if (panel) {
                panel.classList.remove('visible');
                updateAnnotationsButton(false);
            }
        }
        
        function updateAnnotationsButton(isOpen) {
            const toolbarBtn = document.getElementById('toolbarAnnotationsBtn');
            const sidebarBtn = document.getElementById('sidebarAnnotationsBtn');
            const sidebarBadge = document.getElementById('annotationsBadge');
            const todosBadge = document.getElementById('todosBadge');
            
            // Compter les annotations et TODOs de la scène courante (version active)
            let annotationCount = 0;
            let todoCount = 0;
            
            if (currentSceneId) {
                const act = project.acts.find(a => a.id === currentActId);
                if (act) {
                    const chapter = act.chapters.find(c => c.id === currentChapterId);
                    if (chapter) {
                        const scene = chapter.scenes.find(s => s.id === currentSceneId);
                        if (scene) {
                            const annotations = getVersionAnnotations(scene);
                            annotationCount = annotations.length;
                            todoCount = annotations.filter(a => a.type === 'todo' && !a.completed).length;
                        }
                    }
                }
            }
            
            // Compter tous les TODOs non complétés du projet (toutes versions actives)
            let totalTodos = 0;
            project.acts.forEach(act => {
                act.chapters.forEach(chapter => {
                    chapter.scenes.forEach(scene => {
                        const annotations = getVersionAnnotations(scene);
                        totalTodos += annotations.filter(a => a.type === 'todo' && !a.completed).length;
                    });
                });
            });
            
            // Mettre à jour le badge toolbar
            if (toolbarBtn) {
                if (annotationCount > 0) {
                    toolbarBtn.classList.add('has-annotations');
                    toolbarBtn.setAttribute('data-count', annotationCount > 9 ? '9+' : annotationCount);
                } else {
                    toolbarBtn.classList.remove('has-annotations');
                    toolbarBtn.removeAttribute('data-count');
                }
                
                if (isOpen) {
                    toolbarBtn.classList.add('panel-open');
                } else {
                    toolbarBtn.classList.remove('panel-open');
                }
            }
            
            // Mettre à jour le bouton sidebar annotations
            if (sidebarBtn) {
                if (isOpen) {
                    sidebarBtn.classList.add('active');
                } else {
                    sidebarBtn.classList.remove('active');
                }
            }
            
            // Mettre à jour le badge sidebar annotations
            if (sidebarBadge) {
                if (annotationCount > 0) {
                    sidebarBadge.style.display = 'inline';
                    sidebarBadge.textContent = annotationCount > 9 ? '9+' : annotationCount;
                } else {
                    sidebarBadge.style.display = 'none';
                }
            }
            
            // Mettre à jour le badge sidebar TODOs
            if (todosBadge) {
                if (totalTodos > 0) {
                    todosBadge.style.display = 'inline';
                    todosBadge.textContent = totalTodos > 9 ? '9+' : totalTodos;
                } else {
                    todosBadge.style.display = 'none';
                }
            }
        }

        function getAnnotationTypeLabel(type) {
            const labels = {
                comment: 'Commentaire',
                todo: 'TODO',
                note: 'Note',
                question: 'Question'
            };
            return labels[type] || type;
        }

        // ============ ANNOTATIONS LIÉES AUX VERSIONS ============
        
        // Obtenir la version active d'une scène (ou créer une version par défaut)
        function getActiveVersion(scene) {
            if (!scene.versions || scene.versions.length === 0) {
                return null;
            }
            return scene.versions.find(v => v.isActive) || scene.versions[scene.versions.length - 1];
        }
        
        // Obtenir les annotations de la version active
        function getVersionAnnotations(scene) {
            const activeVersion = getActiveVersion(scene);
            if (activeVersion) {
                if (!activeVersion.annotations) {
                    activeVersion.annotations = [];
                }
                return activeVersion.annotations;
            }
            // Fallback: annotations au niveau scène (anciennes données)
            if (!scene.annotations) {
                scene.annotations = [];
            }
            return scene.annotations;
        }
        
        // Ajouter une annotation à la version active
        function addVersionAnnotation(scene, annotation) {
            const activeVersion = getActiveVersion(scene);
            if (activeVersion) {
                if (!activeVersion.annotations) {
                    activeVersion.annotations = [];
                }
                activeVersion.annotations.push(annotation);
            } else {
                // Fallback si pas de version
                if (!scene.annotations) {
                    scene.annotations = [];
                }
                scene.annotations.push(annotation);
            }
        }
        
        // Supprimer une annotation de la version active
        function removeVersionAnnotation(scene, annotationId) {
            const activeVersion = getActiveVersion(scene);
            if (activeVersion && activeVersion.annotations) {
                activeVersion.annotations = activeVersion.annotations.filter(a => a.id !== annotationId);
            } else if (scene.annotations) {
                scene.annotations = scene.annotations.filter(a => a.id !== annotationId);
            }
        }
        
        // Trouver une annotation dans la version active
        function findVersionAnnotation(scene, annotationId) {
            const annotations = getVersionAnnotations(scene);
            return annotations.find(a => a.id === annotationId);
        }
        
        // Migrer les annotations d'une scène vers sa version active (migration one-time)
        function migrateSceneAnnotationsToVersion(scene) {
            if (scene.annotations && scene.annotations.length > 0) {
                const activeVersion = getActiveVersion(scene);
                if (activeVersion) {
                    if (!activeVersion.annotations) {
                        activeVersion.annotations = [];
                    }
                    // Migrer seulement si la version n'a pas déjà ces annotations
                    scene.annotations.forEach(ann => {
                        if (!activeVersion.annotations.find(a => a.id === ann.id)) {
                            activeVersion.annotations.push(ann);
                        }
                    });
                    // Vider les annotations au niveau scène après migration
                    scene.annotations = [];
                    return true; // Migration effectuée
                }
            }
            return false;
        }
        
        // ============ FIN ANNOTATIONS LIÉES AUX VERSIONS ============

        function toggleAnnotationComplete(annotationId) {
            const act = project.acts.find(a => a.id === currentActId);
            const chapter = act.chapters.find(c => c.id === currentChapterId);
            const scene = chapter.scenes.find(s => s.id === currentSceneId);
            const annotation = findVersionAnnotation(scene, annotationId);

            if (annotation) {
                annotation.completed = !annotation.completed;
                saveProject();
                renderAnnotationsPanel();
                renderActsList();
            }
        }

        function deleteAnnotation(annotationId) {
            if (!confirm('Supprimer cette annotation ?')) return;

            const act = project.acts.find(a => a.id === currentActId);
            const chapter = act.chapters.find(c => c.id === currentChapterId);
            const scene = chapter.scenes.find(s => s.id === currentSceneId);

            // Supprimer le marqueur visuel dans l'éditeur
            const marker = document.getElementById(`annotation-${annotationId}`);
            if (marker) {
                // Remplacer le span par son contenu textuel
                const textContent = marker.textContent;
                const textNode = document.createTextNode(textContent);
                marker.parentNode.replaceChild(textNode, marker);
                
                // Mettre à jour le contenu de la scène avec le HTML nettoyé
                const editor = document.querySelector('.editor-textarea');
                if (editor) {
                    scene.content = editor.innerHTML;
                    // Mettre à jour aussi la version active
                    const activeVersion = getActiveVersion(scene);
                    if (activeVersion) {
                        activeVersion.content = editor.innerHTML;
                    }
                }
            }
            
            // Aussi nettoyer dans scene.content si le marqueur est sauvegardé (fallback)
            if (scene.content) {
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = scene.content;
                const savedMarker = tempDiv.querySelector(`#annotation-${annotationId}, [data-annotation-id="${annotationId}"]`);
                if (savedMarker) {
                    const textContent = savedMarker.textContent;
                    const textNode = document.createTextNode(textContent);
                    savedMarker.parentNode.replaceChild(textNode, savedMarker);
                    scene.content = tempDiv.innerHTML;
                }
            }

            // Supprimer l'annotation de la version active
            removeVersionAnnotation(scene, annotationId);
            
            // Mettre à jour aussi le contenu de la version active (fallback)
            const activeVersion = getActiveVersion(scene);
            if (activeVersion && activeVersion.content) {
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = activeVersion.content;
                const versionMarker = tempDiv.querySelector(`#annotation-${annotationId}, [data-annotation-id="${annotationId}"]`);
                if (versionMarker) {
                    const textContent = versionMarker.textContent;
                    const textNode = document.createTextNode(textContent);
                    versionMarker.parentNode.replaceChild(textNode, versionMarker);
                    activeVersion.content = tempDiv.innerHTML;
                }
            }
            
            saveProject();
            renderAnnotationsPanel();
            renderActsList();
            showNotification('✓ Annotation supprimée');
        }

        function scrollToAnnotation(annotationId) {
            // NE PAS fermer le panneau - l'utilisateur veut peut-être voir plusieurs annotations
            
            // Trouver le marqueur dans le texte
            const marker = document.getElementById(`annotation-${annotationId}`);
            
            if (marker) {
                // Trouver le conteneur scrollable de l'éditeur
                const editorWorkspace = document.querySelector('.editor-workspace');
                
                if (editorWorkspace) {
                    // Calculer la position relative du marqueur
                    const markerRect = marker.getBoundingClientRect();
                    const workspaceRect = editorWorkspace.getBoundingClientRect();
                    
                    // Calculer le scroll nécessaire pour centrer le marqueur
                    const targetScroll = editorWorkspace.scrollTop + (markerRect.top - workspaceRect.top) - (workspaceRect.height / 2);
                    
                    editorWorkspace.scrollTo({
                        top: Math.max(0, targetScroll),
                        behavior: 'smooth'
                    });
                }
                
                // Highlighter temporairement
                highlightAnnotation(annotationId);
            } else {
                // Si le marqueur n'existe pas (ancienne annotation), juste informer
                console.warn(`Marqueur annotation-${annotationId} introuvable`);
                showNotification('Annotation non localisée dans le texte');
            }
        }
        
        function highlightAnnotation(annotationId) {
            const marker = document.getElementById(`annotation-${annotationId}`);
            if (!marker) return;
            
            // Sauvegarder le style original
            const originalStyle = marker.style.cssText;
            
            // Ajouter une animation de highlight
            marker.style.cssText = originalStyle + ' background: rgba(212, 175, 55, 0.8) !important; transition: background 0.3s;';
            
            // Pulser 3 fois
            let pulseCount = 0;
            const pulseInterval = setInterval(() => {
                if (pulseCount >= 6) {
                    clearInterval(pulseInterval);
                    // Restaurer le style original
                    marker.style.cssText = originalStyle;
                    return;
                }
                
                if (pulseCount % 2 === 0) {
                    marker.style.cssText = originalStyle + ' background: rgba(212, 175, 55, 0.8) !important;';
                } else {
                    marker.style.cssText = originalStyle;
                }
                pulseCount++;
            }, 400);
        }
        
        function closeAnnotationsPanel() {
            const panel = document.getElementById('annotationsPanel');
            if (panel) {
                panel.classList.remove('visible');
            }
        }



// ========== 29.todos.js ==========
        // ==========================================
        // TODOS PANEL
        // ==========================================
        
        function toggleTodosPanel() {
            const panel = document.getElementById('todosPanel');
            const btn = document.getElementById('sidebarTodosBtn');
            
            if (panel.classList.contains('visible')) {
                panel.classList.remove('visible');
                if (btn) btn.classList.remove('active');
            } else {
                renderTodosPanel();
                panel.classList.add('visible');
                if (btn) btn.classList.add('active');
            }
        }
        
        function closeTodosPanel() {
            const panel = document.getElementById('todosPanel');
            const btn = document.getElementById('sidebarTodosBtn');
            if (panel) {
                panel.classList.remove('visible');
            }
            if (btn) btn.classList.remove('active');
        }
        
        function renderTodosPanel() {
            const panel = document.getElementById('todosPanelContent');
            const parentPanel = document.getElementById('todosPanel');
            
            if (!panel || !parentPanel) {
                console.error('Panneau TODOs introuvable');
                return;
            }
            
            // Collecter tous les TODOs du projet (de la version active de chaque scène)
            const todos = [];
            project.acts.forEach(act => {
                act.chapters.forEach(chapter => {
                    chapter.scenes.forEach(scene => {
                        const annotations = getVersionAnnotations(scene);
                        annotations
                            .filter(a => a.type === 'todo')
                            .forEach(todo => {
                                todos.push({
                                    ...todo,
                                    actId: act.id,
                                    actTitle: act.title,
                                    chapterId: chapter.id,
                                    chapterTitle: chapter.title,
                                    sceneId: scene.id,
                                    sceneTitle: scene.title
                                });
                            });
                    });
                });
            });
            
            const pendingTodos = todos.filter(t => !t.completed);
            const completedTodos = todos.filter(t => t.completed);
            
            if (todos.length === 0) {
                panel.innerHTML = `
                    <div class="annotations-panel-header">
                        <h3 style="margin: 0;"><i data-lucide="check-square" style="width:18px;height:18px;vertical-align:middle;margin-right:6px;"></i>TODOs (0)</h3>
                        <span class="annotations-panel-close" onclick="closeTodosPanel()" title="Fermer">×</span>
                    </div>
                    <p style="text-align: center; color: var(--text-muted); padding: 2rem;">Aucun TODO dans le projet</p>
                `;
            } else {
                panel.innerHTML = `
                    <div class="annotations-panel-header">
                        <h3 style="margin: 0;"><i data-lucide="check-square" style="width:18px;height:18px;vertical-align:middle;margin-right:6px;"></i>TODOs (${pendingTodos.length} actif${pendingTodos.length > 1 ? 's' : ''})</h3>
                        <span class="annotations-panel-close" onclick="closeTodosPanel()" title="Fermer">×</span>
                    </div>
                    
                    ${pendingTodos.length > 0 ? `
                        <div style="margin-bottom: 1rem;">
                            <div style="font-size: 0.75rem; font-weight: 600; color: var(--text-muted); margin-bottom: 0.5rem; text-transform: uppercase;">À faire</div>
                            ${pendingTodos.map(todo => `
                                <div class="annotation-card todo" onclick="goToTodoScene(${todo.actId}, ${todo.chapterId}, ${todo.sceneId})" style="cursor: pointer;">
                                    <div style="font-size: 0.7rem; color: var(--text-muted); margin-bottom: 0.25rem;">${todo.sceneTitle}</div>
                                    <div class="annotation-content">${todo.text}</div>
                                    <div style="display: flex; gap: 0.5rem; margin-top: 0.5rem;">
                                        <button class="btn btn-small" onclick="event.stopPropagation(); toggleTodoFromPanel(${todo.actId}, ${todo.chapterId}, ${todo.sceneId}, ${todo.id})">
                                            Marquer terminé
                                        </button>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    ` : ''}
                    
                    ${completedTodos.length > 0 ? `
                        <div>
                            <div style="font-size: 0.75rem; font-weight: 600; color: var(--text-muted); margin-bottom: 0.5rem; text-transform: uppercase;">Terminés (${completedTodos.length})</div>
                            ${completedTodos.map(todo => `
                                <div class="annotation-card" style="opacity: 0.6; cursor: pointer;" onclick="goToTodoScene(${todo.actId}, ${todo.chapterId}, ${todo.sceneId})">
                                    <div style="font-size: 0.7rem; color: var(--text-muted); margin-bottom: 0.25rem;">${todo.sceneTitle}</div>
                                    <div class="annotation-content" style="text-decoration: line-through;">${todo.text}</div>
                                    <div style="display: flex; gap: 0.5rem; margin-top: 0.5rem;">
                                        <button class="btn btn-small" onclick="event.stopPropagation(); toggleTodoFromPanel(${todo.actId}, ${todo.chapterId}, ${todo.sceneId}, ${todo.id})">
                                            Rouvrir
                                        </button>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    ` : ''}
                `;
            }
            
            // Afficher le panneau
            parentPanel.classList.add('visible');
            
            // Rafraîchir les icônes Lucide
            setTimeout(() => {
                if (typeof lucide !== 'undefined') lucide.createIcons();
            }, 10);
        }
        
        function goToTodoScene(actId, chapterId, sceneId) {
            openScene(actId, chapterId, sceneId);
            closeTodosPanel();
        }
        
        function toggleTodoFromPanel(actId, chapterId, sceneId, todoId) {
            const act = project.acts.find(a => a.id === actId);
            if (!act) return;
            const chapter = act.chapters.find(c => c.id === chapterId);
            if (!chapter) return;
            const scene = chapter.scenes.find(s => s.id === sceneId);
            if (!scene) return;
            
            const todo = findVersionAnnotation(scene, todoId);
            if (todo) {
                todo.completed = !todo.completed;
                saveProject();
                renderTodosPanel();
                updateAnnotationsButton(false);
                renderActsList();
            }
        }

        function getSceneAnnotationCount(scene) {
            const annotations = getVersionAnnotations(scene);
            return annotations.length;
        }

        function getSceneTodoCount(scene) {
            const annotations = getVersionAnnotations(scene);
            return annotations.filter(a => a.type === 'todo' && !a.completed).length;
        }

        // Modifier la fonction renderEditor pour ajouter le bouton révision
        const originalRenderEditor = renderEditor;
        renderEditor = function(act, chapter, scene) {
            originalRenderEditor(act, chapter, scene);
            
            // Ajouter le bouton révision dans la toolbar si pas déjà en mode révision
            if (!revisionMode) {
                const toolbar = document.getElementById('editorToolbar');
                if (toolbar && !toolbar.querySelector('[onclick*="toggleRevisionMode"]')) {
                    const revisionGroup = document.createElement('div');
                    revisionGroup.className = 'toolbar-group';
                    revisionGroup.innerHTML = '<button class="toolbar-btn" onclick="toggleRevisionMode()" title="Mode Révision (Ctrl+R)"><i data-lucide="pencil" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>RÉVISION</button>';
                    try {
                        toolbar.appendChild(revisionGroup);
                    } catch(e) {
                        console.error('Erreur appendChild toolbar:', e);
                    }
                }
            }
            
            // Rafraîchir les icônes Lucide après le rendu
            setTimeout(() => {
                if (typeof lucide !== 'undefined') lucide.createIcons();
                // Réattacher les event listeners sur les marqueurs d'annotation
                reattachAnnotationMarkerListeners();
            }, 10);
        };

        // Modifier renderActsList pour afficher les badges d'annotations
        const originalRenderActsList = renderActsList;
        renderActsList = function() {
            originalRenderActsList();
            
            // Ajouter les badges d'annotations aux scènes (version active)
            project.acts.forEach(act => {
                act.chapters.forEach(chapter => {
                    chapter.scenes.forEach(scene => {
                        const sceneElement = document.querySelector(`[data-scene-id="${scene.id}"]`);
                        const annotations = getVersionAnnotations(scene);
                        if (sceneElement && annotations.length > 0) {
                            const annotCount = annotations.length;
                            const todoCount = annotations.filter(a => a.type === 'todo' && !a.completed).length;
                            
                            let badgeHTML = `<span class="scene-badge">${annotCount}</span>`;
                            if (todoCount > 0) {
                                badgeHTML += `<span class="scene-badge" style="background: var(--accent-red);">✓${todoCount}</span>`;
                            }
                            
                            const textSpan = sceneElement.querySelector('div > span:not(.drag-handle)');
                            if (textSpan && !textSpan.querySelector('.scene-badge')) {
                                textSpan.innerHTML += badgeHTML;
                            }
                        }
                    });
                });
            });
        };

        // Initialiser les annotations dans les scènes existantes (migration vers versions)
        function ensureAnnotationsStructure() {
            let needsSave = false;
            project.acts.forEach(act => {
                act.chapters.forEach(chapter => {
                    chapter.scenes.forEach(scene => {
                        // Migrer les anciennes annotations vers la version active
                        if (migrateSceneAnnotationsToVersion(scene)) {
                            needsSave = true;
                        }
                    });
                });
            });
            if (needsSave) {
                saveProject();
                console.log('Migration des annotations vers les versions effectuée');
            }
        }

        // Appeler au chargement
        const originalInit = init;
        init = function() {
            originalInit();
            ensureAnnotationsStructure();
        };

        // ============================================
        // TODO LIST VIEW
        // ============================================



        function renderTodosList() {
            // Afficher dans editorView au lieu de la sidebar
            const editorView = document.getElementById('editorView');
            if (!editorView) {
                console.error('editorView not found');
                return;
            }
            
            // Collecter tous les TODOs (de la version active de chaque scène)
            const todos = [];
            project.acts.forEach(act => {
                act.chapters.forEach(chapter => {
                    chapter.scenes.forEach(scene => {
                        const annotations = getVersionAnnotations(scene);
                        annotations.filter(a => a.type === 'todo').forEach(todo => {
                            todos.push({
                                ...todo,
                                actId: act.id,
                                actTitle: act.title,
                                chapterId: chapter.id,
                                chapterTitle: chapter.title,
                                sceneId: scene.id,
                                sceneTitle: scene.title
                            });
                        });
                    });
                });
            });
            
            // Trier: non terminés d'abord
            todos.sort((a, b) => {
                if (a.completed === b.completed) return 0;
                return a.completed ? 1 : -1;
            });
            
            if (todos.length === 0) {
                editorView.innerHTML = '<div style="height: 100%; overflow-y: auto; padding: 3rem; text-align: center; color: var(--text-muted); font-size: 1.2rem;">📝 Aucun TODO<br><br><small style="font-size: 0.9rem;">Les TODOs apparaissent lorsque vous utilisez le mode révision</small></div>';
            } else {
                editorView.innerHTML = `
                    <div style="height: 100%; overflow-y: auto; padding: 2rem 3rem;">
                        <h2 style="margin-bottom: 2rem; color: var(--accent-gold);"><i data-lucide="check-square" style="width:24px;height:24px;vertical-align:middle;margin-right:8px;"></i>TODOs (${todos.filter(t => !t.completed).length} actifs)</h2>
                        <div style="display: flex; flex-direction: column; gap: 1rem;">
                        ${todos.map(todo => `
                            <div class="todo-item" onclick="openSceneFromTodo(${todo.actId}, ${todo.chapterId}, ${todo.sceneId})" 
                                 style="display: flex; gap: 1rem; padding: 1rem; background: var(--bg-secondary); border-left: 3px solid ${todo.completed ? 'var(--text-muted)' : 'var(--accent-gold)'}; border-radius: 4px; cursor: pointer; transition: all 0.2s;">
                                <input type="checkbox" ${todo.completed ? 'checked' : ''} 
                                       onclick="event.stopPropagation(); toggleTodoFromList(${todo.id}, ${todo.actId}, ${todo.chapterId}, ${todo.sceneId})"
                                       style="margin-top: 0.25rem;">
                                <div style="flex: 1;">
                                    <div style="font-size: 1rem; ${todo.completed ? 'text-decoration: line-through; opacity: 0.6;' : 'font-weight: 500;'}">${todo.text}</div>
                                    <div style="font-size: 0.85rem; color: var(--text-muted); margin-top: 0.5rem;">
                                        📍 ${todo.actTitle} › ${todo.chapterTitle} › ${todo.sceneTitle}
                                    </div>
                                </div>
                            </div>
                        `).join('')}
                        </div>
                    </div>
                `;
            }
        }

        function toggleTodoFromList(todoId, actId, chapterId, sceneId) {
            const act = project.acts.find(a => a.id === actId);
            const chapter = act.chapters.find(c => c.id === chapterId);
            const scene = chapter.scenes.find(s => s.id === sceneId);
            const todo = findVersionAnnotation(scene, todoId);
            
            if (todo) {
                todo.completed = !todo.completed;
                saveProject();
                renderTodosList();
                renderActsList();
            }
        }

        function openSceneFromTodo(actId, chapterId, sceneId) {
            switchView('editor');
            openScene(actId, chapterId, sceneId);
        }

        // ============================================
        // FIN REVISION MODE
        // ============================================

        // Initialize on load

        // Calculer la hauteur de la toolbar pour le panneau d'annotations
        function updateAnnotationsPanelPosition() {
            const header = document.querySelector('.editor-header');
            const toolbar = document.querySelector('.editor-toolbar, .revision-toolbar');
            const linksPanel = document.getElementById('linksPanel');
            const panel = document.getElementById('annotationsPanel');
            
            if (header && toolbar && panel) {
                let totalHeight = header.offsetHeight + toolbar.offsetHeight;
                if (linksPanel && linksPanel.style.display !== 'none') {
                    totalHeight += linksPanel.offsetHeight;
                }
                panel.style.setProperty('--toolbar-height', totalHeight + 'px');
            }
        }
        
        // Appeler lors de l'ouverture du panneau
        const originalRenderAnnotationsPanel = renderAnnotationsPanel;
        renderAnnotationsPanel = function() {
            originalRenderAnnotationsPanel();
            setTimeout(updateAnnotationsPanelPosition, 50);
        };




// ========== 30.corkboard.js ==========
        // ============================================
        // CORK BOARD FUNCTIONS
        // ============================================
        
        let corkBoardFilter = {
            type: 'all', // 'all', 'act', 'chapter'
            actId: null,
            chapterId: null
        };
        
        function renderCorkBoard() {
            const container = document.getElementById('corkboardList');
            
            // Construire les options de chapitres
            let chaptersOptions = '';
            if (corkBoardFilter.actId) {
                const act = project.acts.find(a => a.id === parseInt(corkBoardFilter.actId));
                if (act) {
                    chaptersOptions = act.chapters.map(ch => 
                        `<option value="${ch.id}" ${corkBoardFilter.chapterId == ch.id ? 'selected' : ''}>${ch.title}</option>`
                    ).join('');
                }
            }
            
            container.innerHTML = `
                <div style="padding: 1.5rem;">
                    <div style="margin-bottom: 1.5rem;">
                        <h3 style="margin-bottom: 0.5rem;"><i data-lucide="layout-grid" style="width:18px;height:18px;vertical-align:middle;margin-right:6px;"></i>Tableau Cork Board</h3>
                        <p style="font-size: 0.85rem; color: var(--text-muted);">
                            Organisez vos scènes visuellement
                        </p>
                    </div>
                    
                    <div style="margin-bottom: 1rem;">
                        <label style="font-size: 0.85rem; color: var(--text-muted); display: block; margin-bottom: 0.5rem;">
                            Filtrer par acte :
                        </label>
                        <select id="corkActFilter" class="form-input" onchange="updateCorkActFilter(this.value)">
                            <option value="all" ${corkBoardFilter.type === 'all' ? 'selected' : ''}>Tous les actes</option>
                            ${project.acts.map(act => 
                                `<option value="${act.id}" ${corkBoardFilter.actId == act.id ? 'selected' : ''}>${act.title}</option>`
                            ).join('')}
                        </select>
                    </div>
                    
                    ${corkBoardFilter.actId ? `
                        <div style="margin-bottom: 1rem;">
                            <label style="font-size: 0.85rem; color: var(--text-muted); display: block; margin-bottom: 0.5rem;">
                                Filtrer par chapitre :
                            </label>
                            <select id="corkChapterFilter" class="form-input" onchange="updateCorkChapterFilter(this.value)">
                                <option value="all">Tous les chapitres de cet acte</option>
                                ${chaptersOptions}
                            </select>
                        </div>
                    ` : ''}
                    
                    <button class="btn btn-primary" style="width: 100%;" onclick="openCorkBoardView()">
                        Ouvrir le tableau
                    </button>
                </div>
            `;
        }
        
        function updateCorkActFilter(actId) {
            if (actId === 'all') {
                corkBoardFilter = { type: 'all', actId: null, chapterId: null };
            } else {
                corkBoardFilter = { type: 'act', actId: parseInt(actId), chapterId: null };
            }
            renderCorkBoard();
        }
        
        function updateCorkChapterFilter(chapterId) {
            if (chapterId === 'all') {
                corkBoardFilter.type = 'act';
                corkBoardFilter.chapterId = null;
            } else {
                corkBoardFilter.type = 'chapter';
                corkBoardFilter.chapterId = parseInt(chapterId);
            }
            renderCorkBoard();
        }
        
        function filterAndRefreshCork(actId, chapterId) {
            if (actId === 'all') {
                corkBoardFilter = { type: 'all', actId: null, chapterId: null };
            } else if (chapterId === 'all' || !chapterId) {
                corkBoardFilter = { type: 'act', actId: parseInt(actId), chapterId: null };
            } else {
                corkBoardFilter = { type: 'chapter', actId: parseInt(actId), chapterId: parseInt(chapterId) };
            }
            openCorkBoardView();
        }
        

        function closeCorkBoardView() {
            switchView('corkboard');
            renderCorkBoard();
        }

        function openCorkBoardView() {
            // Ouvrir la vue Cork Board dans l'éditeur
            const editorView = document.getElementById('editorView');
            editorView.innerHTML = renderCorkBoardFullView();
            
            // Setup drag and drop
            setupCorkBoardDragAndDrop();
        }
        
        function renderCorkBoardFullView() {
            // Collecter toutes les scènes selon le filtre
            let scenes = [];
            
            if (corkBoardFilter.type === 'all') {
                project.acts.forEach(act => {
                    act.chapters.forEach(chapter => {
                        chapter.scenes.forEach(scene => {
                            scenes.push({
                                ...scene,
                                actId: act.id,
                                actTitle: act.title,
                                chapterId: chapter.id,
                                chapterTitle: chapter.title
                            });
                        });
                    });
                });
            } else if (corkBoardFilter.type === 'act') {
                const act = project.acts.find(a => a.id === corkBoardFilter.actId);
                if (act) {
                    act.chapters.forEach(chapter => {
                        chapter.scenes.forEach(scene => {
                            scenes.push({
                                ...scene,
                                actId: act.id,
                                actTitle: act.title,
                                chapterId: chapter.id,
                                chapterTitle: chapter.title
                            });
                        });
                    });
                }
            } else if (corkBoardFilter.type === 'chapter') {
                const act = project.acts.find(a => a.id === corkBoardFilter.actId);
                if (act) {
                    const chapter = act.chapters.find(c => c.id === corkBoardFilter.chapterId);
                    if (chapter) {
                        chapter.scenes.forEach(scene => {
                            scenes.push({
                                ...scene,
                                actId: act.id,
                                actTitle: act.title,
                                chapterId: chapter.id,
                                chapterTitle: chapter.title
                            });
                        });
                    }
                }
            }
            
            // Vue organisée par actes et chapitres (style plume_locale)
            if (project.acts.length === 0 || (project.acts.length === 1 && project.acts[0].chapters.length === 0)) {
                return `
                    <div class="cork-board-container">
                        <div class="cork-board-header">
                            <div class="cork-board-title"><i data-lucide="layout-grid" style="width:16px;height:16px;vertical-align:middle;margin-right:6px;"></i>Cork Board</div>
                            <button class="btn btn-primary" onclick="closeCorkBoardView()">← Retour</button>
                        </div>
                        <div class="cork-board-empty">
                            <div class="cork-board-empty-icon"><i data-lucide="layout-grid" style="width:48px;height:48px;"></i></div>
                            <div style="font-size: 1.2rem; margin-bottom: 0.5rem;">Aucun chapitre</div>
                            <div style="margin-bottom: 1rem;">Créez votre premier chapitre pour commencer à structurer votre histoire</div>
                            <button class="btn btn-primary" onclick="openAddChapterModal()">+ Créer un chapitre</button>
                        </div>
                    </div>
                `;
            }
            
            // Compter le total de chapitres
            const totalChapters = project.acts.reduce((sum, act) => sum + act.chapters.length, 0);
            
            // Vue organisée par actes et chapitres
            let html = `
                <div class="cork-board-container" style="min-height: 100vh; padding: 2rem;">
                    <div class="cork-board-header" style="margin-bottom: 2rem;">
                        <div class="cork-board-title">
                            <i data-lucide="list" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Vue Structure Organisée
                        </div>
                        
                        <div style="display: flex; align-items: center; gap: 1rem; margin-left: auto; margin-right: 1rem;">
                            <label style="font-size: 0.8rem; color: var(--text-muted); display: flex; align-items: center; gap: 0.5rem;">
                                <i data-lucide="zoom-in" style="width:16px;height:16px;"></i>
                                <input type="range" 
                                       min="150" 
                                       max="800" 
                                       value="300" 
                                       step="10"
                                       style="width: 120px; cursor: pointer;"
                                       oninput="updateCorkGridSize(this.value)"
                                       title="Ajuster la largeur des colonnes">
                            </label>
                        </div>
                        <div style="display: flex; gap: 0.5rem;">
                            <button class="btn btn-primary" onclick="closeCorkBoardView()">← Retour</button>
                        </div>
                    </div>
                    
                    <div style="display: flex; flex-direction: column; gap: 2rem;">
            `;
            
            // Générer les actes
            project.acts.forEach((act, actIndex) => {
                const actScenes = scenes.filter(s => s.actId === act.id);
                // Ne pas masquer les actes vides - les afficher quand même
                
                html += `
                    <div class="structured-act-container">
                        <div class="structured-act-header">
                            <button class="structured-collapse-btn" onclick="toggleStructuredAct(${act.id})">
                                <span class="collapse-icon" id="collapse-icon-${act.id}">▼</span>
                            </button>
                            <span class="structured-act-title">${act.title}</span>
                            <button class="btn btn-primary" onclick="createChapterFromCork(${act.id})">+ Nouveau Chapitre</button>
                            <span class="structured-count">${act.chapters.length} chapitre${act.chapters.length > 1 ? 's' : ''}</span>
                        </div>
                        
                        <div class="structured-chapters-grid" id="act-content-${act.id}">
                `;
                
                // Générer les chapitres de l'acte
                act.chapters.forEach((chapter, chapIndex) => {
                    const chapterScenes = actScenes.filter(s => s.chapterId === chapter.id);
                    
                    html += `
                        <div class="structured-chapter-container">
                            <div class="structured-chapter-header">
                                <div style="display: flex; align-items: center; gap: 0.5rem;">
                                    <span class="structured-chapter-icon">::</span>
                                    <span class="structured-chapter-title">${chapter.title}</span>
                                </div>
                            </div>
                            
                            <div class="structured-scenes-list">
                    `;
                    
                    // Générer les scènes du chapitre
                    chapterScenes.forEach((scene, sceneIndex) => {
                        const synopsis = scene.synopsis || '';
                        const wordCount = scene.content ? scene.content.split(/\s+/).filter(w => w.length > 0).length : 0;
                        const color = scene.corkColor || 'default';
                        
                        html += `
                            <div class="structured-scene-card structured-color-${color}" 
                                 data-scene-id="${scene.id}"
                                 data-act-id="${scene.actId}"
                                 data-chapter-id="${scene.chapterId}"
                                 draggable="true"
                                 onclick="openSceneFromCork(${scene.actId}, ${scene.chapterId}, ${scene.id})">
                                <div class="structured-scene-header">
                                    <span class="structured-scene-icon">::</span>
                                    <span class="structured-scene-title">${scene.title}</span>
                                </div>
                                
                                <div class="structured-scene-synopsis" 
                                     contenteditable="true"
                                     onclick="event.stopPropagation()"
                                     onblur="updateSceneSynopsis(${scene.actId}, ${scene.chapterId}, ${scene.id}, this.innerText)"
                                     data-placeholder="Ajouter un résumé...">${synopsis}</div>
                                
                                <div class="structured-scene-meta" style="font-size: 0.75rem; color: var(--text-muted); margin-top: 0.5rem;">
                                    ${wordCount} mots
                                </div>
                            </div>
                        `;
                    });
                    
                    // Bouton + Nouvelle Scène
                    html += `
                                <button class="structured-add-scene-btn" onclick="openAddSceneModalFromCork(${act.id}, ${chapter.id})">
                                    <span style="font-size: 1.2rem;">+</span> Nouvelle Scène
                                </button>
                            </div>
                        </div>
                    `;
                });
                
                // Si l'acte n'a pas de chapitres, afficher un message
                if (act.chapters.length === 0) {
                    html += `
                        <div style="padding: 2rem; text-align: center; color: var(--bg-primary); opacity: 0.7; font-style: italic;">
                            Cet acte est vide. Cliquez sur "+ Nouveau Chapitre" pour commencer.
                        </div>
                    `;
                }
                
                html += `
                        </div>
                    </div>
                `;
            });
            
            html += `
                    </div>
                    
                    <div class="structured-bottom-actions">
                        <button class="btn btn-primary" onclick="createActFromCork()">+ Ajouter un Acte</button>
                    </div>
                </div>
            `;
            
            return html;
        }
        
        function renderCorkCard(scene, index) {
            const wordCount = scene.content ? getWordCount(scene.content) : 0;
            const synopsis = scene.synopsis || 'Pas de synopsis';
            const color = scene.corkColor || 'default';
            
            return `
                <div class="cork-card cork-color-${color}" 
                     data-scene-id="${scene.id}"
                     data-act-id="${scene.actId}"
                     data-chapter-id="${scene.chapterId}"
                     draggable="true">
                    <div class="cork-card-header">
                        <div class="cork-card-number">#${index + 1}</div>
                        <div style="position: relative;">
                            <div class="cork-card-color-tag cork-color-${color}" 
                                 onclick="toggleColorPalette(${scene.id})"></div>
                            <div class="cork-color-palette" id="palette-${scene.id}">
                                <div class="cork-color-option cork-color-yellow" onclick="setCorkColor(${scene.actId}, ${scene.chapterId}, ${scene.id}, 'yellow')"></div>
                                <div class="cork-color-option cork-color-pink" onclick="setCorkColor(${scene.actId}, ${scene.chapterId}, ${scene.id}, 'pink')"></div>
                                <div class="cork-color-option cork-color-blue" onclick="setCorkColor(${scene.actId}, ${scene.chapterId}, ${scene.id}, 'blue')"></div>
                                <div class="cork-color-option cork-color-green" onclick="setCorkColor(${scene.actId}, ${scene.chapterId}, ${scene.id}, 'green')"></div>
                                <div class="cork-color-option cork-color-purple" onclick="setCorkColor(${scene.actId}, ${scene.chapterId}, ${scene.id}, 'purple')"></div>
                                <div class="cork-color-option cork-color-orange" onclick="setCorkColor(${scene.actId}, ${scene.chapterId}, ${scene.id}, 'orange')"></div>
                                <div class="cork-color-option cork-color-red" onclick="setCorkColor(${scene.actId}, ${scene.chapterId}, ${scene.id}, 'red')"></div>
                                <div class="cork-color-option cork-color-teal" onclick="setCorkColor(${scene.actId}, ${scene.chapterId}, ${scene.id}, 'teal')"></div>
                                <div class="cork-color-option cork-color-default" onclick="setCorkColor(${scene.actId}, ${scene.chapterId}, ${scene.id}, 'default')">
                                    <span style="font-size: 1.2rem;">×</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="cork-card-title">${scene.title}</div>
                    
                    <div class="cork-card-synopsis" 
                         contenteditable="true" 
                         onblur="updateSceneSynopsis(${scene.actId}, ${scene.chapterId}, ${scene.id}, this.innerText)"
                         data-placeholder="Cliquez pour ajouter un synopsis...">${synopsis}</div>
                    
                    <div class="cork-card-meta">
                        <span>📍 ${scene.chapterTitle}</span>
                        <span>${wordCount} mots</span>
                    </div>
                    
                    <div class="cork-card-actions">
                        <button class="btn btn-small" onclick="openSceneFromCork(${scene.actId}, ${scene.chapterId}, ${scene.id})">
                            ✏️ Éditer
                        </button>
                    </div>
                </div>
            `;
        }
        
        function toggleColorPalette(sceneId) {
            // Fermer toutes les autres palettes
            document.querySelectorAll('.cork-color-palette').forEach(p => {
                if (p.id !== `palette-${sceneId}`) {
                    p.classList.remove('visible');
                }
            });
            
            const palette = document.getElementById(`palette-${sceneId}`);
            if (palette) {
                palette.classList.toggle('visible');
            }
        }
        
        function setCorkColor(actId, chapterId, sceneId, color) {
            const act = project.acts.find(a => a.id === actId);
            if (!act) return;
            
            const chapter = act.chapters.find(c => c.id === chapterId);
            if (!chapter) return;
            
            const scene = chapter.scenes.find(s => s.id === sceneId);
            if (!scene) return;
            
            scene.corkColor = color;
            saveProject();
            
            // Fermer la palette et re-render
            toggleColorPalette(sceneId);
            openCorkBoardView();
        }
        
        function updateSceneSynopsis(actId, chapterId, sceneId, synopsis) {
            const act = project.acts.find(a => a.id === actId);
            if (!act) return;
            
            const chapter = act.chapters.find(c => c.id === chapterId);
            if (!chapter) return;
            
            const scene = chapter.scenes.find(s => s.id === sceneId);
            if (!scene) return;
            
            scene.synopsis = synopsis;
            saveProject();
        }
        
        function openSceneFromCork(actId, chapterId, sceneId) {
            switchView('editor');
            openScene(actId, chapterId, sceneId);
        }
        
        function toggleStructuredAct(actId) {
            const content = document.getElementById(`act-content-${actId}`);
            const icon = document.getElementById(`collapse-icon-${actId}`);
            
            if (content.style.display === 'none') {
                content.style.display = 'grid';
                icon.textContent = '▼';
            } else {
                content.style.display = 'none';
                icon.textContent = '▶';
            }
        }
        
        function createChapterFromCork(actId) {
            // Sélectionner l'acte
            activeActId = actId;
            currentActId = actId;
            
            // Trouver l'acte
            const act = project.acts.find(a => a.id === actId);
            if (!act) return;
            
            // Demander le nom du chapitre
            const chapterTitle = prompt('Nom du nouveau chapitre:', `Chapitre ${act.chapters.length + 1}`);
            if (!chapterTitle || chapterTitle.trim() === '') return;
            
            // Créer le chapitre
            const newChapter = {
                id: Date.now(),
                title: chapterTitle.trim(),
                scenes: []
            };
            
            // Ajouter le chapitre à l'acte
            act.chapters.push(newChapter);
            
            // Sauvegarder
            saveProject();
            
            // Rafraîchir la sidebar (treeview)
            if (typeof renderActsList === 'function') renderActsList();
            
            // Rafraîchir la vue Cork Board
            openCorkBoardView();
            
            // Notification
            showNotification(`✓ Chapitre "${chapterTitle}" créé`);
        }
        
        function openAddSceneModalFromCork(actId, chapterId) {
            // Trouver l'acte et le chapitre
            const act = project.acts.find(a => a.id === actId);
            if (!act) return;
            
            const chapter = act.chapters.find(c => c.id === chapterId);
            if (!chapter) return;
            
            // Demander le nom de la scène
            const sceneTitle = prompt('Nom de la nouvelle scène:', `Scène ${chapter.scenes.length + 1}`);
            if (!sceneTitle || sceneTitle.trim() === '') return;
            
            // Créer la scène
            const newScene = {
                id: Date.now(),
                title: sceneTitle.trim(),
                content: '',
                synopsis: '',
                characters: [],
                locations: [],
                notes: ''
            };
            
            // Ajouter la scène au chapitre
            chapter.scenes.push(newScene);
            
            // Sauvegarder
            saveProject();
            
            // Rafraîchir la sidebar (treeview)
            if (typeof renderActsList === 'function') renderActsList();
            
            // Rafraîchir la vue Cork Board
            openCorkBoardView();
            
            // Notification
            showNotification(`✓ Scène "${sceneTitle}" créée`);
        }
        
        function createActFromCork() {
            // Demander le nom de l'acte
            const actTitle = prompt('Nom du nouvel acte:', `Acte ${project.acts.length + 1}`);
            if (!actTitle || actTitle.trim() === '') return;
            
            // Créer l'acte
            const newAct = {
                id: Date.now(),
                title: actTitle.trim(),
                chapters: []
            };
            
            // Ajouter l'acte au projet
            project.acts.push(newAct);
            
            // Sauvegarder
            saveProject();
            
            // Rafraîchir la sidebar (treeview)
            if (typeof renderActsList === 'function') renderActsList();
            
            // Rafraîchir la vue Cork Board
            openCorkBoardView();
            
            // Notification
            showNotification(`✓ Acte "${actTitle}" créé`);
        }
        
        function toggleSceneMenu(sceneId) {
            // À implémenter : menu contextuel pour la scène
            console.log('Toggle menu for scene:', sceneId);
        }
        
        function openCreateFromOutlineModal() {
            alert('Fonctionnalité "Create from Outline" à venir');
        }
        
        function showImportOptions() {
            alert('Fonctionnalité "Import" à venir');
        }
        
        function showActions() {
            alert('Fonctionnalité "Actions" à venir');
        }
        
        function setupCorkBoardDragAndDrop() {
            const cards = document.querySelectorAll('.cork-card, .structured-scene-card');
            
            cards.forEach(card => {
                card.addEventListener('dragstart', handleCorkDragStart);
                card.addEventListener('dragend', handleCorkDragEnd);
                card.addEventListener('dragover', handleCorkDragOver);
                card.addEventListener('drop', handleCorkDrop);
            });
        }
        
        let draggedCorkCard = null;
        
        function handleCorkDragStart(e) {
            draggedCorkCard = this;
            this.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
        }
        
        function handleCorkDragEnd(e) {
            this.classList.remove('dragging');
            draggedCorkCard = null;
        }
        
        function handleCorkDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
        }
        

        function showNotification(message) {
            const notif = document.createElement('div');
            notif.style.cssText = `
                position: fixed;
                top: 2rem;
                right: 2rem;
                background: var(--accent-gold);
                color: white;
                padding: 1rem 2rem;
                border-radius: 4px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                z-index: 10000;
                font-weight: 600;
                animation: slideIn 0.3s ease;
            `;
            notif.textContent = message;
            document.body.appendChild(notif);
            
            setTimeout(() => {
                notif.style.animation = 'slideOut 0.3s ease';
                setTimeout(() => notif.remove(), 300);
            }, 2000);
        }

        function handleCorkDrop(e) {
            e.preventDefault();
            
            if (!draggedCorkCard || draggedCorkCard === this) return;
            
            // Récupérer les IDs
            const draggedSceneId = parseInt(draggedCorkCard.dataset.sceneId);
            const draggedActId = parseInt(draggedCorkCard.dataset.actId);
            const draggedChapterId = parseInt(draggedCorkCard.dataset.chapterId);
            
            const targetSceneId = parseInt(this.dataset.sceneId);
            const targetActId = parseInt(this.dataset.actId);
            const targetChapterId = parseInt(this.dataset.chapterId);
            
            // Vérifier qu'on est dans le même chapitre
            if (draggedChapterId !== targetChapterId) {
                alert('Vous ne pouvez déplacer des scènes que dans le même chapitre.\n\nPour déplacer entre chapitres, utilisez la vue Structure (sidebar).');
                return;
            }
            
            // Trouver les objets
            const act = project.acts.find(a => a.id === draggedActId);
            if (!act) return;
            
            const chapter = act.chapters.find(c => c.id === draggedChapterId);
            if (!chapter) return;
            
            const draggedSceneIndex = chapter.scenes.findIndex(s => s.id === draggedSceneId);
            const targetSceneIndex = chapter.scenes.findIndex(s => s.id === targetSceneId);
            
            if (draggedSceneIndex === -1 || targetSceneIndex === -1) return;
            
            // Réorganiser dans le tableau
            const [draggedScene] = chapter.scenes.splice(draggedSceneIndex, 1);
            chapter.scenes.splice(targetSceneIndex, 0, draggedScene);
            
            // Sauvegarder
            saveProject();
            renderActsList();
            
            // Rafraîchir le Cork Board
            openCorkBoardView();
            
            // Notification
            showNotification('✓ Scènes réorganisées');
        }
        
        // Fonction pour redimensionner les colonnes dynamiquement
        function updateCorkGridSize(value) {
            // On applique la variable à la racine du document pour qu'elle soit accessible partout
            document.documentElement.style.setProperty('--chapter-card-width', value + 'px');
            
            // Optionnel : Mettre à jour un label si vous en ajoutez un pour afficher la taille
            const label = document.getElementById('gridSizeLabel');
            if (label) label.textContent = value + 'px';
        }
        // ============================================
        // FIN CORK BOARD
        // ============================================

// ========== 31.mindmap.js ==========
        // ============================================
        // NOUVELLES FONCTIONNALITÉS DE VISUALISATION
        // ============================================
        
        // Initialiser les données de visualisation si elles n'existent pas
        if (!project.mindmapNodes) project.mindmapNodes = [];
        if (!project.plotPoints) project.plotPoints = [];
        if (!project.relationships) project.relationships = [];
        if (!project.mapLocations) project.mapLocations = [];
        if (!project.mapImage) project.mapImage = null;
        if (!project.visualTimeline) project.visualTimeline = [];
        
        // ============================================
        // ========================================
        // MINDMAP SYSTEM - Custom drag & drop mindmaps
        // ========================================

        let mindmapState = {
            zoom: 1,
            panX: 0,
            panY: 0,
            isDragging: false,
            draggedNode: null,
            selectedNode: null,
            isPanning: false,
            lastMouseX: 0,
            lastMouseY: 0,
            linkStart: null,
            libraryCollapsed: false,
            activeLibraryTab: 'characters'
        };

        function renderMindmapView() {
            const container = document.getElementById('mindmapList');
            if (!container) return;

            // Initialiser mindmaps si nécessaire
            if (!project.mindmaps) {
                project.mindmaps = [];
            }

            container.innerHTML = `
                <div class="mindmap-sidebar-header">
                    <h3 style="margin-bottom: 0.5rem; font-size: 1.1rem;">🗺️ Mindmaps</h3>
                    <button class="btn btn-small" onclick="createNewMindmap()" style="width: 100%;">
                        ➕ Nouvelle Mindmap
                    </button>
                </div>
                <div class="mindmap-list">
                    ${project.mindmaps.length === 0 ? `
                        <div style="padding: 1rem; text-align: center; color: var(--text-muted); font-size: 0.9rem;">
                            Aucune mindmap.<br>Créez-en une !
                        </div>
                    ` : project.mindmaps.map(mm => `
                        <div class="mindmap-item ${currentMindmapId === mm.id ? 'active' : ''}" 
                             onclick="selectMindmap(${mm.id})">
                            <span style="flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
                                ${mm.title}
                            </span>
                            <span onclick="event.stopPropagation(); deleteMindmap(${mm.id})" 
                                  style="cursor: pointer; color: var(--accent-red); opacity: 0.7; padding: 0 0.5rem;"
                                  title="Supprimer">×</span>
                        </div>
                    `).join('')}
                </div>
            `;

            renderMindmapCanvas();
        }

        function createNewMindmap() {
            const title = prompt('Nom de la mindmap:', 'Nouvelle mindmap');
            if (!title) return;

            const newMindmap = {
                id: Date.now(),
                title: title,
                nodes: [],
                links: []
            };

            project.mindmaps.push(newMindmap);
            currentMindmapId = newMindmap.id;
            saveProject();
            renderMindmapView();
        }

        function deleteMindmap(id) {
            if (!confirm('Supprimer cette mindmap ?')) return;
            
            const index = project.mindmaps.findIndex(mm => mm.id === id);
            if (index !== -1) {
                project.mindmaps.splice(index, 1);
                if (currentMindmapId === id) {
                    currentMindmapId = project.mindmaps.length > 0 ? project.mindmaps[0].id : null;
                }
                saveProject();
                renderMindmapView();
            }
        }

        function selectMindmap(id) {
            currentMindmapId = id;
            renderMindmapCanvas();
            // Mettre à jour l'affichage de la sidebar
            document.querySelectorAll('.mindmap-item').forEach(item => {
                item.classList.remove('active');
            });
            event.currentTarget.classList.add('active');
        }

        function renameMindmap() {
            const mindmap = project.mindmaps.find(mm => mm.id === currentMindmapId);
            if (!mindmap) return;

            const newTitle = prompt('Nouveau nom:', mindmap.title);
            if (newTitle && newTitle.trim()) {
                mindmap.title = newTitle.trim();
                saveProject();
                renderMindmapView();
            }
        }

        function renderMindmapCanvas() {
            const editorView = document.getElementById('editorView');
            if (!editorView) return;

            const mindmap = project.mindmaps.find(mm => mm.id === currentMindmapId);

            if (!mindmap) {
                // Afficher un message d'accueil
                editorView.innerHTML = `
                    <div class="mindmap-empty">
                        <div class="mindmap-empty-icon">🗺️</div>
                        <h3 style="margin-bottom: 0.5rem;">Aucune mindmap sélectionnée</h3>
                        <p style="margin-bottom: 1rem;">Créez une mindmap pour commencer à organiser vos idées visuellement.</p>
                        <button class="btn" onclick="createNewMindmap()">➕ Créer une mindmap</button>
                    </div>
                `;
                return;
            }

            editorView.innerHTML = `
                <div class="mindmap-wrapper">
                    <div class="mindmap-main">
                        <div class="mindmap-toolbar">
                            <button class="btn btn-small" onclick="renameMindmap()" title="Renommer">✏️</button>
                            <button class="btn btn-small" onclick="addNoteNode()" title="Ajouter une note"><i data-lucide="sticky-note" style="width:14px;height:14px;"></i></button>
                            <button class="btn btn-small" onclick="resetMindmapView()" title="Réinitialiser la vue"><i data-lucide="target" style="width:14px;height:14px;"></i></button>
                            ${mindmapState.linkStart ? `
                                <button class="btn btn-small" onclick="cancelLinking()" style="background: var(--accent-red); color: white;" title="Annuler la liaison">
                                    <i data-lucide="x" style="width:14px;height:14px;"></i> Annuler
                                </button>
                                <span style="font-size: 0.85rem; color: var(--accent-red); font-weight: 600; animation: pulse-text 1s infinite;">
                                    <i data-lucide="link" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>
                                    Cliquez sur un autre nœud pour créer le lien
                                </span>
                            ` : `
                                <span style="font-size: 0.75rem; color: var(--text-muted); font-style: italic;">
                                    <i data-lucide="lightbulb" style="width:12px;height:12px;vertical-align:middle;margin-right:4px;"></i>Survolez un nœud et cliquez sur <i data-lucide="link" style="width:12px;height:12px;vertical-align:middle;"></i> pour créer un lien
                                </span>
                            `}
                            <div style="flex: 1;"></div>
                            <span style="font-size: 0.85rem; color: var(--text-muted);">
                                ${mindmap.nodes.length} nœud(s) · ${mindmap.links.length} lien(s)
                            </span>
                        </div>
                        <div class="mindmap-canvas-wrapper ${mindmapState.linkStart ? 'linking-mode' : ''}" id="mindmapCanvasWrapper">
                            <div class="mindmap-canvas" id="mindmapCanvas"
                                 style="transform: scale(${mindmapState.zoom}) translate(${mindmapState.panX}px, ${mindmapState.panY}px);">
                                <svg id="mindmapSvg" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0; pointer-events: painted;">
                                    ${renderMindmapLinks(mindmap)}
                                </svg>
                                ${renderMindmapNodes(mindmap)}
                            </div>
                        </div>
                    </div>
                    <div class="mindmap-library ${mindmapState.libraryCollapsed ? 'collapsed' : ''}">
                        <div class="mindmap-library-toggle" onclick="toggleLibrary()">
                            ${mindmapState.libraryCollapsed ? '◀' : '▶'}
                        </div>
                        <div class="mindmap-library-tabs">
                            <div class="mindmap-library-tab ${mindmapState.activeLibraryTab === 'characters' ? 'active' : ''}"
                                 onclick="setLibraryTab('characters')" title="Personnages"><i data-lucide="users" style="width:16px;height:16px;"></i></div>
                            <div class="mindmap-library-tab ${mindmapState.activeLibraryTab === 'elements' ? 'active' : ''}"
                                 onclick="setLibraryTab('elements')" title="Univers"><i data-lucide="globe" style="width:16px;height:16px;"></i></div>
                            <div class="mindmap-library-tab ${mindmapState.activeLibraryTab === 'codex' ? 'active' : ''}"
                                 onclick="setLibraryTab('codex')" title="Codex"><i data-lucide="book-open" style="width:16px;height:16px;"></i></div>
                            <div class="mindmap-library-tab ${mindmapState.activeLibraryTab === 'structure' ? 'active' : ''}"
                                 onclick="setLibraryTab('structure')" title="Structure"><i data-lucide="list-tree" style="width:16px;height:16px;"></i></div>
                        </div>
                        <div class="mindmap-library-content">
                            ${renderLibraryContent()}
                        </div>
                    </div>
                </div>
            `;

            // Initialiser les événements
            initMindmapEvents();
            
            // Réinitialiser les icônes Lucide après le rendu
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
        }

        function renderMindmapNodes(mindmap) {
            if (!mindmap.nodes || mindmap.nodes.length === 0) {
                return `
                    <div style="position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); 
                                text-align: center; color: var(--text-muted); pointer-events: none;">
                        <div style="font-size: 3rem; margin-bottom: 1rem; opacity: 0.3;">🗺️</div>
                        <p style="font-size: 0.9rem;">Glissez des éléments depuis la bibliothèque →</p>
                    </div>
                `;
            }

            return mindmap.nodes.map(node => {
                const icon = getNodeIcon(node);
                const typeClass = `type-${node.type}`;
                const content = getNodeContent(node);
                const isLinkingSource = mindmapState.linkStart === node.id;

                return `
                    <div class="mindmap-node ${typeClass} ${mindmapState.selectedNode === node.id ? 'selected' : ''} ${isLinkingSource ? 'linking-source' : ''}"
                         data-node-id="${node.id}"
                         style="left: ${node.x}px; top: ${node.y}px; background-color: ${node.color || 'var(--bg-primary)'};">
                        <div class="mindmap-node-header">
                            <span class="mindmap-node-icon">${icon}</span>
                            <span class="mindmap-node-title">${node.title || 'Sans titre'}</span>
                            <span class="mindmap-node-link-btn" onclick="event.stopPropagation(); startLinkFrom(${node.id})" title="Créer un lien"><i data-lucide="link" style="width:12px;height:12px;"></i></span>
                            <span class="mindmap-node-delete" onclick="event.stopPropagation(); deleteNode(${node.id})">×</span>
                        </div>
                        ${content ? `<div class="mindmap-node-content">${content}</div>` : ''}
                    </div>
                `;
            }).join('');
        }

        function renderMindmapLinks(mindmap) {
            if (!mindmap.links || mindmap.links.length === 0) return '';

            // Créer les markers pour chaque couleur de lien
            const linkColors = new Set(mindmap.links.map(l => l.color || 'var(--accent-gold)'));
            const markers = Array.from(linkColors).map((color, index) => `
                <marker id="arrowhead-${index}" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
                    <polygon points="0 0, 10 3, 0 6" fill="${color}" opacity="0.7"/>
                </marker>
            `).join('');

            const colorToMarkerId = {};
            Array.from(linkColors).forEach((color, index) => {
                colorToMarkerId[color] = `arrowhead-${index}`;
            });

            return mindmap.links.map(link => {
                const fromNode = mindmap.nodes.find(n => n.id === link.from);
                const toNode = mindmap.nodes.find(n => n.id === link.to);
                
                if (!fromNode || !toNode) return '';

                const x1 = fromNode.x + 100; // Centre approximatif du nœud
                const y1 = fromNode.y + 40;
                const x2 = toNode.x + 100;
                const y2 = toNode.y + 40;

                // Calculer la position du label au milieu
                const labelX = (x1 + x2) / 2;
                const labelY = (y1 + y2) / 2;

                const linkColor = link.color || 'var(--accent-gold)';
                const markerId = colorToMarkerId[linkColor];
                const escapedLabel = (link.label || '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');

                return `
                    <line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" 
                          stroke="${linkColor}" stroke-width="4" 
                          opacity="0.7" marker-end="url(#${markerId})"
                          data-link-id="${link.id}"
                          onclick="editLink(${link.id})"
                          style="cursor: pointer; pointer-events: stroke;"/>
                    ${link.label ? `
                        <text x="${labelX}" y="${labelY}" 
                              text-anchor="middle" 
                              dominant-baseline="middle"
                              style="font-size: 12px; fill: ${linkColor}; font-weight: 600; 
                                     cursor: pointer; pointer-events: auto; user-select: none;"
                              onclick="editLink(${link.id})">
                            <tspan x="${labelX}" dy="0" 
                                   style="paint-order: stroke; stroke: var(--bg-primary); 
                                          stroke-width: 3px; stroke-linejoin: round;">
                                ${escapedLabel}
                            </tspan>
                        </text>
                    ` : ''}
                `;
            }).join('') + `
                <defs>
                    ${markers}
                </defs>
            `;
        }

        function renderLibraryContent() {
            const tab = mindmapState.activeLibraryTab;

            if (tab === 'characters') {
                return project.characters.map(char => `
                    <div class="mindmap-library-item" draggable="true" 
                         data-type="character" data-id="${char.id}" data-title="${char.name}">
                        <span class="mindmap-library-item-icon"><i data-lucide="user" style="width:16px;height:16px;"></i></span>
                        <span class="mindmap-library-item-text">${char.name}</span>
                    </div>
                `).join('') || '<div style="padding: 1rem; text-align: center; color: var(--text-muted); font-size: 0.85rem;">Aucun personnage</div>';
            }

            if (tab === 'elements') {
                return project.world.map(elem => {
                    const elemType = elem.type || 'Lieu';
                    // Icônes Lucide selon le type
                    const iconMap = {
                        'Lieu': 'map-pin',
                        'Objet': 'box',
                        'Concept': 'lightbulb',
                        'Organisation': 'building-2',
                        'Événement': 'zap'
                    };
                    const iconName = iconMap[elemType] || 'map-pin';
                    
                    return `
                    <div class="mindmap-library-item" draggable="true" 
                         data-type="element" 
                         data-element-type="${elemType}"
                         data-id="${elem.id}" 
                         data-title="${elem.name}">
                        <span class="mindmap-library-item-icon"><i data-lucide="${iconName}" style="width:16px;height:16px;"></i></span>
                        <span class="mindmap-library-item-text">${elem.name}</span>
                    </div>
                `;
                }).join('') || '<div style="padding: 1rem; text-align: center; color: var(--text-muted); font-size: 0.85rem;">Aucun élément</div>';
            }

            if (tab === 'codex') {
                return (project.codex || []).map(entry => `
                    <div class="mindmap-library-item" draggable="true" 
                         data-type="codex" 
                         data-id="${entry.id}" 
                         data-title="${entry.title || entry.name || 'Sans titre'}">
                        <span class="mindmap-library-item-icon"><i data-lucide="book-open" style="width:16px;height:16px;"></i></span>
                        <span class="mindmap-library-item-text">${entry.title || entry.name || 'Sans titre'}</span>
                    </div>
                `).join('') || '<div style="padding: 1rem; text-align: center; color: var(--text-muted); font-size: 0.85rem;">Aucune entrée codex</div>';
            }

            if (tab === 'structure') {
                let structureHTML = '';
                project.acts.forEach((act, actIndex) => {
                    const actNum = toRoman(actIndex + 1);
                    // Ajouter l'acte
                    structureHTML += `
                        <div class="mindmap-library-item" draggable="true" 
                             data-type="act" 
                             data-id="${act.id}"
                             data-title="Acte ${actNum}: ${act.title || 'Sans titre'}">
                            <span class="mindmap-library-item-icon"><i data-lucide="folder" style="width:16px;height:16px;"></i></span>
                            <span class="mindmap-library-item-text" style="font-weight: 600;">Acte ${actNum}</span>
                        </div>
                    `;
                    
                    act.chapters.forEach((chapter, chapIndex) => {
                        const chapNum = chapIndex + 1;
                        // Ajouter le chapitre
                        structureHTML += `
                            <div class="mindmap-library-item" draggable="true" 
                                 data-type="chapter" 
                                 data-id="${chapter.id}"
                                 data-act="${act.id}"
                                 data-title="A${actNum} › Ch.${chapNum}: ${chapter.title || 'Sans titre'}"
                                 style="margin-left: 0.5rem;">
                                <span class="mindmap-library-item-icon"><i data-lucide="file-text" style="width:16px;height:16px;"></i></span>
                                <span class="mindmap-library-item-text" style="font-size: 0.8rem;">Ch.${chapNum}: ${chapter.title || 'Sans titre'}</span>
                            </div>
                        `;
                        
                        chapter.scenes.forEach(scene => {
                            const sceneLabel = scene.title || 'Sans titre';
                            structureHTML += `
                                <div class="mindmap-library-item" draggable="true" 
                                     data-type="scene" 
                                     data-id="${scene.id}"
                                     data-act="${act.id}"
                                     data-chapter="${chapter.id}"
                                     data-title="A${actNum} › C${chapNum} › ${sceneLabel}"
                                     style="margin-left: 1rem;">
                                    <span class="mindmap-library-item-icon"><i data-lucide="pen-line" style="width:16px;height:16px;"></i></span>
                                    <span class="mindmap-library-item-text" style="font-size: 0.75rem;">${sceneLabel}</span>
                                </div>
                            `;
                        });
                    });
                });
                return structureHTML || '<div style="padding: 1rem; text-align: center; color: var(--text-muted); font-size: 0.85rem;">Aucune structure</div>';
            }

            return '';
        }

        function getNodeIcon(node) {
            if (node.type === 'element') {
                // Icônes Lucide spécifiques selon le type d'élément d'univers
                const elementIconMap = {
                    'Lieu': 'map-pin',
                    'Objet': 'box',
                    'Concept': 'lightbulb',
                    'Organisation': 'building-2',
                    'Événement': 'zap'
                };
                const iconName = elementIconMap[node.elementType] || 'map-pin';
                return `<i data-lucide="${iconName}" style="width:16px;height:16px;"></i>`;
            }
            
            const icons = {
                'character': 'user',
                'scene': 'pen-line',
                'note': 'sticky-note',
                'codex': 'book-open',
                'act': 'folder',
                'chapter': 'file-text'
            };
            const iconName = icons[node.type] || 'pin';
            return `<i data-lucide="${iconName}" style="width:16px;height:16px;"></i>`;
        }

        function getNodeContent(node) {
            if (node.type === 'note') {
                return node.content || '';
            }
            return '';
        }

        function toggleLibrary() {
            mindmapState.libraryCollapsed = !mindmapState.libraryCollapsed;
            renderMindmapCanvas();
        }

        function setLibraryTab(tab) {
            mindmapState.activeLibraryTab = tab;
            document.querySelectorAll('.mindmap-library-tab').forEach(t => t.classList.remove('active'));
            event.currentTarget.classList.add('active');
            document.querySelector('.mindmap-library-content').innerHTML = renderLibraryContent();
            initLibraryDragEvents();
            
            // Réinitialiser les icônes Lucide
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
        }

        function startLinkFrom(nodeId) {
            if (mindmapState.linkStart === nodeId) {
                // Annuler si on reclique sur le même nœud
                cancelLinking();
            } else if (mindmapState.linkStart && mindmapState.linkStart !== nodeId) {
                // Créer le lien
                const mindmap = project.mindmaps.find(mm => mm.id === currentMindmapId);
                if (!mindmap) return;

                const newLink = {
                    id: Date.now(),
                    from: mindmapState.linkStart,
                    to: nodeId,
                    label: '',
                    color: '#d4af37' // Couleur or par défaut
                };
                mindmap.links.push(newLink);
                mindmapState.linkStart = null;
                saveProject();
                renderMindmapCanvas();
            } else {
                // Démarrer une nouvelle liaison
                mindmapState.linkStart = nodeId;
                renderMindmapCanvas();
            }
        }

        function cancelLinking() {
            mindmapState.linkStart = null;
            renderMindmapCanvas();
        }

        function addNoteNode() {
            const mindmap = project.mindmaps.find(mm => mm.id === currentMindmapId);
            if (!mindmap) return;

            const content = prompt('Contenu de la note:');
            if (!content) return;

            const newNode = {
                id: Date.now(),
                type: 'note',
                title: 'Note',
                content: content,
                x: 100 + Math.random() * 200,
                y: 100 + Math.random() * 200,
                color: 'var(--bg-primary)'
            };

            mindmap.nodes.push(newNode);
            saveProject();
            renderMindmapCanvas();
        }

        function deleteNode(nodeId) {
            const mindmap = project.mindmaps.find(mm => mm.id === currentMindmapId);
            if (!mindmap) return;

            if (!confirm('Supprimer ce nœud ?')) return;

            // Supprimer le nœud
            const nodeIndex = mindmap.nodes.findIndex(n => n.id === nodeId);
            if (nodeIndex !== -1) {
                mindmap.nodes.splice(nodeIndex, 1);
            }

            // Supprimer les liens associés
            mindmap.links = mindmap.links.filter(l => l.from !== nodeId && l.to !== nodeId);

            saveProject();
            renderMindmapCanvas();
        }

        function editLink(linkId) {
            const mindmap = project.mindmaps.find(mm => mm.id === currentMindmapId);
            if (!mindmap) return;

            const link = mindmap.links.find(l => l.id === linkId);
            if (!link) return;

            // Couleurs prédéfinies
            const colors = [
                { name: 'Or', value: '#d4af37' },
                { name: 'Rouge', value: '#c44536' },
                { name: 'Bleu', value: '#2196f3' },
                { name: 'Vert', value: '#4caf50' },
                { name: 'Violet', value: '#9c27b0' },
                { name: 'Orange', value: '#ff9800' },
                { name: 'Rose', value: '#e91e63' },
                { name: 'Gris', value: '#757575' }
            ];

            let selectedColor = link.color || '#d4af37';

            // Créer le modal
            const overlay = document.createElement('div');
            overlay.className = 'link-editor-overlay';
            overlay.innerHTML = `
                <div class="link-editor-modal">
                    <div class="link-editor-header">✏️ Éditer le lien</div>
                    
                    <div class="link-editor-field">
                        <label class="link-editor-label">Étiquette</label>
                        <input type="text" class="link-editor-input" id="linkLabelInput" 
                               value="${(link.label || '').replace(/"/g, '&quot;')}" 
                               placeholder="Ex: ennemi de, père de, aime...">
                    </div>
                    
                    <div class="link-editor-field">
                        <label class="link-editor-label">Couleur</label>
                        <div class="link-editor-colors" id="linkColorPicker">
                            ${colors.map(c => `
                                <div class="link-color-option ${c.value === selectedColor ? 'selected' : ''}" 
                                     style="background: ${c.value};"
                                     data-color="${c.value}"
                                     title="${c.name}"></div>
                            `).join('')}
                        </div>
                    </div>
                    
                    <div class="link-editor-buttons">
                        <button class="btn" id="saveLinkBtn" style="flex: 1;">💾 Enregistrer</button>
                        <button class="btn" id="deleteLinkBtn" style="background: var(--accent-red); color: white;">🗑️ Supprimer</button>
                        <button class="btn" id="cancelLinkBtn" style="background: var(--bg-secondary);">✕ Annuler</button>
                    </div>
                </div>
            `;

            if (!document.body) {
                console.error('document.body not available');
                return;
            }

            document.body.appendChild(overlay);

            // Gestionnaires d'événements
            const modal = overlay.querySelector('.link-editor-modal');
            
            // Empêcher la fermeture au clic sur le modal
            modal.addEventListener('click', (e) => {
                e.stopPropagation();
            });

            // Fermer au clic sur l'overlay
            overlay.addEventListener('click', () => {
                overlay.remove();
            });

            // Sélection de couleur
            document.querySelectorAll('.link-color-option').forEach(opt => {
                opt.addEventListener('click', () => {
                    selectedColor = opt.getAttribute('data-color');
                    document.querySelectorAll('.link-color-option').forEach(o => o.classList.remove('selected'));
                    opt.classList.add('selected');
                });
            });

            // Bouton Enregistrer
            document.getElementById('saveLinkBtn').addEventListener('click', () => {
                const newLabel = document.getElementById('linkLabelInput').value.trim();
                link.label = newLabel;
                link.color = selectedColor;
                saveProject();
                overlay.remove();
                renderMindmapCanvas();
            });

            // Bouton Supprimer
            document.getElementById('deleteLinkBtn').addEventListener('click', () => {
                if (!confirm('Supprimer ce lien ?')) return;
                const linkIndex = mindmap.links.findIndex(l => l.id === linkId);
                if (linkIndex !== -1) {
                    mindmap.links.splice(linkIndex, 1);
                    saveProject();
                    overlay.remove();
                    renderMindmapCanvas();
                }
            });

            // Bouton Annuler
            document.getElementById('cancelLinkBtn').addEventListener('click', () => {
                overlay.remove();
            });

            // Focus sur l'input
            document.getElementById('linkLabelInput').focus();
        }

        function resetMindmapView() {
            mindmapState.zoom = 1;
            mindmapState.panX = 0;
            mindmapState.panY = 0;
            renderMindmapCanvas();
        }

        function initMindmapEvents() {
            const canvas = document.getElementById('mindmapCanvas');
            const wrapper = document.getElementById('mindmapCanvasWrapper');
            if (!canvas || !wrapper) return;

            // Drag & drop des nœuds (souris + tactile)
            canvas.querySelectorAll('.mindmap-node').forEach(node => {
                node.addEventListener('mousedown', handleNodeMouseDown);
                node.addEventListener('click', handleNodeClick);
                node.addEventListener('touchstart', handleNodeTouchStart, { passive: false });
            });

            // Pan de la canvas (souris)
            wrapper.addEventListener('mousedown', handleCanvasMouseDown);
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);

            // Pan de la canvas (tactile)
            wrapper.addEventListener('touchstart', handleCanvasTouchStart, { passive: false });
            document.addEventListener('touchmove', handleTouchMove, { passive: false });
            document.addEventListener('touchend', handleTouchEnd);

            // Zoom
            wrapper.addEventListener('wheel', handleWheel);

            // Drop depuis la bibliothèque
            wrapper.addEventListener('dragover', handleDragOver);
            wrapper.addEventListener('drop', handleDrop);

            // Initialiser le drag des items de la bibliothèque
            initLibraryDragEvents();
        }

        function initLibraryDragEvents() {
            document.querySelectorAll('.mindmap-library-item').forEach(item => {
                // Support souris (desktop)
                item.addEventListener('dragstart', handleLibraryDragStart);
                
                // Support tactile (mobile)
                item.addEventListener('touchstart', handleLibraryTouchStart, { passive: false });
            });
        }

        // Variables pour le drag tactile
        let touchDragData = null;
        let touchDragElement = null;
        let touchDragClone = null;

        function handleLibraryTouchStart(e) {
            e.preventDefault();
            
            const item = e.currentTarget;
            const touch = e.touches[0];
            
            // Sauvegarder les données
            touchDragData = {
                type: item.getAttribute('data-type'),
                linkedId: item.getAttribute('data-id'),
                title: item.getAttribute('data-title'),
                actId: item.getAttribute('data-act'),
                chapterId: item.getAttribute('data-chapter'),
                elementType: item.getAttribute('data-element-type')
            };
            
            touchDragElement = item;
            
            // Créer un clone visuel
            touchDragClone = item.cloneNode(true);
            touchDragClone.style.position = 'fixed';
            touchDragClone.style.left = touch.clientX - 60 + 'px';
            touchDragClone.style.top = touch.clientY - 20 + 'px';
            touchDragClone.style.width = '120px';
            touchDragClone.style.opacity = '0.7';
            touchDragClone.style.pointerEvents = 'none';
            touchDragClone.style.zIndex = '10000';
            touchDragClone.style.transform = 'scale(0.9)';
            
            if (document.body) {
                document.body.appendChild(touchDragClone);
            }
            
            // Écouter les mouvements
            document.addEventListener('touchmove', handleLibraryTouchMove, { passive: false });
            document.addEventListener('touchend', handleLibraryTouchEnd);
        }

        function handleLibraryTouchMove(e) {
            e.preventDefault();
            
            if (!touchDragClone) return;
            
            const touch = e.touches[0];
            touchDragClone.style.left = touch.clientX - 60 + 'px';
            touchDragClone.style.top = touch.clientY - 20 + 'px';
        }

        function handleLibraryTouchEnd(e) {
            if (!touchDragClone || !touchDragData) {
                cleanupTouchDrag();
                return;
            }
            
            const touch = e.changedTouches[0];
            
            // Vérifier si on est sur la zone de drop
            const wrapper = document.getElementById('mindmapCanvasWrapper');
            if (!wrapper) {
                cleanupTouchDrag();
                return;
            }
            
            const rect = wrapper.getBoundingClientRect();
            if (touch.clientX >= rect.left && touch.clientX <= rect.right &&
                touch.clientY >= rect.top && touch.clientY <= rect.bottom) {
                
                // Drop sur la canvas
                const mindmap = project.mindmaps.find(mm => mm.id === currentMindmapId);
                if (mindmap) {
                    // Calculer la position en tenant compte du zoom et du pan
                    const x = (touch.clientX - rect.left - mindmapState.panX * mindmapState.zoom) / mindmapState.zoom;
                    const y = (touch.clientY - rect.top - mindmapState.panY * mindmapState.zoom) / mindmapState.zoom;

                    const newNode = {
                        id: Date.now(),
                        type: touchDragData.type,
                        linkedId: touchDragData.linkedId,
                        title: touchDragData.title,
                        x: x,
                        y: y,
                        color: 'var(--bg-primary)'
                    };

                    // Ajouter les données supplémentaires pour les scènes
                    if (touchDragData.type === 'scene') {
                        newNode.actId = touchDragData.actId;
                        newNode.chapterId = touchDragData.chapterId;
                    }

                    // Ajouter le type d'élément pour les éléments d'univers
                    if (touchDragData.type === 'element' && touchDragData.elementType) {
                        newNode.elementType = touchDragData.elementType;
                    }

                    mindmap.nodes.push(newNode);
                    saveProject();
                    renderMindmapCanvas();
                }
            }
            
            cleanupTouchDrag();
        }

        function cleanupTouchDrag() {
            if (touchDragClone && touchDragClone.parentNode) {
                touchDragClone.parentNode.removeChild(touchDragClone);
            }
            touchDragClone = null;
            touchDragData = null;
            touchDragElement = null;
            
            document.removeEventListener('touchmove', handleLibraryTouchMove);
            document.removeEventListener('touchend', handleLibraryTouchEnd);
        }

        function handleLibraryDragStart(e) {
            const type = e.currentTarget.getAttribute('data-type');
            const id = e.currentTarget.getAttribute('data-id');
            const title = e.currentTarget.getAttribute('data-title');
            const actId = e.currentTarget.getAttribute('data-act');
            const chapterId = e.currentTarget.getAttribute('data-chapter');
            const elementType = e.currentTarget.getAttribute('data-element-type');
            
            e.dataTransfer.setData('application/json', JSON.stringify({ 
                type, 
                linkedId: id, 
                title,
                actId,
                chapterId,
                elementType
            }));
            e.dataTransfer.effectAllowed = 'copy';
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'copy';
        }

        function handleDrop(e) {
            e.preventDefault();
            
            const mindmap = project.mindmaps.find(mm => mm.id === currentMindmapId);
            if (!mindmap) return;

            try {
                const data = JSON.parse(e.dataTransfer.getData('application/json'));
                const wrapper = document.getElementById('mindmapCanvasWrapper');
                const canvas = document.getElementById('mindmapCanvas');
                const rect = wrapper.getBoundingClientRect();
                
                // Calculer la position en tenant compte du zoom et du pan
                const x = (e.clientX - rect.left - mindmapState.panX * mindmapState.zoom) / mindmapState.zoom;
                const y = (e.clientY - rect.top - mindmapState.panY * mindmapState.zoom) / mindmapState.zoom;

                const newNode = {
                    id: Date.now(),
                    type: data.type,
                    linkedId: data.linkedId,
                    title: data.title,
                    x: x,
                    y: y,
                    color: 'var(--bg-primary)'
                };

                // Ajouter les données supplémentaires pour les scènes
                if (data.type === 'scene') {
                    newNode.actId = data.actId;
                    newNode.chapterId = data.chapterId;
                }

                // Ajouter le type d'élément pour les éléments d'univers
                if (data.type === 'element' && data.elementType) {
                    newNode.elementType = data.elementType;
                }

                mindmap.nodes.push(newNode);
                saveProject();
                renderMindmapCanvas();
            } catch (err) {
                console.error('Erreur lors du drop:', err);
            }
        }

        function handleNodeMouseDown(e) {
            e.stopPropagation();
            
            const mindmap = project.mindmaps.find(mm => mm.id === currentMindmapId);
            if (!mindmap) return;

            const nodeId = parseInt(e.currentTarget.getAttribute('data-node-id'));
            
            // Mode déplacement uniquement
            mindmapState.isDragging = true;
            mindmapState.draggedNode = nodeId;
            mindmapState.selectedNode = nodeId;
            
            const node = mindmap.nodes.find(n => n.id === nodeId);
            const canvas = document.getElementById('mindmapCanvas');
            const rect = canvas.getBoundingClientRect();
            
            mindmapState.dragOffsetX = (e.clientX - rect.left) / mindmapState.zoom - node.x;
            mindmapState.dragOffsetY = (e.clientY - rect.top) / mindmapState.zoom - node.y;
            
            e.currentTarget.classList.add('dragging');
        }

        function handleNodeClick(e) {
            const nodeId = parseInt(e.currentTarget.getAttribute('data-node-id'));
            const mindmap = project.mindmaps.find(mm => mm.id === currentMindmapId);
            if (!mindmap) return;

            const node = mindmap.nodes.find(n => n.id === nodeId);
            if (!node) return;

            // Double-clic pour ouvrir l'élément lié
            if (e.detail === 2 && node.linkedId) {
                if (node.type === 'character') {
                    switchView('characters');
                    setTimeout(() => openCharacterDetail(node.linkedId), 100);
                } else if (node.type === 'element') {
                    switchView('world');
                    setTimeout(() => openWorldDetail(node.linkedId), 100);
                } else if (node.type === 'codex') {
                    switchView('codex');
                    setTimeout(() => {
                        if (typeof openCodexDetail === 'function') {
                            openCodexDetail(node.linkedId);
                        }
                    }, 100);
                } else if (node.type === 'scene' && node.actId && node.chapterId) {
                    switchView('editor');
                    setTimeout(() => openScene(node.actId, node.chapterId, node.linkedId), 100);
                } else if (node.type === 'chapter' && node.actId) {
                    switchView('editor');
                    // Trouver la première scène du chapitre
                    const act = project.acts.find(a => a.id == node.actId);
                    if (act) {
                        const chapter = act.chapters.find(c => c.id == node.linkedId);
                        if (chapter && chapter.scenes.length > 0) {
                            setTimeout(() => openScene(node.actId, node.linkedId, chapter.scenes[0].id), 100);
                        }
                    }
                } else if (node.type === 'act') {
                    switchView('editor');
                    // Trouver le premier chapitre et scène de l'acte
                    const act = project.acts.find(a => a.id == node.linkedId);
                    if (act && act.chapters.length > 0 && act.chapters[0].scenes.length > 0) {
                        setTimeout(() => openScene(node.linkedId, act.chapters[0].id, act.chapters[0].scenes[0].id), 100);
                    }
                }
            }
            
            // Simple clic en mode liaison : créer le lien vers ce nœud
            if (e.detail === 1 && mindmapState.linkStart && mindmapState.linkStart !== nodeId) {
                // Créer le lien immédiatement
                const newLink = {
                    id: Date.now(),
                    from: mindmapState.linkStart,
                    to: nodeId,
                    label: '',
                    color: '#d4af37'
                };
                mindmap.links.push(newLink);
                mindmapState.linkStart = null;
                saveProject();
                renderMindmapCanvas();
            }
        }

        function handleCanvasMouseDown(e) {
            if (e.target.id === 'mindmapCanvasWrapper' || e.target.id === 'mindmapCanvas') {
                mindmapState.isPanning = true;
                mindmapState.lastMouseX = e.clientX;
                mindmapState.lastMouseY = e.clientY;
                document.getElementById('mindmapCanvas').classList.add('panning');
            }
        }

        function handleMouseMove(e) {
            const mindmap = project.mindmaps.find(mm => mm.id === currentMindmapId);
            if (!mindmap) return;

            if (mindmapState.isDragging && mindmapState.draggedNode) {
                const node = mindmap.nodes.find(n => n.id === mindmapState.draggedNode);
                if (node) {
                    const canvas = document.getElementById('mindmapCanvas');
                    const rect = canvas.getBoundingClientRect();
                    
                    node.x = (e.clientX - rect.left) / mindmapState.zoom - mindmapState.dragOffsetX;
                    node.y = (e.clientY - rect.top) / mindmapState.zoom - mindmapState.dragOffsetY;
                    
                    // Mise à jour en temps réel
                    const nodeElem = document.querySelector(`[data-node-id="${node.id}"]`);
                    if (nodeElem) {
                        nodeElem.style.left = node.x + 'px';
                        nodeElem.style.top = node.y + 'px';
                    }
                    
                    // Redessiner les liens
                    document.getElementById('mindmapSvg').innerHTML = renderMindmapLinks(mindmap);
                }
            } else if (mindmapState.isPanning) {
                const deltaX = e.clientX - mindmapState.lastMouseX;
                const deltaY = e.clientY - mindmapState.lastMouseY;
                
                mindmapState.panX += deltaX / mindmapState.zoom;
                mindmapState.panY += deltaY / mindmapState.zoom;
                
                mindmapState.lastMouseX = e.clientX;
                mindmapState.lastMouseY = e.clientY;
                
                const canvas = document.getElementById('mindmapCanvas');
                canvas.style.transform = `scale(${mindmapState.zoom}) translate(${mindmapState.panX}px, ${mindmapState.panY}px)`;
            }
        }

        function handleMouseUp(e) {
            if (mindmapState.isDragging) {
                const mindmap = project.mindmaps.find(mm => mm.id === currentMindmapId);
                if (mindmap) {
                    saveProject();
                }
                
                document.querySelectorAll('.mindmap-node').forEach(node => {
                    node.classList.remove('dragging');
                });
            }
            
            if (mindmapState.isPanning) {
                document.getElementById('mindmapCanvas').classList.remove('panning');
            }
            
            mindmapState.isDragging = false;
            mindmapState.draggedNode = null;
            mindmapState.isPanning = false;
        }



// ========== 32.touch-events.js ==========
        // ========================================
        // TOUCH EVENTS FOR MOBILE
        // ========================================

        function handleNodeTouchStart(e) {
            // Empêcher le comportement par défaut mais permettre les boutons
            if (e.target.classList.contains('mindmap-node-link-btn') || 
                e.target.classList.contains('mindmap-node-delete')) {
                return; // Laisser les boutons fonctionner
            }
            
            e.preventDefault();
            e.stopPropagation();
            
            const mindmap = project.mindmaps.find(mm => mm.id === currentMindmapId);
            if (!mindmap) return;

            const nodeId = parseInt(e.currentTarget.getAttribute('data-node-id'));
            const touch = e.touches[0];
            
            // Mode déplacement
            mindmapState.isDragging = true;
            mindmapState.draggedNode = nodeId;
            mindmapState.selectedNode = nodeId;
            
            const node = mindmap.nodes.find(n => n.id === nodeId);
            const canvas = document.getElementById('mindmapCanvas');
            const rect = canvas.getBoundingClientRect();
            
            mindmapState.dragOffsetX = (touch.clientX - rect.left) / mindmapState.zoom - node.x;
            mindmapState.dragOffsetY = (touch.clientY - rect.top) / mindmapState.zoom - node.y;
            
            e.currentTarget.classList.add('dragging');
        }

        function handleCanvasTouchStart(e) {
            if (e.target.id === 'mindmapCanvasWrapper' || e.target.id === 'mindmapCanvas') {
                e.preventDefault();
                const touch = e.touches[0];
                mindmapState.isPanning = true;
                mindmapState.lastMouseX = touch.clientX;
                mindmapState.lastMouseY = touch.clientY;
                document.getElementById('mindmapCanvas').classList.add('panning');
            }
        }

        function handleTouchMove(e) {
            const mindmap = project.mindmaps.find(mm => mm.id === currentMindmapId);
            if (!mindmap) return;

            const touch = e.touches[0];

            if (mindmapState.isDragging && mindmapState.draggedNode) {
                e.preventDefault();
                const node = mindmap.nodes.find(n => n.id === mindmapState.draggedNode);
                if (node) {
                    const canvas = document.getElementById('mindmapCanvas');
                    const rect = canvas.getBoundingClientRect();
                    
                    node.x = (touch.clientX - rect.left) / mindmapState.zoom - mindmapState.dragOffsetX;
                    node.y = (touch.clientY - rect.top) / mindmapState.zoom - mindmapState.dragOffsetY;
                    
                    // Mise à jour en temps réel
                    const nodeElem = document.querySelector(`[data-node-id="${node.id}"]`);
                    if (nodeElem) {
                        nodeElem.style.left = node.x + 'px';
                        nodeElem.style.top = node.y + 'px';
                    }
                    
                    // Redessiner les liens
                    document.getElementById('mindmapSvg').innerHTML = renderMindmapLinks(mindmap);
                }
            } else if (mindmapState.isPanning) {
                e.preventDefault();
                const deltaX = touch.clientX - mindmapState.lastMouseX;
                const deltaY = touch.clientY - mindmapState.lastMouseY;
                
                mindmapState.panX += deltaX / mindmapState.zoom;
                mindmapState.panY += deltaY / mindmapState.zoom;
                
                mindmapState.lastMouseX = touch.clientX;
                mindmapState.lastMouseY = touch.clientY;
                
                const canvas = document.getElementById('mindmapCanvas');
                canvas.style.transform = `scale(${mindmapState.zoom}) translate(${mindmapState.panX}px, ${mindmapState.panY}px)`;
            }
        }

        function handleTouchEnd(e) {
            if (mindmapState.isDragging) {
                const mindmap = project.mindmaps.find(mm => mm.id === currentMindmapId);
                if (mindmap) {
                    saveProject();
                }
                
                document.querySelectorAll('.mindmap-node').forEach(node => {
                    node.classList.remove('dragging');
                });
            }
            
            if (mindmapState.isPanning) {
                const canvas = document.getElementById('mindmapCanvas');
                if (canvas) {
                    canvas.classList.remove('panning');
                }
            }
            
            mindmapState.isDragging = false;
            mindmapState.draggedNode = null;
            mindmapState.isPanning = false;
        }

        function handleWheel(e) {
            e.preventDefault();
            
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            const newZoom = Math.max(0.1, Math.min(3, mindmapState.zoom * delta));
            
            mindmapState.zoom = newZoom;
            
            const canvas = document.getElementById('mindmapCanvas');
            canvas.style.transform = `scale(${mindmapState.zoom}) translate(${mindmapState.panX}px, ${mindmapState.panY}px)`;
        }
        
        


// ========== 33.plot.js ==========

        let plotPoints = [];
        
        // Algorithme d'analyse de tension basé sur le contenu
        function calculateSceneTension(scene, actIndex, totalActs, chapterIndex, totalChapters, sceneIndex, totalScenes) {
            let tension = 0;
            const content = (scene.content || '').toLowerCase();
            const title = (scene.title || '').toLowerCase();
            
            // 1. ANALYSE LEXICALE (0-40 points)
            // Charger les mots personnalisés ou utiliser les valeurs par défaut
            const tensionWords = getTensionWords();
            const highTensionWords = tensionWords.high;
            const mediumTensionWords = tensionWords.medium;
            const lowTensionWords = tensionWords.low;
            
            let lexicalScore = 0;
            highTensionWords.forEach(word => {
                if (content.includes(word) || title.includes(word)) lexicalScore += 3;
            });
            mediumTensionWords.forEach(word => {
                if (content.includes(word) || title.includes(word)) lexicalScore += 1.5;
            });
            lowTensionWords.forEach(word => {
                if (content.includes(word) || title.includes(word)) lexicalScore -= 2;
            });
            
            tension += Math.max(0, Math.min(40, lexicalScore));
            
            // 2. ANALYSE DE LA LONGUEUR (0-10 points)
            // Les scènes courtes intenses vs longues descriptives
            const wordCount = content.split(/\s+/).filter(w => w.length > 0).length;
            if (wordCount < 200) tension += 8; // Scène courte = souvent intense
            else if (wordCount < 500) tension += 5;
            else if (wordCount < 1000) tension += 3;
            else tension += 2; // Scène longue = souvent descriptive
            
            // 3. PONCTUATION EXPRESSIVE (0-10 points)
            const exclamations = (content.match(/!/g) || []).length;
            const questions = (content.match(/\?/g) || []).length;
            const suspensions = (content.match(/\.\.\./g) || []).length;
            
            tension += Math.min(10, (exclamations * 0.5 + questions * 0.3 + suspensions * 0.8));
            
            // 4. STRUCTURE NARRATIVE (0-40 points)
            // Position dans l'acte (courbe en 3 actes)
            const actProgress = actIndex / Math.max(totalActs - 1, 1);
            const chapterProgress = chapterIndex / Math.max(totalChapters - 1, 1);
            const sceneProgress = sceneIndex / Math.max(totalScenes - 1, 1);
            
            // Structure classique en 3 actes
            if (totalActs >= 3) {
                if (actIndex === 0) {
                    // Acte 1 : Montée progressive
                    tension += 10 + (chapterProgress * 15);
                } else if (actIndex === totalActs - 1) {
                    // Dernier acte : Haute tension jusqu'au climax, puis résolution
                    if (sceneProgress < 0.7) {
                        tension += 35 + (sceneProgress * 5);
                    } else {
                        // Résolution
                        tension += 40 - ((sceneProgress - 0.7) * 50);
                    }
                } else {
                    // Actes intermédiaires : Montée progressive
                    tension += 20 + (actProgress * 15);
                }
            } else if (totalActs === 2) {
                // Structure en 2 actes
                if (actIndex === 0) {
                    tension += 15 + (chapterProgress * 15);
                } else {
                    tension += 30 + (sceneProgress * 10);
                }
            } else {
                // Un seul acte : courbe progressive
                tension += 20 + (sceneProgress * 20);
            }
            
            // Bonus pour les scènes de fin de chapitre (cliffhangers)
            if (sceneIndex === totalScenes - 1) {
                tension += 5;
            }
            
            // 5. NORMALISATION (0-100)
            tension = Math.max(15, Math.min(95, tension)); // Entre 15 et 95
            
            return tension;
        }
        
        function renderPlotView() {
            const container = document.getElementById('editorView');
            if (!container) {
                console.error('editorView container not found');
                return;
            }
            // Initialiser les points d'intrigue avec calcul intelligent
            if (plotPoints.length === 0 && project.acts.length > 0) {
                let position = 0;
                const totalActs = project.acts.length;
                
                project.acts.forEach((act, actIndex) => {
                    const totalChapters = act.chapters.length;
                    
                    act.chapters.forEach((chapter, chapIndex) => {
                        const totalScenes = chapter.scenes.length;
                        
                        chapter.scenes.forEach((scene, sceneIndex) => {
                            const intensity = calculateSceneTension(
                                scene, 
                                actIndex, 
                                totalActs, 
                                chapIndex, 
                                totalChapters, 
                                sceneIndex, 
                                totalScenes
                            );
                            
                            plotPoints.push({
                                position: position++,
                                intensity: intensity,
                                title: scene.title,
                                actId: act.id,
                                chapterId: chapter.id,
                                sceneId: scene.id,
                                description: `${act.title} > ${chapter.title}`,
                                wordCount: scene.content ? scene.content.split(/\s+/).filter(w => w.length > 0).length : 0
                            });
                        });
                    });
                });
            }
            
            // Générer le graphique SVG
            const svgWidth = 800;
            const svgHeight = 500;
            const padding = 60;
            const plotWidth = svgWidth - padding * 2;
            const plotHeight = svgHeight - padding * 2;
            
            let pathData = '';
            let pointsHTML = '';
            let gridLines = '';
            
            // Lignes de grille
            for (let i = 0; i <= 4; i++) {
                const y = padding + (plotHeight / 4) * i;
                gridLines += `<line x1="${padding}" y1="${y}" x2="${svgWidth - padding}" y2="${y}" stroke="var(--border-color)" stroke-width="1" opacity="0.3" stroke-dasharray="5,5"/>`;
                gridLines += `<text x="${padding - 10}" y="${y + 5}" text-anchor="end" font-size="12" fill="var(--text-muted)">${100 - i * 25}%</text>`;
            }
            
            // Générer la courbe
            if (plotPoints.length > 0) {
                plotPoints.forEach((point, index) => {
                    const x = padding + (plotWidth / Math.max(plotPoints.length - 1, 1)) * index;
                    const y = padding + plotHeight - (point.intensity / 100) * plotHeight;
                    
                    if (index === 0) {
                        pathData = `M ${x} ${y}`;
                    } else {
                        pathData += ` L ${x} ${y}`;
                    }
                    
                    // Points cliquables avec menu contextuel
                    pointsHTML += `
                        <circle cx="${x}" cy="${y}" r="6" fill="var(--accent-gold)" stroke="white" stroke-width="2" 
                                style="cursor: pointer;" 
                                onclick="editPlotPointIntensity(${index})"
                                oncontextmenu="event.preventDefault(); openPlotPoint(${point.actId}, ${point.chapterId}, ${point.sceneId})">
                            <title>Clic gauche: Éditer tension (${Math.round(point.intensity)}%)
Clic droit: Ouvrir scène "${point.title}"</title>
                        </circle>
                    `;
                });
            }
            
            container.innerHTML = `
                <div style="padding: 2rem;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
                        <div>
                            <h3 style="margin: 0;"><i data-lucide="trending-up" style="width:18px;height:18px;vertical-align:middle;margin-right:6px;"></i>Graphique d'Intrigue</h3>
                            <div style="font-size: 0.85rem; color: var(--text-secondary); margin-top: 0.5rem;">
                                📊 ${plotPoints.length} point(s) d'intrigue • 🎯 Tension moyenne: ${plotPoints.length > 0 ? Math.round(plotPoints.reduce((sum, p) => sum + p.intensity, 0) / plotPoints.length) : 0}%
                            </div>
                        </div>
                        <button onclick="openTensionWordsEditor()" 
                                style="padding: 10px 18px; background: #3a7bc8; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.9rem; font-weight: 500; transition: all 0.2s; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"
                                onmouseover="this.style.background='#2d6bb3'; this.style.boxShadow='0 4px 8px rgba(0,0,0,0.15)'"
                                onmouseout="this.style.background='#3a7bc8'; this.style.boxShadow='0 2px 4px rgba(0,0,0,0.1)'">
                            ✏️ Personnaliser les mots de tension
                        </button>
                    </div>
                    <div class="visualization-toolbar">
                        <button class="viz-tool-btn active">Vue d'ensemble</button>
                        <button class="viz-tool-btn" onclick="analyzePlotCurve()">🔍 Analyser la courbe</button>
                        <button class="viz-tool-btn" onclick="showPlotSuggestions()"><i data-lucide="lightbulb" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Suggestions</button>
                        <button class="viz-tool-btn" onclick="resetPlotPoints()">🔄 Recalculer</button>
                        <button class="viz-tool-btn" onclick="exportPlot()">📤 Exporter</button>
                    </div>
                    <div class="visualization-canvas">
                        <div class="plot-graph">
                            <svg width="100%" height="${svgHeight}" viewBox="0 0 ${svgWidth} ${svgHeight}" id="plotSvg">
                                <!-- Axes -->
                                <line x1="${padding}" y1="${svgHeight - padding}" x2="${svgWidth - padding}" y2="${svgHeight - padding}" 
                                      stroke="var(--text-primary)" stroke-width="2"/>
                                <line x1="${padding}" y1="${padding}" x2="${padding}" y2="${svgHeight - padding}" 
                                      stroke="var(--text-primary)" stroke-width="2"/>
                                
                                <!-- Labels -->
                                <text x="${svgWidth / 2}" y="${svgHeight - 20}" text-anchor="middle" fill="var(--text-muted)" font-size="14">
                                    Progression du récit →
                                </text>
                                <text x="20" y="${svgHeight / 2}" text-anchor="middle" fill="var(--text-muted)" font-size="14" 
                                      transform="rotate(-90 20 ${svgHeight / 2})">
                                    ← Tension dramatique
                                </text>
                                
                                <!-- Grille -->
                                ${gridLines}
                                
                                <!-- Courbe d'intrigue -->
                                ${pathData ? `<path d="${pathData}" fill="none" stroke="var(--accent-gold)" stroke-width="3"/>` : ''}
                                
                                <!-- Points -->
                                ${pointsHTML}
                            </svg>
                        </div>
                    </div>
                    <div style="margin-top: 1rem; padding: 1rem; background: var(--bg-secondary); border-radius: 4px;">
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                            <div>
                                <p style="font-size: 0.9rem; color: var(--text-secondary); line-height: 1.6; margin: 0;">
                                    💡 <strong>Utilisation:</strong><br>
                                    • <strong>Clic gauche</strong> sur un point → Modifier manuellement la tension<br>
                                    • <strong>Clic droit</strong> sur un point → Ouvrir la scène pour l'éditer<br>
                                    • <strong>Analyser</strong> → Obtenez un rapport complet sur votre courbe<br>
                                    • <strong>Suggestions</strong> → Conseils personnalisés pour améliorer l'intrigue
                                </p>
                            </div>
                            <div style="padding: 0.75rem; background: var(--bg-primary); border-radius: 4px; border: 1px solid var(--border-color);">
                                <div style="font-size: 0.85rem; font-weight: 600; margin-bottom: 0.5rem; color: var(--text-primary);">Calcul de la tension :</div>
                                <div style="font-size: 0.75rem; line-height: 1.6; color: var(--text-secondary);">
                                    • Analyse lexicale (mots-clés personnalisables)<br>
                                    • Longueur de la scène<br>
                                    • Ponctuation expressive<br>
                                    • Position narrative (structure en 3 actes)
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }
        
        function openPlotPoint(actId, chapterId, sceneId) {
            switchView('editor');
            openScene(actId, chapterId, sceneId);
        }
        
        function editPlotPointIntensity(index) {
            if (index < 0 || index >= plotPoints.length) return;
            
            const point = plotPoints[index];
            const currentIntensity = Math.round(point.intensity);
            
            const newIntensity = prompt(
                `Modifier la tension de "${point.title}"\n\n` +
                `Tension actuelle: ${currentIntensity}%\n` +
                `Entrez une nouvelle valeur (0-100):`,
                currentIntensity
            );
            
            if (newIntensity === null) return;
            
            const intensity = parseInt(newIntensity);
            if (isNaN(intensity) || intensity < 0 || intensity > 100) {
                alert('Veuillez entrer un nombre entre 0 et 100');
                return;
            }
            
            point.intensity = intensity;
            renderPlotView();
            showNotification(`✓ Tension mise à jour: ${intensity}%`);
        }
        
        function analyzePlotCurve() {
            if (plotPoints.length === 0) {
                alert('Aucun point à analyser. Créez d\'abord des scènes.');
                return;
            }
            
            // Analyse de la courbe
            const tensions = plotPoints.map(p => p.intensity);
            const avg = tensions.reduce((a, b) => a + b, 0) / tensions.length;
            const max = Math.max(...tensions);
            const min = Math.min(...tensions);
            const maxIndex = tensions.indexOf(max);
            const minIndex = tensions.indexOf(min);
            
            // Calcul de la variance (mesure de variation)
            const variance = tensions.reduce((sum, t) => sum + Math.pow(t - avg, 2), 0) / tensions.length;
            const stdDev = Math.sqrt(variance);
            
            // Détection du climax
            const lastThird = Math.floor(plotPoints.length * 0.66);
            const climaxInLastThird = maxIndex >= lastThird;
            
            // Analyse de la progression
            const firstHalf = tensions.slice(0, Math.floor(tensions.length / 2));
            const secondHalf = tensions.slice(Math.floor(tensions.length / 2));
            const firstAvg = firstHalf.reduce((a, b) => a + b, 0) / firstHalf.length;
            const secondAvg = secondHalf.reduce((a, b) => a + b, 0) / secondHalf.length;
            const isRising = secondAvg > firstAvg;
            
            // Compter les pics (variations > 20%)
            let peaks = 0;
            for (let i = 1; i < tensions.length - 1; i++) {
                if (tensions[i] > tensions[i-1] + 20 && tensions[i] > tensions[i+1] + 20) {
                    peaks++;
                }
            }
            
            // Rapport d'analyse
            let analysis = `📊 ANALYSE DE VOTRE COURBE D'INTRIGUE\n\n`;
            
            analysis += `📈 STATISTIQUES\n`;
            analysis += `• Tension moyenne : ${Math.round(avg)}%\n`;
            analysis += `• Tension max : ${Math.round(max)}% (${plotPoints[maxIndex].title})\n`;
            analysis += `• Tension min : ${Math.round(min)}% (${plotPoints[minIndex].title})\n`;
            analysis += `• Amplitude : ${Math.round(max - min)}%\n`;
            analysis += `• Variation : ${stdDev < 10 ? 'Faible' : stdDev < 20 ? 'Modérée' : 'Forte'}\n`;
            analysis += `• Nombre de pics : ${peaks}\n\n`;
            
            analysis += `🎯 ÉVALUATION NARRATIVE\n`;
            
            // Évaluation de la tension moyenne
            if (avg < 40) {
                analysis += `⚠️ Tension moyenne BASSE (${Math.round(avg)}%)\n`;
                analysis += `   → Votre histoire manque peut-être de conflits\n`;
            } else if (avg > 70) {
                analysis += `⚠️ Tension moyenne ÉLEVÉE (${Math.round(avg)}%)\n`;
                analysis += `   → Le lecteur risque la fatigue. Ajoutez des pauses\n`;
            } else {
                analysis += `✅ Tension moyenne équilibrée (${Math.round(avg)}%)\n`;
            }
            
            // Évaluation du climax
            if (climaxInLastThird) {
                analysis += `✅ Climax bien placé (dernier tiers du récit)\n`;
            } else {
                analysis += `⚠️ Climax trop tôt (${Math.round((maxIndex / plotPoints.length) * 100)}% du récit)\n`;
                analysis += `   → Le climax devrait être vers 70-80%\n`;
            }
            
            // Évaluation de la progression
            if (isRising) {
                analysis += `✅ Tension croissante (bon rythme)\n`;
            } else {
                analysis += `⚠️ Tension décroissante en moyenne\n`;
                analysis += `   → La seconde moitié perd en intensité\n`;
            }
            
            // Évaluation de la variation
            if (stdDev < 10) {
                analysis += `⚠️ Courbe trop PLATE\n`;
                analysis += `   → Créez plus de contraste entre action et repos\n`;
            } else if (stdDev > 25) {
                analysis += `⚠️ Courbe très IRRÉGULIÈRE\n`;
                analysis += `   → Peut-être intentionnel (action frénétique)?\n`;
            } else {
                analysis += `✅ Variation équilibrée\n`;
            }
            
            // Évaluation des pics
            if (peaks === 0) {
                analysis += `⚠️ Aucun pic majeur détecté\n`;
                analysis += `   → Ajoutez des moments de tension forte\n`;
            } else if (peaks > plotPoints.length / 3) {
                analysis += `⚠️ Trop de pics (${peaks})\n`;
                analysis += `   → Le lecteur n'a pas le temps de souffler\n`;
            } else {
                analysis += `✅ Nombre de pics approprié (${peaks})\n`;
            }
            
            analysis += `\n💡 Cliquez sur "Suggestions" pour des conseils détaillés`;
            
            alert(analysis);
        }
        
        function showPlotSuggestions() {
            if (plotPoints.length === 0) {
                alert('Créez d\'abord des scènes pour obtenir des suggestions.');
                return;
            }
            
            const tensions = plotPoints.map(p => p.intensity);
            const avg = tensions.reduce((a, b) => a + b, 0) / tensions.length;
            
            let suggestions = `💡 SUGGESTIONS POUR AMÉLIORER VOTRE INTRIGUE\n\n`;
            
            // Analyser les zones plates
            let flatZones = [];
            for (let i = 0; i < tensions.length - 2; i++) {
                const range = tensions.slice(i, i + 3);
                const rangeAvg = range.reduce((a, b) => a + b, 0) / range.length;
                const rangeVariance = range.reduce((sum, t) => sum + Math.pow(t - rangeAvg, 2), 0) / range.length;
                if (rangeVariance < 5) {
                    flatZones.push(i);
                }
            }
            
            if (flatZones.length > 0) {
                suggestions += `📉 ZONES PLATES DÉTECTÉES\n`;
                suggestions += `${flatZones.length} séquences manquent de variation.\n`;
                suggestions += `→ Ajoutez un rebondissement ou un obstacle\n`;
                suggestions += `→ Variez le rythme (alternez dialogue et action)\n\n`;
            }
            
            // Suggestions selon la tension moyenne
            if (avg < 40) {
                suggestions += `🔥 AUGMENTER LA TENSION GLOBALE\n`;
                suggestions += `→ Ajoutez plus de conflits entre personnages\n`;
                suggestions += `→ Créez des obstacles plus grands\n`;
                suggestions += `→ Utilisez des mots plus percutants\n`;
                suggestions += `→ Raccourcissez les scènes d'action\n\n`;
            } else if (avg > 70) {
                suggestions += `😌 CRÉER DES PAUSES\n`;
                suggestions += `→ Ajoutez des scènes de réflexion\n`;
                suggestions += `→ Moments de calme après l'action\n`;
                suggestions += `→ Dialogues intimes ou humoristiques\n`;
                suggestions += `→ Descriptions contemplatives\n\n`;
            }
            
            // Suggestions de structure
            suggestions += `📐 STRUCTURE RECOMMANDÉE\n`;
            suggestions += `• Début (0-25%) : 20-40% tension\n`;
            suggestions += `• Milieu (25-66%) : 40-60% tension\n`;
            suggestions += `• Fin (66-90%) : 60-90% tension (climax)\n`;
            suggestions += `• Résolution (90-100%) : 20-40% tension\n\n`;
            
            // Conseils pratiques
            suggestions += `✍️ TECHNIQUES CONCRÈTES\n`;
            suggestions += `→ Pour augmenter la tension :\n`;
            suggestions += `  • Ajoutez des deadlines\n`;
            suggestions += `  • Mettez en danger un personnage aimé\n`;
            suggestions += `  • Révélez un secret\n`;
            suggestions += `  • Créez un dilemme moral\n\n`;
            suggestions += `→ Pour diminuer la tension :\n`;
            suggestions += `  • Résolvez un conflit mineur\n`;
            suggestions += `  • Moment de victoire temporaire\n`;
            suggestions += `  • Scène de camaraderie\n`;
            suggestions += `  • Description paisible\n`;
            
            alert(suggestions);
        }
        
        function resetPlotPoints() {
            if (confirm('Recalculer tous les points d\'intrigue ?\n\nLa tension sera recalculée automatiquement pour toutes les scènes.\n\nLes ajustements manuels seront perdus.')) {
                plotPoints = [];
                renderPlotView();
                showNotification('✓ Points recalculés automatiquement');
            }
        }
        
        function addPlotPoint() {
            alert('Les points sont générés automatiquement depuis vos scènes.\n\nPour ajuster la tension :\n• Clic gauche sur un point → Modifier manuellement\n• Clic droit sur un point → Ouvrir la scène');
        }
        
        function exportPlot() {
            const svg = document.getElementById('plotSvg');
            if (!svg) return;
            
            const svgData = new XMLSerializer().serializeToString(svg);
            const blob = new Blob([svgData], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${project.title}_plot.svg`;
            a.click();
            URL.revokeObjectURL(url);
        }
            
        

// ========== 34.relations-graph.js ==========
        // ============================================
        // RELATIONS GRAPH FUNCTIONS
        // ============================================
        
        function renderRelationsView() {
            const editorView = document.getElementById('editorView');
            if (!editorView) {
                console.error('editorView not found');
                return;
            }
            
            // S'assurer que relations existe
            if (!project.relations) project.relations = [];
            
            // S'assurer que les positions personnalisées existent
            if (!project.characterPositions) project.characterPositions = {};
            
            // Types de relations avec couleurs
            const relationTypes = {
                'amour': { color: '#e91e63', label: '❤️ Amour', icon: '❤️' },
                'amitie': { color: '#4caf50', label: '🤝 Amitié', icon: '🤝' },
                'rivalite': { color: '#f44336', label: '⚔️ Rivalité', icon: '⚔️' },
                'famille': { color: '#2196f3', label: '👨‍👩‍👧 Famille', icon: '👨‍👩‍👧' },
                'mentor': { color: '#ff9800', label: '📚 Mentor', icon: '📚' },
                'ennemi': { color: '#9c27b0', label: '💀 Ennemi', icon: '💀' },
                'alliance': { color: '#00bcd4', label: '🤜🤛 Alliance', icon: '🤜🤛' },
                'neutre': { color: '#757575', label: '😐 Neutre', icon: '😐' }
            };
            
            let graphHTML = '';
            if (project.characters.length >= 2) {
                const centerX = 400;
                const centerY = 350;
                const radius = 220;
                
                // Calculer les positions (personnalisées ou par défaut en cercle)
                const positions = project.characters.map((char, i) => {
                    if (project.characterPositions[char.id]) {
                        return project.characterPositions[char.id];
                    } else {
                        const angle = (i / project.characters.length) * 2 * Math.PI;
                        return {
                            x: centerX + radius * Math.cos(angle),
                            y: centerY + radius * Math.sin(angle)
                        };
                    }
                });
                
                // SVG pour les lignes de relation
                let svgLines = '<svg id="relationsSvg" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0; pointer-events: none;">';
                
                // Dessiner les relations existantes
                project.relations.forEach(rel => {
                    const char1 = project.characters.find(c => c.id === rel.char1Id);
                    const char2 = project.characters.find(c => c.id === rel.char2Id);
                    
                    if (char1 && char2) {
                        const i1 = project.characters.indexOf(char1);
                        const i2 = project.characters.indexOf(char2);
                        
                        const x1 = positions[i1].x;
                        const y1 = positions[i1].y;
                        const x2 = positions[i2].x;
                        const y2 = positions[i2].y;
                        
                        const relType = relationTypes[rel.type] || relationTypes['neutre'];
                        
                        svgLines += `
                            <line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" 
                                  stroke="${relType.color}" 
                                  stroke-width="3" 
                                  opacity="0.7"
                                  style="cursor: pointer;"
                                  onclick="editRelation('${rel.id}')"/>
                            <text x="${(x1 + x2) / 2}" y="${(y1 + y2) / 2 - 10}" 
                                  fill="${relType.color}" 
                                  font-size="20" 
                                  text-anchor="middle"
                                  style="pointer-events: none;">${relType.icon}</text>
                        `;
                    }
                });
                
                svgLines += '</svg>';
                
                // Positionner les personnages (draggables)
                project.characters.forEach((char, i) => {
                    const pos = positions[i];
                    
                    graphHTML += `
                        <div id="char-node-${char.id}" 
                             class="char-node-draggable"
                             data-char-id="${char.id}"
                             style="position: absolute; left: ${pos.x}px; top: ${pos.y}px; transform: translate(-50%, -50%); text-align: center; cursor: move;"
                             onmousedown="startDragCharacter(event, ${char.id})"
                             onclick="handleCharacterClick(event, ${char.id})">
                            <div style="width: 70px; height: 70px; border-radius: 50%; background: var(--accent-gold); 
                                        display: flex; align-items: center; justify-content: center; font-size: 2rem;
                                        border: 3px solid white; box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                                        ${selectedCharsForRelation.includes(char.id) ? 'border-color: var(--accent-red); border-width: 5px;' : ''}
                                        transition: transform 0.2s;">
                                ${char.avatar || '👤'}
                            </div>
                            <div style="margin-top: 0.5rem; font-weight: 600; font-size: 0.9rem; background: var(--bg-accent); color: white;
                                        padding: 0.25rem 0.5rem; border-radius: 4px; white-space: nowrap; pointer-events: none;">${char.name}</div>
                        </div>
                    `;
                });
                
                graphHTML = svgLines + graphHTML;
            } else {
                graphHTML = `
                    <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center;">
                        <div style="font-size: 4rem; margin-bottom: 1rem;"><i data-lucide="users" style="width:64px;height:64px;"></i></div>
                        <div style="font-size: 1.3rem; font-weight: 600; margin-bottom: 0.5rem;">Aucune relation à afficher</div>
                        <div style="color: var(--text-muted); margin-bottom: 1rem;">Créez au moins 2 personnages pour visualiser leurs relations</div>
                        <button class="btn btn-primary" onclick="switchView('characters')">+ Créer des personnages</button>
                    </div>
                `;
            }
            
            editorView.innerHTML = `
                <div style="height: 100%; overflow-y: auto; padding: 2rem 3rem;">
                    <h2 style="margin-bottom: 2rem; color: var(--accent-gold);"><i data-lucide="network" style="width:24px;height:24px;vertical-align:middle;margin-right:8px;"></i>Carte des Relations</h2>
                    
                    ${project.characters.length >= 2 ? `
                        <div style="margin-bottom: 2rem; display: flex; gap: 1rem; flex-wrap: wrap;">
                            <div style="flex: 1; min-width: 300px; padding: 1.5rem; background: var(--bg-secondary); border-radius: 8px; border-left: 4px solid var(--accent-gold);">
                                <div style="font-weight: 600; margin-bottom: 0.5rem;"><i data-lucide="pen-line" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Créer une relation:</div>
                                <div style="font-size: 0.9rem; color: var(--text-secondary); line-height: 1.6;">
                                    1. Cliquez sur un premier personnage<br>
                                    2. Cliquez sur un second personnage<br>
                                    3. Choisissez le type de relation
                                </div>
                            </div>
                            <div style="flex: 1; min-width: 300px; padding: 1.5rem; background: var(--bg-secondary); border-radius: 8px; border-left: 4px solid var(--accent-red);">
                                <div style="font-weight: 600; margin-bottom: 0.5rem;">🖱️ Déplacer les personnages:</div>
                                <div style="font-size: 0.9rem; color: var(--text-secondary); line-height: 1.6;">
                                    Faites glisser les personnages pour réorganiser le graphe<br>
                                    Les liens suivent automatiquement
                                </div>
                            </div>
                        </div>
                        <div style="margin-bottom: 1rem; display: flex; gap: 0.5rem;">
                            <button class="btn btn-small" onclick="resetCharacterPositions()">🔄 Réinitialiser positions</button>
                            <button class="btn btn-small" onclick="autoArrangeCharacters()"><i data-lucide="sparkles" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;"></i>Arranger automatiquement</button>
                        </div>
                    ` : ''}
                    
                    <div id="relationsGraph" style="position: relative; height: 700px; background: var(--bg-secondary); border-radius: 8px; margin-bottom: 2rem;">
                        ${graphHTML}
                    </div>
                    
                    ${project.characters.length >= 2 ? `
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1rem; margin-bottom: 2rem;">
                            ${Object.entries(relationTypes).map(([key, rel]) => `
                                <div style="display: flex; align-items: center; gap: 0.75rem; padding: 1rem; background: var(--bg-secondary); border-radius: 8px; border-left: 4px solid ${rel.color};">
                                    <div style="font-size: 1.5rem;">${rel.icon}</div>
                                    <div style="flex: 1;">
                                        <div style="font-weight: 600; font-size: 0.95rem;">${rel.label.split(' ')[1]}</div>
                                        <div style="font-size: 0.75rem; color: var(--text-muted);">${getRelationCount(key)} relation(s)</div>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    ` : ''}
                    
                    ${project.relations && project.relations.length > 0 ? `
                        <div style="background: var(--bg-secondary); padding: 1.5rem; border-radius: 8px;">
                            <h3 style="margin-bottom: 1rem; color: var(--text-primary);"><i data-lucide="list" style="width:18px;height:18px;vertical-align:middle;margin-right:6px;"></i>Liste des relations (${project.relations.length})</h3>
                            <div style="display: flex; flex-direction: column; gap: 0.75rem;">
                                ${project.relations.map(rel => {
                                    const char1 = project.characters.find(c => c.id === rel.char1Id);
                                    const char2 = project.characters.find(c => c.id === rel.char2Id);
                                    const relType = relationTypes[rel.type] || relationTypes['neutre'];
                                    return char1 && char2 ? `
                                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 1rem; background: var(--bg-primary); border-radius: 4px; border-left: 4px solid ${relType.color};">
                                            <div style="display: flex; align-items: center; gap: 1rem;">
                                                <span style="font-size: 1.5rem;">${relType.icon}</span>
                                                <span style="font-weight: 600;">${char1.name}</span>
                                                <span style="color: var(--text-muted);">↔</span>
                                                <span style="font-weight: 600;">${char2.name}</span>
                                                ${rel.description ? `<span style="color: var(--text-muted); font-size: 0.85rem;">· ${rel.description}</span>` : ''}
                                            </div>
                                            <div style="display: flex; gap: 0.5rem;">
                                                <button class="btn btn-small" onclick="editRelation('${rel.id}')">✏️</button>
                                                <button class="btn btn-small" onclick="deleteRelation('${rel.id}')">🗑️</button>
                                            </div>
                                        </div>
                                    ` : '';
                                }).join('')}
                            </div>
                        </div>
                    ` : ''}
                </div>
            `;
            
            // Ajouter les événements de hover sur les personnages
            setTimeout(() => {
                document.querySelectorAll('.char-node-draggable').forEach(node => {
                    node.addEventListener('mouseenter', () => {
                        node.querySelector('div').style.transform = 'scale(1.1)';
                    });
                    node.addEventListener('mouseleave', () => {
                        node.querySelector('div').style.transform = 'scale(1)';
                    });
                });
            }, 0);
        }
        
        // Variables pour le drag-and-drop
        let draggedCharId = null;
        let dragStartX = 0;
        let dragStartY = 0;
        let isDragging = false;
        let dragMoved = false;
        
        function startDragCharacter(event, charId) {
            event.preventDefault();
            draggedCharId = charId;
            dragStartX = event.clientX;
            dragStartY = event.clientY;
            isDragging = true;
            dragMoved = false;
            
            document.addEventListener('mousemove', dragCharacter);
            document.addEventListener('mouseup', stopDragCharacter);
        }
        
        function dragCharacter(event) {
            if (!isDragging || !draggedCharId) return;
            
            const deltaX = event.clientX - dragStartX;
            const deltaY = event.clientY - dragStartY;
            
            // Considérer comme un drag si mouvement > 5px
            if (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5) {
                dragMoved = true;
            }
            
            const node = document.getElementById(`char-node-${draggedCharId}`);
            if (!node) return;
            
            const graph = document.getElementById('relationsGraph');
            const graphRect = graph.getBoundingClientRect();
            
            // Position actuelle
            const currentLeft = parseFloat(node.style.left);
            const currentTop = parseFloat(node.style.top);
            
            // Nouvelle position
            let newLeft = currentLeft + deltaX;
            let newTop = currentTop + deltaY;
            
            // Limiter aux bords du graphe
            newLeft = Math.max(50, Math.min(graphRect.width - 50, newLeft));
            newTop = Math.max(50, Math.min(graphRect.height - 50, newTop));
            
            node.style.left = newLeft + 'px';
            node.style.top = newTop + 'px';
            
            dragStartX = event.clientX;
            dragStartY = event.clientY;
            
            // Mettre à jour les lignes SVG
            updateRelationLines();
        }
        
        function stopDragCharacter(event) {
            if (!isDragging) return;
            
            document.removeEventListener('mousemove', dragCharacter);
            document.removeEventListener('mouseup', stopDragCharacter);
            
            if (dragMoved) {
                // Sauvegarder la nouvelle position
                const node = document.getElementById(`char-node-${draggedCharId}`);
                if (node) {
                    if (!project.characterPositions) project.characterPositions = {};
                    project.characterPositions[draggedCharId] = {
                        x: parseFloat(node.style.left),
                        y: parseFloat(node.style.top)
                    };
                    saveProject();
                    showNotification('📍 Position sauvegardée');
                }
            }
            
            isDragging = false;
            draggedCharId = null;
            dragMoved = false;
        }
        
        function handleCharacterClick(event, charId) {
            // Ne pas traiter comme un clic si c'était un drag
            if (dragMoved) {
                event.stopPropagation();
                return;
            }
            
            selectCharacterForRelation(charId);
        }
        
        function updateRelationLines() {
            const svg = document.getElementById('relationsSvg');
            if (!svg) return;
            
            const relationTypes = {
                'amour': { color: '#e91e63', icon: '❤️' },
                'amitie': { color: '#4caf50', icon: '🤝' },
                'rivalite': { color: '#f44336', icon: '⚔️' },
                'famille': { color: '#2196f3', icon: '👨‍👩‍👧' },
                'mentor': { color: '#ff9800', icon: '📚' },
                'ennemi': { color: '#9c27b0', icon: '💀' },
                'alliance': { color: '#00bcd4', icon: '🤜🤛' },
                'neutre': { color: '#757575', icon: '😐' }
            };
            
            let svgContent = '';
            
            project.relations.forEach(rel => {
                const char1 = project.characters.find(c => c.id === rel.char1Id);
                const char2 = project.characters.find(c => c.id === rel.char2Id);
                
                if (char1 && char2) {
                    const node1 = document.getElementById(`char-node-${char1.id}`);
                    const node2 = document.getElementById(`char-node-${char2.id}`);
                    
                    if (node1 && node2) {
                        const x1 = parseFloat(node1.style.left);
                        const y1 = parseFloat(node1.style.top);
                        const x2 = parseFloat(node2.style.left);
                        const y2 = parseFloat(node2.style.top);
                        
                        const relType = relationTypes[rel.type] || relationTypes['neutre'];
                        
                        svgContent += `
                            <line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" 
                                  stroke="${relType.color}" 
                                  stroke-width="3" 
                                  opacity="0.7"
                                  style="cursor: pointer;"
                                  onclick="editRelation('${rel.id}')"/>
                            <text x="${(x1 + x2) / 2}" y="${(y1 + y2) / 2 - 10}" 
                                  fill="${relType.color}" 
                                  font-size="20" 
                                  text-anchor="middle"
                                  style="pointer-events: none;">${relType.icon}</text>
                        `;
                    }
                }
            });
            
            svg.innerHTML = svgContent;
        }
        
        function resetCharacterPositions() {
            if (confirm('Réinitialiser toutes les positions des personnages ?')) {
                project.characterPositions = {};
                saveProject();
                renderRelationsView();
                showNotification('🔄 Positions réinitialisées');
            }
        }
        
        function autoArrangeCharacters() {
            // Arranger en cercle avec plus d'espace
            const centerX = 400;
            const centerY = 350;
            const radius = 220;
            
            project.characterPositions = {};
            project.characters.forEach((char, i) => {
                const angle = (i / project.characters.length) * 2 * Math.PI;
                project.characterPositions[char.id] = {
                    x: centerX + radius * Math.cos(angle),
                    y: centerY + radius * Math.sin(angle)
                };
            });
            
            saveProject();
            renderRelationsView();
            showNotification('✨ Personnages arrangés automatiquement');
        }
        
        // Variables pour la sélection de personnages
        let selectedCharsForRelation = [];
        
        function selectCharacterForRelation(charId) {
            if (selectedCharsForRelation.includes(charId)) {
                // Désélectionner
                selectedCharsForRelation = selectedCharsForRelation.filter(id => id !== charId);
            } else {
                selectedCharsForRelation.push(charId);
            }
            
            // Si 2 personnages sélectionnés, demander le type de relation
            if (selectedCharsForRelation.length === 2) {
                createRelationModal();
            } else {
                renderRelationsView();
            }
        }
        
        function createRelationModal() {
            const char1 = project.characters.find(c => c.id === selectedCharsForRelation[0]);
            const char2 = project.characters.find(c => c.id === selectedCharsForRelation[1]);
            
            const relationTypes = {
                'amour': { color: '#e91e63', label: '❤️ Amour' },
                'amitie': { color: '#4caf50', label: '🤝 Amitié' },
                'rivalite': { color: '#f44336', label: '⚔️ Rivalité' },
                'famille': { color: '#2196f3', label: '👨‍👩‍👧 Famille' },
                'mentor': { color: '#ff9800', label: '📚 Mentor' },
                'ennemi': { color: '#9c27b0', label: '💀 Ennemi' },
                'alliance': { color: '#00bcd4', label: '🤜🤛 Alliance' },
                'neutre': { color: '#757575', label: '😐 Neutre' }
            };
            
            const modalHTML = `
                <div class="modal active" id="relationModal" onclick="if(event.target===this) closeRelationModal()">
                    <div class="modal-content" style="max-width: 500px;">
                        <h2 style="margin-bottom: 1.5rem;"><i data-lucide="link" style="width:20px;height:20px;vertical-align:middle;margin-right:6px;"></i>Créer une relation</h2>
                        
                        <div style="margin-bottom: 1.5rem; padding: 1rem; background: var(--bg-secondary); border-radius: 8px; text-align: center;">
                            <span style="font-weight: 600; font-size: 1.1rem;">${char1.name}</span>
                            <span style="margin: 0 1rem; color: var(--text-muted);">↔</span>
                            <span style="font-weight: 600; font-size: 1.1rem;">${char2.name}</span>
                        </div>
                        
                        <div style="margin-bottom: 1.5rem;">
                            <label style="display: block; font-weight: 600; margin-bottom: 0.75rem;">Type de relation:</label>
                            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.5rem;">
                                ${Object.entries(relationTypes).map(([key, rel]) => `
                                    <button class="btn" onclick="selectRelationType('${key}')" 
                                            id="relType-${key}"
                                            style="justify-content: flex-start; text-align: left; padding: 0.75rem;">
                                        <div style="width: 4px; height: 100%; background: ${rel.color}; position: absolute; left: 0; top: 0; bottom: 0;"></div>
                                        ${rel.label}
                                    </button>
                                `).join('')}
                            </div>
                        </div>
                        
                        <div style="margin-bottom: 1.5rem;">
                            <label style="display: block; font-weight: 600; margin-bottom: 0.5rem;">Description (optionnel):</label>
                            <input type="text" class="form-input" id="relationDescription" placeholder="Ex: Frère et sœur, alliés depuis l'enfance...">
                        </div>
                        
                        <div style="display: flex; gap: 0.5rem; justify-content: flex-end;">
                            <button class="btn" onclick="closeRelationModal()">Annuler</button>
                            <button class="btn btn-primary" onclick="saveRelation()" id="saveRelationBtn" disabled>Créer la relation</button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', modalHTML);
        }
        
        let selectedRelationType = null;
        
        function selectRelationType(type) {
            selectedRelationType = type;
            
            // Mettre à jour l'UI
            document.querySelectorAll('[id^="relType-"]').forEach(btn => {
                btn.classList.remove('btn-primary');
            });
            document.getElementById(`relType-${type}`).classList.add('btn-primary');
            document.getElementById('saveRelationBtn').disabled = false;
        }
        
        function saveRelation() {
            if (!selectedRelationType) return;
            
            const description = document.getElementById('relationDescription').value;
            
            if (!project.relations) project.relations = [];
            
            project.relations.push({
                id: 'rel_' + Date.now(),
                char1Id: selectedCharsForRelation[0],
                char2Id: selectedCharsForRelation[1],
                type: selectedRelationType,
                description: description,
                createdAt: new Date().toISOString()
            });
            
            saveProject();
            closeRelationModal();
            selectedCharsForRelation = [];
            selectedRelationType = null;
            renderRelationsView();
            showNotification('🔗 Relation créée');
        }
        
        function closeRelationModal() {
            const modal = document.getElementById('relationModal');
            if (modal) modal.remove();
            selectedCharsForRelation = [];
            selectedRelationType = null;
            renderRelationsView();
        }
        
        function getRelationCount(type) {
            if (!project.relations) return 0;
            return project.relations.filter(r => r.type === type).length;
        }
        
        function editRelation(relId) {
            const relation = project.relations.find(r => r.id === relId);
            if (!relation) return;
            
            // Pour l'instant, juste permettre de changer la description
            const newDesc = prompt('Modifier la description:', relation.description || '');
            if (newDesc !== null) {
                relation.description = newDesc;
                saveProject();
                renderRelationsView();
                showNotification('✏️ Relation modifiée');
            }
        }
        
        function deleteRelation(relId) {
            if (confirm('Supprimer cette relation ?')) {
                project.relations = project.relations.filter(r => r.id !== relId);
                saveProject();
                renderRelationsView();
                showNotification('🗑️ Relation supprimée');
            }
        }
        
        function exportRelations() {
            alert('Export graphique des relations à venir');
        }

// ========== 35.renderMap.js ==========

        // ============================================
        // MAP FUNCTIONS
        // ============================================
        
        function renderMapView() {
            const editorView = document.getElementById('editorView');
            if (!editorView) {
                console.error('editorView not found');
                return;
            }
            
            // S'assurer que mapLocations et mapImage existent
            if (!project.mapLocations) project.mapLocations = [];
            if (!project.mapImage) project.mapImage = null;
            
            let mapContent = '';
            if (project.mapImage) {
                mapContent = `
                    <div style="position: relative; display: inline-block; max-width: 100%;">
                        <img src="${project.mapImage}" 
                             id="worldMapImage"
                             style="max-width: 100%; height: auto; display: block; cursor: crosshair; border: 2px solid var(--border-color); border-radius: 4px;" 
                             alt="Carte du monde"
                             onclick="handleMapClick(event)">
                        ${project.mapLocations.map((loc, i) => `
                            <div class="map-location" 
                                 style="position: absolute; left: ${loc.x}%; top: ${loc.y}%; 
                                        width: 20px; height: 20px; 
                                        background: var(--accent-red); 
                                        border: 2px solid white;
                                        border-radius: 50%; 
                                        transform: translate(-50%, -50%);
                                        cursor: pointer;
                                        box-shadow: 0 2px 8px rgba(0,0,0,0.3);
                                        z-index: 10;"
                                 title="${loc.name}"
                                 onclick="event.stopPropagation(); editMapLocation(${i})">
                                <div style="position: absolute; top: -30px; left: 50%; transform: translateX(-50%);
                                           background: var(--bg-accent); color: white; padding: 0.25rem 0.5rem;
                                           border-radius: 4px; white-space: nowrap; font-size: 0.75rem;
                                           pointer-events: none; opacity: 0; transition: opacity 0.2s;"
                                     class="map-location-label">${loc.name}</div>
                            </div>
                        `).join('')}
                    </div>
                    <style>
                        .map-location:hover .map-location-label {
                            opacity: 1 !important;
                        }
                    </style>
                `;
            } else {
                mapContent = `
                    <div style="padding: 4rem; text-align: center; background: var(--bg-secondary); border-radius: 8px; border: 2px dashed var(--border-color);">
                        <div style="font-size: 4rem; margin-bottom: 1rem;">???</div>
                        <div style="font-size: 1.2rem; font-weight: 600; margin-bottom: 0.5rem;">Aucune carte chargée</div>
                        <div style="color: var(--text-muted); margin-bottom: 1.5rem;">Cliquez sur "Charger carte" pour ajouter une image</div>
                        <button class="btn btn-primary" onclick="uploadMapImage()">?? Charger une carte</button>
                    </div>
                `;
            }
            
            editorView.innerHTML = `
                <div style="height: 100%; overflow-y: auto; padding: 2rem 3rem;">
                    <h2 style="margin-bottom: 2rem; color: var(--accent-gold);">??? Carte Géographique</h2>
                    
                    <div style="margin-bottom: 2rem; display: flex; gap: 0.5rem; flex-wrap: wrap;">
                        <button class="btn btn-primary" onclick="uploadMapImage()">??? Charger carte</button>
                        <button class="btn" onclick="addMapLocation()" ${!project.mapImage ? 'disabled' : ''}>?? Ajouter lieu</button>
                        <button class="btn btn-small" onclick="clearMap()" ${!project.mapImage ? 'disabled' : ''}>??? Effacer carte</button>
                        <button class="btn btn-small" onclick="exportMapData()">?? Exporter données</button>
                    </div>
                    
                    <div style="background: var(--bg-secondary); padding: 2rem; border-radius: 8px; text-align: center;">
                        ${mapContent}
                    </div>
                    
                    ${project.mapLocations.length > 0 ? `
                        <div style="margin-top: 2rem; background: var(--bg-secondary); padding: 1.5rem; border-radius: 8px;">
                            <h3 style="margin-bottom: 1rem; color: var(--text-primary);">?? Lieux marqués (${project.mapLocations.length})</h3>
                            <div style="display: grid; gap: 0.5rem;">
                                ${project.mapLocations.map((loc, i) => `
                                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.75rem; background: var(--bg-primary); border-radius: 4px;">
                                        <span style="font-weight: 500;">${loc.name}</span>
                                        <div style="display: flex; gap: 0.5rem;">
                                            <button class="btn btn-small" onclick="editMapLocation(${i})">??</button>
                                            <button class="btn btn-small" onclick="deleteMapLocation(${i})">???</button>
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    ` : ''}
                    
                    <div style="margin-top: 2rem; padding: 1.5rem; background: var(--bg-secondary); border-radius: 8px; border-left: 4px solid var(--accent-gold);">
                        <p style="font-size: 0.95rem; color: var(--text-secondary); line-height: 1.6;">
                            ?? <strong>Utilisation:</strong><br>
                            1. Chargez une image de carte (dessinée à la main, générée par IA, etc.)<br>
                            2. Cliquez directement sur la carte pour placer un marqueur<br>
                            3. Cliquez sur un marqueur existant pour le modifier ou le supprimer
                        </p>
                    </div>
                </div>
            `;
        }
        
        function handleMapClick(event) {
            // S'assurer que mapLocations existe
            if (!project.mapLocations) project.mapLocations = [];
            
            const img = event.target;
            const rect = img.getBoundingClientRect();
            const x = ((event.clientX - rect.left) / rect.width) * 100;
            const y = ((event.clientY - rect.top) / rect.height) * 100;
            
            const name = prompt('Nom du lieu:');
            if (name) {
                project.mapLocations.push({
                    name: name,
                    x: Math.max(0, Math.min(100, x)),
                    y: Math.max(0, Math.min(100, y)),
                    description: ''
                });
                saveProject();
                renderMapView();
                showNotification(`?? Lieu "${name}" ajouté`);
            }
        }
        
        function uploadMapImage() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        project.mapImage = event.target.result;
                        saveProject();
                        renderMapView();
                    };
                    reader.readAsDataURL(file);
                }
            };
            input.click();
        }
        
        function addMapLocation() {
            if (!project.mapImage) {
                alert('Veuillez d\'abord charger une carte');
                return;
            }
            // S'assurer que mapLocations existe
            if (!project.mapLocations) project.mapLocations = [];
            
            const name = prompt('Nom du lieu:');
            if (name) {
                project.mapLocations.push({
                    name: name,
                    x: 50 + Math.random() * 40,
                    y: 30 + Math.random() * 40,
                    description: ''
                });
                saveProject();
                renderMapView();
            }
        }
        
        function editMapLocation(index) {
            const loc = project.mapLocations[index];
            const newName = prompt('Modifier le nom:', loc.name);
            if (newName) {
                loc.name = newName;
                saveProject();
                renderMapView();
                showNotification(`?? Lieu modifié: ${newName}`);
            }
        }
        
        function deleteMapLocation(index) {
            const loc = project.mapLocations[index];
            if (confirm(`Supprimer le lieu "${loc.name}" ?`)) {
                project.mapLocations.splice(index, 1);
                saveProject();
                renderMapView();
                showNotification(`??? Lieu supprimé: ${loc.name}`);
            }
        }
        
        function clearMap() {
            if (confirm('Effacer la carte et tous les lieux ?')) {
                project.mapImage = null;
                project.mapLocations = [];
                saveProject();
                renderMapView();
                showNotification('??? Carte effacée');
            }
        }
        
        function exportMapData() {
            const data = {
                image: project.mapImage ? 'Image présente' : 'Pas d\'image',
                locations: project.mapLocations
            };
            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `carte_${project.title.replace(/[^a-z0-9]/gi, '_')}.json`;
            a.click();
            showNotification('?? Données de la carte exportées');
        }


// ========== 36.timeline-metro.js ==========
// ============================================
		// ============================================
        // ============================================
        // TIMELINE VIZ FUNCTIONS
        // ============================================
        
        function renderTimelineVizList() {
            const container = document.getElementById('timelineVizList');
            if (!container) {
                console.error('timelineVizList container not found');
                return;
            }
            
            // S'assurer que metroTimeline et characterColors existent
            if (!project.metroTimeline) {
                project.metroTimeline = [];
            }
            if (!project.characterColors) {
                project.characterColors = {};
            }
            
            // Assigner des couleurs par défaut aux personnages qui n'en ont pas
            const defaultColors = ['#E53935', '#1E88E5', '#43A047', '#FB8C00', '#8E24AA', '#00ACC1', '#FFB300', '#D81B60', '#5E35B1', '#00897B'];
            project.characters.forEach((char, i) => {
                if (!project.characterColors[char.id]) {
                    project.characterColors[char.id] = defaultColors[i % defaultColors.length];
                }
            });
            
            // Compter les événements
            const eventCount = project.metroTimeline.length;
            const charCount = project.characters.length;
            
            // Sidebar avec personnages et liste d'événements
            container.innerHTML = `
                <div style="padding: 1rem;">
                    <h3 style="margin-bottom: 1rem; display: flex; align-items: center; gap: 0.5rem;">
                        <i data-lucide="train-track" style="width: 20px; height: 20px;"></i>
                        Timeline Métro
                    </h3>
                    <div style="font-size: 0.85rem; color: var(--text-secondary); line-height: 1.6;">
                        <div style="margin-bottom: 0.5rem;">📅 ${eventCount} événement(s)</div>
                        <div style="margin-bottom: 0.5rem;">👥 ${charCount} personnage(s)</div>
                        <div style="margin-top: 1rem;">
                            <button class="btn btn-primary" onclick="openMetroEventModal()" style="width: 100%;">
                                + Nouvel événement
                            </button>
                        </div>
                    </div>
                    ${eventCount > 0 ? `
                        <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--border-color);">
                            <div style="font-size: 0.85rem; font-weight: 600; margin-bottom: 0.5rem;">
                                <span>Événements:</span>
                            </div>
                            <div id="metroEventsList" class="metro-events-sortable">
                                ${project.metroTimeline.sort((a,b) => (a.order || 0) - (b.order || 0)).map((event, i, arr) => `
                                    <div class="metro-event-item" data-event-id="${event.id}">
                                        <div class="metro-event-reorder-btns">
                                            <button class="metro-reorder-btn" onclick="moveMetroEvent(${event.id}, -1)" ${i === 0 ? 'disabled' : ''} title="Monter">▲</button>
                                            <button class="metro-reorder-btn" onclick="moveMetroEvent(${event.id}, 1)" ${i === arr.length - 1 ? 'disabled' : ''} title="Descendre">▼</button>
                                        </div>
                                        <div class="metro-event-item-content" onclick="openMetroEventModal(${event.id})">
                                            <div style="display: flex; align-items: center; gap: 0.5rem;">
                                                <div style="font-weight: 600; flex: 1;">${event.title}</div>
                                                ${event.sceneId ? `<i data-lucide="file-text" style="width: 14px; height: 14px; color: var(--accent-blue); cursor: pointer;" onclick="event.stopPropagation(); openMetroLinkedScene(${event.sceneId})" title="Scène liée"></i>` : ''}
                                            </div>
                                            <div style="color: var(--text-muted); font-size: 0.75rem;">${event.date || 'Sans date'}</div>
                                            <div style="display: flex; gap: 2px; margin-top: 4px;">
                                                ${(event.characters || []).map(charId => {
                                                    const char = project.characters.find(c => c.id === charId);
                                                    return char ? `<span style="width: 12px; height: 12px; border-radius: 50%; background: ${project.characterColors[charId] || '#999'};" title="${char.name}"></span>` : '';
                                                }).join('')}
                                            </div>
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    ` : ''}
                </div>
            `;
            
            // Rafraîchir les icônes Lucide pour la sidebar
            if (eventCount > 0) {
                if (typeof lucide !== 'undefined') lucide.createIcons();
            }
        }
        
        function renderTimelineVizView() {
            // Render sidebar first
            renderTimelineVizList();
            
            // Render main view
            const editorView = document.getElementById('editorView');
            if (!editorView) {
                console.error('editorView not found for metro timeline');
                return;
            }
            
            const charCount = project.characters?.length || 0;
            
            if (charCount === 0) {
                editorView.innerHTML = `
                    <div class="metro-empty-state">
                        <i data-lucide="users" style="width: 64px; height: 64px; opacity: 0.3;"></i>
                        <h3 style="margin: 1rem 0 0.5rem;">Aucun personnage</h3>
                        <p style="margin-bottom: 1.5rem;">Créez d'abord des personnages dans l'onglet "Personnages" pour pouvoir les lier aux événements de votre timeline.</p>
                        <button class="btn btn-primary" onclick="switchView('characters')">Créer des personnages</button>
                    </div>
                `;
                lucide.createIcons();
                return;
            }
            
            editorView.innerHTML = `
                <div style="padding: 2rem;">
                    <div class="metro-toolbar">
                        <button class="btn btn-primary" onclick="openMetroEventModal()">
                            <i data-lucide="plus" style="width: 16px; height: 16px;"></i>
                            Nouvel événement
                        </button>
                        <button class="btn" onclick="sortMetroByDate()">
                            <i data-lucide="calendar" style="width: 16px; height: 16px;"></i>
                            Trier par date
                        </button>
                        <button class="btn" onclick="exportMetroTimelineCSV()">
                            <i data-lucide="download" style="width: 16px; height: 16px;"></i>
                            Exporter CSV
                        </button>
                        <button class="btn" onclick="clearMetroTimeline()" style="margin-left: auto;">
                            <i data-lucide="trash-2" style="width: 16px; height: 16px;"></i>
                            Tout effacer
                        </button>
                    </div>
                    
                    <div class="metro-timeline-container" id="metroTimelineContainer">
                        ${renderMetroSVG()}
                    </div>
                    
                    <div class="metro-legend">
                        ${project.characters.map(char => `
                            <div class="metro-legend-item" onclick="openMetroColorPicker(${char.id})" style="cursor: pointer;" title="Cliquer pour changer la couleur">
                                <div class="metro-legend-line" style="background: ${project.characterColors[char.id] || '#999'};"></div>
                                <span>${char.name}</span>
                            </div>
                        `).join('')}
                    </div>
                    
                    <div style="margin-top: 1rem; padding: 1rem; background: var(--bg-secondary); border-radius: 4px;">
                        <p style="font-size: 0.9rem; color: var(--text-secondary);">
                            💡 <strong>Utilisation:</strong> Cliquez sur les cercles pour éditer les événements. Les petites icônes bleues 📄 permettent d'ouvrir directement la scène liée. Cliquez sur les couleurs dans la légende pour les personnaliser. Les lignes se rejoignent quand des personnages partagent un événement.
                        </p>
                    </div>
                </div>
            `;
            
            lucide.createIcons();
        }
        
        function renderMetroSVG() {
            const events = (project.metroTimeline || []).sort((a, b) => (a.order || 0) - (b.order || 0));
            const characters = project.characters || [];
            
            if (events.length === 0) {
                return `
                    <div class="metro-empty-state">
                        <i data-lucide="train-track" style="width: 64px; height: 64px; opacity: 0.3;"></i>
                        <h3 style="margin: 1rem 0 0.5rem;">Aucun événement</h3>
                        <p style="margin-bottom: 1.5rem;">Créez votre premier événement pour commencer à visualiser les interactions entre personnages.</p>
                        <button class="btn btn-primary" onclick="openMetroEventModal()">+ Créer un événement</button>
                    </div>
                `;
            }
            
            // Calculer les dimensions
            const rowHeight = 60;
            const eventWidth = 180;
            const leftMargin = 180;
            const topMargin = 40;
            const nodeRadius = 10;
            
            const svgWidth = leftMargin + (events.length * eventWidth) + 100;
            const svgHeight = Math.max(200, topMargin + (characters.length * rowHeight) + 60);
            
            // Générer les lignes horizontales et les paths courbes
            let pathsHTML = '';
            let nodesHTML = '';
            let labelsHTML = '';
            let characterLabelsHTML = '';
            
            // Pour chaque personnage, dessiner sa ligne
            characters.forEach((char, charIndex) => {
                const y = topMargin + (charIndex * rowHeight) + (rowHeight / 2);
                const color = project.characterColors[char.id] || '#999';
                
                // Label du personnage à gauche
                characterLabelsHTML += `
                    <g class="metro-char-label" onclick="openMetroColorPicker(${char.id})" style="cursor: pointer;">
                        <rect x="5" y="${y - 15}" width="160" height="30" fill="transparent"/>
                        <circle cx="25" cy="${y}" r="10" fill="${color}" stroke="white" stroke-width="2"/>
                        <text x="42" y="${y + 5}" font-size="13" fill="var(--text-primary)" font-weight="500">${char.name.substring(0, 18)}${char.name.length > 18 ? '...' : ''}</text>
                    </g>
                `;
                
                // Trouver les événements où ce personnage participe
                const charEvents = events.filter(e => (e.characters || []).includes(char.id));
                
                if (charEvents.length === 0) {
                    // Ligne en pointillés si pas d'événements
                    pathsHTML += `<line x1="${leftMargin}" y1="${y}" x2="${svgWidth - 50}" y2="${y}" stroke="${color}" stroke-width="3" stroke-dasharray="5,5" opacity="0.3"/>`;
                } else {
                    // Dessiner le chemin entre les événements
                    let pathD = '';
                    let lastX = leftMargin;
                    
                    charEvents.forEach((event, eventIdx) => {
                        const eventGlobalIdx = events.indexOf(event);
                        const eventX = leftMargin + (eventGlobalIdx * eventWidth) + (eventWidth / 2);
                        
                        // Calculer Y pour cet événement (converger vers le centre si plusieurs personnages)
                        const eventChars = event.characters || [];
                        const charPosInEvent = eventChars.indexOf(char.id);
                        const totalCharsInEvent = eventChars.length;
                        
                        // Y central de l'événement (moyenne des Y de tous les personnages présents)
                        const avgY = eventChars.reduce((sum, cId) => {
                            const cIdx = characters.findIndex(c => c.id === cId);
                            return sum + (cIdx >= 0 ? topMargin + (cIdx * rowHeight) + (rowHeight / 2) : 0);
                        }, 0) / totalCharsInEvent;
                        
                        const eventY = avgY;
                        
                        if (eventIdx === 0) {
                            // Premier segment: de la ligne de base vers le premier événement
                            pathD = `M ${lastX} ${y}`;
                            
                            // Courbe vers le point de convergence
                            const midX = (lastX + eventX) / 2;
                            pathD += ` C ${midX} ${y}, ${midX} ${eventY}, ${eventX} ${eventY}`;
                        } else {
                            // Segments intermédiaires
                            const prevEvent = charEvents[eventIdx - 1];
                            const prevEventIdx = events.indexOf(prevEvent);
                            const prevX = leftMargin + (prevEventIdx * eventWidth) + (eventWidth / 2);
                            
                            // Y du précédent événement
                            const prevEventChars = prevEvent.characters || [];
                            const prevAvgY = prevEventChars.reduce((sum, cId) => {
                                const cIdx = characters.findIndex(c => c.id === cId);
                                return sum + (cIdx >= 0 ? topMargin + (cIdx * rowHeight) + (rowHeight / 2) : 0);
                            }, 0) / prevEventChars.length;
                            
                            // Courbe du précédent vers l'actuel
                            const midX = (prevX + eventX) / 2;
                            pathD += ` C ${midX} ${prevAvgY}, ${midX} ${eventY}, ${eventX} ${eventY}`;
                        }
                        
                        lastX = eventX;
                    });
                    
                    // Prolonger la ligne après le dernier événement
                    const lastEvent = charEvents[charEvents.length - 1];
                    const lastEventIdx = events.indexOf(lastEvent);
                    const lastEventX = leftMargin + (lastEventIdx * eventWidth) + (eventWidth / 2);
                    const lastEventChars = lastEvent.characters || [];
                    const lastAvgY = lastEventChars.reduce((sum, cId) => {
                        const cIdx = characters.findIndex(c => c.id === cId);
                        return sum + (cIdx >= 0 ? topMargin + (cIdx * rowHeight) + (rowHeight / 2) : 0);
                    }, 0) / lastEventChars.length;
                    
                    const endX = svgWidth - 50;
                    const midX = (lastEventX + endX) / 2;
                    pathD += ` C ${midX} ${lastAvgY}, ${midX} ${y}, ${endX} ${y}`;
                    
                    pathsHTML += `<path d="${pathD}" class="metro-line" stroke="${color}" fill="none"/>`;
                }
            });
            
            // Dessiner les nœuds d'événements (par-dessus les lignes)
            events.forEach((event, eventIdx) => {
                const eventX = leftMargin + (eventIdx * eventWidth) + (eventWidth / 2);
                const eventChars = event.characters || [];
                
                if (eventChars.length > 0) {
                    // Calculer le Y moyen
                    const avgY = eventChars.reduce((sum, cId) => {
                        const cIdx = characters.findIndex(c => c.id === cId);
                        return sum + (cIdx >= 0 ? topMargin + (cIdx * rowHeight) + (rowHeight / 2) : 0);
                    }, 0) / eventChars.length;
                    
                    // Nœud principal
                    nodesHTML += `
                        <g class="metro-event-node" onclick="openMetroEventModal(${event.id})">
                            <circle cx="${eventX}" cy="${avgY}" r="${nodeRadius + 2}" fill="white" stroke="var(--border-color)" stroke-width="2"/>
                            <circle cx="${eventX}" cy="${avgY}" r="${nodeRadius - 2}" fill="var(--text-primary)"/>
                        </g>
                        ${event.sceneId ? `
                            <g onclick="event.stopPropagation(); openMetroLinkedScene(${event.sceneId})" style="cursor: pointer;" title="Ouvrir la scène">
                                <circle cx="${eventX + nodeRadius + 8}" cy="${avgY - nodeRadius - 8}" r="8" fill="var(--accent-blue)" stroke="white" stroke-width="1.5"/>
                                <text x="${eventX + nodeRadius + 8}" y="${avgY - nodeRadius - 4}" text-anchor="middle" font-size="9" fill="white" font-weight="bold">📄</text>
                            </g>
                        ` : ''}
                    `;
                    
                    // Label de l'événement
                    const labelY = avgY < svgHeight / 2 ? avgY - 25 : avgY + 30;
                    labelsHTML += `
                        <g class="metro-event-label-group" onclick="openMetroEventModal(${event.id})" style="cursor: pointer;">
                            <text x="${eventX}" y="${labelY}" text-anchor="middle" class="metro-event-label" font-weight="600">${event.title.substring(0, 20)}${event.title.length > 20 ? '...' : ''}</text>
                            <text x="${eventX}" y="${labelY + 14}" text-anchor="middle" class="metro-event-label" font-size="10" fill="var(--text-muted)">${event.date || ''}</text>
                        </g>
                    `;
                } else {
                    // Événement sans personnages - afficher en haut
                    const floatingY = topMargin - 10;
                    nodesHTML += `
                        <g class="metro-event-node" onclick="openMetroEventModal(${event.id})">
                            <circle cx="${eventX}" cy="${floatingY}" r="${nodeRadius}" fill="var(--text-muted)" stroke="white" stroke-width="2"/>
                        </g>
                    `;
                    labelsHTML += `
                        <g onclick="openMetroEventModal(${event.id})" style="cursor: pointer;">
                            <text x="${eventX}" y="${floatingY - 15}" text-anchor="middle" class="metro-event-label" fill="var(--text-muted)">${event.title.substring(0, 15)}...</text>
                        </g>
                    `;
                }
            });
            
            return `
                <svg width="${svgWidth}" height="${svgHeight}" class="metro-svg-container">
                    <!-- Fond -->
                    <rect width="100%" height="100%" fill="var(--bg-primary)"/>
                    
                    <!-- Lignes de grille légères -->
                    ${characters.map((_, i) => {
                        const y = topMargin + (i * rowHeight) + (rowHeight / 2);
                        return `<line x1="${leftMargin}" y1="${y}" x2="${svgWidth}" y2="${y}" stroke="var(--border-color)" stroke-width="1" opacity="0.3" stroke-dasharray="2,4"/>`;
                    }).join('')}
                    
                    <!-- Labels personnages -->
                    ${characterLabelsHTML}
                    
                    <!-- Chemins des lignes de métro -->
                    ${pathsHTML}
                    
                    <!-- Nœuds des événements -->
                    ${nodesHTML}
                    
                    <!-- Labels des événements -->
                    ${labelsHTML}
                </svg>
            `;
        }
        
        function openMetroEventModal(eventId = null) {
            const modal = document.getElementById('metroEventModal');
            const titleEl = document.getElementById('metroEventModalTitle');
            const deleteBtn = document.getElementById('metroDeleteBtn');
            
            // Reset form
            document.getElementById('metroEventId').value = '';
            document.getElementById('metroEventTitle').value = '';
            document.getElementById('metroEventDate').value = '';
            document.getElementById('metroEventOrder').value = '';
            document.getElementById('metroEventDesc').value = '';
            document.getElementById('metroEventScene').value = '';
            
            // Populate scene selector
            const sceneSelect = document.getElementById('metroEventScene');
            let sceneOptions = '<option value="">Aucune scène</option>';
            project.acts.forEach(act => {
                act.chapters.forEach(chapter => {
                    chapter.scenes.forEach(scene => {
                        const scenePath = `${act.title} > ${chapter.title} > ${scene.title}`;
                        sceneOptions += `<option value="${scene.id}">${scenePath}</option>`;
                    });
                });
            });
            sceneSelect.innerHTML = sceneOptions;
            
            // Populate position selector
            const positionSelect = document.getElementById('metroEventPosition');
            const sortedEvents = (project.metroTimeline || []).sort((a, b) => (a.order || 0) - (b.order || 0));
            
            let positionOptions = '<option value="0">🔼 Au début de la timeline</option>';
            sortedEvents.forEach((evt, idx) => {
                if (!eventId || evt.id !== eventId) {
                    positionOptions += `<option value="${evt.order || idx + 1}">↳ Après: ${evt.title}${evt.date ? ' (' + evt.date + ')' : ''}</option>`;
                }
            });
            positionSelect.innerHTML = positionOptions;
            
            // Populate character selector
            const selectorDiv = document.getElementById('metroCharactersSelector');
            selectorDiv.innerHTML = project.characters.map(char => `
                <label class="metro-char-option" data-char-id="${char.id}">
                    <input type="checkbox" value="${char.id}" onchange="updateMetroLinkedChars()">
                    <span class="metro-char-color-dot" style="background: ${project.characterColors[char.id] || '#999'};"></span>
                    <span>${char.name}</span>
                </label>
            `).join('');
            
            if (eventId) {
                // Edit mode
                const event = project.metroTimeline.find(e => e.id === eventId);
                if (!event) return;
                
                titleEl.textContent = 'Modifier l\'événement';
                deleteBtn.style.display = '';
                
                document.getElementById('metroEventId').value = event.id;
                document.getElementById('metroEventTitle').value = event.title || '';
                document.getElementById('metroEventDate').value = event.date || '';
                document.getElementById('metroEventOrder').value = event.order !== undefined ? event.order : '';
                document.getElementById('metroEventDesc').value = event.description || '';
                document.getElementById('metroEventScene').value = event.sceneId || '';
                
                // Select current position (the event just before this one)
                const currentIdx = sortedEvents.findIndex(e => e.id === eventId);
                if (currentIdx > 0) {
                    const prevEvent = sortedEvents[currentIdx - 1];
                    positionSelect.value = prevEvent.order || currentIdx;
                } else {
                    positionSelect.value = '0';
                }
                
                // Check characters
                (event.characters || []).forEach(charId => {
                    const checkbox = selectorDiv.querySelector(`input[value="${charId}"]`);
                    if (checkbox) {
                        checkbox.checked = true;
                        checkbox.closest('.metro-char-option').classList.add('selected');
                    }
                });
            } else {
                // Create mode
                titleEl.textContent = 'Nouvel événement';
                deleteBtn.style.display = 'none';
                
                // Default position = at the end
                if (sortedEvents.length > 0) {
                    const lastEvent = sortedEvents[sortedEvents.length - 1];
                    positionSelect.value = lastEvent.order || sortedEvents.length;
                } else {
                    positionSelect.value = '0';
                }
                document.getElementById('metroEventOrder').value = sortedEvents.length + 1;
            }
            
            updateMetroLinkedChars();
            modal.classList.add('active');
            document.getElementById('metroEventTitle').focus();
        }
        
        function updateMetroLinkedChars() {
            const selectorDiv = document.getElementById('metroCharactersSelector');
            const linkedDiv = document.getElementById('metroLinkedChars');
            
            const checked = Array.from(selectorDiv.querySelectorAll('input:checked'));
            
            // Update visual selection
            selectorDiv.querySelectorAll('.metro-char-option').forEach(opt => {
                const checkbox = opt.querySelector('input');
                opt.classList.toggle('selected', checkbox.checked);
            });
            
            // Update linked tags
            linkedDiv.innerHTML = checked.map(cb => {
                const charId = parseInt(cb.value);
                const char = project.characters.find(c => c.id === charId);
                if (!char) return '';
                const color = project.characterColors[charId] || '#999';
                return `
                    <span class="metro-linked-char-tag" style="background: ${color};">
                        ${char.name}
                        <span class="remove-char" onclick="removeMetroCharFromEvent(${charId})">×</span>
                    </span>
                `;
            }).join('');
        }
        
        function removeMetroCharFromEvent(charId) {
            const selectorDiv = document.getElementById('metroCharactersSelector');
            const checkbox = selectorDiv.querySelector(`input[value="${charId}"]`);
            if (checkbox) {
                checkbox.checked = false;
                updateMetroLinkedChars();
            }
        }
        
        function saveMetroEvent() {
            const eventId = document.getElementById('metroEventId').value;
            const title = document.getElementById('metroEventTitle').value.trim();
            const date = document.getElementById('metroEventDate').value.trim();
            const positionAfter = parseFloat(document.getElementById('metroEventPosition').value) || 0;
            const description = document.getElementById('metroEventDesc').value.trim();
            const sceneIdValue = document.getElementById('metroEventScene').value;
            const sceneId = sceneIdValue ? parseInt(sceneIdValue) : null;
            
            if (!title) {
                alert('Le titre est obligatoire');
                return;
            }
            
            // Get selected characters
            const selectorDiv = document.getElementById('metroCharactersSelector');
            const characters = Array.from(selectorDiv.querySelectorAll('input:checked')).map(cb => parseInt(cb.value));
            
            if (!project.metroTimeline) {
                project.metroTimeline = [];
            }
            
            // Calculate new order based on position selection
            // positionAfter = 0 means "at the beginning"
            // positionAfter = N means "after the event with order N"
            let newOrder;
            if (positionAfter === 0) {
                newOrder = 0.5; // Will be normalized to 1 after reordering
            } else {
                newOrder = positionAfter + 0.5; // Insert after the selected event
            }
            
            if (eventId) {
                // Update existing
                const event = project.metroTimeline.find(e => e.id === parseInt(eventId));
                if (event) {
                    event.title = title;
                    event.date = date;
                    event.order = newOrder;
                    event.description = description;
                    event.characters = characters;
                    event.sceneId = sceneId;
                }
                showNotification('✓ Événement mis à jour');
            } else {
                // Create new
                project.metroTimeline.push({
                    id: Date.now(),
                    title,
                    date,
                    order: newOrder,
                    description,
                    characters,
                    sceneId: sceneId
                });
                showNotification('✓ Événement créé');
            }
            
            // Reorder all events to have clean sequential numbers
            normalizeMetroEventOrder();
            
            saveProject();
            closeModal('metroEventModal');
            
            // Check if we're in split-view mode
            if (splitViewActive && (splitViewState.left.view === 'timelineviz' || splitViewState.right.view === 'timelineviz')) {
                // Refresh the split panel(s) showing timeline
                if (splitViewState.left.view === 'timelineviz') {
                    renderSplitPanelViewContent('left');
                }
                if (splitViewState.right.view === 'timelineviz') {
                    renderSplitPanelViewContent('right');
                }
                // Also refresh the editor panel if it's showing a scene (to update the timeline badge)
                if (splitViewState.left.view === 'editor' && splitViewState.left.sceneId) {
                    renderSplitPanelViewContent('left');
                }
                if (splitViewState.right.view === 'editor' && splitViewState.right.sceneId) {
                    renderSplitPanelViewContent('right');
                }
            } else if (currentView === 'timelineviz') {
                // Normal full-screen timeline view
                renderTimelineVizView();
            } else if (currentSceneId && currentView === 'editor') {
                // Normal full-screen editor view - refresh to show the new link
                const act = project.acts.find(a => a.id === currentActId);
                const chapter = act?.chapters.find(c => c.id === currentChapterId);
                const scene = chapter?.scenes.find(s => s.id === currentSceneId);
                if (act && chapter && scene) {
                    renderEditor(act, chapter, scene);
                }
            }
        }
        
        function normalizeMetroEventOrder() {
            // Sort by current order
            project.metroTimeline.sort((a, b) => (a.order || 0) - (b.order || 0));
            
            // Reassign clean sequential numbers (1, 2, 3, ...)
            project.metroTimeline.forEach((event, i) => {
                event.order = i + 1;
            });
        }
        
        function moveMetroEvent(eventId, direction) {
            // direction: -1 = monter, 1 = descendre
            const sortedEvents = project.metroTimeline.sort((a, b) => (a.order || 0) - (b.order || 0));
            const currentIndex = sortedEvents.findIndex(e => e.id === eventId);
            
            if (currentIndex === -1) return;
            
            const newIndex = currentIndex + direction;
            
            // Vérifier les limites
            if (newIndex < 0 || newIndex >= sortedEvents.length) return;
            
            // Échanger les positions
            const temp = sortedEvents[currentIndex];
            sortedEvents[currentIndex] = sortedEvents[newIndex];
            sortedEvents[newIndex] = temp;
            
            // Mettre à jour les ordres
            sortedEvents.forEach((event, i) => {
                event.order = i + 1;
            });
            
            project.metroTimeline = sortedEvents;
            
            saveProject();
            refreshTimelineView();
        }
        
        function deleteMetroEvent() {
            const eventId = document.getElementById('metroEventId').value;
            if (!eventId) return;
            
            if (!confirm('Supprimer cet événement ?')) return;
            
            project.metroTimeline = project.metroTimeline.filter(e => e.id !== parseInt(eventId));
            saveProject();
            closeModal('metroEventModal');
            
            // Check if we're in split-view mode
            if (splitViewActive && (splitViewState.left.view === 'timelineviz' || splitViewState.right.view === 'timelineviz')) {
                // Refresh the split panel(s) showing timeline
                if (splitViewState.left.view === 'timelineviz') {
                    renderSplitPanelViewContent('left');
                }
                if (splitViewState.right.view === 'timelineviz') {
                    renderSplitPanelViewContent('right');
                }
            } else if (currentView === 'timelineviz') {
                // Normal full-screen timeline view
                renderTimelineVizView();
            }
            
            showNotification('✓ Événement supprimé');
        }
        
        function openMetroLinkedScene(sceneId) {
            // Find the scene
            let foundScene = null;
            let foundChapter = null;
            let foundAct = null;
            
            for (const act of project.acts) {
                for (const chapter of act.chapters) {
                    const scene = chapter.scenes.find(s => s.id === sceneId);
                    if (scene) {
                        foundScene = scene;
                        foundChapter = chapter;
                        foundAct = act;
                        break;
                    }
                }
                if (foundScene) break;
            }
            
            if (!foundScene) {
                showNotification('❌ Scène introuvable', 'error');
                return;
            }
            
            // Switch to editor view and open the scene
            switchView('editor');
            
            // Use the proper openScene function which handles everything
            setTimeout(() => {
                openScene(foundAct.id, foundChapter.id, foundScene.id);
                showNotification(`📄 Scène ouverte : ${foundScene.title}`);
            }, 100);
        }
        
        function openMetroEventFromScene(eventId) {
            // Store the event ID and show the choice modal
            document.getElementById('metroViewChoiceEventId').value = eventId;
            document.getElementById('metroViewChoiceModal').classList.add('active');
            
            // Refresh icons
            setTimeout(() => {
                if (typeof lucide !== 'undefined') {
                    lucide.createIcons();
                }
            }, 50);
        }
        
        function openMetroEventFullView() {
            const eventId = parseInt(document.getElementById('metroViewChoiceEventId').value);
            closeModal('metroViewChoiceModal');
            
            // Switch to timeline viz view properly
            currentView = 'timelineviz';
            
            // Update nav buttons
            document.querySelectorAll('.nav-btn').forEach(btn => btn.classList.remove('active'));
            const timelineBtn = Array.from(document.querySelectorAll('.nav-btn')).find(btn => 
                btn.textContent.includes('Timeline') || btn.onclick?.toString().includes('timelineviz')
            );
            if (timelineBtn) timelineBtn.classList.add('active');
            
            // Hide all sidebar lists
            const sidebarLists = [
                'chaptersList', 'charactersList', 'worldList', 'timelineList', 
                'notesList', 'codexList', 'statsList', 'versionsList', 'analysisList',
                'todosList', 'corkboardList', 'mindmapList', 'plotList', 
                'relationsList', 'mapList', 'timelineVizList'
            ];
            
            sidebarLists.forEach(listId => {
                const el = document.getElementById(listId);
                if (el) el.style.display = 'none';
            });
            
            // Show the timelineVizList sidebar
            const timelineVizList = document.getElementById('timelineVizList');
            if (timelineVizList) timelineVizList.style.display = 'block';
            
            // Render the timeline viz view completely
            renderTimelineVizView();
            
            // Wait for rendering to complete, then open the modal
            setTimeout(() => {
                // Ensure icons are rendered
                if (typeof lucide !== 'undefined') {
                    lucide.createIcons();
                }
                // Open the event modal
                setTimeout(() => {
                    openMetroEventModal(eventId);
                }, 100);
            }, 300);
        }
        
        function openMetroEventSplitView() {
            const eventId = parseInt(document.getElementById('metroViewChoiceEventId').value);
            closeModal('metroViewChoiceModal');
            
            // Enable split view if not already active
            if (!splitViewActive) {
                toggleSplitView();
            }
            
            // Set the right panel to show timeline viz
            splitViewState.right.view = 'timelineviz';
            splitActivePanel = 'right';
            
            // Update the header to show "Timeline" instead of "Vide"
            updateSplitPanelHeader('right');
            
            // Render the right panel with timeline
            renderSplitPanelViewContent('right');
            
            // Wait for rendering, then open the event modal
            setTimeout(() => {
                if (typeof lucide !== 'undefined') {
                    lucide.createIcons();
                }
                setTimeout(() => {
                    openMetroEventModal(eventId);
                }, 100);
            }, 300);
            
            saveSplitViewState();
        }
        
        function openMetroColorPicker(charId) {
            const char = project.characters.find(c => c.id === charId);
            if (!char) return;
            
            document.getElementById('metroColorCharId').value = charId;
            document.getElementById('metroColorCharName').textContent = char.name;
            
            const currentColor = project.characterColors[charId] || '#999';
            document.getElementById('metroCustomColor').value = currentColor;
            
            // Highlight current color
            document.querySelectorAll('.metro-color-option').forEach(opt => {
                opt.classList.toggle('selected', opt.dataset.color === currentColor);
            });
            
            document.getElementById('metroColorModal').classList.add('active');
        }
        
        function selectMetroColor(color) {
            document.getElementById('metroCustomColor').value = color;
            document.querySelectorAll('.metro-color-option').forEach(opt => {
                opt.classList.toggle('selected', opt.dataset.color === color);
            });
        }
        
        function applyMetroColor() {
            const charId = parseInt(document.getElementById('metroColorCharId').value);
            const color = document.getElementById('metroCustomColor').value;
            
            if (!project.characterColors) {
                project.characterColors = {};
            }
            
            project.characterColors[charId] = color;
            saveProject();
            closeModal('metroColorModal');
            refreshTimelineView();
            showNotification('✓ Couleur mise à jour');
        }
        
        // Helper function to refresh timeline view (works in both normal and split view)
        function refreshTimelineView() {
            if (splitViewActive) {
                // In split view, refresh the active panel
                if (splitActivePanel === 'left' && splitViewState.left.view === 'timelineviz') {
                    renderSplitPanelViewContent('left');
                } else if (splitActivePanel === 'right' && splitViewState.right.view === 'timelineviz') {
                    renderSplitPanelViewContent('right');
                } else {
                    // If neither panel is showing timeline, just render normally
                    renderTimelineVizView();
                }
            } else {
                // Normal view
                renderTimelineVizView();
            }
        }
        
        function sortMetroByDate() {
            if (!project.metroTimeline || project.metroTimeline.length === 0) {
                showNotification('Aucun événement à trier');
                return;
            }
            
            // Helper function to parse date in DD/MM/YYYY format
            function parseRealDate(dateStr) {
                if (!dateStr || !dateStr.trim()) return null;
                
                const trimmed = dateStr.trim();
                const parts = trimmed.split('/');
                
                if (parts.length < 2 || parts.length > 3) return null;
                
                const day = parseInt(parts[0], 10);
                const month = parseInt(parts[1], 10);
                let year = parts[2] ? parseInt(parts[2], 10) : null;
                
                if (isNaN(day) || isNaN(month)) return null;
                if (year === null) return null;
                
                // Handle 2-digit years (assume 1900-1999 for < 50, 2000-2099 for >= 50)
                if (year < 100) {
                    year = year < 50 ? 2000 + year : 1900 + year;
                }
                
                // Create date object (month is 0-indexed in JavaScript Date)
                const date = new Date(year, month - 1, day);
                
                // Validate the date
                if (isNaN(date.getTime())) return null;
                
                return date;
            }
            
            // Helper function to extract a numeric value from fictional dates
            // Handles: "An 2157", "Année 5", "Year 42", "2157", "-500" (BCE), etc.
            function extractYearNumber(dateStr) {
                if (!dateStr || !dateStr.trim()) return null;
                
                const trimmed = dateStr.trim();
                
                // Try to match patterns like "An 2157", "Année 5", "Year 42"
                const yearMatch = trimmed.match(/(?:an|année|year|yr)\s*[:\-]?\s*(-?\d+)/i);
                if (yearMatch) {
                    return parseInt(yearMatch[1], 10);
                }
                
                // Try to match pure numbers (with optional negative for BCE)
                const numberMatch = trimmed.match(/^(-?\d+)/);
                if (numberMatch) {
                    return parseInt(numberMatch[1], 10);
                }
                
                return null;
            }
            
            // Sort by date (events without valid dates go to the end)
            project.metroTimeline.sort((a, b) => {
                const dateStrA = (a.date || '').trim();
                const dateStrB = (b.date || '').trim();
                
                // Without date = at the end
                if (!dateStrA && !dateStrB) return 0;
                if (!dateStrA) return 1;
                if (!dateStrB) return -1;
                
                // Try to parse as real dates first (DD/MM/YYYY)
                const realDateA = parseRealDate(dateStrA);
                const realDateB = parseRealDate(dateStrB);
                
                if (realDateA && realDateB) {
                    return realDateA.getTime() - realDateB.getTime();
                }
                
                // If one is real date and other is not, real date comes first
                if (realDateA) return -1;
                if (realDateB) return 1;
                
                // Try to extract year numbers for fictional calendars
                const yearA = extractYearNumber(dateStrA);
                const yearB = extractYearNumber(dateStrB);
                
                if (yearA !== null && yearB !== null) {
                    return yearA - yearB;
                }
                
                // If one has a year number and other doesn't, number comes first
                if (yearA !== null) return -1;
                if (yearB !== null) return 1;
                
                // Fallback to alphabetical sorting
                return dateStrA.localeCompare(dateStrB);
            });
            
            // Reassign orders sequentially
            project.metroTimeline.forEach((event, i) => {
                event.order = i + 1;
            });
            
            saveProject();
            refreshTimelineView();
            showNotification('✓ Timeline triée par date');
        }
        
        function clearMetroTimeline() {
            if (!project.metroTimeline || project.metroTimeline.length === 0) {
                showNotification('La timeline est déjà vide');
                return;
            }
            
            if (confirm(`Effacer les ${project.metroTimeline.length} événement(s) de la timeline ?`)) {
                project.metroTimeline = [];
                saveProject();
                refreshTimelineView();
                showNotification('✓ Timeline effacée');
            }
        }
        
        function exportMetroTimelineCSV() {
            if (!project.metroTimeline || project.metroTimeline.length === 0) {
                alert('Aucun événement à exporter');
                return;
            }
            
            let csv = 'Ordre,Titre,Date,Description,Personnages\n';
            
            project.metroTimeline.sort((a, b) => (a.order || 0) - (b.order || 0)).forEach(event => {
                const charNames = (event.characters || []).map(cId => {
                    const char = project.characters.find(c => c.id === cId);
                    return char ? char.name : '';
                }).filter(n => n).join('; ');
                
                csv += `${event.order || ''},${escapeCSVField(event.title)},${escapeCSVField(event.date || '')},${escapeCSVField(event.description || '')},${escapeCSVField(charNames)}\n`;
            });
            
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${project.title}_metro_timeline.csv`;
            a.click();
            URL.revokeObjectURL(url);
            
            showNotification(`✓ ${project.metroTimeline.length} événement(s) exporté(s)`);
        }
        
        // Legacy functions for old timeline (keeping for backward compatibility)
        function addTimelineVizEvent() {
            openMetroEventModal();
        }
        
        function editTimelineVizEvent(id) {
            // Try to find in new metro timeline first
            if (project.metroTimeline && project.metroTimeline.find(e => e.id === id)) {
                openMetroEventModal(id);
                return;
            }
            // Fallback to old visual timeline
            const event = project.visualTimeline?.find(e => e.id === id);
            if (!event) return;
            
            const newTitle = prompt('Modifier le titre:', event.title);
            if (newTitle === null) return;
            
            if (newTitle.trim() !== '') {
                event.title = newTitle.trim();
                
                const newDate = prompt('Modifier la date:', event.date);
                if (newDate !== null) {
                    event.date = newDate.trim();
                }
                
                const newDesc = prompt('Modifier la description:', event.description);
                if (newDesc !== null) {
                    event.description = newDesc.trim();
                }
                
                saveProject();
                refreshTimelineView();
                showNotification('✓ Événement mis à jour');
            }
        }
        
        function sortTimelineByDate() {
            sortMetroTimeline();
        }
        
        function clearTimeline() {
            clearMetroTimeline();
        }
        
        function exportTimelineViz() {
            exportMetroTimelineCSV();
        }
        
        // ============================================
        // IMPORT/EXPORT CSV POUR TIMELINE (Legacy)
        // ============================================
        
        function importTimelineCSV() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.csv';
            
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        parseMetroTimelineCSV(event.target.result);
                    } catch (error) {
                        alert('Erreur lors de la lecture du fichier CSV:\n' + error.message);
                    }
                };
                reader.readAsText(file);
            };
            
            input.click();
        }
        
        function parseMetroTimelineCSV(csvContent) {
            const lines = csvContent.split('\n').filter(line => line.trim() !== '');
            
            if (lines.length === 0) {
                alert('Le fichier CSV est vide');
                return;
            }
            
            // Skip header if present
            const header = lines[0].toLowerCase();
            if (header.includes('titre') || header.includes('title') || header.includes('ordre') || header.includes('order')) {
                lines.shift();
            }
            
            if (lines.length === 0) {
                alert('Le fichier CSV ne contient aucun événement');
                return;
            }
            
            if (!confirm(`Importer ${lines.length} événement(s) ? Les événements existants seront conservés.`)) {
                return;
            }
            
            if (!project.metroTimeline) {
                project.metroTimeline = [];
            }
            
            let imported = 0;
            const maxOrder = Math.max(0, ...project.metroTimeline.map(e => e.order || 0));
            
            lines.forEach((line, idx) => {
                const parts = parseCSVLine(line);
                const title = parts[1]?.trim() || parts[0]?.trim() || '';
                
                if (title) {
                    project.metroTimeline.push({
                        id: Date.now() + idx,
                        order: maxOrder + idx + 1,
                        title: title,
                        date: parts[2]?.trim() || '',
                        description: parts[3]?.trim() || '',
                        characters: []
                    });
                    imported++;
                }
            });
            
            saveProject();
            refreshTimelineView();
            showNotification(`✓ ${imported} événement(s) importé(s)`);
        }
        
        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                
                if (char === '"') {
                    if (inQuotes && line[i + 1] === '"') {
                        current += '"';
                        i++;
                    } else {
                        inQuotes = !inQuotes;
                    }
                } else if (char === ',' && !inQuotes) {
                    result.push(current);
                    current = '';
                } else {
                    current += char;
                }
            }
            
            result.push(current);
            return result;
        }
        
        function exportTimelineCSV() {
            exportMetroTimelineCSV();
        }
        
        function escapeCSVField(field) {
            if (!field) return '""';
            
            if (field.includes(',') || field.includes('"') || field.includes('\n')) {
                field = field.replace(/"/g, '""');
                return `"${field}"`;
            }
            
            return field;
        }
       

// ========== 37.theme-manager.js ==========
// ============================================
// Module: ui/theme-manager
// Généré automatiquement - Plume Writer
// ============================================

		// ===================================
        // SYSTÈME DE GESTION DES THÈMES
        // ===================================
        
        // Utilitaire : convertir rgba/rgb/hex en hex
        function rgbaToHex(color) {
            if (!color) return '#000000';
            
            // Si c'est déjà un hex
            if (color.startsWith('#')) {
                return color.length === 7 ? color : color + 'FF';
            }
            
            // Si c'est rgba ou rgb
            const match = color.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
            if (match) {
                const r = parseInt(match[1]);
                const g = parseInt(match[2]);
                const b = parseInt(match[3]);
                return '#' + [r, g, b].map(x => {
                    const hex = x.toString(16);
                    return hex.length === 1 ? '0' + hex : hex;
                }).join('');
            }
            
            return '#000000';
        }        
        
        const themeManager = {
            currentTheme: null,
            customThemes: [],
            
defaultVariables: {
                '--bg-primary': '#faf9f6',
                '--bg-secondary': '#f5f3ed',
                '--bg-accent': '#2a2622',
                '--text-primary': '#2a2622',
                '--text-secondary': '#5a5550',
                '--text-muted': '#5a5550', // CORRECTION : Amélioration du contraste (était #8a847d)
                '--border-color': '#d4cfc5',
                '--primary-color': '#d4af37',
                '--primary-hover': '#b8941f',
                '--accent-red': '#c44536',
                '--accent-gold': '#d4af37',
                '--highlight-yellow': 'rgba(255, 235, 59, 0.4)',
                '--highlight-green': 'rgba(76, 175, 80, 0.3)',
                '--highlight-blue': 'rgba(33, 150, 243, 0.3)',
                '--highlight-red': 'rgba(244, 67, 54, 0.3)',
                '--highlight-purple': 'rgba(156, 39, 176, 0.3)'
            },
            
            presetThemes: {
                'Classique': {
                    '--bg-primary': '#faf9f6',
                    '--bg-secondary': '#f5f3ed',
                    '--bg-accent': '#2a2622',
                    '--text-primary': '#2a2622',
                    '--text-secondary': '#5a5550',
                    '--text-muted': '#5a5550', // CORRECTION
                    '--border-color': '#d4cfc5',
                    '--primary-color': '#d4af37',
                    '--primary-hover': '#b8941f',
                    '--accent-red': '#c44536',
                    '--accent-gold': '#d4af37',
                    '--highlight-yellow': 'rgba(255, 235, 59, 0.4)',
                    '--highlight-green': 'rgba(76, 175, 80, 0.3)',
                    '--highlight-blue': 'rgba(33, 150, 243, 0.3)',
                    '--highlight-red': 'rgba(244, 67, 54, 0.3)',
                    '--highlight-purple': 'rgba(156, 39, 176, 0.3)'
                },
                'Sombre': {
                    '--bg-primary': '#1a1a1a',
                    '--bg-secondary': '#252525',
                    '--bg-accent': '#f5f3ed',
                    '--text-primary': '#e8e6e3',
                    '--text-secondary': '#b8b6b3',
                    '--text-muted': '#888683',
                    '--border-color': '#3a3a3a',
                    '--primary-color': '#ffd700',
                    '--primary-hover': '#ffed4e',
                    '--accent-red': '#ff6b5a',
                    '--accent-gold': '#ffd700',
                    '--highlight-yellow': 'rgba(255, 235, 59, 0.3)',
                    '--highlight-green': 'rgba(76, 175, 80, 0.25)',
                    '--highlight-blue': 'rgba(33, 150, 243, 0.25)',
                    '--highlight-red': 'rgba(244, 67, 54, 0.25)',
                    '--highlight-purple': 'rgba(156, 39, 176, 0.25)'
                },
                'Océan': {
                    '--bg-primary': '#e8f4f8',
                    '--bg-secondary': '#d0e8f0',
                    '--bg-accent': '#1e3a52',
                    '--text-primary': '#1e3a52',
                    '--text-secondary': '#2a5270',
                    '--text-muted': '#2a5270', // CORRECTION (était #5a7a90)
                    '--border-color': '#a8c8d8',
                    '--primary-color': '#3498db',
                    '--primary-hover': '#2980b9',
                    '--accent-red': '#c84a4a',
                    '--accent-gold': '#3498db',
                    '--highlight-yellow': 'rgba(255, 235, 59, 0.3)',
                    '--highlight-green': 'rgba(46, 204, 113, 0.3)',
                    '--highlight-blue': 'rgba(52, 152, 219, 0.4)',
                    '--highlight-red': 'rgba(231, 76, 60, 0.3)',
                    '--highlight-purple': 'rgba(155, 89, 182, 0.3)'
                },
                'Forêt': {
                    '--bg-primary': '#f0f4ed',
                    '--bg-secondary': '#e1e8dc',
                    '--bg-accent': '#2d3e2d',
                    '--text-primary': '#2d3e2d',
                    '--text-secondary': '#4a5e4a',
                    '--text-muted': '#4a5e4a', // CORRECTION (était #7a8a7a)
                    '--border-color': '#c1d0bb',
                    '--primary-color': '#6b8e23',
                    '--primary-hover': '#557a1c',
                    '--accent-red': '#c44536',
                    '--accent-gold': '#6b8e23',
                    '--highlight-yellow': 'rgba(255, 235, 59, 0.3)',
                    '--highlight-green': 'rgba(107, 142, 35, 0.4)',
                    '--highlight-blue': 'rgba(70, 130, 180, 0.3)',
                    '--highlight-red': 'rgba(178, 34, 34, 0.3)',
                    '--highlight-purple': 'rgba(147, 112, 219, 0.3)'
                },
                'Crépuscule': {
                    '--bg-primary': '#2b2d42',
                    '--bg-secondary': '#3a3d54',
                    '--bg-accent': '#edf2f4',
                    '--text-primary': '#edf2f4',
                    '--text-secondary': '#c5cad4',
                    '--text-muted': '#8d99ae',
                    '--border-color': '#4a4d64',
                    '--primary-color': '#ffd166',
                    '--primary-hover': '#ffbe3d',
                    '--accent-red': '#ef476f',
                    '--accent-gold': '#ffd166',
                    '--highlight-yellow': 'rgba(255, 209, 102, 0.3)',
                    '--highlight-green': 'rgba(6, 214, 160, 0.3)',
                    '--highlight-blue': 'rgba(118, 171, 174, 0.3)',
                    '--highlight-red': 'rgba(239, 71, 111, 0.3)',
                    '--highlight-purple': 'rgba(177, 98, 134, 0.3)'
                },
                'Sépia': {
                    '--bg-primary': '#f4ecd8',
                    '--bg-secondary': '#e8dcc4',
                    '--bg-accent': '#3e2723',
                    '--text-primary': '#3e2723',
                    '--text-secondary': '#5d4037',
                    '--text-muted': '#5d4037', // CORRECTION (était #8d6e63)
                    '--border-color': '#d7cdb8',
                    '--primary-color': '#a1887f',
                    '--primary-hover': '#8d6e63',
                    '--accent-red': '#bf360c',
                    '--accent-gold': '#a1887f',
                    '--highlight-yellow': 'rgba(255, 224, 130, 0.4)',
                    '--highlight-green': 'rgba(139, 195, 74, 0.3)',
                    '--highlight-blue': 'rgba(121, 134, 203, 0.3)',
                    '--highlight-red': 'rgba(191, 54, 12, 0.3)',
                    '--highlight-purple': 'rgba(142, 110, 99, 0.3)'
                },
                'Minuit': {
                    '--bg-primary': '#0d1b2a',
                    '--bg-secondary': '#1b263b',
                    '--bg-accent': '#e0e1dd',
                    '--text-primary': '#e0e1dd',
                    '--text-secondary': '#c0c2be',
                    '--text-muted': '#778da9',
                    '--border-color': '#2b3a4f',
                    '--primary-color': '#457b9d',
                    '--primary-hover': '#5a92b5',
                    '--accent-red': '#e63946',
                    '--accent-gold': '#f1faee',
                    '--highlight-yellow': 'rgba(241, 250, 238, 0.2)',
                    '--highlight-green': 'rgba(168, 218, 220, 0.2)',
                    '--highlight-blue': 'rgba(69, 123, 157, 0.3)',
                    '--highlight-red': 'rgba(230, 57, 70, 0.3)',
                    '--highlight-purple': 'rgba(163, 177, 138, 0.2)'
                },
                'Pastel': {
                    '--bg-primary': '#fff5f7',
                    '--bg-secondary': '#ffe8ec',
                    '--bg-accent': '#4a4a4a',
                    '--text-primary': '#2a2a2a',
                    '--text-secondary': '#5a5a5a',
                    '--text-muted': '#5a5a5a', // CORRECTION (était #8a8a8a)
                    '--border-color': '#ffd4dc',
                    '--primary-color': '#ff6b9d',
                    '--primary-hover': '#ff5285',
                    '--accent-red': '#ff6b9d',
                    '--accent-gold': '#c9ada7',
                    '--highlight-yellow': 'rgba(255, 223, 186, 0.5)',
                    '--highlight-green': 'rgba(186, 220, 180, 0.5)',
                    '--highlight-blue': 'rgba(173, 216, 230, 0.5)',
                    '--highlight-red': 'rgba(255, 182, 193, 0.5)',
                    '--highlight-purple': 'rgba(221, 160, 221, 0.5)'
                },
                // ===================================
                // NOUVEAUX THÈMES AJOUTÉS
                // ===================================
                'Cyberpunk': {
                    '--bg-primary': '#0b0c15',
                    '--bg-secondary': '#161829',
                    '--bg-accent': '#2a2d45',
                    '--text-primary': '#00f3ff',
                    '--text-secondary': '#b300ff',
                    '--text-muted': '#565c8d',
                    '--border-color': '#2a2d45',
                    '--primary-color': '#00f3ff',
                    '--primary-hover': '#00bbcc',
                    '--accent-red': '#ff0055',
                    '--accent-gold': '#ffee00',
                    '--highlight-yellow': 'rgba(255, 238, 0, 0.25)',
                    '--highlight-green': 'rgba(0, 243, 255, 0.2)',
                    '--highlight-blue': 'rgba(0, 85, 255, 0.3)',
                    '--highlight-red': 'rgba(255, 0, 85, 0.3)',
                    '--highlight-purple': 'rgba(179, 0, 255, 0.3)'
                },
                'Café': {
                    '--bg-primary': '#f5ebe0',
                    '--bg-secondary': '#e3d5ca',
                    '--bg-accent': '#d5bdaf',
                    '--text-primary': '#4a3b32',
                    '--text-secondary': '#8d7966',
                    '--text-muted': '#8d7966', // Applique aussi la correction ici
                    '--border-color': '#d6ccc2',
                    '--primary-color': '#d5bdaf',
                    '--primary-hover': '#c7a998',
                    '--accent-red': '#bc6c25',
                    '--accent-gold': '#dda15e',
                    '--highlight-yellow': 'rgba(221, 161, 94, 0.3)',
                    '--highlight-green': 'rgba(96, 108, 56, 0.3)',
                    '--highlight-blue': 'rgba(100, 149, 237, 0.3)',
                    '--highlight-red': 'rgba(188, 108, 37, 0.3)',
                    '--highlight-purple': 'rgba(156, 102, 68, 0.3)'
                },
                'Nordique': {
                    '--bg-primary': '#2e3440',
                    '--bg-secondary': '#3b4252',
                    '--bg-accent': '#434c5e',
                    '--text-primary': '#eceff4',
                    '--text-secondary': '#d8dee9',
                    '--text-muted': '#6c7a96',
                    '--border-color': '#4c566a',
                    '--primary-color': '#88c0d0',
                    '--primary-hover': '#81a1c1',
                    '--accent-red': '#bf616a',
                    '--accent-gold': '#ebcb8b',
                    '--highlight-yellow': 'rgba(235, 203, 139, 0.25)',
                    '--highlight-green': 'rgba(163, 190, 140, 0.25)',
                    '--highlight-blue': 'rgba(136, 192, 208, 0.25)',
                    '--highlight-red': 'rgba(191, 97, 106, 0.25)',
                    '--highlight-purple': 'rgba(180, 142, 173, 0.25)'
                },
                'Terminal': {
                    '--bg-primary': '#000000',
                    '--bg-secondary': '#0c0c0c',
                    '--bg-accent': '#1a1a1a',
                    '--text-primary': '#33ff00',
                    '--text-secondary': '#24b300',
                    '--text-muted': '#156600',
                    '--border-color': '#333333',
                    '--primary-color': '#33ff00',
                    '--primary-hover': '#2bd900',
                    '--accent-red': '#ff3333',
                    '--accent-gold': '#ffff33',
                    '--highlight-yellow': 'rgba(255, 255, 51, 0.2)',
                    '--highlight-green': 'rgba(51, 255, 0, 0.2)',
                    '--highlight-blue': 'rgba(0, 204, 255, 0.2)',
                    '--highlight-red': 'rgba(255, 51, 51, 0.2)',
                    '--highlight-purple': 'rgba(204, 51, 255, 0.2)'
                },
                'Sakura': {
                    '--bg-primary': '#fff0f5',
                    '--bg-secondary': '#ffe6ea',
                    '--bg-accent': '#ffc0cb',
                    '--text-primary': '#594a4e',
                    '--text-secondary': '#8c7b7f',
                    '--text-muted': '#8c7b7f', // Applique aussi la correction ici (était #bdacb0)
                    '--border-color': '#fadadd',
                    '--primary-color': '#ff69b4',
                    '--primary-hover': '#ff1493',
                    '--accent-red': '#db7093',
                    '--accent-gold': '#ffb6c1',
                    '--highlight-yellow': 'rgba(255, 250, 205, 0.5)',
                    '--highlight-green': 'rgba(152, 251, 152, 0.4)',
                    '--highlight-blue': 'rgba(176, 224, 230, 0.5)',
                    '--highlight-red': 'rgba(255, 182, 193, 0.5)',
                    '--highlight-purple': 'rgba(221, 160, 221, 0.4)'
                },
                'Luxe': {
                    '--bg-primary': '#050505',
                    '--bg-secondary': '#111111',
                    '--bg-accent': '#1a1a1a',
                    '--text-primary': '#e0e0e0',
                    '--text-secondary': '#a0a0a0',
                    '--text-muted': '#505050',
                    '--border-color': '#333333',
                    '--primary-color': '#cfb53b',
                    '--primary-hover': '#e6c94c',
                    '--accent-red': '#800020',
                    '--accent-gold': '#cfb53b',
                    '--highlight-yellow': 'rgba(207, 181, 59, 0.25)',
                    '--highlight-green': 'rgba(85, 107, 47, 0.3)',
                    '--highlight-blue': 'rgba(70, 130, 180, 0.3)',
                    '--highlight-red': 'rgba(139, 0, 0, 0.3)',
                    '--highlight-purple': 'rgba(75, 0, 130, 0.3)'
                }
            },
            
            init() {
                this.loadCustomThemes();
                this.loadCurrentTheme();
            },
            
            applyTheme(colors) {
                const root = document.documentElement;
                Object.entries(colors).forEach(([variable, value]) => {
                    root.style.setProperty(variable, value);
                });
                this.currentTheme = colors;
                this.saveCurrentTheme();
            },
            
            saveCurrentTheme() {
                localStorage.setItem('plume_locale-current-theme', JSON.stringify(this.currentTheme));
            },
            
            loadCurrentTheme() {
                const saved = localStorage.getItem('plume_locale-current-theme');
                if (saved) {
                    try {
                        this.currentTheme = JSON.parse(saved);
                        this.applyTheme(this.currentTheme);
                    } catch (e) {
                        console.error('Erreur chargement thème', e);
                    }
                }
            },
            
            saveCustomThemes() {
                localStorage.setItem('plume_locale-custom-themes', JSON.stringify(this.customThemes));
            },
            
            loadCustomThemes() {
                const saved = localStorage.getItem('plume_locale-custom-themes');
                if (saved) {
                    try {
                        this.customThemes = JSON.parse(saved);
                    } catch (e) {
                        console.error('Erreur chargement thèmes personnalisés', e);
                    }
                }
            },
            
            addCustomTheme(name, colors) {
                this.customThemes.push({ name, colors });
                this.saveCustomThemes();
            },
            
            deleteCustomTheme(name) {
                this.customThemes = this.customThemes.filter(t => t.name !== name);
                this.saveCustomThemes();
            },
            
            exportTheme(colors, name) {
                const theme = {
                    name: name,
                    colors: colors,
                    version: '1.0'
                };
                
                const json = JSON.stringify(theme, null, 2);
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `theme-${name.toLowerCase().replace(/\s+/g, '-')}.json`;
                a.click();
                URL.revokeObjectURL(url);
            },
            
            importTheme(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const theme = JSON.parse(e.target.result);
                            if (theme.colors && theme.name) {
                                resolve(theme);
                            } else {
                                reject(new Error('Format de thème invalide'));
                            }
                        } catch (error) {
                            reject(error);
                        }
                    };
                    reader.onerror = () => reject(new Error('Erreur de lecture du fichier'));
                    reader.readAsText(file);
                });
            }
        };
        
        function openThemeManager() {
            const modal = document.createElement('div');
            modal.className = 'modal-overlay';
            modal.style.zIndex = '10000';
            
            const currentColors = {};
            Object.keys(themeManager.defaultVariables).forEach(variable => {
                const value = getComputedStyle(document.documentElement).getPropertyValue(variable);
                currentColors[variable] = value.trim();
            });
            
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 1000px; max-height: 90vh; overflow: hidden; display: flex; flex-direction: column;">
                    <div class="modal-header">
                        <h2>🎨 Gestionnaire de Thèmes</h2>
                        <button class="modal-close" onclick="this.closest('.modal-overlay').remove()">✕</button>
                    </div>
                    
                    <div style="flex: 1; overflow-y: auto; padding: 1.5rem;">
                        <!-- Thèmes prédéfinis -->
                        <div style="margin-bottom: 2rem;">
                            <h3 style="margin-bottom: 1rem; font-size: 1.2rem; color: var(--accent-gold);">
                                📚 Thèmes Prédéfinis
                            </h3>
                            <div id="presetThemesList" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 1rem;">
                            </div>
                        </div>
                        
                        <!-- Thèmes personnalisés -->
                        <div style="margin-bottom: 2rem;">
                            <h3 style="margin-bottom: 1rem; font-size: 1.2rem; color: var(--accent-gold);">
                                ✨ Mes Thèmes Personnalisés
                            </h3>
                            <div id="customThemesList" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 1rem;">
                            </div>
                        </div>
                        
                        <!-- Éditeur de couleurs -->
                        <div style="border-top: 2px solid var(--border-color); padding-top: 1.5rem;">
                            <h3 style="margin-bottom: 1rem; font-size: 1.2rem; color: var(--accent-gold);">
                                🎨 Éditeur de Thème
                            </h3>
                            
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 1rem; margin-bottom: 1.5rem;">
                                ${Object.entries(themeManager.defaultVariables).map(([variable, defaultValue]) => {
                                    const label = variable.replace('--', '').split('-').map(w => 
                                        w.charAt(0).toUpperCase() + w.slice(1)
                                    ).join(' ');
                                    
                                    const currentValue = currentColors[variable] || defaultValue;
                                    const hexColor = rgbaToHex(currentValue);
                                    
                                    return `
                                        <div class="color-input-group">
                                            <label style="display: block; margin-bottom: 0.5rem; font-weight: 500; font-size: 0.9rem;">
                                                ${label}
                                            </label>
                                            <div style="display: flex; gap: 0.5rem; align-items: center;">
                                                <input 
                                                    type="color" 
                                                    data-variable="${variable}"
                                                    value="${hexColor}"
                                                    style="width: 50px; height: 40px; border: 2px solid var(--border-color); border-radius: 4px; cursor: pointer;"
                                                >
                                                <input 
                                                    type="text" 
                                                    data-variable-text="${variable}"
                                                    value="${currentValue}"
                                                    placeholder="${currentValue}"
                                                    style="flex: 1; padding: 0.5rem; border: 1px solid var(--border-color); border-radius: 4px; font-family: 'Source Code Pro', monospace; font-size: 0.85rem;"
                                                >
                                            </div>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                            
                            <!-- Actions de l'éditeur -->
                            <div style="display: flex; gap: 0.75rem; flex-wrap: wrap; padding-top: 1rem; border-top: 1px solid var(--border-color);">
                                <button onclick="applyCurrentEditorColors()" class="btn-primary">
                                    ✓ Appliquer les Couleurs
                                </button>
                                <button onclick="saveThemeAsCustom()" class="btn-primary" style="background: var(--accent-gold);">
                                    💾 Sauvegarder comme Thème
                                </button>
                                <button onclick="exportCurrentTheme()" class="btn-secondary">
                                    📤 Exporter en JSON
                                </button>
                                <button onclick="importThemeFile()" class="btn-secondary">
                                    📥 Importer depuis JSON
                                </button>
                                <button onclick="resetToDefault()" class="btn-secondary" style="margin-left: auto;">
                                    🔄 Réinitialiser
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Remplir les thèmes prédéfinis
            renderPresetThemes();
            renderCustomThemes();
            
            // Lier les changements de couleur en temps réel
            modal.querySelectorAll('input[type="color"]').forEach(input => {
                input.addEventListener('input', (e) => {
                    const variable = e.target.dataset.variable;
                    const color = e.target.value;
                    const textInput = modal.querySelector(`input[data-variable-text="${variable}"]`);
                    textInput.value = color;
                    document.documentElement.style.setProperty(variable, color);
                });
            });
            
            modal.querySelectorAll('input[data-variable-text]').forEach(input => {
                input.addEventListener('change', (e) => {
                    const variable = e.target.dataset.variableText;
                    const color = e.target.value;
                    document.documentElement.style.setProperty(variable, color);
                    
                    // Mettre à jour le color picker si possible
                    const hexColor = rgbaToHex(color);
                    const colorInput = modal.querySelector(`input[data-variable="${variable}"]`);
                    if (colorInput && hexColor.match(/^#[0-9A-F]{6}$/i)) {
                        colorInput.value = hexColor;
                    }
                });
            });
        }
        
        function renderPresetThemes() {
            const container = document.getElementById('presetThemesList');
            container.innerHTML = Object.entries(themeManager.presetThemes).map(([name, colors]) => `
                <div class="theme-card" style="border: 2px solid var(--border-color); border-radius: 8px; padding: 1rem; cursor: pointer; transition: all 0.2s;"
                     onmouseover="this.style.borderColor='var(--accent-gold)'"
                     onmouseout="this.style.borderColor='var(--border-color)'"
                     onclick="applyPresetTheme('${name}')">
                    <div style="font-weight: 600; margin-bottom: 0.75rem; font-size: 1rem;">
                        ${name}
                    </div>
                    <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 0.25rem;">
                        ${Object.values(colors).slice(0, 10).map(color => `
                            <div style="width: 100%; padding-bottom: 100%; background: ${color}; border-radius: 2px; border: 1px solid rgba(0,0,0,0.1);"></div>
                        `).join('')}
                    </div>
                </div>
            `).join('');
        }
        
        function renderCustomThemes() {
            const container = document.getElementById('customThemesList');
            if (themeManager.customThemes.length === 0) {
                container.innerHTML = '<p style="color: var(--text-muted); font-style: italic;">Aucun thème personnalisé</p>';
                return;
            }
            
            container.innerHTML = themeManager.customThemes.map(theme => `
                <div class="theme-card" style="border: 2px solid var(--border-color); border-radius: 8px; padding: 1rem; position: relative;">
                    <button onclick="deleteCustomTheme('${theme.name}')" 
                            style="position: absolute; top: 0.5rem; right: 0.5rem; background: var(--accent-red); color: white; border: none; border-radius: 4px; width: 24px; height: 24px; cursor: pointer; font-size: 0.9rem;"
                            title="Supprimer">✕</button>
                    <div style="font-weight: 600; margin-bottom: 0.75rem; font-size: 1rem; padding-right: 2rem;">
                        ${theme.name}
                    </div>
                    <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 0.25rem; margin-bottom: 0.75rem;">
                        ${Object.values(theme.colors).slice(0, 10).map(color => `
                            <div style="width: 100%; padding-bottom: 100%; background: ${color}; border-radius: 2px; border: 1px solid rgba(0,0,0,0.1);"></div>
                        `).join('')}
                    </div>
                    <button onclick="applyCustomTheme('${theme.name}')" class="btn-secondary" style="width: 100%; padding: 0.5rem; font-size: 0.85rem;">
                        Appliquer
                    </button>
                </div>
            `).join('');
        }
        
        function applyPresetTheme(name) {
            const colors = themeManager.presetThemes[name];
            themeManager.applyTheme(colors);
            showNotification(`✓ Thème "${name}" appliqué`);
            
            // Mettre à jour l'éditeur
            Object.entries(colors).forEach(([variable, value]) => {
                const colorInput = document.querySelector(`input[data-variable="${variable}"]`);
                const textInput = document.querySelector(`input[data-variable-text="${variable}"]`);
                if (colorInput && textInput) {
                    textInput.value = value;
                    const hexColor = rgbaToHex(value);
                    if (hexColor.match(/^#[0-9A-F]{6}$/i)) {
                        colorInput.value = hexColor;
                    }
                }
            });
        }
        
        function applyCustomTheme(name) {
            const theme = themeManager.customThemes.find(t => t.name === name);
            if (theme) {
                themeManager.applyTheme(theme.colors);
                showNotification(`✓ Thème "${name}" appliqué`);
                
                // Mettre à jour l'éditeur
                Object.entries(theme.colors).forEach(([variable, value]) => {
                    const colorInput = document.querySelector(`input[data-variable="${variable}"]`);
                    const textInput = document.querySelector(`input[data-variable-text="${variable}"]`);
                    if (colorInput && textInput) {
                        textInput.value = value;
                        const hexColor = rgbaToHex(value);
                        if (hexColor.match(/^#[0-9A-F]{6}$/i)) {
                            colorInput.value = hexColor;
                        }
                    }
                });
            }
        }
        
        function deleteCustomTheme(name) {
            if (confirm(`Supprimer le thème "${name}" ?`)) {
                themeManager.deleteCustomTheme(name);
                renderCustomThemes();
                showNotification(`✓ Thème "${name}" supprimé`);
            }
        }
        
        function applyCurrentEditorColors() {
            const colors = {};
            document.querySelectorAll('input[data-variable-text]').forEach(input => {
                const variable = input.dataset.variableText;
                colors[variable] = input.value;
            });
            themeManager.applyTheme(colors);
            showNotification('✓ Couleurs appliquées');
        }
        
        function saveThemeAsCustom() {
            const name = prompt('Nom du thème :');
            if (!name) return;
            
            // Vérifier si le nom existe déjà
            if (themeManager.customThemes.find(t => t.name === name)) {
                if (!confirm(`Un thème nommé "${name}" existe déjà. Remplacer ?`)) {
                    return;
                }
                themeManager.deleteCustomTheme(name);
            }
            
            const colors = {};
            document.querySelectorAll('input[data-variable-text]').forEach(input => {
                const variable = input.dataset.variableText;
                colors[variable] = input.value;
            });
            
            themeManager.addCustomTheme(name, colors);
            renderCustomThemes();
            showNotification(`✓ Thème "${name}" sauvegardé`);
        }
        
        function exportCurrentTheme() {
            const name = prompt('Nom du thème pour l\'export :', 'Mon Thème');
            if (!name) return;
            
            const colors = {};
            document.querySelectorAll('input[data-variable-text]').forEach(input => {
                const variable = input.dataset.variableText;
                colors[variable] = input.value;
            });
            
            themeManager.exportTheme(colors, name);
            showNotification(`✓ Thème "${name}" exporté`);
        }
        
        function importThemeFile() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = async (e) => {
                try {
                    const file = e.target.files[0];
                    const theme = await themeManager.importTheme(file);
                    
                    // Demander si on veut l'appliquer ou le sauvegarder
                    const choice = confirm(`Thème "${theme.name}" importé.\n\nOK = Appliquer maintenant\nAnnuler = Sauvegarder dans mes thèmes`);
                    
                    if (choice) {
                        themeManager.applyTheme(theme.colors);
                        showNotification(`✓ Thème "${theme.name}" appliqué`);
                    } else {
                        // Vérifier si le nom existe
                        if (themeManager.customThemes.find(t => t.name === theme.name)) {
                            if (!confirm(`Un thème nommé "${theme.name}" existe déjà. Remplacer ?`)) {
                                return;
                            }
                            themeManager.deleteCustomTheme(theme.name);
                        }
                        themeManager.addCustomTheme(theme.name, theme.colors);
                        renderCustomThemes();
                        showNotification(`✓ Thème "${theme.name}" sauvegardé`);
                    }
                    
                    // Mettre à jour l'éditeur
                    Object.entries(theme.colors).forEach(([variable, value]) => {
                        const colorInput = document.querySelector(`input[data-variable="${variable}"]`);
                        const textInput = document.querySelector(`input[data-variable-text="${variable}"]`);
                        if (colorInput && textInput) {
                            textInput.value = value;
                            const hexColor = rgbaToHex(value);
                            if (hexColor.match(/^#[0-9A-F]{6}$/i)) {
                                colorInput.value = hexColor;
                            }
                        }
                    });
                    
                } catch (error) {
                    alert(`Erreur lors de l'import : ${error.message}`);
                }
            };
            input.click();
        }
        
        function resetToDefault() {
            if (confirm('Revenir au thème par défaut ?')) {
                themeManager.applyTheme(themeManager.defaultVariables);
                showNotification('✓ Thème par défaut restauré');
                
                // Mettre à jour l'éditeur
                Object.entries(themeManager.defaultVariables).forEach(([variable, value]) => {
                    const colorInput = document.querySelector(`input[data-variable="${variable}"]`);
                    const textInput = document.querySelector(`input[data-variable-text="${variable}"]`);
                    if (colorInput && textInput) {
                        textInput.value = value;
                        const hexColor = rgbaToHex(value);
                        if (hexColor.match(/^#[0-9A-F]{6}$/i)) {
                            colorInput.value = hexColor;
                        }
                    }
                });
            }
        }



// ========== 38.tension.js ==========
// ============================================
// Module: features/analysis
// Généré automatiquement - Plume Writer
// ============================================
        // Initialize
        // === TENSION WORDS MANAGEMENT ===
        
        // Valeurs par défaut des mots de tension
        const DEFAULT_TENSION_WORDS = {
            high: [
                'combat', 'bataille', 'mort', 'tuer', 'danger', 'peur', 'terreur', 'cri', 'hurler',
                'sang', 'blessure', 'fuir', 'course', 'poursuite', 'menace', 'attaque', 'explosion',
                'feu', 'incendie', 'catastrophe', 'urgence', 'panique', 'désespoir', 'tragédie',
                'révélation', 'secret', 'trahison', 'conflit', 'confrontation', 'affrontement',
                'climax', 'crucial', 'décisif', 'critique', 'vital', 'dramatique'
            ],
            medium: [
                'mystère', 'suspense', 'intrigue', 'complot', 'enquête', 'découverte', 'surprise',
                'tension', 'stress', 'angoisse', 'inquiétude', 'doute', 'hésitation', 'dilemme',
                'choix', 'décision', 'tournant', 'changement', 'transformation'
            ],
            low: [
                'calme', 'paix', 'repos', 'détente', 'tranquille', 'paisible', 'serein',
                'conversation', 'discussion', 'réflexion', 'souvenir', 'rêve', 'pensée'
            ]
        };

        // Récupérer les mots de tension (personnalisés ou par défaut)
        function getTensionWords() {
            const stored = localStorage.getItem('tensionWords');
            if (stored) {
                try {
                    return JSON.parse(stored);
                } catch (e) {
                    console.error('Erreur lors du chargement des mots de tension:', e);
                    return DEFAULT_TENSION_WORDS;
                }
            }
            return DEFAULT_TENSION_WORDS;
        }

        // Sauvegarder les mots de tension
        function saveTensionWordsToStorage(words) {
            localStorage.setItem('tensionWords', JSON.stringify(words));
        }

        // Ouvrir l'éditeur de mots de tension
        function openTensionWordsEditor() {
            document.getElementById('tensionWordsModal').classList.add('active');
            loadTensionWordsInEditor();
        }

        // Charger les mots dans l'éditeur
        function loadTensionWordsInEditor() {
            const words = getTensionWords();
            
            // Charger les mots de haute tension
            const highList = document.getElementById('highTensionList');
            highList.innerHTML = '';
            words.high.forEach((word, index) => {
                highList.innerHTML += createWordElement(word, 'high', index);
            });
            
            // Charger les mots de tension moyenne
            const mediumList = document.getElementById('mediumTensionList');
            mediumList.innerHTML = '';
            words.medium.forEach((word, index) => {
                mediumList.innerHTML += createWordElement(word, 'medium', index);
            });
            
            // Charger les mots de faible tension
            const lowList = document.getElementById('lowTensionList');
            lowList.innerHTML = '';
            words.low.forEach((word, index) => {
                lowList.innerHTML += createWordElement(word, 'low', index);
            });
        }

        // Créer un élément de mot avec bouton de suppression
        function createWordElement(word, type, index) {
            const colors = {
                high: 'var(--accent-red)',
                medium: '#e6a23c',
                low: 'var(--accent-blue)'
            };
            
            return `
                <div style="display: flex; align-items: center; justify-content: space-between; padding: 0.5rem 0.75rem; background: var(--bg-primary); border-radius: 4px; border: 1px solid var(--border-color);">
                    <span style="font-size: 0.85rem; color: var(--text-primary);">${word}</span>
                    <button onclick="removeTensionWord('${type}', ${index})" 
                            style="background: none; border: none; color: ${colors[type]}; cursor: pointer; font-size: 1rem; padding: 0 0.25rem; opacity: 0.7; transition: opacity 0.2s;"
                            onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0.7'"
                            title="Supprimer ce mot">
                        ×
                    </button>
                </div>
            `;
        }

        // Ajouter un mot de tension
        function addTensionWord(type) {
            const input = document.getElementById(`${type}TensionInput`);
            const word = input.value.trim().toLowerCase();
            
            if (!word) {
                showNotification('⚠️ Veuillez entrer un mot', 'warning');
                return;
            }
            
            const words = getTensionWords();
            
            // Vérifier si le mot existe déjà
            if (words[type].includes(word)) {
                showNotification('⚠️ Ce mot existe déjà dans cette catégorie', 'warning');
                return;
            }
            
            // Vérifier si le mot existe dans une autre catégorie
            for (const category in words) {
                if (category !== type && words[category].includes(word)) {
                    showNotification(`⚠️ Ce mot existe déjà dans la catégorie "${category === 'high' ? 'haute' : category === 'medium' ? 'moyenne' : 'faible'} tension"`, 'warning');
                    return;
                }
            }
            
            // Ajouter le mot
            words[type].push(word);
            saveTensionWordsToStorage(words);
            
            // Recharger la liste
            loadTensionWordsInEditor();
            
            // Vider l'input
            input.value = '';
            
            showNotification(`✓ Mot "${word}" ajouté`, 'success');
        }

        // Supprimer un mot de tension
        function removeTensionWord(type, index) {
            const words = getTensionWords();
            const removedWord = words[type][index];
            
            words[type].splice(index, 1);
            saveTensionWordsToStorage(words);
            
            // Recharger la liste
            loadTensionWordsInEditor();
            
            showNotification(`✓ Mot "${removedWord}" supprimé`, 'success');
        }

        // Enregistrer les modifications
        function saveTensionWords() {
            closeModal('tensionWordsModal');
            showNotification('✓ Mots de tension enregistrés. Le graphique sera recalculé lors de la prochaine visualisation.', 'success');
        }

        // Réinitialiser aux valeurs par défaut
        function resetTensionWordsToDefault() {
            if (confirm('Êtes-vous sûr de vouloir réinitialiser tous les mots de tension aux valeurs par défaut ? Cette action est irréversible.')) {
                saveTensionWordsToStorage(DEFAULT_TENSION_WORDS);
                loadTensionWordsInEditor();
                showNotification('✓ Mots de tension réinitialisés aux valeurs par défaut', 'success');
            }
        }

        // Exporter les dictionnaires de mots de tension
        function exportTensionWords() {
            const words = getTensionWords();
            
            // Créer trois fichiers texte, un par catégorie
            const highWords = words.high.join('\n');
            const mediumWords = words.medium.join('\n');
            const lowWords = words.low.join('\n');
            
            // Créer un fichier ZIP virtuel avec les trois fichiers
            const content = `=== DICTIONNAIRES DE MOTS DE TENSION ===
Exporté le ${new Date().toLocaleString('fr-FR')}

=== HAUTE TENSION (${words.high.length} mots) ===
${highWords}

=== TENSION MOYENNE (${words.medium.length} mots) ===
${mediumWords}

=== FAIBLE TENSION (${words.low.length} mots) ===
${lowWords}
`;
            
            // Créer et télécharger le fichier
            const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `dictionnaires-tension-${new Date().toISOString().slice(0, 10)}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showNotification('✓ Dictionnaires exportés avec succès', 'success');
        }

        // === BULK IMPORT FOR TENSION WORDS ===
        
        let currentBulkImportType = null;

        // Ouvrir le modal d'import en masse
        function openBulkImport(type) {
            currentBulkImportType = type;
            
            const titles = {
                high: '📥 Import en masse - Haute tension',
                medium: '📥 Import en masse - Tension moyenne',
                low: '📥 Import en masse - Faible tension'
            };
            
            document.getElementById('bulkImportTitle').textContent = titles[type];
            document.getElementById('bulkImportText').value = '';
            document.getElementById('bulkImportFile').value = '';
            document.querySelector('input[name="importMode"][value="add"]').checked = true;
            
            document.getElementById('bulkImportModal').classList.add('active');
        }

        // Traiter l'import en masse
        function processBulkImport() {
            if (!currentBulkImportType) return;
            
            const textarea = document.getElementById('bulkImportText');
            const fileInput = document.getElementById('bulkImportFile');
            const mode = document.querySelector('input[name="importMode"]:checked').value;
            
            // Vérifier si un fichier est sélectionné
            if (fileInput.files && fileInput.files[0]) {
                const file = fileInput.files[0];
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    const content = e.target.result;
                    importWordsFromText(content, currentBulkImportType, mode);
                };
                
                reader.onerror = function() {
                    showNotification('❌ Erreur lors de la lecture du fichier', 'error');
                };
                
                reader.readAsText(file);
            } else if (textarea.value.trim()) {
                // Utiliser le texte collé
                importWordsFromText(textarea.value, currentBulkImportType, mode);
            } else {
                showNotification('⚠️ Veuillez coller du texte ou sélectionner un fichier', 'warning');
            }
        }

        // Importer les mots depuis du texte
        function importWordsFromText(text, type, mode) {
            // Nettoyer et parser le texte
            let words = [];
            
            // Séparer par retours à la ligne ET par virgules
            const lines = text.split(/\r?\n/);
            lines.forEach(line => {
                // Pour chaque ligne, séparer aussi par virgules
                const wordsInLine = line.split(',');
                wordsInLine.forEach(word => {
                    const cleaned = word.trim().toLowerCase();
                    if (cleaned && cleaned.length > 0) {
                        words.push(cleaned);
                    }
                });
            });
            
            // Supprimer les doublons
            words = [...new Set(words)];
            
            if (words.length === 0) {
                showNotification('⚠️ Aucun mot valide trouvé', 'warning');
                return;
            }
            
            // Récupérer les mots existants
            const tensionWords = getTensionWords();
            
            if (mode === 'replace') {
                // Remplacer tous les mots
                tensionWords[type] = words;
                showNotification(`✓ ${words.length} mots importés (remplacement)`, 'success');
            } else {
                // Ajouter aux mots existants (sans doublons)
                const existingWords = new Set(tensionWords[type]);
                let addedCount = 0;
                
                words.forEach(word => {
                    if (!existingWords.has(word)) {
                        tensionWords[type].push(word);
                        addedCount++;
                    }
                });
                
                const skippedCount = words.length - addedCount;
                if (addedCount > 0) {
                    showNotification(`✓ ${addedCount} mot(s) ajouté(s)${skippedCount > 0 ? ` (${skippedCount} doublon(s) ignoré(s))` : ''}`, 'success');
                } else {
                    showNotification(`⚠️ Tous les mots existent déjà (${skippedCount} doublon(s))`, 'warning');
                }
            }
            
            // Sauvegarder et recharger
            saveTensionWordsToStorage(tensionWords);
            loadTensionWordsInEditor();
            
            // Fermer le modal
            closeModal('bulkImportModal');
        }

        // Gestionnaire pour le changement de fichier
        document.addEventListener('DOMContentLoaded', function() {
            const fileInput = document.getElementById('bulkImportFile');
            if (fileInput) {
                fileInput.addEventListener('change', function() {
                    if (this.files && this.files[0]) {
                        // Vider le textarea si un fichier est sélectionné
                        document.getElementById('bulkImportText').value = '';
                    }
                });
            }
            
            const textarea = document.getElementById('bulkImportText');
            if (textarea) {
                textarea.addEventListener('input', function() {
                    if (this.value.trim()) {
                        // Vider le file input si du texte est saisi
                        document.getElementById('bulkImportFile').value = '';
                    }
                });
            }
        });



// ========== 39.export.js ==========
        // ============================================
        // EXPORT NOVEL FUNCTIONS
        // ============================================

        // Global variable to track selection state
        let exportSelectionState = {};

        function openExportNovelModal() {
            // Initialize selection state with all items checked
            exportSelectionState = {};
            project.acts.forEach(act => {
                exportSelectionState[`act-${act.id}`] = true;
                act.chapters.forEach(chapter => {
                    exportSelectionState[`chapter-${chapter.id}`] = true;
                    chapter.scenes.forEach(scene => {
                        exportSelectionState[`scene-${scene.id}`] = true;
                    });
                });
            });
            
            renderExportTree();
            updateExportFormatInfo();
            document.getElementById('exportNovelModal').classList.add('active');
        }

        function renderExportTree() {
            const container = document.getElementById('exportTreeContainer');
            console.log('renderExportTree called, container:', container);
            console.log('project.acts:', project.acts);
            if (!container) return;
            
            let html = '';
            
            if (!project.acts || project.acts.length === 0) {
                html = '<p style="color: var(--text-muted); text-align: center;">Aucun acte à exporter</p>';
                container.innerHTML = html;
                return;
            }
            
            project.acts.forEach((act, actIndex) => {
                const actChecked = exportSelectionState[`act-${act.id}`] ? 'checked' : '';
                html += `
                    <div style="margin-bottom: 1rem;">
                        <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-weight: 600; font-size: 1rem; margin-bottom: 0.5rem;">
                            <input type="checkbox" ${actChecked} onchange="toggleAct(${act.id})" id="export-act-${act.id}" style="cursor: pointer;">
                            <span>Acte ${actIndex + 1}</span>
                        </label>
                        <div style="margin-left: 1.5rem;">
                `;
                
                act.chapters.forEach((chapter, chapIndex) => {
                    const chapterChecked = exportSelectionState[`chapter-${chapter.id}`] ? 'checked' : '';
                    html += `
                        <div style="margin-bottom: 0.75rem;">
                            <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-weight: 500; font-size: 0.95rem; margin-bottom: 0.25rem;">
                                <input type="checkbox" ${chapterChecked} onchange="toggleChapter(${act.id}, ${chapter.id})" id="export-chapter-${chapter.id}" style="cursor: pointer;">
                                <span>Chapitre ${chapIndex + 1}</span>
                            </label>
                            <div style="margin-left: 1.5rem;">
                    `;
                    
                    chapter.scenes.forEach((scene, sceneIndex) => {
                        const sceneChecked = exportSelectionState[`scene-${scene.id}`] ? 'checked' : '';
                        html += `
                            <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-size: 0.9rem; color: var(--text-secondary); margin-bottom: 0.25rem;">
                                <input type="checkbox" ${sceneChecked} onchange="toggleScene(${act.id}, ${chapter.id}, ${scene.id})" id="export-scene-${scene.id}" style="cursor: pointer;">
                                <span>Scène ${sceneIndex + 1}</span>
                            </label>
                        `;
                    });
                    
                    html += `
                            </div>
                        </div>
                    `;
                });
                
                html += `
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }

        function toggleAllScenes() {
            // Check if all are currently selected
            const allSelected = Object.values(exportSelectionState).every(v => v === true);
            
            // Toggle all to opposite state
            const newState = !allSelected;
            
            project.acts.forEach(act => {
                exportSelectionState[`act-${act.id}`] = newState;
                act.chapters.forEach(chapter => {
                    exportSelectionState[`chapter-${chapter.id}`] = newState;
                    chapter.scenes.forEach(scene => {
                        exportSelectionState[`scene-${scene.id}`] = newState;
                    });
                });
            });
            
            renderExportTree();
        }

        // Act Management
        // Fonctions toggleAct et toggleChapter déjà définies plus haut (lignes ~5854 et ~5944)
        // Les définitions en double ont été supprimées pour éviter les conflits

        function toggleScene(actId, chapterId, sceneId) {
            const checkbox = document.getElementById(`export-scene-${sceneId}`);
            exportSelectionState[`scene-${sceneId}`] = checkbox.checked;
            
            // Update chapter checkbox
            const act = project.acts.find(a => a.id === actId);
            if (act) {
                const chapter = act.chapters.find(c => c.id === chapterId);
                if (chapter) {
                    const allScenesChecked = chapter.scenes.every(s => exportSelectionState[`scene-${s.id}`]);
                    exportSelectionState[`chapter-${chapterId}`] = allScenesChecked;
                    
                    // Update act checkbox
                    const allChaptersChecked = act.chapters.every(c => exportSelectionState[`chapter-${c.id}`]);
                    exportSelectionState[`act-${actId}`] = allChaptersChecked;
                }
            }
            
            renderExportTree();
        }

        function updateExportFormatInfo() {
            const format = document.getElementById('exportFormatSelect').value;
            const infoBox = document.getElementById('formatInfoBox');
            
            const messages = {
                docx: '<strong style="color: var(--text-primary);">ℹ️ Note :</strong> Toutes les fonctionnalités ne sont pas supportées en format DOCX. Le texte exporté pourrait ne pas ressembler exactement à l\'éditeur. Pour une compatibilité complète, utilisez un autre format.',
                markdown: '<strong style="color: var(--text-primary);">✅ Format Markdown :</strong> Excellent pour la portabilité et la compatibilité avec la plupart des éditeurs de texte et des plateformes de publication.',
                txt: '<strong style="color: var(--text-primary);">📋 Texte brut :</strong> Format universel sans formatage. Compatible avec tous les logiciels.',
                html: '<strong style="color: var(--text-primary);">🌐 HTML :</strong> Format web avec préservation complète du formatage. Ouvrez dans un navigateur ou importez dans des éditeurs HTML.',
                epub: '<strong style="color: var(--text-primary);">📚 EPUB :</strong> Format e-book standard. Compatible avec Kindle (via conversion), Kobo, Apple Books, et la plupart des liseuses.'
            };
            
            infoBox.innerHTML = messages[format] || messages.docx;
        }

        function executeNovelExport() {
            const format = document.getElementById('exportFormatSelect').value;
            const options = {
                exportSummaries: document.getElementById('exportSummariesCheck').checked,
                exportProse: document.getElementById('exportProseCheck').checked,
                includeActTitles: document.getElementById('includeActTitlesCheck').checked,
                includeSceneSubtitles: document.getElementById('includeSceneSubtitlesCheck').checked,
                sceneDivider: document.getElementById('sceneDividerSelect').value,
                includeCharacters: document.getElementById('includeCharactersCheck').checked,
                includeWorld: document.getElementById('includeWorldCheck').checked,
                includeTimeline: document.getElementById('includeTimelineCheck').checked,
                includeRelations: document.getElementById('includeRelationsCheck').checked,
                includeCodex: document.getElementById('includeCodexCheck').checked,
                includeNotes: document.getElementById('includeNotesCheck').checked
            };
            
            // Check if creating a ZIP archive (project export)
            const isProjectExport = options.includeCharacters || options.includeWorld || 
                                   options.includeTimeline || options.includeRelations || 
                                   options.includeCodex || options.includeNotes;
            
            if (isProjectExport) {
                exportProjectAsZip(format, options);
            } else {
                // Single file export
                switch(format) {
                    case 'docx':
                        exportAsDOCX(options);
                        break;
                    case 'markdown':
                        exportAsMarkdown(options);
                        break;
                    case 'txt':
                        exportAsTXT(options);
                        break;
                    case 'html':
                        exportAsHTML(options);
                        break;
                    case 'epub':
                        exportAsEPUB(options);
                        break;
                }
            }
        }
        
        function toggleAllExportOptions(selectAll) {
            const checkboxes = [
                'includeCharactersCheck', 'includeWorldCheck', 'includeTimelineCheck',
                'includeRelationsCheck', 'includeCodexCheck', 'includeNotesCheck'
            ];
            checkboxes.forEach(id => {
                const checkbox = document.getElementById(id);
                if (checkbox) checkbox.checked = selectAll;
            });
        }

        function getSelectedContent(options) {
            let content = {
                acts: []
            };
            
            project.acts.forEach((act, actIndex) => {
                if (!exportSelectionState[`act-${act.id}`]) return;
                
                let exportAct = {
                    title: `Acte ${actIndex + 1}`,
                    chapters: []
                };
                
                act.chapters.forEach((chapter, chapIndex) => {
                    if (!exportSelectionState[`chapter-${chapter.id}`]) return;
                    
                    let exportChapter = {
                        title: chapter.title || `Chapitre ${chapIndex + 1}`,
                        scenes: []
                    };
                    
                    chapter.scenes.forEach((scene, sceneIndex) => {
                        if (!exportSelectionState[`scene-${scene.id}`]) return;
                        
                        // Utiliser la version finale si elle existe, sinon le contenu actuel
                        const sceneContent = getSceneExportContent(scene);
                        
                        let exportScene = {
                            title: scene.title || `Scène ${sceneIndex + 1}`,
                            summary: scene.summary || '',
                            content: sceneContent || ''
                        };
                        
                        exportChapter.scenes.push(exportScene);
                    });
                    
                    if (exportChapter.scenes.length > 0) {
                        exportAct.chapters.push(exportChapter);
                    }
                });
                
                if (exportAct.chapters.length > 0) {
                    content.acts.push(exportAct);
                }
            });
            
            return content;
        }

        function getSceneDivider(dividerType) {
            switch(dividerType) {
                case 'asterisks':
                    return '\n\n* * *\n\n';
                case 'hash':
                    return '\n\n###\n\n';
                case 'line':
                    return '\n\n---\n\n';
                case 'space':
                    return '\n\n\n';
                case 'none':
                    return '\n\n';
                default:
                    return '\n\n* * *\n\n';
            }
        }

        function exportAsMarkdown(options) {
            const content = getSelectedContent(options);
            const divider = getSceneDivider(options.sceneDivider);
            let markdown = `# ${project.title}\n\n`;
            
            content.acts.forEach((act, actIndex) => {
                if (options.includeActTitles) {
                    markdown += `# ${act.title}\n\n`;
                }
                
                act.chapters.forEach((chapter, chapIndex) => {
                    markdown += `## ${chapter.title}\n\n`;
                    
                    chapter.scenes.forEach((scene, sceneIndex) => {
                        if (options.includeSceneSubtitles && scene.title) {
                            markdown += `### ${scene.title}\n\n`;
                        }
                        
                        if (options.exportSummaries && scene.summary) {
                            markdown += `> ${scene.summary}\n\n`;
                        }
                        
                        if (options.exportProse && scene.content) {
                            markdown += `${scene.content}\n`;
                        }
                        
                        // Add divider between scenes (except after last scene)
                        if (sceneIndex < chapter.scenes.length - 1) {
                            markdown += divider;
                        }
                    });
                    
                    markdown += '\n\n';
                });
            });
            
            downloadFile(markdown, `${project.title}.md`, 'text/markdown');
            showNotification('✓ Export Markdown terminé');
            closeModal('exportNovelModal');
        }

        function exportAsTXT(options) {
            const content = getSelectedContent(options);
            const divider = getSceneDivider(options.sceneDivider);
            let text = `${project.title}\n${'='.repeat(project.title.length)}\n\n`;
            
            content.acts.forEach((act, actIndex) => {
                if (options.includeActTitles) {
                    text += `${act.title}\n${'-'.repeat(act.title.length)}\n\n`;
                }
                
                act.chapters.forEach((chapter, chapIndex) => {
                    text += `${chapter.title}\n\n`;
                    
                    chapter.scenes.forEach((scene, sceneIndex) => {
                        if (options.includeSceneSubtitles && scene.title) {
                            text += `${scene.title}\n\n`;
                        }
                        
                        if (options.exportSummaries && scene.summary) {
                            text += `[Résumé: ${scene.summary}]\n\n`;
                        }
                        
                        if (options.exportProse && scene.content) {
                            text += `${scene.content}\n`;
                        }
                        
                        if (sceneIndex < chapter.scenes.length - 1) {
                            text += divider;
                        }
                    });
                    
                    text += '\n\n';
                });
            });
            
            downloadFile(text, `${project.title}.txt`, 'text/plain');
            showNotification('✓ Export TXT terminé');
            closeModal('exportNovelModal');
        }

        function exportAsHTML(options) {
            const content = getSelectedContent(options);
            const divider = getSceneDivider(options.sceneDivider).replace(/\n/g, '<br>');
            
            let html = `<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${project.title}</title>
    <style>
        body {
            font-family: 'Georgia', serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 2rem;
            line-height: 1.8;
            color: #333;
            background: #fafafa;
        }
        h1 {
            font-size: 2.5rem;
            margin-bottom: 2rem;
            text-align: center;
            border-bottom: 3px solid #333;
            padding-bottom: 1rem;
        }
        h2 {
            font-size: 2rem;
            margin-top: 3rem;
            margin-bottom: 1.5rem;
            border-bottom: 2px solid #666;
            padding-bottom: 0.5rem;
        }
        h3 {
            font-size: 1.5rem;
            margin-top: 2rem;
            margin-bottom: 1rem;
            color: #666;
        }
        h4 {
            font-size: 1.2rem;
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
            color: #888;
            font-style: italic;
        }
        p {
            margin-bottom: 1rem;
            text-align: justify;
        }
        .summary {
            background: #f0f0f0;
            padding: 1rem;
            border-left: 4px solid #999;
            margin: 1rem 0;
            font-style: italic;
            color: #666;
        }
        .divider {
            text-align: center;
            margin: 2rem 0;
            color: #999;
        }
    </style>
</head>
<body>
    <h1>${project.title}</h1>
`;
            
            content.acts.forEach((act, actIndex) => {
                if (options.includeActTitles) {
                    html += `    <h2>${act.title}</h2>\n`;
                }
                
                act.chapters.forEach((chapter, chapIndex) => {
                    html += `    <h3>${chapter.title}</h3>\n`;
                    
                    chapter.scenes.forEach((scene, sceneIndex) => {
                        if (options.includeSceneSubtitles && scene.title) {
                            html += `    <h4>${scene.title}</h4>\n`;
                        }
                        
                        if (options.exportSummaries && scene.summary) {
                            html += `    <div class="summary">${scene.summary}</div>\n`;
                        }
                        
                        if (options.exportProse && scene.content) {
                            // Convert line breaks to paragraphs
                            const paragraphs = scene.content.split('\n').filter(p => p.trim());
                            paragraphs.forEach(para => {
                                html += `    <p>${para}</p>\n`;
                            });
                        }
                        
                        if (sceneIndex < chapter.scenes.length - 1 && options.sceneDivider !== 'none') {
                            html += `    <div class="divider">${divider}</div>\n`;
                        }
                    });
                });
            });
            
            html += `
        <!-- Arc Scene Panel -->
        <div id="arcScenePanel" class="arc-scene-panel hidden">
            <div class="arc-scene-panel-header">
                <h3>Arcs dans cette scène</h3>
                <button class="arc-panel-close" onclick="toggleArcScenePanel()">✕</button>
            </div>
            <div id="arcScenePanelContent" class="arc-scene-panel-content">
                <!-- Contenu dynamique -->
            </div>
        </div>

    </body>\n</html>`;
            
            downloadFile(html, `${project.title}.html`, 'text/html');
            showNotification('✓ Export HTML terminé');
            closeModal('exportNovelModal');
        }

        async function exportAsEPUB(options) {
            if (typeof JSZip === 'undefined') {
                alert('❌ Erreur : La bibliothèque JSZip n\'est pas chargée. Veuillez rafraîchir la page.');
                return;
            }

            const content = getSelectedContent(options);
            const zip = new JSZip();
            const bookId = 'plume-' + Date.now();
            const timestamp = new Date().toISOString().split('.')[0] + 'Z';
            
            // Helper to escape XML
            const escapeXML = (str) => {
                if (!str) return '';
                return str.replace(/&/g, '&amp;')
                         .replace(/</g, '&lt;')
                         .replace(/>/g, '&gt;')
                         .replace(/"/g, '&quot;')
                         .replace(/'/g, '&apos;');
            };
            
            // Helper to convert HTML content to XHTML
            const toXHTML = (text) => {
                if (!text) return '';
                const paragraphs = text.split('\n').filter(p => p.trim());
                return paragraphs.map(p => `<p>${escapeXML(p)}</p>`).join('\n');
            };
            
            // Get scene divider for EPUB
            const getDividerXHTML = () => {
                switch(options.sceneDivider) {
                    case 'asterisks': return '<p class="divider">* * *</p>';
                    case 'hash': return '<p class="divider">###</p>';
                    case 'line': return '<hr class="divider"/>';
                    case 'space': return '<p class="divider-space">&#160;</p>';
                    case 'none': return '';
                    default: return '<p class="divider">* * *</p>';
                }
            };
            
            // 1. mimetype (must be first and uncompressed)
            zip.file('mimetype', 'application/epub+zip', { compression: 'STORE' });
            
            // 2. META-INF/container.xml
            const containerXML = `<?xml version="1.0" encoding="UTF-8"?>
<container version="1.0" xmlns="urn:oasis:names:tc:opendocument:xmlns:container">
  <rootfiles>
    <rootfile full-path="OEBPS/content.opf" media-type="application/oebps-package+xml"/>
  </rootfiles>
</container>`;
            zip.file('META-INF/container.xml', containerXML);
            
            // 3. OEBPS/styles.css
            const stylesCSS = `
body {
    font-family: Georgia, "Times New Roman", serif;
    margin: 1em;
    line-height: 1.6;
}
h1 {
    font-size: 1.8em;
    text-align: center;
    margin: 1em 0;
    page-break-before: always;
}
h2 {
    font-size: 1.4em;
    margin: 1.5em 0 0.5em 0;
    page-break-before: always;
}
h3 {
    font-size: 1.1em;
    font-style: italic;
    margin: 1em 0 0.5em 0;
}
p {
    margin: 0;
    text-indent: 1.5em;
    text-align: justify;
}
p:first-of-type, h1 + p, h2 + p, h3 + p, .divider + p, .divider-space + p, hr + p {
    text-indent: 0;
}
.summary {
    font-style: italic;
    color: #666;
    margin: 1em 0;
    padding: 0.5em;
    border-left: 3px solid #ccc;
    text-indent: 0;
}
.divider {
    text-align: center;
    margin: 1.5em 0;
    text-indent: 0;
}
.divider-space {
    margin: 2em 0;
    text-indent: 0;
}
hr.divider {
    border: none;
    border-top: 1px solid #ccc;
    margin: 1.5em 2em;
}
.title-page {
    text-align: center;
    margin-top: 30%;
}
.title-page h1 {
    page-break-before: avoid;
}
`;
            zip.file('OEBPS/styles.css', stylesCSS);
            
            // 4. Generate chapter files and build manifest/spine
            const manifestItems = [];
            const spineItems = [];
            let chapterNum = 0;
            
            // Title page
            const titlePageXHTML = `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="fr" lang="fr">
<head>
    <meta charset="UTF-8"/>
    <title>${escapeXML(project.title)}</title>
    <link rel="stylesheet" type="text/css" href="styles.css"/>
</head>
<body>
    <div class="title-page">
        <h1>${escapeXML(project.title)}</h1>
    </div>

        <!-- Arc Scene Panel -->
        <div id="arcScenePanel" class="arc-scene-panel hidden">
            <div class="arc-scene-panel-header">
                <h3>Arcs dans cette scène</h3>
                <button class="arc-panel-close" onclick="toggleArcScenePanel()">✕</button>
            </div>
            <div id="arcScenePanelContent" class="arc-scene-panel-content">
                <!-- Contenu dynamique -->
            </div>
        </div>

    </body>
</html>`;
            zip.file('OEBPS/title.xhtml', titlePageXHTML);
            manifestItems.push('<item id="title" href="title.xhtml" media-type="application/xhtml+xml"/>');
            spineItems.push('<itemref idref="title"/>');
            
            // NAV document (EPUB 3 navigation)
            let navContent = `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="fr" lang="fr">
<head>
    <meta charset="UTF-8"/>
    <title>Table des matières</title>
    <link rel="stylesheet" type="text/css" href="styles.css"/>
</head>
<body>
    <nav epub:type="toc" id="toc">
        <h1>Table des matières</h1>
        <ol>
            <li><a href="title.xhtml">${escapeXML(project.title)}</a></li>
`;
            
            // Generate chapter files
            content.acts.forEach((act, actIndex) => {
                if (options.includeActTitles) {
                    navContent += `            <li><a href="chapter${chapterNum + 1}.xhtml">${escapeXML(act.title)}</a>
                <ol>\n`;
                }
                
                act.chapters.forEach((chapter, chapIndex) => {
                    chapterNum++;
                    const chapterId = `chapter${chapterNum}`;
                    const fileName = `${chapterId}.xhtml`;
                    
                    let chapterContent = `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="fr" lang="fr">
<head>
    <meta charset="UTF-8"/>
    <title>${escapeXML(chapter.title)}</title>
    <link rel="stylesheet" type="text/css" href="styles.css"/>
</head>
<body>
`;
                    
                    if (options.includeActTitles && chapIndex === 0) {
                        chapterContent += `    <h1>${escapeXML(act.title)}</h1>\n`;
                    }
                    
                    chapterContent += `    <h2>${escapeXML(chapter.title)}</h2>\n`;
                    
                    chapter.scenes.forEach((scene, sceneIndex) => {
                        if (options.includeSceneSubtitles && scene.title) {
                            chapterContent += `    <h3>${escapeXML(scene.title)}</h3>\n`;
                        }
                        
                        if (options.exportSummaries && scene.summary) {
                            chapterContent += `    <p class="summary">${escapeXML(scene.summary)}</p>\n`;
                        }
                        
                        if (options.exportProse && scene.content) {
                            chapterContent += toXHTML(scene.content) + '\n';
                        }
                        
                        if (sceneIndex < chapter.scenes.length - 1 && options.sceneDivider !== 'none') {
                            chapterContent += `    ${getDividerXHTML()}\n`;
                        }
                    });
                    
                    chapterContent += `
        <!-- Arc Scene Panel -->
        <div id="arcScenePanel" class="arc-scene-panel hidden">
            <div class="arc-scene-panel-header">
                <h3>Arcs dans cette scène</h3>
                <button class="arc-panel-close" onclick="toggleArcScenePanel()">✕</button>
            </div>
            <div id="arcScenePanelContent" class="arc-scene-panel-content">
                <!-- Contenu dynamique -->
            </div>
        </div>

    </body>
</html>`;
                    
                    zip.file(`OEBPS/${fileName}`, chapterContent);
                    manifestItems.push(`<item id="${chapterId}" href="${fileName}" media-type="application/xhtml+xml"/>`);
                    spineItems.push(`<itemref idref="${chapterId}"/>`);
                    
                    if (options.includeActTitles) {
                        navContent += `                    <li><a href="${fileName}">${escapeXML(chapter.title)}</a></li>\n`;
                    } else {
                        navContent += `            <li><a href="${fileName}">${escapeXML(chapter.title)}</a></li>\n`;
                    }
                });
                
                if (options.includeActTitles) {
                    navContent += `                </ol>
            </li>\n`;
                }
            });
            
            navContent += `        </ol>
    </nav>

        <!-- Arc Scene Panel -->
        <div id="arcScenePanel" class="arc-scene-panel hidden">
            <div class="arc-scene-panel-header">
                <h3>Arcs dans cette scène</h3>
                <button class="arc-panel-close" onclick="toggleArcScenePanel()">✕</button>
            </div>
            <div id="arcScenePanelContent" class="arc-scene-panel-content">
                <!-- Contenu dynamique -->
            </div>
        </div>

    </body>
</html>`;
            
            zip.file('OEBPS/nav.xhtml', navContent);
            manifestItems.push('<item id="nav" href="nav.xhtml" media-type="application/xhtml+xml" properties="nav"/>');
            
            // 5. content.opf (package document)
            const contentOPF = `<?xml version="1.0" encoding="UTF-8"?>
<package xmlns="http://www.idpf.org/2007/opf" version="3.0" unique-identifier="BookId">
    <metadata xmlns:dc="http://purl.org/dc/elements/1.1/">
        <dc:identifier id="BookId">${bookId}</dc:identifier>
        <dc:title>${escapeXML(project.title)}</dc:title>
        <dc:language>fr</dc:language>
        <dc:creator>Plume</dc:creator>
        <meta property="dcterms:modified">${timestamp}</meta>
    </metadata>
    <manifest>
        <item id="css" href="styles.css" media-type="text/css"/>
        ${manifestItems.join('\n        ')}
    </manifest>
    <spine>
        ${spineItems.join('\n        ')}
    </spine>
</package>`;
            
            zip.file('OEBPS/content.opf', contentOPF);
            
            // Generate the EPUB file
            try {
                const blob = await zip.generateAsync({ 
                    type: 'blob',
                    mimeType: 'application/epub+zip',
                    compression: 'DEFLATE',
                    compressionOptions: { level: 9 }
                });
                saveAs(blob, `${project.title}.epub`);
                showNotification('✓ Export EPUB terminé');
                closeModal('exportNovelModal');
            } catch (error) {
                alert('❌ Erreur lors de l\'export EPUB : ' + error.message);
                console.error(error);
            }
        }

        async function exportAsDOCX(options) {
            // Check if docx library is loaded
            if (typeof docx === 'undefined') {
                alert('❌ Erreur : La bibliothèque DOCX n\'est pas chargée. Veuillez rafraîchir la page.');
                return;
            }

            const content = getSelectedContent(options);
            const { Document, Packer, Paragraph, TextRun, HeadingLevel, AlignmentType } = docx;
            
            const children = [];
            
            // Title
            children.push(
                new Paragraph({
                    text: project.title,
                    heading: HeadingLevel.TITLE,
                    alignment: AlignmentType.CENTER,
                    spacing: { after: 400 }
                })
            );
            
            content.acts.forEach((act, actIndex) => {
                if (options.includeActTitles) {
                    children.push(
                        new Paragraph({
                            text: act.title,
                            heading: HeadingLevel.HEADING_1,
                            spacing: { before: 400, after: 200 }
                        })
                    );
                }
                
                act.chapters.forEach((chapter, chapIndex) => {
                    children.push(
                        new Paragraph({
                            text: chapter.title,
                            heading: HeadingLevel.HEADING_2,
                            spacing: { before: 300, after: 200 }
                        })
                    );
                    
                    chapter.scenes.forEach((scene, sceneIndex) => {
                        if (options.includeSceneSubtitles && scene.title) {
                            children.push(
                                new Paragraph({
                                    text: scene.title,
                                    heading: HeadingLevel.HEADING_3,
                                    spacing: { before: 200, after: 100 }
                                })
                            );
                        }
                        
                        if (options.exportSummaries && scene.summary) {
                            children.push(
                                new Paragraph({
                                    children: [
                                        new TextRun({
                                            text: scene.summary,
                                            italics: true
                                        })
                                    ],
                                    spacing: { after: 200 }
                                })
                            );
                        }
                        
                        if (options.exportProse && scene.content) {
                            const paragraphs = scene.content.split('\n').filter(p => p.trim());
                            paragraphs.forEach(para => {
                                children.push(
                                    new Paragraph({
                                        text: para,
                                        spacing: { after: 200 }
                                    })
                                );
                            });
                        }
                        
                        // Add divider between scenes
                        if (sceneIndex < chapter.scenes.length - 1) {
                            const dividerText = options.sceneDivider === 'asterisks' ? '* * *' :
                                              options.sceneDivider === 'hash' ? '###' :
                                              options.sceneDivider === 'line' ? '---' : '';
                            
                            if (dividerText) {
                                children.push(
                                    new Paragraph({
                                        text: dividerText,
                                        alignment: AlignmentType.CENTER,
                                        spacing: { before: 200, after: 200 }
                                    })
                                );
                            }
                        }
                    });
                });
            });
            
            const doc = new Document({
                sections: [{
                    properties: {},
                    children: children
                }]
            });
            
            try {
                const blob = await Packer.toBlob(doc);
                saveAs(blob, `${project.title}.docx`);
                showNotification('✓ Export DOCX terminé');
                closeModal('exportNovelModal');
            } catch (error) {
                alert('❌ Erreur lors de l\'export DOCX : ' + error.message);
                console.error(error);
            }
        }

        async function exportProjectAsZip(format, options) {
            if (typeof JSZip === 'undefined') {
                alert('❌ Erreur : La bibliothèque JSZip n\'est pas chargée. Veuillez rafraîchir la page.');
                return;
            }

            const zip = new JSZip();
            
            // Add main novel file
            const content = getSelectedContent(options);
            let mainFileContent = '';
            let mainFileName = '';
            
            switch(format) {
                case 'markdown':
                    mainFileContent = await generateMarkdownContent(content, options);
                    mainFileName = `${project.title}.md`;
                    break;
                case 'txt':
                    mainFileContent = await generateTXTContent(content, options);
                    mainFileName = `${project.title}.txt`;
                    break;
                case 'html':
                    mainFileContent = await generateHTMLContent(content, options);
                    mainFileName = `${project.title}.html`;
                    break;
                case 'docx':
                    // DOCX is binary, handled separately below
                    break;
            }
            
            if (format !== 'docx') {
                zip.file(mainFileName, mainFileContent);
            } else {
                // For DOCX, we need to generate the binary blob
                const docxBlob = await generateDOCXBlob(content, options);
                zip.file(`${project.title}.docx`, docxBlob);
            }
            
            // Add Characters if requested
            if (options.includeCharacters && project.characters && project.characters.length > 0) {
                let charactersContent = '# Personnages\n\n';
                project.characters.forEach(char => {
                    charactersContent += `## ${char.name}\n\n`;
                    if (char.role) charactersContent += `**Rôle:** ${char.role}\n\n`;
                    if (char.age) charactersContent += `**Âge:** ${char.age}\n\n`;
                    if (char.description) charactersContent += `**Description:** ${char.description}\n\n`;
                    if (char.background) charactersContent += `**Histoire:** ${char.background}\n\n`;
                    if (char.personality) charactersContent += `**Personnalité:** ${char.personality}\n\n`;
                    if (char.goals) charactersContent += `**Objectifs:** ${char.goals}\n\n`;
                    if (char.strengths) charactersContent += `**Forces:** ${char.strengths}\n\n`;
                    if (char.weaknesses) charactersContent += `**Faiblesses:** ${char.weaknesses}\n\n`;
                    if (char.notes) charactersContent += `**Notes:** ${char.notes}\n\n`;
                    charactersContent += '---\n\n';
                });
                zip.file('Personnages.md', charactersContent);
            }
            
            // Add World/Universe if requested
            if (options.includeWorld && project.world && project.world.length > 0) {
                let worldContent = '# Univers\n\n';
                project.world.forEach(elem => {
                    worldContent += `## ${elem.name}\n\n`;
                    if (elem.type) worldContent += `**Type:** ${elem.type}\n\n`;
                    if (elem.description) worldContent += `${elem.description}\n\n`;
                    if (elem.history) worldContent += `**Histoire:** ${elem.history}\n\n`;
                    if (elem.culture) worldContent += `**Culture:** ${elem.culture}\n\n`;
                    if (elem.geography) worldContent += `**Géographie:** ${elem.geography}\n\n`;
                    if (elem.notes) worldContent += `**Notes:** ${elem.notes}\n\n`;
                    worldContent += '---\n\n';
                });
                zip.file('Univers.md', worldContent);
            }
            
            // Add Timeline if requested
            if (options.includeTimeline && project.timeline && project.timeline.length > 0) {
                let timelineContent = '# Timeline\n\n';
                const sortedEvents = [...project.timeline].sort((a, b) => {
                    if (a.date && b.date) return new Date(a.date) - new Date(b.date);
                    return (a.order || 0) - (b.order || 0);
                });
                sortedEvents.forEach(event => {
                    timelineContent += `## ${event.title}\n\n`;
                    if (event.date) timelineContent += `**Date:** ${event.date}\n\n`;
                    if (event.era) timelineContent += `**Ère:** ${event.era}\n\n`;
                    if (event.description) timelineContent += `${event.description}\n\n`;
                    if (event.characters && event.characters.length > 0) {
                        const charNames = event.characters.map(id => {
                            const char = project.characters?.find(c => c.id === id);
                            return char ? char.name : id;
                        }).join(', ');
                        timelineContent += `**Personnages impliqués:** ${charNames}\n\n`;
                    }
                    timelineContent += '---\n\n';
                });
                zip.file('Timeline.md', timelineContent);
            }
            
            // Add Relations if requested
            if (options.includeRelations && project.relationships && project.relationships.length > 0) {
                let relationsContent = '# Relations entre personnages\n\n';
                project.relationships.forEach(rel => {
                    const char1 = project.characters?.find(c => c.id === rel.source || c.id === rel.from);
                    const char2 = project.characters?.find(c => c.id === rel.target || c.id === rel.to);
                    const name1 = char1 ? char1.name : 'Inconnu';
                    const name2 = char2 ? char2.name : 'Inconnu';
                    relationsContent += `## ${name1} ↔ ${name2}\n\n`;
                    if (rel.type) relationsContent += `**Type:** ${rel.type}\n\n`;
                    if (rel.label) relationsContent += `**Relation:** ${rel.label}\n\n`;
                    if (rel.description) relationsContent += `${rel.description}\n\n`;
                    relationsContent += '---\n\n';
                });
                zip.file('Relations.md', relationsContent);
            }
            
            // Add Codex if requested
            if (options.includeCodex && project.codex && project.codex.length > 0) {
                let codexContent = '# Codex\n\n';
                project.codex.forEach(entry => {
                    codexContent += `## ${entry.title || entry.name}\n\n`;
                    if (entry.category) codexContent += `**Catégorie:** ${entry.category}\n\n`;
                    if (entry.content) codexContent += `${entry.content}\n\n`;
                    if (entry.description) codexContent += `${entry.description}\n\n`;
                    codexContent += '---\n\n';
                });
                zip.file('Codex.md', codexContent);
            }
            
            // Add Notes if requested  
            if (options.includeNotes && project.notes && project.notes.length > 0) {
                let notesContent = '# Notes\n\n';
                project.notes.forEach(note => {
                    notesContent += `## ${note.title}\n\n`;
                    if (note.category) notesContent += `**Catégorie:** ${note.category}\n\n`;
                    if (note.content) notesContent += `${note.content}\n\n`;
                    notesContent += '---\n\n';
                });
                zip.file('Notes.md', notesContent);
            }
            
            // Generate and download ZIP
            try {
                const blob = await zip.generateAsync({ type: 'blob' });
                saveAs(blob, `${project.title}_Export.zip`);
                showNotification('✓ Export du projet complet terminé');
                closeModal('exportNovelModal');
            } catch (error) {
                alert('❌ Erreur lors de la création du ZIP : ' + error.message);
                console.error(error);
            }
        }

        async function generateMarkdownContent(content, options) {
            const divider = getSceneDivider(options.sceneDivider);
            let markdown = `# ${project.title}\n\n`;
            
            content.acts.forEach((act, actIndex) => {
                if (options.includeActTitles) {
                    markdown += `# ${act.title}\n\n`;
                }
                
                act.chapters.forEach((chapter, chapIndex) => {
                    markdown += `## ${chapter.title}\n\n`;
                    
                    chapter.scenes.forEach((scene, sceneIndex) => {
                        if (options.includeSceneSubtitles && scene.title) {
                            markdown += `### ${scene.title}\n\n`;
                        }
                        
                        if (options.exportSummaries && scene.summary) {
                            markdown += `> ${scene.summary}\n\n`;
                        }
                        
                        if (options.exportProse && scene.content) {
                            markdown += `${scene.content}\n`;
                        }
                        
                        if (sceneIndex < chapter.scenes.length - 1) {
                            markdown += divider;
                        }
                    });
                    
                    markdown += '\n\n';
                });
            });
            
            return markdown;
        }

        async function generateTXTContent(content, options) {
            const divider = getSceneDivider(options.sceneDivider);
            let text = `${project.title}\n${'='.repeat(project.title.length)}\n\n`;
            
            content.acts.forEach((act, actIndex) => {
                if (options.includeActTitles) {
                    text += `${act.title}\n${'-'.repeat(act.title.length)}\n\n`;
                }
                
                act.chapters.forEach((chapter, chapIndex) => {
                    text += `${chapter.title}\n\n`;
                    
                    chapter.scenes.forEach((scene, sceneIndex) => {
                        if (options.includeSceneSubtitles && scene.title) {
                            text += `${scene.title}\n\n`;
                        }
                        
                        if (options.exportSummaries && scene.summary) {
                            text += `[Résumé: ${scene.summary}]\n\n`;
                        }
                        
                        if (options.exportProse && scene.content) {
                            text += `${scene.content}\n`;
                        }
                        
                        if (sceneIndex < chapter.scenes.length - 1) {
                            text += divider;
                        }
                    });
                    
                    text += '\n\n';
                });
            });
            
            return text;
        }

        async function generateHTMLContent(content, options) {
            const divider = getSceneDivider(options.sceneDivider).replace(/\n/g, '<br>');
            
            let html = `<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${project.title}</title>
    <style>
        body { font-family: 'Georgia', serif; max-width: 800px; margin: 0 auto; padding: 2rem; line-height: 1.8; color: #333; background: #fafafa; }
        h1 { font-size: 2.5rem; margin-bottom: 2rem; text-align: center; border-bottom: 3px solid #333; padding-bottom: 1rem; }
        h2 { font-size: 2rem; margin-top: 3rem; margin-bottom: 1.5rem; border-bottom: 2px solid #666; padding-bottom: 0.5rem; }
        h3 { font-size: 1.5rem; margin-top: 2rem; margin-bottom: 1rem; color: #666; }
        h4 { font-size: 1.2rem; margin-top: 1.5rem; margin-bottom: 0.75rem; color: #888; font-style: italic; }
        p { margin-bottom: 1rem; text-align: justify; }
        .summary { background: #f0f0f0; padding: 1rem; border-left: 4px solid #999; margin: 1rem 0; font-style: italic; color: #666; }
        .divider { text-align: center; margin: 2rem 0; color: #999; }
    </style>
</head>
<body>
    <h1>${project.title}</h1>
`;
            
            content.acts.forEach((act, actIndex) => {
                if (options.includeActTitles) {
                    html += `    <h2>${act.title}</h2>\n`;
                }
                
                act.chapters.forEach((chapter, chapIndex) => {
                    html += `    <h3>${chapter.title}</h3>\n`;
                    
                    chapter.scenes.forEach((scene, sceneIndex) => {
                        if (options.includeSceneSubtitles && scene.title) {
                            html += `    <h4>${scene.title}</h4>\n`;
                        }
                        
                        if (options.exportSummaries && scene.summary) {
                            html += `    <div class="summary">${scene.summary}</div>\n`;
                        }
                        
                        if (options.exportProse && scene.content) {
                            const paragraphs = scene.content.split('\n').filter(p => p.trim());
                            paragraphs.forEach(para => {
                                html += `    <p>${para}</p>\n`;
                            });
                        }
                        
                        if (sceneIndex < chapter.scenes.length - 1 && options.sceneDivider !== 'none') {
                            html += `    <div class="divider">${divider}</div>\n`;
                        }
                    });
                });
            });
            
            html += `
        <!-- Arc Scene Panel -->
        <div id="arcScenePanel" class="arc-scene-panel hidden">
            <div class="arc-scene-panel-header">
                <h3>Arcs dans cette scène</h3>
                <button class="arc-panel-close" onclick="toggleArcScenePanel()">✕</button>
            </div>
            <div id="arcScenePanelContent" class="arc-scene-panel-content">
                <!-- Contenu dynamique -->
            </div>
        </div>

    </body>\n</html>`;
            return html;
        }

        async function generateDOCXBlob(content, options) {
            const { Document, Packer, Paragraph, TextRun, HeadingLevel, AlignmentType } = docx;
            
            const children = [];
            
            children.push(
                new Paragraph({
                    text: project.title,
                    heading: HeadingLevel.TITLE,
                    alignment: AlignmentType.CENTER,
                    spacing: { after: 400 }
                })
            );
            
            content.acts.forEach((act, actIndex) => {
                if (options.includeActTitles) {
                    children.push(
                        new Paragraph({
                            text: act.title,
                            heading: HeadingLevel.HEADING_1,
                            spacing: { before: 400, after: 200 }
                        })
                    );
                }
                
                act.chapters.forEach((chapter, chapIndex) => {
                    children.push(
                        new Paragraph({
                            text: chapter.title,
                            heading: HeadingLevel.HEADING_2,
                            spacing: { before: 300, after: 200 }
                        })
                    );
                    
                    chapter.scenes.forEach((scene, sceneIndex) => {
                        if (options.includeSceneSubtitles && scene.title) {
                            children.push(
                                new Paragraph({
                                    text: scene.title,
                                    heading: HeadingLevel.HEADING_3,
                                    spacing: { before: 200, after: 100 }
                                })
                            );
                        }
                        
                        if (options.exportSummaries && scene.summary) {
                            children.push(
                                new Paragraph({
                                    children: [
                                        new TextRun({
                                            text: scene.summary,
                                            italics: true
                                        })
                                    ],
                                    spacing: { after: 200 }
                                })
                            );
                        }
                        
                        if (options.exportProse && scene.content) {
                            const paragraphs = scene.content.split('\n').filter(p => p.trim());
                            paragraphs.forEach(para => {
                                children.push(
                                    new Paragraph({
                                        text: para,
                                        spacing: { after: 200 }
                                    })
                                );
                            });
                        }
                        
                        if (sceneIndex < chapter.scenes.length - 1) {
                            const dividerText = options.sceneDivider === 'asterisks' ? '* * *' :
                                              options.sceneDivider === 'hash' ? '###' :
                                              options.sceneDivider === 'line' ? '---' : '';
                            
                            if (dividerText) {
                                children.push(
                                    new Paragraph({
                                        text: dividerText,
                                        alignment: AlignmentType.CENTER,
                                        spacing: { before: 200, after: 200 }
                                    })
                                );
                            }
                        }
                    });
                });
            });
            
            const doc = new Document({
                sections: [{
                    properties: {},
                    children: children
                }]
            });
            
            return await Packer.toBlob(doc);
        }

        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: `${mimeType};charset=utf-8` });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }



// ========== 40.sidebar-views.js ==========
        // ============================================
        // MOBILE SIDEBAR VIEWS
        // ============================================
        
        function renderMobileSidebarView(view) {
            const editorView = document.getElementById('editorView');
            if (!editorView) return;
            
            const viewConfig = {
                editor: {
                    icon: '📝',
                    title: 'Structure de votre roman',
                    description: 'Organisez votre roman en actes, chapitres et scènes',
                    emptyMessage: 'Aucun acte créé',
                    emptySubMessage: 'Commencez par créer votre premier acte pour structurer votre histoire',
                    actionButton: '<button class="btn btn-primary" style="font-size: 1.2rem; padding: 1rem 2rem;" onclick="openAddActModal()">+ Créer un acte</button>',
                    sidebarHint: 'Utilisez la poignée dorée sur le bord gauche pour naviguer dans votre structure'
                },
                characters: {
                    icon: '👥',
                    title: 'Personnages',
                    description: 'Gérez vos personnages et leurs caractéristiques',
                    emptyMessage: 'Aucun personnage créé',
                    emptySubMessage: 'Créez votre premier personnage pour donner vie à votre histoire',
                    actionButton: '<button class="btn btn-primary" style="font-size: 1.2rem; padding: 1rem 2rem;" onclick="openAddCharacterModal()">+ Créer un personnage</button>',
                    sidebarHint: 'Utilisez la poignée dorée sur le bord gauche pour voir la liste complète'
                },
                world: {
                    icon: '🌍',
                    title: 'Univers',
                    description: 'Créez les éléments de votre monde (lieux, objets, concepts)',
                    emptyMessage: 'Aucun élément créé',
                    emptySubMessage: 'Ajoutez des lieux, objets ou concepts pour enrichir votre univers',
                    actionButton: '<button class="btn btn-primary" style="font-size: 1.2rem; padding: 1rem 2rem;" onclick="openAddWorldModal()">+ Créer un élément</button>',
                    sidebarHint: 'Utilisez la poignée dorée sur le bord gauche pour voir tous vos éléments'
                },
                notes: {
                    icon: '📋',
                    title: 'Notes',
                    description: 'Prenez des notes et organisez vos recherches',
                    emptyMessage: 'Aucune note créée',
                    emptySubMessage: 'Créez des notes pour garder vos idées et recherches organisées',
                    actionButton: '<button class="btn btn-primary" style="font-size: 1.2rem; padding: 1rem 2rem;" onclick="openAddNoteModal()">+ Créer une note</button>',
                    sidebarHint: 'Utilisez la poignée dorée sur le bord gauche pour voir toutes vos notes'
                },
                codex: {
                    icon: '📖',
                    title: 'Codex',
                    description: 'Wiki de votre univers - glossaire et encyclopédie',
                    emptyMessage: 'Aucune entrée dans le codex',
                    emptySubMessage: 'Créez des entrées pour documenter votre univers',
                    actionButton: '<button class="btn btn-primary" style="font-size: 1.2rem; padding: 1rem 2rem;" onclick="openAddCodexModal()">+ Créer une entrée</button>',
                    sidebarHint: 'Utilisez la poignée dorée sur le bord gauche pour parcourir le codex'
                }
            };
            
            const config = viewConfig[view];
            if (!config) return;
            
            // Vérifier si vide
            let isEmpty = false;
            let count = 0;
            
            if (view === 'editor') {
                isEmpty = !project.acts || project.acts.length === 0;
                count = project.acts ? project.acts.length : 0;
            } else if (view === 'characters') {
                isEmpty = !project.characters || project.characters.length === 0;
                count = project.characters ? project.characters.length : 0;
            } else if (view === 'world') {
                isEmpty = !project.world || project.world.length === 0;
                count = project.world ? project.world.length : 0;
            } else if (view === 'notes') {
                isEmpty = !project.notes || project.notes.length === 0;
                count = project.notes ? project.notes.length : 0;
            } else if (view === 'codex') {
                isEmpty = !project.codex || project.codex.length === 0;
                count = project.codex ? project.codex.length : 0;
            }
            
            let html = `
                <div class="empty-state" style="padding: 2rem 1.5rem; text-align: center;">
                    <div class="empty-state-icon" style="font-size: 4rem; margin-bottom: 1rem;">
                        ${config.icon}
                    </div>
                    <div class="empty-state-title" style="font-size: 1.5rem; font-weight: 600; margin-bottom: 0.5rem; color: var(--text-primary);">
                        ${config.title}
                    </div>
                    <div class="empty-state-text" style="color: var(--text-secondary); margin-bottom: 1.5rem; line-height: 1.6;">
                        ${config.description}
                    </div>
            `;
            
            if (isEmpty) {
                html += `
                    <div style="background: var(--bg-secondary); padding: 1.5rem; border-radius: 8px; margin-bottom: 1.5rem; border-left: 3px solid var(--accent-gold);">
                        <div style="font-weight: 600; margin-bottom: 0.5rem; color: var(--text-primary);">
                            ${config.emptyMessage}
                        </div>
                        <div style="color: var(--text-secondary); font-size: 0.95rem;">
                            ${config.emptySubMessage}
                        </div>
                    </div>
                    ${config.actionButton}
                `;
            } else {
                html += `
                    <div style="background: var(--bg-secondary); padding: 1.5rem; border-radius: 8px; margin-bottom: 1.5rem;">
                        <div style="font-size: 2rem; font-weight: bold; color: var(--accent-gold); margin-bottom: 0.5rem;">
                            ${count}
                        </div>
                        <div style="color: var(--text-secondary);">
                            ${count === 1 ? 'élément' : 'éléments'}
                        </div>
                    </div>
                    ${config.actionButton}
                `;
            }
            
            html += `
                    <div style="margin-top: 2rem; padding: 1rem; background: rgba(212, 175, 55, 0.1); border-radius: 8px; border: 1px solid var(--accent-gold);">
                        <div style="font-size: 1.2rem; margin-bottom: 0.5rem;">💡</div>
                        <div style="font-size: 0.9rem; color: var(--text-secondary); line-height: 1.6;">
                            ${config.sidebarHint}
                        </div>
                    </div>
                </div>
            `;
            
            editorView.innerHTML = html;
        }
        
        // ============================================
        // END MOBILE SIDEBAR VIEWS
        // ============================================

// ========== 41.storageMonitoring.js ==========


        // ============================================
        // STORAGE QUOTA MONITORING FUNCTIONS
        // ============================================

        let storageWarningShown = false;
        let storageCriticalShown = false;

        function initStorageMonitoring() {
            console.log('🔍 Initialisation de la surveillance du stockage IndexedDB...');
            
            // Vérifier que les éléments existent
            const badge = document.getElementById('storage-badge');
            const percentage = document.getElementById('storage-percentage');
            
            if (!badge) {
                console.error('❌ Badge de stockage introuvable dans le DOM');
                return;
            }
            
            if (!percentage) {
                console.error('❌ Élément storage-percentage introuvable');
                return;
            }
            
            console.log('✅ Éléments trouvés, mise à jour du badge...');
            updateStorageBadge();
            checkStorageQuota();
            console.log('✅ Surveillance du stockage initialisée');
        }

        async function getStorageSize() {
            try {
                // Utiliser l'API Storage Estimate pour obtenir la taille réelle
                if ('storage' in navigator && 'estimate' in navigator.storage) {
                    const estimate = await navigator.storage.estimate();
                    return {
                        used: estimate.usage || 0,
                        quota: estimate.quota || (50 * 1024 * 1024) // Default 50 MB si non disponible
                    };
                } else {
                    // Fallback : calculer la taille approximative d'IndexedDB
                    const size = await getIndexedDBSize();
                    return {
                        used: size,
                        quota: 50 * 1024 * 1024 // 50 MB par défaut
                    };
                }
            } catch (error) {
                console.error('❌ Erreur calcul taille stockage:', error);
                return {
                    used: 0,
                    quota: 50 * 1024 * 1024
                };
            }
        }

        function formatBytes(bytes) {
            if (bytes === 0) return '0 MB';
            const mb = bytes / (1024 * 1024);
            return mb.toFixed(2) + ' MB';
        }

        async function updateStorageBadge() {
            try {
                const { used, quota } = await getStorageSize();
                const percentage = Math.min(100, Math.round((used / quota) * 100));
                
                const badge = document.getElementById('storage-badge');
                const percentageText = document.getElementById('storage-percentage');
                
                if (!badge || !percentageText) return;
                
                percentageText.textContent = percentage + '%';
                
                // Update badge status
                badge.className = 'storage-badge';
                if (percentage >= 95) {
                    badge.classList.add('status-danger');
                } else if (percentage >= 80) {
                    badge.classList.add('status-warning');
                } else {
                    badge.classList.add('status-ok');
                }
                
                // Check and show warnings
                await checkStorageQuota();
            } catch (error) {
                console.error('❌ Erreur mise à jour badge:', error);
            }
        }

        async function checkStorageQuota() {
            try {
                const { used, quota } = await getStorageSize();
                const percentage = (used / quota) * 100;
                
                if (percentage >= 95 && !storageCriticalShown) {
                    storageCriticalShown = true;
                    showStorageAlert(
                        '🚨 Espace critique !',
                        `Vous avez utilisé ${Math.round(percentage)}% de l'espace disponible (${formatBytes(used)} / ${formatBytes(quota)}).\n\n` +
                        `⚠️ ATTENTION : Vous risquez de perdre vos données !\n\n` +
                        `Actions urgentes :\n` +
                        `• Exportez immédiatement votre projet en JSON\n` +
                        `• Supprimez des versions anciennes\n` +
                        `• Réduisez le nombre de notes\n\n` +
                        `Voulez-vous exporter maintenant ?`,
                        'danger'
                    );
                } else if (percentage >= 80 && !storageWarningShown) {
                    storageWarningShown = true;
                    showStorageAlert(
                        '⚠️ Espace limité',
                        `Vous avez utilisé ${Math.round(percentage)}% de l'espace disponible.\n\n` +
                        `Recommandations :\n` +
                        `• Exportez régulièrement votre projet\n` +
                        `• Surveillez votre utilisation\n` +
                        `• Pensez à nettoyer les anciennes versions`,
                        'warning'
                    );
                }
                
                // Reset warnings if space freed
                if (percentage < 80) {
                    storageWarningShown = false;
                    storageCriticalShown = false;
                }
            } catch (error) {
                console.error('❌ Erreur vérification quota:', error);
            }
        }

        function showStorageAlert(title, message, level) {
            if (confirm(`${title}\n\n${message}`)) {
                if (level === 'danger') {
                    showExportModal();
                } else {
                    showStorageDetails();
                }
            }
        }

        async function showStorageDetails() {
            try {
                const { used, quota } = await getStorageSize();
                const percentage = Math.min(100, Math.round((used / quota) * 100));
                const available = quota - used;
                
                // Update storage bar
                const barFill = document.getElementById('storage-bar-fill');
                const barText = document.getElementById('storage-bar-text');
                
                if (barFill && barText) {
                    barFill.style.width = percentage + '%';
                    barText.textContent = percentage + '%';
                    
                    // Update bar color
                    barFill.className = 'storage-bar-fill';
                    if (percentage >= 95) {
                        barFill.classList.add('danger');
                    } else if (percentage >= 80) {
                        barFill.classList.add('warning');
                    } else {
                        barFill.classList.add('ok');
                    }
                }
                
                // Update stats
                const usedEl = document.getElementById('storage-used');
                const availableEl = document.getElementById('storage-available');
                
                if (usedEl) usedEl.textContent = formatBytes(used);
                if (availableEl) availableEl.textContent = formatBytes(available);
                
                // Update recommendations
                const recommendationsContainer = document.getElementById('storage-recommendations-container');
                const recommendationsDetails = document.getElementById('storage-recommendations-details');
                const recommendationsSummary = recommendationsDetails ? recommendationsDetails.querySelector('summary') : null;
                
                if (recommendationsContainer && recommendationsSummary) {
                    let recommendations = '';
                    let summaryText = '';
                    let summaryColor = 'var(--accent-green)';
                    
                    if (percentage >= 95) {
                        summaryText = '🚨 Actions urgentes';
                        summaryColor = 'var(--accent-red)';
                        recommendations = `
                            <ul style="font-size: 0.8rem; color: var(--text-secondary); line-height: 1.5; padding-left: 1.25rem; margin: 0;">
                                <li>Exportez immédiatement votre projet en JSON</li>
                                <li>Supprimez des versions anciennes</li>
                                <li>Réduisez le nombre de notes archivées</li>
                            </ul>
                        `;
                        // Ouvrir automatiquement si urgent
                        recommendationsDetails.open = true;
                    } else if (percentage >= 80) {
                        summaryText = '⚠️ Attention requise';
                        summaryColor = 'var(--accent-gold)';
                        recommendations = `
                            <ul style="font-size: 0.8rem; color: var(--text-secondary); line-height: 1.5; padding-left: 1.25rem; margin: 0;">
                                <li>Exportez régulièrement votre projet</li>
                                <li>Surveillez l'évolution de votre utilisation</li>
                                <li>Nettoyez les versions inutilisées</li>
                            </ul>
                        `;
                    } else {
                        summaryText = '✅ Espace suffisant';
                        summaryColor = 'var(--accent-green)';
                        recommendations = `
                            <ul style="font-size: 0.8rem; color: var(--text-secondary); line-height: 1.5; padding-left: 1.25rem; margin: 0;">
                                <li>Continuez à exporter régulièrement</li>
                                <li>Votre projet est dans la limite normale</li>
                                <li>IndexedDB : ${formatBytes(quota)} disponibles</li>
                            </ul>
                        `;
                    }
                    
                    recommendationsSummary.textContent = summaryText;
                    recommendationsSummary.style.color = summaryColor;
                    recommendationsContainer.innerHTML = recommendations;
                }
                
                // Show modal using Plume's modal system
                const modal = document.getElementById('storage-modal');
                if (modal) {
                    modal.classList.add('active');
                } else {
                    console.error('Modal storage-modal not found!');
                }
            } catch (error) {
                console.error('❌ Erreur affichage détails stockage:', error);
            }
        }

        function handleStorageError() {
            alert(
                '🚨 ERREUR DE SAUVEGARDE\n\n' +
                'Impossible de sauvegarder : espace de stockage insuffisant.\n\n' +
                'Actions à faire MAINTENANT :\n' +
                '1. Exportez votre projet en JSON\n' +
                '2. Supprimez des versions anciennes\n' +
                '3. Libérez de l\'espace\n\n' +
                'Sans cela, vos modifications récentes seront perdues !'
            );
            showStorageDetails();
        }

        // Avertir avant de quitter si l'espace est critique
        window.addEventListener('beforeunload', async function(e) {
            try {
                const { used, quota } = await getStorageSize();
                const percentage = (used / quota) * 100;
                
                if (percentage >= 95) {
                    e.preventDefault();
                    e.returnValue = 'ATTENTION : Votre espace de stockage est presque plein. Pensez à exporter votre projet !';
                    return e.returnValue;
                }
            } catch (error) {
                console.error('❌ Erreur vérification avant fermeture:', error);
            }
        });

        // ============================================
        // END STORAGE QUOTA MONITORING FUNCTIONS
        // ============================================

// ========== 42.mobile-swipe.js ==========
        // ============================================
        // MOBILE SWIPE GESTURE SUPPORT
        // ============================================
        
        let touchStartX = 0;
        let touchStartY = 0;
        let touchEndX = 0;
        let touchEndY = 0;
        
        // Détecter le swipe depuis le bord gauche
        document.addEventListener('touchstart', function(e) {
            touchStartX = e.changedTouches[0].screenX;
            touchStartY = e.changedTouches[0].screenY;
        }, false);
        
        document.addEventListener('touchend', function(e) {
            touchEndX = e.changedTouches[0].screenX;
            touchEndY = e.changedTouches[0].screenY;
            handleSwipe();
        }, false);
        
        function handleSwipe() {
            const diffX = touchEndX - touchStartX;
            const diffY = touchEndY - touchStartY;
            
            // Vérifier que c'est un swipe horizontal (pas vertical)
            if (Math.abs(diffX) > Math.abs(diffY)) {
                // Swipe depuis le bord gauche (moins de 50px du bord)
                if (touchStartX < 50 && diffX > 50) {
                    // Swipe vers la droite depuis le bord gauche
                    const sidebar = document.querySelector('.sidebar');
                    if (sidebar && !sidebar.classList.contains('mobile-open')) {
                        toggleMobileSidebar();
                    }
                }
                // Swipe vers la gauche pour fermer
                else if (diffX < -50) {
                    const sidebar = document.querySelector('.sidebar');
                    if (sidebar && sidebar.classList.contains('mobile-open')) {
                        toggleMobileSidebar();
                    }
                }
            }
        }
        
        // ============================================
        // END MOBILE SWIPE GESTURE SUPPORT
        // ============================================

// ========== 43.arcs.js ==========
// ============================================
        // ============================================
        // ARCS NARRATIFS - INLINE EDITING VERSION
        // ============================================

        // Arc types avec leurs propriétés
        const ARC_TYPES = {
            character: { icon: 'user', label: 'Personnage', color: '#3498db' },
            plot: { icon: 'book-open', label: 'Intrigue', color: '#e74c3c' },
            theme: { icon: 'message-circle', label: 'Thème', color: '#9b59b6' },
            subplot: { icon: 'file-text', label: 'Intrigue secondaire', color: '#16a085' },
            relationship: { icon: 'heart', label: 'Relation', color: '#e91e63' },
            mystery: { icon: 'search', label: 'Mystère', color: '#607d8b' },
            conflict: { icon: 'swords', label: 'Conflit', color: '#ff5722' },
            growth: { icon: 'sprout', label: 'Croissance', color: '#4caf50' },
            redemption: { icon: 'sparkles', label: 'Rédemption', color: '#ffd700' },
            vengeance: { icon: 'flame', label: 'Vengeance', color: '#d32f2f' },
            quest: { icon: 'map', label: 'Quête', color: '#ff9800' },
            discovery: { icon: 'telescope', label: 'Découverte', color: '#00bcd4' },
            transformation: { icon: 'butterfly', label: 'Transformation', color: '#ab47bc' },
            political: { icon: 'crown', label: 'Politique', color: '#795548' },
            philosophical: { icon: 'brain', label: 'Philosophique', color: '#546e7a' },
            comedic: { icon: 'smile', label: 'Comédie', color: '#ffeb3b' },
            tragic: { icon: 'frown', label: 'Tragédie', color: '#424242' },
            action: { icon: 'zap', label: 'Action', color: '#ff6f00' },
            universe: { icon: 'globe', label: 'Univers', color: '#1976d2' },
            linked_characters: { icon: 'users', label: 'Personnages liés', color: '#8e24aa' }
        };
        
        // Helper function to render arc type icon
        function renderArcTypeIcon(iconName, color = null) {
            const colorStyle = color ? `style="color: ${color}"` : '';
            return `<i data-lucide="${iconName}" class="arc-lucide-icon" ${colorStyle}></i>`;
        }

        // Initialize narrative arcs if not exists
        function initNarrativeArcs() {
            if (!project.narrativeArcs) {
                project.narrativeArcs = [];
            }
        }

        // ============================================
        // SIDEBAR FUNCTIONS
        // ============================================

        function renderArcsList() {
            const list = document.getElementById('arcsList');
            if (!list) return;

            initNarrativeArcs();
            const arcs = project.narrativeArcs || [];

            if (arcs.length === 0) {
                list.innerHTML = `
                    <div class="sidebar-empty">
                        <div class="sidebar-empty-icon"><i data-lucide="drama"></i></div>
                        <p>Aucun arc narratif</p>
                    </div>
                `;
                if (typeof lucide !== 'undefined') lucide.createIcons();
                return;
            }

            // Group by importance
            const majorArcs = arcs.filter(a => a.importance === 'major');
            const minorArcs = arcs.filter(a => a.importance === 'minor');

            let html = '';

            if (majorArcs.length > 0) {
                html += '<div class="sidebar-group-title">Arcs Majeurs</div>';
                html += majorArcs.map(arc => {
                    const typeData = ARC_TYPES[arc.type] || ARC_TYPES.plot;
                    const sceneCount = arc.scenePresence ? arc.scenePresence.length : 0;
                    return `
                        <div class="sidebar-item" onclick="openArcDetail('${arc.id}')" data-arc-id="${arc.id}">
                            <div class="sidebar-item-header">
                                <span class="sidebar-item-icon" style="color: ${arc.color}"><i data-lucide="${typeData.icon}"></i></span>
                                <span class="sidebar-item-title">${arc.title}</span>
                            </div>
                            <div class="sidebar-item-meta">
                                <span>${sceneCount} scène${sceneCount > 1 ? 's' : ''}</span>
                            </div>
                        </div>
                    `;
                }).join('');
            }

            if (minorArcs.length > 0) {
                html += '<div class="sidebar-group-title">Arcs Mineurs</div>';
                html += minorArcs.map(arc => {
                    const typeData = ARC_TYPES[arc.type] || ARC_TYPES.plot;
                    const sceneCount = arc.scenePresence ? arc.scenePresence.length : 0;
                    return `
                        <div class="sidebar-item" onclick="openArcDetail('${arc.id}')" data-arc-id="${arc.id}">
                            <div class="sidebar-item-header">
                                <span class="sidebar-item-icon" style="color: ${arc.color}"><i data-lucide="${typeData.icon}"></i></span>
                                <span class="sidebar-item-title">${arc.title}</span>
                            </div>
                            <div class="sidebar-item-meta">
                                <span>${sceneCount} scène${sceneCount > 1 ? 's' : ''}</span>
                            </div>
                        </div>
                    `;
                }).join('');
            }

            list.innerHTML = html;
            
            // Initialize Lucide icons for the new content
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
        }

        function renderArcsWelcome() {
            const view = document.getElementById('editorView');
            if (!view) return;

            initNarrativeArcs();
            const arcs = project.narrativeArcs || [];

            if (arcs.length === 0) {
                view.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon"><i data-lucide="drama"></i></div>
                        <div class="empty-state-title">Gérez vos arcs narratifs</div>
                        <div class="empty-state-text">
                            Les arcs narratifs vous permettent de suivre l'évolution de vos personnages,<br>
                            intrigues et thèmes à travers votre roman.
                        </div>
                        <button class="btn btn-primary" onclick="createNewArc()">
                            <i data-lucide="sparkles"></i> Créer votre premier arc
                        </button>
                    </div>
                `;
                if (typeof lucide !== 'undefined') lucide.createIcons();
                return;
            }

            view.innerHTML = `
                <div class="empty-state">
                    <div class="empty-state-icon"><i data-lucide="drama"></i></div>
                    <div class="empty-state-title">Sélectionnez un arc</div>
                    <div class="empty-state-text">
                        Choisissez un arc dans la barre latérale pour voir ses détails<br>
                        et sa progression à travers votre roman.
                    </div>
                </div>
            `;
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }

        // ============================================
        // ARC DETAIL VIEW
        // ============================================

        function openArcDetail(arcId) {
            // Passer directement en mode édition quand on clique sur un arc
            const arc = project.narrativeArcs.find(a => a.id === arcId);
            if (!arc) return;
            renderArcEditor(arc, false);
        }

        // ============================================
        // INLINE EDITOR
        // ============================================

        function createNewArc() {
            const newArc = {
                id: 'arc_' + Date.now(),
                title: '',
                type: 'character',
                color: ARC_TYPES.character.color,
                description: '',
                relatedCharacters: [],
                importance: 'major',
                resolution: { type: 'ongoing', sceneId: null },
                scenePresence: [],
                created: new Date().toISOString().split('T')[0],
                updated: new Date().toISOString().split('T')[0]
            };

            renderArcEditor(newArc, true);
        }

        function renderArcEditor(arc, isNew = false) {
            const view = document.getElementById('editorView');
            if (!view) return;

            const typeData = ARC_TYPES[arc.type] || ARC_TYPES.character;

            // Get character options
            const characterOptions = project.characters && project.characters.length > 0
                ? project.characters.map(char => {
                    const selected = arc.relatedCharacters.includes(char.id) ? 'selected' : '';
                    return `<option value="${char.id}" ${selected}>${char.name}</option>`;
                  }).join('')
                : '<option disabled>Aucun personnage créé</option>';

            const arcTypesHTML = Object.entries(ARC_TYPES).map(([key, data]) => {
                const selected = arc.type === key ? 'selected' : '';
                return `
                    <div class="arc-type-card ${selected}" data-type="${key}" onclick="selectArcTypeInEditor('${key}')">
                        <span class="arc-type-icon"><i data-lucide="${data.icon}"></i></span>
                        <span class="arc-type-label">${data.label}</span>
                    </div>
                `;
            }).join('');

            view.innerHTML = `
                <div class="arc-editor-view">
                    <div class="arc-editor-header">
                        <h2><i data-lucide="${isNew ? 'sparkles' : 'pencil'}"></i> ${isNew ? 'Créer un arc narratif' : 'Modifier l\'arc'}</h2>
                        <div class="arc-editor-actions-header">
                            <button class="btn-secondary" onclick="cancelArcEdit()">Annuler</button>
                            <button class="btn-primary" onclick="saveArcFromEditor(${isNew})">
                                <i data-lucide="${isNew ? 'sparkles' : 'save'}"></i> ${isNew ? 'Créer' : 'Enregistrer'}
                            </button>
                        </div>
                    </div>

                    <div class="arc-editor-form">
                        <div class="arc-editor-section">
                            <h3><i data-lucide="pin"></i> Informations de base</h3>

                            <div class="form-group">
                                <label>Titre de l'arc *</label>
                                <input type="text" id="arcTitleInput" class="form-input" 
                                    value="${arc.title}" placeholder="Ex: La vengeance de Kaito">
                            </div>

                            <div class="form-group">
                                <label>Description</label>
                                <textarea id="arcDescriptionInput" class="form-textarea" 
                                    placeholder="Décrivez l'arc narratif...">${arc.description}</textarea>
                            </div>

                            <div class="form-row">
                                <div class="form-group">
                                    <label>Couleur de l'arc</label>
                                    <div class="color-picker-group">
                                        <input type="color" id="arcColorPicker" value="${arc.color}" 
                                            onchange="document.getElementById('arcColorText').value = this.value">
                                        <input type="text" id="arcColorText" class="form-input-small" 
                                            value="${arc.color}" 
                                            onchange="document.getElementById('arcColorPicker').value = this.value">
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="arc-editor-section">
                            <h3><i data-lucide="drama"></i> Type d'arc narratif *</h3>
                            <div class="arc-types-grid">
                                ${arcTypesHTML}
                            </div>
                        </div>

                        <div class="arc-editor-section">
                            <h3><i data-lucide="users"></i> Personnages liés</h3>
                            <select id="arcCharactersSelect" class="form-select" multiple size="5">
                                ${characterOptions}
                            </select>
                            <p class="form-help">Maintenez Ctrl (ou Cmd) pour sélectionner plusieurs personnages</p>
                        </div>

                        <div class="arc-editor-section">
                            <h3><i data-lucide="scale"></i> Importance & Résolution</h3>

                            <div class="form-row">
                                <div class="form-group">
                                    <label>Importance</label>
                                    <select id="arcImportanceSelect" class="form-select">
                                        <option value="major" ${arc.importance === 'major' ? 'selected' : ''}>Majeur</option>
                                        <option value="minor" ${arc.importance === 'minor' ? 'selected' : ''}>Mineur</option>
                                    </select>
                                </div>

                                <div class="form-group">
                                    <label>Statut de résolution</label>
                                    <select id="arcResolutionSelect" class="form-select">
                                        <option value="ongoing" ${arc.resolution.type === 'ongoing' ? 'selected' : ''}>En cours</option>
                                        <option value="resolved" ${arc.resolution.type === 'resolved' ? 'selected' : ''}>Résolu</option>
                                        <option value="abandoned" ${arc.resolution.type === 'abandoned' ? 'selected' : ''}>Abandonné</option>
                                    </select>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;

            // Store current arc in global var
            window.currentEditingArc = arc;
            window.currentEditingArcIsNew = isNew;
            
            // Initialize Lucide icons for the new content
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
        }

        function selectArcTypeInEditor(type) {
            // Update UI
            document.querySelectorAll('.arc-type-card').forEach(card => {
                card.classList.remove('selected');
            });
            const selected = document.querySelector(`[data-type="${type}"]`);
            if (selected) selected.classList.add('selected');

            // Update color
            const typeData = ARC_TYPES[type];
            if (typeData) {
                document.getElementById('arcColorPicker').value = typeData.color;
                document.getElementById('arcColorText').value = typeData.color;
            }

            // Update global var
            window.currentEditingArc.type = type;
        }

        function saveArcFromEditor(isNew) {
            const arc = window.currentEditingArc;
            if (!arc) return;

            // Get values from form
            arc.title = document.getElementById('arcTitleInput').value.trim();
            arc.description = document.getElementById('arcDescriptionInput').value.trim();
            arc.color = document.getElementById('arcColorPicker').value;
            arc.importance = document.getElementById('arcImportanceSelect').value;
            arc.resolution.type = document.getElementById('arcResolutionSelect').value;

            // Get selected characters
            const select = document.getElementById('arcCharactersSelect');
            arc.relatedCharacters = Array.from(select.selectedOptions).map(opt => opt.value);

            // Validation
            if (!arc.title) {
                alert('Veuillez entrer un titre pour l\'arc');
                document.getElementById('arcTitleInput').focus();
                return;
            }

            // Save
            if (isNew) {
                project.narrativeArcs.push(arc);
            } else {
                const index = project.narrativeArcs.findIndex(a => a.id === arc.id);
                if (index !== -1) {
                    project.narrativeArcs[index] = arc;
                }
            }

            arc.updated = new Date().toISOString().split('T')[0];
            saveProject();

            // Refresh sidebar and show detail
            renderArcsList();
            openArcDetail(arc.id);
        }

        function editArcInline(arcId) {
            const arc = project.narrativeArcs.find(a => a.id === arcId);
            if (!arc) return;
            renderArcEditor(arc, false);
        }

        function cancelArcEdit() {
            const arcs = project.narrativeArcs || [];
            if (arcs.length > 0) {
                renderArcsWelcome();
                renderArcsList();
            } else {
                renderArcsWelcome();
            }
        }

        // ============================================
        // DELETE ARC
        // ============================================

        function deleteNarrativeArc(arcId) {
            const arc = project.narrativeArcs.find(a => a.id === arcId);
            if (!arc) return;

            if (!confirm(`Voulez-vous vraiment supprimer l'arc "${arc.title}" ?\n\nCette action est irréversible.`)) {
                return;
            }

            project.narrativeArcs = project.narrativeArcs.filter(a => a.id !== arcId);
            saveProject();

            renderArcsList();
            renderArcsWelcome();
        }

        // ============================================
        // SCENE PANEL (For editing arcs in a scene)
        // ============================================

        function toggleArcScenePanel() {
            const panel = document.getElementById('arcScenePanel');
            if (!panel) return;

            panel.classList.toggle('hidden');
            if (!panel.classList.contains('hidden')) {
                renderArcScenePanel();
            }
        }

        function renderArcScenePanel() {
            if (!currentScene) return;

            const content = document.getElementById('arcScenePanelContent');
            if (!content) return;

            initNarrativeArcs();
            const arcs = project.narrativeArcs || [];

            // Get arcs present in this scene
            const arcsInScene = arcs.filter(arc => 
                arc.scenePresence && arc.scenePresence.some(p => p.sceneId === currentScene.id)
            );

            if (arcsInScene.length === 0 && arcs.length === 0) {
                content.innerHTML = `
                    <div class="arc-panel-empty">
                        <div class="arc-panel-empty-icon"><i data-lucide="drama"></i></div>
                        <p>Aucun arc narratif créé</p>
                    </div>
                `;
                if (typeof lucide !== 'undefined') lucide.createIcons();
                return;
            }

            let html = `
                <div class="arc-scene-info">
                    <div class="arc-scene-info-title">Scène actuelle</div>
                    <div>${currentScene.title}</div>
                </div>
            `;

            // Show arcs in scene
            if (arcsInScene.length > 0) {
                arcsInScene.forEach(arc => {
                    const presence = arc.scenePresence.find(p => p.sceneId === currentScene.id);
                    if (!presence) return;

                    const typeData = ARC_TYPES[arc.type] || ARC_TYPES.plot;

                    html += `
                        <div class="arc-in-scene" data-arc-id="${arc.id}">
                            <div class="arc-in-scene-header">
                                <div class="arc-in-scene-title">
                                    <span style="color: ${arc.color}"><i data-lucide="${typeData.icon}"></i></span> ${arc.title}
                                </div>
                                <button class="arc-in-scene-remove" onclick="removeArcFromScene('${arc.id}')" title="Retirer">×</button>
                            </div>

                            <div class="arc-in-scene-control">
                                <label class="arc-in-scene-label">Intensité</label>
                                <input type="range" min="1" max="5" value="${presence.intensity}" 
                                    class="arc-intensity-slider" 
                                    oninput="updateArcIntensity('${arc.id}', this.value)">
                                <div class="arc-intensity-value">${presence.intensity}/5</div>
                            </div>

                            <div class="arc-in-scene-control">
                                <label class="arc-in-scene-label">Statut</label>
                                <select class="arc-status-select" onchange="updateArcStatus('${arc.id}', this.value)">
                                    <option value="setup" ${presence.status === 'setup' ? 'selected' : ''}>Introduction</option>
                                    <option value="development" ${presence.status === 'development' ? 'selected' : ''}>Développement</option>
                                    <option value="climax" ${presence.status === 'climax' ? 'selected' : ''}>Point culminant</option>
                                    <option value="resolution" ${presence.status === 'resolution' ? 'selected' : ''}>Résolution</option>
                                </select>
                            </div>

                            <div class="arc-in-scene-control">
                                <label class="arc-in-scene-label">Notes</label>
                                <textarea class="arc-notes-textarea" 
                                    placeholder="Notes pour cette scène..."
                                    onblur="updateArcNotes('${arc.id}', this.value)">${presence.notes || ''}</textarea>
                            </div>
                        </div>
                    `;
                });
            }

            // Add arc button
            const availableArcs = arcs.filter(arc => !arcsInScene.includes(arc));
            if (availableArcs.length > 0) {
                html += `
                    <select id="arcToAddSelect" class="arc-panel-add-select">
                        <option value="">-- Ajouter un arc --</option>
                        ${availableArcs.map(arc => {
                            const typeData = ARC_TYPES[arc.type] || ARC_TYPES.plot;
                            return `<option value="${arc.id}">${typeData.label} - ${arc.title}</option>`;
                        }).join('')}
                    </select>
                    <button class="arc-panel-add-btn" onclick="addArcToCurrentScene()">+ Ajouter l'arc</button>
                `;
            }

            content.innerHTML = html;
            
            // Initialize Lucide icons for the new content
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
        }

        function addArcToCurrentScene() {
            const select = document.getElementById('arcToAddSelect');
            if (!select) return;

            const arcId = select.value;
            if (!arcId) return;

            const arc = project.narrativeArcs.find(a => a.id === arcId);
            if (!arc || !currentScene) return;

            if (!arc.scenePresence) arc.scenePresence = [];

            arc.scenePresence.push({
                actId: currentAct.id,
                chapterId: currentChapter.id,
                sceneId: currentScene.id,
                intensity: 3,
                notes: '',
                status: 'development'
            });

            saveProject();
            renderArcScenePanel();
        }

        function removeArcFromScene(arcId) {
            const arc = project.narrativeArcs.find(a => a.id === arcId);
            if (!arc || !currentScene) return;

            arc.scenePresence = arc.scenePresence.filter(p => p.sceneId !== currentScene.id);
            saveProject();
            renderArcScenePanel();
        }

        function updateArcIntensity(arcId, intensity) {
            const arc = project.narrativeArcs.find(a => a.id === arcId);
            if (!arc || !currentScene) return;

            const presence = arc.scenePresence.find(p => p.sceneId === currentScene.id);
            if (presence) {
                presence.intensity = parseInt(intensity);

                // Update display
                const arcDiv = document.querySelector(`[data-arc-id="${arcId}"]`);
                if (arcDiv) {
                    const valueDiv = arcDiv.querySelector('.arc-intensity-value');
                    if (valueDiv) valueDiv.textContent = `${intensity}/5`;
                }

                saveProject();
            }
        }

        function updateArcStatus(arcId, status) {
            const arc = project.narrativeArcs.find(a => a.id === arcId);
            if (!arc || !currentScene) return;

            const presence = arc.scenePresence.find(p => p.sceneId === currentScene.id);
            if (presence) {
                presence.status = status;
                saveProject();
            }
        }

        function updateArcNotes(arcId, notes) {
            const arc = project.narrativeArcs.find(a => a.id === arcId);
            if (!arc || !currentScene) return;

            const presence = arc.scenePresence.find(p => p.sceneId === currentScene.id);
            if (presence) {
                presence.notes = notes;
                saveProject();
            }
        }

        init();
        themeManager.init();
        
        // Initialize Lucide icons
        if (typeof lucide !== 'undefined') {
            lucide.createIcons();
        }



// ========== 44.storygrid.js ==========
// ============================================
// Module: views/storygrid
// Story Grid - Tableau de bord narratif
// ============================================

// ============================================
// CONSTANTS & CONFIGURATION
// ============================================

const STORYGRID_ROW_TYPES = {
    character: { 
        icon: 'user', 
        label: 'Personnage', 
        defaultColor: '#3498db',
        source: 'characters'
    },
    arc: { 
        icon: 'drama', 
        label: 'Arc narratif', 
        defaultColor: '#e74c3c',
        source: 'narrativeArcs'
    },
    location: { 
        icon: 'map-pin', 
        label: 'Lieu', 
        defaultColor: '#27ae60',
        source: 'world'
    },
    theme: { 
        icon: 'lightbulb', 
        label: 'Thème / Motif', 
        defaultColor: '#9b59b6',
        source: 'custom'
    },
    structure: { 
        icon: 'layout', 
        label: 'Structure narrative', 
        defaultColor: '#f39c12',
        source: 'custom'
    },
    custom: { 
        icon: 'tag', 
        label: 'Personnalisé', 
        defaultColor: '#95a5a6',
        source: 'custom'
    }
};

const STORYGRID_ZOOM_LEVELS = {
    ultra: { 
        name: 'Scènes',
        unit: 'scene',
        label: 'Scènes',
        minWidth: 160
    },
    micro: { 
        name: 'Chapitres',
        unit: 'chapter',
        label: 'Chapitres',
        minWidth: 200
    },
    macro: { 
        name: 'Actes',
        unit: 'act',
        label: 'Actes',
        minWidth: 220
    }
};

const CARD_STATUSES = {
    draft: { label: 'Brouillon', color: '#95a5a6', icon: 'file' },
    inProgress: { label: 'En cours', color: '#f39c12', icon: 'edit-3' },
    review: { label: 'A réviser', color: '#3498db', icon: 'eye' },
    done: { label: 'Finalisé', color: '#27ae60', icon: 'check-circle' }
};

// ============================================
// STATE MANAGEMENT
// ============================================

let storyGridState = {
    rows: [],
    zoomLevel: 'ultra',
    columnWidth: 160,
    viewMode: 'chronological', // chronological, character, arc, location, structure
    filters: {
        rowTypes: Object.keys(STORYGRID_ROW_TYPES),
        showHiddenRows: false
    },
    dragState: null,
    panState: {
        isPanning: false,
        startX: 0,
        scrollLeft: 0
    },
    selectedCard: null,
    hoveredCardId: null, // Pour la surbrillance des cards jumelles
    links: [] // Links between cards
};

// ============================================
// INITIALIZATION
// ============================================

// Fonction closeModal pour toutes les modales
// Supprime du DOM uniquement les modales dynamiques (créées par JS avec data-dynamic="true")
function closeModal(modalId) {
    const modal = document.getElementById(modalId);
    if (modal) {
        modal.classList.remove('active');
        // Supprimer du DOM uniquement si c'est une modale dynamique
        if (modal.dataset.dynamic === 'true') {
            setTimeout(() => {
                if (modal.parentNode) {
                    modal.parentNode.removeChild(modal);
                }
            }, 200);
        }
    }
}

function initStoryGrid() {
    // Initialize story grid data in project if not exists
    if (!project.storyGrid) {
        project.storyGrid = {
            rows: [],
            links: [],
            settings: {
                defaultZoom: 'micro',
                showEmptyCells: true,
                snapToGrid: true
            }
        };
    }
    
    // Load rows from project
    storyGridState.rows = project.storyGrid.rows || [];
    storyGridState.links = project.storyGrid.links || [];
    
    // Migrate old cards to new hierarchical system
    migrateOldCards();
    
    // Auto-create rows from existing data if none exist
    if (storyGridState.rows.length === 0) {
        autoCreateRowsFromProject();
    }
}

function migrateOldCards() {
    // Migrate cards that only have columnId to the new hierarchical system
    // AND add new multi-link fields (characters, arcs, locations)
    let needsSave = false;
    
    storyGridState.rows.forEach(row => {
        row.cards.forEach(card => {
            // Migration des nouveaux champs de liaison multiple
            if (!card.characters) {
                card.characters = [];
                needsSave = true;
            }
            if (!card.arcs) {
                card.arcs = [];
                needsSave = true;
            }
            if (!card.locations) {
                card.locations = [];
                needsSave = true;
            }
            
            // If card doesn't have actId/chapterId, try to extract from columnId
            if (card.columnId && (!card.actId || !card.chapterId)) {
                const columnIdParts = card.columnId.split('_');
                
                if (columnIdParts[0] === 'col' && columnIdParts[1]) {
                    const type = columnIdParts[1]; // 'act', 'chapter', or 'scene'
                    const id = columnIdParts[2];
                    
                    // Find the corresponding structural element
                    for (const act of project.acts || []) {
                        if (type === 'act' && act.id === id) {
                            card.actId = act.id;
                            needsSave = true;
                        }
                        
                        for (const chapter of act.chapters || []) {
                            if (type === 'chapter' && chapter.id === id) {
                                card.actId = act.id;
                                card.chapterId = chapter.id;
                                needsSave = true;
                            }
                            
                            for (const scene of chapter.scenes || []) {
                                if (type === 'scene' && scene.id === id) {
                                    card.actId = act.id;
                                    card.chapterId = chapter.id;
                                    card.sceneId = scene.id;
                                    needsSave = true;
                                }
                            }
                        }
                    }
                }
            }
        });
    });
    
    if (needsSave) {
        saveStoryGridData();
    }
}

function autoCreateRowsFromProject() {
    // Auto-create character rows
    if (project.characters && project.characters.length > 0) {
        project.characters.forEach((char, index) => {
            storyGridState.rows.push({
                id: 'row_char_' + char.id,
                type: 'character',
                sourceId: char.id,
                title: char.name,
                color: char.color || STORYGRID_ROW_TYPES.character.defaultColor,
                order: index,
                visible: true,
                cards: []
            });
        });
    }
    
    // Auto-create arc rows
    if (project.narrativeArcs && project.narrativeArcs.length > 0) {
        project.narrativeArcs.forEach((arc, index) => {
            storyGridState.rows.push({
                id: 'row_arc_' + arc.id,
                type: 'arc',
                sourceId: arc.id,
                title: arc.title,
                color: arc.color || STORYGRID_ROW_TYPES.arc.defaultColor,
                order: storyGridState.rows.length + index,
                visible: true,
                cards: []
            });
        });
    }
    
    // Auto-create location rows from world elements
    if (project.world && project.world.length > 0) {
        const locations = project.world.filter(w => w.type === 'location' || w.type === 'Lieu');
        locations.forEach((loc, index) => {
            storyGridState.rows.push({
                id: 'row_loc_' + loc.id,
                type: 'location',
                sourceId: loc.id,
                title: loc.name,
                color: loc.color || STORYGRID_ROW_TYPES.location.defaultColor,
                order: storyGridState.rows.length + index,
                visible: true,
                cards: []
            });
        });
    }
    
    // Add default structure row
    storyGridState.rows.push({
        id: 'row_struct_default',
        type: 'structure',
        sourceId: null,
        title: 'Structure narrative',
        color: STORYGRID_ROW_TYPES.structure.defaultColor,
        order: storyGridState.rows.length,
        visible: true,
        cards: []
    });
    
    saveStoryGridData();
}

function saveStoryGridData() {
    project.storyGrid = {
        rows: storyGridState.rows,
        links: storyGridState.links,
        settings: project.storyGrid?.settings || {
            defaultZoom: 'micro',
            showEmptyCells: true,
            snapToGrid: true
        }
    };
    saveProject();
}

// ============================================
// COLUMN (TIMELINE) MANAGEMENT
// ============================================

function getTimelineColumns() {
    const columns = [];
    const zoom = STORYGRID_ZOOM_LEVELS[storyGridState.zoomLevel];
    
    if (!project.acts || project.acts.length === 0) {
        return [{
            id: 'empty',
            type: 'placeholder',
            title: 'Aucun contenu',
            items: []
        }];
    }
    
    switch (zoom.unit) {
        case 'act':
            project.acts.forEach((act, actIndex) => {
                columns.push({
                    id: 'col_act_' + act.id,
                    type: 'act',
                    actId: act.id,
                    title: act.title,
                    order: actIndex,
                    items: getAllScenesFromAct(act)
                });
            });
            break;
            
        case 'chapter':
            project.acts.forEach((act, actIndex) => {
                if (act.chapters) {
                    act.chapters.forEach((chapter, chapterIndex) => {
                        columns.push({
                            id: 'col_chapter_' + chapter.id,
                            type: 'chapter',
                            actId: act.id,
                            chapterId: chapter.id,
                            title: chapter.title,
                            actTitle: act.title,
                            order: actIndex * 1000 + chapterIndex,
                            items: chapter.scenes || []
                        });
                    });
                }
            });
            break;
            
        case 'scene':
            project.acts.forEach((act, actIndex) => {
                if (act.chapters) {
                    act.chapters.forEach((chapter, chapterIndex) => {
                        if (chapter.scenes) {
                            chapter.scenes.forEach((scene, sceneIndex) => {
                                columns.push({
                                    id: 'col_scene_' + scene.id,
                                    type: 'scene',
                                    actId: act.id,
                                    chapterId: chapter.id,
                                    sceneId: scene.id,
                                    title: scene.title,
                                    chapterTitle: chapter.title,
                                    actTitle: act.title,
                                    order: actIndex * 100000 + chapterIndex * 1000 + sceneIndex,
                                    items: [scene]
                                });
                            });
                        }
                    });
                }
            });
            break;
    }
    
    return columns.sort((a, b) => a.order - b.order);
}

function getAllScenesFromAct(act) {
    const scenes = [];
    if (act.chapters) {
        act.chapters.forEach(chapter => {
            if (chapter.scenes) {
                scenes.push(...chapter.scenes);
            }
        });
    }
    return scenes;
}

// ============================================
// ROW MANAGEMENT
// ============================================

function addStoryGridRow(type, options = {}) {
    const typeData = STORYGRID_ROW_TYPES[type];
    if (!typeData) return null;
    
    const newRow = {
        id: 'row_' + Date.now(),
        type: type,
        sourceId: options.sourceId || null,
        title: options.title || `Nouveau ${typeData.label}`,
        color: options.color || typeData.defaultColor,
        order: storyGridState.rows.length,
        visible: true,
        cards: []
    };
    
    storyGridState.rows.push(newRow);
    saveStoryGridData();
    renderStoryGrid();
    
    return newRow;
}

function deleteStoryGridRow(rowId) {
    const index = storyGridState.rows.findIndex(r => r.id === rowId);
    if (index === -1) return;
    
    // Also remove any links involving cards from this row
    const rowCards = storyGridState.rows[index].cards.map(c => c.id);
    storyGridState.links = storyGridState.links.filter(link => 
        !rowCards.includes(link.fromCard) && !rowCards.includes(link.toCard)
    );
    
    storyGridState.rows.splice(index, 1);
    
    // Reorder remaining rows
    storyGridState.rows.forEach((row, idx) => {
        row.order = idx;
    });
    
    saveStoryGridData();
    renderStoryGrid();
}

function updateStoryGridRow(rowId, updates) {
    const row = storyGridState.rows.find(r => r.id === rowId);
    if (!row) return;
    
    Object.assign(row, updates);
    saveStoryGridData();
    renderStoryGrid();
}

function toggleRowVisibility(rowId) {
    const row = storyGridState.rows.find(r => r.id === rowId);
    if (row) {
        row.visible = !row.visible;
        saveStoryGridData();
        renderStoryGrid();
    }
}

function reorderRows(fromIndex, toIndex) {
    const [removed] = storyGridState.rows.splice(fromIndex, 1);
    storyGridState.rows.splice(toIndex, 0, removed);
    
    storyGridState.rows.forEach((row, idx) => {
        row.order = idx;
    });
    
    saveStoryGridData();
    renderStoryGrid();
}

// ============================================
// CARD MANAGEMENT
// ============================================

function addCardToGrid(rowId, columnId, sceneData = null) {
    const row = storyGridState.rows.find(r => r.id === rowId);
    if (!row) return null;
    
    // Extract hierarchical references from column
    const column = getColumnFromId(columnId);
    if (!column) return null;
    
    const card = {
        id: 'card_' + Date.now(),
        rowId: rowId,
        columnId: columnId, // Keep for backward compatibility
        // Store hierarchical references for dynamic column matching
        actId: column.actId || null,
        chapterId: column.chapterId || null,
        sceneId: sceneData?.id || column.sceneId || null,
        title: sceneData?.title || 'Nouvelle carte',
        summary: sceneData?.summary || '',
        status: 'draft',
        intensity: 3, // 1-5
        objective: '',
        conflict: '',
        pov: '',
        notes: '',
        color: null, // Uses row color if null
        order: row.cards.filter(c => matchesColumn(c, column)).length,
        // Nouveaux champs pour liaisons multiples
        characters: [],
        arcs: [],
        locations: []
    };
    
    // Auto-liaison ÃƒÂ  la ligne de création
    autoLinkCardToRow(card, row);
    
    row.cards.push(card);
    saveStoryGridData();
    renderStoryGrid();
    
    return card;
}

// Auto-liaison d'une card ÃƒÂ  une ligne selon son type
function autoLinkCardToRow(card, row) {
    if (!row.sourceId) return;
    
    switch (row.type) {
        case 'character':
            if (!card.characters.includes(row.sourceId)) {
                card.characters.push(row.sourceId);
            }
            break;
        case 'arc':
            if (!card.arcs.includes(row.sourceId)) {
                card.arcs.push(row.sourceId);
            }
            break;
        case 'location':
            if (!card.locations.includes(row.sourceId)) {
                card.locations.push(row.sourceId);
            }
            break;
    }
}

function getColumnFromId(columnId) {
    const columns = getTimelineColumns();
    return columns.find(col => col.id === columnId);
}

function matchesColumn(card, column) {
    // Match card to column based on hierarchical structure
    switch (column.type) {
        case 'act':
            // Card matches if it belongs to this act
            return card.actId === column.actId;
        case 'chapter':
            // Card matches if it belongs to this chapter
            return card.chapterId === column.chapterId;
        case 'scene':
            // Card matches if it's specifically for this scene, or if it's in this scene's chapter
            return card.sceneId === column.sceneId || 
                   (card.chapterId === column.chapterId && !card.sceneId);
        default:
            return false;
    }
}

function updateCard(cardId, updates) {
    for (const row of storyGridState.rows) {
        const card = row.cards.find(c => c.id === cardId);
        if (card) {
            Object.assign(card, updates);
            saveStoryGridData();
            renderStoryGrid();
            return;
        }
    }
}

function deleteCard(cardId) {
    for (const row of storyGridState.rows) {
        const index = row.cards.findIndex(c => c.id === cardId);
        if (index !== -1) {
            row.cards.splice(index, 1);
            
            // Remove any links involving this card
            storyGridState.links = storyGridState.links.filter(link =>
                link.fromCard !== cardId && link.toCard !== cardId
            );
            
            saveStoryGridData();
            renderStoryGrid();
            return;
        }
    }
}

function moveCard(cardId, newRowId, newColumnId) {
    // Find and remove card from current location
    let card = null;
    for (const row of storyGridState.rows) {
        const index = row.cards.findIndex(c => c.id === cardId);
        if (index !== -1) {
            card = row.cards.splice(index, 1)[0];
            break;
        }
    }
    
    if (!card) return;
    
    // Add to new location
    const newRow = storyGridState.rows.find(r => r.id === newRowId);
    if (!newRow) return;
    
    // Get new column to extract hierarchical references
    const newColumn = getColumnFromId(newColumnId);
    if (!newColumn) return;
    
    card.rowId = newRowId;
    card.columnId = newColumnId;
    card.actId = newColumn.actId || card.actId;
    card.chapterId = newColumn.chapterId || card.chapterId;
    // Only update sceneId if the new column is a scene column
    if (newColumn.type === 'scene') {
        card.sceneId = newColumn.sceneId;
    }
    card.order = newRow.cards.filter(c => matchesColumn(c, newColumn)).length;
    
    // Auto-liaison ÃƒÂ  la nouvelle ligne
    autoLinkCardToRow(card, newRow);
    
    newRow.cards.push(card);
    saveStoryGridData();
    renderStoryGrid();
}

/**
 * Gère la suppression d'une carte de manière contextuelle.
 * - Si c'est un duplicata, retire uniquement l'association avec la ligne.
 * - Si c'est la carte originale, effectue une suppression complète (avec suppression des liens inter-cartes).
 * @param {string} cardId - L'ID de la carte ÃƒÂ  supprimer.
 * @param {string} displayRowId - L'ID de la ligne sur laquelle le bouton de suppression a été cliqué.
 */
function deleteCardContextual(cardId, displayRowId) {
    const card = findCardById(cardId);
    if (!card) return;

    // Déterminer si la carte est l'originale pour cette ligne.
    const isOriginal = card.rowId === displayRowId;
    
    // Si ce n'est pas la ligne d'origine, c'est un "duplicata" (carte jumelle)
    const isDuplicate = !isOriginal;

    if (isDuplicate) {
        // C'est un duplicata : on retire l'association avec la ligne.
        // La carte originale et les liaisons inter-cartes restent intactes.
        removeCardAssociation(cardId, displayRowId);
    } else {
        // C'est la carte originale : on effectue la suppression complète.
        // C'est ici que l'appel ÃƒÂ  deleteCard(cardId) supprime l'objet carte et toutes ses liaisons.
        deleteCard(cardId); 
    }
}

// ============================================
// FONCTIONS DE LIAISON MULTIPLE (TWINS)
// ============================================

// Recherche globale d'une card par ID
function findCardById(cardId) {
    for (const row of storyGridState.rows) {
        const card = row.cards.find(c => c.id === cardId);
        if (card) return card;
    }
    return null;
}

// Détermine si une card doit apparaÃ®tre sur une ligne donnée
function shouldCardAppearOnRow(card, row) {
    // La card apparaÃ®t toujours sur sa ligne d'origine
    if (card.rowId === row.id) return true;
    
    // Si la ligne n'a pas de sourceId, pas de jumelle
    if (!row.sourceId) return false;
    
    // Vérifier selon le type de ligne
    switch (row.type) {
        case 'character':
            return card.characters && card.characters.includes(row.sourceId);
        case 'arc':
            return card.arcs && card.arcs.includes(row.sourceId);
        case 'location':
            return card.locations && card.locations.includes(row.sourceId);
    }
    return false;
}

// Récupère toutes les cards (originales + jumelles) pour une cellule
function getCardsForCell(row, column) {
    const cards = [];
    
    // Cards directes de cette ligne
    const directCards = row.cards.filter(c => matchesColumn(c, column));
    directCards.forEach(card => {
        cards.push({
            ...card,
            isOriginal: true,
            isTwin: false,
            displayRowId: row.id,
            originalRowId: card.rowId
        });
    });
    
    // Cards jumelles (cards d'autres lignes qui doivent apparaÃ®tre ici)
    storyGridState.rows.forEach(otherRow => {
        if (otherRow.id === row.id) return; // Pas la mÃªme ligne
        
        otherRow.cards.forEach(card => {
            if (matchesColumn(card, column) && shouldCardAppearOnRow(card, row)) {
                // Vérifier qu'on n'a pas déjÃƒÂ  cette card
                if (!cards.find(c => c.id === card.id)) {
                    cards.push({
                        ...card,
                        isOriginal: false,
                        isTwin: true,
                        displayRowId: row.id,
                        originalRowId: card.rowId
                    });
                }
            }
        });
    });
    
    return cards;
}

// Compte le nombre total d'apparitions d'une card (incluant jumelles)
function getCardTwinCount(cardId) {
    const card = findCardById(cardId);
    if (!card) return 1;
    
    let count = 1; // L'originale
    
    storyGridState.rows.forEach(row => {
        if (row.id !== card.rowId && shouldCardAppearOnRow(card, row)) {
            count++;
        }
    });
    
    return count;
}

// Ajouter un personnage à une card
function addCharacterToCard(cardId, characterId) {
    const card = findCardById(cardId);
    if (!card) return;
    
    // Initialiser le tableau si nécessaire
    if (!card.characters) card.characters = [];
    
    if (!card.characters.includes(characterId)) {
        card.characters.push(characterId);
        saveStoryGridData();
        renderStoryGrid();
    }
}

// Retirer un personnage d'une card
function removeCharacterFromCard(cardId, characterId) {
    const card = findCardById(cardId);
    if (!card || !card.characters) return;
    
    const idx = card.characters.indexOf(characterId);
    if (idx !== -1) {
        card.characters.splice(idx, 1);
        saveStoryGridData();
        renderStoryGrid();
    }
}

// Ajouter un arc à une card
function addArcToCard(cardId, arcId) {
    const card = findCardById(cardId);
    if (!card) return;
    
    // Initialiser le tableau si nécessaire
    if (!card.arcs) card.arcs = [];
    
    if (!card.arcs.includes(arcId)) {
        card.arcs.push(arcId);
        saveStoryGridData();
        renderStoryGrid();
    }
}

// Retirer un arc d'une card
function removeArcFromCard(cardId, arcId) {
    const card = findCardById(cardId);
    if (!card || !card.arcs) return;
    
    const idx = card.arcs.indexOf(arcId);
    if (idx !== -1) {
        card.arcs.splice(idx, 1);
        saveStoryGridData();
        renderStoryGrid();
    }
}

// Supprime l'association d'une carte avec la source d'une ligne (ex: enlève un personnage de la carte)
function removeCardAssociation(cardId, rowId) {
    const card = findCardById(cardId);
    const row = storyGridState.rows.find(r => r.id === rowId);

    if (!card || !row || !row.sourceId) return;

    // Détermine le type de la ligne pour savoir quelle liaison retirer (caractère, arc, lieu)
    switch (row.type) {
        case 'character':
            // Utilise la fonction existante pour retirer l'ID de la source de la carte
            removeCharacterFromCard(cardId, row.sourceId);
            break;
        case 'arc':
            // Utilise la fonction existante pour retirer l'ID de la source de la carte
            removeArcFromCard(cardId, row.sourceId);
            break;
        case 'location':
            // Utilise la fonction existante pour retirer l'ID de la source de la carte
            removeLocationFromCard(cardId, row.sourceId);
            break;
        default:
            // Pour les types sans sourceId, il ne devrait pas y avoir de carte jumelle.
            return;
    }
}

// Ajouter un lieu à une card
function addLocationToCard(cardId, locationId) {
    const card = findCardById(cardId);
    if (!card) return;
    
    // Initialiser le tableau si nécessaire
    if (!card.locations) card.locations = [];
    
    if (!card.locations.includes(locationId)) {
        card.locations.push(locationId);
        saveStoryGridData();
        renderStoryGrid();
    }
}

// Retirer un lieu d'une card
function removeLocationFromCard(cardId, locationId) {
    const card = findCardById(cardId);
    if (!card || !card.locations) return;
    
    const idx = card.locations.indexOf(locationId);
    if (idx !== -1) {
        card.locations.splice(idx, 1);
        saveStoryGridData();
        renderStoryGrid();
    }
}

// Surbrillance synchronisée des cards jumelles
function highlightTwinCards(cardId) {
    storyGridState.hoveredCardId = cardId;
    document.querySelectorAll(`[data-card-id="${cardId}"]`).forEach(el => {
        el.classList.add('twin-highlight');
    });
}

function unhighlightTwinCards() {
    if (storyGridState.hoveredCardId) {
        document.querySelectorAll(`[data-card-id="${storyGridState.hoveredCardId}"]`).forEach(el => {
            el.classList.remove('twin-highlight');
        });
        storyGridState.hoveredCardId = null;
    }
}

// ============================================
// LINKS MANAGEMENT
// ============================================

const LINK_TYPES = {
    depends: { label: 'Dépend de', color: '#3498db', icon: 'link' },
    flashback: { label: 'Flashback de', color: '#9b59b6', icon: 'rewind' },
    consequence: { label: 'Conséquence de', color: '#e74c3c', icon: 'arrow-right' },
    parallel: { label: 'Parallèle ÃƒÂ ', color: '#f39c12', icon: 'columns' },
    foreshadow: { label: 'Préfigure', color: '#27ae60', icon: 'eye' }
};

function addCardLink(fromCardId, toCardId, linkType) {
    // Prevent duplicate links
    const exists = storyGridState.links.some(l => 
        l.fromCard === fromCardId && l.toCard === toCardId
    );
    
    if (exists) return null;
    
    const link = {
        id: 'link_' + Date.now(),
        fromCard: fromCardId,
        toCard: toCardId,
        type: linkType,
        notes: ''
    };
    
    storyGridState.links.push(link);
    saveStoryGridData();
    renderStoryGrid();
    
    return link;
}

function deleteCardLink(linkId) {
    storyGridState.links = storyGridState.links.filter(l => l.id !== linkId);
    saveStoryGridData();
    renderStoryGrid();
}

// ============================================
// VIEW MODES
// ============================================

// Stockage des filtres manuels pour les restaurer en mode chronologique
let storyGridManualFilters = null;

function setStoryGridViewMode(mode) {
    const previousMode = storyGridState.viewMode;
    storyGridState.viewMode = mode;
    
    // Appliquer les filtres selon le mode de vue
    switch (mode) {
        case 'chronological':
            // Restaurer les filtres manuels ou afficher tous les types
            if (storyGridManualFilters) {
                storyGridState.filters.rowTypes = [...storyGridManualFilters];
            } else {
                storyGridState.filters.rowTypes = Object.keys(STORYGRID_ROW_TYPES);
            }
            break;
            
        case 'character':
            // Sauvegarder les filtres actuels si on quitte le mode chronologique
            if (previousMode === 'chronological') {
                storyGridManualFilters = [...storyGridState.filters.rowTypes];
            }
            storyGridState.filters.rowTypes = ['character'];
            break;
            
        case 'arc':
            if (previousMode === 'chronological') {
                storyGridManualFilters = [...storyGridState.filters.rowTypes];
            }
            storyGridState.filters.rowTypes = ['arc'];
            break;
            
        case 'location':
            if (previousMode === 'chronological') {
                storyGridManualFilters = [...storyGridState.filters.rowTypes];
            }
            storyGridState.filters.rowTypes = ['location'];
            break;
            
        default:
            storyGridState.filters.rowTypes = Object.keys(STORYGRID_ROW_TYPES);
    }
    
    renderStoryGrid();
}

function setStoryGridZoom(level) {
    if (!STORYGRID_ZOOM_LEVELS[level]) return;
    storyGridState.zoomLevel = level;
    storyGridState.columnWidth = STORYGRID_ZOOM_LEVELS[level].minWidth;
    renderStoryGrid();
}

function filterStoryGridRows(rowTypes) {
    storyGridState.filters.rowTypes = rowTypes;
    renderStoryGrid();
}

// ============================================
// RENDERING
// ============================================

function renderStoryGrid() {
    initStoryGrid();
    
    const container = document.getElementById('editorView');
    if (!container) return;
    
    const columns = getTimelineColumns();
    const visibleRows = storyGridState.rows
        .filter(r => r.visible && storyGridState.filters.rowTypes.includes(r.type))
        .sort((a, b) => a.order - b.order);
    
    container.innerHTML = `
        <div class="storygrid-container">
            ${renderStoryGridToolbar()}
            <div class="storygrid-main">
                ${renderStoryGridRowHeaders(visibleRows)}
                <div class="storygrid-content" id="storyGridContent">
                    ${renderStoryGridColumnHeaders(columns)}
                    ${renderStoryGridBody(visibleRows, columns)}
                    <svg class="storygrid-links-svg" id="storyGridLinks"></svg>
                </div>
            </div>
        </div>
    `;
    
    // Initialize event listeners
    initStoryGridEventListeners();
    
    // Render links
    renderStoryGridLinks();
    
    // Initialize Lucide icons
    if (typeof lucide !== 'undefined') {
        lucide.createIcons();
    }
}

function renderStoryGridToolbar() {
    const zoom = STORYGRID_ZOOM_LEVELS[storyGridState.zoomLevel];
    
    return `
        <div class="storygrid-toolbar">
            <div class="storygrid-toolbar-left">
                <div class="storygrid-toolbar-title">
                    <i data-lucide="layout-grid"></i>
                    <span>Story Grid</span>
                </div>
                
                <div class="storygrid-view-modes">
                    <button class="storygrid-view-btn ${storyGridState.viewMode === 'chronological' ? 'active' : ''}" 
                            onclick="setStoryGridViewMode('chronological')" title="Vue chronologique">
                        <i data-lucide="calendar"></i>
                    </button>
                    <button class="storygrid-view-btn ${storyGridState.viewMode === 'character' ? 'active' : ''}" 
                            onclick="setStoryGridViewMode('character')" title="Par personnage">
                        <i data-lucide="user"></i>
                    </button>
                    <button class="storygrid-view-btn ${storyGridState.viewMode === 'arc' ? 'active' : ''}" 
                            onclick="setStoryGridViewMode('arc')" title="Par arc">
                        <i data-lucide="drama"></i>
                    </button>
                    <button class="storygrid-view-btn ${storyGridState.viewMode === 'location' ? 'active' : ''}" 
                            onclick="setStoryGridViewMode('location')" title="Par lieu">
                        <i data-lucide="map-pin"></i>
                    </button>
                </div>
            </div>
            
            <div class="storygrid-toolbar-center">
                <div class="storygrid-zoom-control">
                    <button class="storygrid-zoom-btn" onclick="zoomStoryGrid(-1)" title="Dézoomer">
                        <i data-lucide="zoom-out"></i>
                    </button>
                    <div class="storygrid-zoom-label">
                        <i data-lucide="layers"></i>
                        <span>${zoom.name}</span>
                    </div>
                    <button class="storygrid-zoom-btn" onclick="zoomStoryGrid(1)" title="Zoomer">
                        <i data-lucide="zoom-in"></i>
                    </button>
                </div>
            </div>
            
            <div class="storygrid-toolbar-right">
                <button class="storygrid-action-btn" onclick="openAddRowModal()" title="Ajouter une ligne">
                    <i data-lucide="plus"></i>
                    <span>Ligne</span>
                </button>
                <button class="storygrid-action-btn" onclick="openStoryGridSettings()" title="Paramètres">
                    <i data-lucide="settings"></i>
                </button>
                <button class="storygrid-action-btn ${storyGridState.viewMode !== 'chronological' ? 'disabled' : ''}" 
                        onclick="${storyGridState.viewMode === 'chronological' ? 'toggleStoryGridFilters()' : ''}" 
                        title="${storyGridState.viewMode === 'chronological' ? 'Filtres' : 'Filtres désactivés en mode vue spécifique'}"
                        ${storyGridState.viewMode !== 'chronological' ? 'disabled' : ''}>
                    <i data-lucide="filter"></i>
                </button>
            </div>
        </div>
        
        ${storyGridState.viewMode === 'chronological' ? `
        <div class="storygrid-filters" id="storyGridFilters" style="display: none;">
            <div class="storygrid-filters-title">Filtrer par type</div>
            <div class="storygrid-filters-options">
                ${Object.entries(STORYGRID_ROW_TYPES).map(([type, data]) => `
                    <label class="storygrid-filter-option">
                        <input type="checkbox" 
                               ${storyGridState.filters.rowTypes.includes(type) ? 'checked' : ''}
                               onchange="toggleRowTypeFilter('${type}')">
                        <i data-lucide="${data.icon}" style="color: ${data.defaultColor}"></i>
                        <span>${data.label}</span>
                    </label>
                `).join('')}
            </div>
        </div>
        ` : `
        <div class="storygrid-view-mode-info">
            <i data-lucide="info"></i>
            <span>Vue filtrée : ${getViewModeLabel(storyGridState.viewMode)}</span>
        </div>
        `}
    `;
}

function renderStoryGridRowHeaders(rows) {
    const zoom = STORYGRID_ZOOM_LEVELS[storyGridState.zoomLevel];

    // Hauteurs des barres d'en-tÃªtes COLONNE (ÃƒÂ  aligner avec ton CSS colonne)
    const ACT_HEADER_HEIGHT = 33;       // .storygrid-act-groups height
    const CHAPTER_HEADER_HEIGHT = 33;   // .storygrid-chapter-groups height
    const COLUMN_HEADER_HEIGHT = 49;    // .storygrid-columns header height

    let cornerHeight;

    if (zoom.unit === 'act') {
        // En vue acte : une seule ligne d'en-tÃªte colonne (les actes)
        cornerHeight = COLUMN_HEADER_HEIGHT;
    } else if (zoom.unit === 'chapter') {
        // En vue chapitre : actes + ligne de chapitres
        cornerHeight = ACT_HEADER_HEIGHT + COLUMN_HEADER_HEIGHT;
    } else if (zoom.unit === 'scene') {
        // En vue scène : actes + chapitres + scènes
        cornerHeight = ACT_HEADER_HEIGHT + CHAPTER_HEADER_HEIGHT + COLUMN_HEADER_HEIGHT;
    } else {
        // fallback raisonnable
        cornerHeight = COLUMN_HEADER_HEIGHT;
    }

    if (rows.length === 0) {
        return `
            <div class="storygrid-row-headers">
                <div class="storygrid-corner" style="height: ${cornerHeight}px;"></div>
                <div class="storygrid-empty-rows">
                    <i data-lucide="layers"></i>
                    <p>Aucune ligne</p>
                    <button class="btn btn-sm" onclick="openAddRowModal()">Ajouter</button>
                </div>
            </div>
        `;
    }

    return `
        <div class="storygrid-row-headers">
            <div class="storygrid-corner" style="height: ${cornerHeight}px;">
            </div>
            ${rows.map((row, index) => {
                const typeData = STORYGRID_ROW_TYPES[row.type];
                return `
                    <div class="storygrid-row-header" 
                         data-row-id="${row.id}"
                         data-row-index="${index}"
                         draggable="true"
                         style="--row-color: ${row.color}">
                        <div class="storygrid-row-drag">
                            <i data-lucide="grip-vertical"></i>
                        </div>
                        <div class="storygrid-row-icon" style="color: ${row.color}">
                            <i data-lucide="${typeData.icon}"></i>
                        </div>
                        <div class="storygrid-row-title" 
                             ondblclick="editRowTitle('${row.id}', this)">
                            ${row.title}
                        </div>
                        <div class="storygrid-row-actions">
                            <button class="storygrid-row-action" 
                                    onclick="openRowOptionsMenu('${row.id}', event)"
                                    title="Options">
                                <i data-lucide="more-horizontal"></i>
                            </button>
                        </div>
                    </div>
                `;
            }).join('')}
        </div>
    `;
}






function renderStoryGridColumnHeaders(columns) {
    const zoom = STORYGRID_ZOOM_LEVELS[storyGridState.zoomLevel];

    if (columns.length === 0 || columns[0].type === 'placeholder') {
        return `
            <div class="storygrid-column-headers">
                <div class="storygrid-empty-columns">
                    <i data-lucide="file-text"></i>
                    <p>Aucun contenu dans le manuscrit</p>
                </div>
            </div>
        `;
    }

    // Helper pour récupérer le titre d'un chapitre ÃƒÂ  partir de son ID
    function getChapterTitleById(chapterId) {
        if (!chapterId) return 'Chapitre';

        // On cherche dans tous les actes, dans leurs chapitres
        const allActs = project.acts || [];
        for (const act of allActs) {
            const chapters = act.chapters || [];
            const chapter = chapters.find(c => c.id == chapterId);
            if (chapter) {
                return chapter.title || 'Chapitre';
            }
        }

        // Si jamais rien trouvé, on met un libellé générique
        return 'Chapitre';
    }

    let html = '<div class="storygrid-column-headers">';

    // 1. Ligne des actes (affichée sauf en zoom "acte")
    if (zoom.unit !== 'act') {
        const actGroups = {};
        columns.forEach(col => {
            const actId = col.actId ?? 'unknown-act';
            if (!actGroups[actId]) actGroups[actId] = [];
            actGroups[actId].push(col);
        });

        html += '<div class="storygrid-act-groups">';
        Object.entries(actGroups).forEach(([actId, cols]) => {
            const act = (project.acts || []).find(a => a.id == actId);
            const width = cols.length * storyGridState.columnWidth;
            html += `
                <div class="storygrid-act-group" style="width: ${width}px;">
                    ${act?.title || ''}
                </div>
            `;
        });
        html += '</div>';
    }

    // 2. Ligne des chapitres (affichée uniquement en zoom "scene")
    if (zoom.unit === 'scene') {
        const chapterGroups = {};
        columns.forEach(col => {
            const chapterId = col.chapterId ?? 'unknown-chapter';
            if (!chapterGroups[chapterId]) chapterGroups[chapterId] = [];
            chapterGroups[chapterId].push(col);
        });

        html += '<div class="storygrid-chapter-groups">';
        Object.entries(chapterGroups).forEach(([chapterId, cols]) => {
            const width = cols.length * storyGridState.columnWidth;
            const title = chapterId === 'unknown-chapter'
                ? 'Chapitre'
                : getChapterTitleById(chapterId);

            html += `
                <div class="storygrid-chapter-group" style="width: ${width}px;">
                    ${title}
                </div>
            `;
        });
        html += '</div>';
    }

    // 3. Ligne des colonnes (chapitres ou scènes selon le zoom)
    html += '<div class="storygrid-columns">';
    columns.forEach(col => {
        html += `
            <div class="storygrid-column-header" 
                 data-column-id="${col.id}"
                 style="width: ${storyGridState.columnWidth}px;">
                <div class="storygrid-column-title">${col.title}</div>
                ${col.items?.length > 0 ? `
                    <div class="storygrid-column-count">${col.items.length} scène${col.items.length > 1 ? 's' : ''}</div>
                ` : ''}
            </div>
        `;
    });
    html += '</div>';

    html += '</div>'; // Fin du conteneur principal
    return html;
}






function renderStoryGridBody(rows, columns) {
    if (rows.length === 0 || columns.length === 0 || columns[0].type === 'placeholder') {
        return `<div class="storygrid-body empty"></div>`;
    }
    
    let html = '<div class="storygrid-body">';
    
    rows.forEach(row => {
        html += `<div class="storygrid-row" data-row-id="${row.id}">`;
        
        // Track which columns are already covered by a spanning card
        const coveredColumns = new Set();
        
        columns.forEach((col, colIndex) => {
            // Check if this column is covered by a previous spanning card
            const isCovered = coveredColumns.has(col.id);
            
            if (isCovered) {
                // Render an empty cell for covered columns
                html += `
                    <div class="storygrid-cell storygrid-cell-covered"
                         data-row-id="${row.id}"
                         data-column-id="${col.id}"
                         style="width: ${storyGridState.columnWidth}px;">
                    </div>
                `;
                return;
            }
            
            // Utiliser getCardsForCell pour obtenir les cards + jumelles
            const cellCards = getCardsForCell(row, col);
            const hasContent = checkRowColumnContent(row, col);
            
            // Check if any card should span multiple columns
            let spanningCard = null;
            let columnSpan = 1;
            
            if (cellCards.length > 0) {
                // Check if this card should span multiple columns
                const card = cellCards[0]; // Take first card
                const spanInfo = calculateCardSpan(card, col, columns, colIndex);
                if (spanInfo.span > 1) {
                    spanningCard = card;
                    columnSpan = spanInfo.span;
                    // Mark covered columns
                    for (let i = 1; i < columnSpan; i++) {
                        if (columns[colIndex + i]) {
                            coveredColumns.add(columns[colIndex + i].id);
                        }
                    }
                }
            }
            
            const spanWidth = storyGridState.columnWidth * columnSpan;
            
            // Style de fond coloré si contenu présent
            const cellBgStyle = hasContent ? `background-color: ${row.color}20; border-color: ${row.color}40;` : '';
            
            html += `
                <div class="storygrid-cell ${hasContent ? 'has-content' : ''} ${cellCards.length > 0 ? 'has-cards' : ''} ${spanningCard ? 'has-spanning-card' : ''}"
                     data-row-id="${row.id}"
                     data-column-id="${col.id}"
                     style="width: ${storyGridState.columnWidth}px; ${cellBgStyle}">
                    ${hasContent && cellCards.length === 0 ? renderAutoCard(row, col) : ''}
                    ${spanningCard ? 
                        renderStoryGridCard(spanningCard, row, spanWidth) : 
                        cellCards.map(card => renderStoryGridCard(card, row)).join('')
                    }
                    ${!isCovered ? `
                        <div class="storygrid-cell-add" 
                             onclick="quickAddCard('${row.id}', '${col.id}')">
                            <i data-lucide="plus"></i>
                        </div>
                    ` : ''}
                </div>
            `;
        });
        
        html += '</div>';
    });
    
    html += '</div>';
    return html;
}

function calculateCardSpan(card, currentColumn, allColumns, currentColumnIndex) {
    // Determine how many consecutive columns this card should span
    let span = 1;
    
    // Only span if we're in scene view and card belongs to chapter (not specific scene)
    if (currentColumn.type === 'scene' && card.chapterId && !card.sceneId) {
        // Count consecutive scene columns in the same chapter
        for (let i = currentColumnIndex + 1; i < allColumns.length; i++) {
            const nextCol = allColumns[i];
            if (nextCol.type === 'scene' && nextCol.chapterId === card.chapterId) {
                span++;
            } else {
                break;
            }
        }
    }
    
    return { span };
}

function checkRowColumnContent(row, column) {
    // Check if this row has content in this column based on type
    // Utilise linkedCharacters et linkedElements de auto-detect.js
    switch (row.type) {
        case 'character':
            return column.items?.some(scene => 
                scene.linkedCharacters?.includes(row.sourceId) ||
                scene.characters?.includes(row.sourceId) ||
                scene.pov === row.sourceId
            );
        
        case 'arc':
            const arc = project.narrativeArcs?.find(a => a.id === row.sourceId);
            if (arc?.scenePresence) {
                return column.items?.some(scene =>
                    arc.scenePresence.some(p => p.sceneId === scene.id)
                );
            }
            // Vérifier aussi linkedArcs si implémenté
            return column.items?.some(scene =>
                scene.linkedArcs?.includes(row.sourceId)
            );
        
        case 'location':
            return column.items?.some(scene =>
                scene.linkedElements?.includes(row.sourceId) ||
                scene.location === row.sourceId ||
                scene.locations?.includes(row.sourceId)
            );
        
        default:
            return false;
    }
}

function renderAutoCard(row, column) {
    // Render automatic indicator for content that exists in the project
    const typeData = STORYGRID_ROW_TYPES[row.type];
    
    // Bouton de navigation (seulement si c'est une scène)
    let navButton = '';
    if (column.type === 'scene' && column.sceneId) {
        navButton = `
            <button class="storygrid-auto-nav" 
                    onclick="event.stopPropagation(); showSceneNavigationModal('${column.actId}', '${column.chapterId}', '${column.sceneId}')"
                    title="Ouvrir la scène">
                <i data-lucide="eye"></i>
            </button>
        `;
    }
    
    return `
        <div class="storygrid-auto-card" 
             style="border-color: ${row.color}40; background: ${row.color}15;">
            ${navButton}
            <div class="storygrid-auto-card-icon" style="color: ${row.color}">
                <i data-lucide="${typeData.icon}"></i>
            </div>
        </div>
    `;
}

function renderStoryGridCard(card, row, spanWidth = null) {
    const status = CARD_STATUSES[card.status] || CARD_STATUSES.draft;
    const cardColor = card.color || row.color;
    const isSpanning = spanWidth !== null;
    const widthStyle = isSpanning ? `width: ${spanWidth}px;` : '';
    
    // Détecter si c'est une jumelle
    const isTwin = card.isTwin === true;
    const isOriginal = card.isOriginal !== false;
    const twinCount = getCardTwinCount(card.id);
    const hasTwins = twinCount > 1;
    
    // Badges de liaisons
    const linkBadges = renderCardLinkBadges(card);
    
    return `
        <div class="storygrid-card ${isSpanning ? 'spanning' : ''} ${isTwin ? 'is-twin' : ''} ${hasTwins && isOriginal ? 'has-twins' : ''}" 
             data-card-id="${card.id}"
             draggable="true"
             onclick="openCardDetail('${card.id}')"
             onmouseenter="highlightTwinCards('${card.id}')"
             onmouseleave="unhighlightTwinCards()"
             style="--card-color: ${cardColor}; --status-color: ${status.color}; ${widthStyle}">
            <button class="storygrid-card-delete" 
                    onclick="event.stopPropagation(); deleteCardContextual('${card.id}', '${card.displayRowId}')" 
                    title="Supprimer la carte">
                x
            </button>
            <div class="storygrid-card-header">
                <div class="storygrid-card-status" title="${status.label}">
                    <i data-lucide="${status.icon}"></i>
                </div>
                ${hasTwins && isOriginal ? `
                    <div class="storygrid-card-twins" title="${twinCount} apparitions">
                        <i data-lucide="copy"></i>
                        <span>${twinCount}</span>
                    </div>
                ` : ''}
                ${isTwin ? `
                    <div class="storygrid-card-twin-badge" title="Carte jumelle">
                        <i data-lucide="link"></i>
                    </div>
                ` : ''}
                <div class="storygrid-card-intensity">
                    ${renderIntensityDots(card.intensity)}
                </div>
            </div>
            <div class="storygrid-card-title">${card.title}</div>
            ${card.summary ? `<div class="storygrid-card-summary">${card.summary}</div>` : ''}
            ${card.conflict ? `
                <div class="storygrid-card-conflict">
                    <i data-lucide="zap"></i> ${truncateText(card.conflict, 40)}
                </div>
            ` : ''}
            ${linkBadges ? `<div class="storygrid-card-badges">${linkBadges}</div>` : ''}
        </div>
    `;
}

// Rendu des badges de liaison sur une card
function renderCardLinkBadges(card) {
    let badges = '';
    
    const charCount = card.characters?.length || 0;
    const arcCount = card.arcs?.length || 0;
    const locCount = card.locations?.length || 0;
    
    if (charCount > 0) {
        badges += `<span class="card-badge card-badge-character" title="${charCount} personnage(s)">
            <i data-lucide="user"></i>${charCount}
        </span>`;
    }
    if (arcCount > 0) {
        badges += `<span class="card-badge card-badge-arc" title="${arcCount} arc(s)">
            <i data-lucide="git-branch"></i>${arcCount}
        </span>`;
    }
    if (locCount > 0) {
        badges += `<span class="card-badge card-badge-location" title="${locCount} lieu(x)">
            <i data-lucide="map-pin"></i>${locCount}
        </span>`;
    }
    
    return badges;
}

function renderIntensityDots(intensity) {
    let dots = '';
    for (let i = 1; i <= 5; i++) {
        dots += `<span class="intensity-dot ${i <= intensity ? 'active' : ''}"></span>`;
    }
    return dots;
}

function truncateText(text, maxLength) {
    if (text.length <= maxLength) return text;
    return text.substring(0, maxLength) + '...';
}

// ============================================
// SVG LINKS RENDERING
// ============================================

function renderStoryGridLinks() {
    const svg = document.getElementById('storyGridLinks');
    if (!svg) return;
    
    svg.innerHTML = '';
    
    storyGridState.links.forEach(link => {
        const fromCard = document.querySelector(`[data-card-id="${link.fromCard}"]`);
        const toCard = document.querySelector(`[data-card-id="${link.toCard}"]`);
        
        if (!fromCard || !toCard) return;
        
        const fromRect = fromCard.getBoundingClientRect();
        const toRect = toCard.getBoundingClientRect();
        const svgRect = svg.getBoundingClientRect();
        
        const fromX = fromRect.right - svgRect.left;
        const fromY = fromRect.top + fromRect.height / 2 - svgRect.top;
        const toX = toRect.left - svgRect.left;
        const toY = toRect.top + toRect.height / 2 - svgRect.top;
        
        const linkTypeData = LINK_TYPES[link.type] || LINK_TYPES.depends;
        
        // Create curved path
        const midX = (fromX + toX) / 2;
        const path = `M ${fromX} ${fromY} C ${midX} ${fromY}, ${midX} ${toY}, ${toX} ${toY}`;
        
        const pathEl = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        pathEl.setAttribute('d', path);
        pathEl.setAttribute('stroke', linkTypeData.color);
        pathEl.setAttribute('stroke-width', '2');
        pathEl.setAttribute('fill', 'none');
        pathEl.setAttribute('class', 'storygrid-link-path');
        pathEl.setAttribute('data-link-id', link.id);
        
        // Add arrow marker
        pathEl.setAttribute('marker-end', `url(#arrow-${link.type})`);
        
        svg.appendChild(pathEl);
    });
    
    // Add markers for arrows
    const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
    Object.entries(LINK_TYPES).forEach(([type, data]) => {
        const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
        marker.setAttribute('id', `arrow-${type}`);
        marker.setAttribute('markerWidth', '10');
        marker.setAttribute('markerHeight', '10');
        marker.setAttribute('refX', '9');
        marker.setAttribute('refY', '3');
        marker.setAttribute('orient', 'auto');
        
        const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
        polygon.setAttribute('points', '0 0, 10 3, 0 6');
        polygon.setAttribute('fill', data.color);
        
        marker.appendChild(polygon);
        defs.appendChild(marker);
    });
    svg.insertBefore(defs, svg.firstChild);
}

// ============================================
// DRAG & DROP
// ============================================

function handleCardDragStart(event) {
    const card = event.currentTarget;
    const cardId = card.dataset.cardId;
    if (!cardId) {
        return;
    }
    
    event.dataTransfer.setData('text/plain', cardId);
    event.dataTransfer.effectAllowed = 'move';
    card.classList.add('dragging');
    storyGridState.dragState = { cardId };
}

function handleCardDragEnd(event) {
    event.currentTarget.classList.remove('dragging');
    storyGridState.dragState = null;
    
    // Remove all drag-over states
    document.querySelectorAll('.storygrid-cell.drag-over').forEach(cell => {
        cell.classList.remove('drag-over');
    });
}

function handleCardDragOver(event) {
    event.preventDefault();
    event.dataTransfer.dropEffect = 'move';
    event.currentTarget.classList.add('drag-over');
}

function handleCardDragLeave(event) {
    event.currentTarget.classList.remove('drag-over');
}

// Drop handlers for cards - propagate to parent cell
function handleCardDropOnCard(event) {
    event.preventDefault();
    event.stopPropagation();
    
    // Find the parent cell
    const cell = event.currentTarget.closest('.storygrid-cell');
    if (!cell) return;
    
    cell.classList.remove('drag-over');
    
    const cardId = event.dataTransfer.getData('text/plain');
    const draggedCardId = event.currentTarget.dataset.cardId;
    
    // Don't drop on itself
    if (cardId === draggedCardId) return;
    
    const newRowId = cell.dataset.rowId;
    const newColumnId = cell.dataset.columnId;
    
    if (cardId && newRowId && newColumnId) {
        moveCard(cardId, newRowId, newColumnId);
    }
}

function handleCardDragOverOnCard(event) {
    event.preventDefault();
    event.stopPropagation();
    event.dataTransfer.dropEffect = 'move';
    
    // Highlight the parent cell
    const cell = event.currentTarget.closest('.storygrid-cell');
    if (cell) {
        cell.classList.add('drag-over');
    }
}

function handleCardDragLeaveOnCard(event) {
    event.stopPropagation();
    
    // Remove highlight from parent cell
    const cell = event.currentTarget.closest('.storygrid-cell');
    if (cell) {
        // Only remove if we're not still over the cell
        const relatedTarget = event.relatedTarget;
        if (!cell.contains(relatedTarget)) {
            cell.classList.remove('drag-over');
        }
    }
}

// Generic drop handlers for cell children (add button, auto-cards, etc.)
function handleCellChildDrop(event) {
    event.preventDefault();
    event.stopPropagation();
    
    // Find the parent cell
    const cell = event.currentTarget.closest('.storygrid-cell');
    if (!cell) return;
    
    cell.classList.remove('drag-over');
    
    const cardId = event.dataTransfer.getData('text/plain');
    const newRowId = cell.dataset.rowId;
    const newColumnId = cell.dataset.columnId;
    
    if (cardId && newRowId && newColumnId) {
        moveCard(cardId, newRowId, newColumnId);
    }
}

function handleCellChildDragOver(event) {
    event.preventDefault();
    event.stopPropagation();
    event.dataTransfer.dropEffect = 'move';
    
    // Highlight the parent cell
    const cell = event.currentTarget.closest('.storygrid-cell');
    if (cell) {
        cell.classList.add('drag-over');
    }
}

function handleCellChildDragLeave(event) {
    event.stopPropagation();
    
    // Remove highlight from parent cell only if leaving the cell entirely
    const cell = event.currentTarget.closest('.storygrid-cell');
    if (cell) {
        const relatedTarget = event.relatedTarget;
        if (!cell.contains(relatedTarget)) {
            cell.classList.remove('drag-over');
        }
    }
}

function handleCardDrop(event) {
    event.preventDefault();
    event.currentTarget.classList.remove('drag-over');
    
    const cardId = event.dataTransfer.getData('text/plain');
    const newRowId = event.currentTarget.dataset.rowId;
    const newColumnId = event.currentTarget.dataset.columnId;
    
    if (cardId && newRowId && newColumnId) {
        moveCard(cardId, newRowId, newColumnId);
    }
}

// Row drag & drop
function initRowDragDrop() {
    const rowHeaders = document.querySelectorAll('.storygrid-row-header');
    
    rowHeaders.forEach(header => {
        header.addEventListener('dragstart', handleRowDragStart);
        header.addEventListener('dragend', handleRowDragEnd);
        header.addEventListener('dragover', handleRowDragOver);
        header.addEventListener('drop', handleRowDrop);
    });
}

function handleRowDragStart(event) {
    event.dataTransfer.setData('text/plain', event.target.dataset.rowIndex);
    event.target.classList.add('dragging');
}

function handleRowDragEnd(event) {
    event.target.classList.remove('dragging');
    document.querySelectorAll('.storygrid-row-header.drag-over').forEach(el => {
        el.classList.remove('drag-over');
    });
}

function handleRowDragOver(event) {
    event.preventDefault();
    event.currentTarget.classList.add('drag-over');
}

function handleRowDrop(event) {
    event.preventDefault();
    event.currentTarget.classList.remove('drag-over');
    
    const fromIndex = parseInt(event.dataTransfer.getData('text/plain'));
    const toIndex = parseInt(event.currentTarget.dataset.rowIndex);
    
    if (!isNaN(fromIndex) && !isNaN(toIndex) && fromIndex !== toIndex) {
        reorderRows(fromIndex, toIndex);
    }
}

// ============================================
// EVENT LISTENERS
// ============================================

function initStoryGridEventListeners() {
    const content = document.getElementById('storyGridContent');
    if (!content) {
        return;
    }
    
    // Pan functionality
    content.addEventListener('mousedown', handlePanStart);
    content.addEventListener('mousemove', handlePanMove);
    content.addEventListener('mouseup', handlePanEnd);
    content.addEventListener('mouseleave', handlePanEnd);
    
    // Wheel zoom
    content.addEventListener('wheel', handleWheelZoom, { passive: false });
    
    // Initialize row drag/drop
    initRowDragDrop();
    
    // Delegated drag and drop for cards - captures events at container level
    content.addEventListener('dragstart', handleDelegatedDragStart);
    content.addEventListener('dragend', handleDelegatedDragEnd);
    content.addEventListener('dragover', handleDelegatedDragOver);
    content.addEventListener('dragleave', handleDelegatedDragLeave);
    content.addEventListener('drop', handleDelegatedDrop);
}

// Delegated dragstart - find the card being dragged
function handleDelegatedDragStart(event) {
    const card = event.target.closest('.storygrid-card');
    if (!card) {
        return;
    }
    
    const cardId = card.dataset.cardId;
    
    if (!cardId) {
        return;
    }
    
    event.dataTransfer.setData('text/plain', cardId);
    event.dataTransfer.effectAllowed = 'move';
    card.classList.add('dragging');
    storyGridState.dragState = { cardId };
}

function handleDelegatedDragEnd(event) {
    const card = event.target.closest('.storygrid-card');
    if (card) {
        card.classList.remove('dragging');
    }
    storyGridState.dragState = null;
    
    // Remove all drag-over states
    document.querySelectorAll('.storygrid-cell.drag-over').forEach(cell => {
        cell.classList.remove('drag-over');
    });
}

// Delegated drag handlers - work regardless of which child element is hovered
function handleDelegatedDragOver(event) {
    // Find the closest cell
    const cell = event.target.closest('.storygrid-cell');
    if (!cell) {
        return;
    }
    
    // Check if we're dragging a card (not a row)
    if (!storyGridState.dragState) {
        return;
    }
    
    event.preventDefault();
    event.dataTransfer.dropEffect = 'move';
    
    // Remove drag-over from all cells and add to current
    document.querySelectorAll('.storygrid-cell.drag-over').forEach(c => {
        if (c !== cell) c.classList.remove('drag-over');
    });
    cell.classList.add('drag-over');
}

function handleDelegatedDragLeave(event) {
    // Only handle if leaving a cell
    const cell = event.target.closest('.storygrid-cell');
    if (!cell) return;
    
    // Check if we're really leaving the cell (not just moving to a child)
    const relatedTarget = event.relatedTarget;
    if (relatedTarget && cell.contains(relatedTarget)) return;
    
    cell.classList.remove('drag-over');
}

function handleDelegatedDrop(event) {
    
    // Find the closest cell
    const cell = event.target.closest('.storygrid-cell');
    if (!cell) {
        return;
    }
    
    // Check if we have drag state
    if (!storyGridState.dragState) {
        return;
    }
    
    event.preventDefault();
    event.stopPropagation();
    
    // Remove all drag-over states
    document.querySelectorAll('.storygrid-cell.drag-over').forEach(c => {
        c.classList.remove('drag-over');
    });
    
    const cardId = storyGridState.dragState.cardId;
    const newRowId = cell.dataset.rowId;
    const newColumnId = cell.dataset.columnId;
    
    if (!cardId || !newRowId || !newColumnId) {
        return;
    }
    
    // Find the original card to check its current position
    const card = findCardById(cardId);
    if (!card) {
        return;
    }
    
    // Check if we're dropping in the exact same position (same row AND same column)
    // Allow drop if either row or column is different
    const currentColumnId = getCardColumnId(card);
    
    if (card.rowId === newRowId && currentColumnId === newColumnId) {
        return;
    }
    moveCard(cardId, newRowId, newColumnId);
}

// Helper to get the column ID for a card based on its hierarchical position
function getCardColumnId(card) {
    const zoom = STORYGRID_ZOOM_LEVELS[storyGridState.zoomLevel];
    switch (zoom.unit) {
        case 'act':
            return card.actId ? 'col_act_' + card.actId : null;
        case 'chapter':
            return card.chapterId ? 'col_chapter_' + card.chapterId : null;
        case 'scene':
            return card.sceneId ? 'col_scene_' + card.sceneId : 
                   (card.chapterId ? 'col_chapter_' + card.chapterId : null);
        default:
            return null;
    }
}

function handlePanStart(event) {
    // Only pan when clicking on empty space
    if (event.target.closest('.storygrid-card') || event.target.closest('.storygrid-cell-add')) {
        return;
    }
    
    if (event.button === 1 || (event.button === 0 && event.altKey)) { // Middle click or Alt+Left click
        storyGridState.panState.isPanning = true;
        storyGridState.panState.startX = event.pageX;
        storyGridState.panState.scrollLeft = event.currentTarget.scrollLeft;
        event.currentTarget.style.cursor = 'grabbing';
    }
}

function handlePanMove(event) {
    if (!storyGridState.panState.isPanning) return;
    
    event.preventDefault();
    const x = event.pageX;
    const walk = (x - storyGridState.panState.startX) * 1.5;
    event.currentTarget.scrollLeft = storyGridState.panState.scrollLeft - walk;
}

function handlePanEnd(event) {
    storyGridState.panState.isPanning = false;
    event.currentTarget.style.cursor = '';
}

function handleWheelZoom(event) {
    if (event.ctrlKey || event.metaKey) {
        event.preventDefault();
        
        if (event.deltaY < 0) {
            zoomStoryGrid(1);
        } else {
            zoomStoryGrid(-1);
        }
    }
}

function zoomStoryGrid(direction) {
    const levels = Object.keys(STORYGRID_ZOOM_LEVELS);
    const currentIndex = levels.indexOf(storyGridState.zoomLevel);
    const newIndex = Math.max(0, Math.min(levels.length - 1, currentIndex + direction));
    
    if (newIndex !== currentIndex) {
        setStoryGridZoom(levels[newIndex]);
    }
}

// ============================================
// UI HELPERS
// ============================================

function toggleStoryGridFilters() {
    const filters = document.getElementById('storyGridFilters');
    if (filters) {
        filters.style.display = filters.style.display === 'none' ? 'flex' : 'none';
    }
}

function toggleRowTypeFilter(type) {
    // Ne rien faire si on n'est pas en mode chronologique
    if (storyGridState.viewMode !== 'chronological') {
        return;
    }
    
    const index = storyGridState.filters.rowTypes.indexOf(type);
    if (index === -1) {
        storyGridState.filters.rowTypes.push(type);
    } else {
        storyGridState.filters.rowTypes.splice(index, 1);
    }
    
    // Mettre à jour les filtres manuels
    storyGridManualFilters = [...storyGridState.filters.rowTypes];
        
    renderStoryGrid();
    
    // ===============================================
    // NOUVEAU CODE AJOUTÉ POUR GARDER LA BARRE VISIBLE
    // ===============================================
    const filters = document.getElementById('storyGridFilters');
    if (filters) {
        // Force l'affichage du panneau des filtres sur 'flex'
        filters.style.display = 'flex'; 
    }
    // ===============================================
}

function getViewModeLabel(mode) {
    const labels = {
        chronological: 'Vue chronologique',
        character: 'Personnages',
        arc: 'Arcs narratifs',
        location: 'Lieux'
    };
    return labels[mode] || mode;
}

function editRowTitle(rowId, element) {
    const row = storyGridState.rows.find(r => r.id === rowId);
    if (!row) return;
    
    const input = document.createElement('input');
    input.type = 'text';
    input.className = 'storygrid-row-title-input';
    input.value = row.title;
    
    element.textContent = '';
    element.appendChild(input);
    input.focus();
    input.select();
    
    const finishEditing = () => {
        const newTitle = input.value.trim();
        if (newTitle && newTitle !== row.title) {
            row.title = newTitle;
            saveStoryGridData();
        }
        renderStoryGrid();
    };
    
    input.addEventListener('blur', finishEditing);
    input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') finishEditing();
        if (e.key === 'Escape') renderStoryGrid();
    });
}

function quickAddCard(rowId, columnId) {
    const card = addCardToGrid(rowId, columnId);
    if (card) {
        openCardDetail(card.id);
    }
}

// ============================================
// MODALS
// ============================================

function openAddRowModal() {
    const modal = document.createElement('div');
    modal.className = 'modal active';
    modal.id = 'addStoryGridRowModal';
    modal.dataset.dynamic = 'true';
    modal.innerHTML = `
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header">
                <div class="modal-title">Ajouter une ligne</div>
                <button class="modal-close" onclick="closeModal('addStoryGridRowModal')">x</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">Type de ligne</label>
                    <div class="storygrid-row-type-selector">
                        ${Object.entries(STORYGRID_ROW_TYPES).map(([type, data]) => `
                            <label class="storygrid-row-type-option">
                                <input type="radio" name="rowType" value="${type}" ${type === 'character' ? 'checked' : ''}>
                                <div class="storygrid-row-type-card">
                                    <i data-lucide="${data.icon}" style="color: ${data.defaultColor}"></i>
                                    <span>${data.label}</span>
                                </div>
                            </label>
                        `).join('')}
                    </div>
                </div>
                
                <div class="form-group" id="rowSourceSelector" style="display: none;">
                    <label class="form-label">Source</label>
                    <select class="form-input" id="rowSourceSelect">
                        <option value="">-- Sélectionner --</option>
                    </select>
                </div>
                
                <div class="form-group" id="rowCustomTitle">
                    <label class="form-label">Titre</label>
                    <input type="text" class="form-input" id="newRowTitle" placeholder="Nom de la ligne...">
                </div>
                
                <div class="form-group">
                    <label class="form-label">Couleur</label>
                    <input type="color" class="form-input" id="newRowColor" value="#3498db" style="height: 40px;">
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeModal('addStoryGridRowModal')">Annuler</button>
                <button class="btn btn-primary" onclick="confirmAddRow()">Ajouter</button>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
    
    // Setup type selector change
    modal.querySelectorAll('input[name="rowType"]').forEach(radio => {
        radio.addEventListener('change', updateRowSourceOptions);
    });
    
    updateRowSourceOptions();
    
    if (typeof lucide !== 'undefined') {
        lucide.createIcons();
    }
}

function updateRowSourceOptions() {
    const type = document.querySelector('input[name="rowType"]:checked')?.value;
    const sourceSelector = document.getElementById('rowSourceSelector');
    const sourceSelect = document.getElementById('rowSourceSelect');
    const customTitle = document.getElementById('rowCustomTitle');
    const colorInput = document.getElementById('newRowColor');
    const typeData = STORYGRID_ROW_TYPES[type];
    
    colorInput.value = typeData?.defaultColor || '#3498db';
    
    if (!typeData || typeData.source === 'custom') {
        sourceSelector.style.display = 'none';
        customTitle.style.display = 'block';
        return;
    }
    
    let options = '<option value="">-- Sélectionner --</option>';
    let items = [];
    
    switch (type) {
        case 'character':
            items = project.characters || [];
            items.forEach(char => {
                // Check if not already a row
                const exists = storyGridState.rows.some(r => r.type === 'character' && r.sourceId === char.id);
                if (!exists) {
                    options += `<option value="${char.id}">${char.name}</option>`;
                }
            });
            break;
        case 'arc':
            items = project.narrativeArcs || [];
            items.forEach(arc => {
                const exists = storyGridState.rows.some(r => r.type === 'arc' && r.sourceId === arc.id);
                if (!exists) {
                    options += `<option value="${arc.id}">${arc.title}</option>`;
                }
            });
            break;
        case 'location':
            // Les lieux sont dans project.world, filtrés par type
            const worldItems = project.world || [];
            items = worldItems.filter(w => w.type === 'location' || w.type === 'Lieu');
            items.forEach(loc => {
                const exists = storyGridState.rows.some(r => r.type === 'location' && r.sourceId === loc.id);
                if (!exists) {
                    options += `<option value="${loc.id}">${loc.name}</option>`;
                }
            });
            break;
    }
    
    sourceSelect.innerHTML = options;
    sourceSelector.style.display = 'block';
    customTitle.style.display = 'none';
    
    // Update title when source changes
    sourceSelect.onchange = function() {
        const titleInput = document.getElementById('newRowTitle');
        if (this.value) {
            const selectedOption = this.options[this.selectedIndex];
            titleInput.value = selectedOption.text;
        }
    };
}

function confirmAddRow() {
    const type = document.querySelector('input[name="rowType"]:checked')?.value;
    const sourceSelect = document.getElementById('rowSourceSelect');
    const titleInput = document.getElementById('newRowTitle');
    const colorInput = document.getElementById('newRowColor');
    
    const typeData = STORYGRID_ROW_TYPES[type];
    let title = titleInput.value.trim();
    let sourceId = null;
    
    if (typeData.source !== 'custom' && sourceSelect.value) {
        sourceId = sourceSelect.value;
        const selectedOption = sourceSelect.options[sourceSelect.selectedIndex];
        title = selectedOption.text;
    }
    
    if (!title) {
        alert('Veuillez saisir un titre pour la ligne.');
        return;
    }
    
    addStoryGridRow(type, {
        sourceId: sourceId,
        title: title,
        color: colorInput.value
    });
    
    closeModal('addStoryGridRowModal');
}

function openRowOptionsMenu(rowId, event) {
    event.stopPropagation();
    
    // Remove any existing menu
    const existingMenu = document.querySelector('.storygrid-context-menu');
    if (existingMenu) existingMenu.remove();
    
    const row = storyGridState.rows.find(r => r.id === rowId);
    if (!row) return;
    
    const menu = document.createElement('div');
    menu.className = 'storygrid-context-menu';
    menu.innerHTML = `
        <div class="context-menu-item" onclick="editRowProperties('${rowId}')">
            <i data-lucide="edit-3"></i> Modifier
        </div>
        <div class="context-menu-item" onclick="toggleRowVisibility('${rowId}'); this.parentElement.remove();">
            <i data-lucide="${row.visible ? 'eye-off' : 'eye'}"></i> 
            ${row.visible ? 'Masquer' : 'Afficher'}
        </div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-item danger" onclick="confirmDeleteRow('${rowId}')">
            <i data-lucide="trash-2"></i> Supprimer
        </div>
    `;
    
    // Position menu
    const rect = event.target.getBoundingClientRect();
    menu.style.top = rect.bottom + 'px';
    menu.style.left = rect.left + 'px';
    
    document.body.appendChild(menu);
    
    if (typeof lucide !== 'undefined') {
        lucide.createIcons();
    }
    
    // Close menu on click outside
    setTimeout(() => {
        document.addEventListener('click', function closeMenu(e) {
            if (!menu.contains(e.target)) {
                menu.remove();
                document.removeEventListener('click', closeMenu);
            }
        });
    }, 10);
}

function editRowProperties(rowId) {
    const row = storyGridState.rows.find(r => r.id === rowId);
    if (!row) return;
    
    // Close context menu
    const existingMenu = document.querySelector('.storygrid-context-menu');
    if (existingMenu) existingMenu.remove();
    
    const modal = document.createElement('div');
    modal.className = 'modal active';
    modal.id = 'editRowModal';
    modal.dataset.dynamic = 'true';
    modal.innerHTML = `
        <div class="modal-content" style="max-width: 400px;">
            <div class="modal-header">
                <div class="modal-title">Modifier la ligne</div>
                <button class="modal-close" onclick="closeModal('editRowModal')">x</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">Titre</label>
                    <input type="text" class="form-input" id="editRowTitle" value="${row.title}">
                </div>
                <div class="form-group">
                    <label class="form-label">Couleur</label>
                    <input type="color" class="form-input" id="editRowColor" value="${row.color}" style="height: 40px;">
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeModal('editRowModal')">Annuler</button>
                <button class="btn btn-primary" onclick="saveRowProperties('${rowId}')">Enregistrer</button>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
}

function saveRowProperties(rowId) {
    const title = document.getElementById('editRowTitle').value.trim();
    const color = document.getElementById('editRowColor').value;
    
    if (title) {
        updateStoryGridRow(rowId, { title, color });
    }
    
    closeModal('editRowModal');
}

function confirmDeleteRow(rowId) {
    // Close context menu
    const existingMenu = document.querySelector('.storygrid-context-menu');
    if (existingMenu) existingMenu.remove();
    
    if (confirm('ÃŠtes-vous sÃƒÂ»r de vouloir supprimer cette ligne et toutes ses cartes ?')) {
        deleteStoryGridRow(rowId);
    }
}

// ============================================
// CARD DETAIL MODAL
// ============================================

function openCardDetail(cardId) {
    let card = null;
    let row = null;
    
    for (const r of storyGridState.rows) {
        const c = r.cards.find(c => c.id === cardId);
        if (c) {
            card = c;
            row = r;
            break;
        }
    }
    
    if (!card || !row) return;
    
    storyGridState.selectedCard = cardId;
    
    const modal = document.createElement('div');
    modal.className = 'modal active';
    modal.id = 'cardDetailModal';
    modal.dataset.dynamic = 'true';
    modal.innerHTML = `
        <div class="modal-content storygrid-card-modal">
            <div class="modal-header" style="border-left: 4px solid ${row.color};">
                <div class="modal-title">
                    <input type="text" class="storygrid-card-title-input" 
                           value="${card.title}" 
                           onchange="updateCard('${cardId}', {title: this.value})">
                </div>
                <button class="modal-close" onclick="closeModal('cardDetailModal')">x</button>
            </div>
            <div class="modal-body">
                <div class="storygrid-card-detail-grid">
                    <div class="storygrid-card-detail-main">
                        <div class="form-group">
                            <label class="form-label">Résumé</label>
                            <textarea class="form-input" rows="3" 
                                      onchange="updateCard('${cardId}', {summary: this.value})"
                                      placeholder="Résumé de la scène...">${card.summary || ''}</textarea>
                        </div>
                        
                        <div class="form-group">
                            <label class="form-label">Objectif dramatique</label>
                            <textarea class="form-input" rows="2" 
                                      onchange="updateCard('${cardId}', {objective: this.value})"
                                      placeholder="Que doit accomplir cette scène ?">${card.objective || ''}</textarea>
                        </div>
                        
                        <div class="form-group">
                            <label class="form-label">
                                <i data-lucide="zap" style="width: 14px; height: 14px;"></i> Conflit
                            </label>
                            <textarea class="form-input" rows="2" 
                                      onchange="updateCard('${cardId}', {conflict: this.value})"
                                      placeholder="Tension, obstacle, enjeu...">${card.conflict || ''}</textarea>
                        </div>
                        
                        <div class="form-group">
                            <label class="form-label">Notes</label>
                            <textarea class="form-input" rows="3" 
                                      onchange="updateCard('${cardId}', {notes: this.value})"
                                      placeholder="Notes personnelles...">${card.notes || ''}</textarea>
                        </div>
                        
                        <!-- Section Liaisons Multiples -->
                        <div class="storygrid-card-links-section">
                            <div class="section-title">
                                <i data-lucide="link-2"></i>
                                <span>Liaisons (Cards Jumelles)</span>
                            </div>
                            <div class="storygrid-links-grid" id="cardLinksGrid">
                                ${renderCardEntityLinks(card)}
                            </div>
                        </div>
                    </div>
                    
                    <div class="storygrid-card-detail-side">
                        <div class="form-group">
                            <label class="form-label">Statut</label>
                            <select class="form-input" onchange="updateCard('${cardId}', {status: this.value})">
                                ${Object.entries(CARD_STATUSES).map(([key, data]) => `
                                    <option value="${key}" ${card.status === key ? 'selected' : ''}>
                                        ${data.label}
                                    </option>
                                `).join('')}
                            </select>
                        </div>
                        
                        <div class="form-group">
                            <label class="form-label">Intensité</label>
                            <div class="storygrid-intensity-selector">
                                ${[1, 2, 3, 4, 5].map(i => `
                                    <button class="intensity-btn ${card.intensity >= i ? 'active' : ''}"
                                            onclick="updateCardIntensity('${cardId}', ${i})">
                                        ${i}
                                    </button>
                                `).join('')}
                            </div>
                        </div>
                        
                        <div class="form-group">
                            <label class="form-label">Point de vue</label>
                            <select class="form-input" onchange="updateCard('${cardId}', {pov: this.value})">
                                <option value="">-- Aucun --</option>
                                ${(project.characters || []).map(char => `
                                    <option value="${char.id}" ${card.pov === char.id ? 'selected' : ''}>
                                        ${char.name}
                                    </option>
                                `).join('')}
                            </select>
                        </div>
                        
                        <div class="form-group">
                            <label class="form-label">Couleur personnalisée</label>
                            <div class="storygrid-color-picker">
                                <input type="color" value="${card.color || row.color}" 
                                       onchange="updateCard('${cardId}', {color: this.value})">
                                <button class="btn btn-sm" onclick="updateCard('${cardId}', {color: null}); this.previousElementSibling.value='${row.color}';">
                                    Reset
                                </button>
                            </div>
                        </div>
                        
                        <div class="form-group">
                            <label class="form-label">Liens entre cartes</label>
                            <div class="storygrid-card-links">
                                ${renderCardLinks(cardId)}
                            </div>
                            <button class="btn btn-sm btn-outline" onclick="openAddLinkModal('${cardId}')">
                                <i data-lucide="link"></i> Ajouter un lien
                            </button>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-danger" onclick="confirmDeleteCard('${cardId}')">
                    <i data-lucide="trash-2"></i> Supprimer
                </button>
                <button class="btn btn-primary" onclick="closeModal('cardDetailModal')">Fermer</button>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
    
    if (typeof lucide !== 'undefined') {
        lucide.createIcons();
    }
}

// Rendu des liaisons d'entités (personnages, arcs, lieux) dans la modale
function renderCardEntityLinks(card) {
    return `
        <!-- Personnages liés -->
        <div class="storygrid-link-group">
            <div class="storygrid-link-group-header">
                <i data-lucide="user" style="color: #3498db;"></i>
                <span>Personnages</span>
                <button class="btn btn-xs btn-ghost" onclick="openAddCharacterToCardModal('${card.id}')">
                    <i data-lucide="plus"></i>
                </button>
            </div>
            <div class="storygrid-link-group-items" id="cardCharacterLinks">
                ${renderCardCharacters(card)}
            </div>
        </div>
        
        <!-- Arcs liés -->
        <div class="storygrid-link-group">
            <div class="storygrid-link-group-header">
                <i data-lucide="git-branch" style="color: #e74c3c;"></i>
                <span>Arcs narratifs</span>
                <button class="btn btn-xs btn-ghost" onclick="openAddArcToCardModal('${card.id}')">
                    <i data-lucide="plus"></i>
                </button>
            </div>
            <div class="storygrid-link-group-items" id="cardArcLinks">
                ${renderCardArcs(card)}
            </div>
        </div>
        
        <!-- Lieux liés -->
        <div class="storygrid-link-group">
            <div class="storygrid-link-group-header">
                <i data-lucide="map-pin" style="color: #27ae60;"></i>
                <span>Lieux</span>
                <button class="btn btn-xs btn-ghost" onclick="openAddLocationToCardModal('${card.id}')">
                    <i data-lucide="plus"></i>
                </button>
            </div>
            <div class="storygrid-link-group-items" id="cardLocationLinks">
                ${renderCardLocations(card)}
            </div>
        </div>
    `;
}

function renderCardCharacters(card) {
    if (!card.characters || card.characters.length === 0) {
        return '<div class="storygrid-no-links">Aucun personnage</div>';
    }
    
    return card.characters.map(charId => {
        const char = (project.characters || []).find(c => c.id === charId);
        if (!char) return '';
        return `
            <div class="storygrid-link-tag" style="--tag-color: ${char.color || '#3498db'}">
                <span>${char.name}</span>
                <button class="tag-remove" onclick="event.stopPropagation(); removeCharacterFromCard('${card.id}', '${charId}'); refreshCardDetailLinks('${card.id}');">
                    <i data-lucide="x"></i>
                </button>
            </div>
        `;
    }).join('');
}

function renderCardArcs(card) {
    if (!card.arcs || card.arcs.length === 0) {
        return '<div class="storygrid-no-links">Aucun arc</div>';
    }
    
    return card.arcs.map(arcId => {
        const arc = (project.narrativeArcs || []).find(a => a.id === arcId);
        if (!arc) return '';
        return `
            <div class="storygrid-link-tag" style="--tag-color: ${arc.color || '#e74c3c'}">
                <span>${arc.title}</span>
                <button class="tag-remove" onclick="event.stopPropagation(); removeArcFromCard('${card.id}', '${arcId}'); refreshCardDetailLinks('${card.id}');">
                    <i data-lucide="x"></i>
                </button>
            </div>
        `;
    }).join('');
}

function renderCardLocations(card) {
    if (!card.locations || card.locations.length === 0) {
        return '<div class="storygrid-no-links">Aucun lieu</div>';
    }
    
    // Lieux dans world
    const locations = (project.world || []).filter(w => w.type === 'location' || w.type === 'Lieu');
    
    return card.locations.map(locId => {
        const loc = locations.find(l => l.id === locId);
        if (!loc) return '';
        return `
            <div class="storygrid-link-tag" style="--tag-color: ${loc.color || '#27ae60'}">
                <span>${loc.name}</span>
                <button class="tag-remove" onclick="event.stopPropagation(); removeLocationFromCard('${card.id}', '${locId}'); refreshCardDetailLinks('${card.id}');">
                    <i data-lucide="x"></i>
                </button>
            </div>
        `;
    }).join('');
}

// RafraÃ®chir les liens dans la modale sans la fermer
function refreshCardDetailLinks(cardId) {
    const card = findCardById(cardId);
    if (!card) return;
    
    const linksGrid = document.getElementById('cardLinksGrid');
    if (linksGrid) {
        linksGrid.innerHTML = renderCardEntityLinks(card);
        if (typeof lucide !== 'undefined') {
            lucide.createIcons();
        }
    }
}

// Modale pour ajouter un personnage
function openAddCharacterToCardModal(cardId) {
    // Fermer si déjà ouverte
    const existing = document.getElementById('addCharacterModal');
    if (existing) existing.remove();
    
    const card = findCardById(cardId);
    if (!card) return;
    
    const availableChars = (project.characters || []).filter(c => 
        !card.characters || !card.characters.includes(c.id)
    );
    
    if (availableChars.length === 0) {
        alert('Tous les personnages sont déjà liés à cette carte.');
        return;
    }
    
    const modal = document.createElement('div');
    modal.className = 'modal active';
    modal.id = 'addCharacterModal';
    modal.dataset.dynamic = 'true';
    modal.style.zIndex = '10001';
    modal.innerHTML = `
        <div class="modal-content" style="max-width: 400px;">
            <div class="modal-header">
                <div class="modal-title"><i data-lucide="user"></i> Ajouter un personnage</div>
                <button class="modal-close" onclick="closeModal('addCharacterModal')">X</button>
            </div>
            <div class="modal-body">
                <div class="storygrid-add-link-list">
                    ${availableChars.map(char => `
                        <div class="storygrid-add-link-item" onclick="selectCharacterForCard('${cardId}', '${char.id}')">
                            <div class="item-icon" style="background: ${char.color || '#3498db'}20; color: ${char.color || '#3498db'}">
                                <i data-lucide="user"></i>
                            </div>
                            <span>${char.name}</span>
                        </div>
                    `).join('')}
                </div>
            </div>
        </div>
    `;
    
    // Fermer en cliquant sur le fond
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            closeModal('addCharacterModal');
        }
    });
    
    document.body.appendChild(modal);
    if (typeof lucide !== 'undefined') lucide.createIcons();
}

function selectCharacterForCard(cardId, characterId) {
    addCharacterToCard(cardId, characterId);
    closeModal('addCharacterModal');
    refreshCardDetailLinks(cardId);
}

// Modale pour ajouter un arc
function openAddArcToCardModal(cardId) {
    // Fermer si déjà ouverte
    const existing = document.getElementById('addArcModal');
    if (existing) existing.remove();
    
    const card = findCardById(cardId);
    if (!card) return;
    
    const availableArcs = (project.narrativeArcs || []).filter(a => 
        !card.arcs || !card.arcs.includes(a.id)
    );
    
    if (availableArcs.length === 0) {
        alert('Tous les arcs sont déjÃƒÂ  liés ÃƒÂ  cette carte.');
        return;
    }
    
    const modal = document.createElement('div');
    modal.className = 'modal active';
    modal.id = 'addArcModal';
    modal.dataset.dynamic = 'true';
    modal.style.zIndex = '10001';
    modal.innerHTML = `
        <div class="modal-content" style="max-width: 400px;">
            <div class="modal-header">
                <div class="modal-title"><i data-lucide="git-branch"></i> Ajouter un arc</div>
                <button class="modal-close" onclick="closeModal('addArcModal')">x</button>
            </div>
            <div class="modal-body">
                <div class="storygrid-add-link-list">
                    ${availableArcs.map(arc => `
                        <div class="storygrid-add-link-item" onclick="selectArcForCard('${cardId}', '${arc.id}')">
                            <div class="item-icon" style="background: ${arc.color || '#e74c3c'}20; color: ${arc.color || '#e74c3c'}">
                                <i data-lucide="git-branch"></i>
                            </div>
                            <span>${arc.title}</span>
                        </div>
                    `).join('')}
                </div>
            </div>
        </div>
    `;
    
    // Fermer en cliquant sur le fond
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            closeModal('addArcModal');
        }
    });
    
    document.body.appendChild(modal);
    if (typeof lucide !== 'undefined') lucide.createIcons();
}

function selectArcForCard(cardId, arcId) {
    addArcToCard(cardId, arcId);
    closeModal('addArcModal');
    refreshCardDetailLinks(cardId);
}

// Modale pour ajouter un lieu
function openAddLocationToCardModal(cardId) {
    // Fermer si déjà ouverte
    const existing = document.getElementById('addLocationModal');
    if (existing) existing.remove();
    
    const card = findCardById(cardId);
    if (!card) return;
    
    const locations = (project.world || []).filter(w => w.type === 'location' || w.type === 'Lieu');
    const availableLocs = locations.filter(l => 
        !card.locations || !card.locations.includes(l.id)
    );
    
    if (availableLocs.length === 0) {
        alert('Tous les lieux sont déjÃƒÂ  liés ÃƒÂ  cette carte.');
        return;
    }
    
    const modal = document.createElement('div');
    modal.className = 'modal active';
    modal.id = 'addLocationModal';
    modal.dataset.dynamic = 'true';
    modal.style.zIndex = '10001';
    modal.innerHTML = `
        <div class="modal-content" style="max-width: 400px;">
            <div class="modal-header">
                <div class="modal-title"><i data-lucide="map-pin"></i> Ajouter un lieu</div>
                <button class="modal-close" onclick="closeModal('addLocationModal')">x</button>
            </div>
            <div class="modal-body">
                <div class="storygrid-add-link-list">
                    ${availableLocs.map(loc => `
                        <div class="storygrid-add-link-item" onclick="selectLocationForCard('${cardId}', '${loc.id}')">
                            <div class="item-icon" style="background: ${loc.color || '#27ae60'}20; color: ${loc.color || '#27ae60'}">
                                <i data-lucide="map-pin"></i>
                            </div>
                            <span>${loc.name}</span>
                        </div>
                    `).join('')}
                </div>
            </div>
        </div>
    `;
    
    // Fermer en cliquant sur le fond
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            closeModal('addLocationModal');
        }
    });
    
    document.body.appendChild(modal);
    if (typeof lucide !== 'undefined') lucide.createIcons();
}

function selectLocationForCard(cardId, locationId) {
    addLocationToCard(cardId, locationId);
    closeModal('addLocationModal');
    refreshCardDetailLinks(cardId);
}

function renderCardLinks(cardId) {
    const links = storyGridState.links.filter(l => l.fromCard === cardId || l.toCard === cardId);
    
    if (links.length === 0) {
        return '<div class="storygrid-no-links">Aucun lien</div>';
    }
    
    return links.map(link => {
        const linkType = LINK_TYPES[link.type];
        const isFrom = link.fromCard === cardId;
        const otherCardId = isFrom ? link.toCard : link.fromCard;
        
        // Find other card
        let otherCard = null;
        for (const row of storyGridState.rows) {
            otherCard = row.cards.find(c => c.id === otherCardId);
            if (otherCard) break;
        }
        
        return `
            <div class="storygrid-link-item" style="border-left-color: ${linkType.color}">
                <div class="storygrid-link-info">
                    <span class="storygrid-link-type">${isFrom ? linkType.label : 'Lié ÃƒÂ '}</span>
                    <span class="storygrid-link-target">${otherCard?.title || 'Carte inconnue'}</span>
                </div>
                <button class="storygrid-link-remove" onclick="deleteCardLink('${link.id}'); openCardDetail('${cardId}');">
                    <i data-lucide="x"></i>
                </button>
            </div>
        `;
    }).join('');
}

function updateCardIntensity(cardId, intensity) {
    updateCard(cardId, { intensity });
    
    // Update UI without full re-render
    const buttons = document.querySelectorAll('.storygrid-intensity-selector .intensity-btn');
    buttons.forEach((btn, index) => {
        btn.classList.toggle('active', index < intensity);
    });
}

function confirmDeleteCard(cardId) {
    if (confirm('ÃŠtes-vous sÃƒÂ»r de vouloir supprimer cette carte ?')) {
        deleteCard(cardId);
        closeModal('cardDetailModal');
    }
}

function openAddLinkModal(fromCardId) {
    const modal = document.createElement('div');
    modal.className = 'modal active';
    modal.id = 'addLinkModal';
    modal.dataset.dynamic = 'true';
    modal.style.zIndex = '10001';
    
    // Get all cards except the current one
    const allCards = [];
    storyGridState.rows.forEach(row => {
        row.cards.forEach(card => {
            if (card.id !== fromCardId) {
                allCards.push({ ...card, rowTitle: row.title });
            }
        });
    });
    
    modal.innerHTML = `
        <div class="modal-content" style="max-width: 400px;">
            <div class="modal-header">
                <div class="modal-title">Ajouter un lien</div>
                <button class="modal-close" onclick="closeModal('addLinkModal')">x</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">Type de lien</label>
                    <select class="form-input" id="linkTypeSelect">
                        ${Object.entries(LINK_TYPES).map(([type, data]) => `
                            <option value="${type}">${data.label}</option>
                        `).join('')}
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label">Vers la carte</label>
                    <select class="form-input" id="linkTargetSelect">
                        <option value="">-- Sélectionner --</option>
                        ${allCards.map(card => `
                            <option value="${card.id}">[${card.rowTitle}] ${card.title}</option>
                        `).join('')}
                    </select>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeModal('addLinkModal')">Annuler</button>
                <button class="btn btn-primary" onclick="confirmAddLink('${fromCardId}')">Ajouter</button>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
}

function confirmAddLink(fromCardId) {
    const linkType = document.getElementById('linkTypeSelect').value;
    const toCardId = document.getElementById('linkTargetSelect').value;
    
    if (!toCardId) {
        alert('Veuillez sélectionner une carte cible.');
        return;
    }
    
    addCardLink(fromCardId, toCardId, linkType);
    closeModal('addLinkModal');
    openCardDetail(fromCardId); // Refresh detail modal
}

function openStoryGridSettings() {
    const settings = project.storyGrid?.settings || {};
    
    const modal = document.createElement('div');
    modal.className = 'modal active';
    modal.id = 'storyGridSettingsModal';
    modal.dataset.dynamic = 'true';
    modal.innerHTML = `
        <div class="modal-content" style="max-width: 400px;">
            <div class="modal-header">
                <div class="modal-title">Paramètres du Story Grid</div>
                <button class="modal-close" onclick="closeModal('storyGridSettingsModal')">x</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">Zoom par défaut</label>
                    <select class="form-input" id="sgDefaultZoom">
                        ${Object.entries(STORYGRID_ZOOM_LEVELS).map(([key, data]) => `
                            <option value="${key}" ${settings.defaultZoom === key ? 'selected' : ''}>
                                ${data.name} (${data.label})
                            </option>
                        `).join('')}
                    </select>
                </div>
                <div class="form-group">
                    <label class="toggle-label">
                        <input type="checkbox" id="sgShowEmptyCells" ${settings.showEmptyCells ? 'checked' : ''}>
                        <span>Afficher les cellules vides</span>
                    </label>
                </div>
                <div class="form-group">
                    <label class="toggle-label">
                        <input type="checkbox" id="sgSnapToGrid" ${settings.snapToGrid ? 'checked' : ''}>
                        <span>Alignement automatique</span>
                    </label>
                </div>
                <hr style="margin: 16px 0;">
                <div class="form-group">
                    <button class="btn btn-outline btn-block" onclick="resetStoryGrid()">
                        <i data-lucide="refresh-cw"></i> Réinitialiser le Story Grid
                    </button>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeModal('storyGridSettingsModal')">Annuler</button>
                <button class="btn btn-primary" onclick="saveStoryGridSettings()">Enregistrer</button>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
    
    if (typeof lucide !== 'undefined') {
        lucide.createIcons();
    }
}

function saveStoryGridSettings() {
    project.storyGrid.settings = {
        defaultZoom: document.getElementById('sgDefaultZoom').value,
        showEmptyCells: document.getElementById('sgShowEmptyCells').checked,
        snapToGrid: document.getElementById('sgSnapToGrid').checked
    };
    
    saveProject();
    closeModal('storyGridSettingsModal');
}

function resetStoryGrid() {
    if (confirm('ÃŠtes-vous sÃƒÂ»r de vouloir réinitialiser le Story Grid ? Toutes les lignes personnalisées et cartes seront supprimées.')) {
        storyGridState.rows = [];
        storyGridState.links = [];
        autoCreateRowsFromProject();
        closeModal('storyGridSettingsModal');
        renderStoryGrid();
    }
}

// ============================================
// WELCOME VIEW
// ============================================

function renderStoryGridWelcome() {
    const container = document.getElementById('editorView');
    if (!container) return;
    
    container.innerHTML = `
        <div class="empty-state">
            <div class="empty-state-icon"><i data-lucide="layout-grid"></i></div>
            <div class="empty-state-title">Story Grid</div>
            <div class="empty-state-text">
                Visualisez et organisez votre récit avec le tableau de bord narratif.<br>
                Suivez vos personnages, arcs et lieux ÃƒÂ  travers chaque scène.
            </div>
            <button class="btn btn-primary" onclick="renderStoryGrid()">
                <i data-lucide="play"></i> Ouvrir le Story Grid
            </button>
        </div>
    `;
    
    if (typeof lucide !== 'undefined') {
        lucide.createIcons();
    }
}

// ============================================
// SCENE LINKING
// ============================================

function linkSceneToCard(sceneId, cardId) {
    for (const row of storyGridState.rows) {
        const card = row.cards.find(c => c.id === cardId);
        if (card) {
            // Find scene data
            let sceneData = null;
            for (const act of project.acts) {
                for (const chapter of act.chapters || []) {
                    const scene = (chapter.scenes || []).find(s => s.id === sceneId);
                    if (scene) {
                        sceneData = scene;
                        break;
                    }
                }
                if (sceneData) break;
            }
            
            if (sceneData) {
                card.sceneId = sceneId;
                card.title = sceneData.title;
                card.summary = sceneData.summary || '';
                saveStoryGridData();
                renderStoryGrid();
            }
            return;
        }
    }
}

// ============================================
// EXPORT/IMPORT
// ============================================

function exportStoryGridData() {
    const data = {
        rows: storyGridState.rows,
        links: storyGridState.links,
        settings: project.storyGrid?.settings || {},
        exportedAt: new Date().toISOString()
    };
    
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `storygrid_${project.title || 'export'}_${Date.now()}.json`;
    a.click();
    URL.revokeObjectURL(url);
}

function importStoryGridData(file) {
    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const data = JSON.parse(e.target.result);
            if (data.rows && Array.isArray(data.rows)) {
                storyGridState.rows = data.rows;
                storyGridState.links = data.links || [];
                if (data.settings) {
                    project.storyGrid.settings = data.settings;
                }
                saveStoryGridData();
                renderStoryGrid();
            }
        } catch (error) {
            alert('Erreur lors de l\'importation: ' + error.message);
        }
    };
    reader.readAsText(file);
}

// ============================================
// SCENE NAVIGATION MODAL
// ============================================

function showSceneNavigationModal(actId, chapterId, sceneId) {
    // Trouver le titre de la scène
    let sceneTitle = 'Scène';
    const act = project.acts?.find(a => a.id === actId);
    if (act) {
        const chapter = act.chapters?.find(c => c.id === chapterId);
        if (chapter) {
            const scene = chapter.scenes?.find(s => s.id === sceneId);
            if (scene) {
                sceneTitle = scene.title || 'Scène sans titre';
            }
        }
    }
    
    // Créer la modale
    const modal = document.createElement('div');
    modal.className = 'modal active';
    modal.id = 'sceneNavigationModal';
    modal.dataset.dynamic = 'true';
    modal.innerHTML = `
        <div class="modal-content" style="max-width: 400px;">
            <div class="modal-header">
                <div class="modal-title">Ouvrir la scène</div>
                <button class="modal-close" onclick="closeModal('sceneNavigationModal')">Ã—</button>
            </div>
            <div class="modal-body">
                <p style="margin-bottom: 16px; color: var(--text-secondary);">
                    <strong>${sceneTitle}</strong>
                </p>
                <p style="margin-bottom: 20px; color: var(--text-secondary);">
                    Comment souhaitez-vous visualiser cette scène ?
                </p>
                
                <div class="scene-nav-options">
                    <div class="scene-nav-option" onclick="navigateToSceneFromGrid('${actId}', '${chapterId}', '${sceneId}')">
                        <div class="scene-nav-option-icon" style="color: #3498db;">
                            <i data-lucide="external-link"></i>
                        </div>
                        <div class="scene-nav-option-content">
                            <div class="scene-nav-option-title">Vue complète</div>
                            <div class="scene-nav-option-desc">Basculer vers la vue Structure (quitte la vue actuelle)</div>
                        </div>
                    </div>
                    
                    <div class="scene-nav-option" onclick="openSceneInSplitViewFromGrid('${actId}', '${chapterId}', '${sceneId}')">
                        <div class="scene-nav-option-icon" style="color: #27ae60;">
                            <i data-lucide="columns-2"></i>
                        </div>
                        <div class="scene-nav-option-content">
                            <div class="scene-nav-option-title">Split-view</div>
                            <div class="scene-nav-option-desc">Ouvrir la scène en vue séparée (conserve le Story Grid)</div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeModal('sceneNavigationModal')">Annuler</button>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
    if (typeof lucide !== 'undefined') lucide.createIcons();
}

function navigateToSceneFromGrid(actId, chapterId, sceneId) {
    closeModal('sceneNavigationModal');
    
    // Utiliser la navigation existante
    currentActId = actId;
    currentChapterId = chapterId;
    currentSceneId = sceneId;
    
    switchToView('structure');
    
    // Ouvrir la scène dans l'éditeur après un court délai
    setTimeout(() => {
        if (typeof openSceneEditor === 'function') {
            openSceneEditor(actId, chapterId, sceneId);
        }
    }, 100);
}

function openSceneInSplitViewFromGrid(actId, chapterId, sceneId) {
    closeModal('sceneNavigationModal');
    
    // Utiliser le système de split-view existant
    if (typeof openSplitView === 'function') {
        openSplitView('editor', {
            actId: actId,
            chapterId: chapterId,
            sceneId: sceneId
        });
    } else {
        // Fallback si la fonction n'existe pas
        navigateToSceneFromGrid(actId, chapterId, sceneId);
    }
}

// ========== 45.arc-board.js ==========
// ============================================
// ARC BOARD - Canvas System (Milanote-inspired)
// ============================================

// ============================================
// CONFIGURATION & TYPES
// ============================================

const ARC_BOARD_CONFIG = {
    minZoom: 0.25,
    maxZoom: 2,
    zoomStep: 0.1,
    gridSize: 24,
    defaultColumnWidth: 280,
    minColumnWidth: 200,
    maxColumnWidth: 500,
    canvasWidth: 3000,
    canvasHeight: 2000,
    snapToGrid: true
};

// Catégories d'arcs prédéfinies
const ARC_CATEGORIES = {
    intrigue: { label: 'Intrigue principale', icon: 'book-open', color: '#e74c3c' },
    subplot: { label: 'Intrigue secondaire', icon: 'file-text', color: '#16a085' },
    character: { label: 'Arc personnage', icon: 'user', color: '#3498db' },
    relationship: { label: 'Relation', icon: 'heart', color: '#e91e63' },
    theme: { label: 'Thème', icon: 'message-circle', color: '#9b59b6' },
    mystery: { label: 'Mystère', icon: 'search', color: '#607d8b' },
    worldbuilding: { label: 'Worldbuilding', icon: 'globe', color: '#1976d2' }
};

// Types de cartes
const CARD_TYPES = {
    note: { label: 'Note', icon: 'file-text' },
    image: { label: 'Image', icon: 'image' },
    link: { label: 'Lien', icon: 'link' },
    todo: { label: 'Tâches', icon: 'check-square' },
    comment: { label: 'Commentaire', icon: 'message-square' },
    table: { label: 'Tableau', icon: 'table' },
    audio: { label: 'Audio', icon: 'music' },
    divider: { label: 'Séparateur', icon: 'minus' }
};

// ============================================
// STATE MANAGEMENT
// ============================================

let arcBoardState = {
    currentArcId: null,
    zoom: 1,
    panX: 0,
    panY: 0,
    isPanning: false,
    panStartX: 0,
    panStartY: 0,
    selectedItems: [],
    connectionSource: null,  // Pour le mode connexion simplifié
    isDragging: false,
    dragItem: null,
    dragStartX: 0,
    dragStartY: 0,
    isResizing: false,
    resizeItem: null,
    clipboard: null,
    contextPanelOpen: false,
    activeTool: 'select',
    showingArcForm: false,
    showingCategoryForm: false,
    editingArcId: null,  // ID de l'arc en cours d'édition (null = création)
};

// ============================================
// INITIALIZATION
// ============================================

function initArcBoard() {
    // Initialiser les catégories custom si pas existantes
    if (!project.arcCategories) {
        project.arcCategories = {};
    }
    
    // Initialiser les arcs si pas existants
    if (!project.narrativeArcs) {
        project.narrativeArcs = [];
    }
}

// ============================================
// SIDEBAR TREEVIEW (Liste des arcs par catégorie)
// ============================================

function renderArcsBoardSidebar() {
    const list = document.getElementById('arcsList');
    if (!list) return;
    
    initArcBoard();
    
    const arcs = project.narrativeArcs || [];
    
    let html = '';
    
    // Formulaire de création d'arc (si actif)
    if (arcBoardState.showingArcForm) {
        html += renderInlineArcForm();
    }
    
    // Formulaire de création de catégorie (si actif)
    if (arcBoardState.showingCategoryForm) {
        html += renderInlineCategoryForm();
    }
    
    if (arcs.length === 0 && !arcBoardState.showingArcForm && !arcBoardState.showingCategoryForm) {
        html += `
            <div class="sidebar-empty">
                <div class="sidebar-empty-icon"><i data-lucide="layout-dashboard"></i></div>
                <p>Aucun arc narratif</p>
            </div>
        `;
    } else if (arcs.length > 0) {
        // Fusionner catégories prédéfinies et custom
        const allCategories = { ...ARC_CATEGORIES, ...project.arcCategories };
        
        // Grouper les arcs par catégorie
        const arcsByCategory = {};
        const uncategorized = [];
        
        arcs.forEach(arc => {
            const cat = arc.category || 'uncategorized';
            if (cat === 'uncategorized' || !allCategories[cat]) {
                uncategorized.push(arc);
            } else {
                if (!arcsByCategory[cat]) arcsByCategory[cat] = [];
                arcsByCategory[cat].push(arc);
            }
        });
        
        // Rendre les arcs non catégorisés en premier
        if (uncategorized.length > 0) {
            const isExpanded = !project.collapsedArcCategories || !project.collapsedArcCategories.includes('uncategorized');
            html += `
                <div class="sidebar-tree-category" data-category="uncategorized">
                    <div class="sidebar-tree-header" onclick="toggleArcCategory('uncategorized')">
                        <span class="sidebar-tree-toggle">
                            <i data-lucide="${isExpanded ? 'chevron-down' : 'chevron-right'}"></i>
                        </span>
                        <span class="sidebar-tree-icon" style="color: var(--text-muted)">
                            <i data-lucide="folder"></i>
                        </span>
                        <span class="sidebar-tree-label">Non catégorisé</span>
                        <span class="sidebar-tree-count">${uncategorized.length}</span>
                    </div>
                    <div class="sidebar-tree-children ${isExpanded ? '' : 'collapsed'}">
                        ${uncategorized.map(arc => renderArcTreeItem(arc)).join('')}
                    </div>
                </div>
            `;
        }
        
        // Rendre chaque catégorie
        Object.entries(allCategories).forEach(([catKey, catData]) => {
            const categoryArcs = arcsByCategory[catKey] || [];
            if (categoryArcs.length === 0) return;
            
            const isExpanded = !project.collapsedArcCategories || !project.collapsedArcCategories.includes(catKey);
            
            html += `
                <div class="sidebar-tree-category" data-category="${catKey}">
                    <div class="sidebar-tree-header" onclick="toggleArcCategory('${catKey}')">
                        <span class="sidebar-tree-toggle">
                            <i data-lucide="${isExpanded ? 'chevron-down' : 'chevron-right'}"></i>
                        </span>
                        <span class="sidebar-tree-icon" style="color: ${catData.color}">
                            <i data-lucide="${catData.icon}"></i>
                        </span>
                        <span class="sidebar-tree-label">${catData.label}</span>
                        <span class="sidebar-tree-count">${categoryArcs.length}</span>
                    </div>
                    <div class="sidebar-tree-children ${isExpanded ? '' : 'collapsed'}">
                        ${categoryArcs.map(arc => renderArcTreeItem(arc)).join('')}
                    </div>
                </div>
            `;
        });
    }
    
    // Bouton pour créer une catégorie (si pas en mode formulaire)
    if (!arcBoardState.showingCategoryForm && !arcBoardState.showingArcForm) {
        html += `
            <div class="sidebar-tree-add" onclick="showInlineCategoryForm()">
                <i data-lucide="folder-plus"></i>
                <span>Nouvelle catégorie</span>
            </div>
        `;
    }
    
    list.innerHTML = html;
    if (typeof lucide !== 'undefined') lucide.createIcons();
    
    // Focus sur le premier input si formulaire affiché
    if (arcBoardState.showingArcForm) {
        const input = document.getElementById('inlineArcTitle');
        if (input) input.focus();
    } else if (arcBoardState.showingCategoryForm) {
        const input = document.getElementById('inlineCategoryName');
        if (input) input.focus();
    }
}
// ============================================
// FORMULAIRE INLINE - CRÉATION DE CATÉGORIE
// ============================================

function renderInlineCategoryForm() {
    return `
        <div class="sidebar-inline-form">
            <div class="sidebar-inline-form-header">
                <i data-lucide="folder-plus"></i>
                <span>Nouvelle catégorie</span>
                <button class="sidebar-inline-form-close" onclick="cancelInlineCategoryForm()">
                    <i data-lucide="x"></i>
                </button>
            </div>
            <div class="sidebar-inline-form-body">
            <input type="hidden" id="inlineArcId" value="">
                <div class="sidebar-inline-form-group">
                    <label>Nom *</label>
                    <input type="text" id="inlineCategoryName" class="sidebar-inline-input" 
                           placeholder="Ex: Arcs de croissance"
                           onkeydown="handleInlineCategoryKeydown(event)">
                </div>
                <div class="sidebar-inline-form-group">
                    <label>Couleur</label>
                    <div class="sidebar-inline-color-row">
                        <input type="color" id="inlineCategoryColor" value="#6c757d" class="sidebar-inline-color">
                    </div>
                </div>
                <div class="sidebar-inline-form-actions">
                    <button class="btn-secondary btn-sm" onclick="cancelInlineCategoryForm()">Annuler</button>
                    <button class="btn-primary btn-sm" onclick="confirmInlineCategoryForm()">
                        <i data-lucide="plus"></i> Créer
                    </button>
                </div>
            </div>
        </div>
    `;
}

function showInlineCategoryForm() {
    arcBoardState.showingCategoryForm = true;
    arcBoardState.showingArcForm = false;
    renderArcsBoardSidebar();
}

// Remplacer l'ancienne fonction
function showAddCategoryModal() {
    showInlineCategoryForm();
}

function cancelInlineCategoryForm() {
    arcBoardState.showingCategoryForm = false;
    renderArcsBoardSidebar();
}

function handleInlineCategoryKeydown(event) {
    if (event.key === 'Enter') {
        confirmInlineCategoryForm();
    } else if (event.key === 'Escape') {
        cancelInlineCategoryForm();
    }
}

function confirmInlineCategoryForm() {
    const name = document.getElementById('inlineCategoryName').value.trim();
    const color = document.getElementById('inlineCategoryColor').value;
    
    if (!name) {
        document.getElementById('inlineCategoryName').classList.add('error');
        document.getElementById('inlineCategoryName').focus();
        return;
    }
    
    const key = name.toLowerCase().replace(/[^a-z0-9]/g, '_').replace(/_+/g, '_');
    
    if (!project.arcCategories) project.arcCategories = {};
    
    project.arcCategories[key] = {
        label: name,
        icon: 'folder',
        color: color,
        custom: true
    };
    
    saveProject();
    arcBoardState.showingCategoryForm = false;
    renderArcsBoardSidebar();
}


function renderInlineArcForm() {
    const allCategories = { ...ARC_CATEGORIES, ...project.arcCategories };
    const categoryOptions = Object.entries(allCategories).map(([key, cat]) => 
        `<option value="${key}">${cat.label}</option>`
    ).join('');
    
    // Vérifier si on est en mode édition
    const editingArc = arcBoardState.editingArcId 
        ? project.narrativeArcs.find(a => a.id === arcBoardState.editingArcId) 
        : null;
    
    const isEditing = !!editingArc;
    const formTitle = isEditing ? `Modifier l'arc` : 'Nouvel arc narratif';
    const formIcon = isEditing ? 'settings' : 'sparkles';
    const buttonText = isEditing ? 'Enregistrer' : 'Créer';
    const buttonIcon = isEditing ? 'save' : 'plus';
    
    // Valeurs par défaut ou valeurs de l'arc existant
    const arcId = editingArc?.id || '';
    const arcTitle = editingArc?.title || '';
    const arcCategory = editingArc?.category || 'intrigue';
    const arcColor = editingArc?.color || '#e74c3c';
    
    return `
        <div class="sidebar-inline-form" id="arc-form-panel">
            <div class="sidebar-inline-form-header">
                <i data-lucide="${formIcon}"></i>
                <span>${formTitle}</span>
                <button class="sidebar-inline-form-close" onclick="cancelInlineArcForm()">
                    <i data-lucide="x"></i>
                </button>
            </div>
            <div class="sidebar-inline-form-body">
                <input type="hidden" id="inlineArcId" value="${arcId}"> 
                <div class="sidebar-inline-form-group">
                    <label>Titre *</label>
                    <input type="text" id="inlineArcTitle" class="sidebar-inline-input" 
                           placeholder="Ex: La quête de rédemption"
                           value="${arcTitle.replace(/"/g, '&quot;')}"
                           onkeydown="handleInlineArcKeydown(event)">
                </div>
                <div class="sidebar-inline-form-group">
                    <label>Catégorie</label>
                    <select id="inlineArcCategory" class="sidebar-inline-select" onchange="updateInlineArcColor()">
                        ${Object.entries(allCategories).map(([key, cat]) => 
                            `<option value="${key}" ${key === arcCategory ? 'selected' : ''}>${cat.label}</option>`
                        ).join('')}
                    </select>
                </div>
                <div class="sidebar-inline-form-group">
                    <label>Couleur</label>
                    <div class="sidebar-inline-color-row">
                        <input type="color" id="inlineArcColor" value="${arcColor}" class="sidebar-inline-color">
                        <span id="inlineArcColorHex" class="sidebar-inline-color-hex">${arcColor}</span>
                    </div>
                </div>
                <div class="sidebar-inline-form-actions">
                    <button class="btn-secondary btn-sm" onclick="cancelInlineArcForm()">Annuler</button>
                    <button class="btn-primary btn-sm" onclick="confirmInlineArcForm()">
                        <i data-lucide="${buttonIcon}"></i> ${buttonText}
                    </button>
                </div>
            </div>
        </div>
    `;
}


function renderArcTreeItem(arc) {
    const isActive = arcBoardState.currentArcId === arc.id;
    const allCategories = { ...ARC_CATEGORIES, ...project.arcCategories };
    const catData = allCategories[arc.category] || { color: '#999' };
    
    return `
        <div class="sidebar-tree-item ${isActive ? 'active' : ''}" 
             onclick="openArcBoard('${arc.id}')" 
             data-arc-id="${arc.id}">
            <span class="sidebar-tree-item-dot" style="background: ${arc.color || catData.color}"></span>
            <span class="sidebar-tree-item-title">${arc.title || 'Sans titre'}</span>
            <button class="sidebar-tree-item-menu" onclick="event.stopPropagation(); showArcContextMenu(event, '${arc.id}')">
                <i data-lucide="more-horizontal"></i>
            </button>
        </div>
    `;
}
function showInlineArcForm(arcId = null) { 
    // Nettoyer l'ID des guillemets doubles et simples (Mesure de sécurité)
    if (typeof arcId === 'string') {
        arcId = arcId.replace(/['\"]/g, '').trim(); 
        if (arcId === '') arcId = null;
    }
    
    // Stocker l'ID de l'arc à éditer (null = mode création)
    arcBoardState.editingArcId = arcId;
    arcBoardState.showingArcForm = true;
    arcBoardState.showingCategoryForm = false;
    
    // Rendre la sidebar (le formulaire sera pré-rempli automatiquement)
    renderArcsBoardSidebar(); 
    
    // Focus sur le champ titre
    const input = document.getElementById('inlineArcTitle');
    if (input) input.focus();
}

function cancelInlineArcForm() {
    arcBoardState.showingArcForm = false;
    arcBoardState.editingArcId = null;
    renderArcsBoardSidebar();
}

function handleInlineArcKeydown(event) {
    if (event.key === 'Enter') {
        confirmInlineArcForm();
    } else if (event.key === 'Escape') {
        cancelInlineArcForm();
    }
}

function updateInlineArcColor() {
    const category = document.getElementById('inlineArcCategory').value;
    const allCategories = { ...ARC_CATEGORIES, ...project.arcCategories };
    if (allCategories[category]) {
        document.getElementById('inlineArcColor').value = allCategories[category].color;
        document.getElementById('inlineArcColorHex').textContent = allCategories[category].color;
    }
}

function confirmInlineArcForm() {
    // 1. Récupérer l'ID, le titre, la catégorie et la couleur
    const arcId = document.getElementById('inlineArcId').value; // Récupère l'ID caché
    const title = document.getElementById('inlineArcTitle').value.trim();
    const category = document.getElementById('inlineArcCategory').value;
    const color = document.getElementById('inlineArcColor').value;
    
    if (!title) {
        document.getElementById('inlineArcTitle').classList.add('error');
        document.getElementById('inlineArcTitle').focus();
        return;
    }

    // Réinitialiser la classe d'erreur
    document.getElementById('inlineArcTitle').classList.remove('error');
    
    let targetArc;

    if (arcId) {
        // --- MODE ÉDITION : Mise à jour de l'arc existant ---
        targetArc = project.narrativeArcs.find(a => a.id === arcId);
        if (targetArc) {
            targetArc.title = title;
            targetArc.category = category;
            targetArc.color = color;
            targetArc.updated = new Date().toISOString();
        } else {
            console.error('Arc to edit not found:', arcId);
            return;
        }
        
    } else {
        // --- MODE CRÉATION : Code existant pour créer un nouvel arc ---
        const newArcId = generateUniqueId('arc');
        targetArc = {
            id: newArcId,
            title: title,
            category: category,
            color: color,
            description: '',
            created: new Date().toISOString(),
            updated: new Date().toISOString(),
            board: {
                items: [],
                connections: []
            },
            type: category,
            importance: 'major',
            relatedCharacters: [],
            resolution: { type: 'ongoing', sceneId: null },
            scenePresence: []
        };
        
        if (!project.narrativeArcs) project.narrativeArcs = [];
        project.narrativeArcs.push(targetArc);
    }
    
    saveProject();
    
    arcBoardState.showingArcForm = false;
    arcBoardState.editingArcId = null;
    renderArcsBoardSidebar();
    
    // Après édition/création, passer à l'arc concerné
    openArcBoard(targetArc.id); 
}


function toggleArcCategory(categoryKey) {
    if (!project.collapsedArcCategories) {
        project.collapsedArcCategories = [];
    }
    
    const index = project.collapsedArcCategories.indexOf(categoryKey);
    if (index === -1) {
        project.collapsedArcCategories.push(categoryKey);
    } else {
        project.collapsedArcCategories.splice(index, 1);
    }
    
    saveProject();
    renderArcsBoardSidebar();
}

// ============================================
// CRÉATION D'ARC
// ============================================

function createNewArcBoard() {
    showInlineArcForm();
}

function closeCreateArcModal(event) {
    if (event && event.target !== event.currentTarget) return;
    const modal = document.getElementById('createArcModal');
    if (modal) modal.remove();
}

function confirmCreateArc() {
    const title = document.getElementById('newArcTitle').value.trim();
    const category = document.getElementById('newArcCategory').value;
    const color = document.getElementById('newArcColor').value;
    const description = document.getElementById('newArcDescription').value.trim();
    
    if (!title) {
        alert('Veuillez entrer un titre pour l\'arc');
        document.getElementById('newArcTitle').focus();
        return;
    }
    
    const newArc = {
        id: 'arc_' + Date.now(),
        title: title,
        category: category,
        color: color,
        description: description,
        created: new Date().toISOString(),
        updated: new Date().toISOString(),
        // Board data
        board: {
            items: [],
            connections: []
        },
        // Legacy compatibility
        type: category,
        importance: 'major',
        relatedCharacters: [],
        resolution: { type: 'ongoing', sceneId: null },
        scenePresence: []
    };
    
    if (!project.narrativeArcs) project.narrativeArcs = [];
    project.narrativeArcs.push(newArc);
    saveProject();
    
    closeCreateArcModal();
    renderArcsBoardSidebar();
    openArcBoard(newArc.id);
}

// ============================================
// OUVERTURE DU BOARD D'UN ARC
// ============================================

function openArcBoard(arcId) {
    const arc = project.narrativeArcs.find(a => a.id === arcId);
    if (!arc) return;
    
    // Initialiser le board si nécessaire
    if (!arc.board) {
        arc.board = {
            items: [],
            connections: []
        };
    }
    
    arcBoardState.currentArcId = arcId;
    arcBoardState.selectedItems = [];
    arcBoardState.zoom = 1;
    arcBoardState.panX = 0;
    arcBoardState.panY = 0;
    
    renderArcsBoardSidebar();
    renderArcBoardCanvas(arc);
}

// ============================================
// RENDU DU CANVAS
// ============================================

function renderArcBoardCanvas(arc) {
    const view = document.getElementById('editorView');
    if (!view) return;
    
    view.innerHTML = `
        <div class="arc-board-container">
            <!-- Toolbar gauche -->
            <div class="arc-board-toolbar">
                <button class="arc-toolbar-btn ${arcBoardState.activeTool === 'select' ? 'active' : ''}" 
                        data-tooltip="Sélection" onclick="setArcTool('select')">
                    <i data-lucide="mouse-pointer-2"></i>
                </button>
                <button class="arc-toolbar-btn ${arcBoardState.activeTool === 'pan' ? 'active' : ''}" 
                        data-tooltip="Déplacer" onclick="setArcTool('pan')">
                    <i data-lucide="hand"></i>
                </button>
                
                <div class="arc-toolbar-separator"></div>
                
                <button class="arc-toolbar-btn" data-tooltip="Note" onclick="addArcItem('note')">
                    <i data-lucide="file-text"></i>
                </button>
                <button class="arc-toolbar-btn" data-tooltip="Colonne" onclick="addArcItem('column')">
                    <i data-lucide="columns-3"></i>
                </button>
                <button class="arc-toolbar-btn" data-tooltip="Lien" onclick="addArcItem('link')">
                    <i data-lucide="link"></i>
                </button>
                <button class="arc-toolbar-btn" data-tooltip="Tâches" onclick="addArcItem('todo')">
                    <i data-lucide="check-square"></i>
                </button>
                <button class="arc-toolbar-btn" data-tooltip="Commentaire" onclick="addArcItem('comment')">
                    <i data-lucide="message-square"></i>
                </button>
                <button class="arc-toolbar-btn" data-tooltip="Tableau" onclick="addArcItem('table')">
                    <i data-lucide="table"></i>
                </button>
                
                <div class="arc-toolbar-separator"></div>
                
                <button class="arc-toolbar-btn" data-tooltip="Image" onclick="addArcItem('image')">
                    <i data-lucide="image"></i>
                </button>
                <button class="arc-toolbar-btn" data-tooltip="Upload" onclick="triggerArcUpload()">
                    <i data-lucide="upload"></i>
                </button>
                
                <div class="arc-toolbar-separator"></div>
                
                <button class="arc-toolbar-btn ${arcBoardState.activeTool === 'connect' ? 'active' : ''}" 
                        data-tooltip="Connexion (cliquer sur source puis cible)" onclick="toggleConnectionMode()">
                    <i data-lucide="git-branch"></i>
                </button>
                
                <div style="flex:1"></div>
                
                <button class="arc-toolbar-btn" data-tooltip="Supprimer sélection" onclick="deleteSelectedItems()">
                    <i data-lucide="trash-2"></i>
                </button>
            </div>
            
            <!-- Canvas principal -->
            <div class="arc-board-canvas-wrapper">
                <div class="arc-board-canvas" id="arcBoardCanvas"
                     onmousedown="handleCanvasMouseDown(event)"
                     onmousemove="handleCanvasMouseMove(event)"
                     onmouseup="handleCanvasMouseUp(event)"
                     onwheel="handleCanvasWheel(event)"
                     oncontextmenu="handleCanvasContextMenu(event)"
                     ondrop="handleCanvasDrop(event)"
                     ondragover="handleCanvasDragOver(event)"
                     ondragleave="handleCanvasDragLeave(event)">
                    
                    <div class="arc-board-content" id="arcBoardContent" 
                         style="transform: scale(${arcBoardState.zoom}) translate(${arcBoardState.panX}px, ${arcBoardState.panY}px)">
                        
                        <!-- Layer des connexions SVG -->
                        <div class="arc-connections-layer" id="arcConnectionsLayer">
                            <svg id="arcConnectionsSvg">
                                <defs>
                                    <marker id="arrowhead" markerWidth="10" markerHeight="7" 
                                            refX="9" refY="3.5" orient="auto">
                                        <polygon points="0 0, 10 3.5, 0 7" class="arc-connection-arrow"/>
                                    </marker>
                                </defs>
                            </svg>
                        </div>
                        
                        <!-- Items du board -->
                        <div id="arcBoardItems"></div>
                        
                    </div>
                    
                    <!-- Message mode connexion -->
                    <div class="arc-connection-mode-hint" id="connectionModeHint" style="display:none">
                        <i data-lucide="git-branch"></i>
                        <span id="connectionHintText">Cliquez sur l'élément source</span>
                        <button onclick="cancelConnectionMode()"><i data-lucide="x"></i> Annuler</button>
                    </div>
                    
                    ${arc.board.items.length === 0 ? `
                        <div class="arc-board-empty">
                            <div class="arc-board-empty-icon"><i data-lucide="layout-dashboard"></i></div>
                            <div class="arc-board-empty-title">Board vide</div>
                            <div class="arc-board-empty-text">
                                Utilisez la barre d'outils à gauche pour ajouter<br>
                                des colonnes, notes, images et plus encore.
                            </div>
                        </div>
                    ` : ''}
                </div>
                
                <!-- Zoom controls -->
                <div class="arc-zoom-controls">
                    <button class="arc-zoom-btn" onclick="zoomArcBoard(-1)" title="Zoom arrière">
                        <i data-lucide="zoom-out"></i>
                    </button>
                    <span class="arc-zoom-level" id="arcZoomLevel">${Math.round(arcBoardState.zoom * 100)}%</span>
                    <button class="arc-zoom-btn" onclick="zoomArcBoard(1)" title="Zoom avant">
                        <i data-lucide="zoom-in"></i>
                    </button>
                    <button class="arc-zoom-btn" onclick="resetArcZoom()" title="Réinitialiser">
                        <i data-lucide="maximize-2"></i>
                    </button>
                </div>
            </div>
            
            <!-- Panneau contextuel (droite) -->
            <div class="arc-board-context-panel ${arcBoardState.contextPanelOpen ? '' : 'collapsed'}" id="arcContextPanel">
                <div class="arc-context-header">
                    <div class="arc-context-title">
                        <i data-lucide="sliders-horizontal"></i>
                        <span>Propriétés</span>
                    </div>
                    <button class="arc-context-close" onclick="toggleArcContextPanel()">
                        <i data-lucide="x"></i>
                    </button>
                </div>
                <div class="arc-context-body" id="arcContextBody">
                    <!-- Contenu dynamique selon sélection -->
                    ${renderArcContextDefault(arc)}
                </div>
            </div>
        </div>
        
        <!-- Input file caché pour upload -->
        <input type="file" id="arcFileInput" style="display:none" accept="image/*" onchange="handleArcFileUpload(event)">
    `;
    
    if (typeof lucide !== 'undefined') lucide.createIcons();
    
    // Rendre les items existants
    renderArcBoardItems(arc);
    renderArcConnections(arc);
}

// ============================================
// RENDU DES ITEMS
// ============================================

function renderArcBoardItems(arc) {
    const container = document.getElementById('arcBoardItems');
    if (!container || !arc.board) return;
    
    container.innerHTML = arc.board.items.map(item => renderArcItem(item)).join('');
    
    if (typeof lucide !== 'undefined') lucide.createIcons();
    
    // Masquer l'empty state si items présents
    const emptyState = document.querySelector('.arc-board-empty');
    if (emptyState) {
        emptyState.style.display = arc.board.items.length > 0 ? 'none' : 'block';
    }
}

function renderArcItem(item) {
    const isSelected = arcBoardState.selectedItems.includes(item.id);
    
    switch (item.type) {
        case 'column':
            return renderArcColumn(item, isSelected);
        case 'note':
            return renderArcNote(item, isSelected);
        case 'image':
            return renderArcImage(item, isSelected);
        case 'link':
            return renderArcLink(item, isSelected);
        case 'todo':
            return renderArcTodo(item, isSelected);
        case 'comment':
            return renderArcComment(item, isSelected);
        case 'table':
            return renderArcTable(item, isSelected);
        default:
            return '';
    }
}

function renderArcColumn(item, isSelected) {
    const cardsHtml = (item.cards || []).map(card => renderArcCard(card, item.id)).join('');
    const cardCount = (item.cards || []).length;
    
    return `
        <div class="arc-column ${isSelected ? 'selected' : ''}" 
             id="item-${item.id}"
             data-item-id="${item.id}"
             data-item-type="column"
             style="left: ${item.x}px; top: ${item.y}px; width: ${item.width || ARC_BOARD_CONFIG.defaultColumnWidth}px"
             onmousedown="handleItemMouseDown(event, '${item.id}')"
             onclick="selectArcItem(event, '${item.id}')">
            
            <div class="arc-column-header">
                <input type="text" class="arc-column-title" value="${item.title || ''}" 
                       placeholder="Titre de la colonne"
                       onchange="updateArcItemTitle('${item.id}', this.value)"
                       onclick="event.stopPropagation()">
                <span class="arc-column-meta">${cardCount} carte${cardCount > 1 ? 's' : ''}</span>
            </div>
            
            <div class="arc-column-body" 
                 ondrop="handleCardDrop(event, '${item.id}')"
                 ondragover="handleCardDragOver(event)"
                 ondragleave="handleCardDragLeave(event)">
                ${cardsHtml}
                <div class="arc-card-add" onclick="event.stopPropagation(); addCardToColumn('${item.id}')">
                    <i data-lucide="plus"></i> Ajouter une carte
                </div>
            </div>
            
            <div class="arc-column-resize" onmousedown="startColumnResize(event, '${item.id}')"></div>
        </div>
    `;
}

function renderArcCard(card, columnId) {
    // Bouton de suppression commun à toutes les cartes
    const deleteBtn = `
        <button class="arc-card-delete" onclick="deleteArcCard(event, '${columnId}', '${card.id}')" title="Supprimer">
            <i data-lucide="x"></i>
        </button>
    `;
    
    // Attributs communs de drag
    const dragAttrs = `draggable="true" ondragstart="handleCardDragStart(event, '${card.id}', '${columnId}')" ondragend="handleCardDragEnd(event)"`;
    
    switch (card.type) {
        case 'note':
            return `
                <div class="arc-card arc-card-note" data-card-id="${card.id}" ${dragAttrs}
                     onclick="selectArcCard(event, '${card.id}', '${columnId}')">
                    ${deleteBtn}
                    <div class="arc-card-content" contenteditable="true"
                         onblur="updateArcCardContent('${columnId}', '${card.id}', this.innerHTML)"
                         onclick="event.stopPropagation()">${card.content || ''}</div>
                </div>
            `;
        
        case 'image':
            return `
                <div class="arc-card arc-card-image" data-card-id="${card.id}" ${dragAttrs}
                     onclick="selectArcCard(event, '${card.id}', '${columnId}')">
                    ${deleteBtn}
                    ${card.src ? 
                        `<img src="${card.src}" alt="">` : 
                        `<div class="arc-card-upload" onclick="triggerCardImageUpload('${columnId}', '${card.id}')">
                            <i data-lucide="cloud-upload"></i>
                            <span>Ajouter une image</span>
                        </div>`
                    }
                    ${card.caption ? `<div class="arc-card-caption">${card.caption}</div>` : ''}
                </div>
            `;
        
        case 'link':
            return `
                <div class="arc-card arc-card-link" data-card-id="${card.id}" ${dragAttrs}
                     onclick="selectArcCard(event, '${card.id}', '${columnId}')">
                    ${deleteBtn}
                    ${card.url ? `
                        <div class="arc-link-preview">
                            ${card.previewImage ? `<div class="arc-link-preview-image" style="background-image:url(${card.previewImage})"></div>` : ''}
                            <div class="arc-link-preview-info">
                                <div class="arc-link-preview-title">${card.title || card.url}</div>
                                <div class="arc-link-preview-url">${card.url}</div>
                            </div>
                        </div>
                    ` : `
                        <div class="arc-link-input">
                            <i data-lucide="link"></i>
                            <input type="text" placeholder="Entrer une URL" 
                                   onkeypress="handleLinkInput(event, '${columnId}', '${card.id}')"
                                   onclick="event.stopPropagation()">
                        </div>
                    `}
                </div>
            `;
        
        case 'todo':
            const todosHtml = (card.items || []).map((todo, idx) => `
                <div class="arc-todo-item">
                    <div class="arc-todo-checkbox ${todo.completed ? 'checked' : ''}"
                         onclick="toggleArcTodo('${columnId}', '${card.id}', ${idx})">
                        ${todo.completed ? '<i data-lucide="check"></i>' : ''}
                    </div>
                    <input type="text" class="arc-todo-text ${todo.completed ? 'completed' : ''}"
                           value="${todo.text || ''}"
                           onchange="updateArcTodoText('${columnId}', '${card.id}', ${idx}, this.value)"
                           onclick="event.stopPropagation()">
                </div>
            `).join('');
            
            return `
                <div class="arc-card arc-card-todo" data-card-id="${card.id}" ${dragAttrs}
                     onclick="selectArcCard(event, '${card.id}', '${columnId}')">
                    ${deleteBtn}
                    <input type="text" class="arc-card-title" value="${card.title || ''}"
                           placeholder="Titre de la liste"
                           onchange="updateArcCardTitle('${columnId}', '${card.id}', this.value)"
                           onclick="event.stopPropagation()">
                    <div class="arc-todo-list">
                        ${todosHtml}
                    </div>
                    <div class="arc-todo-add" onclick="addArcTodoItem('${columnId}', '${card.id}'); event.stopPropagation();">
                        <i data-lucide="plus"></i> Ajouter une tâche...
                    </div>
                    ${card.assignee ? `<button class="arc-todo-assign">${card.assignee}</button>` : 
                        `<button class="arc-todo-assign" onclick="assignArcTodo('${columnId}', '${card.id}'); event.stopPropagation();">Assigner à</button>`}
                </div>
            `;
        
        case 'audio':
            return `
                <div class="arc-card arc-card-audio" data-card-id="${card.id}" ${dragAttrs}
                     onclick="selectArcCard(event, '${card.id}', '${columnId}')">
                    ${deleteBtn}
                    <div class="arc-audio-placeholder">
                        <i data-lucide="music"></i>
                        <span>${card.url ? 'Audio embed' : 'Coller un lien Spotify ou SoundCloud'}</span>
                    </div>
                </div>
            `;
        
        default:
            return `
                <div class="arc-card arc-card-note" data-card-id="${card.id}" ${dragAttrs}
                     onclick="selectArcCard(event, '${card.id}', '${columnId}')">
                    ${deleteBtn}
                    <div class="arc-card-content">${card.content || ''}</div>
                </div>
            `;
    }
}

// Fonction pour supprimer une carte
function deleteArcCard(event, columnId, cardId) {
    event.stopPropagation();
    event.preventDefault();
    
    const arc = project.narrativeArcs.find(a => a.id === arcBoardState.currentArcId);
    if (!arc) return;
    
    const column = arc.board.items.find(i => i.id === columnId);
    if (!column || !column.cards) return;
    
    column.cards = column.cards.filter(c => c.id !== cardId);
    
    saveProject();
    renderArcBoardItems(arc);
}

// Fonction pour fin de drag
function handleCardDragEnd(event) {
    event.target.classList.remove('dragging');
}

function renderArcNote(item, isSelected) {
    return `
        <div class="arc-floating-item arc-floating-note ${isSelected ? 'selected' : ''}"
             id="item-${item.id}"
             data-item-id="${item.id}"
             data-item-type="note"
             style="left: ${item.x}px; top: ${item.y}px; width: ${item.width || 250}px"
             draggable="true"
             ondragstart="handleFloatingDragStart(event, '${item.id}')"
             ondragend="handleFloatingDragEnd(event)"
             onmousedown="handleItemMouseDown(event, '${item.id}')"
             onclick="selectArcItem(event, '${item.id}')">
            <div class="arc-card-content" contenteditable="true"
                 onblur="updateArcItemContent('${item.id}', this.innerHTML)"
                 onclick="event.stopPropagation()">${item.content || ''}</div>
        </div>
    `;
}

function renderArcImage(item, isSelected) {
    return `
        <div class="arc-floating-item arc-floating-image ${isSelected ? 'selected' : ''}"
             id="item-${item.id}"
             data-item-id="${item.id}"
             data-item-type="image"
             style="left: ${item.x}px; top: ${item.y}px"
             draggable="true"
             ondragstart="handleFloatingDragStart(event, '${item.id}')"
             ondragend="handleFloatingDragEnd(event)"
             onmousedown="handleItemMouseDown(event, '${item.id}')"
             onclick="selectArcItem(event, '${item.id}')">
            ${item.src ? 
                `<img src="${item.src}" alt="" style="max-width: ${item.width || 300}px" draggable="false">` :
                `<div class="arc-card-upload" style="padding: 40px" onclick="triggerItemImageUpload('${item.id}')">
                    <i data-lucide="cloud-upload"></i>
                    <span>Ajouter une image</span>
                </div>`
            }
        </div>
    `;
}

function renderArcLink(item, isSelected) {
    return `
        <div class="arc-floating-item ${isSelected ? 'selected' : ''}"
             id="item-${item.id}"
             data-item-id="${item.id}"
             data-item-type="link"
             style="left: ${item.x}px; top: ${item.y}px; width: 280px"
             draggable="true"
             ondragstart="handleFloatingDragStart(event, '${item.id}')"
             ondragend="handleFloatingDragEnd(event)"
             onmousedown="handleItemMouseDown(event, '${item.id}')"
             onclick="selectArcItem(event, '${item.id}')">
            <div class="arc-card arc-card-link" style="margin:0">
                ${item.url ? `
                    <div class="arc-link-preview">
                        <div class="arc-link-preview-info">
                            <div class="arc-link-preview-title">${item.title || item.url}</div>
                            <div class="arc-link-preview-url">${item.url}</div>
                        </div>
                    </div>
                ` : `
                    <div class="arc-link-input">
                        <i data-lucide="link"></i>
                        <input type="text" placeholder="Entrer une URL"
                               onkeypress="handleFloatingLinkInput(event, '${item.id}')"
                               onclick="event.stopPropagation()">
                    </div>
                `}
            </div>
        </div>
    `;
}

function renderArcTodo(item, isSelected) {
    const todosHtml = (item.items || []).map((todo, idx) => `
        <div class="arc-todo-item">
            <div class="arc-todo-checkbox ${todo.completed ? 'checked' : ''}"
                 onclick="toggleFloatingTodo('${item.id}', ${idx})">
                ${todo.completed ? '<i data-lucide="check"></i>' : ''}
            </div>
            <input type="text" class="arc-todo-text ${todo.completed ? 'completed' : ''}"
                   value="${todo.text || ''}"
                   onchange="updateFloatingTodoText('${item.id}', ${idx}, this.value)"
                   onclick="event.stopPropagation()">
        </div>
    `).join('');
    
    return `
        <div class="arc-floating-item ${isSelected ? 'selected' : ''}"
             id="item-${item.id}"
             data-item-id="${item.id}"
             data-item-type="todo"
             style="left: ${item.x}px; top: ${item.y}px; width: 260px"
             draggable="true"
             ondragstart="handleFloatingDragStart(event, '${item.id}')"
             ondragend="handleFloatingDragEnd(event)"
             onmousedown="handleItemMouseDown(event, '${item.id}')"
             onclick="selectArcItem(event, '${item.id}')">
            <div class="arc-card arc-card-todo" style="margin:0">
                <input type="text" class="arc-card-title" value="${item.title || ''}"
                       placeholder="Liste de tâches"
                       onchange="updateArcItemTitle('${item.id}', this.value)"
                       onclick="event.stopPropagation()">
                <div class="arc-todo-list">${todosHtml}</div>
                <div class="arc-todo-add" onclick="addFloatingTodoItem('${item.id}'); event.stopPropagation();">
                    <i data-lucide="plus"></i> Ajouter une tâche...
                </div>
            </div>
        </div>
    `;
}

function renderArcComment(item, isSelected) {
    return `
        <div class="arc-floating-item ${isSelected ? 'selected' : ''}"
             id="item-${item.id}"
             data-item-id="${item.id}"
             data-item-type="comment"
             style="left: ${item.x}px; top: ${item.y}px; width: 220px"
             draggable="true"
             ondragstart="handleFloatingDragStart(event, '${item.id}')"
             ondragend="handleFloatingDragEnd(event)"
             onmousedown="handleItemMouseDown(event, '${item.id}')"
             onclick="selectArcItem(event, '${item.id}')">
            <div class="arc-card arc-card-comment" style="margin:0">
                <div class="arc-card-content" contenteditable="true"
                     onblur="updateArcItemContent('${item.id}', this.innerHTML)"
                     onclick="event.stopPropagation()">${item.content || ''}</div>
            </div>
        </div>
    `;
}

function renderArcTable(item, isSelected) {
    const rows = item.rows || 3;
    const cols = item.cols || 3;
    const data = item.data || [];
    
    let tableHtml = '<table>';
    for (let r = 0; r < rows; r++) {
        tableHtml += '<tr>';
        for (let c = 0; c < cols; c++) {
            const cellData = data[r] && data[r][c] ? data[r][c] : '';
            const tag = r === 0 ? 'th' : 'td';
            tableHtml += `<${tag} contenteditable="true" 
                           onblur="updateArcTableCell('${item.id}', ${r}, ${c}, this.textContent)"
                           onclick="event.stopPropagation()">${cellData}</${tag}>`;
        }
        tableHtml += '</tr>';
    }
    tableHtml += '</table>';
    
    return `
        <div class="arc-floating-item ${isSelected ? 'selected' : ''}"
             id="item-${item.id}"
             data-item-id="${item.id}"
             data-item-type="table"
             style="left: ${item.x}px; top: ${item.y}px"
             draggable="true"
             ondragstart="handleFloatingDragStart(event, '${item.id}')"
             ondragend="handleFloatingDragEnd(event)"
             onmousedown="handleItemMouseDown(event, '${item.id}')"
             onclick="selectArcItem(event, '${item.id}')">
            <div class="arc-card arc-card-table" style="margin:0">
                ${tableHtml}
            </div>
        </div>
    `;
}

// ============================================
// PANNEAU CONTEXTUEL
// ============================================

function renderArcContextDefault(arc) {
    const allCategories = { ...ARC_CATEGORIES, ...project.arcCategories };
    const catData = allCategories[arc.category] || { label: 'Non catégorisé', color: '#999' };
    
    return `
        <div class="arc-context-section">
            <div class="arc-context-section-title">Arc actuel</div>
            <div style="margin-bottom:12px">
                <input type="text" class="form-input" value="${arc.title}"
                       onchange="updateCurrentArcTitle(this.value)"
                       style="font-weight:600">
            </div>
            <div style="display:flex;align-items:center;gap:8px;margin-bottom:8px">
                <span style="width:12px;height:12px;border-radius:50%;background:${arc.color}"></span>
                <span style="font-size:13px;color:var(--text-secondary)">${catData.label}</span>
            </div>
        </div>
        
        <div class="arc-context-section">
            <div class="arc-context-section-title">Ajouter au board</div>
            <div class="arc-context-tools">
                <div class="arc-context-tool" onclick="addArcItem('column')">
                    <i data-lucide="columns-3"></i>
                    <span>Colonne</span>
                </div>
                <div class="arc-context-tool" onclick="addArcItem('note')">
                    <i data-lucide="file-text"></i>
                    <span>Note</span>
                </div>
                <div class="arc-context-tool" onclick="addArcItem('image')">
                    <i data-lucide="image"></i>
                    <span>Image</span>
                </div>
                <div class="arc-context-tool" onclick="addArcItem('todo')">
                    <i data-lucide="check-square"></i>
                    <span>Tâches</span>
                </div>
            </div>
        </div>
        
        <div class="arc-context-section">
            <div class="arc-context-section-title">Statistiques</div>
            <div style="font-size:13px;color:var(--text-secondary)">
                <div style="margin-bottom:4px">${arc.board.items.length} élément${arc.board.items.length > 1 ? 's' : ''}</div>
                <div>${arc.board.connections ? arc.board.connections.length : 0} connexion${(arc.board.connections?.length || 0) > 1 ? 's' : ''}</div>
            </div>
        </div>
    `;
}

function renderArcContextForItem(item) {
    const body = document.getElementById('arcContextBody');
    if (!body) return;
    
    let html = '';
    
    switch (item.type) {
        case 'column':
            html = renderColumnContextPanel(item);
            break;
        case 'note':
        case 'comment':
            html = renderTextContextPanel(item);
            break;
        case 'image':
            html = renderImageContextPanel(item);
            break;
        case 'todo':
            html = renderTodoContextPanel(item);
            break;
        case 'table':
            html = renderTableContextPanel(item);
            break;
        default:
            html = renderDefaultContextPanel(item);
    }
    
    body.innerHTML = html;
    if (typeof lucide !== 'undefined') lucide.createIcons();
    
    // Ouvrir le panneau si fermé
    if (!arcBoardState.contextPanelOpen) {
        toggleArcContextPanel();
    }
}

function renderColumnContextPanel(item) {
    return `
        <div class="arc-context-section">
            <div class="arc-context-section-title">Colonne</div>
            <div class="form-group">
                <label style="font-size:12px">Titre</label>
                <input type="text" class="form-input" value="${item.title || ''}"
                       onchange="updateArcItemTitle('${item.id}', this.value)">
            </div>
            <div class="form-group">
                <label style="font-size:12px">Largeur (px)</label>
                <input type="number" class="form-input" value="${item.width || ARC_BOARD_CONFIG.defaultColumnWidth}"
                       min="${ARC_BOARD_CONFIG.minColumnWidth}" max="${ARC_BOARD_CONFIG.maxColumnWidth}"
                       onchange="updateArcItemWidth('${item.id}', this.value)">
            </div>
        </div>
        
        <div class="arc-context-section">
            <div class="arc-context-section-title">Ajouter une carte</div>
            <div class="arc-context-tools">
                <div class="arc-context-tool" onclick="addCardToColumn('${item.id}', 'note')">
                    <i data-lucide="file-text"></i>
                    <span>Note</span>
                </div>
                <div class="arc-context-tool" onclick="addCardToColumn('${item.id}', 'image')">
                    <i data-lucide="image"></i>
                    <span>Image</span>
                </div>
                <div class="arc-context-tool" onclick="addCardToColumn('${item.id}', 'link')">
                    <i data-lucide="link"></i>
                    <span>Lien</span>
                </div>
                <div class="arc-context-tool" onclick="addCardToColumn('${item.id}', 'todo')">
                    <i data-lucide="check-square"></i>
                    <span>Tâches</span>
                </div>
            </div>
        </div>
        
        <div class="arc-context-section">
            <button class="arc-context-delete" onclick="deleteArcItem('${item.id}')">
                <i data-lucide="trash-2"></i> Supprimer la colonne
            </button>
        </div>
    `;
}

function renderTextContextPanel(item) {
    return `
        <div class="arc-context-section">
            <div class="arc-context-section-title">Mise en forme</div>
            <div class="arc-context-format-bar">
                <button class="arc-format-btn" onclick="formatArcText('bold')" title="Gras">
                    <i data-lucide="bold"></i>
                </button>
                <button class="arc-format-btn" onclick="formatArcText('italic')" title="Italique">
                    <i data-lucide="italic"></i>
                </button>
                <button class="arc-format-btn" onclick="formatArcText('strikethrough')" title="Barré">
                    <i data-lucide="strikethrough"></i>
                </button>
                <button class="arc-format-btn" onclick="formatArcText('underline')" title="Souligné">
                    <i data-lucide="underline"></i>
                </button>
            </div>
        </div>
        
        <div class="arc-context-section">
            <div class="arc-context-section-title">Listes</div>
            <div class="arc-context-format-bar">
                <button class="arc-format-btn" onclick="formatArcText('insertUnorderedList')" title="Liste à puces">
                    <i data-lucide="list"></i>
                </button>
                <button class="arc-format-btn" onclick="formatArcText('insertOrderedList')" title="Liste numérotée">
                    <i data-lucide="list-ordered"></i>
                </button>
            </div>
        </div>
        
        <div class="arc-context-section">
            <div class="arc-context-section-title">Alignement</div>
            <div class="arc-context-format-bar">
                <button class="arc-format-btn" onclick="formatArcText('justifyLeft')" title="Gauche">
                    <i data-lucide="align-left"></i>
                </button>
                <button class="arc-format-btn" onclick="formatArcText('justifyCenter')" title="Centre">
                    <i data-lucide="align-center"></i>
                </button>
                <button class="arc-format-btn" onclick="formatArcText('justifyRight')" title="Droite">
                    <i data-lucide="align-right"></i>
                </button>
            </div>
        </div>
        
        <div class="arc-context-section">
            <div class="arc-context-section-title">Code</div>
            <div class="arc-context-format-bar">
                <button class="arc-format-btn" onclick="insertArcCode()" title="Code">
                    <i data-lucide="code"></i>
                </button>
            </div>
        </div>
        
        <div class="arc-context-section">
            <button class="arc-context-delete" onclick="deleteArcItem('${item.id}')">
                <i data-lucide="trash-2"></i> Supprimer
            </button>
        </div>
    `;
}

function renderImageContextPanel(item) {
    return `
        <div class="arc-context-section">
            <div class="arc-context-section-title">Image</div>
            <button class="btn-secondary" style="width:100%" onclick="triggerItemImageUpload('${item.id}')">
                <i data-lucide="upload"></i> Changer l'image
            </button>
        </div>
        
        <div class="arc-context-section">
            <div class="arc-context-section-title">Taille</div>
            <div class="form-group">
                <label style="font-size:12px">Largeur max (px)</label>
                <input type="number" class="form-input" value="${item.width || 300}"
                       min="100" max="800"
                       onchange="updateArcItemWidth('${item.id}', this.value)">
            </div>
        </div>
        
        <div class="arc-context-section">
            <button class="arc-context-delete" onclick="deleteArcItem('${item.id}')">
                <i data-lucide="trash-2"></i> Supprimer
            </button>
        </div>
    `;
}

function renderTodoContextPanel(item) {
    return `
        <div class="arc-context-section">
            <div class="arc-context-section-title">Liste de tâches</div>
            <div class="form-group">
                <label style="font-size:12px">Titre</label>
                <input type="text" class="form-input" value="${item.title || ''}"
                       onchange="updateArcItemTitle('${item.id}', this.value)">
            </div>
        </div>
        
        <div class="arc-context-section">
            <button class="btn-secondary" style="width:100%" onclick="addFloatingTodoItem('${item.id}')">
                <i data-lucide="plus"></i> Ajouter une tâche
            </button>
        </div>
        
        <div class="arc-context-section">
            <button class="arc-context-delete" onclick="deleteArcItem('${item.id}')">
                <i data-lucide="trash-2"></i> Supprimer
            </button>
        </div>
    `;
}

function renderTableContextPanel(item) {
    return `
        <div class="arc-context-section">
            <div class="arc-context-section-title">Tableau</div>
            <div class="form-row" style="display:flex;gap:8px">
                <div class="form-group" style="flex:1">
                    <label style="font-size:12px">Lignes</label>
                    <input type="number" class="form-input" value="${item.rows || 3}"
                           min="1" max="20"
                           onchange="updateArcTableSize('${item.id}', 'rows', this.value)">
                </div>
                <div class="form-group" style="flex:1">
                    <label style="font-size:12px">Colonnes</label>
                    <input type="number" class="form-input" value="${item.cols || 3}"
                           min="1" max="10"
                           onchange="updateArcTableSize('${item.id}', 'cols', this.value)">
                </div>
            </div>
        </div>
        
        <div class="arc-context-section">
            <button class="arc-context-delete" onclick="deleteArcItem('${item.id}')">
                <i data-lucide="trash-2"></i> Supprimer
            </button>
        </div>
    `;
}

function renderDefaultContextPanel(item) {
    return `
        <div class="arc-context-section">
            <div class="arc-context-section-title">Élément</div>
            <p style="font-size:13px;color:var(--text-secondary)">Type: ${item.type}</p>
        </div>
        
        <div class="arc-context-section">
            <button class="arc-context-delete" onclick="deleteArcItem('${item.id}')">
                <i data-lucide="trash-2"></i> Supprimer
            </button>
        </div>
    `;
}

function toggleArcContextPanel() {
    const panel = document.getElementById('arcContextPanel');
    if (!panel) return;
    
    arcBoardState.contextPanelOpen = !arcBoardState.contextPanelOpen;
    panel.classList.toggle('collapsed', !arcBoardState.contextPanelOpen);
}

// ============================================
// CONNEXIONS - SYSTÈME SIMPLIFIÉ
// ============================================

// Mode connexion : clic sur source, puis clic sur cible
function toggleConnectionMode() {
    if (arcBoardState.activeTool === 'connect') {
        cancelConnectionMode();
    } else {
        arcBoardState.activeTool = 'connect';
        arcBoardState.connectionSource = null;
        
        // Update UI
        document.querySelectorAll('.arc-toolbar-btn').forEach(btn => btn.classList.remove('active'));
        const connectBtn = document.querySelector('.arc-toolbar-btn[onclick="toggleConnectionMode()"]');
        if (connectBtn) connectBtn.classList.add('active');
        
        // Afficher le hint
        const hint = document.getElementById('connectionModeHint');
        if (hint) {
            hint.style.display = 'flex';
            document.getElementById('connectionHintText').textContent = 'Cliquez sur l\'élément source';
        }
        
        // Ajouter classe au canvas
        const canvas = document.getElementById('arcBoardCanvas');
        if (canvas) canvas.classList.add('connection-mode');
        
        // Highlight tous les éléments connectables
        document.querySelectorAll('.arc-column, .arc-floating-item').forEach(el => {
            el.classList.add('connectable');
        });
        
        if (typeof lucide !== 'undefined') lucide.createIcons();
    }
}

function cancelConnectionMode() {
    arcBoardState.activeTool = 'select';
    arcBoardState.connectionSource = null;
    
    // Update UI
    document.querySelectorAll('.arc-toolbar-btn').forEach(btn => btn.classList.remove('active'));
    const selectBtn = document.querySelector('.arc-toolbar-btn[onclick="setArcTool(\'select\')"]');
    if (selectBtn) selectBtn.classList.add('active');
    
    // Masquer le hint
    const hint = document.getElementById('connectionModeHint');
    if (hint) hint.style.display = 'none';
    
    // Retirer classe du canvas
    const canvas = document.getElementById('arcBoardCanvas');
    if (canvas) canvas.classList.remove('connection-mode');
    
    // Retirer highlight
    document.querySelectorAll('.arc-column, .arc-floating-item').forEach(el => {
        el.classList.remove('connectable', 'connection-source', 'connection-target');
    });
}

function handleConnectionClick(itemId) {
    if (arcBoardState.activeTool !== 'connect') return false;
    
    const arc = project.narrativeArcs.find(a => a.id === arcBoardState.currentArcId);
    if (!arc) return false;
    
    if (!arcBoardState.connectionSource) {
        // Premier clic : sélectionner la source
        arcBoardState.connectionSource = itemId;
        
        // Update UI
        const sourceEl = document.getElementById(`item-${itemId}`);
        if (sourceEl) {
            sourceEl.classList.add('connection-source');
            sourceEl.classList.remove('connectable');
        }
        
        document.getElementById('connectionHintText').textContent = 'Cliquez sur l\'élément cible';
        
        // Les autres éléments deviennent des cibles potentielles
        document.querySelectorAll('.arc-column, .arc-floating-item').forEach(el => {
            if (el.id !== `item-${itemId}`) {
                el.classList.add('connection-target');
            }
        });
        
        return true;
    } else {
        // Deuxième clic : créer la connexion
        if (arcBoardState.connectionSource === itemId) {
            // Clic sur le même élément = annuler
            cancelConnectionMode();
            return true;
        }
        
        // Vérifier si connexion existe déjà
        const exists = arc.board.connections && arc.board.connections.some(c => 
            (c.from === arcBoardState.connectionSource && c.to === itemId) ||
            (c.from === itemId && c.to === arcBoardState.connectionSource)
        );
        
        if (!exists) {
            // Calculer les meilleurs côtés pour la connexion
            const sides = calculateBestConnectionSides(arcBoardState.connectionSource, itemId);
            
            // Créer la connexion
            const newConnection = {
                id: 'conn_' + Date.now(),
                from: arcBoardState.connectionSource,
                fromSide: sides.fromSide,
                to: itemId,
                toSide: sides.toSide
            };
            
            if (!arc.board.connections) arc.board.connections = [];
            arc.board.connections.push(newConnection);
            
            saveProject();
            renderArcConnections(arc);
        }
        
        // Réinitialiser pour une nouvelle connexion
        arcBoardState.connectionSource = null;
        document.getElementById('connectionHintText').textContent = 'Cliquez sur l\'élément source';
        
        document.querySelectorAll('.arc-column, .arc-floating-item').forEach(el => {
            el.classList.remove('connection-source', 'connection-target');
            el.classList.add('connectable');
        });
        
        return true;
    }
}

function calculateBestConnectionSides(fromId, toId) {
    const fromEl = document.getElementById(`item-${fromId}`);
    const toEl = document.getElementById(`item-${toId}`);
    
    if (!fromEl || !toEl) return { fromSide: 'right', toSide: 'left' };
    
    const fromRect = fromEl.getBoundingClientRect();
    const toRect = toEl.getBoundingClientRect();
    
    const fromCenterX = fromRect.left + fromRect.width / 2;
    const fromCenterY = fromRect.top + fromRect.height / 2;
    const toCenterX = toRect.left + toRect.width / 2;
    const toCenterY = toRect.top + toRect.height / 2;
    
    const dx = toCenterX - fromCenterX;
    const dy = toCenterY - fromCenterY;
    
    let fromSide, toSide;
    
    // Déterminer la direction principale
    if (Math.abs(dx) > Math.abs(dy)) {
        // Connexion horizontale
        if (dx > 0) {
            fromSide = 'right';
            toSide = 'left';
        } else {
            fromSide = 'left';
            toSide = 'right';
        }
    } else {
        // Connexion verticale
        if (dy > 0) {
            fromSide = 'bottom';
            toSide = 'top';
        } else {
            fromSide = 'top';
            toSide = 'bottom';
        }
    }
    
    return { fromSide, toSide };
}

function renderArcConnections(arc) {
    const svg = document.getElementById('arcConnectionsSvg');
    if (!svg) return;
    
    // Conserver les defs
    const defs = svg.querySelector('defs');
    svg.innerHTML = '';
    if (defs) svg.appendChild(defs);
    
    if (!arc.board.connections || arc.board.connections.length === 0) return;
    
    const content = document.getElementById('arcBoardContent');
    if (!content) return;
    
    arc.board.connections.forEach(conn => {
        const fromEl = document.getElementById(`item-${conn.from}`);
        const toEl = document.getElementById(`item-${conn.to}`);
        
        if (!fromEl || !toEl) return;
        
        // Obtenir les positions relatives au content
        const fromPos = getElementPosition(fromEl, conn.fromSide);
        const toPos = getElementPosition(toEl, conn.toSide);
        
        // Créer la courbe Bézier
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        const d = createBezierPath(fromPos, toPos, conn.fromSide, conn.toSide);
        
        path.setAttribute('d', d);
        path.setAttribute('class', `arc-connection-line ${arcBoardState.selectedItems.includes(conn.id) ? 'selected' : ''}`);
        path.setAttribute('data-connection-id', conn.id);
        path.setAttribute('marker-end', 'url(#arrowhead)');
        path.style.pointerEvents = 'stroke';
        path.onclick = (e) => {
            e.stopPropagation();
            selectArcConnection(e, conn.id);
        };
        
        svg.appendChild(path);
    });
}

function getElementPosition(element, side) {
    // Obtenir la position depuis le style (left/top)
    const x = parseInt(element.style.left) || 0;
    const y = parseInt(element.style.top) || 0;
    const w = element.offsetWidth;
    const h = element.offsetHeight;
    
    switch (side) {
        case 'top': return { x: x + w/2, y: y };
        case 'bottom': return { x: x + w/2, y: y + h };
        case 'left': return { x: x, y: y + h/2 };
        case 'right': return { x: x + w, y: y + h/2 };
        default: return { x: x + w/2, y: y + h/2 };
    }
}

function createBezierPath(from, to, fromSide, toSide) {
    const dx = to.x - from.x;
    const dy = to.y - from.y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    const offset = Math.min(80, Math.max(40, dist / 3));
    
    let cp1 = { x: from.x, y: from.y };
    let cp2 = { x: to.x, y: to.y };
    
    switch (fromSide) {
        case 'top': cp1.y -= offset; break;
        case 'bottom': cp1.y += offset; break;
        case 'left': cp1.x -= offset; break;
        case 'right': cp1.x += offset; break;
    }
    
    switch (toSide) {
        case 'top': cp2.y -= offset; break;
        case 'bottom': cp2.y += offset; break;
        case 'left': cp2.x -= offset; break;
        case 'right': cp2.x += offset; break;
    }
    
    return `M ${from.x} ${from.y} C ${cp1.x} ${cp1.y}, ${cp2.x} ${cp2.y}, ${to.x} ${to.y}`;
}

function selectArcConnection(event, connId) {
    event.stopPropagation();
    arcBoardState.selectedItems = [connId];
    
    // Désélectionner les items
    document.querySelectorAll('.arc-column, .arc-floating-item').forEach(el => {
        el.classList.remove('selected');
    });
    
    // Highlight la connexion
    document.querySelectorAll('.arc-connection-line').forEach(line => {
        line.classList.remove('selected');
    });
    
    const line = document.querySelector(`[data-connection-id="${connId}"]`);
    if (line) line.classList.add('selected');
}

function deleteSelectedItems() {
    const arc = project.narrativeArcs.find(a => a.id === arcBoardState.currentArcId);
    if (!arc) return;
    
    if (arcBoardState.selectedItems.length === 0) {
        alert('Sélectionnez un élément à supprimer');
        return;
    }
    
    arcBoardState.selectedItems.forEach(id => {
        // Vérifier si c'est une connexion
        if (arc.board.connections) {
            const connIndex = arc.board.connections.findIndex(c => c.id === id);
            if (connIndex !== -1) {
                arc.board.connections.splice(connIndex, 1);
                return;
            }
        }
        
        // Sinon c'est un item
        const itemIndex = arc.board.items.findIndex(i => i.id === id);
        if (itemIndex !== -1) {
            arc.board.items.splice(itemIndex, 1);
            
            // Supprimer les connexions liées
            if (arc.board.connections) {
                arc.board.connections = arc.board.connections.filter(c => 
                    c.from !== id && c.to !== id
                );
            }
        }
    });
    
    arcBoardState.selectedItems = [];
    saveProject();
    renderArcBoardItems(arc);
    renderArcConnections(arc);
}

// ============================================
// ÉVÉNEMENTS CANVAS
// ============================================

function handleCanvasMouseDown(event) {
    // Clic sur le fond du canvas
    if (event.target.id === 'arcBoardCanvas' || event.target.id === 'arcBoardContent' || 
        event.target.classList.contains('arc-board-content') || event.target.id === 'arcBoardItems') {
        
        if (arcBoardState.activeTool === 'pan' || event.button === 1) {
            // Mode pan
            arcBoardState.isPanning = true;
            arcBoardState.panStartX = event.clientX - arcBoardState.panX;
            arcBoardState.panStartY = event.clientY - arcBoardState.panY;
            document.getElementById('arcBoardCanvas').classList.add('dragging');
        } else if (arcBoardState.activeTool === 'connect') {
            // Clic sur le fond en mode connexion = annuler
            cancelConnectionMode();
        } else {
            // Désélectionner
            deselectAllArcItems();
        }
    }
}

function handleCanvasMouseMove(event) {
    if (arcBoardState.isPanning) {
        arcBoardState.panX = event.clientX - arcBoardState.panStartX;
        arcBoardState.panY = event.clientY - arcBoardState.panStartY;
        updateCanvasTransform();
    }
    
    if (arcBoardState.isDragging && arcBoardState.dragItem) {
        handleItemDrag(event);
    }
    
    if (arcBoardState.isResizing && arcBoardState.resizeItem) {
        handleColumnResizeDrag(event);
    }
}

function handleCanvasMouseUp(event) {
    if (arcBoardState.isPanning) {
        arcBoardState.isPanning = false;
        document.getElementById('arcBoardCanvas')?.classList.remove('dragging');
    }
    
    if (arcBoardState.isDragging) {
        endItemDrag(event);
    }
    
    if (arcBoardState.isResizing) {
        endColumnResize(event);
    }
}

function handleCanvasWheel(event) {
    if (event.ctrlKey || event.metaKey) {
        event.preventDefault();
        const delta = event.deltaY > 0 ? -ARC_BOARD_CONFIG.zoomStep : ARC_BOARD_CONFIG.zoomStep;
        zoomArcBoard(delta > 0 ? 1 : -1);
    }
}

function handleCanvasContextMenu(event) {
    event.preventDefault();
    showCanvasContextMenu(event);
}

function updateCanvasTransform() {
    const content = document.getElementById('arcBoardContent');
    if (content) {
        content.style.transform = `scale(${arcBoardState.zoom}) translate(${arcBoardState.panX}px, ${arcBoardState.panY}px)`;
    }
}

// ============================================
// ZOOM
// ============================================

function zoomArcBoard(direction) {
    const newZoom = arcBoardState.zoom + (direction * ARC_BOARD_CONFIG.zoomStep);
    arcBoardState.zoom = Math.max(ARC_BOARD_CONFIG.minZoom, Math.min(ARC_BOARD_CONFIG.maxZoom, newZoom));
    
    updateCanvasTransform();
    
    const zoomLevel = document.getElementById('arcZoomLevel');
    if (zoomLevel) {
        zoomLevel.textContent = `${Math.round(arcBoardState.zoom * 100)}%`;
    }
}

function resetArcZoom() {
    arcBoardState.zoom = 1;
    arcBoardState.panX = 0;
    arcBoardState.panY = 0;
    updateCanvasTransform();
    
    const zoomLevel = document.getElementById('arcZoomLevel');
    if (zoomLevel) {
        zoomLevel.textContent = '100%';
    }
}

// ============================================
// OUTILS
// ============================================

function setArcTool(tool) {
    arcBoardState.activeTool = tool;
    
    // Update toolbar buttons
    document.querySelectorAll('.arc-toolbar-btn').forEach(btn => {
        btn.classList.remove('active');
    });
    
    const activeBtn = document.querySelector(`.arc-toolbar-btn[onclick="setArcTool('${tool}')"]`);
    if (activeBtn) activeBtn.classList.add('active');
    
    // Update cursor
    const canvas = document.getElementById('arcBoardCanvas');
    if (canvas) {
        canvas.classList.remove('dragging', 'connecting');
        if (tool === 'pan') canvas.style.cursor = 'grab';
        else if (tool === 'connect') canvas.style.cursor = 'crosshair';
        else canvas.style.cursor = 'default';
    }
}

// ============================================
// AJOUT D'ITEMS
// ============================================

function addArcItem(type) {
    const arc = project.narrativeArcs.find(a => a.id === arcBoardState.currentArcId);
    if (!arc) return;
    
    // Position au centre visible du canvas
    const canvas = document.getElementById('arcBoardCanvas');
    const rect = canvas.getBoundingClientRect();
    const x = (rect.width / 2 - arcBoardState.panX) / arcBoardState.zoom;
    const y = (rect.height / 2 - arcBoardState.panY) / arcBoardState.zoom;
    
    // Snap to grid
    const snappedX = ARC_BOARD_CONFIG.snapToGrid ? Math.round(x / ARC_BOARD_CONFIG.gridSize) * ARC_BOARD_CONFIG.gridSize : x;
    const snappedY = ARC_BOARD_CONFIG.snapToGrid ? Math.round(y / ARC_BOARD_CONFIG.gridSize) * ARC_BOARD_CONFIG.gridSize : y;
    
    let newItem = {
        id: 'item_' + Date.now(),
        type: type,
        x: snappedX,
        y: snappedY
    };
    
    switch (type) {
        case 'column':
            newItem.title = 'Nouvelle colonne';
            newItem.width = ARC_BOARD_CONFIG.defaultColumnWidth;
            newItem.cards = [];
            break;
        case 'note':
            newItem.content = '';
            newItem.width = 250;
            break;
        case 'image':
            newItem.src = '';
            newItem.width = 300;
            break;
        case 'link':
            newItem.url = '';
            newItem.title = '';
            break;
        case 'todo':
            newItem.title = 'Liste de tâches';
            newItem.items = [];
            break;
        case 'comment':
            newItem.content = '';
            break;
        case 'table':
            newItem.rows = 3;
            newItem.cols = 3;
            newItem.data = [];
            break;
    }
    
    arc.board.items.push(newItem);
    saveProject();
    
    renderArcBoardItems(arc);
    selectArcItem(null, newItem.id);
}

function addCardToColumn(columnId, cardType = 'note') {
    const arc = project.narrativeArcs.find(a => a.id === arcBoardState.currentArcId);
    if (!arc) return;
    
    const column = arc.board.items.find(item => item.id === columnId);
    if (!column || column.type !== 'column') return;
    
    if (!column.cards) column.cards = [];
    
    const newCard = {
        id: 'card_' + Date.now(),
        type: cardType
    };
    
    switch (cardType) {
        case 'note':
            newCard.content = '';
            break;
        case 'image':
            newCard.src = '';
            newCard.caption = '';
            break;
        case 'link':
            newCard.url = '';
            newCard.title = '';
            break;
        case 'todo':
            newCard.title = '';
            newCard.items = [];
            break;
        case 'audio':
            newCard.url = '';
            break;
    }
    
    column.cards.push(newCard);
    saveProject();
    renderArcBoardItems(arc);
}

// ============================================
// SÉLECTION
// ============================================

function selectArcItem(event, itemId) {
    if (event) event.stopPropagation();
    
    // Si on est en mode connexion, gérer la connexion
    if (arcBoardState.activeTool === 'connect') {
        handleConnectionClick(itemId);
        return;
    }
    
    const arc = project.narrativeArcs.find(a => a.id === arcBoardState.currentArcId);
    if (!arc) return;
    
    // Multi-sélection avec Ctrl/Cmd
    if (event && (event.ctrlKey || event.metaKey)) {
        const index = arcBoardState.selectedItems.indexOf(itemId);
        if (index === -1) {
            arcBoardState.selectedItems.push(itemId);
        } else {
            arcBoardState.selectedItems.splice(index, 1);
        }
    } else {
        arcBoardState.selectedItems = [itemId];
    }
    
    // Update UI
    document.querySelectorAll('.arc-column, .arc-floating-item').forEach(el => {
        el.classList.remove('selected');
    });
    
    // Désélectionner les connexions
    document.querySelectorAll('.arc-connection-line').forEach(line => {
        line.classList.remove('selected');
    });
    
    arcBoardState.selectedItems.forEach(id => {
        const el = document.getElementById(`item-${id}`);
        if (el) el.classList.add('selected');
    });
    
    // Update context panel
    if (arcBoardState.selectedItems.length === 1) {
        const item = arc.board.items.find(i => i.id === itemId);
        if (item) renderArcContextForItem(item);
    }
}

function selectArcCard(event, cardId, columnId) {
    event.stopPropagation();
    // Pour l'instant, sélectionner la colonne parente
    selectArcItem(event, columnId);
}

function deselectAllArcItems() {
    arcBoardState.selectedItems = [];
    
    document.querySelectorAll('.arc-column, .arc-floating-item').forEach(el => {
        el.classList.remove('selected');
    });
    
    document.querySelectorAll('.arc-connection-line').forEach(line => {
        line.classList.remove('selected');
    });
    
    // Reset context panel
    const arc = project.narrativeArcs.find(a => a.id === arcBoardState.currentArcId);
    if (arc) {
        const body = document.getElementById('arcContextBody');
        if (body) body.innerHTML = renderArcContextDefault(arc);
        if (typeof lucide !== 'undefined') lucide.createIcons();
    }
}

// ============================================
// DRAG & DROP ITEMS
// ============================================

function handleItemMouseDown(event, itemId) {
    if (event.target.classList.contains('arc-column-resize')) return;
    if (event.target.closest('.arc-connection-point')) return;
    if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA' || event.target.contentEditable === 'true') return;
    
    event.stopPropagation();
    
    arcBoardState.isDragging = true;
    arcBoardState.dragItem = itemId;
    arcBoardState.dragStartX = event.clientX;
    arcBoardState.dragStartY = event.clientY;
    
    const el = document.getElementById(`item-${itemId}`);
    if (el) {
        el.classList.add('dragging');
        arcBoardState.dragItemStartX = parseInt(el.style.left) || 0;
        arcBoardState.dragItemStartY = parseInt(el.style.top) || 0;
    }
}

function handleItemDrag(event) {
    if (!arcBoardState.isDragging || !arcBoardState.dragItem) return;
    
    const dx = (event.clientX - arcBoardState.dragStartX) / arcBoardState.zoom;
    const dy = (event.clientY - arcBoardState.dragStartY) / arcBoardState.zoom;
    
    let newX = arcBoardState.dragItemStartX + dx;
    let newY = arcBoardState.dragItemStartY + dy;
    
    // Snap to grid
    if (ARC_BOARD_CONFIG.snapToGrid) {
        newX = Math.round(newX / ARC_BOARD_CONFIG.gridSize) * ARC_BOARD_CONFIG.gridSize;
        newY = Math.round(newY / ARC_BOARD_CONFIG.gridSize) * ARC_BOARD_CONFIG.gridSize;
    }
    
    const el = document.getElementById(`item-${arcBoardState.dragItem}`);
    if (el) {
        el.style.left = `${newX}px`;
        el.style.top = `${newY}px`;
    }
    
    // Update connections in real-time
    const arc = project.narrativeArcs.find(a => a.id === arcBoardState.currentArcId);
    if (arc) renderArcConnections(arc);
}

function endItemDrag(event) {
    if (!arcBoardState.isDragging || !arcBoardState.dragItem) return;
    
    const el = document.getElementById(`item-${arcBoardState.dragItem}`);
    if (el) {
        el.classList.remove('dragging');
        
        // Save new position
        const arc = project.narrativeArcs.find(a => a.id === arcBoardState.currentArcId);
        if (arc) {
            const item = arc.board.items.find(i => i.id === arcBoardState.dragItem);
            if (item) {
                item.x = parseInt(el.style.left) || 0;
                item.y = parseInt(el.style.top) || 0;
                saveProject();
            }
        }
    }
    
    arcBoardState.isDragging = false;
    arcBoardState.dragItem = null;
}

// ============================================
// RESIZE COLONNES
// ============================================

function startColumnResize(event, columnId) {
    event.stopPropagation();
    event.preventDefault();
    
    arcBoardState.isResizing = true;
    arcBoardState.resizeItem = columnId;
    arcBoardState.resizeStartX = event.clientX;
    
    const el = document.getElementById(`item-${columnId}`);
    if (el) {
        arcBoardState.resizeStartWidth = parseInt(el.style.width) || ARC_BOARD_CONFIG.defaultColumnWidth;
    }
}

function handleColumnResizeDrag(event) {
    if (!arcBoardState.isResizing || !arcBoardState.resizeItem) return;
    
    const dx = (event.clientX - arcBoardState.resizeStartX) / arcBoardState.zoom;
    let newWidth = arcBoardState.resizeStartWidth + dx;
    
    newWidth = Math.max(ARC_BOARD_CONFIG.minColumnWidth, Math.min(ARC_BOARD_CONFIG.maxColumnWidth, newWidth));
    
    const el = document.getElementById(`item-${arcBoardState.resizeItem}`);
    if (el) {
        el.style.width = `${newWidth}px`;
    }
}

function endColumnResize(event) {
    if (!arcBoardState.isResizing || !arcBoardState.resizeItem) return;
    
    const el = document.getElementById(`item-${arcBoardState.resizeItem}`);
    if (el) {
        const arc = project.narrativeArcs.find(a => a.id === arcBoardState.currentArcId);
        if (arc) {
            const item = arc.board.items.find(i => i.id === arcBoardState.resizeItem);
            if (item) {
                item.width = parseInt(el.style.width) || ARC_BOARD_CONFIG.defaultColumnWidth;
                saveProject();
            }
        }
    }
    
    arcBoardState.isResizing = false;
    arcBoardState.resizeItem = null;
}

// ============================================
// MISE À JOUR DES ITEMS
// ============================================

function updateArcItemTitle(itemId, title) {
    const arc = project.narrativeArcs.find(a => a.id === arcBoardState.currentArcId);
    if (!arc) return;
    
    const item = arc.board.items.find(i => i.id === itemId);
    if (item) {
        item.title = title;
        saveProject();
    }
}

function updateArcItemContent(itemId, content) {
    const arc = project.narrativeArcs.find(a => a.id === arcBoardState.currentArcId);
    if (!arc) return;
    
    const item = arc.board.items.find(i => i.id === itemId);
    if (item) {
        item.content = content;
        saveProject();
    }
}

function updateArcItemWidth(itemId, width) {
    const arc = project.narrativeArcs.find(a => a.id === arcBoardState.currentArcId);
    if (!arc) return;
    
    const item = arc.board.items.find(i => i.id === itemId);
    if (item) {
        item.width = parseInt(width);
        saveProject();
        renderArcBoardItems(arc);
    }
}

function updateCurrentArcTitle(title) {
    const arc = project.narrativeArcs.find(a => a.id === arcBoardState.currentArcId);
    if (arc) {
        arc.title = title;
        arc.updated = new Date().toISOString();
        saveProject();
        renderArcsBoardSidebar();
    }
}

// ============================================
// CARTES - MISE À JOUR
// ============================================

function updateArcCardContent(columnId, cardId, content) {
    const arc = project.narrativeArcs.find(a => a.id === arcBoardState.currentArcId);
    if (!arc) return;
    
    const column = arc.board.items.find(i => i.id === columnId);
    if (!column || !column.cards) return;
    
    const card = column.cards.find(c => c.id === cardId);
    if (card) {
        card.content = content;
        saveProject();
    }
}

function updateArcCardTitle(columnId, cardId, title) {
    const arc = project.narrativeArcs.find(a => a.id === arcBoardState.currentArcId);
    if (!arc) return;
    
    const column = arc.board.items.find(i => i.id === columnId);
    if (!column || !column.cards) return;
    
    const card = column.cards.find(c => c.id === cardId);
    if (card) {
        card.title = title;
        saveProject();
    }
}

// ============================================
// TO-DO FUNCTIONS
// ============================================

function addArcTodoItem(columnId, cardId) {
    const arc = project.narrativeArcs.find(a => a.id === arcBoardState.currentArcId);
    if (!arc) return;
    
    const column = arc.board.items.find(i => i.id === columnId);
    if (!column || !column.cards) return;
    
    const card = column.cards.find(c => c.id === cardId);
    if (!card) return;
    
    if (!card.items) card.items = [];
    card.items.push({ text: '', completed: false });
    
    saveProject();
    renderArcBoardItems(arc);
}

function toggleArcTodo(columnId, cardId, todoIndex) {
    const arc = project.narrativeArcs.find(a => a.id === arcBoardState.currentArcId);
    if (!arc) return;
    
    const column = arc.board.items.find(i => i.id === columnId);
    if (!column || !column.cards) return;
    
    const card = column.cards.find(c => c.id === cardId);
    if (!card || !card.items || !card.items[todoIndex]) return;
    
    card.items[todoIndex].completed = !card.items[todoIndex].completed;
    
    saveProject();
    renderArcBoardItems(arc);
}

function updateArcTodoText(columnId, cardId, todoIndex, text) {
    const arc = project.narrativeArcs.find(a => a.id === arcBoardState.currentArcId);
    if (!arc) return;
    
    const column = arc.board.items.find(i => i.id === columnId);
    if (!column || !column.cards) return;
    
    const card = column.cards.find(c => c.id === cardId);
    if (!card || !card.items || !card.items[todoIndex]) return;
    
    card.items[todoIndex].text = text;
    saveProject();
}

// Floating todo functions
function addFloatingTodoItem(itemId) {
    const arc = project.narrativeArcs.find(a => a.id === arcBoardState.currentArcId);
    if (!arc) return;
    
    const item = arc.board.items.find(i => i.id === itemId);
    if (!item) return;
    
    if (!item.items) item.items = [];
    item.items.push({ text: '', completed: false });
    
    saveProject();
    renderArcBoardItems(arc);
}

function toggleFloatingTodo(itemId, todoIndex) {
    const arc = project.narrativeArcs.find(a => a.id === arcBoardState.currentArcId);
    if (!arc) return;
    
    const item = arc.board.items.find(i => i.id === itemId);
    if (!item || !item.items || !item.items[todoIndex]) return;
    
    item.items[todoIndex].completed = !item.items[todoIndex].completed;
    
    saveProject();
    renderArcBoardItems(arc);
}

function updateFloatingTodoText(itemId, todoIndex, text) {
    const arc = project.narrativeArcs.find(a => a.id === arcBoardState.currentArcId);
    if (!arc) return;
    
    const item = arc.board.items.find(i => i.id === itemId);
    if (!item || !item.items || !item.items[todoIndex]) return;
    
    item.items[todoIndex].text = text;
    saveProject();
}

// ============================================
// TABLE FUNCTIONS
// ============================================

function updateArcTableCell(itemId, row, col, value) {
    const arc = project.narrativeArcs.find(a => a.id === arcBoardState.currentArcId);
    if (!arc) return;
    
    const item = arc.board.items.find(i => i.id === itemId);
    if (!item) return;
    
    if (!item.data) item.data = [];
    if (!item.data[row]) item.data[row] = [];
    
    item.data[row][col] = value;
    saveProject();
}

function updateArcTableSize(itemId, dimension, value) {
    const arc = project.narrativeArcs.find(a => a.id === arcBoardState.currentArcId);
    if (!arc) return;
    
    const item = arc.board.items.find(i => i.id === itemId);
    if (!item) return;
    
    item[dimension] = parseInt(value);
    saveProject();
    renderArcBoardItems(arc);
}

// ============================================
// LINK FUNCTIONS
// ============================================

function handleLinkInput(event, columnId, cardId) {
    if (event.key !== 'Enter') return;
    
    const url = event.target.value.trim();
    if (!url) return;
    
    const arc = project.narrativeArcs.find(a => a.id === arcBoardState.currentArcId);
    if (!arc) return;
    
    const column = arc.board.items.find(i => i.id === columnId);
    if (!column || !column.cards) return;
    
    const card = column.cards.find(c => c.id === cardId);
    if (!card) return;
    
    card.url = url;
    card.title = url; // Could be fetched from URL later
    
    saveProject();
    renderArcBoardItems(arc);
}

function handleFloatingLinkInput(event, itemId) {
    if (event.key !== 'Enter') return;
    
    const url = event.target.value.trim();
    if (!url) return;
    
    const arc = project.narrativeArcs.find(a => a.id === arcBoardState.currentArcId);
    if (!arc) return;
    
    const item = arc.board.items.find(i => i.id === itemId);
    if (!item) return;
    
    item.url = url;
    item.title = url;
    
    saveProject();
    renderArcBoardItems(arc);
}

// ============================================
// IMAGE UPLOAD
// ============================================

function triggerArcUpload() {
    document.getElementById('arcFileInput')?.click();
}

function triggerItemImageUpload(itemId) {
    const input = document.getElementById('arcFileInput');
    if (input) {
        input.dataset.targetItem = itemId;
        input.dataset.targetType = 'item';
        input.click();
    }
}

function triggerCardImageUpload(columnId, cardId) {
    const input = document.getElementById('arcFileInput');
    if (input) {
        input.dataset.targetColumn = columnId;
        input.dataset.targetCard = cardId;
        input.dataset.targetType = 'card';
        input.click();
    }
}

function handleArcFileUpload(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = function(e) {
        const src = e.target.result;
        const input = event.target;
        
        if (input.dataset.targetType === 'card') {
            updateCardImage(input.dataset.targetColumn, input.dataset.targetCard, src);
        } else if (input.dataset.targetType === 'item') {
            updateItemImage(input.dataset.targetItem, src);
        } else {
            // Créer un nouveau item image
            addArcItem('image');
            setTimeout(() => {
                const arc = project.narrativeArcs.find(a => a.id === arcBoardState.currentArcId);
                if (arc && arc.board.items.length > 0) {
                    const lastItem = arc.board.items[arc.board.items.length - 1];
                    if (lastItem.type === 'image') {
                        lastItem.src = src;
                        saveProject();
                        renderArcBoardItems(arc);
                    }
                }
            }, 100);
        }
        
        // Reset input
        input.value = '';
        delete input.dataset.targetItem;
        delete input.dataset.targetColumn;
        delete input.dataset.targetCard;
        delete input.dataset.targetType;
    };
    reader.readAsDataURL(file);
}

function updateItemImage(itemId, src) {
    const arc = project.narrativeArcs.find(a => a.id === arcBoardState.currentArcId);
    if (!arc) return;
    
    const item = arc.board.items.find(i => i.id === itemId);
    if (item) {
        item.src = src;
        saveProject();
        renderArcBoardItems(arc);
    }
}

function updateCardImage(columnId, cardId, src) {
    const arc = project.narrativeArcs.find(a => a.id === arcBoardState.currentArcId);
    if (!arc) return;
    
    const column = arc.board.items.find(i => i.id === columnId);
    if (!column || !column.cards) return;
    
    const card = column.cards.find(c => c.id === cardId);
    if (card) {
        card.src = src;
        saveProject();
        renderArcBoardItems(arc);
    }
}

// ============================================
// SUPPRESSION
// ============================================

function deleteArcItem(itemId) {
    const arc = project.narrativeArcs.find(a => a.id === arcBoardState.currentArcId);
    if (!arc) return;
    
    // Supprimer l'item
    arc.board.items = arc.board.items.filter(i => i.id !== itemId);
    
    // Supprimer les connexions liées
    if (arc.board.connections) {
        arc.board.connections = arc.board.connections.filter(c => c.from !== itemId && c.to !== itemId);
    }
    
    arcBoardState.selectedItems = arcBoardState.selectedItems.filter(id => id !== itemId);
    
    saveProject();
    renderArcBoardItems(arc);
    renderArcConnections(arc);
    deselectAllArcItems();
}

// ============================================
// FORMATAGE TEXTE
// ============================================

function formatArcText(command) {
    document.execCommand(command, false, null);
}

function insertArcCode() {
    document.execCommand('insertHTML', false, '<code></code>');
}

// ============================================
// DRAG & DROP BIDIRECTIONNEL
// ============================================

let dragData = {
    type: null,        // 'card' ou 'floating'
    itemId: null,      // ID de l'élément flottant OU de la carte
    sourceColumnId: null, // ID de la colonne source (si carte)
    element: null      // Référence à l'élément DOM
};

// Démarrer le drag d'une carte (dans une colonne)
function handleCardDragStart(event, cardId, columnId) {
    event.stopPropagation();
    
    dragData = {
        type: 'card',
        itemId: cardId,
        sourceColumnId: columnId,
        element: event.target
    };
    
    event.dataTransfer.effectAllowed = 'move';
    event.dataTransfer.setData('text/plain', JSON.stringify({
        type: 'card',
        cardId: cardId,
        columnId: columnId
    }));
    
    event.target.classList.add('dragging');
    
    // Montrer les zones de drop
    setTimeout(() => {
        document.querySelectorAll('.arc-column-body').forEach(el => {
            el.classList.add('drop-target');
        });
        document.getElementById('arcBoardContent')?.classList.add('drop-zone-active');
    }, 0);
}

// Démarrer le drag d'un élément flottant
function handleFloatingDragStart(event, itemId) {
    event.stopPropagation();
    
    dragData = {
        type: 'floating',
        itemId: itemId,
        sourceColumnId: null,
        element: event.target.closest('.arc-floating-item')
    };
    
    event.dataTransfer.effectAllowed = 'move';
    event.dataTransfer.setData('text/plain', JSON.stringify({
        type: 'floating',
        itemId: itemId
    }));
    
    if (dragData.element) {
        dragData.element.classList.add('dragging');
    }
    
    // Montrer les zones de drop (colonnes)
    setTimeout(() => {
        document.querySelectorAll('.arc-column-body').forEach(el => {
            el.classList.add('drop-target');
        });
    }, 0);
}

// Fin du drag
function handleCardDragEnd(event) {
    event.target.classList.remove('dragging');
    
    // Nettoyer les zones de drop
    document.querySelectorAll('.arc-column-body').forEach(el => {
        el.classList.remove('drop-target', 'drop-hover');
    });
    document.getElementById('arcBoardContent')?.classList.remove('drop-zone-active');
    
    dragData = { type: null, itemId: null, sourceColumnId: null, element: null };
}

function handleFloatingDragEnd(event) {
    if (dragData.element) {
        dragData.element.classList.remove('dragging');
    }
    
    document.querySelectorAll('.arc-column-body').forEach(el => {
        el.classList.remove('drop-target', 'drop-hover');
    });
    
    dragData = { type: null, itemId: null, sourceColumnId: null, element: null };
}

// Dragover sur une colonne
function handleCardDragOver(event) {
    event.preventDefault();
    event.dataTransfer.dropEffect = 'move';
    event.currentTarget.classList.add('drop-hover');
}

function handleCardDragLeave(event) {
    event.currentTarget.classList.remove('drop-hover');
}

// Drop sur une colonne - accepte cartes ET éléments flottants
function handleCardDrop(event, targetColumnId) {
    event.preventDefault();
    event.stopPropagation();
    event.currentTarget.classList.remove('drop-hover');
    
    const arc = project.narrativeArcs.find(a => a.id === arcBoardState.currentArcId);
    if (!arc) return;
    
    const targetColumn = arc.board.items.find(i => i.id === targetColumnId);
    if (!targetColumn) return;
    
    if (!targetColumn.cards) targetColumn.cards = [];
    
    if (dragData.type === 'card') {
        // Déplacer une carte d'une colonne à une autre
        if (dragData.sourceColumnId === targetColumnId) return; // Même colonne
        
        const sourceColumn = arc.board.items.find(i => i.id === dragData.sourceColumnId);
        if (!sourceColumn || !sourceColumn.cards) return;
        
        const cardIndex = sourceColumn.cards.findIndex(c => c.id === dragData.itemId);
        if (cardIndex === -1) return;
        
        const [card] = sourceColumn.cards.splice(cardIndex, 1);
        targetColumn.cards.push(card);
        
    } else if (dragData.type === 'floating') {
        // Convertir un élément flottant en carte
        const floatingIndex = arc.board.items.findIndex(i => i.id === dragData.itemId);
        if (floatingIndex === -1) return;
        
        const [floatingItem] = arc.board.items.splice(floatingIndex, 1);
        
        // Supprimer les connexions liées à cet élément
        if (arc.board.connections) {
            arc.board.connections = arc.board.connections.filter(c => 
                c.from !== floatingItem.id && c.to !== floatingItem.id
            );
        }
        
        // Convertir en carte
        const newCard = convertFloatingToCard(floatingItem);
        targetColumn.cards.push(newCard);
    }
    
    saveProject();
    renderArcBoardItems(arc);
    renderArcConnections(arc);
    
    dragData = { type: null, itemId: null, sourceColumnId: null, element: null };
}

// Drop sur le canvas - convertir une carte en élément flottant
function handleCanvasDrop(event) {
    // Ne pas traiter si on drop sur une colonne
    if (event.target.closest('.arc-column-body')) return;
    if (event.target.closest('.arc-column')) return;
    
    event.preventDefault();
    
    // Retirer le feedback visuel
    document.getElementById('arcBoardCanvas')?.classList.remove('drop-hover');
    
    if (dragData.type !== 'card') return;
    
    const arc = project.narrativeArcs.find(a => a.id === arcBoardState.currentArcId);
    if (!arc) return;
    
    const sourceColumn = arc.board.items.find(i => i.id === dragData.sourceColumnId);
    if (!sourceColumn || !sourceColumn.cards) return;
    
    const cardIndex = sourceColumn.cards.findIndex(c => c.id === dragData.itemId);
    if (cardIndex === -1) return;
    
    const [card] = sourceColumn.cards.splice(cardIndex, 1);
    
    // Calculer la position du drop
    const content = document.getElementById('arcBoardContent');
    const contentRect = content.getBoundingClientRect();
    const x = (event.clientX - contentRect.left) / arcBoardState.zoom;
    const y = (event.clientY - contentRect.top) / arcBoardState.zoom;
    
    // Snap to grid
    const snappedX = ARC_BOARD_CONFIG.snapToGrid ? Math.round(x / ARC_BOARD_CONFIG.gridSize) * ARC_BOARD_CONFIG.gridSize : x;
    const snappedY = ARC_BOARD_CONFIG.snapToGrid ? Math.round(y / ARC_BOARD_CONFIG.gridSize) * ARC_BOARD_CONFIG.gridSize : y;
    
    // Convertir la carte en élément flottant
    const floatingItem = convertCardToFloating(card, snappedX, snappedY);
    arc.board.items.push(floatingItem);
    
    saveProject();
    renderArcBoardItems(arc);
    
    dragData = { type: null, itemId: null, sourceColumnId: null, element: null };
}

// Dragover sur le canvas
function handleCanvasDragOver(event) {
    // Permettre le drop seulement pour les cartes (pas les éléments flottants)
    if (dragData.type === 'card') {
        event.preventDefault();
        event.dataTransfer.dropEffect = 'move';
        
        // Ne pas montrer le feedback si on est sur une colonne
        if (!event.target.closest('.arc-column')) {
            document.getElementById('arcBoardCanvas')?.classList.add('drop-hover');
        }
    }
}

// Dragleave sur le canvas
function handleCanvasDragLeave(event) {
    // Vérifier qu'on quitte vraiment le canvas
    if (!event.relatedTarget || !event.currentTarget.contains(event.relatedTarget)) {
        document.getElementById('arcBoardCanvas')?.classList.remove('drop-hover');
    }
}

// Convertir un élément flottant en carte
function convertFloatingToCard(floatingItem) {
    const card = {
        id: 'card_' + Date.now(),
        type: floatingItem.type
    };
    
    switch (floatingItem.type) {
        case 'note':
            card.content = floatingItem.content || '';
            break;
        case 'comment':
            card.type = 'note'; // Les commentaires deviennent des notes
            card.content = floatingItem.content || '';
            break;
        case 'todo':
            card.title = floatingItem.title || '';
            card.items = floatingItem.items || [];
            break;
        case 'image':
            card.src = floatingItem.src || '';
            card.caption = floatingItem.caption || '';
            break;
        case 'link':
            card.url = floatingItem.url || '';
            card.title = floatingItem.title || '';
            break;
        case 'table':
            card.type = 'note';
            card.content = 'Tableau converti';
            break;
        default:
            card.type = 'note';
            card.content = floatingItem.content || '';
    }
    
    return card;
}

// Convertir une carte en élément flottant
function convertCardToFloating(card, x, y) {
    const floatingItem = {
        id: 'item_' + Date.now(),
        type: card.type,
        x: x,
        y: y
    };
    
    switch (card.type) {
        case 'note':
            floatingItem.content = card.content || '';
            floatingItem.width = 250;
            break;
        case 'todo':
            floatingItem.title = card.title || '';
            floatingItem.items = card.items || [];
            break;
        case 'image':
            floatingItem.src = card.src || '';
            floatingItem.width = 300;
            break;
        case 'link':
            floatingItem.url = card.url || '';
            floatingItem.title = card.title || '';
            break;
        default:
            floatingItem.type = 'note';
            floatingItem.content = card.content || '';
            floatingItem.width = 250;
    }
    
    return floatingItem;
}

// ============================================
// MENU CONTEXTUEL
// ============================================

function showCanvasContextMenu(event) {
    removeContextMenu();
    
    const menu = document.createElement('div');
    menu.className = 'arc-context-menu';
    menu.id = 'arcContextMenu';
    menu.style.left = `${event.clientX}px`;
    menu.style.top = `${event.clientY}px`;
    
    menu.innerHTML = `
        <div class="arc-context-menu-item" onclick="addArcItemAtPosition(${event.clientX}, ${event.clientY}, 'column')">
            <i data-lucide="columns-3"></i> Ajouter une colonne
        </div>
        <div class="arc-context-menu-item" onclick="addArcItemAtPosition(${event.clientX}, ${event.clientY}, 'note')">
            <i data-lucide="file-text"></i> Ajouter une note
        </div>
        <div class="arc-context-menu-item" onclick="addArcItemAtPosition(${event.clientX}, ${event.clientY}, 'image')">
            <i data-lucide="image"></i> Ajouter une image
        </div>
        <div class="arc-context-menu-separator"></div>
        <div class="arc-context-menu-item" onclick="pasteArcItem()">
            <i data-lucide="clipboard"></i> Coller
        </div>
        <div class="arc-context-menu-separator"></div>
        <div class="arc-context-menu-item" onclick="resetArcZoom()">
            <i data-lucide="maximize-2"></i> Réinitialiser le zoom
        </div>
    `;
    
    document.body.appendChild(menu);
    if (typeof lucide !== 'undefined') lucide.createIcons();
    
    // Fermer au clic ailleurs
    setTimeout(() => {
        document.addEventListener('click', removeContextMenu, { once: true });
    }, 10);
}

function showArcContextMenu(event, arcId) {
    removeContextMenu();
    
    const menu = document.createElement('div');
    menu.className = 'arc-context-menu';
    menu.id = 'arcContextMenu';
    menu.style.left = `${event.clientX}px`;
    menu.style.top = `${event.clientY}px`;
    
    menu.innerHTML = `
        <div class="arc-context-menu-item" onclick="openArcBoard('${arcId}')">
            <i data-lucide="layout-dashboard"></i> Ouvrir
        </div>
        
        <div class="arc-context-menu-item" onclick="showInlineArcForm('${arcId}')">
            <i data-lucide="settings"></i> Modifier
        </div>
        
        <div class="arc-context-menu-item" onclick="renameArc('${arcId}')">
            <i data-lucide="pencil"></i> Renommer
        </div>
        <div class="arc-context-menu-item" onclick="duplicateArc('${arcId}')">
            <i data-lucide="copy"></i> Dupliquer
        </div>
        <div class="arc-context-menu-separator"></div>
        <div class="arc-context-menu-item danger" onclick="deleteArc('${arcId}')">
            <i data-lucide="trash-2"></i> Supprimer
        </div>
    `;
    
    document.body.appendChild(menu);
    if (typeof lucide !== 'undefined') lucide.createIcons();
    
    setTimeout(() => {
        document.addEventListener('click', removeContextMenu, { once: true });
    }, 10);
}

function removeContextMenu() {
    const menu = document.getElementById('arcContextMenu');
    if (menu) menu.remove();
}

function addArcItemAtPosition(clientX, clientY, type) {
    removeContextMenu();
    
    const arc = project.narrativeArcs.find(a => a.id === arcBoardState.currentArcId);
    if (!arc) return;
    
    const canvasRect = document.getElementById('arcBoardContent').getBoundingClientRect();
    const x = (clientX - canvasRect.left) / arcBoardState.zoom;
    const y = (clientY - canvasRect.top) / arcBoardState.zoom;
    
    const snappedX = ARC_BOARD_CONFIG.snapToGrid ? Math.round(x / ARC_BOARD_CONFIG.gridSize) * ARC_BOARD_CONFIG.gridSize : x;
    const snappedY = ARC_BOARD_CONFIG.snapToGrid ? Math.round(y / ARC_BOARD_CONFIG.gridSize) * ARC_BOARD_CONFIG.gridSize : y;
    
    let newItem = {
        id: 'item_' + Date.now(),
        type: type,
        x: snappedX,
        y: snappedY
    };
    
    switch (type) {
        case 'column':
            newItem.title = 'Nouvelle colonne';
            newItem.width = ARC_BOARD_CONFIG.defaultColumnWidth;
            newItem.cards = [];
            break;
        case 'note':
            newItem.content = '';
            newItem.width = 250;
            break;
        case 'image':
            newItem.src = '';
            newItem.width = 300;
            break;
    }
    
    arc.board.items.push(newItem);
    saveProject();
    renderArcBoardItems(arc);
}

// ============================================
// GESTION DES ARCS
// ============================================

function deleteArc(arcId) {
    removeContextMenu();
    
    const arc = project.narrativeArcs.find(a => a.id === arcId);
    if (!arc) return;
    
    if (!confirm(`Voulez-vous vraiment supprimer l'arc "${arc.title}" ?\n\nCette action est irréversible.`)) {
        return;
    }
    
    project.narrativeArcs = project.narrativeArcs.filter(a => a.id !== arcId);
    
    if (arcBoardState.currentArcId === arcId) {
        arcBoardState.currentArcId = null;
        renderArcsWelcomeBoard();
    }
    
    saveProject();
    renderArcsBoardSidebar();
}

function duplicateArc(arcId) {
    removeContextMenu();
    
    const arc = project.narrativeArcs.find(a => a.id === arcId);
    if (!arc) return;
    
    const newArc = JSON.parse(JSON.stringify(arc));
    newArc.id = 'arc_' + Date.now();
    newArc.title = arc.title + ' (copie)';
    newArc.created = new Date().toISOString();
    newArc.updated = new Date().toISOString();
    
    // Regen IDs for items and connections
    const idMap = {};
    newArc.board.items.forEach(item => {
        const oldId = item.id;
        item.id = 'item_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        idMap[oldId] = item.id;
        
        if (item.cards) {
            item.cards.forEach(card => {
                card.id = 'card_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            });
        }
    });
    
    if (newArc.board.connections) {
        newArc.board.connections.forEach(conn => {
            conn.id = 'conn_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            conn.from = idMap[conn.from] || conn.from;
            conn.to = idMap[conn.to] || conn.to;
        });
    }
    
    project.narrativeArcs.push(newArc);
    saveProject();
    renderArcsBoardSidebar();
    openArcBoard(newArc.id);
}

function renameArc(arcId) {
    removeContextMenu();
    
    const arc = project.narrativeArcs.find(a => a.id === arcId);
    if (!arc) return;
    
    const newTitle = prompt('Nouveau nom de l\'arc:', arc.title);
    if (newTitle && newTitle.trim()) {
        arc.title = newTitle.trim();
        arc.updated = new Date().toISOString();
        saveProject();
        renderArcsBoardSidebar();
    }
}

// ============================================
// CATÉGORIES CUSTOM
// ============================================

function showAddCategoryModal() {
    showInlineCategoryForm();
}

function closeAddCategoryModal(event) {
    if (event && event.target !== event.currentTarget) return;
    const modal = document.getElementById('addCategoryModal');
    if (modal) modal.remove();
}

function confirmAddCategory() {
    const name = document.getElementById('newCategoryName').value.trim();
    const color = document.getElementById('newCategoryColor').value;
    
    if (!name) {
        alert('Veuillez entrer un nom pour la catégorie');
        return;
    }
    
    // Créer une clé à partir du nom
    const key = name.toLowerCase().replace(/[^a-z0-9]/g, '_').replace(/_+/g, '_');
    
    if (!project.arcCategories) project.arcCategories = {};
    
    project.arcCategories[key] = {
        label: name,
        icon: 'folder',
        color: color,
        custom: true
    };
    
    saveProject();
    closeAddCategoryModal();
    renderArcsBoardSidebar();
}

// ============================================
// WELCOME VIEW
// ============================================

function renderArcsWelcomeBoard() {
    const view = document.getElementById('editorView');
    if (!view) return;
    
    initArcBoard();
    const arcs = project.narrativeArcs || [];
    
    if (arcs.length === 0) {
        view.innerHTML = `
            <div class="empty-state">
                <div class="empty-state-icon"><i data-lucide="layout-dashboard"></i></div>
                <div class="empty-state-title">Gérez vos arcs narratifs</div>
                <div class="empty-state-text">
                    Créez des boards visuels pour planifier vos arcs narratifs,<br>
                    organiser vos idées et suivre la progression de votre histoire.
                </div>
                <button class="btn btn-primary" onclick="createNewArcBoard()">
                    <i data-lucide="sparkles"></i> Créer votre premier arc
                </button>
            </div>
        `;
    } else {
        view.innerHTML = `
            <div class="empty-state">
                <div class="empty-state-icon"><i data-lucide="layout-dashboard"></i></div>
                <div class="empty-state-title">Sélectionnez un arc</div>
                <div class="empty-state-text">
                    Choisissez un arc dans la barre latérale<br>
                    ou créez-en un nouveau.
                </div>
                <button class="btn btn-primary" onclick="createNewArcBoard()">
                    <i data-lucide="plus"></i> Nouvel arc
                </button>
            </div>
        `;
    }
    
    if (typeof lucide !== 'undefined') lucide.createIcons();
}

// ============================================
// KEYBOARD SHORTCUTS
// ============================================

document.addEventListener('keydown', function(event) {
    // Ne pas interférer si on édite du texte
    if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA' || event.target.contentEditable === 'true') {
        return;
    }
    
    // Vérifier qu'on est dans le mode arc board
    if (!arcBoardState.currentArcId) return;
    
    // Delete/Backspace - supprimer sélection
    if (event.key === 'Delete' || event.key === 'Backspace') {
        if (arcBoardState.selectedItems.length > 0) {
            event.preventDefault();
            arcBoardState.selectedItems.forEach(id => {
                // Check if it's a connection
                const arc = project.narrativeArcs.find(a => a.id === arcBoardState.currentArcId);
                if (arc?.board.connections?.some(c => c.id === id)) {
                    deleteSelectedConnection();
                } else {
                    deleteArcItem(id);
                }
            });
        }
    }
    
    // Escape - cancel current action
    if (event.key === 'Escape') {
        if (arcBoardState.isConnecting) {
            cancelConnection();
        } else {
            deselectAllArcItems();
        }
    }
    
    // Ctrl+A - select all
    if ((event.ctrlKey || event.metaKey) && event.key === 'a') {
        event.preventDefault();
        const arc = project.narrativeArcs.find(a => a.id === arcBoardState.currentArcId);
        if (arc) {
            arcBoardState.selectedItems = arc.board.items.map(i => i.id);
            arc.board.items.forEach(item => {
                const el = document.getElementById(`item-${item.id}`);
                if (el) el.classList.add('selected');
            });
        }
    }
    
    // Ctrl+C - copy
    if ((event.ctrlKey || event.metaKey) && event.key === 'c') {
        if (arcBoardState.selectedItems.length > 0) {
            event.preventDefault();
            copySelectedItems();
        }
    }
    
    // Ctrl+V - paste
    if ((event.ctrlKey || event.metaKey) && event.key === 'v') {
        if (arcBoardState.clipboard) {
            event.preventDefault();
            pasteArcItem();
        }
    }
    
    // Ctrl+Z - undo
    if ((event.ctrlKey || event.metaKey) && event.key === 'z' && !event.shiftKey) {
        event.preventDefault();
        if (typeof undo === 'function') undo();
    }
    
    // Ctrl+Y ou Ctrl+Shift+Z - redo
    if ((event.ctrlKey || event.metaKey) && (event.key === 'y' || (event.key === 'z' && event.shiftKey))) {
        event.preventDefault();
        if (typeof redo === 'function') redo();
    }
});

// ============================================
// COPY/PASTE
// ============================================

function copySelectedItems() {
    const arc = project.narrativeArcs.find(a => a.id === arcBoardState.currentArcId);
    if (!arc) return;
    
    const itemsToCopy = arc.board.items.filter(i => arcBoardState.selectedItems.includes(i.id));
    arcBoardState.clipboard = JSON.parse(JSON.stringify(itemsToCopy));
}

function pasteArcItem() {
    removeContextMenu();
    
    if (!arcBoardState.clipboard || arcBoardState.clipboard.length === 0) return;
    
    const arc = project.narrativeArcs.find(a => a.id === arcBoardState.currentArcId);
    if (!arc) return;
    
    const offset = 40;
    
    arcBoardState.clipboard.forEach(item => {
        const newItem = JSON.parse(JSON.stringify(item));
        newItem.id = 'item_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        newItem.x += offset;
        newItem.y += offset;
        
        if (newItem.cards) {
            newItem.cards.forEach(card => {
                card.id = 'card_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            });
        }
        
        arc.board.items.push(newItem);
    });
    
    saveProject();
    renderArcBoardItems(arc);
}

// ============================================
// INTÉGRATION AVEC L'ANCIEN SYSTÈME
// ============================================

// Override des fonctions existantes pour utiliser le nouveau système
function renderArcsList() {
    renderArcsBoardSidebar();
}

function renderArcsWelcome() {
    renderArcsWelcomeBoard();
}

function createNewArc() {
    showInlineArcForm();
}

function openArcDetail(arcId) {
    openArcBoard(arcId);
}

// ========== 46.thriller-board.js ==========
// ============================================
// THRILLER BOARD - Canvas System for Mystery Elements
// ============================================

// ============================================
// CONFIGURATION & TYPES
// ============================================

const THRILLER_BOARD_CONFIG = {
    minZoom: 0.25,
    maxZoom: 2,
    zoomStep: 0.1,
    gridSize: 24,
    defaultColumnWidth: 280,
    minColumnWidth: 200,
    maxColumnWidth: 500,
    canvasWidth: 3000,
    canvasHeight: 2000,
    snapToGrid: true
};

// Thriller element types based on the JSON schemas
const THRILLER_TYPES = {
    alibi: {
        label: 'Alibi',
        icon: 'shield-check',
        color: '#27ae60',
        description: 'Character alibi for an event'
    },
    backstory: {
        label: 'Backstory',
        icon: 'history',
        color: '#8e44ad',
        description: 'Character background information'
    },
    clue: {
        label: 'Clue',
        icon: 'search',
        color: '#e67e22',
        description: 'Evidence or hint in the mystery'
    },
    knowledge_state: {
        label: 'Knowledge State',
        icon: 'brain',
        color: '#3498db',
        description: 'What a character knows'
    },
    location: {
        label: 'Location',
        icon: 'map-pin',
        color: '#16a085',
        description: 'Important location in the story'
    },
    motive_means_opportunity: {
        label: 'Motive/Means/Opportunity',
        icon: 'target',
        color: '#e74c3c',
        description: 'Suspect\'s potential for committing crime'
    },
    question: {
        label: 'Question',
        icon: 'help-circle',
        color: '#f39c12',
        description: 'Mystery question to be answered'
    },
    red_herring: {
        label: 'Red Herring',
        icon: 'fish',
        color: '#9b59b6',
        description: 'False lead or misleading clue'
    },
    reversal: {
        label: 'Reversal',
        icon: 'rotate-ccw',
        color: '#d35400',
        description: 'Plot twist or revelation'
    },
    secret: {
        label: 'Secret',
        icon: 'lock',
        color: '#c0392b',
        description: 'Hidden information'
    }
};

// Card types for thriller elements
const THRILLER_CARD_TYPES = {
    note: { label: 'Note', icon: 'file-text' },
    image: { label: 'Image', icon: 'image' },
    link: { label: 'Lien', icon: 'link' },
    todo: { label: 'Tâches', icon: 'check-square' },
    comment: { label: 'Commentaire', icon: 'message-square' },
    table: { label: 'Tableau', icon: 'table' },
    audio: { label: 'Audio', icon: 'music' },
    divider: { label: 'Séparateur', icon: 'minus' }
};

// ============================================
// STATE MANAGEMENT
// ============================================

let thrillerBoardState = {
    elements: [], // Array of thriller elements
    connections: [], // Links between elements
    canvasOffset: { x: 0, y: 0 },
    zoom: 1,
    selectedElements: [],
    contextPanelOpen: true,
    currentFilter: 'all',
    snapToGrid: true
};

// ============================================
// INITIALIZATION
// ============================================

function initThrillerBoard() {
    // Initialize thriller elements array if not exists
    if (!project.thrillerElements) {
        project.thrillerElements = [];
    }
    if (!project.thrillerConnections) {
        project.thrillerConnections = [];
    }

    thrillerBoardState.elements = project.thrillerElements;
    thrillerBoardState.connections = project.thrillerConnections;
}

function renderThrillerBoard() {
    const container = document.getElementById('editorView');
    if (!container) return;

    initThrillerBoard();

    container.innerHTML = `
        <div class="thriller-board-container">
            <!-- Toolbar -->
            <div class="thriller-board-toolbar">
                <div class="thriller-toolbar-left">
                    <button class="btn btn-secondary" onclick="addThrillerElement()">
                        <i data-lucide="plus"></i>
                        Ajouter élément
                    </button>
                    <div class="thriller-filter">
                        <select id="thrillerFilter" onchange="filterThrillerElements(this.value)">
                            <option value="all">Tous les éléments</option>
                            <option value="alibi">Alibis</option>
                            <option value="clue">Indices</option>
                            <option value="secret">Secrets</option>
                            <option value="question">Questions</option>
                            <option value="motive_means_opportunity">Motive/Means/Opportunity</option>
                            <option value="location">Lieux</option>
                            <option value="backstory">Backstories</option>
                            <option value="knowledge_state">États de connaissance</option>
                            <option value="red_herring">Fausses pistes</option>
                            <option value="reversal">Reversements</option>
                        </select>
                    </div>
                </div>
                <div class="thriller-toolbar-center">
                    <button class="btn btn-ghost" onclick="zoomThrillerBoard(-1)">
                        <i data-lucide="zoom-out"></i>
                    </button>
                    <span id="thrillerZoomLevel">100%</span>
                    <button class="btn btn-ghost" onclick="zoomThrillerBoard(1)">
                        <i data-lucide="zoom-in"></i>
                    </button>
                    <button class="btn btn-ghost" onclick="fitThrillerBoardToScreen()">
                        <i data-lucide="maximize"></i>
                    </button>
                </div>
                <div class="thriller-toolbar-right">
                    <button class="btn btn-ghost" onclick="toggleThrillerContextPanel()">
                        <i data-lucide="sidebar"></i>
                    </button>
                </div>
            </div>

            <!-- Canvas Area -->
            <div class="thriller-board-canvas-wrapper">
                <div class="thriller-board-canvas" id="thrillerBoardCanvas"
                     onmousedown="handleThrillerCanvasMouseDown(event)"
                     onmousemove="handleThrillerCanvasMouseMove(event)"
                     onmouseup="handleThrillerCanvasMouseUp(event)"
                     onwheel="handleThrillerCanvasWheel(event)">
                    <div class="thriller-board-content" id="thrillerBoardContent">
                        <!-- Elements will be rendered here -->
                    </div>
                </div>
            </div>

            <!-- Context Panel -->
            <div class="thriller-board-context-panel ${thrillerBoardState.contextPanelOpen ? '' : 'collapsed'}" id="thrillerContextPanel">
                <div class="thriller-context-header">
                    <h3>Éléments Thriller</h3>
                    <button class="btn btn-ghost btn-sm" onclick="toggleThrillerContextPanel()">
                        <i data-lucide="chevron-right"></i>
                    </button>
                </div>
                <div class="thriller-context-content" id="thrillerContextContent">
                    <!-- Context content will be populated here -->
                </div>
            </div>
        </div>
    `;

    renderThrillerElements();
    updateThrillerContextPanel();

    // Refresh Lucide icons
    setTimeout(() => {
        if (typeof lucide !== 'undefined') lucide.createIcons();
    }, 50);
}

// ============================================
// ELEMENT MANAGEMENT
// ============================================

function addThrillerElement(type = null) {
    if (!type) {
        // Show type selection modal
        showThrillerTypeSelector();
        return;
    }

    const elementType = THRILLER_TYPES[type];
    if (!elementType) return;

    const newElement = {
        id: generateId(),
        type: type,
        title: `${elementType.label} ${thrillerBoardState.elements.length + 1}`,
        description: '',
        position: { x: 100, y: 100 },
        size: { width: 280, height: 200 },
        color: elementType.color,
        data: {}, // Element-specific data
        connections: [],
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
    };

    thrillerBoardState.elements.push(newElement);
    project.thrillerElements = thrillerBoardState.elements;

    renderThrillerElements();
    saveProject();

    // Open edit modal for the new element
    editThrillerElement(newElement.id);
}

function showThrillerTypeSelector() {
    const modal = document.createElement('div');
    modal.className = 'modal-overlay';
    modal.innerHTML = `
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header">
                <h3>Choisir un type d'élément</h3>
                <button class="modal-close" onclick="this.closest('.modal-overlay').remove()">
                    <i data-lucide="x"></i>
                </button>
            </div>
            <div class="modal-body">
                <div class="thriller-type-grid">
                    ${Object.entries(THRILLER_TYPES).map(([key, type]) => `
                        <button class="thriller-type-card" onclick="addThrillerElement('${key}'); this.closest('.modal-overlay').remove();">
                            <div class="thriller-type-icon" style="color: ${type.color}">
                                <i data-lucide="${type.icon}"></i>
                            </div>
                            <div class="thriller-type-label">${type.label}</div>
                            <div class="thriller-type-desc">${type.description}</div>
                        </button>
                    `).join('')}
                </div>
            </div>
        </div>
    `;

    document.body.appendChild(modal);

    setTimeout(() => {
        if (typeof lucide !== 'undefined') lucide.createIcons();
    }, 50);
}

function renderThrillerElements() {
    const content = document.getElementById('thrillerBoardContent');
    if (!content) return;

    const filteredElements = thrillerBoardState.currentFilter === 'all'
        ? thrillerBoardState.elements
        : thrillerBoardState.elements.filter(el => el.type === thrillerBoardState.currentFilter);

    content.innerHTML = filteredElements.map(element => {
        const typeData = THRILLER_TYPES[element.type];
        return `
            <div class="thriller-element-card"
                 id="thriller-element-${element.id}"
                 style="left: ${element.position.x}px; top: ${element.position.y}px; width: ${element.size.width}px; min-height: ${element.size.height}px;"
                 onclick="selectThrillerElement('${element.id}')"
                 ondblclick="editThrillerElement('${element.id}')">
                <div class="thriller-element-header" style="background-color: ${element.color}">
                    <div class="thriller-element-icon">
                        <i data-lucide="${typeData.icon}"></i>
                    </div>
                    <div class="thriller-element-title">${element.title}</div>
                    <div class="thriller-element-actions">
                        <button class="btn btn-ghost btn-xs" onclick="event.stopPropagation(); deleteThrillerElement('${element.id}')">
                            <i data-lucide="trash-2"></i>
                        </button>
                    </div>
                </div>
                <div class="thriller-element-content">
                    <div class="thriller-element-description">${element.description || 'Aucune description'}</div>
                </div>
            </div>
        `;
    }).join('');

    // Render connections
    renderThrillerConnections();

    setTimeout(() => {
        if (typeof lucide !== 'undefined') lucide.createIcons();
    }, 50);
}

function renderThrillerConnections() {
    // Remove existing connection lines
    document.querySelectorAll('.thriller-connection').forEach(el => el.remove());

    const canvas = document.getElementById('thrillerBoardCanvas');
    if (!canvas) return;

    thrillerBoardState.connections.forEach(connection => {
        const fromElement = thrillerBoardState.elements.find(el => el.id === connection.from);
        const toElement = thrillerBoardState.elements.find(el => el.id === connection.to);

        if (!fromElement || !toElement) return;

        const fromRect = document.getElementById(`thriller-element-${connection.from}`).getBoundingClientRect();
        const toRect = document.getElementById(`thriller-element-${connection.to}`).getBoundingClientRect();
        const canvasRect = canvas.getBoundingClientRect();

        const x1 = fromRect.left + fromRect.width / 2 - canvasRect.left;
        const y1 = fromRect.top + fromRect.height / 2 - canvasRect.top;
        const x2 = toRect.left + toRect.width / 2 - canvasRect.left;
        const y2 = toRect.top + toRect.height / 2 - canvasRect.top;

        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', x1);
        line.setAttribute('y1', y1);
        line.setAttribute('x2', x2);
        line.setAttribute('y2', y2);
        line.setAttribute('stroke', connection.color || '#666');
        line.setAttribute('stroke-width', '2');
        line.classList.add('thriller-connection');

        canvas.appendChild(line);
    });
}

function editThrillerElement(elementId) {
    const element = thrillerBoardState.elements.find(el => el.id === elementId);
    if (!element) return;

    const typeData = THRILLER_TYPES[element.type];

    const modal = document.createElement('div');
    modal.className = 'modal-overlay';
    modal.innerHTML = `
        <div class="modal-content" style="max-width: 700px;">
            <div class="modal-header">
                <h3>Modifier ${typeData.label}</h3>
                <button class="modal-close" onclick="this.closest('.modal-overlay').remove()">
                    <i data-lucide="x"></i>
                </button>
            </div>
            <div class="modal-body">
                <form id="thrillerElementForm" onsubmit="saveThrillerElement(event, '${elementId}')">
                    <div class="form-group">
                        <label for="elementTitle">Titre</label>
                        <input type="text" id="elementTitle" value="${element.title}" required>
                    </div>
                    <div class="form-group">
                        <label for="elementDescription">Description</label>
                        <textarea id="elementDescription" rows="4">${element.description}</textarea>
                    </div>
                    ${renderThrillerElementFields(element)}
                    <div class="form-actions">
                        <button type="button" class="btn btn-secondary" onclick="this.closest('.modal-overlay').remove()">Annuler</button>
                        <button type="submit" class="btn btn-primary">Sauvegarder</button>
                    </div>
                </form>
            </div>
        </div>
    `;

    document.body.appendChild(modal);

    setTimeout(() => {
        if (typeof lucide !== 'undefined') lucide.createIcons();
    }, 50);
}

function renderThrillerElementFields(element) {
    // Render specific fields based on element type
    switch (element.type) {
        case 'alibi':
            return `
                <div class="form-group">
                    <label for="characterId">Personnage</label>
                    <select id="characterId">
                        <option value="">Sélectionner un personnage</option>
                        ${project.characters.map(char => `<option value="${char.id}" ${element.data.character_id === char.id ? 'selected' : ''}>${char.name}</option>`).join('')}
                    </select>
                </div>
                <div class="form-group">
                    <label for="forEvent">Événement couvert</label>
                    <input type="text" id="forEvent" value="${element.data.for_event || ''}">
                </div>
                <div class="form-group">
                    <label for="claimedLocation">Lieu prétendu</label>
                    <input type="text" id="claimedLocation" value="${element.data.claimed_location || ''}">
                </div>
                <div class="form-group">
                    <label for="isTrue">Est-ce vrai ?</label>
                    <select id="isTrue">
                        <option value="true" ${element.data.is_true ? 'selected' : ''}>Vrai</option>
                        <option value="false" ${!element.data.is_true ? 'selected' : ''}>Faux</option>
                    </select>
                </div>
            `;

        case 'clue':
            return `
                <div class="form-group">
                    <label for="clueType">Type d'indice</label>
                    <select id="clueType">
                        <option value="physical" ${element.data.clue_type === 'physical' ? 'selected' : ''}>Physique</option>
                        <option value="testimonial" ${element.data.clue_type === 'testimonial' ? 'selected' : ''}>Témoignage</option>
                        <option value="circumstantial" ${element.data.clue_type === 'circumstantial' ? 'selected' : ''}>Circonstanciel</option>
                        <option value="digital" ${element.data.clue_type === 'digital' ? 'selected' : ''}>Numérique</option>
                        <option value="forensic" ${element.data.clue_type === 'forensic' ? 'selected' : ''}>Scientifique</option>
                        <option value="documentary" ${element.data.clue_type === 'documentary' ? 'selected' : ''}>Documentaire</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="isGenuine">Est authentique ?</label>
                    <select id="isGenuine">
                        <option value="true" ${element.data.is_genuine !== false ? 'selected' : ''}>Oui</option>
                        <option value="false" ${element.data.is_genuine === false ? 'selected' : ''}>Non (fabriqué)</option>
                    </select>
                </div>
            `;

        case 'secret':
            return `
                <div class="form-group">
                    <label for="holderCharacterId">Détenteur du secret</label>
                    <select id="holderCharacterId">
                        <option value="">Sélectionner un personnage</option>
                        ${project.characters.map(char => `<option value="${char.id}" ${element.data.holder_character_id === char.id ? 'selected' : ''}>${char.name}</option>`).join('')}
                    </select>
                </div>
                <div class="form-group">
                    <label for="aboutCharacterId">Secret concernant</label>
                    <select id="aboutCharacterId">
                        <option value="">Sélectionner un personnage</option>
                        ${project.characters.map(char => `<option value="${char.id}" ${element.data.about_character_id === char.id ? 'selected' : ''}>${char.name}</option>`).join('')}
                    </select>
                </div>
                <div class="form-group">
                    <label for="secretType">Type de secret</label>
                    <select id="secretType">
                        <option value="identity" ${element.data.secret_type === 'identity' ? 'selected' : ''}>Identité</option>
                        <option value="crime" ${element.data.secret_type === 'crime' ? 'selected' : ''}>Crime</option>
                        <option value="relationship" ${element.data.secret_type === 'relationship' ? 'selected' : ''}>Relation</option>
                        <option value="past" ${element.data.secret_type === 'past' ? 'selected' : ''}>Passé</option>
                        <option value="ability" ${element.data.secret_type === 'ability' ? 'selected' : ''}>Capacité</option>
                    </select>
                </div>
            `;

        default:
            return '';
    }
}

function saveThrillerElement(event, elementId) {
    event.preventDefault();

    const element = thrillerBoardState.elements.find(el => el.id === elementId);
    if (!element) return;

    element.title = document.getElementById('elementTitle').value;
    element.description = document.getElementById('elementDescription').value;
    element.updatedAt = new Date().toISOString();

    // Save type-specific data
    switch (element.type) {
        case 'alibi':
            element.data = {
                character_id: document.getElementById('characterId').value,
                for_event: document.getElementById('forEvent').value,
                claimed_location: document.getElementById('claimedLocation').value,
                is_true: document.getElementById('isTrue').value === 'true'
            };
            break;
        case 'clue':
            element.data = {
                clue_type: document.getElementById('clueType').value,
                is_genuine: document.getElementById('isGenuine').value === 'true'
            };
            break;
        case 'secret':
            element.data = {
                holder_character_id: document.getElementById('holderCharacterId').value,
                about_character_id: document.getElementById('aboutCharacterId').value,
                secret_type: document.getElementById('secretType').value
            };
            break;
    }

    project.thrillerElements = thrillerBoardState.elements;
    renderThrillerElements();
    saveProject();

    event.target.closest('.modal-overlay').remove();
}

function deleteThrillerElement(elementId) {
    if (!confirm('Êtes-vous sûr de vouloir supprimer cet élément ?')) return;

    thrillerBoardState.elements = thrillerBoardState.elements.filter(el => el.id !== elementId);
    thrillerBoardState.connections = thrillerBoardState.connections.filter(conn =>
        conn.from !== elementId && conn.to !== elementId
    );

    project.thrillerElements = thrillerBoardState.elements;
    project.thrillerConnections = thrillerBoardState.connections;

    renderThrillerElements();
    saveProject();
}

function filterThrillerElements(filterType) {
    thrillerBoardState.currentFilter = filterType;
    renderThrillerElements();
}

// ============================================
// CANVAS INTERACTION
// ============================================

function handleThrillerCanvasMouseDown(event) {
    // Handle canvas panning and element interactions
    // Implementation similar to arc-board
}

function handleThrillerCanvasMouseMove(event) {
    // Handle dragging elements
}

function handleThrillerCanvasMouseUp(event) {
    // Handle mouse up events
}

function handleThrillerCanvasWheel(event) {
    // Handle zooming
}

// ============================================
// CONTEXT PANEL
// ============================================

function updateThrillerContextPanel() {
    const content = document.getElementById('thrillerContextContent');
    if (!content) return;

    const elementCounts = {};
    thrillerBoardState.elements.forEach(element => {
        elementCounts[element.type] = (elementCounts[element.type] || 0) + 1;
    });

    content.innerHTML = `
        <div class="thriller-stats">
            <h4>Éléments (${thrillerBoardState.elements.length})</h4>
            ${Object.entries(THRILLER_TYPES).map(([key, type]) => `
                <div class="thriller-stat-item">
                    <span class="thriller-stat-icon" style="color: ${type.color}">
                        <i data-lucide="${type.icon}"></i>
                    </span>
                    <span class="thriller-stat-label">${type.label}</span>
                    <span class="thriller-stat-count">${elementCounts[key] || 0}</span>
                </div>
            `).join('')}
        </div>
        <div class="thriller-recent">
            <h4>Éléments récents</h4>
            ${thrillerBoardState.elements.slice(-5).reverse().map(element => {
                const typeData = THRILLER_TYPES[element.type];
                return `
                    <div class="thriller-recent-item" onclick="editThrillerElement('${element.id}')">
                        <span class="thriller-recent-icon" style="color: ${element.color}">
                            <i data-lucide="${typeData.icon}"></i>
                        </span>
                        <span class="thriller-recent-title">${element.title}</span>
                    </div>
                `;
            }).join('')}
        </div>
    `;

    setTimeout(() => {
        if (typeof lucide !== 'undefined') lucide.createIcons();
    }, 50);
}

function toggleThrillerContextPanel() {
    thrillerBoardState.contextPanelOpen = !thrillerBoardState.contextPanelOpen;
    const panel = document.getElementById('thrillerContextPanel');
    if (panel) {
        panel.classList.toggle('collapsed', !thrillerBoardState.contextPanelOpen);
    }
}

// ============================================
// ZOOM AND NAVIGATION
// ============================================

function zoomThrillerBoard(direction) {
    const newZoom = Math.max(THRILLER_BOARD_CONFIG.minZoom,
        Math.min(THRILLER_BOARD_CONFIG.maxZoom, thrillerBoardState.zoom + direction * THRILLER_BOARD_CONFIG.zoomStep));

    thrillerBoardState.zoom = newZoom;
    updateThrillerZoomDisplay();

    const canvas = document.getElementById('thrillerBoardCanvas');
    if (canvas) {
        canvas.style.transform = `scale(${newZoom})`;
    }
}

function updateThrillerZoomDisplay() {
    const zoomDisplay = document.getElementById('thrillerZoomLevel');
    if (zoomDisplay) {
        zoomDisplay.textContent = `${Math.round(thrillerBoardState.zoom * 100)}%`;
    }
}

function fitThrillerBoardToScreen() {
    // Implementation to fit all elements in view
    thrillerBoardState.zoom = 1;
    thrillerBoardState.canvasOffset = { x: 0, y: 0 };
    updateThrillerZoomDisplay();

    const canvas = document.getElementById('thrillerBoardCanvas');
    if (canvas) {
        canvas.style.transform = 'scale(1) translate(0, 0)';
    }
}

// ============================================
// UTILITY FUNCTIONS
// ============================================

function selectThrillerElement(elementId) {
    // Handle element selection
    thrillerBoardState.selectedElements = [elementId];
    // Update visual selection
}

function generateId() {
    return 'thriller_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
}

    </script>

        <!-- Arc Scene Panel -->
        <div id="arcScenePanel" class="arc-scene-panel hidden">
            <div class="arc-scene-panel-header">
                <h3>Arcs dans cette scène</h3>
                <button class="arc-panel-close" onclick="toggleArcScenePanel()">✕</button>
            </div>
            <div id="arcScenePanelContent" class="arc-scene-panel-content">
                <!-- Contenu dynamique -->
            </div>
        </div>

    </body>
</html>
